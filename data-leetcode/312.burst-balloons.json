[
    {
        "title": "Integer to Roman",
        "question_content": "Roman numerals are represented by seven different symbols:&nbsp;I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,&nbsp;2 is written as II&nbsp;in Roman numeral, just two one's added together. 12 is written as&nbsp;XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n\tI can be placed before V (5) and X (10) to make 4 and 9.&nbsp;\n\tX can be placed before L (50) and C (100) to make 40 and 90.&nbsp;\n\tC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n&nbsp;\nExample 1:\n\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\n\nExample 2:\n\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n\nExample 3:\n\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= num <= 3999",
        "solutions": [
            {
                "id": 6274,
                "title": "simple-solution",
                "content": "```\\npublic static String intToRoman(int num) {\\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static String intToRoman(int num) {\\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6310,
                "title": "my-java-solution-easy-to-understand",
                "content": "Reference:\\nhttp://blog.csdn.net/beiyeqingteng/article/details/8547565\\n\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        \\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] strs = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<values.length;i++) {\\n            while(num >= values[i]) {\\n                num -= values[i];\\n                sb.append(strs[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 1293176,
                "title": "c-easy-solution-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962674,
                "title": "easiest-o-1-faang-method-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n# ***Please Upvote if it helps \\u2764\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6382,
                "title": "my-simple-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        string intToRoman(int num) \\n        {\\n            string res;\\n            string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n            int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n            \\n            for(int i=0; num != 0; i++)\\n            {\\n                while(num >= val[i])\\n                {\\n                    num -= val[i];\\n                    res += sym[i];\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string intToRoman(int num) \\n        {\\n            string res;\\n            string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}",
                "codeTag": "Java"
            },
            {
                "id": 6304,
                "title": "python-simple-solution",
                "content": "        \\n    def intToRoman1(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res, i = \"\", 0\\n        while num:\\n            res += (num//values[i]) * numerals[i]\\n            num %= values[i]\\n            i += 1\\n        return res\\n        \\n    def intToRoman(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res = \"\"\\n        for i, v in enumerate(values):\\n            res += (num//v) * numerals[i]\\n            num %= v\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def intToRoman1(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res, i = \"\", 0\\n        while num:\\n            res += (num//values[i]) * numerals[i]\\n            num %= values[i]\\n            i += 1\\n        return res\\n        \\n    def intToRoman(self, num):\\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        res = \"\"\\n        for i, v in enumerate(values):\\n            res += (num//v) * numerals[i]\\n            num %= v\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3216797,
                "title": "easiest-beginner-friendly-sol-c-java-python",
                "content": "# Intuition of this Problem:\\nThis code takes a non-negative integer as input and converts it into its corresponding Roman numeral representation. The approach used here is to store the Roman numeral values and their corresponding symbols in a vector of pairs. The algorithm then iterates through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty string called Roman to store the resulting Roman numeral.\\n2. Create a vector of pairs called storeIntRoman, to store the Roman numeral values and their corresponding symbols.\\n3. Iterate through the storeIntRoman vector using a for loop.\\n4. For each pair, check if the input integer is greater than or equal to the Roman numeral value.\\n5. If it is, add the corresponding symbol to the Roman string and subtract the corresponding value from the input integer.\\n6. Repeat steps 4-5 until the input integer becomes zero.\\n7. Return the Roman string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Approach 1 : \\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string Roman = \"\";\\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n        for (int i = 0; i < storeIntRoman.size(); i++) {\\n            while (num >= storeIntRoman[i].first) {\\n                Roman += storeIntRoman[i].second;\\n                num -= storeIntRoman[i].first;\\n            }\\n        }\\n        return Roman;\\n    }\\n};\\n```\\n```C++ []\\n//Approach 2\\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        string tens[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        string hundreds[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        string thousands[]= {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string Roman =  thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n        return Roman;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String Roman = \"\";\\n        int[][] storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        for (int i = 0; i < storeIntRoman.length; i++) {\\n            while (num >= storeIntRoman[i][0]) {\\n                Roman += storeIntRoman[i][1];\\n                num -= storeIntRoman[i][0];\\n            }\\n        }\\n        return Roman;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(13) = O(1)** - Approach 1\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(13) = O(1)** - Approach 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```C++ []\\n//Approach 1 : \\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string Roman = \"\";\\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\\n        for (int i = 0; i < storeIntRoman.size(); i++) {\\n            while (num >= storeIntRoman[i].first) {\\n                Roman += storeIntRoman[i].second;\\n                num -= storeIntRoman[i].first;\\n            }\\n        }\\n        return Roman;\\n    }\\n};\\n```\n```C++ []\\n//Approach 2\\n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        string tens[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        string hundreds[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        string thousands[]= {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string Roman =  thousands[num / 1000] + hundreds[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n        return Roman;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String Roman = \"\";\\n        int[][] storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        for (int i = 0; i < storeIntRoman.length; i++) {\\n            while (num >= storeIntRoman[i][0]) {\\n                Roman += storeIntRoman[i][1];\\n                num -= storeIntRoman[i][0];\\n            }\\n        }\\n        return Roman;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        Roman = \"\"\\n        storeIntRoman = [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100, \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\\n        for i in range(len(storeIntRoman)):\\n            while num >= storeIntRoman[i][0]:\\n                Roman += storeIntRoman[i][1]\\n                num -= storeIntRoman[i][0]\\n        return Roman\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102775,
                "title": "js-python-java-c-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nJust like Roman to Integer, this problem is most easily solved using a **lookup table** for the conversion between digit and numeral. In this case, we can easily deal with the values in descending order and insert the appropriate numeral (or numerals) as many times as we can while reducing the our target number (**N**) by the same amount.\\n\\nOnce **N** runs out, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava\\'s **StringBuilder** can take care of repeated string concatenations without some of the overhead of making string copies.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **124ms / 43.5MB** (beats 100% / 100%).\\n```javascript\\nconst val = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nconst rom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nvar intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.1MB** (beats 95% / 86%).\\n```python\\nval = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nrom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nclass Solution:\\n    def intToRoman(self, N: int) -> str:\\n        ans = \"\"\\n        for i in range(13):\\n            while N >= val[i]:\\n                ans += rom[i]\\n                N -= val[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 38.1MB** (beats 100% / 95%).\\n```java\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 98%).\\n```c++\\nclass Solution {\\npublic:\\n    const int val[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    const string rom[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    string intToRoman(int N) {\\n        string ans = \"\";\\n        for (int i = 0; N; i++)\\n            while (N >= val[i]) ans += rom[i], N -= val[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst val = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nconst rom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nvar intToRoman = function(N) {\\n    let ans = \"\"\\n    for (let i = 0; N; i++)\\n        while (N >= val[i]) ans += rom[i], N -= val[i]\\n    return ans\\n};\\n```\n```python\\nval = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\nrom = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n\\nclass Solution:\\n    def intToRoman(self, N: int) -> str:\\n        ans = \"\"\\n        for i in range(13):\\n            while N >= val[i]:\\n                ans += rom[i]\\n                N -= val[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    const int val[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    const string rom[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    string intToRoman(int N) {\\n        string ans = \"\";\\n        for (int i = 0; N; i++)\\n            while (N >= val[i]) ans += rom[i], N -= val[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724200,
                "title": "python-s-simple-and-easy-to-understand-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        # Creating Dictionary for Lookup\\n        num_map = {\\n            1: \"I\",\\n            5: \"V\",    4: \"IV\",\\n            10: \"X\",   9: \"IX\",\\n            50: \"L\",   40: \"XL\",\\n            100: \"C\",  90: \"XC\",\\n            500: \"D\",  400: \"CD\",\\n            1000: \"M\", 900: \"CM\",\\n        }\\n        \\n        # Result Variable\\n        r = \\'\\'\\n        \\n        \\n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\\n            # If n in list then add the roman value to result variable\\n            while n <= num:\\n                r += num_map[n]\\n                num-=n\\n        return r\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        # Creating Dictionary for Lookup\\n        num_map = {\\n            1: \"I\",\\n            5: \"V\",    4: \"IV\",\\n            10: \"X\",   9: \"IX\",\\n            50: \"L\",   40: \"XL\",\\n            100: \"C\",  90: \"XC\",\\n            500: \"D\",  400: \"CD\",\\n            1000: \"M\", 900: \"CM\",\\n        }\\n        \\n        # Result Variable\\n        r = \\'\\'\\n        \\n        \\n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\\n            # If n in list then add the roman value to result variable\\n            while n <= num:\\n                r += num_map[n]\\n                num-=n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723774,
                "title": "c-simple-and-easy-solution",
                "content": "**Please connect with me if u like my solution**\\n**Please Upvote**\\nhttps://www.linkedin.com/in/shubham-roy-0b71a0220/\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                res.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                res.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6273,
                "title": "share-my-python-solution-96ms",
                "content": "    M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];",
                "solutionTags": [
                    "Python"
                ],
                "code": "    M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];",
                "codeTag": "Unknown"
            },
            {
                "id": 292605,
                "title": "python-solution-44ms",
                "content": "if this helps, please upvote! Thanks!\\n\\n```class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        res = \\'\\'\\n        for k in d:\\n            while num >= k:\\n                res += d[k]\\n                num -= k\\n        return res\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}",
                "codeTag": "Java"
            },
            {
                "id": 6361,
                "title": "a-simple-python-code-easy-to-understand",
                "content": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        dict = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n        result = \"\"\\n        for letter, n in zip(dict, nums):\\n            result += letter * int(num / n)\\n            num %= n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        dict = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\\n        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n        result = \"\"\\n        for letter, n in zip(dict, nums):\\n            result += letter * int(num / n)\\n            num %= n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462641,
                "title": "python-pythonic-simple-solution-88-9-100-0",
                "content": "If you like, please upvote!\\n```\\ndef intToRoman(num: int):\\n    roman = {\\n        1000: \\'M\\',\\n        900: \\'CM\\',\\n        500: \\'D\\',\\n        400: \\'CD\\',\\n        100: \\'C\\',\\n        90: \\'XC\\',\\n        50: \\'L\\',\\n        40: \\'XL\\',\\n        10: \\'X\\',\\n        9: \\'IX\\',\\n        5: \\'V\\',\\n        4: \\'IV\\',\\n        1: \\'I\\'\\n        }\\n    romanized = \\'\\'\\n\\n    for base, symb in roman.items():\\n        romanized += symb * (num // base)\\n        num %= base\\n    else:\\n        return romanized\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef intToRoman(num: int):\\n    roman = {\\n        1000: \\'M\\',\\n        900: \\'CM\\',\\n        500: \\'D\\',\\n        400: \\'CD\\',\\n        100: \\'C\\',\\n        90: \\'XC\\',\\n        50: \\'L\\',\\n        40: \\'XL\\',\\n        10: \\'X\\',\\n        9: \\'IX\\',\\n        5: \\'V\\',\\n        4: \\'IV\\',\\n        1: \\'I\\'\\n        }\\n    romanized = \\'\\'\\n\\n    for base, symb in roman.items():\\n        romanized += symb * (num // base)\\n        num %= base\\n    else:\\n        return romanized\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6376,
                "title": "simple-java-solution",
                "content": "    public String intToRoman(int num) {\\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String intToRoman(int num) {\\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6489,
                "title": "sharing-my-really-simple-solution-with-explanation",
                "content": "    string intToRoman(int num) {\\n        string table[4][10] = {{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                               {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                               {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                               {\"\", \"M\", \"MM\", \"MMM\"}\\n                              };\\n        string result;\\n        int count = 0;\\n        while(num > 0){\\n            int temp = num % 10;\\n            result = table[count][temp] + result;\\n            num /= 10;\\n            count++;\\n        }\\n        return result;\\n    }\\n\\nThe basic idea is really simple: replace every digit in num by roman numerals.\\n\\nFor example, we have a num: 2438.\\n\\n2 --> \"MM\"\\n\\n4 --> \"CD\"\\n\\n3 --> \"XXX\"\\n\\n8 --> \"VIII\"\\n\\nThen the result is \"MMCDXXXVIII\".",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    string intToRoman(int num) {\\n        string table[4][10] = {{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                               {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                               {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                               {\"\", \"M\", \"MM\", \"MMM\"}\\n                              };\\n        string result;\\n        int count = 0;\\n        while(num > 0){\\n            int temp = num % 10;\\n            result = table[count][temp] + result;\\n            num /= 10;\\n            count++;\\n        }\\n        return result;\\n    }\\n\\nThe basic idea is really simple: replace every digit in num by roman numerals.\\n\\nFor example, we have a num: 2438.\\n\\n2 --> \"MM\"\\n\\n4 --> \"CD\"\\n\\n3 --> \"XXX\"\\n\\n8 --> \"VIII\"\\n\\nThen the result is \"MMCDXXXVIII\".",
                "codeTag": "Unknown"
            },
            {
                "id": 1144148,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    \\n    private let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    private let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\\n    \\n    func intToRoman(_ num: Int) -> String {\\n        \\n        var int = num\\n        var sym = \"\"\\n        \\n        while int > 0 {\\n            for (i, d) in values.enumerated() where int - d >= 0 {\\n                int -= d\\n                sym += symbols[i]\\n                break\\n            }\\n        }\\n        return sym\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.013 (0.015) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 3 is represented as 3 ones.\\n    func test0() {\\n        let value = solution.intToRoman(3)\\n        XCTAssertEqual(value, \"III\")\\n    }\\n    \\n    // L = 50, V = 5, III = 3.\\n    func test1() {\\n        let value = solution.intToRoman(58)\\n        XCTAssertEqual(value, \"LVIII\")\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4.\\n    func test2() {\\n        let value = solution.intToRoman(1994)\\n        XCTAssertEqual(value, \"MCMXCIV\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    \\n    private let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    private let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\\n    \\n    func intToRoman(_ num: Int) -> String {\\n        \\n        var int = num\\n        var sym = \"\"\\n        \\n        while int > 0 {\\n            for (i, d) in values.enumerated() where int - d >= 0 {\\n                int -= d\\n                sym += symbols[i]\\n                break\\n            }\\n        }\\n        return sym\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 3 is represented as 3 ones.\\n    func test0() {\\n        let value = solution.intToRoman(3)\\n        XCTAssertEqual(value, \"III\")\\n    }\\n    \\n    // L = 50, V = 5, III = 3.\\n    func test1() {\\n        let value = solution.intToRoman(58)\\n        XCTAssertEqual(value, \"LVIII\")\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4.\\n    func test2() {\\n        let value = solution.intToRoman(1994)\\n        XCTAssertEqual(value, \"MCMXCIV\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401764,
                "title": "clean-javascript-solution-using-map",
                "content": "Here\\'s clean javascript solution:\\n\\nFirst version using ```forEach```:\\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    let result = \\'\\';\\n    Object.entries(map).forEach(([letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n    });\\n    return result;\\n}\\n```\\n\\nSecond version with ```reduce```:\\n\\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    return Object.entries(map).reduce((result, [letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n        return result;\\n    }, \\'\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```forEach```\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    let result = \\'\\';\\n    Object.entries(map).forEach(([letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n    });\\n    return result;\\n}\\n```\n```reduce```\n```\\nfunction intToRoman(num) {\\n    const map = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };\\n    return Object.entries(map).reduce((result, [letter, n]) => {\\n        result += letter.repeat(Math.floor(num / n));\\n        num %= n;\\n        return result;\\n    }, \\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6309,
                "title": "more-generalizable-solution-can-be-extended-to-any-roman-to-integer-conversion",
                "content": "This solution includes generalizability. Even if the number to be converted is > 3999, it works without making extra effort for finding cases.\\n```\\nbool isMul(int n) {\\n        return (n + 1) % 5 == 0;\\n    }\\n    int getMult(const int & n) {\\n        if(n / 1000 > 0) return 1000;\\n        if(n / 100 > 0) return 100;\\n        if(n / 10 > 0) return 10;\\n        return 1;\\n    }\\n    string subProb(int &num) {\\n        map<int,string> val;\\n        val[1] = \"I\";\\n        val[5] = \"V\";\\n        val[10] = \"X\";\\n        val[50] = \"L\";\\n        val[100] = \"C\";\\n        val[500] = \"D\";\\n        val[1000] = \"M\";\\n        int multiple = getMult(num);\\n        string ans = \"\";\\n        int value = num / multiple;\\n        if(value == 4) ans += (val[multiple] + val[5 * multiple]), value -=4;\\n        else if(value == 9) ans += (val[multiple] + val[10 * multiple]), value -=9;\\n        else if(value >= 5) {\\n            ans += val[5 * multiple];\\n            value -= 5;\\n        }\\n        for(int i = 0; i < value; i ++) ans += val[multiple];\\n        num %= multiple;\\n        return ans;\\n    }\\n    string intToRoman(int num) {\\n        string ans = \"\";\\n        while(num > 0) ans += subProb(num);\\n        return ans;\\n        \\n    }\\n```\\n\\nHope you like the solution",
                "solutionTags": [],
                "code": "```\\nbool isMul(int n) {\\n        return (n + 1) % 5 == 0;\\n    }\\n    int getMult(const int & n) {\\n        if(n / 1000 > 0) return 1000;\\n        if(n / 100 > 0) return 100;\\n        if(n / 10 > 0) return 10;\\n        return 1;\\n    }\\n    string subProb(int &num) {\\n        map<int,string> val;\\n        val[1] = \"I\";\\n        val[5] = \"V\";\\n        val[10] = \"X\";\\n        val[50] = \"L\";\\n        val[100] = \"C\";\\n        val[500] = \"D\";\\n        val[1000] = \"M\";\\n        int multiple = getMult(num);\\n        string ans = \"\";\\n        int value = num / multiple;\\n        if(value == 4) ans += (val[multiple] + val[5 * multiple]), value -=4;\\n        else if(value == 9) ans += (val[multiple] + val[10 * multiple]), value -=9;\\n        else if(value >= 5) {\\n            ans += val[5 * multiple];\\n            value -= 5;\\n        }\\n        for(int i = 0; i < value; i ++) ans += val[multiple];\\n        num %= multiple;\\n        return ans;\\n    }\\n    string intToRoman(int num) {\\n        string ans = \"\";\\n        while(num > 0) ans += subProb(num);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6281,
                "title": "two-lines-can-do-the-job",
                "content": "String[] romanPieces={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\\n\\t\\t\\t\\t\\t\\t\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\\n\\t\\t\\t\\t\\t\\t\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\\n\\t\\t\\t\\t\\t\\t\"\",\"M\",\"MM\",\"MMM\",\"MMMM\"};\\nreturn romanPieces[num/1000+30]+romanPieces[(num/100)%10+20]\\n\\t\\t\\t\\t\\t+romanPieces[(num/10)%10+10]+romanPieces[num%10];",
                "solutionTags": [],
                "code": "String[] romanPieces={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\\n\\t\\t\\t\\t\\t\\t\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\\n\\t\\t\\t\\t\\t\\t\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\\n\\t\\t\\t\\t\\t\\t\"\",\"M\",\"MM\",\"MMM\",\"MMMM\"};\\nreturn romanPieces[num/1000+30]+romanPieces[(num/100)%10+20]\\n\\t\\t\\t\\t\\t+romanPieces[(num/10)%10+10]+romanPieces[num%10];",
                "codeTag": "Unknown"
            },
            {
                "id": 6432,
                "title": "easy-to-understand-java-solution",
                "content": "public class Solution {\\n\\n    public enum Type{\\n        M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);\\n        private final int value;\\n        Type(int value) {\\n            this.value = value;\\n        }\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder output = new StringBuilder();\\n        for (Type t:Type.values()) {\\n            while (num>=t.value) {\\n                output.append(t);\\n                num -= t.value;\\n            }\\n        }\\n        return output.toString();\\n    }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public enum Type{\\n        M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);\\n        private final int value;\\n        Type(int value) {\\n            this.value = value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512574,
                "title": "c-java-python-javascript-5-lines-of-code-100-simple-solution",
                "content": "# Intuition:\\nThe given problem is about converting an integer into a Roman numeral. To do this, we can create arrays that represent the Roman numeral symbols for each place value (ones, tens, hundreds, thousands). Then, we can divide the given number into its respective place values and concatenate the corresponding Roman numeral symbols.\\n\\n# Approach:\\n1. Create four arrays: `ones`, `tens`, `hrns`, and `ths`, representing the Roman numeral symbols for ones, tens, hundreds, and thousands respectively. Each array contains the symbols for the numbers from 0 to 9 in their respective place value.\\n2. Divide the given number `num` into its respective place values:\\n   - `thousands = num / 1000`\\n   - `hundreds = (num % 1000) / 100`\\n   - `tens = (num % 100) / 10`\\n   - `ones = num % 10`\\n3. Concatenate the Roman numeral symbols based on the place values:\\n   - `ths[num/1000]` represents the Roman numeral for thousands place.\\n   - `hrns[(num%1000)/100]` represents the Roman numeral for hundreds place.\\n   - `tens[(num%100)/10]` represents the Roman numeral for tens place.\\n   - `ones[num%10]` represents the Roman numeral for ones place.\\n4. Return the concatenation of the Roman numeral symbols obtained from step 3.\\n\\n# Complexity:\\n- Time complexity: O(1) because the number of digits in the given number is constant (up to 4 digits for the given range).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) because the arrays storing the Roman numeral values have fixed sizes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String[] hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String[] ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};\\n```\\n---\\n# Python\\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        ths = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String[] hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String[] ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10];\\n    }\\n}\\n\\n```\n```\\nvar intToRoman = function(num) {\\n    const ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    const tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const ths = [\"\", \"M\", \"MM\", \"MMM\"];\\n    return ths[Math.floor(num / 1000)] + hrns[Math.floor((num % 1000) / 100)] + tens[Math.floor((num % 100) / 10)] + ones[num % 10];\\n};\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        hrns = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        ths = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        return ths[num / 1000] + hrns[(num % 1000) / 100] + tens[(num % 100) / 10] + ones[num % 10]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422472,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int intCode[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string code[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        string s;\\n        for(int i=0; i<13; ++i){\\n            while(num>=intCode[i]){\\n                s.append(code[i]);\\n                num-=intCode[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int intCode[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string code[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        string s;\\n        for(int i=0; i<13; ++i){\\n            while(num>=intCode[i]){\\n                s.append(code[i]);\\n                num-=intCode[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723782,
                "title": "java-explained-in-detail-simple-fast-solution-dictionary",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n#### Java - Using Dictionary - Approach 1\\n\\n```\\npublic String intToRoman(int num) {\\n\\n        // Approach:\\n        // This method uses two arrays with the corresponding integer-roman map, in descending order.\\n\\n        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder romanNumeral = new StringBuilder();\\n\\n        for (int i = 0; i < value.length && num > 0; i++) {\\n            // Check from the highest value, 1000 to the smallest.\\n            // If it is possible to subtract, for example 400, we know the roman numeral next is \"CD\".\\n            while (num >= value[i]) {\\n                romanNumeral.append(roman[i]);\\n                num -= value[i];\\n            }\\n        }\\n        return romanNumeral.toString();\\n    }\\n```\\n---\\n\\n#### Java - Without Dictionary - Approach 2\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String romanNumeral = \"\";\\n        while (num >= 1000) {\\n            romanNumeral += \"M\";\\n            num -= 1000;\\n        }\\n        while (num >= 900) {\\n            romanNumeral += \"CM\";\\n            num -= 900;\\n        }\\n        while (num >= 500) {\\n            romanNumeral += \"D\";\\n            num -= 500;\\n        }\\n        while (num >= 400) {\\n            romanNumeral += \"CD\";\\n            num -= 400;\\n        }\\n        while (num >= 100) {\\n            romanNumeral += \"C\";\\n            num -= 100;\\n        }\\n        while (num >= 90) {\\n            romanNumeral += \"XC\";\\n            num -= 90;\\n        }\\n        while (num >= 50) {\\n            romanNumeral += \"L\";\\n            num -= 50;\\n        }\\n        while (num >= 40) {\\n            romanNumeral += \"XL\";\\n            num -= 40;\\n        }\\n        while (num >= 10) {\\n            romanNumeral += \"X\";\\n            num -= 10;\\n        }\\n        while (num >= 9) {\\n            romanNumeral += \"IX\";\\n            num -= 9;\\n        }\\n        while (num >= 5) {\\n            romanNumeral += \"V\";\\n            num -= 5;\\n        }\\n        while (num >= 4) {\\n            romanNumeral += \"IV\";\\n            num -= 4;\\n        }\\n        while (num >= 1) {\\n            romanNumeral += \"I\";\\n            num -= 1;\\n        }\\n\\n        return romanNumeral;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String intToRoman(int num) {\\n\\n        // Approach:\\n        // This method uses two arrays with the corresponding integer-roman map, in descending order.\\n\\n        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder romanNumeral = new StringBuilder();\\n\\n        for (int i = 0; i < value.length && num > 0; i++) {\\n            // Check from the highest value, 1000 to the smallest.\\n            // If it is possible to subtract, for example 400, we know the roman numeral next is \"CD\".\\n            while (num >= value[i]) {\\n                romanNumeral.append(roman[i]);\\n                num -= value[i];\\n            }\\n        }\\n        return romanNumeral.toString();\\n    }\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String romanNumeral = \"\";\\n        while (num >= 1000) {\\n            romanNumeral += \"M\";\\n            num -= 1000;\\n        }\\n        while (num >= 900) {\\n            romanNumeral += \"CM\";\\n            num -= 900;\\n        }\\n        while (num >= 500) {\\n            romanNumeral += \"D\";\\n            num -= 500;\\n        }\\n        while (num >= 400) {\\n            romanNumeral += \"CD\";\\n            num -= 400;\\n        }\\n        while (num >= 100) {\\n            romanNumeral += \"C\";\\n            num -= 100;\\n        }\\n        while (num >= 90) {\\n            romanNumeral += \"XC\";\\n            num -= 90;\\n        }\\n        while (num >= 50) {\\n            romanNumeral += \"L\";\\n            num -= 50;\\n        }\\n        while (num >= 40) {\\n            romanNumeral += \"XL\";\\n            num -= 40;\\n        }\\n        while (num >= 10) {\\n            romanNumeral += \"X\";\\n            num -= 10;\\n        }\\n        while (num >= 9) {\\n            romanNumeral += \"IX\";\\n            num -= 9;\\n        }\\n        while (num >= 5) {\\n            romanNumeral += \"V\";\\n            num -= 5;\\n        }\\n        while (num >= 4) {\\n            romanNumeral += \"IV\";\\n            num -= 4;\\n        }\\n        while (num >= 1) {\\n            romanNumeral += \"I\";\\n            num -= 1;\\n        }\\n\\n        return romanNumeral;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975240,
                "title": "java-runtime-3ms-beats-98-91-o-1",
                "content": "# Intuition\\nMy initial approach to solving this problem involves converting an integer to its Roman numeral representation using a predefined set of values and corresponding Roman numeral symbols.\\n\\n# Approach\\nTo achieve this, I utilize a greedy approach where I repeatedly subtract the largest possible value from the given number while appending the corresponding Roman numeral symbol to the result string. I maintain two arrays: `values`, which contains the integer values corresponding to Roman numerals, and `romanNumerals`, which contains the corresponding Roman numeral symbols.\\n\\nStarting with the largest value, I iterate through the `values` array and at each step, I check if the current value can be subtracted from the given number. If it can be, I append the corresponding Roman numeral symbol to the result string and subtract the value from the number. If not, I move on to the next smaller value.\\n\\nI continue this process until the given number becomes zero, and the result string represents the Roman numeral equivalent of the original number.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  The algorithm performs a constant number of operations regardless of the magnitude of the input number. The iteration through the `values` array and the subsequent calculations are independent of the value of the input.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a fixed amount of additional memory space for variables and arrays, leading to a constant space complexity.\\n\\n# Code\\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n     \\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] romanNumerals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n    \\n        while (num > 0) {\\n            if (num >= values[i]) {\\n                \\n                sb.append(romanNumerals[i]);\\n                num -= values[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n     \\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] romanNumerals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n    \\n        while (num > 0) {\\n            if (num >= values[i]) {\\n                \\n                sb.append(romanNumerals[i]);\\n                num -= values[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421938,
                "title": "awesome-python-solution",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        return M[num//1000]+C[num%1000//100]+X[num%1000%100//10]+I[num%1000%100%10]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        return M[num//1000]+C[num%1000//100]+X[num%1000%100//10]+I[num%1000%100%10]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531193,
                "title": "python-solution-without-big-table",
                "content": "I think my solution is good in terms of scalability -- No need to create big table :)\\n\\n``` python\\ndef intToRoman(self, num: int) -> str:\\n\\tones = [\\'I\\', \\'X\\', \\'C\\', \\'M\\']\\n\\tfives = [\\'V\\', \\'L\\', \\'D\\']\\n\\ti = 0\\n\\tans = []\\n\\n\\twhile num > 0:\\n\\t\\tn = num % 10\\n\\t\\tif 1 <= n <= 3:\\n\\t\\t\\tans.append(ones[i] * n) \\n\\t\\telif n == 4:\\n\\t\\t\\tans.append(ones[i] + fives[i])\\n\\t\\telif 5 <= n <= 8:\\n\\t\\t\\tans.append(fives[i] + ones[i] * (n - 5))\\n\\t\\telif n == 9:\\n\\t\\t\\tans.append(ones[i] + ones[i+1])\\n\\n\\t\\ti += 1\\n\\t\\tnum //= 10\\n\\n\\treturn \"\".join(ans[::-1])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I think my solution is good in terms of scalability -- No need to create big table :)\\n\\n``` python\\ndef intToRoman(self, num: int) -> str:\\n\\tones = [\\'I\\', \\'X\\', \\'C\\', \\'M\\']\\n\\tfives = [\\'V\\', \\'L\\', \\'D\\']\\n\\ti = 0\\n\\tans = []\\n\\n\\twhile num > 0:\\n\\t\\tn = num % 10\\n\\t\\tif 1 <= n <= 3:\\n\\t\\t\\tans.append(ones[i] * n) \\n\\t\\telif n == 4:\\n\\t\\t\\tans.append(ones[i] + fives[i])\\n\\t\\telif 5 <= n <= 8:\\n\\t\\t\\tans.append(fives[i] + ones[i] * (n - 5))\\n\\t\\telif n == 9:\\n\\t\\t\\tans.append(ones[i] + ones[i+1])\\n\\n\\t\\ti += 1\\n\\t\\tnum //= 10\\n\\n\\treturn \"\".join(ans[::-1])",
                "codeTag": "Python3"
            },
            {
                "id": 1102673,
                "title": "python-short-solution-explained",
                "content": "Let us look at Roman representation digit by digit and see how it works.\\nFor last digit we can have \\n`\" \", I, II, III, IV, V, VI, VII, VIII, IX`\\nFor next digit we can have \\n`\" \", X, XX, XXX, XL, L, LX, LXX, LXXX, XC`\\nand so on.\\n\\nNotice, that we have exactly the same pattern here, but instead of `I, V, X`, we have `X, L, C` symbols. Let us use this idea and function `digit` to construct our number. We find last digit of integer representation of our number, create corresponding roman part and add it to the beginning of our answer.\\n\\n**Complexity**: time complexity is just `O(1)`, because length is restricted by `15`. Space complexity is `O(1)` as well.\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num):\\n        def digit(a,b,c,dig):\\n            return [\"\",a,2*a,3*a,a+b,b,b+a,b+2*a,b+3*a,a+c][dig]\\n        \\n        l = [\"I\",\"V\",\"X\",\"L\",\"C\",\"D\",\"M\",\"!\",\"!\"]\\n        out, i = \"\", 0\\n\\n        while num != 0:\\n            num, last = divmod(num, 10)\\n            out = digit(l[i], l[i+1], l[i+2], last) + out\\n            i += 2\\n        return out\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num):\\n        def digit(a,b,c,dig):\\n            return [\"\",a,2*a,3*a,a+b,b,b+a,b+2*a,b+3*a,a+c][dig]\\n        \\n        l = [\"I\",\"V\",\"X\",\"L\",\"C\",\"D\",\"M\",\"!\",\"!\"]\\n        out, i = \"\", 0\\n\\n        while num != 0:\\n            num, last = divmod(num, 10)\\n            out = digit(l[i], l[i+1], l[i+2], last) + out\\n            i += 2\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341297,
                "title": "easiest-and-fastest-0-ms-c-solution-a-little-bit-more-memory-for-simplicity",
                "content": "```\\nclass Solution {\\nprivate:\\n    const vector<pair<int, char*>> conv = {{1000, \"M\"},\\n                                            {900, \"CM\"},\\n                                            {500, \"D\"},\\n                                            {400, \"CD\"},\\n                                            {100, \"C\"},\\n                                            {90, \"XC\"},\\n                                            {50, \"L\"},\\n                                            {40, \"XL\"},\\n                                            {10, \"X\"},\\n                                            {9, \"IX\"},\\n                                            {5, \"V\"},\\n                                            {4, \"IV\"},\\n                                            {1, \"I\"}};\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        auto it = conv.begin();\\n        while (num > 0 && it != conv.end()) {\\n            if (num >= it->first) {\\n                num -= it->first;\\n                res += it->second;\\n            } else {\\n                ++it;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const vector<pair<int, char*>> conv = {{1000, \"M\"},\\n                                            {900, \"CM\"},\\n                                            {500, \"D\"},\\n                                            {400, \"CD\"},\\n                                            {100, \"C\"},\\n                                            {90, \"XC\"},\\n                                            {50, \"L\"},\\n                                            {40, \"XL\"},\\n                                            {10, \"X\"},\\n                                            {9, \"IX\"},\\n                                            {5, \"V\"},\\n                                            {4, \"IV\"},\\n                                            {1, \"I\"}};\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        auto it = conv.begin();\\n        while (num > 0 && it != conv.end()) {\\n            if (num >= it->first) {\\n                num -= it->first;\\n                res += it->second;\\n            } else {\\n                ++it;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057323,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    final static int[] val = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n    final static String[] rom = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\n    public String intToRoman(int N) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 0; N > 0; i++)\\n            while (N >= val[i]) {\\n                ans.append(rom[i]);\\n                N -= val[i];\\n            }\\n        return ans.toString();\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725325,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=RckYHjMJLNI)\\nhttps://www.youtube.com/watch?v=RckYHjMJLNI\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> vm = {{1000, \"M\"},{900, \"CM\"} , {500, \"D\"},{400, \"CD\"} , {100, \"C\"} , {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},{10, \"X\"}, {9, \"IX\"},{5, \"V\"} , {4, \"IV\"},{1, \"I\"} };\\n        string s_ans = \"\";\\n        while(num > 0){\\n            for(auto x : vm){\\n                if(num >= x.first){\\n                    s_ans += x.second;\\n                    num = num - x.first;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return s_ans;\\n    }\\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> vm = {{1000, \"M\"},{900, \"CM\"} , {500, \"D\"},{400, \"CD\"} , {100, \"C\"} , {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},{10, \"X\"}, {9, \"IX\"},{5, \"V\"} , {4, \"IV\"},{1, \"I\"} };\\n        string s_ans = \"\";\\n        while(num > 0){\\n            for(auto x : vm){\\n                if(num >= x.first){\\n                    s_ans += x.second;\\n                    num = num - x.first;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return s_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704000,
                "title": "javascript",
                "content": "```\\nvar intToRoman = function(num) {\\n    let res = \"\";\\n    if (num < 1 || num > 3999) return res;\\n    let weight = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\\n   let token = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\', \\'C\\', \\'XC\\', \\'L\\', \\'XL\\', \\'X\\', \\'IX\\', \\'V\\', \\'IV\\', \\'I\\'];\\n    let i = 0;\\n    while (num > 0){\\n        if (num - weight[i] >= 0){\\n            res += token[i];\\n            num -= weight[i];\\n        }\\n        else{\\n            i++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar intToRoman = function(num) {\\n    let res = \"\";\\n    if (num < 1 || num > 3999) return res;\\n    let weight = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\\n   let token = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\', \\'C\\', \\'XC\\', \\'L\\', \\'XL\\', \\'X\\', \\'IX\\', \\'V\\', \\'IV\\', \\'I\\'];\\n    let i = 0;\\n    while (num > 0){\\n        if (num - weight[i] >= 0){\\n            res += token[i];\\n            num -= weight[i];\\n        }\\n        else{\\n            i++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6473,
                "title": "esay-c-solution-43ms",
                "content": "    class Solution {\\n    public:\\n    \\tconst static string THOUS[];\\n    \\tconst static string HUNDS[];\\n    \\tconst static string TENS[];\\n    \\tconst static string ONES[];\\n        string intToRoman(int num) {\\n    \\t\\tstring result;\\n    \\t\\tresult += THOUS[(int)(num/1000)%10];\\n    \\t\\tresult += HUNDS[(int)(num/100)%10];\\n    \\t\\tresult += TENS[(int)(num/10)%10];\\n    \\t\\tresult += ONES[num%10];\\n    \\t\\treturn result;\\n        }\\n    };\\n    \\n    const string Solution::THOUS[]\\t= {\"\",\"M\",\"MM\",\"MMM\"};\\n    const string Solution::HUNDS[]\\t= {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n    const string Solution::TENS[]\\t= {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    const string Solution::ONES[]\\t= {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tconst static string THOUS[];\\n    \\tconst static string HUNDS[];\\n    \\tconst static string TENS[];\\n    \\tconst static string ONES[];\\n        string intToRoman(int num) {\\n    \\t\\tstring result;\\n    \\t\\tresult += THOUS[(int)(num/1000)%10];\\n    \\t\\tresult += HUNDS[(int)(num/100)%10];\\n    \\t\\tresult += TENS[(int)(num/10)%10];\\n    \\t\\tresult += ONES[num%10];\\n    \\t\\treturn result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2724006,
                "title": "c-integer-to-roman-just-8-lines-of-code",
                "content": "```\\nstring intToRoman(int num) {\\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\\n    string ans;\\n    for (int i=0; i<13; i++) {\\n        for (int j=0; j<(num/val[i]); j++) {\\n            ans += str[i];\\n        }\\n        num %= val[i];\\n    }\\n    return ans;\\n}\\n```\\nHelpful?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) {\\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\\n    string ans;\\n    for (int i=0; i<13; i++) {\\n        for (int j=0; j<(num/val[i]); j++) {\\n            ans += str[i];\\n        }\\n        num %= val[i];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521374,
                "title": "no-loop-no-conditions-used",
                "content": "String[] Thousands={\"\",\"M\",\"MM\",\"MMM\"};\\n        String[] Hundreds={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String[] Tens={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String[] Units={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        return Thousands[num/1000]+Hundreds[(num%1000)/100]+Tens[(num%100)/10]+Units[(num%10)];",
                "solutionTags": [],
                "code": "String[] Thousands={\"\",\"M\",\"MM\",\"MMM\"};\\n        String[] Hundreds={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String[] Tens={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String[] Units={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        return Thousands[num/1000]+Hundreds[(num%1000)/100]+Tens[(num%100)/10]+Units[(num%10)];",
                "codeTag": "Unknown"
            },
            {
                "id": 255369,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425736,
                "title": "best-and-easy-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                Easiest Approaah using arrays \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n                  store the info and use it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                  O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                  O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] s={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String t=\"\";\\n       int i=0;\\n       while(num>0){\\n           if(num>=values[i]){\\n               t+=s[i];\\n               num-=values[i];\\n           }\\n            else\\n           i++;\\n       }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String[] s={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String t=\"\";\\n       int i=0;\\n       while(num>0){\\n           if(num>=values[i]){\\n               t+=s[i];\\n               num-=values[i];\\n           }\\n            else\\n           i++;\\n       }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536553,
                "title": "java-easy-solution-using-a-linkedhashmap",
                "content": "I noticed most of the solutions to this problem are using multiple arrays, instead I used a single LinkedHashMap to solve it.\\n\\n**Q. Why use LinkedHashMap instead of HashMap?\\nA. LinkedHashMap is ordered, HashMap is unordered.**\\n\\nsource: https://docs.oracle.com/javase/6/docs/api/java/util/LinkedHashMap.html\\n\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();\\n        map.put(1000, \"M\");\\n        map.put(900, \"CM\");\\n        map.put(500, \"D\");\\n        map.put(400, \"CD\");\\n        map.put(100, \"C\");\\n        map.put(90, \"XC\");\\n        map.put(50, \"L\");\\n        map.put(40, \"XL\");\\n        map.put(10, \"X\");\\n        map.put(9, \"IX\");\\n        map.put(5, \"V\");\\n        map.put(4, \"IV\");\\n        map.put(1, \"I\");\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\\n            while (num >= entry.getKey()) {\\n                num -= entry.getKey();\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();\\n        map.put(1000, \"M\");\\n        map.put(900, \"CM\");\\n        map.put(500, \"D\");\\n        map.put(400, \"CD\");\\n        map.put(100, \"C\");\\n        map.put(90, \"XC\");\\n        map.put(50, \"L\");\\n        map.put(40, \"XL\");\\n        map.put(10, \"X\");\\n        map.put(9, \"IX\");\\n        map.put(5, \"V\");\\n        map.put(4, \"IV\");\\n        map.put(1, \"I\");\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\\n            while (num >= entry.getKey()) {\\n                num -= entry.getKey();\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723880,
                "title": "fastest-python-solution-using-mapping",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        i=1\\n        dic={1:\\'I\\',5:\\'V\\',10:\\'X\\',50:\\'L\\',100:\\'C\\',500:\\'D\\',1000:\\'M\\'}\\n        s=\"\"\\n        while num!=0:\\n            y=num%pow(10,i)//pow(10,i-1)\\n            if y==5:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==1:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==4:\\n                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s\\n            elif y==9:\\n                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s\\n            elif y<4:\\n                s=dic[pow(10,i-1)]*y+s\\n            elif y>5 and y<9:\\n                y-=5\\n                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s\\n            num=num//pow(10,i)\\n            num*=pow(10,i)\\n            i+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        i=1\\n        dic={1:\\'I\\',5:\\'V\\',10:\\'X\\',50:\\'L\\',100:\\'C\\',500:\\'D\\',1000:\\'M\\'}\\n        s=\"\"\\n        while num!=0:\\n            y=num%pow(10,i)//pow(10,i-1)\\n            if y==5:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==1:\\n                s=dic[y*pow(10,i-1)]+s\\n            elif y==4:\\n                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s\\n            elif y==9:\\n                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s\\n            elif y<4:\\n                s=dic[pow(10,i-1)]*y+s\\n            elif y>5 and y<9:\\n                y-=5\\n                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s\\n            num=num//pow(10,i)\\n            num*=pow(10,i)\\n            i+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971772,
                "title": "c-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string romans[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int numerals[]={1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        string res;\\n        while(num)\\n        {\\n            for(int i=12;i>=0;i--)\\n            {\\n                int x = num/numerals[i];\\n                if(x)\\n                {\\n                    while(x--)\\n                    {\\n                        res += romans[i];\\n                    }\\n                    num %= numerals[i];\\n                    break;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Integer to Roman.\\nMemory Usage: 6 MB, less than 99.00% of C++ online submissions for Integer to Roman.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string romans[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int numerals[]={1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        string res;\\n        while(num)\\n        {\\n            for(int i=12;i>=0;i--)\\n            {\\n                int x = num/numerals[i];\\n                if(x)\\n                {\\n                    while(x--)\\n                    {\\n                        res += romans[i];\\n                    }\\n                    num %= numerals[i];\\n                    break;\\n                }\\n            }\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202670,
                "title": "best-c-2-solution-hash-table-math-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using String + Hash Table + Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\\n    which is constant.\\n\\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\\u2019t depend on the\\n    input size hence the space complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\n        for(int i=0; num != 0; i++){\\n            while(num >= val[i]){\\n                num -= val[i];\\n                res += sym[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \\n    O(3.60) which is constant hence the overall time complexity will be O(1).\\n\\n    Space Complexity : O(1), We are using four arrays whose sizes don\\u2019t depend on the input size hence the space\\n    complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string ans = \"\";\\n        \\n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\\n    which is constant.\\n\\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\\u2019t depend on the\\n    input size hence the space complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res;\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\n        for(int i=0; num != 0; i++){\\n            while(num >= val[i]){\\n                num -= val[i];\\n                res += sym[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \\n    O(3.60) which is constant hence the overall time complexity will be O(1).\\n\\n    Space Complexity : O(1), We are using four arrays whose sizes don\\u2019t depend on the input size hence the space\\n    complexity will be O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        string ans = \"\";\\n        \\n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724009,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private static final StringBuilder sb = new StringBuilder(15);\\n    \\n    private static final String[] thou = {\"\", \"M\", \"MM\", \"MMM\"};\\n    private static final String[] hund = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\"DCCC\",\"CM\"};\\n    private static final String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    private static final String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\"VII\",\"VIII\",\"IX\"};\\n    \\n    public String intToRoman(int num) {\\n        sb.setLength(0);\\n        \\n        sb.append(thou[num/1000]);\\n        sb.append(hund[(num%1000)/100]);\\n        sb.append(tens[(num%100)/10]);\\n        sb.append(ones[num%10]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final StringBuilder sb = new StringBuilder(15);\\n    \\n    private static final String[] thou = {\"\", \"M\", \"MM\", \"MMM\"};\\n    private static final String[] hund = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\"DCCC\",\"CM\"};\\n    private static final String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n    private static final String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\"VII\",\"VIII\",\"IX\"};\\n    \\n    public String intToRoman(int num) {\\n        sb.setLength(0);\\n        \\n        sb.append(thou[num/1000]);\\n        sb.append(hund[(num%1000)/100]);\\n        sb.append(tens[(num%100)/10]);\\n        sb.append(ones[num%10]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245498,
                "title": "c-greedy",
                "content": "Decrement large to small ```val``` from value vector by the largest possible amount each time  from ```num```\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res = \"\";\\n        vector<int> val{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> str{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for (int i = 0; i < val.size(); ++i) {\\n            while (num >= val[i]) {\\n                num -= val[i];\\n                res += str[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```val```\n```num```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string res = \"\";\\n        vector<int> val{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> str{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for (int i = 0; i < val.size(); ++i) {\\n            while (num >= val[i]) {\\n                num -= val[i];\\n                res += str[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444278,
                "title": "java-runtime-3s-and-greater-than-100-100",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, \\n                     50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \\n                          \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, \\n                     50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \\n                          \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6469,
                "title": "share-my-iterative-solution",
                "content": "    public String intToRoman(int num) {\\n        int[] weights={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] tokens={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder rs=new StringBuilder(\"\");\\n        int start=0;\\n        while(num>0){\\n            for(int i=start;i<13;i++){\\n                if(num>=weights[i]){\\n                    num-=weights[i];\\n                    rs.append(tokens[i]);\\n                    break;\\n                }\\n                start=i+1; // skip those impossible check, make it faster\\n            }\\n        }\\n        return rs.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String intToRoman(int num) {\\n        int[] weights={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] tokens={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder rs=new StringBuilder(\"\");\\n        int start=0;\\n        while(num>0){\\n            for(int i=start;i<13;i++){\\n                if(num>=weights[i]){\\n                    num-=weights[i];\\n                    rs.append(tokens[i]);\\n                    break;\\n                }\\n                start=i+1; // skip those impossible check, make it faster\\n            }\\n        }\\n        return rs.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1102756,
                "title": "python-stack-solution",
                "content": "My code:\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        dct = {1: \\'I\\', 4: \\'IV\\', 5: \\'V\\', 9: \\'IX\\', 10: \\'X\\', 40: \\'XL\\', 50: \\'L\\', 90: \\'XC\\', 100: \\'C\\', 400: \\'CD\\', 500: \\'D\\', 900: \\'CM\\', 1000: \\'M\\'}\\n        stack = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\\n        ans = []\\n        while num > 0:\\n            if stack[-1] > num:\\n                stack.pop()\\n            else:\\n                num -= stack[-1]\\n                ans.append(dct[stack[-1]])\\n        return \"\".join(map(str, ans))\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        dct = {1: \\'I\\', 4: \\'IV\\', 5: \\'V\\', 9: \\'IX\\', 10: \\'X\\', 40: \\'XL\\', 50: \\'L\\', 90: \\'XC\\', 100: \\'C\\', 400: \\'CD\\', 500: \\'D\\', 900: \\'CM\\', 1000: \\'M\\'}\\n        stack = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\\n        ans = []\\n        while num > 0:\\n            if stack[-1] > num:\\n                stack.pop()\\n            else:\\n                num -= stack[-1]\\n                ans.append(dct[stack[-1]])\\n        return \"\".join(map(str, ans))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 6405,
                "title": "my-solutions-in-java",
                "content": "\\n    public String intToRoman(int num) {\\n        String data[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int value[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1}, base = -1;\\n        StringBuilder result = new StringBuilder();\\n\\n        for(int i = 0;i < data.length;i++){\\n            if((base=num/value[i])!=0){\\n                while(base--!=0)result.append(data[i]);\\n                num=num%value[i];\\n            }\\n        }\\n        return result.toString();\\n    }",
                "solutionTags": [],
                "code": "\\n    public String intToRoman(int num) {\\n        String data[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int value[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1}, base = -1;\\n        StringBuilder result = new StringBuilder();\\n\\n        for(int i = 0;i < data.length;i++){\\n            if((base=num/value[i])!=0){\\n                while(base--!=0)result.append(data[i]);\\n                num=num%value[i];\\n            }\\n        }\\n        return result.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1102727,
                "title": "python-java-clean-concise",
                "content": "**Python**\\n```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\\n               (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\\n\\n        ans = \"\"\\n        for n, s in digits:  # Maximum 13 operations\\n            while num >= n:  # Each while loop, maximum 3 operations, imagine case num=3\\n                ans += s\\n                num -= n\\n        return ans\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < values.length; i++) {\\n            while (num >= values[i]) {\\n                num -= values[i];\\n                sb.append(symbols[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time & Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\\n               (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\\n\\n        ans = \"\"\\n        for n, s in digits:  # Maximum 13 operations\\n            while num >= n:  # Each while loop, maximum 3 operations, imagine case num=3\\n                ans += s\\n                num -= n\\n        return ans\\n```\n```java\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < values.length; i++) {\\n            while (num >= values[i]) {\\n                num -= values[i];\\n                sb.append(symbols[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689156,
                "title": "python3-smart-work-soln-4-line",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        \\n        return M[num//1000]+C[(num//100)%10]+X[(num//10)%10]+I[num%10]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M=[\"\",\"M\",\"MM\",\"MMM\"]\\n        C=[\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]\\n        X=[\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"]\\n        I=[\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"]\\n        \\n        return M[num//1000]+C[(num//100)%10]+X[(num//10)%10]+I[num%10]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 492037,
                "title": "java-easiest-solution-must-read",
                "content": "```\\npublic String intToRoman(int num) {\\n\\n\\tString[] thousands = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\tString[] hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\tString[] tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\tString[] ones = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n\\tStringBuilder sol = new StringBuilder();\\n\\tsol.append(thousands[num/1000])\\n\\t\\t.append(hundreds[(num%1000)/100])\\n\\t\\t.append(tens[(num%100)/10])\\n\\t\\t.append(ones[num%10]);\\n\\t\\t\\n\\treturn  sol.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String intToRoman(int num) {\\n\\n\\tString[] thousands = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\tString[] hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\tString[] tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\tString[] ones = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n\\tStringBuilder sol = new StringBuilder();\\n\\tsol.append(thousands[num/1000])\\n\\t\\t.append(hundreds[(num%1000)/100])\\n\\t\\t.append(tens[(num%100)/10])\\n\\t\\t.append(ones[num%10]);\\n\\t\\t\\n\\treturn  sol.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2289110,
                "title": "very-easy-100-c-java-javascript-fully-explained-line-by-line",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        vector<string> romanWord = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector<int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.size() - 1;\\n        //create the solution which will be in string format...\\n        string sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        String romanWord[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int value[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.length - 1;\\n        //create the solution which will be in string format...\\n        String sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\n//Another approach is here..\\nvar intToRoman = function(num) {\\n    //create the list..\\n    const M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    const C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    //return solution with this procedure...\\n    return M[Math.floor(num / 1000)] + C[Math.floor((num % 1000) / 100)] + X[Math.floor((num % 100) / 10)] + I[num % 10];\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        vector<string> romanWord = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector<int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.size() - 1;\\n        //create the solution which will be in string format...\\n        string sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        //first we create a table of roman word and their values..\\n        String romanWord[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int value[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        //initialize and set the index i...\\n        int i = romanWord.length - 1;\\n        //create the solution which will be in string format...\\n        String sol = \"\";\\n        //a loop will be made to begin the procedure...\\n        while(num>0){\\n            //this loop is working untill the the vslue of integer is less or equal to num...\\n            while(value[i]<=num){\\n                //Append the roman numeral into an solution string...\\n                sol += romanWord[i];\\n                //subtract the integral value from the given integer...\\n                //Subtract the current number until the given integer is greater than the current number.\\n                num -= value[i];\\n            }\\n            i--;\\n        }\\n        //Once we are done with all the roman numerals, we return the solution.\\n        return sol;\\n    }\\n}\\n```\n```\\n//Another approach is here..\\nvar intToRoman = function(num) {\\n    //create the list..\\n    const M = [\"\", \"M\", \"MM\", \"MMM\"];\\n    const C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    const X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    const I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    //return solution with this procedure...\\n    return M[Math.floor(num / 1000)] + C[Math.floor((num % 1000) / 100)] + X[Math.floor((num % 100) / 10)] + I[num % 10];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928027,
                "title": "don-t-spend-too-much-time-on-this-problem-if-you-don-t-understand-the-logic-behind-roman-numerals",
                "content": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        // 42\\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] romanNumerals ={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            \\n            while(num >= values[i]) {\\n                \\n                num -= values[i];\\n                sb.append(romanNumerals[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n        \\n        // 42\\n        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 323502,
                "title": "a-simple-javascript-solution",
                "content": "```js\\n// build a roman set\\n// build a number set correspond roman set\\n// traverse set ,Decrease num\\nvar intToRoman = function(num) {\\n    var list = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\',\\'C\\',\\'XC\\',\\'L\\', \\'XL\\',\\'X\\',\\'IX\\',\\'V\\',\\'IV\\',\\'I\\']\\n    var valueList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    var result = \\'\\'\\n    while(num !== 0) {\\n        for(var i = 0 ; i < valueList.length ; i++) {\\n            if(num >= valueList[i]){\\n                result += list[i]\\n                num -= valueList[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// build a roman set\\n// build a number set correspond roman set\\n// traverse set ,Decrease num\\nvar intToRoman = function(num) {\\n    var list = [\\'M\\', \\'CM\\', \\'D\\', \\'CD\\',\\'C\\',\\'XC\\',\\'L\\', \\'XL\\',\\'X\\',\\'IX\\',\\'V\\',\\'IV\\',\\'I\\']\\n    var valueList = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\\n    var result = \\'\\'\\n    while(num !== 0) {\\n        for(var i = 0 ; i < valueList.length ; i++) {\\n            if(num >= valueList[i]){\\n                result += list[i]\\n                num -= valueList[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6438,
                "title": "straight-forward-java-recursive-solution",
                "content": "    public class Solution {\\n        public String intToRoman(int num) {\\n            if (num>=1000) {\\n                return (\"M\"+intToRoman(num-1000));\\n            } else if (num>=900) {\\n                return (\"CM\"+intToRoman(num-900));\\n            } else if (num>=500) {\\n                return (\"D\"+intToRoman(num-500));\\n            } else if (num>=400) {\\n                return (\"CD\"+intToRoman(num-400));\\n            } else if (num>=100) {\\n                return (\"C\"+intToRoman(num-100));\\n            } else if (num>=90) {\\n                return (\"XC\"+intToRoman(num-90));\\n            } else if (num>=50) {\\n                return (\"L\"+intToRoman(num-50));\\n            } else if (num>=40) {\\n                return (\"XL\"+intToRoman(num-40));\\n            } else if (num>=10) {\\n                return (\"X\"+intToRoman(num-10));\\n            } else if (num>=9) {\\n                return (\"IX\"+intToRoman(num-9));\\n            } else if (num>=5) {\\n                return (\"V\"+intToRoman(num-5));\\n            } else if (num>=4) {\\n                return (\"IV\"+intToRoman(num-4));\\n            } else if (num>=1) {\\n                return (\"I\"+intToRoman(num-1));\\n            }\\n            return (\"\");\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            if (num>=1000) {\\n                return (\"M\"+intToRoman(num-1000));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3968557,
                "title": "java-simple-solution-runtime-9ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\n\\nclass Solution {\\n     public static String intToRoman(int num)\\n    {\\n        StringBuilder s = new StringBuilder();\\n\\n        Hashtable<Integer , String > list = new Hashtable<>();\\n        list.put(1 , \"I\");\\n        list.put(4 , \"IV\");\\n        list.put(5 , \"V\");\\n        list.put(9 , \"IX\");\\n        list.put(10 , \"X\");\\n        list.put(40 , \"XL\");\\n        list.put(50 , \"L\");\\n        list.put(90 , \"XC\");\\n        list.put(100 , \"C\");\\n        list.put(400 , \"CD\");\\n        list.put(500 , \"D\");\\n        list.put(900 , \"CM\");\\n        list.put(1000 , \"M\");\\n        \\n        while (num > 0)\\n        {\\n            int maxkey = getMaxKey(list , num);\\n            s.append(list.get(maxkey));\\n            num -= maxkey;\\n        }\\n        return s.toString();\\n    }\\n\\n    public static int getMaxKey(Hashtable list , int target)\\n    {\\n        int maxKey = -1;\\n\\n        Enumeration<Integer> keys = list.keys();\\n        while (keys.hasMoreElements()) {\\n            int key = keys.nextElement();\\n            if (key <= target && key > maxKey) {\\n                maxKey = key;\\n            }\\n        }\\n        return maxKey;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/8e0d7970-b648-4a25-9abb-98529499d16b_1693157592.6218796.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\n\\nclass Solution {\\n     public static String intToRoman(int num)\\n    {\\n        StringBuilder s = new StringBuilder();\\n\\n        Hashtable<Integer , String > list = new Hashtable<>();\\n        list.put(1 , \"I\");\\n        list.put(4 , \"IV\");\\n        list.put(5 , \"V\");\\n        list.put(9 , \"IX\");\\n        list.put(10 , \"X\");\\n        list.put(40 , \"XL\");\\n        list.put(50 , \"L\");\\n        list.put(90 , \"XC\");\\n        list.put(100 , \"C\");\\n        list.put(400 , \"CD\");\\n        list.put(500 , \"D\");\\n        list.put(900 , \"CM\");\\n        list.put(1000 , \"M\");\\n        \\n        while (num > 0)\\n        {\\n            int maxkey = getMaxKey(list , num);\\n            s.append(list.get(maxkey));\\n            num -= maxkey;\\n        }\\n        return s.toString();\\n    }\\n\\n    public static int getMaxKey(Hashtable list , int target)\\n    {\\n        int maxKey = -1;\\n\\n        Enumeration<Integer> keys = list.keys();\\n        while (keys.hasMoreElements()) {\\n            int key = keys.nextElement();\\n            if (key <= target && key > maxKey) {\\n                maxKey = key;\\n            }\\n        }\\n        return maxKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311278,
                "title": "c-java-c-python3-simple-easy-to-understand-efficient-clean-code",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 27},\\n    {\"Microsoft\", 5},\\n    {\"Bloomberg\", 5},\\n    {\"Apple\", 3},\\n    {\"Capital One\", 3},\\n    {\"Adobe\", 2},\\n    {\"Google\", 2},\\n    {\"tiktok\", 2}\\n};\\n```\\n\\n# Solution\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\nprivate:\\n    int values[7] { 1000, 500, 100, 50, 10, 5, 1 };\\n    string strs[7] { \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" };\\n    unordered_map<int, int> myDict {{4, 0}, {3, 2}, {2, 4}, {1, 6}};\\n\\n    string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num--) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private String[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Map<Integer, Integer> myDict = new HashMap<Integer, Integer>() {{\\n        put(4, 0);\\n        put(3, 2);\\n        put(2, 4);\\n        put(1, 6);\\n    }};\\n\\n    public String intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private String convertRoman(int digit, int value) {\\n        String res = \"\";\\n        int temp = myDict.get(value);\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private String repeat(String repeatVal, int num) {\\n        String ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private string[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Dictionary<int, int> myDict = new Dictionary<int, int> {\\n        {4, 0},\\n        {3, 2},\\n        {2, 4},\\n        {1, 6}\\n    };\\n\\n    public string IntToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.values = [1000, 500, 100, 50, 10, 5, 1]\\n        self.strs = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\\n        self.myDict = {4: 0, 3: 2, 2: 4, 1: 6}\\n\\n    def intToRoman(self, num: int) -> str:\\n        return self.convertRoman(num//1000, 4) + self.convertRoman((num%1000)//100, 3) + self.convertRoman((num%100)//10, 2) + self.convertRoman(num%10, 1)\\n\\n    def convertRoman(self, digit: int, value: int) -> str:\\n        res = \"\"\\n        temp = self.myDict[value]\\n        if temp == 0:\\n            res = self.repeat(self.strs[temp], digit)\\n        else:\\n            if digit >= 1 and digit < 4:\\n                res += self.repeat(self.strs[temp], digit)\\n            elif digit == 4:\\n                res += self.strs[temp] + self.strs[temp - 1]\\n            elif digit >= 5 and digit < 9:\\n                res += self.strs[temp - 1] + self.repeat(self.strs[temp], (digit - 5))\\n            elif digit == 9:\\n                res += self.strs[temp] + self.strs[temp - 2]\\n        return res\\n\\n    def repeat(self, repeatVal: str, num: int) -> str:\\n        ret = \"\"\\n        while num > 0:\\n            ret += repeatVal\\n            num -= 1\\n        return ret\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 27},\\n    {\"Microsoft\", 5},\\n    {\"Bloomberg\", 5},\\n    {\"Apple\", 3},\\n    {\"Capital One\", 3},\\n    {\"Adobe\", 2},\\n    {\"Google\", 2},\\n    {\"tiktok\", 2}\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\nprivate:\\n    int values[7] { 1000, 500, 100, 50, 10, 5, 1 };\\n    string strs[7] { \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" };\\n    unordered_map<int, int> myDict {{4, 0}, {3, 2}, {2, 4}, {1, 6}};\\n\\n    string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num--) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private String[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Map<Integer, Integer> myDict = new HashMap<Integer, Integer>() {{\\n        put(4, 0);\\n        put(3, 2);\\n        put(2, 4);\\n        put(1, 6);\\n    }};\\n\\n    public String intToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private String convertRoman(int digit, int value) {\\n        String res = \"\";\\n        int temp = myDict.get(value);\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private String repeat(String repeatVal, int num) {\\n        String ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    private int[] values = {1000, 500, 100, 50, 10, 5, 1};\\n    private string[] strs = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n    private Dictionary<int, int> myDict = new Dictionary<int, int> {\\n        {4, 0},\\n        {3, 2},\\n        {2, 4},\\n        {1, 6}\\n    };\\n\\n    public string IntToRoman(int num) {\\n        return convertRoman(num/1000, 4) + convertRoman((num%1000)/100, 3) + convertRoman((num%100)/10, 2) + convertRoman(num%10, 1);      \\n    }\\n\\n    private string convertRoman(int digit, int value) {\\n        string res = \"\";\\n        int temp = myDict[value];\\n        if (temp == 0) \\n            res = repeat(strs[temp], digit);\\n        else {\\n            if (digit >= 1 && digit < 4) \\n                res += repeat(strs[temp], digit);\\n            else if (digit == 4) \\n                res += strs[temp] + strs[temp - 1];\\n            else if (digit >= 5 && digit < 9) \\n                res += strs[temp - 1] + repeat(strs[temp], (digit - 5));\\n            else if (digit == 9) \\n                res += strs[temp] + strs[temp - 2];\\n        }\\n        return res;\\n    }\\n\\n    private string repeat(string repeatVal, int num) {\\n        string ret = \"\";\\n        while (num-- > 0) \\n            ret += repeatVal;\\n        return ret;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.values = [1000, 500, 100, 50, 10, 5, 1]\\n        self.strs = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\\n        self.myDict = {4: 0, 3: 2, 2: 4, 1: 6}\\n\\n    def intToRoman(self, num: int) -> str:\\n        return self.convertRoman(num//1000, 4) + self.convertRoman((num%1000)//100, 3) + self.convertRoman((num%100)//10, 2) + self.convertRoman(num%10, 1)\\n\\n    def convertRoman(self, digit: int, value: int) -> str:\\n        res = \"\"\\n        temp = self.myDict[value]\\n        if temp == 0:\\n            res = self.repeat(self.strs[temp], digit)\\n        else:\\n            if digit >= 1 and digit < 4:\\n                res += self.repeat(self.strs[temp], digit)\\n            elif digit == 4:\\n                res += self.strs[temp] + self.strs[temp - 1]\\n            elif digit >= 5 and digit < 9:\\n                res += self.strs[temp - 1] + self.repeat(self.strs[temp], (digit - 5))\\n            elif digit == 9:\\n                res += self.strs[temp] + self.strs[temp - 2]\\n        return res\\n\\n    def repeat(self, repeatVal: str, num: int) -> str:\\n        ret = \"\"\\n        while num > 0:\\n            ret += repeatVal\\n            num -= 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725198,
                "title": "python-rust-c-three-easy-concise-solutions-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/826490173/) employs a repetition of Roman digits. It demonstrated **47 ms runtime (96.77%)** and used **13.9 MB memory (35.57%)**. Time complexity is contstant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n\\t\\t# Starting from Python 3.7, dictionary order is guaranteed \\n\\t\\t# to be insertion order\\n        num_to_roman = { 1000 : \"M\", 900 : \"CM\", 500 : \"D\", 400 : \"CD\",\\n                          100 : \"C\",  90 : \"XC\",  50 : \"L\",  40 : \"XL\",\\n                           10 : \"X\",   9 : \"IX\",   5 : \"V\",   4 : \"IV\",\\n                            1 : \"I\" }\\n        roman: str = \"\"\\n\\n        # The idea is to repeat each of Roman digits as many times\\n        # as needed to cover the decimal representation.\\n        for i, r in num_to_roman.items():\\n            roman += r * (num // i)\\n            num   %= i\\n        else:\\n            return roman\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/826504889/) employs a brute force digit substitution. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (94.20%)**. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nconst ONES : [&str;10] = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\nconst TENS : [&str;10] = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\nconst CENT : [&str;10] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\nconst MILS : [&str;4]  = [\"\", \"M\", \"MM\", \"MMM\"];\\n\\nimpl Solution \\n{\\n    pub fn int_to_roman(num: i32) -> String \\n    {\\n        // Given that the number of outcomes is small, a brute force\\n\\t\\t// substituion for each power of ten is a viable solution...\\n\\t\\tformat!(\"{}{}{}{}\", MILS[(num / 1000 % 10) as usize],\\n                            CENT[(num / 100  % 10) as usize],\\n                            TENS[(num / 10   % 10) as usize],\\n                            ONES[(num        % 10) as usize])\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/826509511/) employs an iterative build-up of a Roman number. It demonstrated **0 ms runtime (100.0%)** and used **6.1 MB memory (47.60%)**. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n```\\nclass Solution \\n{\\n    const int    intgr[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const string roman[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\npublic:\\n    string intToRoman(int num)\\n    {\\n        string rom = \"\";\\n\\t\\t\\n        for (int i = 0; num > 0; i++)\\n\\t\\t    // each digit is repeated as many times as needed to \\n\\t\\t\\t// completely cover the decimal representation \\n            while (num >= intgr[i]) rom += roman[i], num -= intgr[i];\\n        return rom;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n\\t\\t# Starting from Python 3.7, dictionary order is guaranteed \\n\\t\\t# to be insertion order\\n        num_to_roman = { 1000 : \"M\", 900 : \"CM\", 500 : \"D\", 400 : \"CD\",\\n                          100 : \"C\",  90 : \"XC\",  50 : \"L\",  40 : \"XL\",\\n                           10 : \"X\",   9 : \"IX\",   5 : \"V\",   4 : \"IV\",\\n                            1 : \"I\" }\\n        roman: str = \"\"\\n\\n        # The idea is to repeat each of Roman digits as many times\\n        # as needed to cover the decimal representation.\\n        for i, r in num_to_roman.items():\\n            roman += r * (num // i)\\n            num   %= i\\n        else:\\n            return roman\\n```\n```\\nconst ONES : [&str;10] = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\nconst TENS : [&str;10] = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\nconst CENT : [&str;10] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\nconst MILS : [&str;4]  = [\"\", \"M\", \"MM\", \"MMM\"];\\n\\nimpl Solution \\n{\\n    pub fn int_to_roman(num: i32) -> String \\n    {\\n        // Given that the number of outcomes is small, a brute force\\n\\t\\t// substituion for each power of ten is a viable solution...\\n\\t\\tformat!(\"{}{}{}{}\", MILS[(num / 1000 % 10) as usize],\\n                            CENT[(num / 100  % 10) as usize],\\n                            TENS[(num / 10   % 10) as usize],\\n                            ONES[(num        % 10) as usize])\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    const int    intgr[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const string roman[13] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n\\npublic:\\n    string intToRoman(int num)\\n    {\\n        string rom = \"\";\\n\\t\\t\\n        for (int i = 0; num > 0; i++)\\n\\t\\t    // each digit is repeated as many times as needed to \\n\\t\\t\\t// completely cover the decimal representation \\n            while (num >= intgr[i]) rom += roman[i], num -= intgr[i];\\n        return rom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724059,
                "title": "python-3-8-lines-w-example-t-m-99-5-46",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str: \\n\\n        mils = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        cens = [ \"\",  \"C\",  \"CC\",  \"CCC\", \"CD\",\\n                \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n\\n        decs = [ \"\",  \"X\",  \"XX\",  \"XXX\", \"XL\",\\n                \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n\\n        unes = [ \"\",  \"I\",  \"II\",  \"III\", \"IV\",\\n                \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]    #    EX:  num = 2579\\n\\n        m, num = divmod(num,1000)                  #  m = 2  num =  579\\n        c, num = divmod(num,100 )                  #  m = 5  num =   79\\n        d, u   = divmod(num,10  )                  #  m = 7  u   =    9\\n\\n        return mils[m]+cens[c]+decs[d]+unes[u]     #  mils[2]+cens[5]+decs[7]+unes[9] = MM + D + LXX + IX = MMDLXXIX \\n```\\n[https://leetcode.com/submissions/detail/826328411/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str: \\n\\n        mils = [\"\", \"M\", \"MM\", \"MMM\"]\\n\\n        cens = [ \"\",  \"C\",  \"CC\",  \"CCC\", \"CD\",\\n                \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n\\n        decs = [ \"\",  \"X\",  \"XX\",  \"XXX\", \"XL\",\\n                \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n\\n        unes = [ \"\",  \"I\",  \"II\",  \"III\", \"IV\",\\n                \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]    #    EX:  num = 2579\\n\\n        m, num = divmod(num,1000)                  #  m = 2  num =  579\\n        c, num = divmod(num,100 )                  #  m = 5  num =   79\\n        d, u   = divmod(num,10  )                  #  m = 7  u   =    9\\n\\n        return mils[m]+cens[c]+decs[d]+unes[u]     #  mils[2]+cens[5]+decs[7]+unes[9] = MM + D + LXX + IX = MMDLXXIX \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744490,
                "title": "easy-c-solution-with-full-explanation",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Basic approach, taking all possible cases that can happen and making a while loop for every case.\\n- We\\u2019ll calculate from a large value and will continue until it\\u2019s reduced to any other cases.\\n- Add the character to the last of the ans string.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- Here we store the values of all cases in a string and int variable.\\n- Here 13 possible cases can happen, so we run a loop for 13 indexes.\\n- Similar to the previous approach runs a while loop until num is greater or equal to current number of our array & add this to our ans array.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num >= 1000){\\n            ans += \"M\";\\n            num -= 1000;\\n        }\\n        if(num >= 900){\\n            ans += \"CM\";\\n            num -= 900;\\n        }\\n        while(num >= 500){\\n            ans += \"D\";\\n            num -= 500;\\n        }\\n        if(num >= 400){\\n            ans += \"CD\";\\n            num -= 400;\\n        }\\n        while(num >= 100){\\n            ans += \"C\";\\n            num -= 100;\\n        }\\n        if(num >= 90){\\n            ans += \"XC\";\\n            num -= 90;\\n        }\\n        while(num >= 50){\\n            ans += \"L\";\\n            num -= 50;\\n        }\\n        if(num >= 40){\\n            ans += \"XL\";\\n            num -= 40;\\n        }\\n        while(num >= 10){\\n            ans += \"X\";\\n            num -= 10;\\n        }\\n        if(num >= 9){\\n            ans += \"IX\";\\n            num -= 9;\\n        }\\n        while(num >= 5){\\n            ans += \"V\";\\n            num -= 5;\\n        }\\n        if(num >= 4){\\n            ans += \"IV\";\\n            num -= 4;\\n        }\\n        while(num >= 1){\\n            ans += \"I\";\\n            num -= 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string valr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int vali[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string ans;\\n        \\n        for(int i=0; i<13; i++){\\n            while(num >= vali[i]){\\n                ans.append(valr[i]);\\n                num -= vali[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num >= 1000){\\n            ans += \"M\";\\n            num -= 1000;\\n        }\\n        if(num >= 900){\\n            ans += \"CM\";\\n            num -= 900;\\n        }\\n        while(num >= 500){\\n            ans += \"D\";\\n            num -= 500;\\n        }\\n        if(num >= 400){\\n            ans += \"CD\";\\n            num -= 400;\\n        }\\n        while(num >= 100){\\n            ans += \"C\";\\n            num -= 100;\\n        }\\n        if(num >= 90){\\n            ans += \"XC\";\\n            num -= 90;\\n        }\\n        while(num >= 50){\\n            ans += \"L\";\\n            num -= 50;\\n        }\\n        if(num >= 40){\\n            ans += \"XL\";\\n            num -= 40;\\n        }\\n        while(num >= 10){\\n            ans += \"X\";\\n            num -= 10;\\n        }\\n        if(num >= 9){\\n            ans += \"IX\";\\n            num -= 9;\\n        }\\n        while(num >= 5){\\n            ans += \"V\";\\n            num -= 5;\\n        }\\n        if(num >= 4){\\n            ans += \"IV\";\\n            num -= 4;\\n        }\\n        while(num >= 1){\\n            ans += \"I\";\\n            num -= 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string valr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int vali[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string ans;\\n        \\n        for(int i=0; i<13; i++){\\n            while(num >= vali[i]){\\n                ans.append(valr[i]);\\n                num -= vali[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119875,
                "title": "solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] v = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] s = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=0;i<v.length;i++){\\n            while(num>=v[i]){\\n                sb.append(s[i]);\\n                num-=v[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] v = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] s = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int i=0;i<v.length;i++){\\n            while(num>=v[i]){\\n                sb.append(s[i]);\\n                num-=v[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102909,
                "title": "c-simplest-straight-forward-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> roman = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n        vector<int> integers = {1000, 500, 100, 50, 10, 5, 1};\\n        vector<int> carry = {100, 100, 10, 10, 1, 1, 0};\\n        \\n        string res = \"\";\\n        int next;\\n        \\n        for (int i = 0; num; i++) {\\n            \\n            int temp = num / integers[i];\\n            while (temp--) res += roman[i];\\n            num %= integers[i];\\n            \\n            if (i == 6) return res;\\n            \\n            next = carry[i];\\n            if ((num - num % next) == (integers[i] - next)) {\\n                res += i % 2 ? roman[i+1] + roman[i] : roman[i+2] + roman[i];\\n                num -= integers[i] - next;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> roman = {\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"};\\n        vector<int> integers = {1000, 500, 100, 50, 10, 5, 1};\\n        vector<int> carry = {100, 100, 10, 10, 1, 1, 0};\\n        \\n        string res = \"\";\\n        int next;\\n        \\n        for (int i = 0; num; i++) {\\n            \\n            int temp = num / integers[i];\\n            while (temp--) res += roman[i];\\n            num %= integers[i];\\n            \\n            if (i == 6) return res;\\n            \\n            next = carry[i];\\n            if ((num - num % next) == (integers[i] - next)) {\\n                res += i % 2 ? roman[i+1] + roman[i] : roman[i+2] + roman[i];\\n                num -= integers[i] - next;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204750,
                "title": "easy-with-javascript",
                "content": "```\\nfunction intToRoman(num) {\\n    var hash = [\\n        [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    ];\\n    \\n    var result = \\'\\';\\n    var counter = 0;\\n    while (num > 0) {\\n        result = hash[counter++][num % 10] + result;\\n        num = Math.floor(num / 10);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction intToRoman(num) {\\n    var hash = [\\n        [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    ];\\n    \\n    var result = \\'\\';\\n    var counter = 0;\\n    while (num > 0) {\\n        result = hash[counter++][num % 10] + result;\\n        num = Math.floor(num / 10);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169178,
                "title": "simple-java-solution-with-treemap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass Solution {\\n\\n    public static TreeMap<Integer, String> map = new TreeMap<>();\\n\\n    static {\\n\\n        map.put(1,\"I\");\\n        map.put(5, \"V\");\\n        map.put(10, \"X\");\\n        map.put(50, \"L\");\\n        map.put(100, \"C\");\\n        map.put(500, \"D\");\\n        map.put(1000, \"M\");\\n        map.put(4, \"IV\");\\n        map.put(9, \"IX\");\\n        map.put(40, \"XL\");\\n        map.put(90, \"XC\");\\n        map.put(400, \"CD\");\\n        map.put(900, \"CM\");\\n    }\\n    public static String intToRoman(int num) {\\n        StringBuilder ans = new StringBuilder();\\n        while (num != 0) {\\n            Map.Entry<Integer, String> entry = map.floorEntry(num);\\n            ans.append(entry.getValue());\\n            num -= entry.getKey();\\n        }\\n        return ans.toString();\\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass Solution {\\n\\n    public static TreeMap<Integer, String> map = new TreeMap<>();\\n\\n    static {\\n\\n        map.put(1,\"I\");\\n        map.put(5, \"V\");\\n        map.put(10, \"X\");\\n        map.put(50, \"L\");\\n        map.put(100, \"C\");\\n        map.put(500, \"D\");\\n        map.put(1000, \"M\");\\n        map.put(4, \"IV\");\\n        map.put(9, \"IX\");\\n        map.put(40, \"XL\");\\n        map.put(90, \"XC\");\\n        map.put(400, \"CD\");\\n        map.put(900, \"CM\");\\n    }\\n    public static String intToRoman(int num) {\\n        StringBuilder ans = new StringBuilder();\\n        while (num != 0) {\\n            Map.Entry<Integer, String> entry = map.floorEntry(num);\\n            ans.append(entry.getValue());\\n            num -= entry.getKey();\\n        }\\n        return ans.toString();\\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114050,
                "title": "js-ts-clean-and-easy-solution-beats-98-5",
                "content": "```\\nfunction intToRoman(num: number): string {\\n    const rNums: Record<string,number> = {\\n      M:1000,\\n      CM:900,\\n      D:500,\\n      CD:400,\\n      C:100,\\n      XC:90,\\n      L:50,\\n      XL:40,\\n      X:10,\\n      IX:9,\\n      V:5,\\n      IV:4,\\n      I:1\\n    };\\n    let result = \\'\\';\\n    for(let rN in rNums){\\n        let count = num / rNums[rN];\\n        if(count>0) {\\n            result+= rN.repeat(count);\\n            num = num % rNums[rN];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction intToRoman(num: number): string {\\n    const rNums: Record<string,number> = {\\n      M:1000,\\n      CM:900,\\n      D:500,\\n      CD:400,\\n      C:100,\\n      XC:90,\\n      L:50,\\n      XL:40,\\n      X:10,\\n      IX:9,\\n      V:5,\\n      IV:4,\\n      I:1\\n    };\\n    let result = \\'\\';\\n    for(let rN in rNums){\\n        let count = num / rNums[rN];\\n        if(count>0) {\\n            result+= rN.repeat(count);\\n            num = num % rNums[rN];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613942,
                "title": "python-solution",
                "content": "```\\ndef intToRoman(self, num: int) -> str:\\n\\tdic = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400,\\n\\t   \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10,\\n\\t   \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\\n\\n\\toutput = \"\"\\n\\tfor key, value in dic.items():\\n\\t\\toutput += key * (num // value)\\n\\t\\tif num // value != 0:\\n\\t\\t\\tnum -= (value * (num // value))\\n\\n\\treturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef intToRoman(self, num: int) -> str:\\n\\tdic = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400,\\n\\t   \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10,\\n\\t   \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\\n\\n\\toutput = \"\"\\n\\tfor key, value in dic.items():\\n\\t\\toutput += key * (num // value)\\n\\t\\tif num // value != 0:\\n\\t\\t\\tnum -= (value * (num // value))\\n\\n\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2568037,
                "title": "javascript-simple-solution",
                "content": "```\\nvar intToRoman = function(num) {\\n    let roman = {\\n        \\'M\\':  1000, \\'CM\\': 900, \\'D\\':  500, \\'CD\\': 400,\\n        \\'C\\':  100,  \\'XC\\': 90,  \\'L\\':  50,  \\'XL\\': 40,\\n        \\'X\\':  10,   \\'IX\\': 9,   \\'V\\':  5,   \\'IV\\': 4, \\'I\\':  1\\n    },  \\n\\tromanNum = \\'\\';\\n\\t\\n    for(let i in roman){\\n        while(num >= roman[i]){\\n            romanNum += i;\\n            num -= roman[i];\\n        }\\n    }\\n    return romanNum; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intToRoman = function(num) {\\n    let roman = {\\n        \\'M\\':  1000, \\'CM\\': 900, \\'D\\':  500, \\'CD\\': 400,\\n        \\'C\\':  100,  \\'XC\\': 90,  \\'L\\':  50,  \\'XL\\': 40,\\n        \\'X\\':  10,   \\'IX\\': 9,   \\'V\\':  5,   \\'IV\\': 4, \\'I\\':  1\\n    },  \\n\\tromanNum = \\'\\';\\n\\t\\n    for(let i in roman){\\n        while(num >= roman[i]){\\n            romanNum += i;\\n            num -= roman[i];\\n        }\\n    }\\n    return romanNum; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2240419,
                "title": "c-2methods-easy-and-fast",
                "content": "**METHOD 1: Short and easy**\\n\\nEach quotient will tell how much is the value / what should be the Roman Symbol\\n\\n//KHELO DIMAAG SE XD\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n\\n```\\n\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***\\n```\\n\\n```\\n\\n**METHOD 2: correct but quite bulky ;)**\\n\\nSuppose num = 1984\\nwe split it as : 1000 + 900 + 80 + 4 \\nand at each iteration compare it\\'s value.\\n\\nSpecial cases are dealt separately. (4,9,40,90,400,90)\\n\\n80 is internally split as : 50 + 10 +10 +10\\nSEE RANGES of num in the if-else ladder \\n\\nand atlast we do num = num - val;\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int val=1;\\n        while(num>0){\\n            string ch=\"\";\\n            if(num>=1000)\\n                val=1000;\\n            else if(num>=900)\\n                val=900;\\n            else if(num>=500)\\n                val=500;\\n            else if(num>=400)\\n                val=400;\\n            else if(num>=100)\\n                val=100;\\n            else if(num>=90)\\n                val=90;\\n            else if(num>=50)\\n                val=50;\\n            else if(num>=40)\\n                val=40;\\n            else if(num>=10)\\n                val=10;\\n            else if(num==9)\\n                val=9;\\n            else if(num>=5)\\n                val=5;\\n            else if(num==4)\\n                val=4;\\n            else if(num>=1)\\n                val=1;\\n            \\n            switch(val){\\n                case 1: ch=\"I\";break;\\n                case 5: ch=\"V\";break;\\n                case 10: ch=\"X\";break;\\n                case 50: ch=\"L\";break;\\n                case 100: ch=\"C\";break;\\n                case 500: ch=\"D\";break;\\n                case 1000: ch=\"M\";break;\\n                case 4: ch=\"IV\";break;\\n                case 9: ch=\"IX\";break;\\n                case 40: ch=\"XL\";break;\\n                case 90: ch=\"XC\";break;\\n                case 400: ch=\"CD\";break;\\n                case 900: ch=\"CM\";break;\\n            }\\n            ans+=ch;\\n            num=num-val;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n\\n```\n```\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int val=1;\\n        while(num>0){\\n            string ch=\"\";\\n            if(num>=1000)\\n                val=1000;\\n            else if(num>=900)\\n                val=900;\\n            else if(num>=500)\\n                val=500;\\n            else if(num>=400)\\n                val=400;\\n            else if(num>=100)\\n                val=100;\\n            else if(num>=90)\\n                val=90;\\n            else if(num>=50)\\n                val=50;\\n            else if(num>=40)\\n                val=40;\\n            else if(num>=10)\\n                val=10;\\n            else if(num==9)\\n                val=9;\\n            else if(num>=5)\\n                val=5;\\n            else if(num==4)\\n                val=4;\\n            else if(num>=1)\\n                val=1;\\n            \\n            switch(val){\\n                case 1: ch=\"I\";break;\\n                case 5: ch=\"V\";break;\\n                case 10: ch=\"X\";break;\\n                case 50: ch=\"L\";break;\\n                case 100: ch=\"C\";break;\\n                case 500: ch=\"D\";break;\\n                case 1000: ch=\"M\";break;\\n                case 4: ch=\"IV\";break;\\n                case 9: ch=\"IX\";break;\\n                case 40: ch=\"XL\";break;\\n                case 90: ch=\"XC\";break;\\n                case 400: ch=\"CD\";break;\\n                case 900: ch=\"CM\";break;\\n            }\\n            ans+=ch;\\n            num=num-val;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311405,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] no={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] code={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<no.length;i++)\\n        {\\n            while(num >= no[i])\\n            {\\n                sb.append(code[i]);\\n                num-=no[i];\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int[] no={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] code={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<no.length;i++)\\n        {\\n            while(num >= no[i])\\n            {\\n                sb.append(code[i]);\\n                num-=no[i];\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168743,
                "title": "go-4ms-3-3mb-solution-with-0-b-op-and-0-aloc-op",
                "content": "```go\\nvar (\\n\\tr0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\\n\\tr1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\\n\\tr2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\\n\\tr3 = []string{\"\", \"M\", \"MM\", \"MMM\"}\\n)\\n\\nfunc intToRoman(num int) string {\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[num%1e4/1e3] + r2[num%1e3/1e2] + r1[num%100/10] + r0[num%10]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nvar (\\n\\tr0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\\n\\tr1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\\n\\tr2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\\n\\tr3 = []string{\"\", \"M\", \"MM\", \"MMM\"}\\n)\\n\\nfunc intToRoman(num int) string {\\n\\t// This is efficient in Go. The 4 operands are evaluated,\\n\\t// then a single allocation is made of the exact size needed for the result.\\n\\treturn r3[num%1e4/1e3] + r2[num%1e3/1e2] + r1[num%100/10] + r0[num%10]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103708,
                "title": "java-simple-and-easy-to-understand-solution-3-ms-faster-than-100-00-with-efficient-memory-usage",
                "content": "# PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\n\\n```\\nclass Solution {\\n    static String[] symbol = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n    static int[] value = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n    \\n    public String intToRoman(int num) {\\n\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = value.length - 1;\\n        \\n        //Logic\\n        //Subtract num with value[i] till num is greater than Zero, \\n        // if num is greater/equal to value[i], and append Corresponding symbol\\n        // else just move lower value\\n         \\n        while(num > 0 && i >= 0){\\n            \\n            if(num < value[i]){\\n                //just move to lower value\\n                i--;\\n            } else {\\n                //decreament num with Current value\\n                num -= value[i];\\n                \\n                //now append the corresponding symbol\\n                sb.append(symbol[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    static String[] symbol = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n    static int[] value = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n    \\n    public String intToRoman(int num) {\\n\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = value.length - 1;\\n        \\n        //Logic\\n        //Subtract num with value[i] till num is greater than Zero, \\n        // if num is greater/equal to value[i], and append Corresponding symbol\\n        // else just move lower value\\n         \\n        while(num > 0 && i >= 0){\\n            \\n            if(num < value[i]){\\n                //just move to lower value\\n                i--;\\n            } else {\\n                //decreament num with Current value\\n                num -= value[i];\\n                \\n                //now append the corresponding symbol\\n                sb.append(symbol[i]);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491557,
                "title": "python-o-log-n-o-1-100-100-simple-intuitive",
                "content": "```\\nclass Solution:\\n\\tdef intToRoman(self, num: int) -> str:\\n\\t\\tres = \"\"\\n\\t\\ts=1000\\n\\n\\t\\td = {1:\"I\", 5:\"V\", 10:\"X\", 50:\"L\", 100:\"C\", 500:\"D\", 1000:\"M\"}\\n\\n\\t\\twhile num!=0:\\n\\t\\t\\tr, temp = divmod(num, s)\\n\\n\\t\\t\\tif r==9:\\n\\t\\t\\t\\tres+=d[s]+d[s*10]\\n\\t\\t\\telif r==4:\\n\\t\\t\\t\\tres+=d[s]+d[s*5]\\n\\t\\t\\telif r>=5:\\n\\t\\t\\t\\tres+=d[s*5] + d[s]*(r-5) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += d[s]*r\\n\\n\\t\\t\\ts=s//10\\n\\t\\t\\tnum=temp\\n\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef intToRoman(self, num: int) -> str:\\n\\t\\tres = \"\"\\n\\t\\ts=1000\\n\\n\\t\\td = {1:\"I\", 5:\"V\", 10:\"X\", 50:\"L\", 100:\"C\", 500:\"D\", 1000:\"M\"}\\n\\n\\t\\twhile num!=0:\\n\\t\\t\\tr, temp = divmod(num, s)\\n\\n\\t\\t\\tif r==9:\\n\\t\\t\\t\\tres+=d[s]+d[s*10]\\n\\t\\t\\telif r==4:\\n\\t\\t\\t\\tres+=d[s]+d[s*5]\\n\\t\\t\\telif r>=5:\\n\\t\\t\\t\\tres+=d[s*5] + d[s]*(r-5) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tres += d[s]*r\\n\\n\\t\\t\\ts=s//10\\n\\t\\t\\tnum=temp\\n\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389377,
                "title": "easy-to-understand-python3",
                "content": "We are basically creating a dict for mapping the numerals, and then substracting the values from the `num` variable, starting with the highest, and on every substraction we add the corresponding roman numeral.\\n\\nYou can use an `OrderedDict` instead of having the extra list `arr` that i\\'m using, but I don\\'t think theres much of a performance difference.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        mapping = {\\n            1: \"I\",\\n            4: \"IV\",\\n            5: \"V\",\\n            9: \"IX\",\\n            10: \"X\",\\n            40: \"XL\",\\n            50: \"L\",\\n            90: \"XC\",\\n            100: \"C\",\\n            400: \"CD\",\\n            500: \"D\",\\n            900: \"CM\",\\n            1000: \"M\",\\n        }\\n        arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\n        result = \"\"\\n        for a in arr:\\n            while num >= a:\\n                num = num - a\\n                result = result + mapping[a]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        mapping = {\\n            1: \"I\",\\n            4: \"IV\",\\n            5: \"V\",\\n            9: \"IX\",\\n            10: \"X\",\\n            40: \"XL\",\\n            50: \"L\",\\n            90: \"XC\",\\n            100: \"C\",\\n            400: \"CD\",\\n            500: \"D\",\\n            900: \"CM\",\\n            1000: \"M\",\\n        }\\n        arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\\n        result = \"\"\\n        for a in arr:\\n            while num >= a:\\n                num = num - a\\n                result = result + mapping[a]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241683,
                "title": "simple-python-beats-99",
                "content": "```\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if not num: return\\n        \\n        out = \\'\\'\\n        \\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        Roman = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        for i in range (len(values)):\\n            while num >= values[i]:\\n                num -= values[i]\\n                out += Roman[i]\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if not num: return\\n        \\n        out = \\'\\'\\n        \\n        values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        Roman = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        for i in range (len(values)):\\n            while num >= values[i]:\\n                num -= values[i]\\n                out += Roman[i]\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233083,
                "title": "95-python-solution-that-s-easy-to-grok",
                "content": "While looking through the Python solutions trying to figure out how to get mine faster I was surprised that none were similar to mine, so...\\n\\n```python\\nret = \"\" \\nroman_to_int = [ \\n    (\"M\", 1000),\\n    (\"CM\", 900),\\n    (\"D\", 500),\\n    (\"CD\", 400),\\n    (\"C\", 100),\\n    (\"XC\", 90),\\n    (\"L\", 50),\\n    (\"XL\", 40),\\n    (\"X\", 10),\\n    (\"IX\", 9),\\n    (\"V\", 5),\\n    (\"IV\", 4),\\n    (\"I\", 1),\\n]\\n\\nfor roman, value in roman_to_int:\\n    while num >= value:\\n        ret += roman \\n        num -= value\\n    \\nreturn ret\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nret = \"\" \\nroman_to_int = [ \\n    (\"M\", 1000),\\n    (\"CM\", 900),\\n    (\"D\", 500),\\n    (\"CD\", 400),\\n    (\"C\", 100),\\n    (\"XC\", 90),\\n    (\"L\", 50),\\n    (\"XL\", 40),\\n    (\"X\", 10),\\n    (\"IX\", 9),\\n    (\"V\", 5),\\n    (\"IV\", 4),\\n    (\"I\", 1),\\n]\\n\\nfor roman, value in roman_to_int:\\n    while num >= value:\\n        ret += roman \\n        num -= value\\n    \\nreturn ret\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752772,
                "title": "beats-99-55-brute-force-easy-to-understand-beginner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/207d1a5c-ba36-4766-bf5d-574a7adbc53e_1690968849.1358607.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        x = \\'\\'\\n        while num!=0:\\n            if num>= 1000:\\n                x+=\\'M\\'\\n                num-=1000\\n            elif num>= 900:\\n                x+=\\'CM\\'\\n                num-=900\\n            elif num>= 500:\\n                x+=\\'D\\'\\n                num-= 500\\n            elif num>= 400: \\n                x+=\\'CD\\' \\n                num-= 400\\n            elif num>= 100:\\n                x+=\\'C\\'\\n                num-=100\\n            elif num>= 90:\\n                x+=\\'XC\\' \\n                num-=90\\n            elif num>= 50:\\n                x+=\\'L\\' \\n                num-=50\\n            elif num>= 40:\\n                x+=\\'XL\\' \\n                num-=40\\n            elif num>= 10:\\n                x+=\\'X\\' \\n                num-=10\\n            elif num>= 9:\\n                x+=\\'IX\\' \\n                num-=9\\n            elif num>= 5:\\n                x+=\\'V\\' \\n                num-=5\\n            elif num>= 4:\\n                x+=\\'IV\\' \\n                num-=4\\n            else:\\n                x+=\\'I\\'\\n                num-=1\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        x = \\'\\'\\n        while num!=0:\\n            if num>= 1000:\\n                x+=\\'M\\'\\n                num-=1000\\n            elif num>= 900:\\n                x+=\\'CM\\'\\n                num-=900\\n            elif num>= 500:\\n                x+=\\'D\\'\\n                num-= 500\\n            elif num>= 400: \\n                x+=\\'CD\\' \\n                num-= 400\\n            elif num>= 100:\\n                x+=\\'C\\'\\n                num-=100\\n            elif num>= 90:\\n                x+=\\'XC\\' \\n                num-=90\\n            elif num>= 50:\\n                x+=\\'L\\' \\n                num-=50\\n            elif num>= 40:\\n                x+=\\'XL\\' \\n                num-=40\\n            elif num>= 10:\\n                x+=\\'X\\' \\n                num-=10\\n            elif num>= 9:\\n                x+=\\'IX\\' \\n                num-=9\\n            elif num>= 5:\\n                x+=\\'V\\' \\n                num-=5\\n            elif num>= 4:\\n                x+=\\'IV\\' \\n                num-=4\\n            else:\\n                x+=\\'I\\'\\n                num-=1\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724066,
                "title": "c-solution-easy-5-line-function",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n\\n# If you liked the solution please UPVOTE \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    string intToRoman(int A) {\\n\\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\n    \\n\\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\\n\\n}\\n};\\n```\\n\\n\\n## if you reached till here and solution worked for you kindly upvote the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    string intToRoman(int A) {\\n\\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n\\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n\\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n\\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\\n\\n    \\n\\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723812,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int Value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string Symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for(int i=0;num!=0;i++)\\n        {\\n            while(num>=Value[i])\\n            {\\n                ans+=Symbol[i];\\n                num-=Value[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        int Value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string Symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        for(int i=0;num!=0;i++)\\n        {\\n            while(num>=Value[i])\\n            {\\n                ans+=Symbol[i];\\n                num-=Value[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489093,
                "title": "simple-solution-no-loop",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n     \\n    String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        \\n String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        \\nString hundreds[]=  {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        \\nString thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n\\n        \\n        return (thousands[n/1000]+\\n               hundreds[(n % 1000)/100]+\\n                tens[(n%100)/10]+\\n               units[n%10]);\\n        \\n        \\n    }\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n     \\n    String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        \\n String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        \\nString hundreds[]=  {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        \\nString thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n\\n        \\n        return (thousands[n/1000]+\\n               hundreds[(n % 1000)/100]+\\n                tens[(n%100)/10]+\\n               units[n%10]);\\n        \\n        \\n    }\\n}  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427934,
                "title": "java-solution-using-treemap",
                "content": "```\\n\\tpublic String intToRoman(int num) {\\n        TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\\n        tm.put(1,\"I\");\\n        tm.put(5,\"V\");\\n        tm.put(10,\"X\");\\n        tm.put(50,\"L\");\\n        tm.put(100,\"C\");\\n        tm.put(500,\"D\");\\n        tm.put(1000,\"M\");\\n        tm.put(4,\"IV\");\\n        tm.put(9,\"IX\");\\n        tm.put(40,\"XL\");\\n        tm.put(90,\"XC\");\\n        tm.put(400,\"CD\");\\n        tm.put(900,\"CM\");\\n        \\n        StringBuilder romanNumeral = new StringBuilder(\"\");\\n        while(num > 0){\\n            int nearestNum = tm.floorKey(num);\\n            romanNumeral.append(tm.get(nearestNum));\\n            num = num - nearestNum;\\n        }\\n        \\n        return romanNumeral.toString();\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\tpublic String intToRoman(int num) {\\n        TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\\n        tm.put(1,\"I\");\\n        tm.put(5,\"V\");\\n        tm.put(10,\"X\");\\n        tm.put(50,\"L\");\\n        tm.put(100,\"C\");\\n        tm.put(500,\"D\");\\n        tm.put(1000,\"M\");\\n        tm.put(4,\"IV\");\\n        tm.put(9,\"IX\");\\n        tm.put(40,\"XL\");\\n        tm.put(90,\"XC\");\\n        tm.put(400,\"CD\");\\n        tm.put(900,\"CM\");\\n        \\n        StringBuilder romanNumeral = new StringBuilder(\"\");\\n        while(num > 0){\\n            int nearestNum = tm.floorKey(num);\\n            romanNumeral.append(tm.get(nearestNum));\\n            num = num - nearestNum;\\n        }\\n        \\n        return romanNumeral.toString();\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140059,
                "title": "rust-o-1-super-efficient-simple-with-thorough-explanation-0ms",
                "content": "Conversion to Roman numerals is O(1) time-complexity and space complexity is also constant.\\n\\nExplanation: The array of Roman numerals from 0 to 3999 is indexed by the input value, `num`.\\n\\n\\u2728\\uD83D\\uDE01 \\u2728\\n\\n```rust\\n\\nimpl Solution {\\n    pub fn int_to_roman(num: i32) -> String {\\n        NUMERALS[num as usize].to_string()\\n    }\\n}\\n\\nconst NUMERALS: [&str; 4000] = [\\n    \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\",\"VIII\", \"IX\", \"X\", \"XI\", \\n    \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\",\\n    \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \\n    \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \\n    \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\", \"XLIV\", \"XLV\", \"XLVI\",\\n    \"XLVII\", \"XLVIII\", \"XLIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\\n    \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \\n    \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \\n    \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\",\\n    \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\\n    \"LXXXIX\", \"XC\", \"XCI\", \"XCII\", \"XCIII\", \"XCIV\", \"XCV\", \"XCVI\", \"XCVII\", \\n    \"XCVIII\", \"XCIX\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \\n    \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \\n    \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \\n    \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \\n    \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\\n    \"CXXXIX\", \"CXL\", \"CXLI\", \"CXLII\", \"CXLIII\", \"CXLIV\", \"CXLV\", \"CXLVI\", \\n    \"CXLVII\", \"CXLVIII\", \"CXLIX\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIV\", \\n    \"CLV\", \"CLVI\", \"CLVII\", \"CLVIII\", \"CLIX\", \"CLX\", \"CLXI\", \"CLXII\", \\n    \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \\n    \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \\n    \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\", \\n    \"CLXXXIII\", \"CLXXXIV\", \"CLXXXV\", \"CLXXXVI\", \"CLXXXVII\", \"CLXXXVIII\", \\n    \"CLXXXIX\", \"CXC\", \"CXCI\", \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \\n    \"CXCVII\", \"CXCVIII\", \"CXCIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \\n    \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \\n    \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \\n    \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \\n    \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \\n    \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\", \\n    \"CCXXXIX\", \"CCXL\", \"CCXLI\", \"CCXLII\", \"CCXLIII\", \"CCXLIV\", \"CCXLV\", \\n    \"CCXLVI\", \"CCXLVII\", \"CCXLVIII\", \"CCXLIX\", \"CCL\", \"CCLI\", \"CCLII\", \\n    \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\", \"CCLVIII\", \"CCLIX\", \\n    \"CCLX\", \"CCLXI\", \"CCLXII\", \"CCLXIII\", \"CCLXIV\", \"CCLXV\", \"CCLXVI\", \\n    \"CCLXVII\", \"CCLXVIII\", \"CCLXIX\", \"CCLXX\", \"CCLXXI\", \"CCLXXII\", \\n    \"CCLXXIII\", \"CCLXXIV\", \"CCLXXV\", \"CCLXXVI\", \"CCLXXVII\", \"CCLXXVIII\", \\n    \"CCLXXIX\", \"CCLXXX\", \"CCLXXXI\", \"CCLXXXII\", \"CCLXXXIII\", \"CCLXXXIV\", \\n    \"CCLXXXV\", \"CCLXXXVI\", \"CCLXXXVII\", \"CCLXXXVIII\", \"CCLXXXIX\", \"CCXC\", \\n    \"CCXCI\", \"CCXCII\", \"CCXCIII\", \"CCXCIV\", \"CCXCV\", \"CCXCVI\", \"CCXCVII\", \\n    \"CCXCVIII\", \"CCXCIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\",\\n    \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"CCCXII\", \\n    \"CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\", \"CCCXVII\", \"CCCXVIII\", \"CCCXIX\", \\n    \"CCCXX\", \"CCCXXI\", \"CCCXXII\", \"CCCXXIII\", \"CCCXXIV\", \"CCCXXV\", \\n    \"CCCXXVI\", \"CCCXXVII\", \"CCCXXVIII\", \"CCCXXIX\", \"CCCXXX\", \"CCCXXXI\", \\n    \"CCCXXXII\", \"CCCXXXIII\", \"CCCXXXIV\", \"CCCXXXV\", \"CCCXXXVI\", \"CCCXXXVII\", \\n    \"CCCXXXVIII\", \"CCCXXXIX\", \"CCCXL\", \"CCCXLI\", \"CCCXLII\", \"CCCXLIII\", \\n    \"CCCXLIV\", \"CCCXLV\", \"CCCXLVI\", \"CCCXLVII\", \"CCCXLVIII\", \"CCCXLIX\", \\n    \"CCCL\", \"CCCLI\", \"CCCLII\", \"CCCLIII\", \"CCCLIV\", \"CCCLV\", \"CCCLVI\", \\n    \"CCCLVII\", \"CCCLVIII\", \"CCCLIX\", \"CCCLX\", \"CCCLXI\", \"CCCLXII\", \\n    \"CCCLXIII\", \"CCCLXIV\", \"CCCLXV\", \"CCCLXVI\", \"CCCLXVII\", \"CCCLXVIII\", \\n    \"CCCLXIX\", \"CCCLXX\", \"CCCLXXI\", \"CCCLXXII\", \"CCCLXXIII\", \"CCCLXXIV\", \\n    \"CCCLXXV\", \"CCCLXXVI\", \"CCCLXXVII\", \"CCCLXXVIII\", \"CCCLXXIX\", \"CCCLXXX\", \\n    \"CCCLXXXI\", \"CCCLXXXII\", \"CCCLXXXIII\", \"CCCLXXXIV\", \"CCCLXXXV\", \\n    \"CCCLXXXVI\", \"CCCLXXXVII\", \"CCCLXXXVIII\", \"CCCLXXXIX\", \"CCCXC\", \\n    \"CCCXCI\", \"CCCXCII\", \"CCCXCIII\", \"CCCXCIV\", \"CCCXCV\", \"CCCXCVI\", \\n    \"CCCXCVII\", \"CCCXCVIII\", \"CCCXCIX\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \\n    \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"CDX\", \"CDXI\", \\n    \"CDXII\", \"CDXIII\", \"CDXIV\", \"CDXV\", \"CDXVI\", \"CDXVII\", \"CDXVIII\", \\n    \"CDXIX\", \"CDXX\", \"CDXXI\", \"CDXXII\", \"CDXXIII\", \"CDXXIV\", \"CDXXV\", \\n    \"CDXXVI\", \"CDXXVII\", \"CDXXVIII\", \"CDXXIX\", \"CDXXX\", \"CDXXXI\", \"CDXXXII\",\\n    \"CDXXXIII\", \"CDXXXIV\", \"CDXXXV\", \"CDXXXVI\", \"CDXXXVII\", \"CDXXXVIII\", \\n    \"CDXXXIX\", \"CDXL\", \"CDXLI\", \"CDXLII\", \"CDXLIII\", \"CDXLIV\", \"CDXLV\", \\n    \"CDXLVI\", \"CDXLVII\", \"CDXLVIII\", \"CDXLIX\", \"CDL\", \"CDLI\", \"CDLII\", \\n    \"CDLIII\", \"CDLIV\", \"CDLV\", \"CDLVI\", \"CDLVII\", \"CDLVIII\", \"CDLIX\", \\n    \"CDLX\", \"CDLXI\", \"CDLXII\", \"CDLXIII\", \"CDLXIV\", \"CDLXV\", \"CDLXVI\", \\n    \"CDLXVII\", \"CDLXVIII\", \"CDLXIX\", \"CDLXX\", \"CDLXXI\", \"CDLXXII\", \\n    \"CDLXXIII\", \"CDLXXIV\", \"CDLXXV\", \"CDLXXVI\", \"CDLXXVII\", \"CDLXXVIII\", \\n    \"CDLXXIX\", \"CDLXXX\", \"CDLXXXI\", \"CDLXXXII\", \"CDLXXXIII\", \"CDLXXXIV\", \\n    \"CDLXXXV\", \"CDLXXXVI\", \"CDLXXXVII\", \"CDLXXXVIII\", \"CDLXXXIX\", \"CDXC\", \\n    \"CDXCI\", \"CDXCII\", \"CDXCIII\", \"CDXCIV\", \"CDXCV\", \"CDXCVI\", \"CDXCVII\", \\n    \"CDXCVIII\", \"CDXCIX\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\", \"DVI\", \\n    \"DVII\", \"DVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \\n    \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \\n    \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \\n    \"DXXXII\", \"DXXXIII\", \"DXXXIV\", \"DXXXV\", \"DXXXVI\", \"DXXXVII\", \"DXXXVIII\", \\n    \"DXXXIX\", \"DXL\", \"DXLI\", \"DXLII\", \"DXLIII\", \"DXLIV\", \"DXLV\", \"DXLVI\", \\n    \"DXLVII\", \"DXLVIII\", \"DXLIX\", \"DL\", \"DLI\", \"DLII\", \"DLIII\", \"DLIV\", \\n    \"DLV\", \"DLVI\", \"DLVII\", \"DLVIII\", \"DLIX\", \"DLX\", \"DLXI\", \"DLXII\", \\n    \"DLXIII\", \"DLXIV\", \"DLXV\", \"DLXVI\", \"DLXVII\", \"DLXVIII\", \"DLXIX\", \\n    \"DLXX\", \"DLXXI\", \"DLXXII\", \"DLXXIII\", \"DLXXIV\", \"DLXXV\", \"DLXXVI\", \\n    \"DLXXVII\", \"DLXXVIII\", \"DLXXIX\", \"DLXXX\", \"DLXXXI\", \"DLXXXII\", \\n    \"DLXXXIII\", \"DLXXXIV\", \"DLXXXV\", \"DLXXXVI\", \"DLXXXVII\", \"DLXXXVIII\", \\n    \"DLXXXIX\", \"DXC\", \"DXCI\", \"DXCII\", \"DXCIII\", \"DXCIV\", \"DXCV\", \"DXCVI\", \\n    \"DXCVII\", \"DXCVIII\", \"DXCIX\", \"DC\", \"DCI\", \"DCII\", \"DCIII\", \"DCIV\", \\n    \"DCV\", \"DCVI\", \"DCVII\", \"DCVIII\", \"DCIX\", \"DCX\", \"DCXI\", \"DCXII\", \\n    \"DCXIII\", \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \\n    \"DCXX\", \"DCXXI\", \"DCXXII\", \"DCXXIII\", \"DCXXIV\", \"DCXXV\", \"DCXXVI\", \\n    \"DCXXVII\", \"DCXXVIII\", \"DCXXIX\", \"DCXXX\", \"DCXXXI\", \"DCXXXII\", \\n    \"DCXXXIII\", \"DCXXXIV\", \"DCXXXV\", \"DCXXXVI\", \"DCXXXVII\", \"DCXXXVIII\", \\n    \"DCXXXIX\", \"DCXL\", \"DCXLI\", \"DCXLII\", \"DCXLIII\", \"DCXLIV\", \"DCXLV\", \\n    \"DCXLVI\", \"DCXLVII\", \"DCXLVIII\", \"DCXLIX\", \"DCL\", \"DCLI\", \"DCLII\", \\n    \"DCLIII\", \"DCLIV\", \"DCLV\", \"DCLVI\", \"DCLVII\", \"DCLVIII\", \"DCLIX\", \\n    \"DCLX\", \"DCLXI\", \"DCLXII\", \"DCLXIII\", \"DCLXIV\", \"DCLXV\", \"DCLXVI\", \\n    \"DCLXVII\", \"DCLXVIII\", \"DCLXIX\", \"DCLXX\", \"DCLXXI\", \"DCLXXII\", \\n    \"DCLXXIII\", \"DCLXXIV\", \"DCLXXV\", \"DCLXXVI\", \"DCLXXVII\", \"DCLXXVIII\", \\n    \"DCLXXIX\", \"DCLXXX\", \"DCLXXXI\", \"DCLXXXII\", \"DCLXXXIII\", \"DCLXXXIV\", \\n    \"DCLXXXV\", \"DCLXXXVI\", \"DCLXXXVII\", \"DCLXXXVIII\", \"DCLXXXIX\", \"DCXC\", \\n    \"DCXCI\", \"DCXCII\", \"DCXCIII\", \"DCXCIV\", \"DCXCV\", \"DCXCVI\", \"DCXCVII\", \\n    \"DCXCVIII\", \"DCXCIX\", \"DCC\", \"DCCI\", \"DCCII\", \"DCCIII\", \"DCCIV\", \\n    \"DCCV\", \"DCCVI\", \"DCCVII\", \"DCCVIII\", \"DCCIX\", \"DCCX\", \"DCCXI\", \\n    \"DCCXII\", \"DCCXIII\", \"DCCXIV\", \"DCCXV\", \"DCCXVI\", \"DCCXVII\", \"DCCXVIII\",\\n    \"DCCXIX\", \"DCCXX\", \"DCCXXI\", \"DCCXXII\", \"DCCXXIII\", \"DCCXXIV\", \"DCCXXV\", \\n    \"DCCXXVI\", \"DCCXXVII\", \"DCCXXVIII\", \"DCCXXIX\", \"DCCXXX\", \"DCCXXXI\", \\n    \"DCCXXXII\", \"DCCXXXIII\", \"DCCXXXIV\", \"DCCXXXV\", \"DCCXXXVI\", \"DCCXXXVII\", \\n                        :\\n\\t\\t\\t            :   // Edited to reduce size of post, but you get the idea...\\n\\t\\t\\t\\t\\t\\t:\\n    \"MMMCMXCII\", \"MMMCMXCIII\", \"MMMCMXCIV\", \"MMMCMXCV\", \"MMMCMXCVI\",\\n    \"MMMCMXCVII\", \"MMMCMXCVIII\", \"MMMCMXCIX\"];\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n\\nimpl Solution {\\n    pub fn int_to_roman(num: i32) -> String {\\n        NUMERALS[num as usize].to_string()\\n    }\\n}\\n\\nconst NUMERALS: [&str; 4000] = [\\n    \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\",\"VIII\", \"IX\", \"X\", \"XI\", \\n    \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\",\\n    \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \\n    \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \\n    \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\", \"XLIV\", \"XLV\", \"XLVI\",\\n    \"XLVII\", \"XLVIII\", \"XLIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\\n    \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \\n    \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \\n    \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\",\\n    \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\\n    \"LXXXIX\", \"XC\", \"XCI\", \"XCII\", \"XCIII\", \"XCIV\", \"XCV\", \"XCVI\", \"XCVII\", \\n    \"XCVIII\", \"XCIX\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \\n    \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \\n    \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \\n    \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \\n    \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\\n    \"CXXXIX\", \"CXL\", \"CXLI\", \"CXLII\", \"CXLIII\", \"CXLIV\", \"CXLV\", \"CXLVI\", \\n    \"CXLVII\", \"CXLVIII\", \"CXLIX\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIV\", \\n    \"CLV\", \"CLVI\", \"CLVII\", \"CLVIII\", \"CLIX\", \"CLX\", \"CLXI\", \"CLXII\", \\n    \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \\n    \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \\n    \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\", \\n    \"CLXXXIII\", \"CLXXXIV\", \"CLXXXV\", \"CLXXXVI\", \"CLXXXVII\", \"CLXXXVIII\", \\n    \"CLXXXIX\", \"CXC\", \"CXCI\", \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \\n    \"CXCVII\", \"CXCVIII\", \"CXCIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \\n    \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \\n    \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \\n    \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \\n    \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \\n    \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\", \\n    \"CCXXXIX\", \"CCXL\", \"CCXLI\", \"CCXLII\", \"CCXLIII\", \"CCXLIV\", \"CCXLV\", \\n    \"CCXLVI\", \"CCXLVII\", \"CCXLVIII\", \"CCXLIX\", \"CCL\", \"CCLI\", \"CCLII\", \\n    \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\", \"CCLVIII\", \"CCLIX\", \\n    \"CCLX\", \"CCLXI\", \"CCLXII\", \"CCLXIII\", \"CCLXIV\", \"CCLXV\", \"CCLXVI\", \\n    \"CCLXVII\", \"CCLXVIII\", \"CCLXIX\", \"CCLXX\", \"CCLXXI\", \"CCLXXII\", \\n    \"CCLXXIII\", \"CCLXXIV\", \"CCLXXV\", \"CCLXXVI\", \"CCLXXVII\", \"CCLXXVIII\", \\n    \"CCLXXIX\", \"CCLXXX\", \"CCLXXXI\", \"CCLXXXII\", \"CCLXXXIII\", \"CCLXXXIV\", \\n    \"CCLXXXV\", \"CCLXXXVI\", \"CCLXXXVII\", \"CCLXXXVIII\", \"CCLXXXIX\", \"CCXC\", \\n    \"CCXCI\", \"CCXCII\", \"CCXCIII\", \"CCXCIV\", \"CCXCV\", \"CCXCVI\", \"CCXCVII\", \\n    \"CCXCVIII\", \"CCXCIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\",\\n    \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"CCCXII\", \\n    \"CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\", \"CCCXVII\", \"CCCXVIII\", \"CCCXIX\", \\n    \"CCCXX\", \"CCCXXI\", \"CCCXXII\", \"CCCXXIII\", \"CCCXXIV\", \"CCCXXV\", \\n    \"CCCXXVI\", \"CCCXXVII\", \"CCCXXVIII\", \"CCCXXIX\", \"CCCXXX\", \"CCCXXXI\", \\n    \"CCCXXXII\", \"CCCXXXIII\", \"CCCXXXIV\", \"CCCXXXV\", \"CCCXXXVI\", \"CCCXXXVII\", \\n    \"CCCXXXVIII\", \"CCCXXXIX\", \"CCCXL\", \"CCCXLI\", \"CCCXLII\", \"CCCXLIII\", \\n    \"CCCXLIV\", \"CCCXLV\", \"CCCXLVI\", \"CCCXLVII\", \"CCCXLVIII\", \"CCCXLIX\", \\n    \"CCCL\", \"CCCLI\", \"CCCLII\", \"CCCLIII\", \"CCCLIV\", \"CCCLV\", \"CCCLVI\", \\n    \"CCCLVII\", \"CCCLVIII\", \"CCCLIX\", \"CCCLX\", \"CCCLXI\", \"CCCLXII\", \\n    \"CCCLXIII\", \"CCCLXIV\", \"CCCLXV\", \"CCCLXVI\", \"CCCLXVII\", \"CCCLXVIII\", \\n    \"CCCLXIX\", \"CCCLXX\", \"CCCLXXI\", \"CCCLXXII\", \"CCCLXXIII\", \"CCCLXXIV\", \\n    \"CCCLXXV\", \"CCCLXXVI\", \"CCCLXXVII\", \"CCCLXXVIII\", \"CCCLXXIX\", \"CCCLXXX\", \\n    \"CCCLXXXI\", \"CCCLXXXII\", \"CCCLXXXIII\", \"CCCLXXXIV\", \"CCCLXXXV\", \\n    \"CCCLXXXVI\", \"CCCLXXXVII\", \"CCCLXXXVIII\", \"CCCLXXXIX\", \"CCCXC\", \\n    \"CCCXCI\", \"CCCXCII\", \"CCCXCIII\", \"CCCXCIV\", \"CCCXCV\", \"CCCXCVI\", \\n    \"CCCXCVII\", \"CCCXCVIII\", \"CCCXCIX\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \\n    \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"CDX\", \"CDXI\", \\n    \"CDXII\", \"CDXIII\", \"CDXIV\", \"CDXV\", \"CDXVI\", \"CDXVII\", \"CDXVIII\", \\n    \"CDXIX\", \"CDXX\", \"CDXXI\", \"CDXXII\", \"CDXXIII\", \"CDXXIV\", \"CDXXV\", \\n    \"CDXXVI\", \"CDXXVII\", \"CDXXVIII\", \"CDXXIX\", \"CDXXX\", \"CDXXXI\", \"CDXXXII\",\\n    \"CDXXXIII\", \"CDXXXIV\", \"CDXXXV\", \"CDXXXVI\", \"CDXXXVII\", \"CDXXXVIII\", \\n    \"CDXXXIX\", \"CDXL\", \"CDXLI\", \"CDXLII\", \"CDXLIII\", \"CDXLIV\", \"CDXLV\", \\n    \"CDXLVI\", \"CDXLVII\", \"CDXLVIII\", \"CDXLIX\", \"CDL\", \"CDLI\", \"CDLII\", \\n    \"CDLIII\", \"CDLIV\", \"CDLV\", \"CDLVI\", \"CDLVII\", \"CDLVIII\", \"CDLIX\", \\n    \"CDLX\", \"CDLXI\", \"CDLXII\", \"CDLXIII\", \"CDLXIV\", \"CDLXV\", \"CDLXVI\", \\n    \"CDLXVII\", \"CDLXVIII\", \"CDLXIX\", \"CDLXX\", \"CDLXXI\", \"CDLXXII\", \\n    \"CDLXXIII\", \"CDLXXIV\", \"CDLXXV\", \"CDLXXVI\", \"CDLXXVII\", \"CDLXXVIII\", \\n    \"CDLXXIX\", \"CDLXXX\", \"CDLXXXI\", \"CDLXXXII\", \"CDLXXXIII\", \"CDLXXXIV\", \\n    \"CDLXXXV\", \"CDLXXXVI\", \"CDLXXXVII\", \"CDLXXXVIII\", \"CDLXXXIX\", \"CDXC\", \\n    \"CDXCI\", \"CDXCII\", \"CDXCIII\", \"CDXCIV\", \"CDXCV\", \"CDXCVI\", \"CDXCVII\", \\n    \"CDXCVIII\", \"CDXCIX\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIV\", \"DV\", \"DVI\", \\n    \"DVII\", \"DVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \\n    \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \\n    \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \\n    \"DXXXII\", \"DXXXIII\", \"DXXXIV\", \"DXXXV\", \"DXXXVI\", \"DXXXVII\", \"DXXXVIII\", \\n    \"DXXXIX\", \"DXL\", \"DXLI\", \"DXLII\", \"DXLIII\", \"DXLIV\", \"DXLV\", \"DXLVI\", \\n    \"DXLVII\", \"DXLVIII\", \"DXLIX\", \"DL\", \"DLI\", \"DLII\", \"DLIII\", \"DLIV\", \\n    \"DLV\", \"DLVI\", \"DLVII\", \"DLVIII\", \"DLIX\", \"DLX\", \"DLXI\", \"DLXII\", \\n    \"DLXIII\", \"DLXIV\", \"DLXV\", \"DLXVI\", \"DLXVII\", \"DLXVIII\", \"DLXIX\", \\n    \"DLXX\", \"DLXXI\", \"DLXXII\", \"DLXXIII\", \"DLXXIV\", \"DLXXV\", \"DLXXVI\", \\n    \"DLXXVII\", \"DLXXVIII\", \"DLXXIX\", \"DLXXX\", \"DLXXXI\", \"DLXXXII\", \\n    \"DLXXXIII\", \"DLXXXIV\", \"DLXXXV\", \"DLXXXVI\", \"DLXXXVII\", \"DLXXXVIII\", \\n    \"DLXXXIX\", \"DXC\", \"DXCI\", \"DXCII\", \"DXCIII\", \"DXCIV\", \"DXCV\", \"DXCVI\", \\n    \"DXCVII\", \"DXCVIII\", \"DXCIX\", \"DC\", \"DCI\", \"DCII\", \"DCIII\", \"DCIV\", \\n    \"DCV\", \"DCVI\", \"DCVII\", \"DCVIII\", \"DCIX\", \"DCX\", \"DCXI\", \"DCXII\", \\n    \"DCXIII\", \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \\n    \"DCXX\", \"DCXXI\", \"DCXXII\", \"DCXXIII\", \"DCXXIV\", \"DCXXV\", \"DCXXVI\", \\n    \"DCXXVII\", \"DCXXVIII\", \"DCXXIX\", \"DCXXX\", \"DCXXXI\", \"DCXXXII\", \\n    \"DCXXXIII\", \"DCXXXIV\", \"DCXXXV\", \"DCXXXVI\", \"DCXXXVII\", \"DCXXXVIII\", \\n    \"DCXXXIX\", \"DCXL\", \"DCXLI\", \"DCXLII\", \"DCXLIII\", \"DCXLIV\", \"DCXLV\", \\n    \"DCXLVI\", \"DCXLVII\", \"DCXLVIII\", \"DCXLIX\", \"DCL\", \"DCLI\", \"DCLII\", \\n    \"DCLIII\", \"DCLIV\", \"DCLV\", \"DCLVI\", \"DCLVII\", \"DCLVIII\", \"DCLIX\", \\n    \"DCLX\", \"DCLXI\", \"DCLXII\", \"DCLXIII\", \"DCLXIV\", \"DCLXV\", \"DCLXVI\", \\n    \"DCLXVII\", \"DCLXVIII\", \"DCLXIX\", \"DCLXX\", \"DCLXXI\", \"DCLXXII\", \\n    \"DCLXXIII\", \"DCLXXIV\", \"DCLXXV\", \"DCLXXVI\", \"DCLXXVII\", \"DCLXXVIII\", \\n    \"DCLXXIX\", \"DCLXXX\", \"DCLXXXI\", \"DCLXXXII\", \"DCLXXXIII\", \"DCLXXXIV\", \\n    \"DCLXXXV\", \"DCLXXXVI\", \"DCLXXXVII\", \"DCLXXXVIII\", \"DCLXXXIX\", \"DCXC\", \\n    \"DCXCI\", \"DCXCII\", \"DCXCIII\", \"DCXCIV\", \"DCXCV\", \"DCXCVI\", \"DCXCVII\", \\n    \"DCXCVIII\", \"DCXCIX\", \"DCC\", \"DCCI\", \"DCCII\", \"DCCIII\", \"DCCIV\", \\n    \"DCCV\", \"DCCVI\", \"DCCVII\", \"DCCVIII\", \"DCCIX\", \"DCCX\", \"DCCXI\", \\n    \"DCCXII\", \"DCCXIII\", \"DCCXIV\", \"DCCXV\", \"DCCXVI\", \"DCCXVII\", \"DCCXVIII\",\\n    \"DCCXIX\", \"DCCXX\", \"DCCXXI\", \"DCCXXII\", \"DCCXXIII\", \"DCCXXIV\", \"DCCXXV\", \\n    \"DCCXXVI\", \"DCCXXVII\", \"DCCXXVIII\", \"DCCXXIX\", \"DCCXXX\", \"DCCXXXI\", \\n    \"DCCXXXII\", \"DCCXXXIII\", \"DCCXXXIV\", \"DCCXXXV\", \"DCCXXXVI\", \"DCCXXXVII\", \\n                        :\\n\\t\\t\\t            :   // Edited to reduce size of post, but you get the idea...\\n\\t\\t\\t\\t\\t\\t:\\n    \"MMMCMXCII\", \"MMMCMXCIII\", \"MMMCMXCIV\", \"MMMCMXCV\", \"MMMCMXCVI\",\\n    \"MMMCMXCVII\", \"MMMCMXCVIII\", \"MMMCMXCIX\"];\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018967,
                "title": "very-easy-c-solution-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> in={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        vector<string> roman={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<(int)in.size();i++)\\n        {\\n            int count=num/in[i];\\n            while(count--)\\n            {\\n                res+=roman[i];\\n            }\\n            num=num%in[i];\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> in={1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 1980870,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/6KqgMr3S/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/6KqgMr3S/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1847281,
                "title": "python-solution",
                "content": "Please Upvote\\n\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        result = \\'\\'\\n        \\n        for k in d.keys():\\n            result += (num // k) * d[k]\\n            num %= k\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        result = \\'\\'\\n        \\n        for k in d.keys():\\n            result += (num // k) * d[k]\\n            num %= k\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759934,
                "title": "python3-solution-100-faster",
                "content": "**Solution - 1**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\\n```\\n\\n**Solution - 2**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\',\\'\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit%5 == 4: ans = values[i] + values[i + 1 + int(digit==9)] + ans\\n            else: ans = values[i+1]*int(digit>=5) + values[i]*(digit%5) + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```\\n\\n**Solution - 3**\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit == 4: ans = values[i] + values[i + 1] + ans\\n            elif digit == 9: ans = values[i] + values[i + 2] + ans\\n            elif digit >= 5: ans = values[i+1] + values[i]*(digit-5) + ans\\n            else: ans = values[i]*digit + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        M = [\"\", \"M\", \"MM\", \"MMM\"]\\n        C = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\\n        X = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\\n        I = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\\n        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\',\\'\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit%5 == 4: ans = values[i] + values[i + 1 + int(digit==9)] + ans\\n            else: ans = values[i+1]*int(digit>=5) + values[i]*(digit%5) + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        values = [\\'I\\',\\'V\\',\\'X\\',\\'L\\',\\'C\\',\\'D\\',\\'M\\']\\n        ans,i = \\'\\',0\\n        while num:\\n            digit = num%10\\n            if digit == 4: ans = values[i] + values[i + 1] + ans\\n            elif digit == 9: ans = values[i] + values[i + 2] + ans\\n            elif digit >= 5: ans = values[i+1] + values[i]*(digit-5) + ans\\n            else: ans = values[i]*digit + ans\\n            num //= 10\\n            i += 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410013,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-integer-to-roman",
                "content": "# Simple and elegant solution\\n```\\nstring intToRoman(int number) {\\n        int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n    string sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n    int i=12;  \\n    int d;\\n    string ans=\"\";\\n    while(number>0)\\n    {\\n        d = number/num[i];\\n      number = number%num[i];\\n      while(d--)\\n      {\\n        ans+=sym[i];\\n      }\\n      i--;\\n    }\\n     return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nstring intToRoman(int number) {\\n        int num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n    string sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n    int i=12;  \\n    int d;\\n    string ans=\"\";\\n    while(number>0)\\n    {\\n        d = number/num[i];\\n      number = number%num[i];\\n      while(d--)\\n      {\\n        ans+=sym[i];\\n      }\\n      i--;\\n    }\\n     return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354615,
                "title": "simple-java-solution-100-faster",
                "content": "``` class Solution {\\n    private static int[] keys = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};      \\n    private static String[] values = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    \\n    public String intToRoman(int num) {\\n        StringBuilder s = new StringBuilder();\\n        int counter = 0;\\n        \\n        \\n        while(num > 0){\\n            if(num >= keys[counter]){\\n                s.append(values[counter]);\\n                num -= keys[counter];\\n            }\\n            else\\n                counter++;\\n        }\\n        \\n        return s.toString();\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "``` class Solution {\\n    private static int[] keys = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};      \\n    private static String[] values = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n    \\n    public String intToRoman(int num) {\\n        StringBuilder s = new StringBuilder();\\n        int counter = 0;\\n        \\n        \\n        while(num > 0){\\n            if(num >= keys[counter]){\\n                s.append(values[counter]);\\n                num -= keys[counter];\\n            }\\n            else\\n                counter++;\\n        }\\n        \\n        return s.toString();\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1202412,
                "title": "easy-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        int numbers[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string romans[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        string res;\\n        \\n        for(int i=0; i<13; i++)\\n        {\\n            while(num >= numbers[i])\\n            {\\n                num -= numbers[i];\\n                res += romans[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        int numbers[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string romans[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        string res;\\n        \\n        for(int i=0; i<13; i++)\\n        {\\n            while(num >= numbers[i])\\n            {\\n                num -= numbers[i];\\n                res += romans[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216081,
                "title": "swift-solution",
                "content": "class Solution {\\n    func intToRoman(_ num: Int) -> String {\\n        if num == 0 {\\n            return \"\"\\n        } else if num >= 1000 {\\n            return \"M\" + intToRoman(num - 1000)\\n        } else if num >= 900 {\\n            return \"CM\" + intToRoman(num - 900)\\n        } else if num >= 500 {\\n            return \"D\" + intToRoman(num - 500)\\n        } else if num >= 400 {\\n            return \"CD\" + intToRoman(num - 400)\\n        } else if num >= 100 {\\n            return \"C\" + intToRoman(num - 100)\\n        } else if num >= 90 {\\n            return \"XC\" + intToRoman(num - 90)\\n        } else if num >= 50 {\\n            return \"L\" + intToRoman(num - 50)\\n        } else if num >= 40 {\\n            return \"XL\" + intToRoman(num - 40)\\n        } else if num >= 10 {\\n            return \"X\" + intToRoman(num - 10)\\n        } else if num >= 9 {\\n            return \"IX\" + intToRoman(num - 9)\\n        } else if num >= 5 {\\n            return \"V\" + intToRoman(num - 5)\\n        } else if num >= 4 {\\n            return \"IV\" + intToRoman(num - 4)\\n        } else if num > 0 {\\n            return \"I\" + intToRoman(num - 1)\\n        }\\n        \\n        return \"\"\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func intToRoman(_ num: Int) -> String {\\n        if num == 0 {\\n            return \"\"\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 188598,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n  public String intToRoman(int num) {\\n        \\n        return convert(num,new String());\\n        \\n    }\\n    \\n   public String convert(int num, String res){\\n        \\n        if(num == 0) return res;\\n        else if(num >= 1000) return convert(num - 1000, res +\"M\");\\n        else if(num >= 900) return convert(num - 900, res +\"CM\");\\n        else if(num >= 500) return convert(num - 500, res +\"D\");\\n        else if(num >= 400) return convert(num - 400, res +\"CD\");\\n        else if(num >= 100) return convert(num - 100, res +\"C\");\\n        else if(num >= 90) return convert(num - 90, res +\"XC\");\\n        else if(num >= 50) return convert(num - 50, res +\"L\");\\n        else if(num >= 40) return convert(num - 40, res +\"XL\");\\n        else if(num >= 10) return convert(num - 10, res +\"X\");\\n        else if(num >= 9) return convert(num - 9, res +\"IX\");\\n        else if(num >= 5) return convert(num - 5, res +\"V\");\\n        else if(num >= 4) return convert(num - 4, res +\"IV\");\\n        else if(num == 3) return convert(num - 3, res +\"III\");\\n        else if(num == 2) return convert(num - 2, res +\"II\");\\n        else if(num == 1) return convert(num - 1, res +\"I\");\\n        \\n        return null;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String intToRoman(int num) {\\n        \\n        return convert(num,new String());\\n        \\n    }\\n    \\n   public String convert(int num, String res){\\n        \\n        if(num == 0) return res;\\n        else if(num >= 1000) return convert(num - 1000, res +\"M\");\\n        else if(num >= 900) return convert(num - 900, res +\"CM\");\\n        else if(num >= 500) return convert(num - 500, res +\"D\");\\n        else if(num >= 400) return convert(num - 400, res +\"CD\");\\n        else if(num >= 100) return convert(num - 100, res +\"C\");\\n        else if(num >= 90) return convert(num - 90, res +\"XC\");\\n        else if(num >= 50) return convert(num - 50, res +\"L\");\\n        else if(num >= 40) return convert(num - 40, res +\"XL\");\\n        else if(num >= 10) return convert(num - 10, res +\"X\");\\n        else if(num >= 9) return convert(num - 9, res +\"IX\");\\n        else if(num >= 5) return convert(num - 5, res +\"V\");\\n        else if(num >= 4) return convert(num - 4, res +\"IV\");\\n        else if(num == 3) return convert(num - 3, res +\"III\");\\n        else if(num == 2) return convert(num - 2, res +\"II\");\\n        else if(num == 1) return convert(num - 1, res +\"I\");\\n        \\n        return null;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6388,
                "title": "my-java-solution",
                "content": "\\n\\n\\n        String res = \"\";\\n        String[] c = new String[]{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int[] n = new int[]{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        int i = 12;\\n        while(num > 0 && i>=0){\\n            if(num >= n[i]){\\n                res += c[i];\\n                num -= n[i];\\n            }else{\\n                i--;\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\n\\n\\n        String res = \"\";\\n        String[] c = new String[]{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int[] n = new int[]{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        int i = 12;\\n        while(num > 0 && i>=0){\\n            if(num >= n[i]){\\n                res += c[i];\\n                num -= n[i];\\n            }else{\\n                i--;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 6451,
                "title": "my-easy-understanding-solution",
                "content": "\\n    string intToRoman(int num) \\n    {   \\n        string s;  \\n    \\n        while (num > 0)\\n        {   \\n            if (num >= 1000) {s += \"M\"; num-=1000; continue;}\\n            if (num >= 900)  {s += \"CM\"; num-=900; continue;}\\n            if (num >= 500)  {s += \"D\"; num-=500; continue;}\\n            if (num >= 400)  {s += \"CD\"; num-=400; continue;}\\n            if (num >= 100)  {s += \"C\"; num-=100; continue;}\\n            if (num >= 90)   {s += \"XC\"; num-=90; continue;}\\n            if (num >= 50)   {s += \"L\"; num-=50; continue;}\\n            if (num >= 40)   {s += \"XL\"; num-=40; continue;}\\n            if (num >= 10)   {s += \"X\"; num-=10; continue;}\\n            if (num >= 9)    {s += \"IX\"; num-=9; continue;}\\n            if (num >= 5)    {s += \"V\"; num-=5; continue;}\\n            if (num >= 4)    {s += \"IV\"; num-=4; continue;}\\n            if (num == 3)    {s += \"III\"; num-=3; continue;}\\n            if (num == 2)    {s += \"II\"; num-=2; continue;}\\n            if (num == 1)    {s += \"I\"; num-=1; continue;}\\n        }   \\n    \\n        return s;\\n    }",
                "solutionTags": [],
                "code": "\\n    string intToRoman(int num) \\n    {   \\n        string s;  \\n    \\n        while (num > 0)\\n        {   \\n            if (num >= 1000) {s += \"M\"; num-=1000; continue;}\\n            if (num >= 900)  {s += \"CM\"; num-=900; continue;}\\n            if (num >= 500)  {s += \"D\"; num-=500; continue;}\\n            if (num >= 400)  {s += \"CD\"; num-=400; continue;}\\n            if (num >= 100)  {s += \"C\"; num-=100; continue;}\\n            if (num >= 90)   {s += \"XC\"; num-=90; continue;}\\n            if (num >= 50)   {s += \"L\"; num-=50; continue;}\\n            if (num >= 40)   {s += \"XL\"; num-=40; continue;}\\n            if (num >= 10)   {s += \"X\"; num-=10; continue;}\\n            if (num >= 9)    {s += \"IX\"; num-=9; continue;}\\n            if (num >= 5)    {s += \"V\"; num-=5; continue;}\\n            if (num >= 4)    {s += \"IV\"; num-=4; continue;}\\n            if (num == 3)    {s += \"III\"; num-=3; continue;}\\n            if (num == 2)    {s += \"II\"; num-=2; continue;}\\n            if (num == 1)    {s += \"I\"; num-=1; continue;}\\n        }   \\n    \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3618408,
                "title": "beats-100-by-using-subtraction-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> v1={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\\n                           \"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        vector<int> v2={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string res=\"\";\\n        for(int i=0; num>0; i++){\\n            while(num>=v2[i]){\\n                res=res+v1[i];\\n                num=num-v2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<string> v1={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\\n                           \"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        vector<int> v2={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string res=\"\";\\n        for(int i=0; num>0; i++){\\n            while(num>=v2[i]){\\n                res=res+v1[i];\\n                num=num-v2[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724994,
                "title": "java-without-extended-dictionary",
                "content": "```\\npublic String intToRoman(int number) {\\n        Map<Integer, Character> map = Map.of(1, \\'I\\', 5, \\'V\\', 10, \\'X\\', 50, \\'L\\', 100, \\'C\\', 500, \\'D\\', 1000, \\'M\\');\\n        StringBuilder roman = new StringBuilder();\\n\\n        int multiplier = 1;\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            if (digit == 4 || digit == 9)\\n                roman.insert(0, \"\" + map.get(multiplier) + map.get((digit + 1) * multiplier));\\n            else\\n                roman.insert(0,  (digit >= 5 ? map.get(5 * multiplier) : \"\") + (map.get(multiplier).toString().repeat(digit >= 5 ? digit - 5 : digit)));\\n\\n            number = number / 10; multiplier *= 10;\\n        }\\n\\n        return roman.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String intToRoman(int number) {\\n        Map<Integer, Character> map = Map.of(1, \\'I\\', 5, \\'V\\', 10, \\'X\\', 50, \\'L\\', 100, \\'C\\', 500, \\'D\\', 1000, \\'M\\');\\n        StringBuilder roman = new StringBuilder();\\n\\n        int multiplier = 1;\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            if (digit == 4 || digit == 9)\\n                roman.insert(0, \"\" + map.get(multiplier) + map.get((digit + 1) * multiplier));\\n            else\\n                roman.insert(0,  (digit >= 5 ? map.get(5 * multiplier) : \"\") + (map.get(multiplier).toString().repeat(digit >= 5 ? digit - 5 : digit)));\\n\\n            number = number / 10; multiplier *= 10;\\n        }\\n\\n        return roman.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724574,
                "title": "go-simple-recursion",
                "content": "Please Upvote if you like the solution \\n\\n```\\nfunc intToRoman(num int) string {\\n    return getRoman(num, \"\")\\n}\\n\\nfunc getRoman(num int, roman string) string {\\n    if num == 0 {\\n        return roman\\n    }\\n    \\n    if num - 1000 >= 0 {\\n        return getRoman(num-1000, roman + \"M\")\\n    }\\n    \\n    if num - 900 >= 0 {\\n        return getRoman(num-900, roman + \"CM\")\\n    }\\n    \\n    if num - 500 >= 0 {\\n        return getRoman(num-500, roman + \"D\")\\n    }\\n    \\n    if num - 400 >= 0 {\\n        return getRoman(num-400, roman + \"CD\")\\n    }\\n    \\n    if num - 100 >= 0 {\\n        return getRoman(num-100, roman + \"C\")\\n    }\\n    \\n    if num - 90 >= 0 {\\n        return getRoman(num-90, roman + \"XC\")\\n    }\\n    \\n    if num - 50 >= 0 {\\n        return getRoman(num-50, roman + \"L\")\\n    }\\n    \\n    if num - 40 >= 0 {\\n        return getRoman(num-40, roman + \"XL\")\\n    }\\n    \\n    if num - 10 >= 0 {\\n        return getRoman(num-10, roman + \"X\")\\n    }\\n    \\n    if num - 9 >= 0 {\\n        return getRoman(num-9, roman + \"IX\")\\n    }\\n    \\n    if num - 5 >= 0 {\\n        return getRoman(num-5, roman + \"V\")\\n    }\\n    \\n    if num - 4 >= 0 {\\n        return getRoman(num-4, roman + \"IV\")\\n    }\\n    \\n    if num - 1 >= 0 {\\n        return getRoman(num-1, roman + \"I\")\\n    }\\n     \\n    return roman\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc intToRoman(num int) string {\\n    return getRoman(num, \"\")\\n}\\n\\nfunc getRoman(num int, roman string) string {\\n    if num == 0 {\\n        return roman\\n    }\\n    \\n    if num - 1000 >= 0 {\\n        return getRoman(num-1000, roman + \"M\")\\n    }\\n    \\n    if num - 900 >= 0 {\\n        return getRoman(num-900, roman + \"CM\")\\n    }\\n    \\n    if num - 500 >= 0 {\\n        return getRoman(num-500, roman + \"D\")\\n    }\\n    \\n    if num - 400 >= 0 {\\n        return getRoman(num-400, roman + \"CD\")\\n    }\\n    \\n    if num - 100 >= 0 {\\n        return getRoman(num-100, roman + \"C\")\\n    }\\n    \\n    if num - 90 >= 0 {\\n        return getRoman(num-90, roman + \"XC\")\\n    }\\n    \\n    if num - 50 >= 0 {\\n        return getRoman(num-50, roman + \"L\")\\n    }\\n    \\n    if num - 40 >= 0 {\\n        return getRoman(num-40, roman + \"XL\")\\n    }\\n    \\n    if num - 10 >= 0 {\\n        return getRoman(num-10, roman + \"X\")\\n    }\\n    \\n    if num - 9 >= 0 {\\n        return getRoman(num-9, roman + \"IX\")\\n    }\\n    \\n    if num - 5 >= 0 {\\n        return getRoman(num-5, roman + \"V\")\\n    }\\n    \\n    if num - 4 >= 0 {\\n        return getRoman(num-4, roman + \"IV\")\\n    }\\n    \\n    if num - 1 >= 0 {\\n        return getRoman(num-1, roman + \"I\")\\n    }\\n     \\n    return roman\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336437,
                "title": "easy-explanation-commented-c",
                "content": "Initially we need to store all the integer values which have specific roman values.\\nThen we will extract the key in sorted order (biggest to smallest) and check again and again if number is greater than the key then subtract the key from number and also add the roman in the answer.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        // map is decreasing sorted by key\\n        map<int, string, greater<int>> m;\\n        m[1000] = \"M\";\\n        m[900] = \"CM\";\\n        m[500] = \"D\";\\n        m[400] = \"CD\";\\n        m[100] = \"C\";\\n        m[90] = \"XC\";\\n        m[50] = \"L\";\\n        m[40] = \"XL\";\\n        m[10] = \"X\";\\n        m[9] = \"IX\";\\n        m[5] = \"V\";\\n        m[4] = \"IV\";\\n        m[1] = \"I\";\\n        \\n        string ans = \"\";\\n\\t\\t// take pair from map\\n        for(auto p: m)\\n        {\\n            // if number is lesser or equal to key then add\\n            while(num >= p.first)\\n            {\\n                ans += p.second;\\n                num -= p.first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        // map is decreasing sorted by key\\n        map<int, string, greater<int>> m;\\n        m[1000] = \"M\";\\n        m[900] = \"CM\";\\n        m[500] = \"D\";\\n        m[400] = \"CD\";\\n        m[100] = \"C\";\\n        m[90] = \"XC\";\\n        m[50] = \"L\";\\n        m[40] = \"XL\";\\n        m[10] = \"X\";\\n        m[9] = \"IX\";\\n        m[5] = \"V\";\\n        m[4] = \"IV\";\\n        m[1] = \"I\";\\n        \\n        string ans = \"\";\\n\\t\\t// take pair from map\\n        for(auto p: m)\\n        {\\n            // if number is lesser or equal to key then add\\n            while(num >= p.first)\\n            {\\n                ans += p.second;\\n                num -= p.first;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2162067,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans;\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        int i=0;\\n        while(num){\\n            \\n            while(val[i]<=num){\\n                num-=val[i];\\n                ans+=sym[i];\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote and thank you**\\n\\n**Feel Free to ask questions**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans;\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        \\n        int i=0;\\n        while(num){\\n            \\n            while(val[i]<=num){\\n                num-=val[i];\\n                ans+=sym[i];\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371192,
                "title": "c-no-recursion",
                "content": "```\\nstring intToRoman(int num) {\\n     vector<string> ones ={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        vector<string>tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        vector<string>hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        vector<string>thousand = {\"\",\"M\",\"MM\",\"MMM\"};\\n        return thousand[num/1000]+hundreds[num%1000/100]+tens[num%100/10]+ones[num%10];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) {\\n     vector<string> ones ={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        vector<string>tens = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        vector<string>hundreds = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        vector<string>thousand = {\"\",\"M\",\"MM\",\"MMM\"};\\n        return thousand[num/1000]+hundreds[num%1000/100]+tens[num%100/10]+ones[num%10];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316412,
                "title": "simple-javascript-solution-beats-99-5",
                "content": "```\\n// 124ms 99.5%, 44MB 97.8%\\nconst symbolToValue = {\\n    \"M\" : 1000,\\n    \"CM\": 900,\\n    \"D\" : 500,\\n    \"CD\": 400,\\n    \"C\" : 100,\\n    \"XC\": 90,\\n    \"L\" : 50,\\n    \"XL\": 40,\\n    \"X\" : 10,\\n    \"IX\": 9,\\n    \"V\" : 5,\\n    \"IV\": 4,\\n    \"I\" : 1,\\n}\\n\\nvar intToRoman = function(num) {\\n    let finalStr = \"\";\\n    for (s in symbolToValue){\\n        const v = symbolToValue[s];\\n        while (num >= v){\\n            num -= v;\\n            finalStr += s;\\n        }    \\n    }\\n    return finalStr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 124ms 99.5%, 44MB 97.8%\\nconst symbolToValue = {\\n    \"M\" : 1000,\\n    \"CM\": 900,\\n    \"D\" : 500,\\n    \"CD\": 400,\\n    \"C\" : 100,\\n    \"XC\": 90,\\n    \"L\" : 50,\\n    \"XL\": 40,\\n    \"X\" : 10,\\n    \"IX\": 9,\\n    \"V\" : 5,\\n    \"IV\": 4,\\n    \"I\" : 1,\\n}\\n\\nvar intToRoman = function(num) {\\n    let finalStr = \"\";\\n    for (s in symbolToValue){\\n        const v = symbolToValue[s];\\n        while (num >= v){\\n            num -= v;\\n            finalStr += s;\\n        }    \\n    }\\n    return finalStr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812398,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String hundreds[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return thousands[num/1000]+\\n                hundreds[(num%1000)/100]+\\n                tens[(num%100)/10]+\\n                units[num%10];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String units[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        String tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        String hundreds[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        String thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return thousands[num/1000]+\\n                hundreds[(num%1000)/100]+\\n                tens[(num%100)/10]+\\n                units[num%10];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757248,
                "title": "c-solution",
                "content": "```\\nstring intToRoman(int num) {\\n\\tvector<string> roman {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tvector<int> no {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\tstring ans = \"\";\\n\\tfor(int i=0; num != 0; i++){\\n\\t\\twhile(num >= no[i]){\\n\\t\\t\\tnum -= no[i];\\n\\t\\t\\tans += roman[i];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num) {\\n\\tvector<string> roman {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tvector<int> no {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n\\tstring ans = \"\";\\n\\tfor(int i=0; num != 0; i++){\\n\\t\\twhile(num >= no[i]){\\n\\t\\t\\tnum -= no[i];\\n\\t\\t\\tans += roman[i];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657354,
                "title": "java-beatiful-solution",
                "content": "```\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        String[] romanNums = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] arabNums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int index = 0;\\n        \\n        while (num > 0) {\\n            int mult = num / arabNums[index];\\n            \\n            if (mult > 0) {\\n                num %= arabNums[index];\\n                sb.append(romanNums[index].repeat(mult));\\n                // sb.append(String.join(\"\", Collections.nCopies(mult, romanNums[index])));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        String[] romanNums = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] arabNums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int index = 0;\\n        \\n        while (num > 0) {\\n            int mult = num / arabNums[index];\\n            \\n            if (mult > 0) {\\n                num %= arabNums[index];\\n                sb.append(romanNums[index].repeat(mult));\\n                // sb.append(String.join(\"\", Collections.nCopies(mult, romanNums[index])));\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657129,
                "title": "my-c-solution-without-hardcoding-all-the-numerals",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string intToRoman(int num)\\n    {       \\n        string res = \"\";\\n        string s[] = {\"I\", \"X\", \"C\", \"M\", \"V\", \"L\", \"D\", \"\"};\\n        int i = 0;\\n        while (num)\\n        {\\n            switch(num % 10)\\n            {\\n                case 1: res.insert(0, s[i]); break;\\n                case 2: res.insert(0, s[i] + s[i]); break;\\n                case 3: res.insert(0, s[i] + s[i] + s[i]); break;\\n                case 4: res.insert(0, s[i] + s[i + 4]); break;\\n                case 5: res.insert(0, s[i + 4]); break;\\n                case 6: res.insert(0, s[i + 4] + s[i]); break;\\n                case 7: res.insert(0, s[i + 4] + s[i] + s[i]); break;\\n                case 8: res.insert(0, s[i + 4] + s[i] + s[i] + s[i]); break;\\n                case 9: res.insert(0, s[i] + s[i + 1]); break;  \\n            }\\n            num /= 10;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string intToRoman(int num)\\n    {       \\n        string res = \"\";\\n        string s[] = {\"I\", \"X\", \"C\", \"M\", \"V\", \"L\", \"D\", \"\"};\\n        int i = 0;\\n        while (num)\\n        {\\n            switch(num % 10)\\n            {\\n                case 1: res.insert(0, s[i]); break;\\n                case 2: res.insert(0, s[i] + s[i]); break;\\n                case 3: res.insert(0, s[i] + s[i] + s[i]); break;\\n                case 4: res.insert(0, s[i] + s[i + 4]); break;\\n                case 5: res.insert(0, s[i + 4]); break;\\n                case 6: res.insert(0, s[i + 4] + s[i]); break;\\n                case 7: res.insert(0, s[i + 4] + s[i] + s[i]); break;\\n                case 8: res.insert(0, s[i + 4] + s[i] + s[i] + s[i]); break;\\n                case 9: res.insert(0, s[i] + s[i + 1]); break;  \\n            }\\n            num /= 10;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389923,
                "title": "faster-than-98-6-javascript",
                "content": "```\\nvar intToRoman = function(num) {\\n    var digit, r = \\'\\';\\n    var convert = (digit, tens, fives, ones) => {\\n        if(digit === 9) { r = r.concat(ones + tens); }\\n        else if(digit > 5) { r = r.concat(fives + ones.repeat(digit % 5)); }\\n        else if(digit === 5) { r = r.concat(fives); }\\n        else if(digit === 4) { r = r.concat(ones + fives); }\\n        else if(digit > 0) { r = r.concat(ones.repeat(digit)) }\\n    };\\n    \\n    if(num > 999) { convert(Math.floor(num/1000), \\'\\', \\'\\', \\'M\\');\\n        num = Math.floor(num%1000);\\n    }\\n    if(num > 99) { convert(Math.floor(num/100), \\'M\\', \\'D\\', \\'C\\');\\n        num = Math.floor(num%100);\\n    }\\n    if(num > 9) { convert(Math.floor(num/10), \\'C\\', \\'L\\', \\'X\\');\\n        num = Math.floor(num%10);\\n    }\\n    convert(num, \\'X\\', \\'V\\', \\'I\\');\\n    return r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intToRoman = function(num) {\\n    var digit, r = \\'\\';\\n    var convert = (digit, tens, fives, ones) => {\\n        if(digit === 9) { r = r.concat(ones + tens); }\\n        else if(digit > 5) { r = r.concat(fives + ones.repeat(digit % 5)); }\\n        else if(digit === 5) { r = r.concat(fives); }\\n        else if(digit === 4) { r = r.concat(ones + fives); }\\n        else if(digit > 0) { r = r.concat(ones.repeat(digit)) }\\n    };\\n    \\n    if(num > 999) { convert(Math.floor(num/1000), \\'\\', \\'\\', \\'M\\');\\n        num = Math.floor(num%1000);\\n    }\\n    if(num > 99) { convert(Math.floor(num/100), \\'M\\', \\'D\\', \\'C\\');\\n        num = Math.floor(num%100);\\n    }\\n    if(num > 9) { convert(Math.floor(num/10), \\'C\\', \\'L\\', \\'X\\');\\n        num = Math.floor(num%10);\\n    }\\n    convert(num, \\'X\\', \\'V\\', \\'I\\');\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342992,
                "title": "java-solution-beats-100-100",
                "content": "```\\npublic String intToRoman(int num) {        \\n\\tString[] romans = new String[]{\"M\", \"CM\", \"D\", \"CD\", \\n\\t\\t\\t\\t\\t\\t\\t\\t   \"C\", \"XC\", \"L\", \"XL\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tint[] numbers = new int[]{1000, 900, 500, 400,\\n\\t\\t\\t\\t\\t\\t\\t 100, 90, 50, 40,\\n\\t\\t\\t\\t\\t\\t\\t 10, 9, 5, 4, 1};\\n\\tStringBuilder romanRes = new StringBuilder();\\n\\tfor (int i = 0; i < romans.length; i++) {\\n\\t\\tif (num == 0) break;\\n\\t\\tint count = num/numbers[i];\\n\\t\\twhile (count > 0) {\\n\\t\\t\\tromanRes.append(romans[i]);\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tnum = num % numbers[i];\\n\\t}\\n\\n\\treturn romanRes.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String intToRoman(int num) {        \\n\\tString[] romans = new String[]{\"M\", \"CM\", \"D\", \"CD\", \\n\\t\\t\\t\\t\\t\\t\\t\\t   \"C\", \"XC\", \"L\", \"XL\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n\\tint[] numbers = new int[]{1000, 900, 500, 400,\\n\\t\\t\\t\\t\\t\\t\\t 100, 90, 50, 40,\\n\\t\\t\\t\\t\\t\\t\\t 10, 9, 5, 4, 1};\\n\\tStringBuilder romanRes = new StringBuilder();\\n\\tfor (int i = 0; i < romans.length; i++) {\\n\\t\\tif (num == 0) break;\\n\\t\\tint count = num/numbers[i];\\n\\t\\twhile (count > 0) {\\n\\t\\t\\tromanRes.append(romans[i]);\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t\\tnum = num % numbers[i];\\n\\t}\\n\\n\\treturn romanRes.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279026,
                "title": "c-solution-12ms-and-7-4mb-beats-100",
                "content": "```\\n#define ROMAN_SUM_TYPE_COUNT 13\\n\\nstruct RomanItem\\n{\\n\\tint interSum;\\n    char *romanStr;\\n};\\n\\nchar* intToRoman(int num) {\\n    char *answer = (char *)malloc(sizeof(char) * 50);\\n    answer[0] = \\'\\\\0\\';\\n    int quotient = 0;\\n    struct RomanItem romanArray[ROMAN_SUM_TYPE_COUNT] = {{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"},\\n        {900, \"CM\"}, {1000, \"M\"}};\\n    \\n    for (int i = ROMAN_SUM_TYPE_COUNT - 1; i >= 0; i--)\\n    {\\n        quotient = num/romanArray[i].interSum;\\n        while(quotient > 0)\\n        {\\n            strcat(answer, romanArray[i].romanStr);\\n            quotient--;\\n        }\\n        num = num % romanArray[i].interSum;\\n    }\\n    return answer;\\n}\\n```\\n\\ni had tried to solve this solution without enumeration but it\\'s more clearer and eaiser by enumeration...",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ROMAN_SUM_TYPE_COUNT 13\\n\\nstruct RomanItem\\n{\\n\\tint interSum;\\n    char *romanStr;\\n};\\n\\nchar* intToRoman(int num) {\\n    char *answer = (char *)malloc(sizeof(char) * 50);\\n    answer[0] = \\'\\\\0\\';\\n    int quotient = 0;\\n    struct RomanItem romanArray[ROMAN_SUM_TYPE_COUNT] = {{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"},\\n        {900, \"CM\"}, {1000, \"M\"}};\\n    \\n    for (int i = ROMAN_SUM_TYPE_COUNT - 1; i >= 0; i--)\\n    {\\n        quotient = num/romanArray[i].interSum;\\n        while(quotient > 0)\\n        {\\n            strcat(answer, romanArray[i].romanStr);\\n            quotient--;\\n        }\\n        num = num % romanArray[i].interSum;\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256455,
                "title": "a-top-1-10-concise-c-solution",
                "content": "The speed of this solution varies depending on run, but it\\'s always in top 10%.\\nNote: order by key in descending order in \\'foreach\\' is not required by this runtime \\u2014 it follows declaration order.\\n\\n```\\npublic class Solution \\n{\\n    public string IntToRoman(int num) \\n    {\\n        var result = new StringBuilder();\\n        var map = new Dictionary<int, string>\\n        {\\n            { 1000, \"M\" },\\n            { 900, \"CM\" },\\n            { 500, \"D\" },\\n            { 400, \"CD\" },\\n            { 100, \"C\" },\\n            { 90, \"XC\" },\\n            { 50, \"L\" },\\n            { 40, \"XL\" },\\n            { 10, \"X\" },\\n            { 9, \"IX\" },\\n            { 5, \"V\" },\\n            { 4, \"IV\" },\\n            { 1, \"I\" },\\n        };\\n        \\n        foreach (var kv in map)  \\n        {\\n            while (num >= kv.Key)\\n            {\\n                num -= kv.Key;\\n                result.Append(kv.Value);\\n            }\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string IntToRoman(int num) \\n    {\\n        var result = new StringBuilder();\\n        var map = new Dictionary<int, string>\\n        {\\n            { 1000, \"M\" },\\n            { 900, \"CM\" },\\n            { 500, \"D\" },\\n            { 400, \"CD\" },\\n            { 100, \"C\" },\\n            { 90, \"XC\" },\\n            { 50, \"L\" },\\n            { 40, \"XL\" },\\n            { 10, \"X\" },\\n            { 9, \"IX\" },\\n            { 5, \"V\" },\\n            { 4, \"IV\" },\\n            { 1, \"I\" },\\n        };\\n        \\n        foreach (var kv in map)  \\n        {\\n            while (num >= kv.Key)\\n            {\\n                num -= kv.Key;\\n                result.Append(kv.Value);\\n            }\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196579,
                "title": "javascript-98",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\n /* value, str mapping */\\n const mapping = [\\n    [1000, \\'M\\'], [900, \\'CM\\'], [500, \\'D\\'], [400, \\'CD\\'], [100, \\'C\\'], [90, \\'XC\\'], [50, \\'L\\'], [40, \\'XL\\'], [10, \\'X\\'], [9, \\'IX\\'], [5, \\'V\\'], [4, \\'IV\\'], [1, \\'I\\']\\n];\\n\\nvar intToRoman = function(num) {\\n    let str = \\'\\';\\n\\n    for (let i = 0; i < mapping.length; i++) {\\n        const [val, char] = mapping[i];\\n\\n        if (num >= val) {\\n            while (num >= val) {\\n                num -= val;\\n                str += char;\\n            }\\n        }\\n    }\\n\\n    return str;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\n /* value, str mapping */\\n const mapping = [\\n    [1000, \\'M\\'], [900, \\'CM\\'], [500, \\'D\\'], [400, \\'CD\\'], [100, \\'C\\'], [90, \\'XC\\'], [50, \\'L\\'], [40, \\'XL\\'], [10, \\'X\\'], [9, \\'IX\\'], [5, \\'V\\'], [4, \\'IV\\'], [1, \\'I\\']\\n];\\n\\nvar intToRoman = function(num) {\\n    let str = \\'\\';\\n\\n    for (let i = 0; i < mapping.length; i++) {\\n        const [val, char] = mapping[i];\\n\\n        if (num >= val) {\\n            while (num >= val) {\\n                num -= val;\\n                str += char;\\n            }\\n        }\\n    }\\n\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059438,
                "title": "best-o-1-solution",
                "content": "# Approach 1\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> s = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector <int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        string ans = \"\";\\n        int i = value.size() - 1; \\n        while (i >= 0 ) {\\n            if (num < value[i]) {\\n                i--;\\n            } else {\\n                ans += s[i];\\n                num -= value[i];\\n            }    \\n        }\\n        return ans;\\n};\\n```\\n\\n# Approach 2\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector <string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector <string> hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector <string> ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> s = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        vector <int> value = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        string ans = \"\";\\n        int i = value.size() - 1; \\n        while (i >= 0 ) {\\n            if (num < value[i]) {\\n                i--;\\n            } else {\\n                ans += s[i];\\n                num -= value[i];\\n            }    \\n        }\\n        return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector <string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        vector <string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        vector <string> hrns = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        vector <string> ths = {\"\", \"M\", \"MM\", \"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722581,
                "title": "take-this-simple-sol-with-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_mapping = {\\n            1000: \\'M\\',\\n            900: \\'CM\\',\\n            500: \\'D\\',\\n            400: \\'CD\\',\\n            100: \\'C\\',\\n            90: \\'XC\\',\\n            50: \\'L\\',\\n            40: \\'XL\\',\\n            10: \\'X\\',\\n            9: \\'IX\\',\\n            5: \\'V\\',\\n            4: \\'IV\\',\\n            1: \\'I\\'\\n        }\\n        result = \"\"\\n        for value, symbol in roman_mapping.items():\\n            while num >= value:\\n                result += symbol\\n                num -= value\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_mapping = {\\n            1000: \\'M\\',\\n            900: \\'CM\\',\\n            500: \\'D\\',\\n            400: \\'CD\\',\\n            100: \\'C\\',\\n            90: \\'XC\\',\\n            50: \\'L\\',\\n            40: \\'XL\\',\\n            10: \\'X\\',\\n            9: \\'IX\\',\\n            5: \\'V\\',\\n            4: \\'IV\\',\\n            1: \\'I\\'\\n        }\\n        result = \"\"\\n        for value, symbol in roman_mapping.items():\\n            while num >= value:\\n                result += symbol\\n                num -= value\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423552,
                "title": "simple-c-solution-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    // creating int to roman map.\\n    unordered_map<int,char>itor={\\n        {1,\\'I\\'},{5,\\'V\\'},{10,\\'X\\'},{50,\\'L\\'},{100,\\'C\\'},{500,\\'D\\'},{1000,\\'M\\'}\\n    };\\n    // reverse the string.\\n    void reverse(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    // main function.\\n    string intToRoman(int num) {\\n        \\n        string res=\"\";\\n        //Multiplier to determine once,tens... places\\n        int mul=1;\\n        while(num)\\n        {\\n            int x=num%10; //last digit\\n            num/=10; //removing last digit from num.\\n            if(x==0) //if zero then move to next digit (with increasing multiplier).\\n            {\\n                mul*=10;\\n                continue;\\n            }\\n            // we have two cases 4 and 9 then make b=5 || 10.\\n            int b=-1;\\n            if(x==4)\\n                b=5;\\n            else if(x==9)\\n                b=10;\\n            \\n            if(b==-1) //if last digit is not 4||9 then simply add I. for 3= III\\n            {\\n                while(x)\\n                {\\n                    if(x==5)\\n                    {\\n                        res+=itor[5*mul];\\n                        x-=5;\\n                    }\\n                    else\\n                    {\\n                        res+=itor[1*mul];\\n                        x-=1;\\n                    }\\n                }\\n            }\\n            else // if(last digit is 4||9) then add IV or IX to res.\\n            {\\n                res+=itor[b*mul];\\n                res+=itor[1*mul];\\n            }\\n            mul*=10;\\n        }\\n        //we traversed from lsb to msb so reverse the string.\\n        reverse(res);\\n        return res;\\n        // remember if 4 comes then we add VI to res so that reverse will be IV.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // creating int to roman map.\\n    unordered_map<int,char>itor={\\n        {1,\\'I\\'},{5,\\'V\\'},{10,\\'X\\'},{50,\\'L\\'},{100,\\'C\\'},{500,\\'D\\'},{1000,\\'M\\'}\\n    };\\n    // reverse the string.\\n    void reverse(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    // main function.\\n    string intToRoman(int num) {\\n        \\n        string res=\"\";\\n        //Multiplier to determine once,tens... places\\n        int mul=1;\\n        while(num)\\n        {\\n            int x=num%10; //last digit\\n            num/=10; //removing last digit from num.\\n            if(x==0) //if zero then move to next digit (with increasing multiplier).\\n            {\\n                mul*=10;\\n                continue;\\n            }\\n            // we have two cases 4 and 9 then make b=5 || 10.\\n            int b=-1;\\n            if(x==4)\\n                b=5;\\n            else if(x==9)\\n                b=10;\\n            \\n            if(b==-1) //if last digit is not 4||9 then simply add I. for 3= III\\n            {\\n                while(x)\\n                {\\n                    if(x==5)\\n                    {\\n                        res+=itor[5*mul];\\n                        x-=5;\\n                    }\\n                    else\\n                    {\\n                        res+=itor[1*mul];\\n                        x-=1;\\n                    }\\n                }\\n            }\\n            else // if(last digit is 4||9) then add IV or IX to res.\\n            {\\n                res+=itor[b*mul];\\n                res+=itor[1*mul];\\n            }\\n            mul*=10;\\n        }\\n        //we traversed from lsb to msb so reverse the string.\\n        reverse(res);\\n        return res;\\n        // remember if 4 comes then we add VI to res so that reverse will be IV.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366255,
                "title": "c-simple-and-clean-solution",
                "content": "Please Upvote if it helped you !!!\\nHappy Coding :)\\n```\\nstring intToRoman(int num) \\n    {\\n        string answer=\"\";\\n        string ones[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hundreds[] ={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        answer=thousands[num/1000]+hundreds[(num%1000)/100]+tens[(num%100)/10]+ones[num%10];\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring intToRoman(int num) \\n    {\\n        string answer=\"\";\\n        string ones[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hundreds[] ={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string thousands[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        answer=thousands[num/1000]+hundreds[(num%1000)/100]+tens[(num%100)/10]+ones[num%10];\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924307,
                "title": "java-intuitive-easy-to-understand-and-remember-solution-100-faster-fully-extensible-too",
                "content": "There are two solutions in this post. The second approach is based on the first approach. \\nThe second approach supports adding new symbols or loading them in runtime without changing the code, one important aspect in code design. (e.g. S.O.L.I.D)\\n\\nThe main idea is to get each digit from left to right of the input `num`, convert each digit to Roman numeral(s) according to the Substraction rules and Mappings at the bottom of the post, and combine them as the final result.\\n\\nFor example: the mappings below are examples for [1,10).\\n\\n```\\n1  -> I\\n2  -> II\\n3  -> III\\n4  -> IV (not IIII)\\n5  -> V\\n6  -> VI\\n7  -> VII\\n8  -> VIII\\n9  -> IX (not VIIII)\\n```\\nThe mappings above are coded in the method `intToRoman` below, with \"I\", \"V\", \"X\" passed as arguments for the case of [1,10).\\n\\t`intToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234`\\n\\nThe same principle applies to tens, hundreds, and thousands when a single digit is considered and mapped to its respective Roman symbols. \\n\\nSee the mappings at the bottom of the post for tens, hundreds, and thousands.\\n\\nThe solution below is intuitive and easy to understand and remember, which is what matters during interviews.\\n\\n\\n```\\nclass Solution {\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tintToRoman(rs, num / 1000, \"M\", \"\", \"\"); //get 1 in 1234\\n\\t\\tintToRoman(rs, num / 100 % 10, \"C\", \"D\", \"M\"); //get 2 in 1234\\n\\t\\tintToRoman(rs, num / 10 % 10, \"X\", \"L\", \"C\");  //get 3 in 1234\\n\\t\\tintToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n //Comments are an example of [1,10)\\n  private void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num)); //this is I, or II, or III, one could be I, X C, M depending on whether it is under tens, tens, hundreds, or thousands\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five); //this is IV\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five); //this V\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5)); //this is VI, or VII, or VIII\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten); //this is IX\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nHope it helps.\\n\\nPlease upvote if it does.\\n\\nFor completeness, below are the references\\n**The Substraction Rules:**\\n```\\n There are six instances where subtraction is used:\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\\n**The Mappings:**\\n```\\n(\\'I\\', 1)\\n(\\'V\\', 5)\\n(\\'X\\', 10)\\n(\\'L\\', 50)\\n(\\'C\\', 100)\\n(\\'D\\', 500)\\n(\\'M\\', 1000)\\n```\\n\\nExamples\\n```\\n3 -> III\\n58- > LVIII\\n1994 -> MCMXCIV\\n```\\nScore (the score is not constant for some reason)\\n![image](https://assets.leetcode.com/users/images/bef342b3-9f4d-4769-8315-5cc924e5c8ff_1649363126.5775585.jpeg)\\n\\n**Follow Up**\\nThe benefit of this method is fully extensible. If it has to support larger number over the current limit, new mappings can be added in `map` variable, even during runtime, the rest of the code remains unchanged.\\n\\nFor example, adding new symbols or loading them in runtime is like below:\\n   \\n   `itr.map.add(new String[] { \"M\", \"\", \"\" });`\\n   \\nThis is the important and bonus point if asked during an interview.\\n\\n```\\nclass Solution {\\n\\n\\tpublic static List<String[]> map = new ArrayList<String[]>();//public for runtime call\\n\\tstatic {\\n\\t\\tmap.add(new String[] { \"I\", \"V\", \"X\" });\\n\\t\\tmap.add(new String[] { \"X\", \"L\", \"C\" });\\n\\t\\tmap.add(new String[] { \"C\", \"D\", \"M\" });\\n\\t\\tmap.add(new String[] { \"M\", \"\", \"\" });\\n\\t}\\n\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tint n = map.size();\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tintToRoman(rs, num / ((int) Math.pow(10, i)) % 10, map.get(i)[0], map.get(i)[1], map.get(i)[2]);\\n\\t\\t}\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n\\tprivate void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num));\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five);\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five);\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5));\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\nPlease upvote if it helps.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1  -> I\\n2  -> II\\n3  -> III\\n4  -> IV (not IIII)\\n5  -> V\\n6  -> VI\\n7  -> VII\\n8  -> VIII\\n9  -> IX (not VIIII)\\n```\n```\\nclass Solution {\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tintToRoman(rs, num / 1000, \"M\", \"\", \"\"); //get 1 in 1234\\n\\t\\tintToRoman(rs, num / 100 % 10, \"C\", \"D\", \"M\"); //get 2 in 1234\\n\\t\\tintToRoman(rs, num / 10 % 10, \"X\", \"L\", \"C\");  //get 3 in 1234\\n\\t\\tintToRoman(rs, num % 10, \"I\", \"V\", \"X\"); //get 4 in 1234\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n //Comments are an example of [1,10)\\n  private void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num)); //this is I, or II, or III, one could be I, X C, M depending on whether it is under tens, tens, hundreds, or thousands\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five); //this is IV\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five); //this V\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5)); //this is VI, or VII, or VIII\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten); //this is IX\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\n There are six instances where subtraction is used:\\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\n```\n```\\n(\\'I\\', 1)\\n(\\'V\\', 5)\\n(\\'X\\', 10)\\n(\\'L\\', 50)\\n(\\'C\\', 100)\\n(\\'D\\', 500)\\n(\\'M\\', 1000)\\n```\n```\\n3 -> III\\n58- > LVIII\\n1994 -> MCMXCIV\\n```\n```\\nclass Solution {\\n\\n\\tpublic static List<String[]> map = new ArrayList<String[]>();//public for runtime call\\n\\tstatic {\\n\\t\\tmap.add(new String[] { \"I\", \"V\", \"X\" });\\n\\t\\tmap.add(new String[] { \"X\", \"L\", \"C\" });\\n\\t\\tmap.add(new String[] { \"C\", \"D\", \"M\" });\\n\\t\\tmap.add(new String[] { \"M\", \"\", \"\" });\\n\\t}\\n\\n\\tpublic String intToRoman(int num) {\\n\\t\\tStringBuilder rs = new StringBuilder();\\n\\t\\tint n = map.size();\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tintToRoman(rs, num / ((int) Math.pow(10, i)) % 10, map.get(i)[0], map.get(i)[1], map.get(i)[2]);\\n\\t\\t}\\n\\t\\treturn rs.toString();\\n\\t}\\n\\n\\tprivate void intToRoman(StringBuilder sb, int num, String one, String five, String ten) {\\n\\t\\tif (1 <= num) {\\n\\t\\t\\tif (num < 4) {\\n\\t\\t\\t\\tsb.append(one.repeat(num));\\n\\t\\t\\t} else if (num < 5) { // num >= 4 && num < 5)\\n\\t\\t\\t\\tsb.append(one).append(five);\\n\\t\\t\\t} else if (num == 5) {\\n\\t\\t\\t\\tsb.append(five);\\n\\t\\t\\t} else if (num < 9) { // num > 5 && num < 9\\n\\t\\t\\t\\tsb.append(five).append(one.repeat(num - 5));\\n\\t\\t\\t} else { // num >= 9 && num < 10\\n\\t\\t\\t\\tsb.append(one).append(ten);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872499,
                "title": "c-java-solution-greedy",
                "content": "**Intuition**\\nGreedily always subtract the maximal roman number equivalent value from ```num```.\\n\\n**Complexity**\\n- Time: O(1)\\n- Space: O(1)\\n\\n**Implementation**\\n- C#\\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        \\n        if(num < 1)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        string[] roman = new string[]{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] nums = new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string res = \"\";\\n        int i = 0;\\n        \\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }            \\n            i++;  \\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n- Java\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        \\n        String[] roman = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```num```\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        \\n        if(num < 1)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        string[] roman = new string[]{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        int[] nums = new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        \\n        string res = \"\";\\n        int i = 0;\\n        \\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }            \\n            i++;  \\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        \\n        String[] roman = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int[] nums = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0)\\n        {\\n            while(num >= nums[i])\\n            {\\n                res += roman[i];\\n                num -= nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799449,
                "title": "clear-c-solution-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int integer[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[13]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<13;i++){\\n            while(num>=integer[i]){\\n                res+=roman[i];\\n                num-=integer[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        int integer[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[13]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string res=\"\";\\n        for(int i=0;i<13;i++){\\n            while(num>=integer[i]){\\n                res+=roman[i];\\n                num-=integer[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776923,
                "title": "go-simple-solution",
                "content": "```   \\nfunc intToRoman(num int) string {\\n    symbol := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\\n    value := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\\n    \\n    result := \"\"\\n    \\n    for num > 0{\\n        for i := range value{\\n            if num >= value[i]{\\n                result += symbol[i] \\n                num -= value[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```   \\nfunc intToRoman(num int) string {\\n    symbol := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\\n    value := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\\n    \\n    result := \"\"\\n    \\n    for num > 0{\\n        for i := range value{\\n            if num >= value[i]{\\n                result += symbol[i] \\n                num -= value[i]\\n                break\\n            }\\n        }\\n    }\\n    return result\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644959,
                "title": "optimised-solution-3ms-38-3mb",
                "content": "class Solution {\\n\\n    public String intToRoman(int num) {\\n       StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        String[] roman = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        for (int i = 0; i < div.length;) {\\n            if (num >= div[i]) {\\n                result.append(roman[i]);\\n                num -= div[i];\\n            } \\n            else i++;\\n        }\\n        \\n        return result.toString();  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public String intToRoman(int num) {\\n       StringBuilder result = new StringBuilder();\\n        int[] div = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1511574,
                "title": "cpp-solution-easy-to-understand",
                "content": "**Please upvote if you like the solution** \\n\\nCode ->\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        string ans;\\nstring symbol[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        for(int i=0; num != 0; i++)\\n        {\\n            while(num >= val[i])\\n            {\\n                num -= val[i];\\n                ans += symbol[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        string ans;\\nstring symbol[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        \\n        for(int i=0; num != 0; i++)\\n        {\\n            while(num >= val[i])\\n            {\\n                num -= val[i];\\n                ans += symbol[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448993,
                "title": "python-easiest-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        translation = {\\n            \\'M\\': 1000,\\n            \\'CM\\': 900,\\n            \\'D\\': 500,\\n            \\'CD\\': 400,\\n            \\'C\\': 100,\\n            \\'XC\\': 90,\\n            \\'L\\': 50,\\n            \\'XL\\': 40,\\n            \\'X\\': 10,\\n            \\'IX\\': 9,\\n            \\'V\\': 5,\\n            \\'IV\\': 4,\\n            \\'I\\': 1,\\n        }\\n        out = \\'\\'\\n        for s,n in translation.items():\\n            out += num // n * s\\n            num %= n\\n        \\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        translation = {\\n            \\'M\\': 1000,\\n            \\'CM\\': 900,\\n            \\'D\\': 500,\\n            \\'CD\\': 400,\\n            \\'C\\': 100,\\n            \\'XC\\': 90,\\n            \\'L\\': 50,\\n            \\'XL\\': 40,\\n            \\'X\\': 10,\\n            \\'IX\\': 9,\\n            \\'V\\': 5,\\n            \\'IV\\': 4,\\n            \\'I\\': 1,\\n        }\\n        out = \\'\\'\\n        for s,n in translation.items():\\n            out += num // n * s\\n            num %= n\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396382,
                "title": "python-95-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_dict = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100,\\n                     \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5,\\n                     \"IV\": 4, \"I\": 1}\\n        output = \"\"\\n        while num >= 1:\\n            for key in roman_dict.keys():\\n                if num - roman_dict[key] >= 0:\\n                    output += key\\n                    num -= roman_dict[key]\\n                    break\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        roman_dict = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100,\\n                     \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5,\\n                     \"IV\": 4, \"I\": 1}\\n        output = \"\"\\n        while num >= 1:\\n            for key in roman_dict.keys():\\n                if num - roman_dict[key] >= 0:\\n                    output += key\\n                    num -= roman_dict[key]\\n                    break\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343815,
                "title": "c-solution-simple-short-and-clear",
                "content": "```\\nstring intToRoman(int num)\\n    {\\n        string symbol[13] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int number[13] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}; \\n        int i = 12;\\n        string ans = \"\";\\n        \\n        while(num > 0)\\n        {\\n            int count = num / number[i];\\n            num = num % number[i];\\n            \\n            while(count--)\\n            {\\n                ans = ans + symbol[i];\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num)\\n    {\\n        string symbol[13] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int number[13] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}; \\n        int i = 12;\\n        string ans = \"\";\\n        \\n        while(num > 0)\\n        {\\n            int count = num / number[i];\\n            num = num % number[i];\\n            \\n            while(count--)\\n            {\\n                ans = ans + symbol[i];\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1250878,
                "title": "easy-python-logic",
                "content": "Instead of the dictionary you can also use two lists.\\n```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d={\\n            1000:\\'M\\',\\n            900:\\'CM\\',\\n            500:\\'D\\',\\n            400:\\'CD\\',\\n            100:\\'C\\',\\n            90:\\'XC\\',\\n            50:\\'L\\',\\n            40:\\'XL\\',\\n            10:\\'X\\',\\n            9:\\'IX\\',\\n            5:\\'V\\',\\n            4:\\'IV\\',\\n            1:\\'I\\'\\n        }\\n        s=\"\"\\n        while num!=0:\\n            for i in d.keys():\\n                if num>=i:\\n                    s+=d[i]\\n                    num-=i\\n                    break\\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d={\\n            1000:\\'M\\',\\n            900:\\'CM\\',\\n            500:\\'D\\',\\n            400:\\'CD\\',\\n            100:\\'C\\',\\n            90:\\'XC\\',\\n            50:\\'L\\',\\n            40:\\'XL\\',\\n            10:\\'X\\',\\n            9:\\'IX\\',\\n            5:\\'V\\',\\n            4:\\'IV\\',\\n            1:\\'I\\'\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1210718,
                "title": "c-upper-bound-clean-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        map<int, string> mp = {{1,\"I\"}, \\n                               {5,\"V\"}, \\n                               {10,\"X\"}, \\n                               {50,\"L\"}, \\n                               {100,\"C\"}, \\n                               {500,\"D\"}, \\n                               {1000,\"M\"}, \\n                               {4,\"IV\"}, \\n                               {9,\"IX\"}, \\n                               {40,\"XL\"},\\n                               {90,\"XC\"},\\n                               {400,\"CD\"},\\n                               {900,\"CM\"}};   \\n        string ans;\\n        while(num > 0){\\n            auto it = --mp.upper_bound(num);\\n            num -= (it->first);\\n            ans += (it->second);\\n        }\\n        return ans;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        \\n        map<int, string> mp = {{1,\"I\"}, \\n                               {5,\"V\"}, \\n                               {10,\"X\"}, \\n                               {50,\"L\"}, \\n                               {100,\"C\"}, \\n                               {500,\"D\"}, \\n                               {1000,\"M\"}, \\n                               {4,\"IV\"}, \\n                               {9,\"IX\"}, \\n                               {40,\"XL\"},\\n                               {90,\"XC\"},\\n                               {400,\"CD\"},\\n                               {900,\"CM\"}};   \\n        string ans;\\n        while(num > 0){\\n            auto it = --mp.upper_bound(num);\\n            num -= (it->first);\\n            ans += (it->second);\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184992,
                "title": "python3-simple-and-easy-to-understand-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        s = \\'\\'\\n        for i in d.keys():\\n            s += (num//i)*d[i]\\n            num %= i\\n        return s\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000: \\'M\\', 900: \\'CM\\', 500: \\'D\\', 400: \\'CD\\', 100: \\'C\\', 90: \\'XC\\', 50: \\'L\\', 40: \\'XL\\', 10: \\'X\\', 9: \\'IX\\', 5: \\'V\\', 4: \\'IV\\', 1: \\'I\\'}\\n        s = \\'\\'\\n        for i in d.keys():\\n            s += (num//i)*d[i]\\n            num %= i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103918,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> values{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        vector<string> roman{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int idx=roman.size()-1;\\n        \\n        string ans;\\n        while(num>0){\\n            while(num<values[idx])\\n                idx--;\\n            int count=num/values[idx];\\n            num=num-count*values[idx];\\n            while(count--){\\n                ans+=roman[idx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** \\nO(1) as num is limited to 3999 only. \\nO(n) if num is very very large and we need add \"M\" to string multiple times (Not given in constraints).\\n\\nWhy O(1) ? \\nReason - In worst case it will take constant(3) calls for some values[i] and value size is also constant to 13. \\nSo runtime will be < 13 * 3 only => *O(39) ~ O(1)*\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<int> values{1,4,5,9,10,40,50,90,100,400,500,900,1000};\\n        vector<string> roman{\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\\n        int idx=roman.size()-1;\\n        \\n        string ans;\\n        while(num>0){\\n            while(num<values[idx])\\n                idx--;\\n            int count=num/values[idx];\\n            num=num-count*values[idx];\\n            while(count--){\\n                ans+=roman[idx];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103010,
                "title": "clean-correct-python-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        vals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        res=\\'\\'\\n        \\n        for i,v in enumerate(vals):\\n            \\n            res += (num//v) * romans[i];\\n            num %= v\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        \\n        vals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]\\n        romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\\n        \\n        res=\\'\\'\\n        \\n        for i,v in enumerate(vals):\\n            \\n            res += (num//v) * romans[i];\\n            num %= v\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625791,
                "title": "golang-8ms",
                "content": "```go\\nimport \"strings\"\\n\\ntype node struct {\\n    val int\\n    s string\\n}\\n\\nvar romanNodes = []node{\\n    {1000, \"M\"},\\n    {900, \"CM\"},\\n    {500, \"D\"},\\n    {400, \"CD\"},\\n    {100, \"C\"},\\n    {90, \"XC\"},\\n    {50, \"L\"},\\n    {40, \"XL\"},\\n    {10, \"X\"},\\n    {9, \"IX\"},\\n    {5, \"V\"},\\n    {4, \"IV\"},\\n    {1, \"I\"},\\n}\\n\\nfunc intToRoman(num int) string {\\n    sb := strings.Builder{}\\n    \\n    for _, n := range romanNodes {\\n        for num >= n.val {\\n            sb.WriteString(n.s)\\n            num -= n.val\\n        }   \\n    }\\n    \\n    return sb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"strings\"\\n\\ntype node struct {\\n    val int\\n    s string\\n}\\n\\nvar romanNodes = []node{\\n    {1000, \"M\"},\\n    {900, \"CM\"},\\n    {500, \"D\"},\\n    {400, \"CD\"},\\n    {100, \"C\"},\\n    {90, \"XC\"},\\n    {50, \"L\"},\\n    {40, \"XL\"},\\n    {10, \"X\"},\\n    {9, \"IX\"},\\n    {5, \"V\"},\\n    {4, \"IV\"},\\n    {1, \"I\"},\\n}\\n\\nfunc intToRoman(num int) string {\\n    sb := strings.Builder{}\\n    \\n    for _, n := range romanNodes {\\n        for num >= n.val {\\n            sb.WriteString(n.s)\\n            num -= n.val\\n        }   \\n    }\\n    \\n    return sb.String()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 544197,
                "title": "easy-java-solution-self-explanatory",
                "content": "class Solution {\\n    public String intToRoman(int num) {\\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n     String[] romanLiterals = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n    StringBuilder roman = new StringBuilder();\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i]){\\n                roman.append(romanLiterals[i]);\\n                    num-=values[i];\\n            }\\n            \\n        }\\n        return roman.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String intToRoman(int num) {\\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1}",
                "codeTag": "Java"
            },
            {
                "id": 318386,
                "title": "java-4-ms-faster-than-69-85-36-1-mb-less-than-99-98",
                "content": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n       String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int n) {\\n       String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262432,
                "title": "faster-than-100-00-of-java",
                "content": "Runtime: 4 ms, faster than 100.00% of Java online submissions for Integer to Roman.\\nMemory Usage: 37.6 MB, less than 100.00% of Java online submissions for Integer to Roman.\\n```java \\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder  result = new StringBuilder();\\n        int[] nums = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] chars= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        while(num!=0){\\n            for(int i =0; i<nums.length;i++){\\n                if(num>=nums[i]){\\n                    result.append(chars[i]);\\n                    num-=nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```\\n\\u8FD9\\u9898\\u6CA1\\u5565\\u610F\\u4E49\\u554A",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java \\nclass Solution {\\n    public String intToRoman(int num) {\\n        StringBuilder  result = new StringBuilder();\\n        int[] nums = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String[] chars= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        while(num!=0){\\n            for(int i =0; i<nums.length;i++){\\n                if(num>=nums[i]){\\n                    result.append(chars[i]);\\n                    num-=nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222715,
                "title": "java-57-ms-beats-95-5-no-map-used-easy-understand",
                "content": "```\\nclass Solution {\\n    int[] nums = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    String[] symbols = new String[] {\\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < nums.length && num > 0; i++) {\\n            int cnt = num / nums[i];\\n            while (cnt-- > 0) {\\n                sb.append(symbols[i]);\\n            }\\n            num %= nums[i];\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    String[] symbols = new String[] {\\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\\n    };\\n    public String intToRoman(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < nums.length && num > 0; i++) {\\n            int cnt = num / nums[i];\\n            while (cnt-- > 0) {\\n                sb.append(symbols[i]);\\n            }\\n            num %= nums[i];\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6343,
                "title": "my-c-solution-beat-95",
                "content": "```\\nstring intToRoman(int num) {\\n        int i=0;\\n        string a = \"IVXLCDM\", res = \"\";\\n        while(num)\\n        {\\n            int temp = num%10;\\n            if(temp<=3) res = string(temp,a[i])+res;\\n            else if(temp==4) res = string(1,a[i])+string(1,a[i+1])+res;\\n            else if(temp==5) res = string(1,a[i+1])+res;\\n            else if(temp<=8) res = string(1,a[i+1])+string(temp-5,a[i])+res;\\n            else if(temp==9) res = string(1,a[i])+string(1,a[i+2])+res;\\n            num = num/10;\\n            i += 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring intToRoman(int num) {\\n        int i=0;\\n        string a = \"IVXLCDM\", res = \"\";\\n        while(num)\\n        {\\n            int temp = num%10;\\n            if(temp<=3) res = string(temp,a[i])+res;\\n            else if(temp==4) res = string(1,a[i])+string(1,a[i+1])+res;\\n            else if(temp==5) res = string(1,a[i+1])+res;\\n            else if(temp<=8) res = string(1,a[i+1])+string(temp-5,a[i])+res;\\n            else if(temp==9) res = string(1,a[i])+string(1,a[i+2])+res;\\n            num = num/10;\\n            i += 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6315,
                "title": "please-laugh-at-me",
                "content": "\\n```\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        StringBuffer res = new StringBuffer();\\n        while(num >= 1000){\\n            res.append(\"M\");\\n            num -= 1000;\\n        }\\n        int temp = num / 100;\\n        switch(temp){\\n            case 9: res.append(\"CM\"); break;\\n            case 8: res.append(\"DCCC\"); break;\\n            case 7: res.append(\"DCC\"); break;\\n            case 6: res.append(\"DC\"); break;\\n            case 5: res.append(\"D\"); break;\\n            case 4: res.append(\"CD\"); break;\\n            case 3: res.append(\"CCC\"); break;\\n            case 2: res.append(\"CC\"); break;\\n            case 1: res.append(\"C\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*100;\\n        temp = num / 10;\\n        switch(temp){\\n            case 9: res.append(\"XC\"); break;\\n            case 8: res.append(\"LXXX\"); break;\\n            case 7: res.append(\"LXX\"); break;\\n            case 6: res.append(\"LX\"); break;\\n            case 5: res.append(\"L\"); break;\\n            case 4: res.append(\"XL\"); break;\\n            case 3: res.append(\"XXX\"); break;\\n            case 2: res.append(\"XX\"); break;\\n            case 1: res.append(\"X\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*10;\\n        switch(num){\\n            case 9: res.append(\"IX\"); break;\\n            case 8: res.append(\"VIII\"); break;\\n            case 7: res.append(\"VII\"); break;\\n            case 6: res.append(\"VI\"); break;\\n            case 5: res.append(\"V\"); break;\\n            case 4: res.append(\"IV\"); break;\\n            case 3: res.append(\"III\"); break;\\n            case 2: res.append(\"II\"); break;\\n            case 1: res.append(\"I\"); break;\\n            case 0: break;\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String intToRoman(int num) {\\n        StringBuffer res = new StringBuffer();\\n        while(num >= 1000){\\n            res.append(\"M\");\\n            num -= 1000;\\n        }\\n        int temp = num / 100;\\n        switch(temp){\\n            case 9: res.append(\"CM\"); break;\\n            case 8: res.append(\"DCCC\"); break;\\n            case 7: res.append(\"DCC\"); break;\\n            case 6: res.append(\"DC\"); break;\\n            case 5: res.append(\"D\"); break;\\n            case 4: res.append(\"CD\"); break;\\n            case 3: res.append(\"CCC\"); break;\\n            case 2: res.append(\"CC\"); break;\\n            case 1: res.append(\"C\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*100;\\n        temp = num / 10;\\n        switch(temp){\\n            case 9: res.append(\"XC\"); break;\\n            case 8: res.append(\"LXXX\"); break;\\n            case 7: res.append(\"LXX\"); break;\\n            case 6: res.append(\"LX\"); break;\\n            case 5: res.append(\"L\"); break;\\n            case 4: res.append(\"XL\"); break;\\n            case 3: res.append(\"XXX\"); break;\\n            case 2: res.append(\"XX\"); break;\\n            case 1: res.append(\"X\"); break;\\n            case 0: break;\\n        }\\n        num -= temp*10;\\n        switch(num){\\n            case 9: res.append(\"IX\"); break;\\n            case 8: res.append(\"VIII\"); break;\\n            case 7: res.append(\"VII\"); break;\\n            case 6: res.append(\"VI\"); break;\\n            case 5: res.append(\"V\"); break;\\n            case 4: res.append(\"IV\"); break;\\n            case 3: res.append(\"III\"); break;\\n            case 2: res.append(\"II\"); break;\\n            case 1: res.append(\"I\"); break;\\n            case 0: break;\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6411,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string intToRoman(int num) {\\n            string ret = \"\";\\n            if (num <= 0) return ret;\\n            //{ {1, 2, 3, 4, 5, 6, 7, 8, 9},\\n            //  {10, 20, 30, 40, 50, 60, 70, 80, 90},\\n            //  {100, 200, 300, 400, 500, 600, 700, 800, 900},\\n            //  {1000, 2000, 3000} }\\n            string roman[4][10] = {{\"0\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                                   {\"0\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                                   {\"0\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                                   {\"0\", \"M\", \"MM\", \"MMM\"}};\\n            int i = 0, k = 1000;\\n            \\n            for (i = 3; i >= 0; --i)\\n            {\\n                if (num / k != 0)\\n                    ret += roman[i][num/k];\\n                num %= k;\\n                k /= 10;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string intToRoman(int num) {\\n            string ret = \"\";\\n            if (num <= 0) return ret;\\n            //{ {1, 2, 3, 4, 5, 6, 7, 8, 9}",
                "codeTag": "Java"
            },
            {
                "id": 6455,
                "title": "my-short-java-code",
                "content": "    public class Solution {\\n        \\n        String[][] base = new String[][]{{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\\n                                    {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\\n                                    {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\\n                                    {\"M\", \"MM\", \"MMM\", \"\", \"\", \"\", \"\", \"\", \"\"}};\\n        \\n        public String intToRoman(int num) {\\n            String r = \"\";\\n            for (int i = 0; num != 0; num /= 10, i++) {\\n                if (num % 10 == 0)\\n                    continue;\\n                r = base[i][num % 10-1] + r;\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        String[][] base = new String[][]{{\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}",
                "codeTag": "Java"
            },
            {
                "id": 6482,
                "title": "a-solution-applies-to-numbers-in-any-range",
                "content": "    public class Solution {\\n        public String intToRoman(int num) {\\n            return (romanDigit((num / 1000) % 10, \"M\", \"XX\", \"XX\")) + \\n                   (romanDigit((num / 100) % 10, \"C\", \"D\", \"M\")) +\\n                   (romanDigit((num / 10) % 10, \"X\", \"L\", \"C\")) +\\n                   (romanDigit(num % 10, \"I\", \"V\", \"X\"));\\n        }\\n        \\n        public String romanDigit(int n, String onechar, String fivechar, String tenchar) {\\n            if (n == 0) return \"\";\\n            if (n == 1) return onechar;\\n            if (n == 2) return onechar + onechar;\\n            if (n == 3) return onechar + onechar + onechar;\\n            if (n == 4) return onechar + fivechar;\\n            if (n == 5) return fivechar;\\n            if (n == 6) return fivechar + onechar;\\n            if (n == 7) return fivechar + onechar + onechar;\\n            if (n == 8) return fivechar + onechar + onechar + onechar;\\n            if (n == 9) return onechar + tenchar;\\n            \\n            return null;\\n        }\\n    }\\n\\n\\nI know the listing way is not so good, but just realized that the patterns are the same and can be summarized as \"onechar\", \"fivechar\" and \"tenchar\", which will simplify the solution a little bit.",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            return (romanDigit((num / 1000) % 10, \"M\", \"XX\", \"XX\")) + \\n                   (romanDigit((num / 100) % 10, \"C\", \"D\", \"M\")) +\\n                   (romanDigit((num / 10) % 10, \"X\", \"L\", \"C\")) +\\n                   (romanDigit(num % 10, \"I\", \"V\", \"X\"));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 6486,
                "title": "an-accepted-answer-in-python-using-s-replace",
                "content": "runtime:168 ms\\n\\n    class Solution:\\n   \\n        # @return a string\\n        def intToRoman(self, num):\\n            result = num//1000 *'M' + num%1000//100*'C' + \\\\\\n                         num%1000%100//10*'X' + num%1000%100%10*'I'\\n\\n            result = result.replace('IIIIIIIII', 'IX')\\n            result = result.replace('IIIII','V')\\n            result = result.replace('IIII' , 'IV')\\n            result = result.replace('XXXXXXXXX', 'XC')\\n            result = result.replace('XXXXX' , 'L')\\n            result = result.replace('XXXX' , 'XL')\\n            result = result.replace('CCCCCCCCC', 'CM')\\n            result = result.replace('CCCCC', 'D')\\n            result = result.replace('CCCC', 'CD')\\n            return (result)",
                "solutionTags": [],
                "code": "runtime:168 ms\\n\\n    class Solution:\\n   \\n        # @return a string\\n        def intToRoman(self, num):\\n            result = num//1000 *'M' + num%1000//100*'C' + \\\\\\n                         num%1000%100//10*'X' + num%1000%100%10*'I'\\n\\n            result = result.replace('IIIIIIIII', 'IX')\\n            result = result.replace('IIIII','V')\\n            result = result.replace('IIII' , 'IV')\\n            result = result.replace('XXXXXXXXX', 'XC')\\n            result = result.replace('XXXXX' , 'L')\\n            result = result.replace('XXXX' , 'XL')\\n            result = result.replace('CCCCCCCCC', 'CM')\\n            result = result.replace('CCCCC', 'D')\\n            result = result.replace('CCCC', 'CD')\\n            return (result)",
                "codeTag": "Java"
            },
            {
                "id": 6495,
                "title": "my-accepted-solution-in-java-using-array",
                "content": "The key of my solution is count the num of every digits,and using array to append it.\\n\\n    public class Solution {\\n        public String intToRoman(int num) {\\n            StringBuffer res=new StringBuffer();\\n            String[] aryC={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n            String[] aryX={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n            String[] aryI={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n            int Mnums=num/1000;        //1000\\n            int Cnums=(num%1000)/100;  //100\\n            int Xnums=(num%100)/10;    //10\\n            int Inums=num%10;          //1\\n            for(int i=Mnums;i>0;i--)\\n            {\\n                res.append(\"M\");\\n            }\\n            res.append(aryC[Cnums]);\\n            res.append(aryX[Xnums]);\\n            res.append(aryI[Inums]);\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String intToRoman(int num) {\\n            StringBuffer res=new StringBuffer();\\n            String[] aryC={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"}",
                "codeTag": "Java"
            },
            {
                "id": 3985674,
                "title": "beats-98-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thougStringhts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two arrays, one to store the Roman numerals and the other to store their corresponding values.\\n2. Initialize a StringBuilder to store the Roman numeral representation of the integer.\\n3. Iterate over the arrays in parallel.\\n4. While the integer is greater than or equal to the value at the current index of the values array, append the Roman numeral at the corresponding index of the notations array to the StringBuilder.\\n5. Decrement the integer by the value at the current index of the values array.\\n6. Repeat steps 4 and 5 until the integer is less than the value at the first index of the values array.\\n7. Return the String representation of the StringBuilder\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int []values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String []notations={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i])\\n            {\\n                num-=values[i];\\n                sb.append(notations[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        int []values={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        String []notations={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        StringBuilder sb=new StringBuilder();\\n\\n        for(int i=0;i<values.length;i++){\\n            while(num>=values[i])\\n            {\\n                num-=values[i];\\n                sb.append(notations[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113157,
                "title": "most-optimised-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string rom;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                rom.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return rom;\\n        }};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) \\n    {\\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\\n        string rom;\\n        for(int i=0;i<13;i++){\\n            while(num>=normal[i]){\\n                rom.append(roman[i]);\\n                num-=normal[i];\\n            }\\n        }\\n        return rom;\\n        }};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991683,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string IntToRoman(int num) {\\n        if (num >= 1000) return \"M\" + IntToRoman(num - 1000);\\n\\n        if (num >= 500) return num >= 900 ? (\"CM\" + IntToRoman(num - 900)) : (\"D\" + IntToRoman(num - 500));\\n\\n        if (num >= 100) return num >= 400 ? (\"CD\" + IntToRoman(num - 400)) : (\"C\" + IntToRoman(num - 100));\\n\\n        if (num >= 50) return num >= 90 ? (\"XC\" + IntToRoman(num - 90)) : (\"L\" + IntToRoman(num - 50));\\n\\n        if (num >= 10) return num >= 40 ? (\"XL\" + IntToRoman(num - 40)): (\"X\" + IntToRoman(num - 10));\\n\\n        if (num >= 5) return num == 9 ? \"IX\" : \"V\" + IntToRoman(num - 5);\\n\\n        if (num > 0) return num == 4 ? \"IV\" : \"I\" + IntToRoman(num - 1);\\n\\n        return \"\";   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724944,
                "title": "c-use-hashmap-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string intToRoman(int num) \\n    {\\n        vector<pair<int, string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\\n                                         {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"},\\n                                         {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        \\n        string res=\"\";\\n        \\n        for(auto it:roman)\\n        {\\n            while(num >= it.first)\\n            {\\n                res += it.second;\\n                num -= it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string intToRoman(int num) \\n    {\\n        vector<pair<int, string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\\n                                         {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"},\\n                                         {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\\n        \\n        string res=\"\";\\n        \\n        for(auto it:roman)\\n        {\\n            while(num >= it.first)\\n            {\\n                res += it.second;\\n                num -= it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724475,
                "title": "java-and-c-simple-and-concise-solution-with-detailed-explanation",
                "content": "# Explanation:\\nInitialize two arrays with all possible roman string and number combinations in descending order. Following are the legitamate possible roman symbols and number combinations.  (*I\\'ve used a vector of pairs in C++ implementation*)\\n```\\n String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n```\\n\\nThe goal here is to check how many times each number is divisible by the roman symbols and convert the number to roman symbol greedily.  \\n\\n` Example :3888`\\n            \\nWe start with 1000 and check if the given number is greater than 1000. In this case, it is greater than 1000. We need to know exactly how many times the number is divisible by 1000 because we need to replace 1000 with M that many number of times.   So we know 3000 can be represented with 3 Ms (`MMM`) as floor(3888 / 1000) is 3. Now since we have converted 3000 to roman number, we need to convert the reminder ie 888.\\n\\nWe know for sure the reminder from the previous operation is less than the previous divisor, so we don\\'t have to loop through the numbers array from the start every time. We can start traversing nums array with the index after the previous divisor, as it is sorted in descending order.  888 < 900, so we continue traversing the nums array. the next element in the array is 500. 888 > 500, so we break out of the first for loop below. Now 888 / 500 = 1. so we append the roman notation for 1 500 i.e D to our result.  Now the result so far is `MMMD` and reminder is 388. After solving for the reminder in the similar manner, we get the answer `MMMMDCCCLXXXVIII`.\\n\\n**Complexity**\\n\\n```\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n```\\n            \\nThis is because we use two arrays of fixed size 13 to store the roman and binary numbers. And no matter what the number is we know the below operations are in the worst case constant space as array size is constant and we are just iterating a constant sized array and we can guarantee in the worst case iterates through every element at the most once. The divisorcan at the most be O(8) which is constant. And all the operations in the below loop are constant operations.  \\n\\n```\\n \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n```\\n\\n# Java Solution\\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int i = 0;\\n        StringBuilder result = new StringBuilder();\\n        \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int,string>> romanPairs = {\\n            {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, \\n            {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\\n        };\\n        \\n        int i = 0;\\n        string result = \"\";\\n        \\n        while(num > 0) {\\n            for(;num < romanPairs[i].first; i++);\\n            string roman = romanPairs[i].second;\\n            int number = romanPairs[i].first; \\n            int count = (num / number);\\n            \\n            for(int j = 0; j < count; j++)\\n                result += roman;\\n            num = num - count * number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n```\n```\\n Time Complexity: O(1)\\n Space Complexity: O(1)\\n```\n```\\n \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n```\n```\\nclass Solution {\\n    public String intToRoman(int num) {\\n        String [] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\\n        Integer [] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n        int i = 0;\\n        StringBuilder result = new StringBuilder();\\n        \\n        while(num > 0) {\\n            for(;num < nums[i]; i++);\\n            int count = (num / nums[i]);\\n            for(int j = 0; j < count; j++)\\n                result.append(romans[i]);\\n            num = num - count * nums[i];\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int,string>> romanPairs = {\\n            {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, \\n            {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\\n        };\\n        \\n        int i = 0;\\n        string result = \"\";\\n        \\n        while(num > 0) {\\n            for(;num < romanPairs[i].first; i++);\\n            string roman = romanPairs[i].second;\\n            int number = romanPairs[i].first; \\n            int count = (num / number);\\n            \\n            for(int j = 0; j < count; j++)\\n                result += roman;\\n            num = num - count * number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724333,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        symbolMap = {\\n            1 : \"I\", \\n            5 : \\'V\\', \\n            10 : \"X\", \\n            50 : \"L\", \\n            100 : \"C\", \\n            500 : \"D\", \\n            1000 : \"M\"\\n        }\\n        \\n        res = [] \\n        while num >= 1000: \\n            res.append(symbolMap[1000])\\n            num -= 1000 \\n        \\n        while num >= 900: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[1000])\\n            num -= 900        \\n            \\n        while num >= 500: \\n            res.append(symbolMap[500])\\n            num -= 500\\n        \\n        while num >= 400: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[500])\\n            num -= 400  \\n        \\n        while num >= 100: \\n            res.append(symbolMap[100])\\n            num -= 100 \\n        \\n        while num >= 90: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[100])\\n            num -= 90  \\n            \\n        while num >= 50: \\n            res.append(symbolMap[50])\\n            num -= 50 \\n            \\n        while num >= 40: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[50])\\n            num -= 40 \\n        \\n        while num >= 10: \\n            res.append(symbolMap[10])\\n            num -= 10\\n            \\n        while num >= 9: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[10])\\n            num -= 400  \\n        \\n        while num >= 5:\\n            res.append(symbolMap[5])\\n            num -= 5 \\n            \\n        while num >= 4: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[5])\\n            num -= 400  \\n        \\n        while num >= 1: \\n            res.append(symbolMap[1])\\n            num -= 1 \\n            \\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        symbolMap = {\\n            1 : \"I\", \\n            5 : \\'V\\', \\n            10 : \"X\", \\n            50 : \"L\", \\n            100 : \"C\", \\n            500 : \"D\", \\n            1000 : \"M\"\\n        }\\n        \\n        res = [] \\n        while num >= 1000: \\n            res.append(symbolMap[1000])\\n            num -= 1000 \\n        \\n        while num >= 900: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[1000])\\n            num -= 900        \\n            \\n        while num >= 500: \\n            res.append(symbolMap[500])\\n            num -= 500\\n        \\n        while num >= 400: \\n            res.append(symbolMap[100])\\n            res.append(symbolMap[500])\\n            num -= 400  \\n        \\n        while num >= 100: \\n            res.append(symbolMap[100])\\n            num -= 100 \\n        \\n        while num >= 90: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[100])\\n            num -= 90  \\n            \\n        while num >= 50: \\n            res.append(symbolMap[50])\\n            num -= 50 \\n            \\n        while num >= 40: \\n            res.append(symbolMap[10])\\n            res.append(symbolMap[50])\\n            num -= 40 \\n        \\n        while num >= 10: \\n            res.append(symbolMap[10])\\n            num -= 10\\n            \\n        while num >= 9: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[10])\\n            num -= 400  \\n        \\n        while num >= 5:\\n            res.append(symbolMap[5])\\n            num -= 5 \\n            \\n        while num >= 4: \\n            res.append(symbolMap[1])\\n            res.append(symbolMap[5])\\n            num -= 400  \\n        \\n        while num >= 1: \\n            res.append(symbolMap[1])\\n            num -= 1 \\n            \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723932,
                "title": "c-no-hard-code-simple-way",
                "content": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> map{{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, \\n\\t\\t{90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"}};\\n        int l = map.size()-1;\\n        string s=\"\";\\n        \\n        while(num!=0){\\n            while(map[l].first>num){\\n                l--;\\n            }\\n            s += map[l].second;\\n            num -= map[l].first;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> map{{1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, \\n\\t\\t{90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"}};\\n        int l = map.size()-1;\\n        string s=\"\";\\n        \\n        while(num!=0){\\n            while(map[l].first>num){\\n                l--;\\n            }\\n            s += map[l].second;\\n            num -= map[l].first;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723735,
                "title": "daily-leetcoding-challenge-october-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/integer-to-roman/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n**Approach 2:** Hardcode Digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/integer-to-roman/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2501930,
                "title": "moms-spaghetti",
                "content": "```\\n\\n   let m = Math.floor(num/1000)\\n  num%=1000\\n  let cm = Math.floor(num / 900)\\n  num%=900\\n  let d = Math.floor(num/500)\\n  num%=500\\nlet cd = Math.floor(num/400)\\nnum%=400\\nlet c = Math.floor(num/100)\\nnum%=100\\nlet xc = Math.floor(num/90)\\nnum%=90\\nlet l = Math.floor(num/50)\\n  num%=50\\nlet xl = Math.floor(num/40)\\nnum%=40\\nlet x = Math.floor(num/10)\\nnum%=10\\nlet ix = Math.floor(num/9)\\nnum%=9\\nlet v = Math.floor(num/5)\\nnum%=5\\nlet iv = Math.floor(num/4)\\nnum%=4\\nlet i = Math.floor(num/1)\\n\\n\\nreturn \"M\".repeat(m)+\"CM\".repeat(cm)+\"D\".repeat(d)+\"CD\".repeat(cd)+\"C\".repeat(c)+\"XC\".repeat(xc)+\"L\".repeat(l)+\"XL\".repeat(xl)+\"X\".repeat(x)+\"IX\".repeat(ix)+\"V\".repeat(v)+\"IV\".repeat(iv)+\"I\".repeat(i)\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n\\n   let m = Math.floor(num/1000)\\n  num%=1000\\n  let cm = Math.floor(num / 900)\\n  num%=900\\n  let d = Math.floor(num/500)\\n  num%=500\\nlet cd = Math.floor(num/400)\\nnum%=400\\nlet c = Math.floor(num/100)\\nnum%=100\\nlet xc = Math.floor(num/90)\\nnum%=90\\nlet l = Math.floor(num/50)\\n  num%=50\\nlet xl = Math.floor(num/40)\\nnum%=40\\nlet x = Math.floor(num/10)\\nnum%=10\\nlet ix = Math.floor(num/9)\\nnum%=9\\nlet v = Math.floor(num/5)\\nnum%=5\\nlet iv = Math.floor(num/4)\\nnum%=4\\nlet i = Math.floor(num/1)\\n\\n\\nreturn \"M\".repeat(m)+\"CM\".repeat(cm)+\"D\".repeat(d)+\"CD\".repeat(cd)+\"C\".repeat(c)+\"XC\".repeat(xc)+\"L\".repeat(l)+\"XL\".repeat(xl)+\"X\".repeat(x)+\"IX\".repeat(ix)+\"V\".repeat(v)+\"IV\".repeat(iv)+\"I\".repeat(i)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497457,
                "title": "thous-hunds-tens-ones-by-mdeakyne",
                "content": "**Please upvote if it was helpful!**\\n\\nThe old elegant solution without a loop.\\n```\\nclass Solution {\\n  String intToRoman(int num) {\\n    final ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    final tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    final hunds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    final thous = [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\"];\\n\\n    final t = thous[num  ~/ 1000];\\n    final h = hunds[num ~/ 100 % 10];\\n    final te = tens[num ~/ 10 % 10];\\n    final o = ones[num % 10];\\n\\n    return t + h + te + o;\\n  }\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/785763057/)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String intToRoman(int num) {\\n    final ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\\n    final tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"];\\n    final hunds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"];\\n    final thous = [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\"];\\n\\n    final t = thous[num  ~/ 1000];\\n    final h = hunds[num ~/ 100 % 10];\\n    final te = tens[num ~/ 10 % 10];\\n    final o = ones[num % 10];\\n\\n    return t + h + te + o;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294406,
                "title": "c-complete-dry-run-digit-by-digit-solution-right-to-left-single-hashmap",
                "content": "After Reading this post definetely you will be crystal clear with the Approach and as well as with Code.\\n***\\nBefore copying the code please once understand completely then you can copy !!\\n```\\nclass Solution {\\npublic:\\n    \\n    //  Dry run some exmaples \\n    /*\\n        3999 = 3000 + 900 + 90 + 9 = MMM + CM + XC + IX\\n        // Go backward only one positions\\n        2835 = 2000 + 800 + 30 + 5 = MM + DCC + XXX + V  (WRONG WAY : MM + CCM + XXX + V)\\n        4000 = MMMM\\n\\n    */\\n    \\n    // DRY RUN of num = 249 for the below code\\n    // 249 = 200 + 40 + 9 = \\n    /* \\n        Ist Pass :\\n        --------\\n        last digit = 9 , place value = x = 1\\n        1. multiply by place value = 9*1 = 9 \\n        2  9 is not found in map\\n        3. Its nearest by place value x=1, 9+1 = 10, 10 is present in map\\n        4. write mp[1]+mp[10] = \"IX\" for \\'9\\'\\n        5. ans = \"IX\"\\n        \\n        IInd Pass :\\n        ---------\\n        last digit = 4 , place value = x = 10\\n        1. multiply by place value = 4*10 = 40\\n        2  40 is not found in map\\n        3. Its nearest by place value x=10, 40+10 = 50, 50 is present in map\\n        4. write mp[10]+mp[50] = \"XL\" for \\'40\\'\\n        5. ans = \"XLIX\"\\n        \\n        IIIrd Pass :\\n        ---------\\n        last digit = 2 , place value = x = 100\\n        1. multiply by place value = 2*100 = 200\\n        2  200 is not found in map\\n        3. Its nearest by place value x=100, 200+100 = 300, 300 is not present in map\\n        4. So perform subtraction by place value x=100, 200-100 = 100, 100 is present in map\\n        5. write mp[100]+mp[100] = \"CC\" for \\'200\\'\\n        6. ans = \"CCXLIX\"\\n        \\n        DONE !\\n    */\\n    string intToRoman(int num) \\n    {\\n        unordered_map<int,string>mp = {{1,\"I\"},{5,\"V\"},{10,\"X\"},{50,\"L\"},{100,\"C\"},{500,\"D\"},{1000,\"M\"}};\\n        \\n        int x=1;\\n        string ans=\"\";\\n        while(num>0)\\n        {\\n            int d=num%10;                           // Last digit of a number\\n            d*=x;                                   // Multiply by its place value (like 1, 10, 100, 1000)\\n            while(d>0)\\n            {\\n                if(mp.find(d)!=mp.end()){           // find the digit in the map - direct \\n                    ans = mp[d] + ans;\\n                    d = 0;\\n                } \\n                else if(mp.find(d+x)!=mp.end())      // or find the approx nearest in the map. // like 40 nearest to 50\\n                {\\n                    ans = mp[x] + mp[d+x] + ans;\\n                    d = 0;\\n                }\\n                else                            // iterate the place value mapped value until it matches the map value\\n                {\\n                    ans = mp[x] + ans;\\n                    d -= x;\\n                } \\n            }\\n            num/=10; // remove the last digit from the number\\n            x*=10; // increment the place value.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //  Dry run some exmaples \\n    /*\\n        3999 = 3000 + 900 + 90 + 9 = MMM + CM + XC + IX\\n        // Go backward only one positions\\n        2835 = 2000 + 800 + 30 + 5 = MM + DCC + XXX + V  (WRONG WAY : MM + CCM + XXX + V)\\n        4000 = MMMM\\n\\n    */\\n    \\n    // DRY RUN of num = 249 for the below code\\n    // 249 = 200 + 40 + 9 = \\n    /* \\n        Ist Pass :\\n        --------\\n        last digit = 9 , place value = x = 1\\n        1. multiply by place value = 9*1 = 9 \\n        2  9 is not found in map\\n        3. Its nearest by place value x=1, 9+1 = 10, 10 is present in map\\n        4. write mp[1]+mp[10] = \"IX\" for \\'9\\'\\n        5. ans = \"IX\"\\n        \\n        IInd Pass :\\n        ---------\\n        last digit = 4 , place value = x = 10\\n        1. multiply by place value = 4*10 = 40\\n        2  40 is not found in map\\n        3. Its nearest by place value x=10, 40+10 = 50, 50 is present in map\\n        4. write mp[10]+mp[50] = \"XL\" for \\'40\\'\\n        5. ans = \"XLIX\"\\n        \\n        IIIrd Pass :\\n        ---------\\n        last digit = 2 , place value = x = 100\\n        1. multiply by place value = 2*100 = 200\\n        2  200 is not found in map\\n        3. Its nearest by place value x=100, 200+100 = 300, 300 is not present in map\\n        4. So perform subtraction by place value x=100, 200-100 = 100, 100 is present in map\\n        5. write mp[100]+mp[100] = \"CC\" for \\'200\\'\\n        6. ans = \"CCXLIX\"\\n        \\n        DONE !\\n    */\\n    string intToRoman(int num) \\n    {\\n        unordered_map<int,string>mp = {{1,\"I\"},{5,\"V\"},{10,\"X\"},{50,\"L\"},{100,\"C\"},{500,\"D\"},{1000,\"M\"}};\\n        \\n        int x=1;\\n        string ans=\"\";\\n        while(num>0)\\n        {\\n            int d=num%10;                           // Last digit of a number\\n            d*=x;                                   // Multiply by its place value (like 1, 10, 100, 1000)\\n            while(d>0)\\n            {\\n                if(mp.find(d)!=mp.end()){           // find the digit in the map - direct \\n                    ans = mp[d] + ans;\\n                    d = 0;\\n                } \\n                else if(mp.find(d+x)!=mp.end())      // or find the approx nearest in the map. // like 40 nearest to 50\\n                {\\n                    ans = mp[x] + mp[d+x] + ans;\\n                    d = 0;\\n                }\\n                else                            // iterate the place value mapped value until it matches the map value\\n                {\\n                    ans = mp[x] + ans;\\n                    d -= x;\\n                } \\n            }\\n            num/=10; // remove the last digit from the number\\n            x*=10; // increment the place value.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247286,
                "title": "c-integer-to-roman-fast-solution",
                "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string roman[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\\n        int val[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\\n        int i = 12;\\n        string str = \"\";\\n        while(num > 0) {\\n            int div = num / val[i];\\n            num %= val[i];\\n            while(div--) {\\n                str += roman[i];\\n            }\\n            i--;\\n        }\\n        return str;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string roman[] = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}",
                "codeTag": "Java"
            },
            {
                "id": 2237969,
                "title": "simple-java-recursive-solution-17ms",
                "content": "```\\n\\t\\tpublic String intToRoman(int num) {\\n\\t\\t\\tif(num == 0) return \"\";\\n\\t\\t\\tif(num >= 1000) return \"M\" + intToRoman( num - 1000);\\n\\t\\t\\tif(num >= 900) return \"CM\" + intToRoman(num - 900);\\n\\t\\t\\tif(num >= 500) return \"D\" + intToRoman( num - 500);\\n\\t\\t\\tif(num >= 400) return \"CD\" + intToRoman(num - 400);\\n\\t\\t\\tif(num >= 100) return \"C\" + intToRoman( num - 100);\\n\\t\\t\\tif(num >= 90) return \"XC\" + intToRoman( num - 90);\\n\\t\\t\\tif(num >= 50) return \"L\" + intToRoman( num - 50);\\n\\t\\t\\tif(num >= 40) return \"XL\" + intToRoman( num - 40);\\n\\t\\t\\tif(num >= 10) return \"X\" + intToRoman( num - 10);\\n\\t\\t\\tif(num >= 9) return \"IX\" + intToRoman( num - 9);\\n\\t\\t\\tif(num >= 5) return \"V\" + intToRoman( num - 5);\\n\\t\\t\\tif(num >= 4) return \"IV\" + intToRoman( num - 4);\\n\\t\\t\\tif(num >= 1) return \"I\" + intToRoman( num - 1);\\n\\t\\t\\treturn intToRoman(num);\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\t\\tpublic String intToRoman(int num) {\\n\\t\\t\\tif(num == 0) return \"\";\\n\\t\\t\\tif(num >= 1000) return \"M\" + intToRoman( num - 1000);\\n\\t\\t\\tif(num >= 900) return \"CM\" + intToRoman(num - 900);\\n\\t\\t\\tif(num >= 500) return \"D\" + intToRoman( num - 500);\\n\\t\\t\\tif(num >= 400) return \"CD\" + intToRoman(num - 400);\\n\\t\\t\\tif(num >= 100) return \"C\" + intToRoman( num - 100);\\n\\t\\t\\tif(num >= 90) return \"XC\" + intToRoman( num - 90);\\n\\t\\t\\tif(num >= 50) return \"L\" + intToRoman( num - 50);\\n\\t\\t\\tif(num >= 40) return \"XL\" + intToRoman( num - 40);\\n\\t\\t\\tif(num >= 10) return \"X\" + intToRoman( num - 10);\\n\\t\\t\\tif(num >= 9) return \"IX\" + intToRoman( num - 9);\\n\\t\\t\\tif(num >= 5) return \"V\" + intToRoman( num - 5);\\n\\t\\t\\tif(num >= 4) return \"IV\" + intToRoman( num - 4);\\n\\t\\t\\tif(num >= 1) return \"I\" + intToRoman( num - 1);\\n\\t\\t\\treturn intToRoman(num);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1898146,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1576240,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1568266,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565655,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565656,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1732820,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1914145,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1652407,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1571035,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778211,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1898146,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1576240,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1568266,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565655,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1565656,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1732820,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1914145,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1652407,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1571035,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778211,
                "content": [
                    {
                        "username": "sulicn",
                        "content": "Can I report those idiots that are still posting solutions here?"
                    },
                    {
                        "username": "Wolfoo",
                        "content": "I think it\\'s easy not medium"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "alalalaa",
                        "content": "double it and give it to the next person\\n"
                    },
                    {
                        "username": "Luojihencha",
                        "content": "I paied a lot of money for leetcode......and still there is no answer. Leetcode please, all questions are hard for me."
                    },
                    {
                        "username": "jy0819",
                        "content": "bro it\\'s been 3 years hope your luoji becomes better now lol"
                    },
                    {
                        "username": "alalalaa",
                        "content": "ask someone who knows how to code to make you connect the dots"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "IHxRK28",
                        "content": "I dont know whether this is a troll statement or not but heres your motivation and tips/advice \\n\\nYou could just follow famous playlists on youtube - \\nSo theres this Indian Guy called striver (Channel Name - TakeuForward) more than half of his videos are in english, You should follow that and I can definitely say You will get better at it. From what I know and understand, You get better at coding with practice which might take different time for different people, so if you are interested in coding keep at it.  "
                    },
                    {
                        "username": "umnik",
                        "content": "I know the easy way of solving this problem is using **23 case** statements (10 for numbers [1-10], 10 for [10-100], 10 for [1000-3000]). But the code does not look good and it's getting bit long. I'm thinking even applying the rules for converting may also make the code complex. Any suggestions?"
                    },
                    {
                        "username": "androidcarson",
                        "content": "[@AdityaBhate](/AdityaBhate) downvoted for using emojis"
                    },
                    {
                        "username": "tolem",
                        "content": "yeah it can  even be solved in 10 to 11 case checks "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you might wanna take a look into this [solution](https://leetcode.com/problems/integer-to-roman/solutions/2726838/c-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "selvablaze",
                        "content": "[@lucayan0506](/lucayan0506) class Solution {\\n    public String getValue(int val, int pos, HashMap<Integer, String> map){\\n        int value = val * (int) Math.pow(10, pos-1);\\n        String answer = \"\";\\n        if(map.containsKey(value))\\n            return map.get(value);\\n        int upperBound = (int) Math.pow(10,pos);\\n        int midBound = (int) Math.pow(10,pos)/2;\\n        int lowerBound = (int) Math.pow(10, pos-1);\\n        if(val == 4)\\n            answer = map.get(lowerBound) + map.get(midBound);\\n        else if(val == 9 )\\n            answer = map.get(lowerBound) + map.get(upperBound);   \\n        else if(val < 4)\\n            answer = map.get(lowerBound).repeat(val);\\n        else if(val > 5)\\n            answer =  map.get(midBound) + map.get(lowerBound).repeat(val-5);   \\n        map.put(value, answer);\\n        return answer;              \\n    }\\n    public String intToRoman(int num) {\\n        String answer = \"\";\\n        int i = 1;\\n        HashMap<Integer,String> map = new HashMap<>();\\n        map.put(1, \"I\" );\\n        map.put(5, \"V\" );\\n        map.put(10, \"X\" );\\n        map.put(50, \"L\" );\\n        map.put(100, \"C\" );\\n        map.put(500, \"D\" );\\n        map.put(1000, \"M\");\\n        while(num>0){\\n            answer = getValue(num%10, i, map) + answer;\\n            num = num/10;\\n            i++;\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "lucayan0506",
                        "content": "I would suggest use map (where you save the value in decimal and the value in roman) `m[1000] = \"M\"    m[900] = \"CM\"`.\nOr you can you use 2 array (one for decimal number, one for roman number) `decimal_number[0] = 1000 roman_number[0] = \"M\"`\nThen use a for loop, instead of 23 case statement"
                    },
                    {
                        "username": "Amax",
                        "content": "For example: how do you spell 1999 in roman?\\nMIM or MCMXCIX?"
                    },
                    {
                        "username": "RittikChaudhary",
                        "content": "[@VinayPatidar](/VinayPatidar) bhai 1001 ho skta hai \"MI\""
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "[@VinayPatidar](/VinayPatidar) Actually I after M is allowed, for example: to write 1001, we can use MI"
                    },
                    {
                        "username": "arthur326",
                        "content": "Yeah, just from the information given in the question, 10 could be written as IX or VIV, right? (This does not violate the subtraction cases they give.) Are we allowed to return either representation? The question should be clearer..."
                    },
                    {
                        "username": "lolo101",
                        "content": "MCMXCIX\\nYou cannot write \"IM\" because you may only remove the previous power of ten to a power of ten.\\nFor instance \"IX\", \"XC\", \"CM\" are allowed. But \"IC\", \"IM\", \"XM\" are not."
                    },
                    {
                        "username": "VinayPatidar",
                        "content": "second one\\nyou cannot have I before or after M"
                    },
                    {
                        "username": "ozkansafak",
                        "content": "[@Kram_](/Kram_) Why? What\\'s the rule we\\'re trying to capture in the code?"
                    },
                    {
                        "username": "abdallahg2120",
                        "content": "According to roman rule which I see in problem description.\\nI think the right answer is MCMXCIX.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "10 years later, we still have the same doubt!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Oh man it\\'s been 10 years for this comment."
                    },
                    {
                        "username": "snoyes",
                        "content": "In modern standard use, the only subtractive forms are IV, IX, XL, XC, CD, and CM, so MIM wouldn\\'t be allowed. In medieval and earlier times, usage was all over the place, so there\\'s no telling "
                    },
                    {
                        "username": "Kram_",
                        "content": "The second one"
                    },
                    {
                        "username": "YuriiHryniv",
                        "content": "I bought leetcode subscription but this problem seems very hard to me :((. Unsubscribe, I thought I would get into FAANG"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@Artsapollo](/Artsapollo) dude he is just joking"
                    },
                    {
                        "username": "Artsapollo",
                        "content": "Dude, try before pay"
                    },
                    {
                        "username": "ztia0004",
                        "content": "I just don\\'t know the point of this question, it\\'s like wasting my time to understand something I do not want to know, rather than coding practice"
                    },
                    {
                        "username": "mayankK135",
                        "content": "Like all DSA problem you solve, it\\'s also to teach how problem solving skill, off course you won\\'t need it in real world"
                    },
                    {
                        "username": "AseCantCode",
                        "content": "[@georgezakharov](/georgezakharov) lmao\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Tell it on an interview :)"
                    },
                    {
                        "username": "ranjeetmadhaviitd",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "this isnt the correct question !!"
                    },
                    {
                        "username": "heshan16",
                        "content": "Er,for example,actually, the roman integer of 49 should be IL?But in this problem,the input of 49 should be output LXIX.So there result would not  the true roman numbers"
                    },
                    {
                        "username": "ivstarkov",
                        "content": "[@xcelr8](/xcelr8) 49 is XLIX. LXIX isnt possible."
                    },
                    {
                        "username": "dtwiers",
                        "content": "In the most loosely-defined version of Roman numerals, yes, IL would be correct. But in the more rigorously defined version, you can only use the next-highest order of 10 unit lower than a number to subtract from a large number - so IM isn\\'t a thing for 999, but CM will get you 900 because C is the next highest power of 10 below 1000. You then get XC (100 - 10), and IX (10 - 1), so 999 is CMXCIX"
                    },
                    {
                        "username": "dtwiers",
                        "content": "[@xcelr8](/xcelr8) that is 69. 49 is XLIX."
                    },
                    {
                        "username": "xcelr8",
                        "content": "49 is LXIX in roman"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ans=\"\";\\n        while(num>=1000){\\n            ans+=\"M\";\\n            num-=1000;\\n        }\\n        while(num>=900){\\n            ans+=\"CM\";\\n            num-=900;\\n        }\\n        while(num>=500){\\n            ans+=\"D\";\\n            num-=500;\\n        }\\n        while(num>=400){\\n            ans+=\"CD\";\\n            num-=400;\\n        }\\n        while(num>=100){\\n            ans+=\"C\";\\n            num-=100;\\n        }\\n        while(num>=90){\\n            ans+=\"XC\";\\n            num-=90;\\n        }\\n        while(num>=50){\\n            ans+=\"L\";\\n            num-=50;\\n        }\\n        while(num>=40){\\n            ans+=\"XL\";\\n            num-=40;\\n        }\\n        while(num>=10){\\n            ans+=\"X\";\\n            num-=10;\\n        }\\n        while(num>=9){\\n            ans+=\"IX\";\\n            num-=9;\\n        }\\n        while(num>=5){\\n            ans+=\"V\";\\n            num-=5;\\n        }\\n        while(num>=4){\\n            ans+=\"IV\";\\n            num-=4;\\n        }\\n        while(num>=1){\\n            ans+=\"I\";\\n            num-=1;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sulicn",
                        "content": "[@user9666yo](/user9666yo) Is it allowed to post answers here in discussion?@Deepak_8811"
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n"
                    }
                ]
            },
            {
                "id": 2071772,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2071582,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2048280,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 2038589,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1968531,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1964782,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1956594,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1887061,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1865905,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1818404,
                "content": [
                    {
                        "username": "mukeshgupta_",
                        "content": "I think its easy question. On GFG this is a Basic Question."
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "The intuition behind it is just to go from highest value to the lowest possible and to add some special cases to the hash table.\n\nThat's it"
                    },
                    {
                        "username": "akotb3",
                        "content": "\\nthis is the code I wrote  I believe it should work but evertime i put into leetcode it is  just out putting a bunch of IIIIIIII an example of this is if the input is 58 it would print : \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"\\n\\nclass Solution(object):\\n    def intToRoman(self, num):\\n        numdict = {1000:\"M\",\\n            900:\"CM\",\\n            500:\"D\",\\n            400:\"CD\",\\n            100:\"C\",\\n            90:\"XC\",\\n            50:\"L\",\\n            40:\"XL\",\\n            10:\"X\",\\n            9:\"IX\",\\n            5:\"V\",\\n            4:\"IV\",\\n            1:\"I\"\\n          }\\n        roman =\"\"\\n        for i in numdict.keys():\\n            while num >= i:\\n                num -= i\\n                roman += numdict[i]\\n            if num == 0:\\n                break\\n        return roman\\n\\nsolution = Solution()\\n\\n\\nresult = solution.intToRoman(1994)\\nprint(result)\\n\\n"
                    },
                    {
                        "username": "megan891685",
                        "content": "If I want to do this in c and not have memory leaks AND keep the compile time down, how should I return an array of char?\\nFor example.\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr =roman;\\n free(roman)\\n return arr; //will cause mem leaks\\n`\\n\\n `char *roman = (char*)malloc(sizeof(char)*8)\\n  char *arr;\\n  for(int i = 0; i < strlen(roman);i++){\\n arr[i] = roman[i];\\n}//going through for loop sounds like a giant waste.\\n free(roman)\\nreturn arr;\\n`"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Have to give this a like, it deserves the upvote, even though it left me with 3 failed attempts "
                    },
                    {
                        "username": "Nwarr_Desirs",
                        "content": "please bros i don\\'t undestand, what is self?? why do i need it? "
                    },
                    {
                        "username": "Kei_Chen",
                        "content": "Self is something that 'represents' a function as a whole allowing you to access any variable inside the class, it doesn't have to be self (i.e. could be wjf), but is normally stated as it. For example, if we have two functions in the class, and we try to call one variable, this could be messy (if you get it). Take this as an example:\n\nclass Person:\n  def __init__(self, name: str, age: int) -> str:\n    self.name = name\n    self.age = age\n\n  def myfunc(abc):\n    return abc.name\n\nAlso you can refer to here: https://www.w3schools.com/python/gloss_python_self.asp#:~:text=The%20self%20parameter%20is%20a,that%20belongs%20to%20the%20class."
                    },
                    {
                        "username": "jetroll2014",
                        "content": "Idk why this is wrong.\n\nIt is clear that my result is same with the expected.... But it's a wrong answer.\n\nIdk why!!! Please someone help me :( \n\nnum=3, Output:\"III\", Expected:\"III\"\nnum=58, Output:\"LVIII\", Expected:\"LVIII\"\n\n\n `class Solution {\npublic:\n    string intToRoman(int num) {\n        int value = 0;\n        int count=0;\n        string result;\n        result+='M'*(num/1000);\n        num%=1000;\n        int idx = num/100;\n        if(idx ==9){\n            result+=\"CM\";\n        }\n        else if(idx==4){\n            result+=\"CD\";\n        }\n        else\n        {result.append(idx/5, 'D');\n        result.append(idx%5, 'C');\n        }\n        num%=100;\n        idx = num/10;\n        if(idx==9){\n            result+=\"XC\";\n        }\n        else if(idx==4){\n            result+=\"XL\";\n        }\n        else\n        {result.append(idx/5, 'L');\n        result.append(idx%5, 'X');\n        }\n        num%=10;\n        if(num==9){\n            result+=\"IX\";\n        }\n        else if(num==4){\n            result+=\"IV\";\n        }\n        else\n        {\n            result.append(num/5, 'V');\n            result.append(num%5, 'I');\n        }\n        return result;\n    }\n};`"
                    },
                    {
                        "username": "EmreArslan",
                        "content": "As I said in this code's comment sections, your code sets 0th index of result string as null. If the value is smaller than 1000. Also, your code doesn't multiplicate the 'M' if the number is bigger than 1000.\n\nHere is the fixed code with comment sections that explains the situation:\n\n```\nclass Solution { \n    public: string intToRoman(int num) \n    { \n        int value = 0; \n        int count=0; \n        string result;\n\n        //In this line, the initial char of 'result' string can be Null\n        // result+='M'*(num/1000); \n\n        //So that, I deactivated this line and wrote this if conditional and while loop\n        if(num/1000){\n            while(num >= 1000){\n                result += 'M';\n                num-=1000;\n            }\n        };\n        \n        // num%=1000; \n        int idx = num/100; \n        if(idx ==9){ result+=\"CM\"; } \n        else if(idx==4){ result+=\"CD\"; } \n        else {\n            result.append(idx/5, 'D'); \n            result.append(idx%5, 'C'); \n        } \n        num%=100; \n        idx = num/10; \n        if(idx==9){ \n            result+=\"XC\"; \n        } \n        else if(idx==4){ \n            result+=\"XL\"; \n        } \n        else {\n            result.append(idx/5, 'L'); \n            result.append(idx%5, 'X'); \n        } \n        num%=10; \n        if(num==9){ \n            result+=\"IX\"; \n        } \n        else if(num==4){ \n            result+=\"IV\"; \n        } \n        else { \n            result.append(num/5, 'V'); \n            result.append(num%5, 'I'); \n        } \n        return result; \n    } \n};\n```\n\nI hope it helps you "
                    },
                    {
                        "username": "arpitagrawal09",
                        "content": "Quite interesting question! "
                    },
                    {
                        "username": "anamrani17",
                        "content": "/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar intToRoman = function(num) {\\n    // step 1: create a lookup table\\n    const lookupTable = {\\n       O: [\\'\\', \\'I\\', \\'II\\', \\'III\\', \\'IV\\', \\'V\\', \\'VI\\', \\'VII\\', \\'VIII\\', \\'IX\\'],\\n        T: [\\'\\', \\'X\\', \\'XX\\', \\'XXX\\', \\'XL\\', \\'L\\', \\'LX\\', \\'LXX\\', \\'LXXX\\', \\'XC\\'],\\n        H : [\\'\\', \\'C\\', \\'CC\\', \\'CCC\\', \\'CD\\', \\'D\\', \\'DC\\', \\'DCC\\', \\'DCCC\\', \\'CM\\'],\\n        Th : [\\'\\', \\'M\\', \\'MM\\', \\'MMM\\']\\n    }\\nreturn lookupTable.Th[Math.floor(num/1000)] + lookupTable.H[Math.floor((num%1000)/100)] + lookupTable.T[Math.floor((num%100)/10)] + lookupTable.O[num%10];\\n    \\n};\\n\\nhere is my solution of JavaScript code.\\nthe main line of code is return statement the expands the number then extract each digit one by one.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zbraven",
                        "content": "int bul(char ch,int value)\\n{\\n\\nswitch (ch)\\n{\\n    case \\'I\\':\\n        value += 1;\\n        break;\\n    case \\'V\\':\\n        value += 5;\\n        break;\\n    case \\'X\\':\\n        value += 10;\\n        break;\\n    case \\'L\\':\\n        value += 50;\\n        break;\\n    case \\'C\\':\\n        value += 100;\\n        break;\\n    case \\'D\\':\\n        value += 500;\\n        break;\\n    case \\'M\\':\\n        value += 1000;\\n            break;\\n }\\n    return value;\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user9666yo",
                        "content": "//criado objeto com a correspondencia dos valores\\nconst symbols = {\\n  \\'I\\': 1,\\n  \\'V\\': 5,\\n  \\'X\\': 10,\\n  \\'L\\': 50,\\n  \\'C\\': 100,\\n  \\'D\\': 500,\\n  \\'M\\': 1000,\\n};\\n\\n//fun\\xE7ao contador total\\nfunction romanToInt(s) {\\n  let total = 0;\\n\\n//percorrer cada algarismo\\n  for (let i = 0; i < s.length; ++i) {\\n    const num1 = symbols[s[i]];\\n    const num2 = symbols[s[i + 1]];\\n\\n    if (num1 < num2) {\\n      total -= num1;\\n    } else {\\n      total += num1;\\n    }\\n  }\\n//retorna o total\\n  return total;\\n}\\n\\nconsole.log(romanToInt(\"MCMXCIV\"));"
                    }
                ]
            },
            {
                "id": 1804156,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1802501,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1799735,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1776009,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1768434,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1766388,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1766291,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1746519,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1744912,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1731563,
                "content": [
                    {
                        "username": "haduong825",
                        "content": "Here is my stupid solution \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\n `class Solution {\\n  String intToRoman(int num) {\\n    final oneMap = {1: \"I\", 10: \"X\", 100: \"C\", 1000: \"M\"};\\n    final fiveMap = {5: \"V\", 50: \"L\", 500: \"D\"};\\n    final inputStr =\\n        num.toString().split(\\'\\').reversed.map((e) => int.parse(e)).toList();\\n    var outputArray = List<String>.empty(growable: true);\\n    for (int i = 0; i < inputStr.length; i++) {\\n      if (inputStr[i] * pow(10, i) < (5 * pow(10, i) - pow(10, i))) {\\n        for (int j = 0; j < inputStr[i]; j++) {\\n          outputArray.add(oneMap[pow(10, i)] ?? \"\");\\n        }\\n      } else if (inputStr[i] * pow(10, i) < 9 * pow(10, i) &&\\n          inputStr[i] * pow(10, i) != (4 * pow(10, i))) {\\n        var tmpStr = \"\";\\n        tmpStr += fiveMap[5 * pow(10, i)] ?? \"\";\\n        for (int j = 0; j < inputStr[i] - 5; j++) {\\n          tmpStr += oneMap[pow(10, i)] ?? \"\";\\n        }\\n\\n        outputArray.add(tmpStr);\\n      } else if (inputStr[i] * pow(10, i) == (4 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${fiveMap[5 * pow(10, i)]}\");\\n      } else if (inputStr[i] * pow(10, i) == (9 * pow(10, i))) {\\n        outputArray.add(\"${oneMap[pow(10, i)]}${oneMap[pow(10, i + 1)]}\");\\n      } else if (inputStr[i] * pow(10, (i + 1)) == (5 * pow(10, (i + 1)))) {\\n        outputArray.add(fiveMap[5 * pow(10, i)] ?? \"\");\\n      }\\n    }\\n\\n    return outputArray.reversed.reduce((value, element) => value + element);\\n  }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nAnd here are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maj-oliveira",
                        "content": "what is the complexity of this code?\\n\\nclass Solution:\\n    def intToRoman(self, num: int) -> str:\\n        d = {1000:\\'M\\',900:\\'CM\\',500:\\'D\\',400:\\'CD\\',100:\\'C\\',90:\\'XC\\',50:\\'L\\',40:\\'XL\\',10:\\'X\\',9:\\'IX\\',5:\\'V\\',4:\\'IV\\',1:\\'I\\'}\\n        result = \"\"\\n\\n        while num !=0:\\n            for key in d:\\n                if key<=num or key==1:\\n                    div = num // key\\n                    for i in range(div):\\n                        result = result + d[key]\\n                    num = num % key\\n\\n        return result"
                    },
                    {
                        "username": "boy19970722",
                        "content": "can someone exmplain why 200 is LLLL instead of CC where 20 is XX instead of VVVV?"
                    },
                    {
                        "username": "jamesTheCoder",
                        "content": "200 is CC. Largest possible. "
                    },
                    {
                        "username": "adnanitzer",
                        "content": "Here is an easy way in JS, find the first number >= the result, add its symbol and substract it then continue\n `let roman = \"M\".repeat(parseInt(num/1000));\n    num = num%1000;\n    const nums = ['900', '500','400','100', '90','50',  '40',  '10', '9', '5','4', '1']\n    const rom = [\"CM\", 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    for (let i in nums){\n        while (num>=nums[i]){\n            roman+=rom[i]\n            num-=nums[i]\n        }\n    }\n    return roman;`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "RASWQQW",
                        "content": "Can we this code but its shown as incorrect in testcase\n\n`\n\n\n        _dict = {1000: \"M\", 500: \"D\", 100: \"C\", 50: \"L\", 10: \"X\", 5: \"V\", 1: \"I\"}\n        # print(dict(reversed(list(_dict.items()))))\n\n        _digitLen = len(str(num))\n        num = str(num)[::-1]\n        dar = 1\n        text = ''\n        for elem in str(num):\n            elem = int(elem) * dar\n            for key, value in _dict.items():\n\n                if int(elem) == key:\n                    text+= value; break\n\n                elif int(elem) % key == 0:\n                    for _ in range(int(elem / dar)):\n                        text+=value\n\n                    break\n\n                elif 3 * dar >= int(elem) % key > 0 and int(elem) % key != elem:\n                    for ss in range(int(int(elem) % key / dar)):\n                        text+=_dict[dar]\n                    text += value\n                    break\n\n                elif int(elem) + dar == key:\n                    text+=value+_dict[dar]; \n                    \n                    break\n\n            dar *= 10\n\n        return text[::-1] `\n\n\n\n\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "hsthanh00",
                        "content": "var roman = \"\";\\nfunction divided(num,romanNum){\\n    roman += romanNum ;\\n    if(num <= 0){\\n        return roman;\\n    }\\n    if( num>=1000){\\n        var romanNumber = \"M\".repeat(num/1000);\\n       return divided(num%1000,romanNumber)\\n    }\\n    if(num >= 900){\\n        var romanNumber = \"CM\".repeat(num/900);\\n       return divided(num%900,romanNumber)\\n    }\\n    if(num>=500){\\n        \\n        var romanNumber = \"D\".repeat(num/500);\\n        return divided(num%500,romanNumber)\\n    }\\n    if(num >= 400){\\n         var romanNumber = \"CD\".repeat(num/400);\\n        return divided(num%400,romanNumber)\\n    }\\n    if(num>=100){\\n        var romanNumber = \"C\".repeat(num/100);\\n        return divided(num%100,romanNumber)\\n    }\\n    if(num>=90){\\n         var romanNumber = \"XC\".repeat(num/90);\\n        return divided(num%90,romanNumber)\\n    }\\n    if(num>=50){\\n        var romanNumber = \"L\".repeat(num/50);\\n        return divided(num%50,romanNumber)\\n    }\\n    if(num>=40){\\n         var romanNumber = \"XL\".repeat(num/40);\\n        return divided(num%40,romanNumber)\\n    }\\n    \\n    if(num>=10){\\n        var romanNumber = \"X\".repeat(num/10);\\n        return divided(num%10,romanNumber)\\n    }\\n    if(num>=9){\\n         var romanNumber = \"IX\".repeat(num/9);\\n        return divided(num%9,romanNumber)\\n    }\\n     if(num>=5){\\n        var romanNumber = \"V\".repeat(num/5);\\n        return  divided(num%5,romanNumber)\\n    }\\n    if(num>=4){\\n         var romanNumber = \"IV\".repeat(num/4);\\n        return divided(num%4,romanNumber)\\n    }\\n     if(num>=1){\\n        var romanNumber = \"I\".repeat(num/1);\\n        return divided(num%1,romanNumber)\\n    }\\n    return roman; \\n}\\n\\nvar intToRoman = function(num) {\\n var roman = divided(num,\"\");\\n return roman \\n};\\n// how does it work when i code it on visual studio code but at \"leetcode\" it\\'s wrong. @@\\n"
                    },
                    {
                        "username": "RohitAgarwal08",
                        "content": "Explanation in Hindi\\n\\nhttps://youtu.be/fh5Q-2TvQwo"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest O(1)\\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            }
        ]
    },
    {
        "title": "Path Sum",
        "question_content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 36378,
                "title": "accepted-my-recursive-solution-in-java",
                "content": "The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0.\\n\\n    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n        \\n            if(root.left == null && root.right == null && sum - root.val == 0) return true;\\n        \\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n        \\n            if(root.left == null && root.right == null && sum - root.val == 0) return true;\\n        \\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36360,
                "title": "short-python-recursive-solution-o-n",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a boolean\\n        # 1:27\\n        def hasPathSum(self, root, sum):\\n            if not root:\\n                return False\\n    \\n            if not root.left and not root.right and root.val == sum:\\n                return True\\n            \\n            sum -= root.val\\n    \\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a boolean\\n        # 1:27\\n        def hasPathSum(self, root, sum):\\n            if not root:\\n                return False\\n    \\n            if not root.left and not root.right and root.val == sum:\\n                return True\\n            \\n            sum -= root.val\\n    \\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)",
                "codeTag": "Java"
            },
            {
                "id": 36367,
                "title": "3-lines-of-c-solution",
                "content": "    bool hasPathSum(TreeNode *root, int sum) {\\n            if (root == NULL) return false;\\n            if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "solutionTags": [],
                "code": "    bool hasPathSum(TreeNode *root, int sum) {\\n            if (root == NULL) return false;\\n            if (root->val == sum && root->left ==  NULL && root->right == NULL) return true;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 36486,
                "title": "python-solutions-dfs-recursively-dfs-stack-bfs-queue",
                "content": "# DFS Recursively \\n    def hasPathSum1(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, res)\\n        return any(res)\\n        \\n    def dfs(self, root, target, res):\\n        if root:\\n            if not root.left and not root.right and root.val == target:\\n                res.append(True)\\n            if root.left:\\n                self.dfs(root.left, target-root.val, res)\\n            if root.right:\\n                self.dfs(root.right, target-root.val, res)\\n    \\n    # DFS with stack\\n    def hasPathSum2(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, val = stack.pop()\\n            if not curr.left and not curr.right and val == sum:\\n                return True\\n            if curr.right:\\n                stack.append((curr.right, val+curr.right.val))\\n            if curr.left:\\n                stack.append((curr.left, val+curr.left.val))\\n        return False\\n        \\n    # BFS with queue\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        queue = [(root, sum-root.val)]\\n        while queue:\\n            curr, val = queue.pop(0)\\n            if not curr.left and not curr.right and val == 0:\\n                return True\\n            if curr.left:\\n                queue.append((curr.left, val-curr.left.val))\\n            if curr.right:\\n                queue.append((curr.right, val-curr.right.val))\\n        return False\\n\\t\\t\\n\\tdef hasPathSum1(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "# DFS Recursively \\n    def hasPathSum1(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, res)\\n        return any(res)\\n        \\n    def dfs(self, root, target, res):\\n        if root:\\n            if not root.left and not root.right and root.val == target:\\n                res.append(True)\\n            if root.left:\\n                self.dfs(root.left, target-root.val, res)\\n            if root.right:\\n                self.dfs(root.right, target-root.val, res)\\n    \\n    # DFS with stack\\n    def hasPathSum2(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, val = stack.pop()\\n            if not curr.left and not curr.right and val == sum:\\n                return True\\n            if curr.right:\\n                stack.append((curr.right, val+curr.right.val))\\n            if curr.left:\\n                stack.append((curr.left, val+curr.left.val))\\n        return False\\n        \\n    # BFS with queue\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        queue = [(root, sum-root.val)]\\n        while queue:\\n            curr, val = queue.pop(0)\\n            if not curr.left and not curr.right and val == 0:\\n                return True\\n            if curr.left:\\n                queue.append((curr.left, val-curr.left.val))\\n            if curr.right:\\n                queue.append((curr.right, val-curr.right.val))\\n        return False\\n\\t\\t\\n\\tdef hasPathSum1(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 670515,
                "title": "c-recursive-solution-4-lines-code",
                "content": "***Pls upvote if you find this helpful  :)***\\n\\nThree things to remember while solving any recursion based questions are:\\n1)Terminating condition/Base Case\\n2)Body (Code to be performed each time)\\n3)Propagation(Calling itself,propagating further)\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096296,
                "title": "easiest-beginner-friendly-sol-recursion-o-n-time-and-o-h-space",
                "content": "# Intuition\\n- We are using **top down recursion** approach to solve this problem.\\n- See below solution to understand how we can use top down and bottom up approach in recursion.\\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/3093043/easiest-beginner-friendly-solution-dfs-o-n-time-and-o-h-space/?orderBy=hot\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a helper function called \"rootToLeafPathSum\" that takes in three parameters: a binary tree node, a target sum, and a current sum.\\n2. Check if the current node is null, and if so, return false.\\n3. Check if the current node is a leaf node (i.e. has no left or right children), and if so, add the value of the node to the current sum.\\n4. If the current sum equals the target sum, return true.\\n5. Recursively call the \"rootToLeafPathSum\" function on the left and right children of the current node, passing in the updated current sum.\\n6. Return the result of the recursive calls.\\n7. In the \"hasPathSum\" function, initialize the current sum to 0 and call the \"rootToLeafPathSum\" function on the root node, passing in the target sum and current sum as parameters.\\n8. Return the result of the \"rootToLeafPathSum\" function call.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\\n        if(root == nullptr)\\n            return false;\\n        if(root -> left == nullptr && root -> right == nullptr){\\n            sum = sum + root -> val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\\n    }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)\\n\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        sum = 0\\n        return self.rootToLeafPathSum(root, targetSum, sum)\\n\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(n)** // where n is the number of nodes in the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(h)** //where h is the height of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\\n        if(root == nullptr)\\n            return false;\\n        if(root -> left == nullptr && root -> right == nullptr){\\n            sum = sum + root -> val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){\\n        if(root == null)\\n            return false;\\n        if(root.left == null && root.right == null){\\n            sum = sum + root.val;\\n            if(sum == targetSum)\\n                return true;   \\n        }\\n        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);\\n    }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        int sum = 0;\\n        return rootToLeafPathSum(root, targetSum, sum);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def rootToLeafPathSum(self, root: TreeNode, targetSum: int, sum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            sum += root.val\\n            if sum == targetSum:\\n                return True   \\n        return self.rootToLeafPathSum(root.left, targetSum, sum + root.val) or self.rootToLeafPathSum(root.right, targetSum, sum + root.val)\\n\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        sum = 0\\n        return self.rootToLeafPathSum(root, targetSum, sum)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36580,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "  \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // iteration method\\n        if (root == null) {return false;}\\n        Stack<TreeNode> path = new Stack<>();\\n        Stack<Integer> sub = new Stack<>();\\n        path.push(root);\\n        sub.push(root.val);\\n        while (!path.isEmpty()) {\\n            TreeNode temp = path.pop();\\n            int tempVal = sub.pop();\\n            if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n            else {\\n                if (temp.left != null) {\\n                    path.push(temp.left);\\n                    sub.push(temp.left.val + tempVal);\\n                }\\n                if (temp.right != null) {\\n                    path.push(temp.right);\\n                    sub.push(temp.right.val + tempVal);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // recursion method\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // iteration method\\n        if (root == null) {return false;}\\n        Stack<TreeNode> path = new Stack<>();\\n        Stack<Integer> sub = new Stack<>();\\n        path.push(root);\\n        sub.push(root.val);\\n        while (!path.isEmpty()) {\\n            TreeNode temp = path.pop();\\n            int tempVal = sub.pop();\\n            if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n            else {\\n                if (temp.left != null) {\\n                    path.push(temp.left);\\n                    sub.push(temp.left.val + tempVal);\\n                }\\n                if (temp.right != null) {\\n                    path.push(temp.right);\\n                    sub.push(temp.right.val + tempVal);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        // recursion method\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36382,
                "title": "accepted-by-using-postorder-traversal",
                "content": "In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited.so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.\\nat leaf node, if SUM == sum, OK, return true. After postorder traversal, return false.\\n\\nI have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near.\\n\\nbelow is my iterator code.\\n\\n\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            stack<TreeNode *> s;\\n            TreeNode *pre = NULL, *cur = root;\\n            int SUM = 0;\\n            while (cur || !s.empty()) {\\n                while (cur) {\\n                    s.push(cur);\\n                    SUM += cur->val;\\n                    cur = cur->left;\\n                }\\n                cur = s.top();\\n                if (cur->left == NULL && cur->right == NULL && SUM == sum) {\\n                    return true;\\n                }\\n                if (cur->right && pre != cur->right) {\\n                    cur = cur->right;\\n                } else {\\n                    pre = cur;\\n                    s.pop();\\n                    SUM -= cur->val;\\n                    cur = NULL;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            stack<TreeNode *> s;\\n            TreeNode *pre = NULL, *cur = root;\\n            int SUM = 0;\\n            while (cur || !s.empty()) {\\n                while (cur) {\\n                    s.push(cur);\\n                    SUM += cur->val;\\n                    cur = cur->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2658162,
                "title": "c-beats-95-easy-explained-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Ques)** Why we `return left || right` ???\\n**Ans =>** `return left || right` means we are checking either root->left side gives us our targetSum or root->right side gives us our targetSum\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dd5b3b44-6321-44eb-8a47-add0158c3dad_1664857526.350247.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36534,
                "title": "my-java-no-recursive-method",
                "content": "the idea is preorder traverse , instead of using recursive call, I am using a stack.\\nthe only problem is that I changed TreeNode value\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n    \\t    Stack <TreeNode> stack = new Stack<> ();\\t    \\n    \\t    stack.push(root) ;\\t    \\n    \\t    while (!stack.isEmpty() && root != null){\\n    \\t    \\tTreeNode cur = stack.pop() ;\\t\\n    \\t    \\tif (cur.left == null && cur.right == null){\\t    \\t\\t\\n    \\t    \\t\\tif (cur.val == sum ) return true ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.right != null) {\\n    \\t    \\t\\tcur.right.val = cur.val + cur.right.val ;\\n    \\t    \\t\\tstack.push(cur.right) ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.left != null) {\\n    \\t    \\t\\tcur.left.val = cur.val + cur.left.val;\\n    \\t    \\t\\tstack.push(cur.left);\\n    \\t    \\t}\\n    \\t    }\\t    \\n    \\t    return false ;\\n    \\t }",
                "solutionTags": [],
                "code": "the idea is preorder traverse , instead of using recursive call, I am using a stack.\\nthe only problem is that I changed TreeNode value\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n    \\t    Stack <TreeNode> stack = new Stack<> ();\\t    \\n    \\t    stack.push(root) ;\\t    \\n    \\t    while (!stack.isEmpty() && root != null){\\n    \\t    \\tTreeNode cur = stack.pop() ;\\t\\n    \\t    \\tif (cur.left == null && cur.right == null){\\t    \\t\\t\\n    \\t    \\t\\tif (cur.val == sum ) return true ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.right != null) {\\n    \\t    \\t\\tcur.right.val = cur.val + cur.right.val ;\\n    \\t    \\t\\tstack.push(cur.right) ;\\n    \\t    \\t}\\n    \\t    \\tif (cur.left != null) {\\n    \\t    \\t\\tcur.left.val = cur.val + cur.left.val;\\n    \\t    \\t\\tstack.push(cur.left);\\n    \\t    \\t}\\n    \\t    }\\t    \\n    \\t    return false ;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 1285179,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum)\\n    {\\n        if(root == NULL)\\n        {\\n            return false;\\n        }\\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\\n        {\\n            return true;\\n        }\\n        \\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n        \\n        return left || right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36596,
                "title": "one-line-solution-sharing-in-javascript",
                "content": "Since this problem is quite straight forward, so I played around a bit and turned it into the shortest solution as below.\\n\\n    /**\\n     * Memo:\\n     * Complex: O(n)\\n     * Runtime: 164ms\\n     * Tests: 114 test cases passed\\n     * Rank: A\\n     */\\n    var hasPathSum = function(root, sum) { return root ? (!root.left && !root.right) ? sum === root.val : (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) : false; };\\n\\nWhile it is equivalent as the following\\n \\n    var hasPathSum = function(root, sum) {\\n        if (!root) return false;\\n\\n        if (!root.left && !root.right) { // check leaf\\n            return sum === root.val;\\n        } else { // continue DFS\\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "Since this problem is quite straight forward, so I played around a bit and turned it into the shortest solution as below.\\n\\n    /**\\n     * Memo:\\n     * Complex: O(n)\\n     * Runtime: 164ms\\n     * Tests: 114 test cases passed\\n     * Rank: A\\n     */\\n    var hasPathSum = function(root, sum) { return root ? (!root.left && !root.right) ? sum === root.val : (hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)) : false; };\\n\\nWhile it is equivalent as the following\\n \\n    var hasPathSum = function(root, sum) {\\n        if (!root) return false;\\n\\n        if (!root.left && !root.right) { // check leaf\\n            return sum === root.val;\\n        } else { // continue DFS\\n            return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 36372,
                "title": "easy-5-lines-and-clean-java-solution",
                "content": "   You simply check if current node (starting with root) is a leaf node and sum is equal its value. If not, you just check left or right with the decremented sum. If one of them returns true, it has a path.\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {    \\n      if (root == null)\\n         return false;\\n            \\n      if (root.left == null && root.right == null && root.val == sum) // Leaf check\\n         return true;\\n            \\n      return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "   You simply check if current node (starting with root) is a leaf node and sum is equal its value. If not, you just check left or right with the decremented sum. If one of them returns true, it has a path.\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {    \\n      if (root == null)\\n         return false;\\n            \\n      if (root.left == null && root.right == null && root.val == sum) // Leaf check\\n         return true;\\n            \\n      return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36370,
                "title": "a-java-concise-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n       if(root == null){\\n\\t     return false;\\n\\t   }\\n       if(root.left == null && root.right == null){\\n\\t      return (root.val == sum);\\n\\t   }\\n\\t   return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n       \\t   \\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n       if(root == null){\\n\\t     return false;\\n\\t   }\\n       if(root.left == null && root.right == null){\\n\\t      return (root.val == sum);\\n\\t   }\\n\\t   return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n       \\t   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1749038,
                "title": "c-efficient-recursive-easy-3-lines-solution-with-comments",
                "content": "#### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false;\\n        \\n        //we reached here,i.e the root is not NULL, so we took the root value in our sum, and remaining targetSum is targetSum-root value.\\n        targetSum=targetSum-root->val;\\n        \\n        //if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if(targetSum==0 && root->left==NULL && root->right==NULL) return true;\\n        \\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left,targetSum) || hasPathSum(root->right,targetSum);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false;\\n        \\n        //we reached here,i.e the root is not NULL, so we took the root value in our sum, and remaining targetSum is targetSum-root value.\\n        targetSum=targetSum-root->val;\\n        \\n        //if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if(targetSum==0 && root->left==NULL && root->right==NULL) return true;\\n        \\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left,targetSum) || hasPathSum(root->right,targetSum);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 534122,
                "title": "python-bfs-dfs-recursive-dfs-iterative-solution",
                "content": "#### I. DFS recursive solution\\nAlgorithm:\\n1. Visit a node and check that node is leaf and node.val == sum. If it\\'s true - return True, else continue traverse\\n2. Traverse the left subtree and decrease current sum by value of current node , i.e., call `hasPathSum(node.left, curr_sum - node.val)`\\n3. Traverse the right subtree and decrease current sum by value of current node , i.e., call `hasPathSum(node.right, curr_sum - node.val)`\\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tif not root:\\n\\t\\treturn False\\n\\tif not root.left and not root.right and root.val == sum:\\n\\t\\treturn True\\n\\treturn self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\\n\\n#### II. DFS iterative solution\\nAlgorithm:\\n1. Create empty stack and push root node and current sum to stack.\\n2. Do followind steps while stack is not empty:\\n\\t * Pop `(node, curr_sum)` from stack\\n\\t * Cheack that node is leaf and `node.val == sum`. If it\\'s true - return True, else go to the next step\\n\\t * Push left child of popped node and current sum decreased by popped node value `(node.left, curr_sum - node.val)`.\\n\\t * Push right child of popped node and current sum decreased by popped node value `(node.right, curr_sum - node.val)`.\\n3. Return False if sum is not found.\\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tstack = [(root, sum)]\\n\\twhile stack:\\n\\t\\tnode, curr_sum = stack.pop()\\n\\tif not node:\\n\\t\\tcontinue\\n\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\treturn True\\n\\tstack.append((node.left, curr_sum - node.val))\\n\\tstack.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```\\n\\n#### III. BFS Solution\\n\\nAlgorithm:\\n1. Create empty deque (double-ended queue) and push root node and current sum to queue.\\n2. Do followind steps while queue is not empty:\\n\\t * Do popfront/popleft `(node, curr_sum)` from queue\\n\\t * If node is None - continue\\n\\t * Cheack that node is leaf and `node.val == sum`. If it\\'s true - return True, else go to the next step\\n\\t * Push left child of popped node and current sum decreased by popped node value `(node.left, curr_sum - node.val)` to the queue.\\n\\t * Push right child of popped node and current sum decreased by popped node value `(node.right, curr_sum - node.val)` to the queue.\\n3. Return False if sum is not found.\\n\\n```Python\\nfrom collections import deque\\n\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tdeq = deque()\\n\\tdeq.append((root, sum))\\n\\t\\twhile deq:\\n\\t\\t\\tnode, curr_sum = deq.popleft()\\n\\t\\t\\tif not node:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tdeq.append((node.left, curr_sum - node.val))\\n\\t\\t\\tdeq.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tif not root:\\n\\t\\treturn False\\n\\tif not root.left and not root.right and root.val == sum:\\n\\t\\treturn True\\n\\treturn self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\n```Python\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tstack = [(root, sum)]\\n\\twhile stack:\\n\\t\\tnode, curr_sum = stack.pop()\\n\\tif not node:\\n\\t\\tcontinue\\n\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\treturn True\\n\\tstack.append((node.left, curr_sum - node.val))\\n\\tstack.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```\n```Python\\nfrom collections import deque\\n\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n\\tdeq = deque()\\n\\tdeq.append((root, sum))\\n\\t\\twhile deq:\\n\\t\\t\\tnode, curr_sum = deq.popleft()\\n\\t\\t\\tif not node:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif not node.left and not node.right and curr_sum == node.val:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tdeq.append((node.left, curr_sum - node.val))\\n\\t\\t\\tdeq.append((node.right, curr_sum - node.val))\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1329291,
                "title": "java-three-easy-approach-with-explanation-preorder-postorder-0ms",
                "content": "```\\n1 st Approach \\nclass Solution\\n{\\n    public boolean hasPathSum(TreeNode root, int targetSum)//we always try to approach the zero ----0++++ from any half left or right, like taking limit//if zero found at leaf then true else false\\n    {\\n        if(root == null)\\n            return false;//base case when the selected path is not the desired path //we return false and check in next half of the subtree//base case for terminnation of the recursion \\n        else if(root.left == null && root.right == null && targetSum - root.val == 0)//we have faith in tree that it can find the node if present where the value nutralizes each other at 0\\n            return true;//only the case when we are returning true \\n        else\\n            return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);//if present in left is good otherwiswe we are searching in right subtree recursively //all permutation in ways are done by recursion and not our tension \\n    }\\n}//Please do Upvote, It helps a lot\\n```\\n```\\n2 nd Approach \\n\\nclass Solution \\n{\\n    private boolean flag= false;//we are taking the base case as false, if the sum is not found and if the target sum lies in the path from root to leaf, we make the flag true  \\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) \\n    {\\n        int sum = 0;//calculate the downward sum \\n        \\n        Helper(root, sum, targetSum);//it helps us calculate  the sum of each node for each path from root to leaf and tells us that our desired sum is present or not, by adding the node at that path \\n        \\n        return flag;//returns true if sum is present else false is returned \\n    }\\n    public TreeNode  Helper(TreeNode root, int sum, int targetSum)\\n    {//postorder traversal + semi preorder traversal(accesing root beforehand once), we want to know about child first and then the parent \\n        if(root == null)//base case when we hit the null node, to tell the parent no node is present we return null \\n            return null;\\n        //ROOT\\n        sum= sum + root.val;//adding the node value to sum at each level//accesing root beforehand once\\n        \\n        TreeNode left= Helper(root.left, sum, targetSum);//recursing down the left subtree and knowing about the left child//storring the reference to detect it is leaf or not, if it is leaf then left == null//LEFT\\n        TreeNode right= Helper(root.right, sum, targetSum);//recursing down the right subtree and knowing about the right child//storring the reference to detect it is leaf or not, if it is leaf then right == null//RIGHT\\n        \\n        //ROOT\\n        if(sum == targetSum && left == null && right == null) //if we reached to our desired sum and the parent node is a leaf node, we got our path finally \\n            flag= true;//we make the flag to true as the desired path from root to leaf is achived \\n        \\n        return root;//returning root, to tell the parent that I am present \\n    }\\n}\\n```\\n```\\n3 rd Approach \\nclass Solution {\\n    //0 -- null node, 1 means node, 2 found path node //metadata about the current status of the node \\n     public int PathSum(TreeNode root, int curr, int targetSum){\\n         if ( root == null){\\n            return 0;//we return 0 to tell that i am leaf \\n        }\\n         curr+= root.val;//preorder sum\\n         \\n         int left= PathSum(root.left, curr, targetSum);\\n         \\n         if ( left == 2 )\\n             return 2;//if left path conatins the desired path to leaf node with target sum, we no need to go to right part reccursively\\n         \\n        int right= PathSum(root.right, curr, targetSum);\\n         \\n        if ( right == 2)\\n             return 2;//if right path conatins the desired path to leaf node with target sum, we no need to check further condition we just return 2 in order to indicate desired path has been found\\n         \\n         //Backtracking postorder traversal \\n         \\n        if ( left == 0 && right == 0 && targetSum == curr){//if we reach to leaf node with desired sum we return 2, inorder to indicate we have found the path \\n             return 2;\\n        }\\n        \\n        return 1;//we return 1, to tell that we have not found the desired path till now  \\n     }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if ( root == null){\\n            return false;//empty graph, no path tp find we return false \\n        }\\n        \\n        if ( PathSum(root, 0, targetSum) == 2)//found path case \\n            return true;\\n        else\\n            return false;//not path found case \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n1 st Approach \\nclass Solution\\n{\\n    public boolean hasPathSum(TreeNode root, int targetSum)//we always try to approach the zero ----0++++ from any half left or right, like taking limit//if zero found at leaf then true else false\\n    {\\n        if(root == null)\\n            return false;//base case when the selected path is not the desired path //we return false and check in next half of the subtree//base case for terminnation of the recursion \\n        else if(root.left == null && root.right == null && targetSum - root.val == 0)//we have faith in tree that it can find the node if present where the value nutralizes each other at 0\\n            return true;//only the case when we are returning true \\n        else\\n            return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);//if present in left is good otherwiswe we are searching in right subtree recursively //all permutation in ways are done by recursion and not our tension \\n    }\\n}//Please do Upvote, It helps a lot\\n```\n```\\n2 nd Approach \\n\\nclass Solution \\n{\\n    private boolean flag= false;//we are taking the base case as false, if the sum is not found and if the target sum lies in the path from root to leaf, we make the flag true  \\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) \\n    {\\n        int sum = 0;//calculate the downward sum \\n        \\n        Helper(root, sum, targetSum);//it helps us calculate  the sum of each node for each path from root to leaf and tells us that our desired sum is present or not, by adding the node at that path \\n        \\n        return flag;//returns true if sum is present else false is returned \\n    }\\n    public TreeNode  Helper(TreeNode root, int sum, int targetSum)\\n    {//postorder traversal + semi preorder traversal(accesing root beforehand once), we want to know about child first and then the parent \\n        if(root == null)//base case when we hit the null node, to tell the parent no node is present we return null \\n            return null;\\n        //ROOT\\n        sum= sum + root.val;//adding the node value to sum at each level//accesing root beforehand once\\n        \\n        TreeNode left= Helper(root.left, sum, targetSum);//recursing down the left subtree and knowing about the left child//storring the reference to detect it is leaf or not, if it is leaf then left == null//LEFT\\n        TreeNode right= Helper(root.right, sum, targetSum);//recursing down the right subtree and knowing about the right child//storring the reference to detect it is leaf or not, if it is leaf then right == null//RIGHT\\n        \\n        //ROOT\\n        if(sum == targetSum && left == null && right == null) //if we reached to our desired sum and the parent node is a leaf node, we got our path finally \\n            flag= true;//we make the flag to true as the desired path from root to leaf is achived \\n        \\n        return root;//returning root, to tell the parent that I am present \\n    }\\n}\\n```\n```\\n3 rd Approach \\nclass Solution {\\n    //0 -- null node, 1 means node, 2 found path node //metadata about the current status of the node \\n     public int PathSum(TreeNode root, int curr, int targetSum){\\n         if ( root == null){\\n            return 0;//we return 0 to tell that i am leaf \\n        }\\n         curr+= root.val;//preorder sum\\n         \\n         int left= PathSum(root.left, curr, targetSum);\\n         \\n         if ( left == 2 )\\n             return 2;//if left path conatins the desired path to leaf node with target sum, we no need to go to right part reccursively\\n         \\n        int right= PathSum(root.right, curr, targetSum);\\n         \\n        if ( right == 2)\\n             return 2;//if right path conatins the desired path to leaf node with target sum, we no need to check further condition we just return 2 in order to indicate desired path has been found\\n         \\n         //Backtracking postorder traversal \\n         \\n        if ( left == 0 && right == 0 && targetSum == curr){//if we reach to leaf node with desired sum we return 2, inorder to indicate we have found the path \\n             return 2;\\n        }\\n        \\n        return 1;//we return 1, to tell that we have not found the desired path till now  \\n     }\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if ( root == null){\\n            return false;//empty graph, no path tp find we return false \\n        }\\n        \\n        if ( PathSum(root, 0, targetSum) == 2)//found path case \\n            return true;\\n        else\\n            return false;//not path found case \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054429,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)\\n            return false;\\n        if(!root->left && !root->right && root->val==targetSum)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum-root->val) ||\\n            hasPathSum(root->right, targetSum-root->val);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)\\n            return false;\\n        if(!root->left && !root->right && root->val==targetSum)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum-root->val) ||\\n            hasPathSum(root->right, targetSum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36581,
                "title": "my-python-iterative-dfs-solution",
                "content": "    \\n    def hasPathSum(self, root, sum):\\n        if root is None:\\n            return False\\n        stack = [(root, sum)]\\n        while stack:\\n            node, _sum = stack.pop()\\n            if node.left is node.right is None and node.val == _sum:\\n                return True\\n            if node.left:\\n                stack.append((node.left, _sum - node.val))\\n            if node.right:\\n                stack.append((node.right, _sum - node.val))\\n        return False\\n\\n\\nCurrent node and the sum until current node as a tuple is pushed onto the stack to keep track of the sum.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    def hasPathSum(self, root, sum):\\n        if root is None:\\n            return False\\n        stack = [(root, sum)]\\n        while stack:\\n            node, _sum = stack.pop()\\n            if node.left is node.right is None and node.val == _sum:\\n                return True\\n            if node.left:\\n                stack.append((node.left, _sum - node.val))\\n            if node.right:\\n                stack.append((node.right, _sum - node.val))\\n        return False\\n\\n\\nCurrent node and the sum until current node as a tuple is pushed onto the stack to keep track of the sum.",
                "codeTag": "Python3"
            },
            {
                "id": 518530,
                "title": "c-97-runtime-iterative-and-recursive-solution",
                "content": "Iterative Solution \\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        stack<pair<TreeNode*,int>> stack;\\n        stack.push({root, root->val});\\n        while(!stack.empty()) {\\n            TreeNode* current = stack.top().first; \\n            int total_sum = stack.top().second; stack.pop();\\n            if(current->right) stack.push({current->right, total_sum+current->right->val});\\n            if(current->left) stack.push({current->left, total_sum+current->left->val});\\n            if(!current->right && !current->left && total_sum==sum) { //if its a leaf\\n                return true; //and total sum is found\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nRecursive Solution\\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        int new_sum = sum - root->val;\\n        if(!root->left && !root->right) return new_sum==0;\\n        return hasPathSum(root->left, new_sum) || hasPathSum(root->right, new_sum);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        stack<pair<TreeNode*,int>> stack;\\n        stack.push({root, root->val});\\n        while(!stack.empty()) {\\n            TreeNode* current = stack.top().first; \\n            int total_sum = stack.top().second; stack.pop();\\n            if(current->right) stack.push({current->right, total_sum+current->right->val});\\n            if(current->left) stack.push({current->left, total_sum+current->left->val});\\n            if(!current->right && !current->left && total_sum==sum) { //if its a leaf\\n                return true; //and total sum is found\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nbool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n        int new_sum = sum - root->val;\\n        if(!root->left && !root->right) return new_sum==0;\\n        return hasPathSum(root->left, new_sum) || hasPathSum(root->right, new_sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170024,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return True\\n            else:\\n                return False\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\\nDFS:\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        stack = [(root,sum - root.val)]\\n        while stack:\\n            u = stack.pop()\\n            if not u[0].left and not u[0].right:\\n                if u[1] == 0:\\n                    return True\\n            if u[0].left:\\n                stack.append((u[0].left, u[1]-u[0].left.val))\\n            if u[0].right:\\n                stack.append((u[0].right, u[1]-u[0].right.val))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return True\\n            else:\\n                return False\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        stack = [(root,sum - root.val)]\\n        while stack:\\n            u = stack.pop()\\n            if not u[0].left and not u[0].right:\\n                if u[1] == 0:\\n                    return True\\n            if u[0].left:\\n                stack.append((u[0].left, u[1]-u[0].left.val))\\n            if u[0].right:\\n                stack.append((u[0].right, u[1]-u[0].right.val))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977919,
                "title": "easy-solution-python3-c-c-c-java-explain-line-by-line-with-image",
                "content": "# Problem\\nYou\\'re given a binary tree and an integer targetSum. The task is to determine whether there exists a root-to-leaf path in the tree where the sum of the values of the nodes along the path equals the targetSum.\\n\\nIn other words, you need to check if there\\'s a sequence of nodes starting from the root and following edges to reach a leaf node such that the sum of values along this path is equal to the given targetSum.\\n\\n\\n---\\n# Solution\\nThe provided solution is implemented as a method named hasPathSum within a class named Solution. The method takes two parameters: root, which is the root node of the binary tree, and targetSum, the desired sum.\\n\\n\\n**Here\\'s how the solution works:** \\n\\n1. f root is None (i.e., the tree is empty), there can\\'t be any path with the desired sum. So, the function returns False.\\n2. If root is a leaf node (i.e., it has no left or right children), the function checks whether the value of the leaf node is equal to the remaining targetSum. If they are equal, it returns True, indicating that a valid path with the target sum has been found.\\n3. If the above conditions are not met, the function recursively checks for a valid path with the target sum in both the left and right subtrees. It subtracts the value of the current node from the targetSum before passing it to the recursive calls.\\n4. The result of the recursive calls on the left and right subtrees (left_sum and right_sum) are then combined using the logical OR operation. This is because if either the left subtree or the right subtree has a valid path, it means there\\'s a valid path in the entire tree, so the function should return True.\\n5. If none of the above conditions are met, the function returns False.\\n\\nThe base cases (when the tree is empty or when a leaf node with a matching value is found) guarantee that the recursion will eventually terminate. The recursion explores all possible paths from the root to leaf nodes, checking if any of them sum up to the given targetSum. The logical OR operation on the results of the recursive calls ensures that the function correctly returns True if a valid path is found anywhere in the tree.\\n\\nThis solution has a time complexity of O(N), where N is the number of nodes in the binary tree, as it visits each node once in the worst case.\\n\\n![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/5bd15a5a-5ff9-4683-82d9-2c25a18bc26a_1693336283.4753764.png)\\n\\n\\n# Code\\n---\\n\\n```Python3 []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\\n```C# []\\npublic class Solution\\n{\\n    public bool HasPathSum(TreeNode root, int targetSum)\\n    {\\n        if (root == null)\\n        {\\n            return false;\\n        }\\n\\n        if (root.left == null && root.right == null)\\n        {\\n            return targetSum == root.val;\\n        }\\n\\n        bool leftSum = HasPathSum(root.left, targetSum - root.val);\\n        bool rightSum = HasPathSum(root.right, targetSum - root.val);\\n\\n        return leftSum || rightSum;\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) {\\n            return false;\\n        }\\n        \\n        if (!root->left && !root->right) {\\n            return targetSum == root->val;\\n        }\\n        \\n        bool left_sum = hasPathSum(root->left, targetSum - root->val);\\n        bool right_sum = hasPathSum(root->right, targetSum - root->val);\\n        \\n        return left_sum || right_sum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.left == null && root.right == null) {\\n            return targetSum == root.val;\\n        }\\n        \\n        boolean leftSum = hasPathSum(root.left, targetSum - root.val);\\n        boolean rightSum = hasPathSum(root.right, targetSum - root.val);\\n        \\n        return leftSum || rightSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\n```python []\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        if not root.left and not root.right:\\n            return targetSum == root.val\\n        \\n        left_sum = self.hasPathSum(root.left, targetSum - root.val)\\n        right_sum = self.hasPathSum(root.right, targetSum - root.val)\\n        \\n        return left_sum or right_sum\\n```\n```C# []\\npublic class Solution\\n{\\n    public bool HasPathSum(TreeNode root, int targetSum)\\n    {\\n        if (root == null)\\n        {\\n            return false;\\n        }\\n\\n        if (root.left == null && root.right == null)\\n        {\\n            return targetSum == root.val;\\n        }\\n\\n        bool leftSum = HasPathSum(root.left, targetSum - root.val);\\n        bool rightSum = HasPathSum(root.right, targetSum - root.val);\\n\\n        return leftSum || rightSum;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) {\\n            return false;\\n        }\\n        \\n        if (!root->left && !root->right) {\\n            return targetSum == root->val;\\n        }\\n        \\n        bool left_sum = hasPathSum(root->left, targetSum - root->val);\\n        bool right_sum = hasPathSum(root->right, targetSum - root->val);\\n        \\n        return left_sum || right_sum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        if (root.left == null && root.right == null) {\\n            return targetSum == root.val;\\n        }\\n        \\n        boolean leftSum = hasPathSum(root.left, targetSum - root.val);\\n        boolean rightSum = hasPathSum(root.right, targetSum - root.val);\\n        \\n        return leftSum || rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658019,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/PNj2PJfY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/PNj2PJfY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 36489,
                "title": "3-line-java-solution",
                "content": "\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && root.val == sum) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2658792,
                "title": "python-elegant-short-dfs",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            return target == root.val\\n        return self.hasPathSum( root.left, target - root.val) or \\\\\\n               self.hasPathSum(root.right, target - root.val)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None:\\n            return target == root.val\\n        return self.hasPathSum( root.left, target - root.val) or \\\\\\n               self.hasPathSum(root.right, target - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255933,
                "title": "c-dfs-multiple-solutions",
                "content": "```\\nSolution 1: \\nclass Solution {\\npublic:\\n    \\n    int pathSum = 0; \\n    bool pathFound = false;\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {                \\n        if(root != NULL)\\n        {\\n            pathSum += root->val;\\n            \\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                if(pathSum == targetSum)\\n                    pathFound = true;\\n            }\\n            else\\n            {\\n                hasPathSum(root->left, targetSum);\\n                hasPathSum(root->right, targetSum);\\n            }\\n            \\n            pathSum -= root->val;    \\n        }\\n\\n        return (pathFound == true) ? true : false;\\n     }\\n};\\n\\nSolution 2: \\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {        \\n        if (root == nullptr) \\n        {\\n          return false;\\n        }\\n\\n        // if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) \\n        {\\n          return true;\\n        }\\n\\t\\t\\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nSolution 1: \\nclass Solution {\\npublic:\\n    \\n    int pathSum = 0; \\n    bool pathFound = false;\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {                \\n        if(root != NULL)\\n        {\\n            pathSum += root->val;\\n            \\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                if(pathSum == targetSum)\\n                    pathFound = true;\\n            }\\n            else\\n            {\\n                hasPathSum(root->left, targetSum);\\n                hasPathSum(root->right, targetSum);\\n            }\\n            \\n            pathSum -= root->val;    \\n        }\\n\\n        return (pathFound == true) ? true : false;\\n     }\\n};\\n\\nSolution 2: \\n\\nclass Solution {\\npublic:\\n    \\n   \\n    bool hasPathSum(TreeNode* root, int targetSum) \\n    {        \\n        if (root == nullptr) \\n        {\\n          return false;\\n        }\\n\\n        // if the current node is a leaf and its value is equal to the sum, we\\'ve found a path\\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) \\n        {\\n          return true;\\n        }\\n\\t\\t\\n        // recursively call to traverse the left and right sub-tree\\n        // return true if any of the two recursive call return true\\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36470,
                "title": "u3010python-u3011recursive-solution-with-explanation-and-thinking-process",
                "content": "## Base case\\n1. This question wants to find a path from node to the **leaf**, so the node who satisfies must be a **leaf** (`not node.left and not nood.right`)\\n2. I want to recursively subtract the `sum` by current node's value, so the leaf node of correct path must have the same value of its assigned `sum`\\n\\n## Recursive step\\n1. We want to traverse all the nodes, so `node.left` and `node.right` must be called parallelly\\n2. One valid path is enough, so we want to use `or` to connect two \"branches\"\\n3. Considering each node as the root of its children, `sum` should be modified from its parent\\n\\n<br>\\n\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n            \\n        if root.val == sum and not root.left and not root.right:\\n            return True\\n            \\n        return self.hasPathSum(root.left, sum - root.val) or \\\\\\n               self.hasPathSum(root.right, sum - root.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Base case\\n1. This question wants to find a path from node to the **leaf**, so the node who satisfies must be a **leaf** (`not node.left and not nood.right`)\\n2. I want to recursively subtract the `sum` by current node's value, so the leaf node of correct path must have the same value of its assigned `sum`\\n\\n## Recursive step\\n1. We want to traverse all the nodes, so `node.left` and `node.right` must be called parallelly\\n2. One valid path is enough, so we want to use `or` to connect two \"branches\"\\n3. Considering each node as the root of its children, `sum` should be modified from its parent\\n\\n<br>\\n\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n            \\n        if root.val == sum and not root.left and not root.right:\\n            return True\\n            \\n        return self.hasPathSum(root.left, sum - root.val) or \\\\\\n               self.hasPathSum(root.right, sum - root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 2432844,
                "title": "very-easy-100-3-line-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == null) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 89.18% of C++ online submissions for Path Sum.\\nMemory Usage: 11.2 MB, less than 92.17% of C++ online submissions for Path Sum.\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == NULL) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\\n\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == null) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == NULL) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == null) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        // If the tree is empty i.e. root is NULL, return false...\\n\\t    if (root == NULL) return false;\\n        // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n        // Call the same function recursively for left and right subtree...\\n\\t    return hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == null) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root.val == targetSum && (root.left == null && root.right == null)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root.left, targetSum - root.val)|| hasPathSum(root.right, targetSum - root.val);\\n};\\n```\n```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    // If the tree is empty i.e. root is NULL, return false...\\n\\tif (root == NULL) return false;\\n    // If there is only a single root node and the value of root node is equal to the targetSum...\\n\\tif (root->val == targetSum && (root->left == NULL && root->right == NULL)) return true;\\n    // Call the same function recursively for left and right subtree...\\n\\treturn hasPathSum(root->left, targetSum - root->val)|| hasPathSum(root->right, targetSum - root->val);\\n}\\n```\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        # If the tree is empty i.e. root is NULL, return false...\\n\\t    if root is None: return 0\\n        # If there is only a single root node and the value of root node is equal to the targetSum...\\n\\t    if root.val == targetSum and (root.left is None and root.right is None):  return 1\\n        # Call the same function recursively for left and right subtree...\\n\\t    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658225,
                "title": "java-easy-solution-2-liner-code-recursive",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\npublic class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        sum = sum - root.val;\\n        if(root.left==null && root.right==null){\\n            if(sum == 0)return true;\\n            else return false;\\n        }\\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n        \\n        \\n    }\\n    \\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        sum = sum - root.val;\\n        if(root.left==null && root.right==null){\\n            if(sum == 0)return true;\\n            else return false;\\n        }\\n        return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n        \\n        \\n    }\\n    \\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928074,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else { return false }\\n        \\n        if root.val == targetSum && root.left == nil && root.right == nil { return true }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else { return false }\\n        \\n        if root.val == targetSum && root.left == nil && root.right == nil { return true }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779613,
                "title": "python-simple-dfs",
                "content": "```\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n    if not root: # edge case\\n        return False\\n    if not root.left and not root.right: \\n        return sum == root.val\\n    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n    if not root: # edge case\\n        return False\\n    if not root.left and not root.right: \\n        return sum == root.val\\n    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3193152,
                "title": "path-sum-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses an iterative approach with a stack to traverse the binary tree and keep track of the current path value. It checks if the current node is a leaf node and its value matches the target sum. If not, it adds the left and right children to the stack along with their updated path value. It returns False if no such path is found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        # Use a list to store the path from root to the current node\\n        stack = [(root, root.val)]\\n        \\n        while stack:\\n            node, val = stack.pop()\\n            \\n            # Check if the current node is a leaf node and its value matches the targetSum\\n            if not node.left and not node.right and val == targetSum:\\n                return True\\n            \\n            # Add the left and right children to the stack along with their updated path value\\n            if node.left:\\n                stack.append((node.left, val + node.left.val))\\n            if node.right:\\n                stack.append((node.right, val + node.right.val))\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        # Use a list to store the path from root to the current node\\n        stack = [(root, root.val)]\\n        \\n        while stack:\\n            node, val = stack.pop()\\n            \\n            # Check if the current node is a leaf node and its value matches the targetSum\\n            if not node.left and not node.right and val == targetSum:\\n                return True\\n            \\n            # Add the left and right children to the stack along with their updated path value\\n            if node.left:\\n                stack.append((node.left, val + node.left.val))\\n            if node.right:\\n                stack.append((node.right, val + node.right.val))\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207135,
                "title": "easy-js-solution",
                "content": "```\\n/*\\n1. Use DFS to try all possible paths.\\n2. Keep track of the sum of path during traversal. When leaf node is reached, check if\\nthe sum of path equals the target. If so, return true, else continue DFS traversal to\\ntry other paths.\\n*/\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n1. Use DFS to try all possible paths.\\n2. Keep track of the sum of path during traversal. When leaf node is reached, check if\\nthe sum of path equals the target. If so, return true, else continue DFS traversal to\\ntry other paths.\\n*/\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190588,
                "title": "python-recursive-approach-easy-to-solve",
                "content": "Think about one small tree. Let say we have only one node like\\n```\\n\\t\\t\\t\\t\\t    1\\n\\t\\t\\t\\tNone         None\\n```\\nand targetSum is 1, so our condtion will be \\n```\\nif root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n```\\n  \\n                     1\\n\\t\\t\\t\\t2         3\\nand targetSum is 4\\nFor the above example we have the path sum in right hand side, so whenever we are recursively calling on a node we will check both side of the tree.\\n```\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if root is None: return False\\n        \\n        if root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n        \\n        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)\\n```\\nPlease Upvote if you get it.\\n\\nPlease check out Path sum II solution. (https://leetcode.com/problems/path-sum-ii/discuss/1192146/Python-or-Recursive-approach-or-97-beats)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t    1\\n\\t\\t\\t\\tNone         None\\n```\n```\\nif root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n```\n```\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if root is None: return False\\n        \\n        if root.left is None and root.right is None and root.val == targetSum:\\n            return True\\n        \\n        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744383,
                "title": "c-solution-recursion-iterative-dfs-iterative-bfs",
                "content": "```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (not root) return false;\\n    sum -= root->val;\\n    if (not root->left and not root->right) {\\n      return sum == 0;\\n    }\\n    return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\\n  }\\n};\\n```\\n//DFS\\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (!root) return false;\\n    stack<pair<TreeNode*, int>> stk;\\n    stk.push({root, sum});\\n    while (!stk.empty()) {\\n      auto [node, curr_sum] = stk.top();\\n      stk.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) {\\n        return true;\\n      }\\n      if (node->right) stk.push({node->right, curr_sum});\\n      if (node->left) stk.push({node->left, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n```\\n// BFS\\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode *root, int sum) {\\n    if (!root) return false;\\n    queue<pair<TreeNode *, int>> q;\\n    q.push({root, sum});\\n    while (!q.empty()) {\\n      auto [node, curr_sum] = q.front();\\n      q.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) return true;\\n      if (node->left) q.push({node->left, curr_sum});\\n      if (node->right) q.push({node->right, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (not root) return false;\\n    sum -= root->val;\\n    if (not root->left and not root->right) {\\n      return sum == 0;\\n    }\\n    return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode* root, int sum) {\\n    if (!root) return false;\\n    stack<pair<TreeNode*, int>> stk;\\n    stk.push({root, sum});\\n    while (!stk.empty()) {\\n      auto [node, curr_sum] = stk.top();\\n      stk.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) {\\n        return true;\\n      }\\n      if (node->right) stk.push({node->right, curr_sum});\\n      if (node->left) stk.push({node->left, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  bool hasPathSum(TreeNode *root, int sum) {\\n    if (!root) return false;\\n    queue<pair<TreeNode *, int>> q;\\n    q.push({root, sum});\\n    while (!q.empty()) {\\n      auto [node, curr_sum] = q.front();\\n      q.pop();\\n      curr_sum -= node->val;\\n      if (!node->left && !node->right && curr_sum == 0) return true;\\n      if (node->left) q.push({node->left, curr_sum});\\n      if (node->right) q.push({node->right, curr_sum});\\n    }\\n    return false;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768446,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6a3e9288-d254-4302-b55e-0e221543c512_1689421045.2787068.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        // Check if the current node is a leaf node and its value matches the targetSum\\n        if (root.left == null && root.right == null && root.val == targetSum) {\\n            return true;\\n        }\\n        \\n        // Recursively check the left and right subtrees with updated targetSum\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        // Check if the current node is a leaf node and its value matches the targetSum\\n        if (root.left == null && root.right == null && root.val == targetSum) {\\n            return true;\\n        }\\n        \\n        // Recursively check the left and right subtrees with updated targetSum\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799035,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658451,
                "title": "path-sum-99-22-fastest-execution-c-3-line-easy-solution-simple-and-short",
                "content": "**SHIVAM DAILY LEETCODE SOLUTIONS || CHECK : [https://bit.ly/leetcode-solutions](https://bit.ly/leetcode-solutions)\\nRuntime: 4 ms, faster than 99.22% of C++ online submissions for Path Sum.\\nMemory Usage: 21.4 MB, less than 38.76% of C++ online submissions for Path Sum.** \\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum)\\n    {\\n        if (!root) return false;\\n        if (!root->left && !root->right) return root->val == sum;\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/6523b1bc-71a3-4707-b34e-bcd7a708ca8d_1664862675.8947413.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum)\\n    {\\n        if (!root) return false;\\n        if (!root->left && !root->right) return root->val == sum;\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518065,
                "title": "javascript-solution-98-32",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    return dfs(root, 0, sum);\\n};\\n\\nvar dfs = function(curr, currentSum, targetSum) {\\n    if (!curr) {\\n        return false;\\n    }\\n\\n    currentSum += curr.val;\\n    \\n    if (curr.left === null && curr.right === null) {\\n        return currentSum === targetSum;\\n    }\\n    \\n    return dfs(curr.left, currentSum, targetSum) || dfs(curr.right, currentSum, targetSum);\\n}\\n```\\n\\nRuntime: 56 ms, faster than 98.32% of JavaScript online submissions for Path Sum.\\nMemory Usage: 37.1 MB, less than 100.00% of JavaScript online submissions for Path Sum.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    return dfs(root, 0, sum);\\n};\\n\\nvar dfs = function(curr, currentSum, targetSum) {\\n    if (!curr) {\\n        return false;\\n    }\\n\\n    currentSum += curr.val;\\n    \\n    if (curr.left === null && curr.right === null) {\\n        return currentSum === targetSum;\\n    }\\n    \\n    return dfs(curr.left, currentSum, targetSum) || dfs(curr.right, currentSum, targetSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36531,
                "title": "share-my-3-lines-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(!root) return false;\\n            if((root -> val == sum) && ((!root -> left) && (!root -> right))) return true;\\n            return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(!root) return false;\\n            if((root -> val == sum) && ((!root -> left) && (!root -> right))) return true;\\n            return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36600,
                "title": "4-ms-c-solution-recursion",
                "content": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        if (!root) \\n            return false;\\n        if (!root->right && !root->left) \\n            return sum==root->val;\\n        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);\\n    }",
                "solutionTags": [],
                "code": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        if (!root) \\n            return false;\\n        if (!root->right && !root->left) \\n            return sum==root->val;\\n        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198445,
                "title": "recursive-depth-first-traversal-with-sum-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse the tree in a depth-first manner, keeping track of the sum of values along the path from the root to the current node. When we reach a leaf node, we check if the sum is equal to the target sum. If yes, we return true, otherwise, we continue traversing the tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a function `hasPathSum` that takes the root node of the binary tree and the target sum as input, and returns a boolean value indicating whether there exists a root-to-leaf path with the given sum.\\n\\nThe first base case is when the root is None, which means we have reached the end of a branch without finding the target sum. In this case, we return False.\\n\\nThe second base case is when the root is a leaf node, which means we have reached the end of a root-to-leaf path. In this case, we check if the sum of values along the path is equal to the target sum. If yes, we return True, otherwise, we return False.\\n\\nIn the recursive case, we call the `hasPathSum` function on the left and right subtrees, with the target sum reduced by the value of the current node. If either of these recursive calls returns True, we return True, because there exists a root-to-leaf path with the target sum. Otherwise, we continue traversing the tree.\\n# Complexity\\n- Time complexity:$O(n)$, where n is the number of nodes in the binary tree. We need to visit every node once to check if it is a leaf node and calculate the sum along the path.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$ O(h)$, where h is the height of the binary tree. In the worst case, the recursion stack will have h frames, one for each level of the tree.\\n\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        if not root.left and not root.right: # leaf node\\n            return targetSum == root.val\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        if not root.left and not root.right: # leaf node\\n            return targetSum == root.val\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661481,
                "title": "c-2-different-approach-recursive-iterative",
                "content": "I came up with 2 different approaches for this problem. Please let me know if you have other ideas or if you have suggestions on how to improve one of the solutions. This problem many good solutions have been posted already, nevertheless I just had fun writing up my thoughts. So here we go. :)\\n\\n\\n### Approach 1: recursive\\n\\nWhen we hear \"binary tree\" the first reaction should almost always be \"recursion\", so here we go:\\n\\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        \\n        if (!root->left && !root->right) return root->val == targetSum;\\n        \\n        return\\n            hasPathSum(root->left, targetSum - root->val) ||\\n            hasPathSum(root->right, targetSum - root->val);\\n    }\\n```\\n\\nPlease note that the code above is better in case there is actually a path, then the following code without \"short circute evaluation\":\\n\\n```cpp\\n        bool left = hasPathSum(root->left, targetSum - root->val);\\n        bool right = hasPathSum(root->right, targetSum - root->val);\\n        return left || right;\\n```\\n\\nThis could be fixed by adding an extra ```if (left) return true;```, but IMO the code above is just the cleanest and shortest solution here.\\n\\n**Complexity Analysis**\\n\\nLet $$n$$ be the number of nodes in the tree, and $$h$$ be the height of the tree, which can range from $$\\\\log n$$ if the tree is perfectly balanced to $$n$$ in the case the tree is basically a linked list.\\n\\n* Time complexity: $$O(n)$$ worst case we need to visit all the nodes.\\n* Space complexity: $$O(h)$$ we need that for the recursion stack.\\n\\n### Approach 2: iterative\\n\\nThe iterative version is straight forward as well if we use a ```stack<pair<TreeNode, int>>```.\\n\\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n\\n        stack<pair<const TreeNode*, int>> st;\\n        st.push({root, targetSum});\\n\\n        while (!empty(st)) {\\n            const auto [node, target] = st.top(); st.pop();\\n            if (!node->left && !node->right && node->val == target) return true;\\n            \\n            if (node->left) st.push({node->left, target - node->val});\\n            if (node->right) st.push({node->right, target - node->val});\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\nWe could use a ```queue``` instead of a ```stack```, but using a BFS like aproach seems a bit pointless to me for this problem. Please let me know if there are good reasons to consider BFS as well.\\n\\nOne aspect I like about an iterative solution is that it seems easier to handle problematic input. Imagine the tree we get is actually not a tree put has a circle. The solutions above would run out of call stack space or allocate more and more memory and eventually run out of memory. For the iterative version we could easly add something like:\\n\\n\\n```cpp\\n   if (size(stack) > 10000) {\\n      LOG_ERROR(\"Tree too larger or input is not a tree.\");\\n      return false;\\n   }\\n```\\n\\nHow to best handle the error would be another questions. Do we want to use exceptions or do we want to use a different API to be able to pass the error to the caller is intersting questions to explore.\\n\\n\\n**Complexity Analysis**\\nThis is basically the same as for approach 1, but we are using an explict stack instead of the implict call stack, but it would grow at the same speed.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        \\n        if (!root->left && !root->right) return root->val == targetSum;\\n        \\n        return\\n            hasPathSum(root->left, targetSum - root->val) ||\\n            hasPathSum(root->right, targetSum - root->val);\\n    }\\n```\n```cpp\\n        bool left = hasPathSum(root->left, targetSum - root->val);\\n        bool right = hasPathSum(root->right, targetSum - root->val);\\n        return left || right;\\n```\n```if (left) return true;```\n```stack<pair<TreeNode, int>>```\n```cpp\\n    static bool hasPathSum(const TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n\\n        stack<pair<const TreeNode*, int>> st;\\n        st.push({root, targetSum});\\n\\n        while (!empty(st)) {\\n            const auto [node, target] = st.top(); st.pop();\\n            if (!node->left && !node->right && node->val == target) return true;\\n            \\n            if (node->left) st.push({node->left, target - node->val});\\n            if (node->right) st.push({node->right, target - node->val});\\n        }\\n        \\n        return false;\\n    }\\n```\n```queue```\n```stack```\n```cpp\\n   if (size(stack) > 10000) {\\n      LOG_ERROR(\"Tree too larger or input is not a tree.\");\\n      return false;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658315,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        \\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654324,
                "title": "java-100-faster-recursion",
                "content": "## Please upvote if it helps! Thx :D\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n\\tif (root == null) return false;\\n\\tif (root.left == null && root.right==null && root.val == targetSum) return true;\\n\\ttargetSum -= root.val;\\n\\treturn hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n\\tif (root == null) return false;\\n\\tif (root.left == null && root.right==null && root.val == targetSum) return true;\\n\\ttargetSum -= root.val;\\n\\treturn hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350383,
                "title": "python3-recursively-and-iteratively",
                "content": "recursively:\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        sum -= root.val\\n        if not root.left and not root.right:\\n            return sum == 0\\n        return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)\\n```\\nIteratively:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        stack = [[root,sum-root.val]]\\n        while stack:\\n            cur,curr_sum = stack.pop()\\n            if not cur.left and not cur.right and curr_sum == 0:\\n                return True\\n            if cur.right:\\n                stack.append((cur.right,curr_sum-cur.right.val))\\n            if cur.left:\\n                stack.append((cur.left, curr_sum-cur.left.val))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        sum -= root.val\\n        if not root.left and not root.right:\\n            return sum == 0\\n        return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        stack = [[root,sum-root.val]]\\n        while stack:\\n            cur,curr_sum = stack.pop()\\n            if not cur.left and not cur.right and curr_sum == 0:\\n                return True\\n            if cur.right:\\n                stack.append((cur.right,curr_sum-cur.right.val))\\n            if cur.left:\\n                stack.append((cur.left, curr_sum-cur.left.val))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486462,
                "title": "solution",
                "content": "The function hasPathSum checks if there is a path from the root to the leaves in the binary tree defined by the root, whose sum of vertex values is equal to the given number targetSum.\\n\\nThe function first checks if the root is empty. If it is empty, the function returns false, since an empty tree has no path from the root to the leaves.\\n\\nThen it subtracts the value of the root from targetSum. It then checks to see if the current node is a leaf, that is, it has no child nodes. If so, the function returns the result of comparing targetSum to zero. If the sum in the current node goes to the right number and the current node is a leaf, then we have found the path from the root to the leaf with the right sum of values.\\n\\nIf the current node is not a leaf, the function calls itself recursively for the left and right subtree, passing targetSum minus the value of the current node as an argument. The function then returns the result of the logical AND of the recursive calls, since both subtrees must have a path from the root to the leaf with the desired sum in order for the whole tree to have that path.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        targetSum -= root.val;\\n\\n        if (root.left == null && root.right == null) {\\n            return targetSum == 0;\\n        }\\n\\n        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C#",
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        targetSum -= root.val;\\n\\n        if (root.left == null && root.right == null) {\\n            return targetSum == 0;\\n        }\\n\\n        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212802,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == targetSum && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == targetSum && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658457,
                "title": "1-line-python",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856379,
                "title": "simple-js-solution-w-comments",
                "content": "```\\nconst hasPathSum = (root, targetSum) => {\\n\\tif (!root) return false;\\n\\n\\tlet output = false;\\n\\tconst traverse = (root, sum = 0) => {\\n\\t\\t// if targetSum exist at end of path, set output to TRUE\\n\\t\\tif (!root.left && !root.right) {\\n\\t\\t\\tif (targetSum === sum + root.val) output = true;\\n\\t\\t}\\n\\n\\t\\t// traverse left/right and keep adding value of nodes in current path\\n\\t\\tif (root.left) traverse(root.left, sum + root.val);\\n\\t\\tif (root.right) traverse(root.right, sum + root.val);\\n\\t};\\n\\n\\ttraverse(root);\\n\\treturn output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst hasPathSum = (root, targetSum) => {\\n\\tif (!root) return false;\\n\\n\\tlet output = false;\\n\\tconst traverse = (root, sum = 0) => {\\n\\t\\t// if targetSum exist at end of path, set output to TRUE\\n\\t\\tif (!root.left && !root.right) {\\n\\t\\t\\tif (targetSum === sum + root.val) output = true;\\n\\t\\t}\\n\\n\\t\\t// traverse left/right and keep adding value of nodes in current path\\n\\t\\tif (root.left) traverse(root.left, sum + root.val);\\n\\t\\tif (root.right) traverse(root.right, sum + root.val);\\n\\t};\\n\\n\\ttraverse(root);\\n\\treturn output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36391,
                "title": "java-iterative-solution-with-one-stack",
                "content": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        Stack<TreeNode> visitedNodes = new Stack<>();\\n        TreeNode prev = null;\\n       \\n        while(root!=null || !visitedNodes.isEmpty()){\\n            while(root!=null){\\n                visitedNodes.push(root);\\n                sum -= root.val;\\n                prev = root;\\n                root = root.left;\\n            }\\n            root = visitedNodes.peek();\\n            if(root.left==null && root.right == null && sum==0) return true;\\n            if(root.right != null && root.right != prev){\\n                root = root.right;\\n            }else{\\n                sum += root.val;\\n                prev = visitedNodes.pop();\\n                root = null;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        Stack<TreeNode> visitedNodes = new Stack<>();\\n        TreeNode prev = null;\\n       \\n        while(root!=null || !visitedNodes.isEmpty()){\\n            while(root!=null){\\n                visitedNodes.push(root);\\n                sum -= root.val;\\n                prev = root;\\n                root = root.left;\\n            }\\n            root = visitedNodes.peek();\\n            if(root.left==null && root.right == null && sum==0) return true;\\n            if(root.right != null && root.right != prev){\\n                root = root.right;\\n            }else{\\n                sum += root.val;\\n                prev = visitedNodes.pop();\\n                root = null;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36543,
                "title": "share-my-easy-and-clean-recursion-java-solution-with-explanation",
                "content": "    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            \\n            // check if root is null\\n            if(root == null) return false;\\n            \\n            // if the current node is not a leaf node, do recursion.\\n            if(root.left != null || root.right != null) \\n                return hasPathSum(root.left, sum - root.val) || \\n                    hasPathSum(root.right, sum - root.val);\\n            \\n            // now the current node is a leaf node\\n            return sum - root.val == 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            \\n            // check if root is null\\n            if(root == null) return false;\\n            \\n            // if the current node is not a leaf node, do recursion.\\n            if(root.left != null || root.right != null) \\n                return hasPathSum(root.left, sum - root.val) || \\n                    hasPathSum(root.right, sum - root.val);\\n            \\n            // now the current node is a leaf node\\n            return sum - root.val == 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36620,
                "title": "java-solution-shortest",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        if (sum - root.val == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n\\n        if (sum - root.val == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3336702,
                "title": "python3-deque-beat-98-10-34ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, root.val)])\\n        while queue:\\n            node, val = queue.popleft()\\n            if not node.left and not node.right:\\n                if val == targetSum: return True\\n                else: continue\\n            if node.left:\\n                queue.append((node.left, val + node.left.val))   \\n            if node.right:\\n                queue.append((node.right, val + node.right.val))   \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, root.val)])\\n        while queue:\\n            node, val = queue.popleft()\\n            if not node.left and not node.right:\\n                if val == targetSum: return True\\n                else: continue\\n            if node.left:\\n                queue.append((node.left, val + node.left.val))   \\n            if node.right:\\n                queue.append((node.right, val + node.right.val))   \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902210,
                "title": "javascript-easy-code-thumbs-up-if-you-like",
                "content": "\\n# Code\\n```\\n\\nvar hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar hasPathSum = function (root, targetSum) {\\n    if (!root)\\n        return false\\n    if (root.val === targetSum && (!root.left && !root.right))\\n        return true\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291836,
                "title": "three-solution-to-come-up-on-iterview-easy-to-understand",
                "content": "Hey there! This problem gives us to practice in use of different binary tree traversals. If you look closer to the idea of the problem you will come up with the following: DFS (**preorder**) with recursion, DFS iterative version and BFS (or level traversal). Go ahead and get to know all of them.\\n\\n___\\n***DFS recursion*** [0ms 44.2MB](https://leetcode.com/submissions/detail/748771650/)\\nThe simplies (it\\'s seems to me) solution based on **preorder** binary tree traversal. Here we will visit all paths to leaf (node with no children) till we find desired path or visit all:\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return hasPathSum(root, targetSum, 0);\\n    }\\n    \\n    private boolean hasPathSum(TreeNode root, int targetSum, int currSum) {\\n        if (root == null)\\n            return false;\\n        currSum += root.val;\\n        if (currSum == targetSum && root.left == null && root.right == null)\\n            return true;\\n        if (hasPathSum(root.left, targetSum, currSum) || hasPathSum(root.right, targetSum, currSum))\\n            return true;\\n        return false;\\n    }\\n```\\nTime complexity: O(2^n) - where 2^n is a size of a binary tree\\nSpace complexity: O(n), where n is a depth of this tree\\n\\nSimple, readable and neet. But recursion is sign to find iterative method.\\n___\\n***DFS iterative*** [4ms 44MB](https://leetcode.com/submissions/detail/748798973/)\\nThis is an alternative to the previous method because we want to avoid recursion as much as possible. Here we use the same principles (e.g. Stack) as in dfs traversal of binary tree. Note here we have two stacks - one will indicate root - to - this - node sum. If you know how to make it one stack in Java - please let me know ;]\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Stack<Integer> sum = new Stack<>();\\n        stack.push(root);\\n        sum.push(root.val);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            int currSum = sum.pop();\\n            if (currSum == targetSum && node.left == null && node.right == null)\\n                return true;\\n            \\n            if (node.right != null) {\\n                stack.push(node.right);\\n                sum.push(node.right.val + currSum);\\n            }\\n            if (node.left != null) {\\n                stack.push(node.left);\\n                sum.push(node.left.val + currSum);\\n            }\\n        }\\n        return false;\\n    }\\n```\\nTime and Space complexity are identical to the first approach.- But it\\'s generally better the previous because recursion may cause stackoverflow\\n\\n____\\n***BFS*** [2ms 44.6MB](https://leetcode.com/submissions/detail/748810508/)\\nThe last approach is so called level traversal - that is, we initially visit one level of the tree, then one that below and so on. We use the standart approach for BFS with queue. Note the same issue with the second queue for sum.\\nIt is so much a like previous in implemention, but the data structure dictates an order - stack makes traversal go in depth, when queue makes us check this level first.\\n\\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> sum = new LinkedList<>();\\n        queue.add(root);\\n        sum.add(root.val);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.remove();\\n                int currSum = sum.remove();\\n                if (currSum == targetSum && node.left == null && node.right == null) {\\n                    return true;\\n                }\\n                \\n                \\n               if (node.left != null) {\\n                    queue.add(node.left);\\n                    sum.add(node.left.val + currSum);\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                    sum.add(node.right.val + currSum);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```\\nAgain, time and space complexity stay the same.\\n___\\nIn conclusion, benchmarks shows recursive is the best.and BFS is best among iterative version. Still you need to look in the root of the problem and choose the most preferable ( but here I belive it doesn\\'t matter much )\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return hasPathSum(root, targetSum, 0);\\n    }\\n    \\n    private boolean hasPathSum(TreeNode root, int targetSum, int currSum) {\\n        if (root == null)\\n            return false;\\n        currSum += root.val;\\n        if (currSum == targetSum && root.left == null && root.right == null)\\n            return true;\\n        if (hasPathSum(root.left, targetSum, currSum) || hasPathSum(root.right, targetSum, currSum))\\n            return true;\\n        return false;\\n    }\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Stack<Integer> sum = new Stack<>();\\n        stack.push(root);\\n        sum.push(root.val);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            int currSum = sum.pop();\\n            if (currSum == targetSum && node.left == null && node.right == null)\\n                return true;\\n            \\n            if (node.right != null) {\\n                stack.push(node.right);\\n                sum.push(node.right.val + currSum);\\n            }\\n            if (node.left != null) {\\n                stack.push(node.left);\\n                sum.push(node.left.val + currSum);\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<Integer> sum = new LinkedList<>();\\n        queue.add(root);\\n        sum.add(root.val);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.remove();\\n                int currSum = sum.remove();\\n                if (currSum == targetSum && node.left == null && node.right == null) {\\n                    return true;\\n                }\\n                \\n                \\n               if (node.left != null) {\\n                    queue.add(node.left);\\n                    sum.add(node.left.val + currSum);\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                    sum.add(node.right.val + currSum);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690667,
                "title": "c-100-time-one-line-recursive-solution",
                "content": "The base case is when the `root->val == sum` and the node is a leaf (ie: both `!root-left` and `!root->right` are true); if not, we keep recursing with decreased values of `sum`:\\n\\nNotice that since the nodes can also have negative values, there is no way to know in advance when you have summed \"too much\" and thus you should stop exploring down.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && (!root->left && !root->right && root->val == sum || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && (!root->left && !root->right && root->val == sum || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523142,
                "title": "javascript",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    if(!root) {\\n        return false;\\n    }\\n    if(!root.left && !root.right) {\\n        return root.val == sum ? true : false;\\n    }\\n    let remain = sum - root.val\\n    return hasPathSum(root.left, remain) || hasPathSum(root.right, remain)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    if(!root) {\\n        return false;\\n    }\\n    if(!root.left && !root.right) {\\n        return root.val == sum ? true : false;\\n    }\\n    let remain = sum - root.val\\n    return hasPathSum(root.left, remain) || hasPathSum(root.right, remain)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519347,
                "title": "go-4ms",
                "content": "```\\nfunc hasPathSum(root *TreeNode, sum int) bool {\\n    if root == nil {\\n        return false\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        return sum == root.Val\\n    }\\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc hasPathSum(root *TreeNode, sum int) bool {\\n    if root == nil {\\n        return false\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        return sum == root.Val\\n    }\\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410446,
                "title": "simple-python-solution-recursive-and-iterative-using-dfs",
                "content": "**Recursive**\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        sum = sum - root.val\\n        \\n        if not root.left and not root.right: #leaf node\\n            return sum == 0\\n        else:\\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```\\n\\t\\t\\t\\n**Iterative**\\n\\n```      \\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        \\n        if not root:\\n            return False\\n        \\n        stack = []\\n        \\n        stack.append((root, sum - root.val))\\n        \\n        while stack:\\n            node, sum = stack.pop()\\n            if not node.left and not node.right and sum == 0:\\n                return True\\n            if node.left:\\n                stack.append((node.left, sum - node.left.val))\\n            if node.right:\\n                stack.append((node.right, sum - node.right.val))       \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        \\n        sum = sum - root.val\\n        \\n        if not root.left and not root.right: #leaf node\\n            return sum == 0\\n        else:\\n            return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```\n```      \\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        \\n        if not root:\\n            return False\\n        \\n        stack = []\\n        \\n        stack.append((root, sum - root.val))\\n        \\n        while stack:\\n            node, sum = stack.pop()\\n            if not node.left and not node.right and sum == 0:\\n                return True\\n            if node.left:\\n                stack.append((node.left, sum - node.left.val))\\n            if node.right:\\n                stack.append((node.right, sum - node.right.val))       \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388724,
                "title": "javascript-easy-top-bottom-approach",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    if (!root) return false;\\n    let queue = [root];\\n    while (queue.length > 0) {\\n        let cur = queue.shift();\\n        if (!cur.left && !cur.right && cur.val == sum) {\\n            return true;\\n        }\\n        if (cur.left) {\\n            cur.left.val += cur.val;\\n            queue.push (cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.val += cur.val;\\n            queue.push (cur.right);\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction TreeNode (val) {\\n    this.val = val;\\n    this.left = this.right = null;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    if (!root) return false;\\n    let queue = [root];\\n    while (queue.length > 0) {\\n        let cur = queue.shift();\\n        if (!cur.left && !cur.right && cur.val == sum) {\\n            return true;\\n        }\\n        if (cur.left) {\\n            cur.left.val += cur.val;\\n            queue.push (cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.val += cur.val;\\n            queue.push (cur.right);\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction TreeNode (val) {\\n    this.val = val;\\n    this.left = this.right = null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36484,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL){\\n                return false;\\n            }\\n            int newsum = sum - root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                return newsum == 0;\\n            }\\n            return hasPathSum(root->left, newsum) || hasPathSum(root->right, newsum);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 36536,
                "title": "my-java-solution-using-recursive",
                "content": "    \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        } else {\\n            if (root.left == null && root.right == null) {\\n                return sum == root.val;\\n            } else {\\n                int subSum = sum - root.val;\\n                return hasPathSum(root.left, subSum) || hasPathSum(root.right, subSum);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    \\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        } else {\\n            if (root.left == null && root.right == null) {\\n                return sum == root.val;\\n            } else {\\n                int subSum = sum - root.val;\\n                return hasPathSum(root.left, subSum) || hasPathSum(root.right, subSum);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36567,
                "title": "12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            sum -= root->val;\\n            return sum == 0 && root->left == NULL && root->right == NULL ? true : hasPathSum(root->left, sum) | hasPathSum(root->right, sum);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            sum -= root->val;\\n            return sum == 0 && root->left == NULL && root->right == NULL ? true : hasPathSum(root->left, sum) | hasPathSum(root->right, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36642,
                "title": "just-another-java-solution-recursive-simple-but-can-be-simpler",
                "content": "    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            //start it off with initial sum of 0, pass in root.\\n            return helper(root,0,sum);\\n        }\\n        \\n      public boolean helper(TreeNode node,int currSum,int wanted){\\n          if(node==null)\\n            return false;\\n            \\n          //node is a leaf\\n          if(node.left==null && node.right==null){\\n              if((node.val+currSum) == wanted) //check if it sumeed up.\\n                  return true;\\n              return false;\\n          }\\n          \\n          //not a leaf, so recursively try again but with child nodes, pass in current sum + val of this node.\\n          return (helper(node.left,currSum+node.val,wanted) || helper(node.right,currSum+node.val,wanted));\\n          \\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            //start it off with initial sum of 0, pass in root.\\n            return helper(root,0,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2231004,
                "title": "python-dfs-binary-tree-leaves-find-all-paths",
                "content": "It is intuitive to find all the possible paths from roots to leaves and sum them and check with the target sum.\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        res = []\\n        if not root:\\n            return False\\n        def dfs(r,path):\\n            if not r.left and not r.right:\\n                path+=[r.val]\\n                res.append(path)\\n                return\\n            if r.left:\\n                dfs(r.left,path+[r.val])\\n            if r.right:\\n                dfs(r.right,path+[r.val])\\n            return \\n        dfs(root,[])\\n        # print(res)\\n        for arr in res:\\n            if sum(arr)==targetSum:\\n                return True\\n        return False\\n```\\n```\\nUPVOTE IF YOU LIKED IT :)\\n```\\nDo Let me know how we can optimise this further.\\nOne way i know that instead of keeping path, we can keep the sum itself and then return true if found targetSum.\\nBut for me it does not change time complexity much. \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        res = []\\n        if not root:\\n            return False\\n        def dfs(r,path):\\n            if not r.left and not r.right:\\n                path+=[r.val]\\n                res.append(path)\\n                return\\n            if r.left:\\n                dfs(r.left,path+[r.val])\\n            if r.right:\\n                dfs(r.right,path+[r.val])\\n            return \\n        dfs(root,[])\\n        # print(res)\\n        for arr in res:\\n            if sum(arr)==targetSum:\\n                return True\\n        return False\\n```\n```\\nUPVOTE IF YOU LIKED IT :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040038,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n    // iteration method\\n    if (root == null) {return false;}\\n    Stack<TreeNode> path = new Stack<>();\\n    Stack<Integer> sub = new Stack<>();\\n    path.push(root);\\n    sub.push(root.val);\\n    while (!path.isEmpty()) {\\n        TreeNode temp = path.pop();\\n        int tempVal = sub.pop();\\n        if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n        else {\\n            if (temp.left != null) {\\n                path.push(temp.left);\\n                sub.push(temp.left.val + tempVal);\\n            }\\n            if (temp.right != null) {\\n                path.push(temp.right);\\n                sub.push(temp.right.val + tempVal);\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\\n        if (root==null){\\n            return false\\n        }\\n        else if (root.left==null && root.right==null && root!!.`val`==sum){\\n            return true\\n        }\\n        return hasPathSum(root.left, sum-root!!.`val`) || hasPathSum(root.right, sum-root!!.`val`)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == targetSum\\n        }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n    // iteration method\\n    if (root == null) {return false;}\\n    Stack<TreeNode> path = new Stack<>();\\n    Stack<Integer> sub = new Stack<>();\\n    path.push(root);\\n    sub.push(root.val);\\n    while (!path.isEmpty()) {\\n        TreeNode temp = path.pop();\\n        int tempVal = sub.pop();\\n        if (temp.left == null && temp.right == null) {if (tempVal == sum) return true;}\\n        else {\\n            if (temp.left != null) {\\n                path.push(temp.left);\\n                sub.push(temp.left.val + tempVal);\\n            }\\n            if (temp.right != null) {\\n                path.push(temp.right);\\n                sub.push(temp.right.val + tempVal);\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(!root)return false;                                         //Terminating Condition\\n        sum=sum-root->val;                                             //Body\\n        if(sum==0&&!root->left&&!root->right)return true;              //body\\n        return hasPathSum(root->left,sum)||hasPathSum(root->right,sum);//Propagation\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\n```\\n```\n```\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    return dfs(root, targetSum);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst dfs = (root, target) => {\\n    if (!root) {\\n        return false;\\n    }\\n    if (!root.left && !root.right) {\\n        return target - root.val === 0;\\n    }\\n    return dfs(root.left, target - root.val) || \\n        dfs(root.right, target - root.val);\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\\n        if (root==null){\\n            return false\\n        }\\n        else if (root.left==null && root.right==null && root!!.`val`==sum){\\n            return true\\n        }\\n        return hasPathSum(root.left, sum-root!!.`val`) || hasPathSum(root.right, sum-root!!.`val`)\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == targetSum\\n        }\\n        \\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val)\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567369,
                "title": "javascript-easy-to-understand-dfs",
                "content": "Since we need to sum the values from root to leaf, it\\'s straightforward to think about DFS. So, the process could be:\\n1. Traverse the tree via DFS\\n2. Check whether current node is leaf\\n\\t- check the target value\\n\\t- continue recursion\\n\\nHere\\'s the code:\\n\\n```js\\nconst hasPathSum = (node, target) => {\\n  if (!node) return false;\\n  if (!node.left && !node.right) return target === node.val;\\n  return (\\n    hasPathSum(node.left, target - node.val) ||\\n    hasPathSum(node.right, target - node.val)\\n  );\\n};\\n```\\n\\nEven, we could make it in 1-line:\\n\\n```js\\nconst hasPathSum = (node, target) => !!node && (!node.left && !node.right ? target === node.val : hasPathSum(node.left, target - node.val) || hasPathSum(node.right, target - node.val));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst hasPathSum = (node, target) => {\\n  if (!node) return false;\\n  if (!node.left && !node.right) return target === node.val;\\n  return (\\n    hasPathSum(node.left, target - node.val) ||\\n    hasPathSum(node.right, target - node.val)\\n  );\\n};\\n```\n```js\\nconst hasPathSum = (node, target) => !!node && (!node.left && !node.right ? target === node.val : hasPathSum(node.left, target - node.val) || hasPathSum(node.right, target - node.val));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517970,
                "title": "two-approaches-dfs-very-simple-c",
                "content": "\\nImplementation\\n\\n**1st Approach using helper(findPath) method\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, int targetSum, int sum){\\n        if(root == NULL) return false;\\n        sum += root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (sum == targetSum) ? true : false;\\n        }\\n        return (findPath(root->left, targetSum, sum) || findPath(root->right, targetSum, sum));        \\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        return findPath(root, targetSum, 0);\\n    }\\n};\\n```\\n\\n**2nd Approach without using any helper method\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        if(root == NULL) return false;\\n        targetSum -= root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (targetSum == 0) ? true : false;\\n        }\\n        return (hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum));        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, int targetSum, int sum){\\n        if(root == NULL) return false;\\n        sum += root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (sum == targetSum) ? true : false;\\n        }\\n        return (findPath(root->left, targetSum, sum) || findPath(root->right, targetSum, sum));        \\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        return findPath(root, targetSum, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {        \\n        if(root == NULL) return false;\\n        targetSum -= root->val;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            return (targetSum == 0) ? true : false;\\n        }\\n        return (hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746228,
                "title": "java-dfs-runtime-0-ms-faster-than-100-00-memory-usage-39-2-mb-less-than-73-39",
                "content": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n// Memory Usage: 39.2 MB, less than 73.39% of Java online submissions for Path Sum.\\nclass Solution {\\n    private boolean answer = false;\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null) return false;\\n        dfs(root,sum,0);\\n        return answer;    \\n    }\\n    \\n    private void dfs(TreeNode node, int sum, int currentSum){\\n        if(answer==true) return;\\n        \\n        if(node.left==null && node.right==null){\\n            currentSum+=node.val;\\n            if(sum==currentSum) answer = true;\\n            return;\\n        }\\n        \\n        currentSum+=node.val;\\n        if(node.left!=null) dfs(node.left, sum, currentSum);\\n        if(node.right!=null) dfs(node.right,sum,currentSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Path Sum.\\n// Memory Usage: 39.2 MB, less than 73.39% of Java online submissions for Path Sum.\\nclass Solution {\\n    private boolean answer = false;\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null) return false;\\n        dfs(root,sum,0);\\n        return answer;    \\n    }\\n    \\n    private void dfs(TreeNode node, int sum, int currentSum){\\n        if(answer==true) return;\\n        \\n        if(node.left==null && node.right==null){\\n            currentSum+=node.val;\\n            if(sum==currentSum) answer = true;\\n            return;\\n        }\\n        \\n        currentSum+=node.val;\\n        if(node.left!=null) dfs(node.left, sum, currentSum);\\n        if(node.right!=null) dfs(node.right,sum,currentSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517434,
                "title": "java-0ms-recursive",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return false;\\n        else\\n            return (root.left == null && root.right == null && root.val == sum)\\n            || hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return false;\\n        else\\n            return (root.left == null && root.right == null && root.val == sum)\\n            || hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36618,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if (root == null)\\n                return false;\\n            if (root.left == null && root.right == null)\\n                return sum == root.val;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n        }   \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean hasPathSum(TreeNode root, int sum) {\\n            if (root == null)\\n                return false;\\n            if (root.left == null && root.right == null)\\n                return sum == root.val;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36640,
                "title": "my-solution-in-c",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            if(!root) return false;\\n            if(!root->left && !root->right)\\n                return root->val == sum;\\n            return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode *root, int sum) {\\n            if(!root) return false;\\n            if(!root->left && !root->right)\\n                return root->val == sum;\\n            return hasPathSum(root->left,sum-root->val) || hasPathSum(root->right,sum-root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3526144,
                "title": "c-easy-in-3-lines",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        if (root->val == targetSum && !root->left && !root->right) return true;\\n        return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root) return false;\\n        if (root->val == targetSum && !root->left && !root->right) return true;\\n        return hasPathSum(root->right, targetSum - root->val) || hasPathSum(root->left, targetSum - root->val);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418430,
                "title": "easiest-java-solution-beats-100-recursive",
                "content": "# Intuition\\nIteration of Tree and summing up the path till leaf.\\nsearcing the leaf node is equal to target or not.\\n\\n# Approach\\njust like node to leaf sum problem , sum up all path till leaf\\nex- \\n```\\ntree = 1            and target is 11\\n      / \\\\\\n    2     3\\n   /     / \\\\\\n  5     4   7\\n```\\n\\nso after path() function tree will be like\\n```\\n       1\\n      / \\\\\\n    3     4\\n   /     / \\\\\\n  8     8   11  \\n\\n```\\n* now search through the leaf to check is there any targetSum present or not if any return true else false  \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum){\\n        path(root);\\n        return has(root,targetSum);\\n    }\\n    public boolean has(TreeNode root, int targetSum) {\\n        if(root==null)\\n        return false;\\n\\n        if(root.left==null && root.right==null){\\n            if(root.val==targetSum)\\n            return true;\\n        }\\n\\n        return has(root.left,targetSum) || has(root.right,targetSum);\\n    }\\n\\n    public static void path(TreeNode root){\\n        if(root==null)\\n        return;\\n        int data = root.val;\\n        if(root.left!=null)\\n        root.left.val += data;\\n\\n        if(root.right!=null)\\n        root.right.val += data;\\n\\n        path(root.left);\\n        path(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ntree = 1            and target is 11\\n      / \\\\\\n    2     3\\n   /     / \\\\\\n  5     4   7\\n```\n```\\n       1\\n      / \\\\\\n    3     4\\n   /     / \\\\\\n  8     8   11  \\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum){\\n        path(root);\\n        return has(root,targetSum);\\n    }\\n    public boolean has(TreeNode root, int targetSum) {\\n        if(root==null)\\n        return false;\\n\\n        if(root.left==null && root.right==null){\\n            if(root.val==targetSum)\\n            return true;\\n        }\\n\\n        return has(root.left,targetSum) || has(root.right,targetSum);\\n    }\\n\\n    public static void path(TreeNode root){\\n        if(root==null)\\n        return;\\n        int data = root.val;\\n        if(root.left!=null)\\n        root.left.val += data;\\n\\n        if(root.right!=null)\\n        root.right.val += data;\\n\\n        path(root.left);\\n        path(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294258,
                "title": "my-shortest-c-solution",
                "content": "\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root)\\n            return false;\\n        \\n        if (root->val == targetSum and !root->left and !root->right)\\n            return true;\\n        \\n        return hasPathSum(root->left, targetSum - root->val) or hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time Complexity : $$O(n)$$ [worst case : Traverse all `n` nodes]\\n- Space Complexity : $$O(1)$$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if (!root)\\n            return false;\\n        \\n        if (root->val == targetSum and !root->left and !root->right)\\n            return true;\\n        \\n        return hasPathSum(root->left, targetSum - root->val) or hasPathSum(root->right, targetSum - root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058005,
                "title": "javascript-simple-up-vote-if-u-like",
                "content": "# Code\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    if (!root) return false // not a leaf\\n    if (!root.left && !root.right) return root.val === targetSum; // leaf\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasPathSum = function(root, targetSum) {\\n    if (!root) return false // not a leaf\\n    if (!root.left && !root.right) return root.val === targetSum; // leaf\\n\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039724,
                "title": "0ms-java-solution-another-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int target) \\n    {\\n        if(root==null)\\n            return false;\\n        if(root.left==null && root.right==null)\\n            return (target-root.val)==0;\\n     return hasPathSum(root.left,target-root.val) || hasPathSum(root.right,target-root.val);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int target) \\n    {\\n        if(root==null)\\n            return false;\\n        if(root.left==null && root.right==null)\\n            return (target-root.val)==0;\\n     return hasPathSum(root.left,target-root.val) || hasPathSum(root.right,target-root.val);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813240,
                "title": "python-recursive",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def helper(node,tot):\\n            if not node:\\n                return \\n            elif not node.left and not node.right:\\n                if tot+node.val==targetSum:\\n                    return True\\n            else:\\n                return helper(node.left,tot+node.val) or helper(node.right,tot+node.val)\\n        if root:\\n            return helper(root,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def helper(node,tot):\\n            if not node:\\n                return \\n            elif not node.left and not node.right:\\n                if tot+node.val==targetSum:\\n                    return True\\n            else:\\n                return helper(node.left,tot+node.val) or helper(node.right,tot+node.val)\\n        if root:\\n            return helper(root,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660894,
                "title": "c-concise-recursion-clean-inorder-traversal",
                "content": "```\\n  bool inorder(TreeNode* root , int sum , int &targetSum)\\n    {\\n        if(!root) return false;\\n        sum+=root->val;\\n        if(root->left==NULL && root->right==NULL) if(sum==targetSum) return true; \\n        return (inorder(root->left , sum , targetSum) || inorder(root->right , sum , targetSum));\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return inorder(root, 0 , targetSum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  bool inorder(TreeNode* root , int sum , int &targetSum)\\n    {\\n        if(!root) return false;\\n        sum+=root->val;\\n        if(root->left==NULL && root->right==NULL) if(sum==targetSum) return true; \\n        return (inorder(root->left , sum , targetSum) || inorder(root->right , sum , targetSum));\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return inorder(root, 0 , targetSum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231534,
                "title": "java-0ms-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        \\n        //return false when root is null or when we reached leaf node but the sum is not equal to target sum\\n        if(root == null) {\\n            return false;\\n        }\\n        \\n        //if the current node is not null then we subract targetSum by it\\'s value and pass the new targetSum ahead in the function\\n        targetSum = targetSum - root.val;\\n        \\n        //if both sides are null then it means that we have reached leaf node and if at the same time targetSum is also equals to 0 then we can return true because we have found the path\\n        if(root.left == null && root.right == null && 0 == targetSum) {\\n            return true;\\n        }\\n        \\n        //we do a recursive call for both the sides and use \\'or(||)\\' function because even if one side is true then we got the ans(path)\\n        return hasPathSum(root.left,  targetSum) || hasPathSum(root.right, targetSum);\\n    }\\n    \\n}\\n\\n//Time Complexity: O(n) n is the total number of nodes in the binary tree\\n//Space Complexity: O(n) n is the total number of nodes in the binary tree\\n//Please upvote the solution if you like it",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        \\n        //return false when root is null or when we reached leaf node but the sum is not equal to target sum\\n        if(root == null) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1550790,
                "title": "90-faster-c-solution",
                "content": "```\\n bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root){\\n            return false;\\n        }\\n        if(targetSum==root->val && root->left==NULL && root->right==NULL){\\n            return true;\\n        }\\n        return hasPathSum(root->left,targetSum-(root->val)) || hasPathSum(root->right,targetSum-(root->val));\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root){\\n            return false;\\n        }\\n        if(targetSum==root->val && root->left==NULL && root->right==NULL){\\n            return true;\\n        }\\n        return hasPathSum(root->left,targetSum-(root->val)) || hasPathSum(root->right,targetSum-(root->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381668,
                "title": "c-dfs-recursive-dfs-iterative-and-bfs",
                "content": "DFS Recursive:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n    \\n    if(root.left == null && root.right == null)\\n        return root.val == targetSum;\\n    \\n    return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\\n}\\n```\\n\\nDFS Iterative:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n        \\n    var stack = new Stack<TreeNode>();\\n    var rest = new Stack<int>();\\n    \\n    stack.Push(root);\\n    rest.Push(targetSum);\\n    \\n    while(stack.Count() > 0)\\n    {\\n        root = stack.Pop();\\n        targetSum = rest.Pop();\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n            \\n        if(root.left != null)\\n        {\\n            stack.Push(root.left);\\n            rest.Push(targetSum - root.val);\\n        }\\n            \\n        if(root.right != null)\\n        {\\n            stack.Push(root.right);\\n            rest.Push(targetSum - root.val);\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\nBFS:\\n\\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if (root == null)\\n        return false;\\n        \\n    var queue = new Queue<TreeNode>();\\n    var rest = new Queue<int>();\\n    \\n    queue.Enqueue(root);\\n    rest.Enqueue(targetSum);\\n\\n    while (queue.Count() > 0)\\n    {\\n        root = queue.Dequeue();\\n        targetSum = rest.Dequeue();\\n        \\n        if (root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n        \\n        if(root.left != null)\\n        {\\n            queue.Enqueue(root.left);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n        \\n        if(root.right != null)\\n        {\\n            queue.Enqueue(root.right);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n    }\\n\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n    \\n    if(root.left == null && root.right == null)\\n        return root.val == targetSum;\\n    \\n    return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\\n}\\n```\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if(root == null)\\n        return false;\\n        \\n    var stack = new Stack<TreeNode>();\\n    var rest = new Stack<int>();\\n    \\n    stack.Push(root);\\n    rest.Push(targetSum);\\n    \\n    while(stack.Count() > 0)\\n    {\\n        root = stack.Pop();\\n        targetSum = rest.Pop();\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n            \\n        if(root.left != null)\\n        {\\n            stack.Push(root.left);\\n            rest.Push(targetSum - root.val);\\n        }\\n            \\n        if(root.right != null)\\n        {\\n            stack.Push(root.right);\\n            rest.Push(targetSum - root.val);\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\npublic bool HasPathSum(TreeNode root, int targetSum)\\n{\\n    if (root == null)\\n        return false;\\n        \\n    var queue = new Queue<TreeNode>();\\n    var rest = new Queue<int>();\\n    \\n    queue.Enqueue(root);\\n    rest.Enqueue(targetSum);\\n\\n    while (queue.Count() > 0)\\n    {\\n        root = queue.Dequeue();\\n        targetSum = rest.Dequeue();\\n        \\n        if (root.left == null && root.right == null)\\n        {\\n            if(targetSum == root.val)\\n                return true;\\n        }\\n        \\n        if(root.left != null)\\n        {\\n            queue.Enqueue(root.left);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n        \\n        if(root.right != null)\\n        {\\n            queue.Enqueue(root.right);\\n            rest.Enqueue(targetSum - root.val);\\n        }\\n    }\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525239,
                "title": "python-js-go-c-o-n-dfs-w-hint",
                "content": "Python O(n) sol by DFS\\n\\n---\\n**Hint**:\\n\\nThink of **DFS** algorithm framework\\n\\nOne node is the so-called **leaf node**, if and only if,\\nit is **not an empty node** and it **doesn\\'t have** both *left child* and *right child*.\\n\\nImagine the path sum as a process treasure hunt **from root to leaf** with specified target value\\n\\nUpdate *target value* as *previous target* - *current node value*, then go down to next level in DFS.\\n\\n\\n---\\n**Implementation_#1**:\\nDFS with recursion\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ## Base case\\n        if not root:\\n            return False\\n        \\n        ## Base case\\n        if not root.left and not root.right:\\n            \\n            # we have the path with targetSum\\n            return targetSum == root.val\\n        \\n        ## General case:\\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\\\\n                self.hasPathSum(root.right, targetSum - root.val)\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\nvar hasPathSum = function(root, targetSum) {\\n    \\n    // Base case\\n    if( null == root ){\\n        return false;\\n    }\\n    \\n    \\n    if( null == root.left && null == root.right ){\\n        // Base case\\n        return root.val == targetSum;\\n    }else{\\n        \\n        // General cases\\n        return hasPathSum( root.left, targetSum-root.val ) || hasPathSum( root.right, targetSum-root.val );\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\\n    \\n    // Base case\\n    if nil == root{\\n        return false\\n    }\\n    \\n    \\n    if nil == root.Left && nil == root.Right{\\n        // Base case\\n        return root.Val == targetSum\\n        \\n    }else{\\n        // General cases\\n        return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)\\n    }\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nin **C++**\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        if ( NULL == root ){\\n            return false;\\n        }\\n        \\n        if ( NULL == root->left && NULL == root->right){\\n            return root->val == targetSum;\\n        }else{\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n        }\\n    }\\n};\\n```\\n</details>\\n\\n---\\n**Implementation_#2**:\\nDFS with stack\\n\\n```\\nclass Solution:\\n    \\n    def hasPathSum(self, root, sum):\\n        \\n        traversal_stack = [(root, sum)]\\n        \\n        # DFS with stack\\n        while traversal_stack:\\n            \\n            node, value = traversal_stack.pop()\\n            \\n            if node:\\n                if not node.left and not node.right and node.val == value:\\n                    # leaf node\\n                    return True\\n                \\n                else:\\n                    # non-leaf node\\n                    traversal_stack.append((node.right, value-node.val))\\n                    traversal_stack.append((node.left, value-node.val))\\n\\n            else:\\n                # empty node\\n                continue\\n                \\n        return False\\n```\\n\\n---\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #113 Path Sum II](https://leetcode.com/problems/path-sum-ii/)\\n\\n[2] [Leetcode #437 Path Sum III](https://leetcode.com/problems/path-sum-iii/)\\n\\n[3] [Leetcode #129 Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ## Base case\\n        if not root:\\n            return False\\n        \\n        ## Base case\\n        if not root.left and not root.right:\\n            \\n            # we have the path with targetSum\\n            return targetSum == root.val\\n        \\n        ## General case:\\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\\\\n                self.hasPathSum(root.right, targetSum - root.val)\\n```\n```\\nvar hasPathSum = function(root, targetSum) {\\n    \\n    // Base case\\n    if( null == root ){\\n        return false;\\n    }\\n    \\n    \\n    if( null == root.left && null == root.right ){\\n        // Base case\\n        return root.val == targetSum;\\n    }else{\\n        \\n        // General cases\\n        return hasPathSum( root.left, targetSum-root.val ) || hasPathSum( root.right, targetSum-root.val );\\n    }\\n};\\n```\n```\\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\\n    \\n    // Base case\\n    if nil == root{\\n        return false\\n    }\\n    \\n    \\n    if nil == root.Left && nil == root.Right{\\n        // Base case\\n        return root.Val == targetSum\\n        \\n    }else{\\n        // General cases\\n        return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        if ( NULL == root ){\\n            return false;\\n        }\\n        \\n        if ( NULL == root->left && NULL == root->right){\\n            return root->val == targetSum;\\n        }else{\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    \\n    def hasPathSum(self, root, sum):\\n        \\n        traversal_stack = [(root, sum)]\\n        \\n        # DFS with stack\\n        while traversal_stack:\\n            \\n            node, value = traversal_stack.pop()\\n            \\n            if node:\\n                if not node.left and not node.right and node.val == value:\\n                    # leaf node\\n                    return True\\n                \\n                else:\\n                    # non-leaf node\\n                    traversal_stack.append((node.right, value-node.val))\\n                    traversal_stack.append((node.left, value-node.val))\\n\\n            else:\\n                # empty node\\n                continue\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328124,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 111106,
                "title": "javascript-clean-solution",
                "content": "```\\nvar hasPathSum = function(root, sum) {\\n    let res = false;\\n    function helper(node, cur){\\n        if(!node) return;\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum){\\n                res = true;\\n                return;\\n            }\\n        }\\n        else{\\n            helper(node.left, cur);\\n            helper(node.right, cur);\\n        }\\n    }\\n    helper(root, 0);\\n    return res;\\n};",
                "solutionTags": [],
                "code": "```\\nvar hasPathSum = function(root, sum) {\\n    let res = false;\\n    function helper(node, cur){\\n        if(!node) return;\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum){\\n                res = true;\\n                return;\\n            }\\n        }\\n        else{\\n            helper(node.left, cur);\\n            helper(node.right, cur);\\n        }\\n    }\\n    helper(root, 0);\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 36387,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36389,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.left == null && root.right == null)\\n            return sum == root.val;\\n        \\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.left == null && root.right == null)\\n            return sum == root.val;\\n        \\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36513,
                "title": "accepted-java-iteration-solution-with-one-stack-without-change-the-value-of-treenode",
                "content": "Enjoy my first post ^ ^\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n\\t\\tStack<TreeNode> stack = new Stack<>();\\n\\t\\twhile (!stack.isEmpty() || root != null) {\\n\\t\\t\\twhile (root != null) {\\n\\t\\t\\t\\tstack.push(root);\\n\\t\\t\\t\\tsum -= root.val;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (sum == 0 && stack.peek().right == null && stack.peek().left == null) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\t//root == null\\n\\t\\t\\t//pop all nodes whose children pathes have been both checked.\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek().right == root) {\\n\\t\\t\\t    root = stack.pop();\\n\\t\\t\\t    sum += root.val;\\n\\t\\t\\t}\\n\\t\\t\\troot = stack.isEmpty() ? null : stack.peek().right;\\n\\t\\t\\t//root is now the first node in in-order which has never been pushed in the stack.\\n\\t\\t}\\n\\t\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Enjoy my first post ^ ^\\n\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n\\t\\tStack<TreeNode> stack = new Stack<>();\\n\\t\\twhile (!stack.isEmpty() || root != null) {\\n\\t\\t\\twhile (root != null) {\\n\\t\\t\\t\\tstack.push(root);\\n\\t\\t\\t\\tsum -= root.val;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (sum == 0 && stack.peek().right == null && stack.peek().left == null) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\t//root == null\\n\\t\\t\\t//pop all nodes whose children pathes have been both checked.\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek().right == root) {\\n\\t\\t\\t    root = stack.pop();\\n\\t\\t\\t    sum += root.val;\\n\\t\\t\\t}\\n\\t\\t\\troot = stack.isEmpty() ? null : stack.peek().right;\\n\\t\\t\\t//root is now the first node in in-order which has never been pushed in the stack.\\n\\t\\t}\\n\\t\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36523,
                "title": "clean-1-ms-recursive-java-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        \\n        if((root==null))\\n        {\\n            return false;\\n        }\\n        sum=sum-root.val;\\n        if(sum==0)\\n        {\\n            if((root.left==null)&&(root.right==null))\\n            {\\n                return true;\\n            }\\n        }\\n\\n       if(hasPathSum(root.left,sum)||hasPathSum(root.right,sum))\\n       {\\n           return true;\\n       }\\n\\n        \\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n        \\n        if((root==null))\\n        {\\n            return false;\\n        }\\n        sum=sum-root.val;\\n        if(sum==0)\\n        {\\n            if((root.left==null)&&(root.right==null))\\n            {\\n                return true;\\n            }\\n        }\\n\\n       if(hasPathSum(root.left,sum)||hasPathSum(root.right,sum))\\n       {\\n           return true;\\n       }\\n\\n        \\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36568,
                "title": "a-c-recursive-version",
                "content": "    public bool HasPathSum(TreeNode root, int sum) {\\n        return root == null ? false :\\n               root.val == sum && root.left == null && root.right == null\\n            || HasPathSum(root.left, sum - root.val)\\n            || HasPathSum(root.right, sum - root.val);\\n    }",
                "solutionTags": [],
                "code": "    public bool HasPathSum(TreeNode root, int sum) {\\n        return root == null ? false :\\n               root.val == sum && root.left == null && root.right == null\\n            || HasPathSum(root.left, sum - root.val)\\n            || HasPathSum(root.right, sum - root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3009126,
                "title": "1ms-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && root.val==targetSum){\\n            return true;\\n        }\\n        if(hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && root.val==targetSum){\\n            return true;\\n        }\\n        if(hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660876,
                "title": "java-dfs-and-bfs",
                "content": "# Intuition\\nTraverse the tree and sum up the values you get along the path to a leaf node.\\nWhenever you arrive at a leaf node, check whether it is equal to the `targetSum`\\n\\n# DFS\\n```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return searchPathSum(root, 0, targetSum);\\n    }\\n    \\n    public boolean searchPathSum(TreeNode root, int currentSum, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        currentSum += root.val;\\n        if (root.left == null && root.right == null) {\\n            return currentSum == targetSum;\\n        }\\n        \\n        return searchPathSum(root.left, currentSum, targetSum) || searchPathSum(root.right, currentSum, targetSum);\\n    }\\n}\\n```\\n\\n# BFS\\n```\\nclass TreeElement {\\n    public TreeNode node;\\n    private int sum;\\n    \\n    TreeElement(TreeNode node, int sum) {\\n        this.node = node;\\n        this.sum = sum;\\n    }\\n    \\n    public boolean isLeaf() {\\n        return node != null && node.left == null && node.right == null;\\n    }\\n    \\n    public int getSum() {\\n        return sum;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        \\n        Queue<TreeElement> queue = new LinkedList<TreeElement>();\\n        queue.add(new TreeElement(root, 0));\\n        \\n        while(queue.size() != 0) {\\n            TreeElement currentElement = queue.poll();\\n            if(currentElement.node == null) continue;\\n            \\n            int newSum = currentElement.getSum() + currentElement.node.val;\\n            if(currentElement.isLeaf() && newSum == targetSum) {\\n                return true;\\n            }\\n            \\n            if(currentElement.node.right != null) {\\n                queue.add(new TreeElement(currentElement.node.right, newSum));\\n            }\\n            if(currentElement.node.left != null) {\\n                queue.add(new TreeElement(currentElement.node.left, newSum));\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        return searchPathSum(root, 0, targetSum);\\n    }\\n    \\n    public boolean searchPathSum(TreeNode root, int currentSum, int targetSum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        currentSum += root.val;\\n        if (root.left == null && root.right == null) {\\n            return currentSum == targetSum;\\n        }\\n        \\n        return searchPathSum(root.left, currentSum, targetSum) || searchPathSum(root.right, currentSum, targetSum);\\n    }\\n}\\n```\n```\\nclass TreeElement {\\n    public TreeNode node;\\n    private int sum;\\n    \\n    TreeElement(TreeNode node, int sum) {\\n        this.node = node;\\n        this.sum = sum;\\n    }\\n    \\n    public boolean isLeaf() {\\n        return node != null && node.left == null && node.right == null;\\n    }\\n    \\n    public int getSum() {\\n        return sum;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        \\n        Queue<TreeElement> queue = new LinkedList<TreeElement>();\\n        queue.add(new TreeElement(root, 0));\\n        \\n        while(queue.size() != 0) {\\n            TreeElement currentElement = queue.poll();\\n            if(currentElement.node == null) continue;\\n            \\n            int newSum = currentElement.getSum() + currentElement.node.val;\\n            if(currentElement.isLeaf() && newSum == targetSum) {\\n                return true;\\n            }\\n            \\n            if(currentElement.node.right != null) {\\n                queue.add(new TreeElement(currentElement.node.right, newSum));\\n            }\\n            if(currentElement.node.left != null) {\\n                queue.add(new TreeElement(currentElement.node.left, newSum));\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658790,
                "title": "c-recursion-with-explanation-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool root_to_leaf(TreeNode* root, int Sum){\\n        \\n        // root reaches NULL that means we didn\\'t find any path root-to-leaf that add up to sum because if there is any we return from line number \\'24\\'\\n        if(root==NULL)return false;\\n        \\n        // because we reach some root value so remaining target sum is sum-root_value\\n        Sum=Sum-root->val;\\n        \\n        // base case when we reach leaf node && Sum becomes \\'0\\' specify that we find a path THEREFORE return true\\n        if(root->left==NULL and root->right==NULL and Sum==0)return true;\\n        \\n        // recursive call to LEFT subtree of root && RIGHT subtree of root using or because \\n        // if any one of them return true we found a path so return true  && if both of them return false we didn\\'t found any path so return false\\n        // true or true => true || true or false => true || false or true => true || false or false => false \\n        return root_to_leaf(root->left,Sum) or root_to_leaf(root->right,Sum);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        // EDGE case when tree is empty because there are no root-to-leaf paths THRERFORE return false\\n        if(root==NULL)return false;\\n        \\n        // function call to check if there exist a path root-to-leaf such that adding up values along the path == targetSum\\n        return root_to_leaf(root,targetSum);\\n    }\\n};\\n```\\n\\n```\\nTIME COMPLEXITY \\nO(N) as we have to visit every node until we find a root-to-leaf path of sum = target sum \\n\\nSPACE COMPLEXITY \\nO(LOGN) recursion stack space as we go as depth as height of tree\\n\\nN=Total Number of Nodes in Tree",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool root_to_leaf(TreeNode* root, int Sum){\\n        \\n        // root reaches NULL that means we didn\\'t find any path root-to-leaf that add up to sum because if there is any we return from line number \\'24\\'\\n        if(root==NULL)return false;\\n        \\n        // because we reach some root value so remaining target sum is sum-root_value\\n        Sum=Sum-root->val;\\n        \\n        // base case when we reach leaf node && Sum becomes \\'0\\' specify that we find a path THEREFORE return true\\n        if(root->left==NULL and root->right==NULL and Sum==0)return true;\\n        \\n        // recursive call to LEFT subtree of root && RIGHT subtree of root using or because \\n        // if any one of them return true we found a path so return true  && if both of them return false we didn\\'t found any path so return false\\n        // true or true => true || true or false => true || false or true => true || false or false => false \\n        return root_to_leaf(root->left,Sum) or root_to_leaf(root->right,Sum);\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        \\n        // EDGE case when tree is empty because there are no root-to-leaf paths THRERFORE return false\\n        if(root==NULL)return false;\\n        \\n        // function call to check if there exist a path root-to-leaf such that adding up values along the path == targetSum\\n        return root_to_leaf(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657629,
                "title": "python-3-7-lines-recursion-t-m-94-56",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if not root :                                               # if null node\\n            return False                                            # return False\\n    \\n        if (not root.right and not root.left                        # if target hit on leaf, \\n            and root.val == targetSum):                             # return True\\n            return True\\n        \\n        return (self.hasPathSum(root.left ,targetSum-root.val) or   # traverse left  subtree\\n                self.hasPathSum(root.right,targetSum-root.val))     # traverse right subtree  \\n```\\n[https://leetcode.com/submissions/detail/603749417/](http://)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        \\n        if not root :                                               # if null node\\n            return False                                            # return False\\n    \\n        if (not root.right and not root.left                        # if target hit on leaf, \\n            and root.val == targetSum):                             # return True\\n            return True\\n        \\n        return (self.hasPathSum(root.left ,targetSum-root.val) or   # traverse left  subtree\\n                self.hasPathSum(root.right,targetSum-root.val))     # traverse right subtree  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580206,
                "title": "accepted-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.left==null && root.right==null && targetSum -root.val ==0)\\n            return true;\\n        \\n        \\n        return hasPathSum(root.left, targetSum -root.val) || hasPathSum(root.right, targetSum -root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.left==null && root.right==null && targetSum -root.val ==0)\\n            return true;\\n        \\n        \\n        return hasPathSum(root.left, targetSum -root.val) || hasPathSum(root.right, targetSum -root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688756,
                "title": "recursive-iterative-and-morris-traversal-solutions-in-python",
                "content": "## Approach 1. recursive\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optiona[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        if root.left == None and root.right == None:\\n            return targetSum == root.val\\n\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\\n## Approach 2. iterative\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        stack = [(root, targetSum - root.val)]\\n\\n        while len(stack) > 0:\\n            node, remainder = stack.pop()\\n\\n            if node.left == None and node.right == None and remainder == 0:\\n                return True\\n\\n            if node.left != None:\\n                stack.append((node.left, remainder - node.left.val))\\n\\n            if node.right != None:\\n                stack.append((node.right, remainder - node.right.val))\\n\\n        return False\\n```\\n## Approach 3. Morris traversal\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\nThis solution is thanks to [ayuanx](https://leetcode.com/problems/path-sum/discuss/36435/C%2B%2B-Non-recursive-O(1)-space-solution-based-on-Morris-Traversal). The intuition behind it is that we keep track of the path sum so far while we traverse down the tree, where `m` is updated when we move the root pointer down the tree, and `n` is updated when we\\'re setting up successor relationships / [threading the tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). When we\\'re about to explore a different path, we subtract the current path\\'s sum `n` from the total path sum `m`.\\n\\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        m = 0\\n\\n        while root != None:\\n            if root.left == None:\\n                m += root.val\\n                root = root.right\\n\\n                if root == None and m == targetSum:\\n                    return True\\n            else:\\n                prev = root.left\\n                n = prev.val\\n\\n                while prev.right != None and prev.right != root:\\n                    prev = prev.right\\n                    n += prev.val\\n\\n                if prev.right == None:\\n                    m += root.val\\n                    prev.right = root\\n\\n                    if prev.left == None and m + n == targetSum:\\n                        return True\\n\\n                    root = root.left\\n                else:\\n                    prev.right = None\\n                    root = root.right\\n                    m -= n\\n\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def hasPathSum(self, root: Optiona[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        if root.left == None and root.right == None:\\n            return targetSum == root.val\\n\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root == None:\\n            return False\\n\\n        stack = [(root, targetSum - root.val)]\\n\\n        while len(stack) > 0:\\n            node, remainder = stack.pop()\\n\\n            if node.left == None and node.right == None and remainder == 0:\\n                return True\\n\\n            if node.left != None:\\n                stack.append((node.left, remainder - node.left.val))\\n\\n            if node.right != None:\\n                stack.append((node.right, remainder - node.right.val))\\n\\n        return False\\n```\n```python\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        m = 0\\n\\n        while root != None:\\n            if root.left == None:\\n                m += root.val\\n                root = root.right\\n\\n                if root == None and m == targetSum:\\n                    return True\\n            else:\\n                prev = root.left\\n                n = prev.val\\n\\n                while prev.right != None and prev.right != root:\\n                    prev = prev.right\\n                    n += prev.val\\n\\n                if prev.right == None:\\n                    m += root.val\\n                    prev.right = root\\n\\n                    if prev.left == None and m + n == targetSum:\\n                        return True\\n\\n                    root = root.left\\n                else:\\n                    prev.right = None\\n                    root = root.right\\n                    m -= n\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896271,
                "title": "simple-recursive-python-3",
                "content": "Algorithm:\\n* decrement the sum as you recurse down the binary tree\\n* if you are at a leaf node, check if `sum == 0`\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        sum -= root.val\\n        \\n        #only check sum if it is a leaf node\\n        if root.left == None and root.right == None:\\n            if sum == 0:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        sum -= root.val\\n        \\n        #only check sum if it is a leaf node\\n        if root.left == None and root.right == None:\\n            if sum == 0:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286472,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && sum == root.val) {\\n            return true;\\n        }\\n\\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null) return false;\\n        if (root.left == null && root.right == null && sum == root.val) {\\n            return true;\\n        }\\n\\n        return HasPathSum(root.left, sum - root.val) || HasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144669,
                "title": "my-swift-solution",
                "content": "\\tfunc hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }",
                "solutionTags": [],
                "code": "\\tfunc hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n        \\n        if root.left == nil && root.right == nil {\\n            return root.val == sum\\n        }\\n        \\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36438,
                "title": "simple-python-solution-3-lines",
                "content": "```\\ndef hasPathSum(self, root, sum):\\n        if root == None:return False\\n        if root.val - sum == 0 and root.left == None and root.right == None:return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "solutionTags": [],
                "code": "```\\ndef hasPathSum(self, root, sum):\\n        if root == None:return False\\n        if root.val - sum == 0 and root.left == None and root.right == None:return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)",
                "codeTag": "Python3"
            },
            {
                "id": 36505,
                "title": "java-recursive-solution-with-comments",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n     \\n     // empty tree\\n     if (root == null)\\n        return false;\\n    \\n     // leaf node, check sum\\n    if (root.left == null && root.right == null) {\\n      if(sum == root.val)\\n        return true;\\n      else \\n        return false;\\n    } \\n    \\n    // at least one sub tree is not null, check if either one has path sum\\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n     \\n        \\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n     \\n     // empty tree\\n     if (root == null)\\n        return false;\\n    \\n     // leaf node, check sum\\n    if (root.left == null && root.right == null) {\\n      if(sum == root.val)\\n        return true;\\n      else \\n        return false;\\n    } \\n    \\n    // at least one sub tree is not null, check if either one has path sum\\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n     \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36500,
                "title": "recommend-for-beginners-recursive-non-recursive-c-implementation-with-detailed-explaination",
                "content": "    class Solution {\\n    public:\\n        /*** recursive solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root==NULL)  return false;\\n            if(root->left==NULL && root->right==NULL)   return sum==root->val;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }\\n        \\n        /*** level-bfs-iterative solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum){\\n            if(root==NULL)  return false;\\n            \\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(q.size()>0){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left==NULL && node->right==NULL){\\n                    if(node->val==sum)  return true;\\n                }\\n                if(node->left){\\n                    node->left->val+=node->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    node->right->val+=node->val;\\n                    q.push(node->right);\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /*** recursive solution  ***/\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root==NULL)  return false;\\n            if(root->left==NULL && root->right==NULL)   return sum==root->val;\\n            return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36510,
                "title": "1ms-3-lines-java-recursion-solution",
                "content": "    public class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        if(root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        if(root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36554,
                "title": "3-line-java-recursive-solution",
                "content": "    public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n            if(root.right==null && root.left == null && root.val == sum) return true;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }",
                "solutionTags": [],
                "code": "    public boolean hasPathSum(TreeNode root, int sum) {\\n            if(root == null) return false;\\n            if(root.right==null && root.left == null && root.val == sum) return true;\\n            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36638,
                "title": "super-easy-3-lines-java-solution",
                "content": "I believe this is the easiest approach. Let me know if you can improve it.\\n\\n    public class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        \\n        if(root.left == null && root.right == null && sum - root.val == 0 ) return true;\\n        \\n        return hasPathSum(root.left,sum - root.val)||hasPathSum(root.right,sum - root.val);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root == null) return false;\\n        \\n        if(root.left == null && root.right == null && sum - root.val == 0 ) return true;\\n        \\n        return hasPathSum(root.left,sum - root.val)||hasPathSum(root.right,sum - root.val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4087878,
                "title": "best-o-n-solution",
                "content": "# Approach\\nDFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool traversal(TreeNode* root, int curSum, int targetSum) {\\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val))\\n                return true;\\n            return false;    \\n        }\\n        if (root->left) {\\n            if (traversal(root->left, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        if (root->right) {\\n            if (traversal(root->right, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int curSum = 0;\\n        if (!root)\\n            return false;\\n        return traversal(root, curSum, targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool traversal(TreeNode* root, int curSum, int targetSum) {\\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val))\\n                return true;\\n            return false;    \\n        }\\n        if (root->left) {\\n            if (traversal(root->left, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        if (root->right) {\\n            if (traversal(root->right, curSum + root->val, targetSum))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        int curSum = 0;\\n        if (!root)\\n            return false;\\n        return traversal(root, curSum, targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609573,
                "title": "path-sum-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a method called hasPathSum that takes two parameters: a root node of a binary tree and a target sum. The method returns true if there is a path from the root to a leaf node that adds up to the target sum, and false otherwise.\\n\\nThe method uses recursion to check every possible path in the tree. It first checks if the root node is null, which means the tree is empty. In that case, it returns false. Then it checks if the root node is a leaf node, which means it has no children. In that case, it subtracts the root node\\u2019s value from the target sum and compares it to zero. If they are equal, it means the path sum equals the target sum, so it returns true. Otherwise, it returns false.\\n\\nIf the root node is not a leaf node, it recursively calls itself on the left and right subtrees of the root node, with the updated target sum (target sum minus root node\\u2019s value). It returns true if either of the recursive calls returns true, or false if both of them return false. This way, it explores all possible paths in the tree and returns true if any of them matches the target sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(h)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.left == null && root.right == null){\\n            if((targetSum - root.val) == 0){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return hasPathSum(root.left,(targetSum - root.val)) || hasPathSum(root.right,(targetSum - root.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root == null){\\n            return false;\\n        }\\n        if(root.left == null && root.right == null){\\n            if((targetSum - root.val) == 0){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return hasPathSum(root.left,(targetSum - root.val)) || hasPathSum(root.right,(targetSum - root.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445571,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return targetSum==root->val;\\n        }\\n        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return false;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return targetSum==root->val;\\n        }\\n        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294299,
                "title": "python3-100-fast-easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Usig DFS**\\n![image.png](https://assets.leetcode.com/users/images/58b332db-48fa-497b-8543-4275b77fc517_1678764586.376835.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use dfs to get till leaf node.\\n- while traversing keep track of current sum.\\n- now when encountered leaf node check current sum and target sum, return true if equal else false.\\n- now we will also keep track of left and right returned values, if we find that from left subtree we\\'re getting answer then we will not traverse right sub-tree.\\n- this will help in redusing time by 50%.\\n- return answer found\\n# Complexity\\n- Time complexity: O(N/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N/2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def dfs_sum(curr=None, sumTill=0):\\n            if curr:\\n                sumTill += curr.val\\n                left = dfs_sum(curr.left, sumTill)\\n                right = False\\n                if not left:\\n                    right = dfs_sum(curr.right, sumTill)\\n                \\n                if curr.left == None and curr.right == None:\\n                    return sumTill == targetSum\\n                return left or right\\n            return False\\n        return dfs_sum(root)\\n```\\n # Please like and comment below ( \\u0361\\uD83D\\uDC41\\uFE0F\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDC41\\uFE0F)\\uD83D\\uDC4C",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        def dfs_sum(curr=None, sumTill=0):\\n            if curr:\\n                sumTill += curr.val\\n                left = dfs_sum(curr.left, sumTill)\\n                right = False\\n                if not left:\\n                    right = dfs_sum(curr.right, sumTill)\\n                \\n                if curr.left == None and curr.right == None:\\n                    return sumTill == targetSum\\n                return left or right\\n            return False\\n        return dfs_sum(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193893,
                "title": "python-recursive-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None and targetSum - root.val == 0:\\n            return True\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root is None:\\n            return False\\n        if root.left is None and root.right is None and targetSum - root.val == 0:\\n            return True\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996017,
                "title": "1ms-java-recursive-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return false;\\n        }\\n        if(root.left==null && root.right==null && targetSum==root.val){\\n            return true;\\n        }\\n\\n        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830351,
                "title": "java-dfs",
                "content": "If you like it pls upvote\\n```\\n\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n\\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n\\n            if(curr.val == targetSum && curr.left==null && curr.right==null) {\\n                return true;\\n            }\\n\\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n\\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n\\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n\\n            if(curr.val == targetSum && curr.left==null && curr.right==null) {\\n                return true;\\n            }\\n\\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n\\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765268,
                "title": "tree-traversal",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ans = [False]\\n        \\n        def tree_traversal(root, curr_sum, ans):\\n            curr_sum += root.val\\n    \\n            if root.left is None and root.right is None:\\n                if curr_sum == targetSum:\\n                    ans[0] = True\\n\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, ans)\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, ans)\\n        \\n        if root:\\n            tree_traversal(root, 0, ans)\\n        return ans[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        \\n        ans = [False]\\n        \\n        def tree_traversal(root, curr_sum, ans):\\n            curr_sum += root.val\\n    \\n            if root.left is None and root.right is None:\\n                if curr_sum == targetSum:\\n                    ans[0] = True\\n\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, ans)\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, ans)\\n        \\n        if root:\\n            tree_traversal(root, 0, ans)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765163,
                "title": "one-lineeer",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        return (root.val == targetSum) if (root and not root.left and not root.right) else (root and (self.hasPathSum(root.right, targetSum - root.val) or self.hasPathSum(root.left, targetSum - root.val)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687829,
                "title": "java-recursive-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        traversal(root,targetSum);\\n        return res;\\n    }\\n    boolean res = false;\\n    public void traversal(TreeNode root, int targetSum) {\\n        if(root != null) {\\n            root.val = targetSum-root.val;\\n            if(root.left == null && root.right == null && root.val == 0) {\\n                res = true;\\n                return;\\n            }\\n            traversal(root.left, root.val);\\n            traversal(root.right, root.val);\\n        }\\n    }\\n}\\n```\\n\\nIf you like the solution please do upvote, Thanks in advance.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        traversal(root,targetSum);\\n        return res;\\n    }\\n    boolean res = false;\\n    public void traversal(TreeNode root, int targetSum) {\\n        if(root != null) {\\n            root.val = targetSum-root.val;\\n            if(root.left == null && root.right == null && root.val == 0) {\\n                res = true;\\n                return;\\n            }\\n            traversal(root.left, root.val);\\n            traversal(root.right, root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658684,
                "title": "root-path-sum",
                "content": "bool hasPathSum(TreeNode* root, int sum) {\\n      if(root == nullptr) return false;\\nif(root->val == sum && root->right == nullptr && root->left == nullptr) return true;\\nif(root->left != nullptr) root->left->val += root->val;\\nif(root->right != nullptr) root->right->val += root->val;\\nreturn hasPathSum(root->left,sum) || hasPathSum(root->right,sum);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "bool hasPathSum(TreeNode* root, int sum) {\\n      if(root == nullptr) return false;\\nif(root->val == sum && root->right == nullptr && root->left == nullptr) return true;\\nif(root->left != nullptr) root->left->val += root->val;\\nif(root->right != nullptr) root->right->val += root->val;\\nreturn hasPathSum(root->left,sum) || hasPathSum(root->right,sum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2658505,
                "title": "112-path-sum-python",
                "content": "Python:\\n```\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        sum -= root.val\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n    def hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        if not root.left and not root.right and root.val == sum:\\n            return True\\n        sum -= root.val\\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2657607,
                "title": "daily-leetcode-solution-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool preOrderTraversal(TreeNode* root,int targetSum)\\n    {\\n        if(root==NULL) return false;\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            if(root->val==targetSum) return true;\\n        }\\n        bool left=preOrderTraversal(root->left,targetSum-(root->val));\\n        bool right=preOrderTraversal(root->right,targetSum-(root->val));\\n        return left|right;\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return preOrderTraversal(root,targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool preOrderTraversal(TreeNode* root,int targetSum)\\n    {\\n        if(root==NULL) return false;\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            if(root->val==targetSum) return true;\\n        }\\n        bool left=preOrderTraversal(root->left,targetSum-(root->val));\\n        bool right=preOrderTraversal(root->right,targetSum-(root->val));\\n        return left|right;\\n    }\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        return preOrderTraversal(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657586,
                "title": "daily-leetcoding-challenge-october-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterations\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2537117,
                "title": "javascript-dfs-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} targetSum\\n * @return {boolean}\\n */\\nconst hasPathSum = (root, targetSum) => {\\n    // DFS\\n    // Relatively easy to understand\\n    if(!root) return false; // Base case if we DFS all the way to the end, but dont find an answer\\n    \\n    // Condition if true\\n    // Since we substract the node value from the targetSum as we DFS\\n    // If we get to a node with no left or right AND the node.val === targetSum, we found an answer\\n\\t// Because if node.val === targetSum, that means if we subtract the two, it is 0\\n    if(!root.left && !root.right && targetSum === root.val) return true;\\n    \\n    // We just need to find 1, so if either side returns true, it is true\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} targetSum\\n * @return {boolean}\\n */\\nconst hasPathSum = (root, targetSum) => {\\n    // DFS\\n    // Relatively easy to understand\\n    if(!root) return false; // Base case if we DFS all the way to the end, but dont find an answer\\n    \\n    // Condition if true\\n    // Since we substract the node value from the targetSum as we DFS\\n    // If we get to a node with no left or right AND the node.val === targetSum, we found an answer\\n\\t// Because if node.val === targetSum, that means if we subtract the two, it is 0\\n    if(!root.left && !root.right && targetSum === root.val) return true;\\n    \\n    // We just need to find 1, so if either side returns true, it is true\\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379258,
                "title": "accepted-dfs-iterative-java",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            \\n            if(curr.val == targetSum && curr.left==null && curr.right==null)    return true;\\n            \\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n            \\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)  return false;\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            \\n            if(curr.val == targetSum && curr.left==null && curr.right==null)    return true;\\n            \\n            if(curr.left!=null) {\\n                curr.left.val += curr.val;\\n                stack.push(curr.left);\\n            }\\n            \\n            if(curr.right!=null) {\\n                curr.right.val += curr.val;\\n                stack.push(curr.right);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176648,
                "title": "python3-short-4lines-dfs",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        if root.val == sum and not  root.left and not root.right:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n        if root.val == sum and not  root.left and not root.right:\\n            return True\\n        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013138,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root == NULL)\\n            return false;\\n        if(root->left == NULL && root->right == NULL && targetSum  - root->val == 0)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val) ;\\n       }\\n\\t};\\n\\t\\n\\nTime complexity  --> O(n) \\nspace complexity --> O(log n)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root == NULL)\\n            return false;\\n        if(root->left == NULL && root->right == NULL && targetSum  - root->val == 0)\\n            return true;\\n        else\\n            return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val) ;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1746355,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)return false;\\n        if(root.left==null &&root.right==null){\\n           return root.val==targetSum;\\n        }\\n        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if(root==null)return false;\\n        if(root.left==null &&root.right==null){\\n           return root.val==targetSum;\\n        }\\n        return hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741659,
                "title": "c-fast-solution-dfs-recursive-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        else  \\n        if(root->left==NULL && root->right==NULL) {\\n             if(targetSum-root->val==0)\\n                return true;\\n            return false;\\n        }\\n            bool l=hasPathSum(root->left,targetSum-root->val);\\n            bool r=hasPathSum(root->right,targetSum-root->val);\\n     return l || r;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        else  \\n        if(root->left==NULL && root->right==NULL) {\\n             if(targetSum-root->val==0)\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1583269,
                "title": "python3-easy-fast-recursive-solution",
                "content": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root: return False\\n        if root and not root.left and not root.right: return root.val == targetSum\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root: return False\\n        if root and not root.left and not root.right: return root.val == targetSum\\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560896,
                "title": "python3-simple-solution-with-explanation",
                "content": "**Idea:**\\nFor every node we visit we add its value to the path_sum, and:\\nIf its a leaf, we check if its `path_sum` is equal to the `targetSum`,\\notherwise, we continue checking with its left and right nodes.\\n\\n**Time complexity:** O(n) where n is the number of nodes in the tree.\\n**Space complexity:** O(h) where h is the height of the tree (in worst case h=n).\\n\\n```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```\\n\\n*Thanx for reading, please **upvote** if it helped you :)*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def inorder(root, path_sum):\\n            if not root:\\n                return False\\n            \\n            path_sum+=root.val\\n            \\n            if not root.left and not root.right:\\n                return path_sum==targetSum\\n                \\n            return inorder(root.left, path_sum) or inorder(root.right, path_sum)\\n             \\n        return inorder(root, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1522254,
                "title": "simple-to-understand-using-recursion-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int targetSum) {\\n        return Search(root, targetSum);\\n    }\\n    \\n    public bool Search(TreeNode node, int targetSum) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        // Determine the current sum\\n        targetSum = targetSum - node.val;\\n        \\n        // Since this is a root-to-leaf check, evaluate for the \\n        // success condition when both left and right nodes are null        \\n        if (node.left == null && node.right == null) {\\n            return targetSum == 0;\\n        }\\n        \\n        // Keep exploring along branches finding the target sum\\n        return Search(node.left, targetSum)\\n            || Search(node.right, targetSum);      \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int targetSum) {\\n        return Search(root, targetSum);\\n    }\\n    \\n    public bool Search(TreeNode node, int targetSum) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        // Determine the current sum\\n        targetSum = targetSum - node.val;\\n        \\n        // Since this is a root-to-leaf check, evaluate for the \\n        // success condition when both left and right nodes are null        \\n        if (node.left == null && node.right == null) {\\n            return targetSum == 0;\\n        }\\n        \\n        // Keep exploring along branches finding the target sum\\n        return Search(node.left, targetSum)\\n            || Search(node.right, targetSum);      \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467761,
                "title": "javascript-solution-with-stack",
                "content": "Solving this question with recursion is too simple. Why not implement a stack instead???\\n\\nStrategy: Add node and current total of the path we are traversing into the stack. \\n\\t\\t\\t\\tKeep track of where we are in the tree using a variable called curr\\n\\t\\t\\t\\tWhen we have no left or right children, we check to see if value in the path is equal to target value.\\n```\\nvar hasPathSum = function(root, targetSum) {\\n//check to see if we are given an empty tree\\n    if (!root)return false\\n    const stack =[]\\n\\t\\n\\t//in our current variable, we will keep track of the tree in 0th index, and keep current sum of path at 1st index\\n     let curr=[root,0]\\n\\t \\n\\t /* our stop conditions for while loop are:\\n\\t 1.) when we have no elements in the stack\\n\\t 2.) since our stack is initially empty, we will add in when curr is null as a stop condition */\\n\\n    while (curr || stack.length){\\n\\t/* we want to keep adding to our stack while traversing left. We will stop when we add a null child to our\\n\\tstack, since that means we are at the leftmost child of current subtree*/\\n       while (curr && curr[0]){\\n           let [node,val]=curr\\n           stack.push([node,val+node.val])\\n           curr=[node.left,val+node.val]\\n       }\\n\\t   /*because curr has an empty child, that means we have went 1 level too far in the tree, in order\\n\\t   to get our last node that had a value in the tree, we just pop off the last item in the stack*/\\n          curr=stack.pop()\\n\\n   /* we need to figure out if the node we are currently at-which we know has no left children, is a leaf,\\n   meaning it has no right children as well. So we set a variable rightNode as either the right node, or null */\\n        let rightNode= curr[0]? curr[0].right :null\\n        if (rightNode === null){\\n\\t\\t/*we need to ensure we are at a leaf, and if we are, we will see if current path sum is equal to target */\\n            if(curr[0].left===null && curr[1]===targetSum){\\n                return true\\n            }\\n\\t\\t\\t/*since we are at a leaf node, we cannot traverse any further, we will instead set curr to null so that\\n\\t\\t\\twe bypass the inner while loop and pop off the stack to previous node */\\n\\t\\t\\tcurr=null\\n        } else {\\n\\t\\t//since we do have a right node, we want to traverse down to the bottom of the graph before checking sum\\n            curr=[rightNode, curr[1]]        \\n        }   \\n\\t\\t\\n    } return false \\n}",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "Solving this question with recursion is too simple. Why not implement a stack instead???\\n\\nStrategy: Add node and current total of the path we are traversing into the stack. \\n\\t\\t\\t\\tKeep track of where we are in the tree using a variable called curr\\n\\t\\t\\t\\tWhen we have no left or right children, we check to see if value in the path is equal to target value.\\n```\\nvar hasPathSum = function(root, targetSum) {\\n//check to see if we are given an empty tree\\n    if (!root)return false\\n    const stack =[]\\n\\t\\n\\t//in our current variable, we will keep track of the tree in 0th index, and keep current sum of path at 1st index\\n     let curr=[root,0]\\n\\t \\n\\t /* our stop conditions for while loop are:\\n\\t 1.) when we have no elements in the stack\\n\\t 2.) since our stack is initially empty, we will add in when curr is null as a stop condition */\\n\\n    while (curr || stack.length){\\n\\t/* we want to keep adding to our stack while traversing left. We will stop when we add a null child to our\\n\\tstack, since that means we are at the leftmost child of current subtree*/\\n       while (curr && curr[0]){\\n           let [node,val]=curr\\n           stack.push([node,val+node.val])\\n           curr=[node.left,val+node.val]\\n       }\\n\\t   /*because curr has an empty child, that means we have went 1 level too far in the tree, in order\\n\\t   to get our last node that had a value in the tree, we just pop off the last item in the stack*/\\n          curr=stack.pop()\\n\\n   /* we need to figure out if the node we are currently at-which we know has no left children, is a leaf,\\n   meaning it has no right children as well. So we set a variable rightNode as either the right node, or null */\\n        let rightNode= curr[0]? curr[0].right :null\\n        if (rightNode === null){\\n\\t\\t/*we need to ensure we are at a leaf, and if we are, we will see if current path sum is equal to target */\\n            if(curr[0].left===null && curr[1]===targetSum){\\n                return true\\n            }\\n\\t\\t\\t/*since we are at a leaf node, we cannot traverse any further, we will instead set curr to null so that\\n\\t\\t\\twe bypass the inner while loop and pop off the stack to previous node */\\n\\t\\t\\tcurr=null\\n        } else {\\n\\t\\t//since we do have a right node, we want to traverse down to the bottom of the graph before checking sum\\n            curr=[rightNode, curr[1]]        \\n        }   \\n\\t\\t\\n    } return false \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1377783,
                "title": "c-short-and-easy-recursion",
                "content": "**If you liked this solution, Please Upvote. Thanks**\\n\\n```\\n\\tbool hasPathSum(TreeNode* root, int sum) {\\n        if(root==nullptr) return false;\\n        if(root->left==nullptr and root->right==nullptr)\\n            if(sum==root->val) return true;\\n        return hasPathSum(root->left,sum-(root->val)) or hasPathSum(root->right,sum-(root->val));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool hasPathSum(TreeNode* root, int sum) {\\n        if(root==nullptr) return false;\\n        if(root->left==nullptr and root->right==nullptr)\\n            if(sum==root->val) return true;\\n        return hasPathSum(root->left,sum-(root->val)) or hasPathSum(root->right,sum-(root->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313180,
                "title": "easy-python-solution-98-77",
                "content": "Runtime: 32 ms, faster than 98.77% of Python3 online submissions for Path Sum.\\nMemory Usage: 15.7 MB, less than 92.65% of Python3 online submissions for Path Sum.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        def h(node,ans):\\n            if(node):\\n                ans-=node.val\\n            else:\\n                return None\\n            if(ans==0 and (node.left==node.right==None)):\\n                return True\\n            else:\\n                return h(node.left,ans) or h(node.right,ans)\\n        return h(root,targetSum)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 32 ms, faster than 98.77% of Python3 online submissions for Path Sum.\\nMemory Usage: 15.7 MB, less than 92.65% of Python3 online submissions for Path Sum.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\\n        def h(node,ans):\\n            if(node):\\n                ans-=node.val\\n            else:\\n                return None\\n            if(ans==0 and (node.left==node.right==None)):\\n                return True\\n            else:\\n                return h(node.left,ans) or h(node.right,ans)\\n        return h(root,targetSum)",
                "codeTag": "Java"
            },
            {
                "id": 1062745,
                "title": "c-simple-recursive-solution-faster-then-95",
                "content": "```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    if (root == NULL) return false;\\n    \\n    // root node is a leaf\\n    if(root->left == NULL && root->right== NULL){\\n        if(root->val == targetSum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    return ((hasPathSum(root->left,targetSum - root->val))||\\n            (hasPathSum(root->right,targetSum - root->val)));\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool hasPathSum(struct TreeNode* root, int targetSum){\\n    if (root == NULL) return false;\\n    \\n    // root node is a leaf\\n    if(root->left == NULL && root->right== NULL){\\n        if(root->val == targetSum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    return ((hasPathSum(root->left,targetSum - root->val))||\\n            (hasPathSum(root->right,targetSum - root->val)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039799,
                "title": "elegant-recursive-java-solution",
                "content": "\\n```\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        if (root.val == targetSum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public boolean hasPathSum(TreeNode root, int targetSum) {\\n        if (root == null) return false;\\n        if (root.val == targetSum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779553,
                "title": "c-recursion-fast-then-94-of-solution-easy-to-understand",
                "content": "**Please UP Vote this solution if you like**\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool dfs(TreeNode *root,int sum)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL && sum-root->val==0)// If this is a leaf node and sum-leafNodeValue==0 return True;\\n            return 1;\\n        \\n        return dfs(root->left,sum-root->val) || dfs(root->right,sum-root->val);//If left or right sub tree satisfy the condition the return true\\n    }\\n    \\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return dfs(root,sum);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool dfs(TreeNode *root,int sum)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(root->left==NULL && root->right==NULL && sum-root->val==0)// If this is a leaf node and sum-leafNodeValue==0 return True;\\n            return 1;\\n        \\n        return dfs(root->left,sum-root->val) || dfs(root->right,sum-root->val);//If left or right sub tree satisfy the condition the return true\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 689922,
                "title": "simple-iterative-solution-c",
                "content": "Iterative Solution\\n```\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        vector<TreeNode*> my_stack;\\n        my_stack.emplace_back(root);\\n        while(!my_stack.empty()){\\n            root = my_stack.back();\\n            my_stack.pop_back();\\n            if(root){\\n                if(!root->left&&!root->right&&root->val==sum) return true; //check terminating condition only at leaf node \\n                if(root->right){\\n                    root->right->val += root->val;\\n                    my_stack.emplace_back(root->right);\\n                }  \\n                if(root->left){\\n                    root->left->val += root->val;\\n                    my_stack.emplace_back(root->left);\\n                }  \\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        vector<TreeNode*> my_stack;\\n        my_stack.emplace_back(root);\\n        while(!my_stack.empty()){\\n            root = my_stack.back();\\n            my_stack.pop_back();\\n            if(root){\\n                if(!root->left&&!root->right&&root->val==sum) return true; //check terminating condition only at leaf node \\n                if(root->right){\\n                    root->right->val += root->val;\\n                    my_stack.emplace_back(root->right);\\n                }  \\n                if(root->left){\\n                    root->left->val += root->val;\\n                    my_stack.emplace_back(root->left);\\n                }  \\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683862,
                "title": "in-rust",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(n) = root {\\n            let node = n.borrow();\\n            if node.left.is_none() && node.right.is_none() && node.val == sum {\\n                return true\\n            }\\n            return Solution::has_path_sum(node.left.clone(), sum - node.val) ||\\n                    Solution::has_path_sum(node.right.clone(), sum - node.val)\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(n) = root {\\n            let node = n.borrow();\\n            if node.left.is_none() && node.right.is_none() && node.val == sum {\\n                return true\\n            }\\n            return Solution::has_path_sum(node.left.clone(), sum - node.val) ||\\n                    Solution::has_path_sum(node.right.clone(), sum - node.val)\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673154,
                "title": "java-dfs-runtime-faster-100",
                "content": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        sum -= root.val;\\n        if (sum == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return false;\\n        }\\n        \\n        sum -= root.val;\\n        if (sum == 0 && root.left == null && root.right == null) {\\n            return true;\\n        }\\n        \\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519579,
                "title": "c-iterative-solution",
                "content": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t    var stack = new Stack<(TreeNode Node, int Sum)>();\\n\\t    stack.Push((root, root.val));\\n\\t    while (stack.Count != 0) {\\n\\t\\t    var p = stack.Pop();\\n            TreeNode node = p.Node;\\n            int psum = p.Sum;\\n            \\n\\t\\t\\tif (node.right != null)\\n\\t\\t        stack.Push((node.right, node.right.val+psum));\\t\\t\\t\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tstack.Push((node.left, node.left.val+psum));\\n            \\n\\t\\t\\tif (node.left == null && node.right == null && psum == sum)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasPathSum(TreeNode root, int sum) {\\n        if (root == null)\\n\\t\\t\\treturn false;\\n\\n\\t    var stack = new Stack<(TreeNode Node, int Sum)>();\\n\\t    stack.Push((root, root.val));\\n\\t    while (stack.Count != 0) {\\n\\t\\t    var p = stack.Pop();\\n            TreeNode node = p.Node;\\n            int psum = p.Sum;\\n            \\n\\t\\t\\tif (node.right != null)\\n\\t\\t        stack.Push((node.right, node.right.val+psum));\\t\\t\\t\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tstack.Push((node.left, node.left.val+psum));\\n            \\n\\t\\t\\tif (node.left == null && node.right == null && psum == sum)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466765,
                "title": "simple-recursion",
                "content": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null){\\n            return false;\\n        }else if(root.left==null && root.right==null && root.val == sum){\\n            return true;\\n        }\\n        return hasPathSum(root.left, sum-(root.val)) || hasPathSum(root.right, sum-(root.val));\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null){\\n            return false;\\n        }else if(root.left==null && root.right==null && root.val == sum){\\n            return true;\\n        }\\n        return hasPathSum(root.left, sum-(root.val)) || hasPathSum(root.right, sum-(root.val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320633,
                "title": "c-88-beat-easy-win-o-n-recursive-solution-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {        \\n        if (root == NULL) { return false; }\\n        sum -= root->val;\\n        if (root->left == NULL && root->right == NULL && sum == 0) { return true; }\\n        if (root->left  != NULL) { if (hasPathSum(root->left,  sum)) { return true; } }\\n        if (root->right != NULL) { if (hasPathSum(root->right, sum)) { return true; } }\\n        return false;\\n    }\\n};\\n```\\n\\nThe logic checks out.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {        \\n        if (root == NULL) { return false; }\\n        sum -= root->val;\\n        if (root->left == NULL && root->right == NULL && sum == 0) { return true; }\\n        if (root->left  != NULL) { if (hasPathSum(root->left,  sum)) { return true; } }\\n        if (root->right != NULL) { if (hasPathSum(root->right, sum)) { return true; } }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315089,
                "title": "simple-rust-recursive-solution-faster-than-100-00-of-rust-online-submissions",
                "content": "```\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        Solution::helper(&root, sum)\\n    }\\n\\n    fn helper(root: &Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(data) = root {\\n            let node = data.borrow_mut();\\n            if node.left.is_none() && node.right.is_none() { // is leaf\\n                return sum == node.val;\\n            }\\n            return Solution::helper(&node.left, sum - node.val)\\n                || Solution::helper(&node.right, sum - node.val);\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        Solution::helper(&root, sum)\\n    }\\n\\n    fn helper(root: &Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\\n        if let Some(data) = root {\\n            let node = data.borrow_mut();\\n            if node.left.is_none() && node.right.is_none() { // is leaf\\n                return sum == node.val;\\n            }\\n            return Solution::helper(&node.left, sum - node.val)\\n                || Solution::helper(&node.right, sum - node.val);\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 157106,
                "title": "easy-4-lines-scala",
                "content": "```\\n  def hasPathSum(root: TreeNode, sum: Int): Boolean = (root, sum) match {\\n    case (null, _) => false\\n    case (r, s) if r.left == null && r.right == null => r.value == sum\\n    case (r, s) =>\\n      hasPathSum(r.left, sum - r.value) || hasPathSum(r.right, sum - r.value)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def hasPathSum(root: TreeNode, sum: Int): Boolean = (root, sum) match {\\n    case (null, _) => false\\n    case (r, s) if r.left == null && r.right == null => r.value == sum\\n    case (r, s) =>\\n      hasPathSum(r.left, sum - r.value) || hasPathSum(r.right, sum - r.value)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 36361,
                "title": "3-lines-accepted-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public boolean hasPathSum(TreeNode root, int sum) \\n    {  \\n        if (root == null) return false;\\n        if (root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean hasPathSum(TreeNode root, int sum) \\n    {  \\n        if (root == null) return false;\\n        if (root.val == sum && root.left == null && root.right == null) return true;\\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36428,
                "title": "java-3-line-easy-to-understand-1-ms",
                "content": "```\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        if(sum-root.val==0 && root.left==null && root.right==null)return true;\\n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean hasPathSum(TreeNode root, int sum) {\\n        if(root==null)return false;\\n        if(sum-root.val==0 && root.left==null && root.right==null)return true;\\n        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36499,
                "title": "one-line-c-solution",
                "content": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && ((!root->left && !root->right && root->val == sum) || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        return root && ((!root->left && !root->right && root->val == sum) || hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36537,
                "title": "c-bfs-solution",
                "content": "    class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            queue<TreeNode*> myqueue;\\n            myqueue.push(root);\\n            while(!myqueue.empty()){\\n                TreeNode* cur = myqueue.front();\\n                myqueue.pop();\\n                if(cur->left != NULL){\\n                    cur->left->val+=cur->val;\\n                    myqueue.push(cur->left);\\n                }\\n                if(cur->right != NULL){\\n                    cur->right->val+=cur->val;\\n                    myqueue.push(cur->right);\\n                }\\n                if(cur->left == NULL && cur->right ==NULL && cur->val == sum) return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool hasPathSum(TreeNode* root, int sum) {\\n            if(root == NULL) return false;\\n            queue<TreeNode*> myqueue;\\n            myqueue.push(root);\\n            while(!myqueue.empty()){\\n                TreeNode* cur = myqueue.front();\\n                myqueue.pop();\\n                if(cur->left != NULL){\\n                    cur->left->val+=cur->val;\\n                    myqueue.push(cur->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 36546,
                "title": "c-12ms-recursive-iterative-solutions",
                "content": "    class Solution {\\n    public:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        //return solution1(root, sum);        //recursive\\n        return solution2(root, sum);        //iterative\\n    }\\n    private:\\n    bool solution1(TreeNode *n, int sum){\\n        if(!n) return false;\\n        if(!n->left && !n->right) return sum - n->val == 0;\\n        return solution1(n->left, sum - n->val) || solution1(n->right, sum - n->val);\\n    }\\n    bool solution2(TreeNode *n, int sum){\\n        if(!n) return false;\\n        stack<TreeNode *> st;\\n        TreeNode *cur = n, *pre;\\n        while(cur || !st.empty()){\\n            while(cur){\\n                st.push(cur);\\n                sum -= cur->val;\\n                cur = cur->left;\\n            }\\n            cur = st.top();\\n            if(!cur->left && !cur->right && !sum) return true;\\n            if(cur->right && pre != cur->right) cur = cur->right;\\n            else{\\n                st.pop();\\n                sum += cur->val;\\n                pre = cur;\\n                cur = NULL;\\n            }\\n        }\\n        return false;\\n    }\\n    };",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        //return solution1(root, sum);        //recursive\\n        return solution2(root, sum);        //iterative\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36590,
                "title": "simple-recursive-solution-in-ruby",
                "content": "    def has_path_sum(root, sum)\\n      return false if root.nil?\\n    \\n      if root.val == sum && root.left.nil? && root.right.nil?\\n        return true\\n      end\\n      \\n      has_path_sum(root.left, sum - root.val) || has_path_sum(root.right, sum - root.val)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def has_path_sum(root, sum)\\n      return false if root.nil?\\n    \\n      if root.val == sum && root.left.nil? && root.right.nil?\\n        return true\\n      end\\n      \\n      has_path_sum(root.left, sum - root.val) || has_path_sum(root.right, sum - root.val)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 36599,
                "title": "8-ms-c-solution-one-line-of-code",
                "content": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        return !root? false: (root->right || root->left)? hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val):sum==root->val ;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    bool hasPathSum(struct TreeNode* root, int sum) {\\n        return !root? false: (root->right || root->left)? hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val):sum==root->val ;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565659,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1564962,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566325,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566073,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1568025,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1572485,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566969,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1570035,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1815767,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1574172,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1565659,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1564962,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566325,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566073,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1568025,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1572485,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566969,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1570035,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1815767,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1574172,
                "content": [
                    {
                        "username": "dong12",
                        "content": "why should 'input [],0'   return false?  Isn't it true?"
                    },
                    {
                        "username": "mayankagarwal2402",
                        "content": "[@AKA_RAN](/AKA_RAN) now you\\'re just devising an argument to support the faulty somehow. To counter your argument I\\'d say \"the given input(zero nodes) satisfies the target(zero) already hence it should have been true\". This question should\\'ve focused on testing my analytical and coding skills and not my grammatical skills. "
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Problem statement not specific enough and both your and relies\\' interpretation are possible. That case messes up the most elegant solution"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "null != 0"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "If you don\\'t have anything i.e. positive, negative or zero. Then how someone can achieve any target."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "There has to be some path. In case of no nodes, there is no path. The null path isn't a path."
                    },
                    {
                        "username": "Jinlong",
                        "content": "       1\\n2            *\\n\\nThe struct is like above, and the sum of  right path is 1. Why the output is false?\\n\\nAdditional:\\n\\nFind another problem: the output of \"{1}, 1\" is true......\\n\\nwhy....."
                    },
                    {
                        "username": "nghiadq",
                        "content": "A leaf is a node with no children. in this case 1 is not a leaf because have children 2, 2 is a leaf"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Just a suggestion but the [] 0 test case makes you create a helper method or add additional complexity for no real gain. Could we perhaps delete that test case?\\n\\nIn all honesty it is rather ambigious if [] 0 should return false or true as there is a path that sums to nothing, the null path. Removing this test case would also remove that ambiguity."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "\"0\" is not NULL. It is real value. Instead of zero it can be any positive or negative value also.\\nTherefore don\\'t consider zero as NULL"
                    },
                    {
                        "username": "slovic",
                        "content": "It depends of usecase... but suggested behavior is more strict, and thou it should be preferred. From implementation point of view it is even simpler to implement it with current spec, because you can reuse top level behavior to left and right nodes (if they are nulls then result is false no matter what so you can call `hasPathSum(root.left, targetSum-root.value)` and if left was null it will return good result."
                    },
                    {
                        "username": "ravichandrae",
                        "content": "This problem has a test case for testing whether there is any path sum 0 for an empty binary tree.\\n{},0\\n\\nIt expects the result as false. But I think it's more intuitive to state the result as true."
                    },
                    {
                        "username": "suraj813",
                        "content": "Root node 1 has 2 children - 2 & None\\nPathSum_1 = 1+2 = 3\\nPathSum_2 = 1+None = 1\\n\\nThe expected answer is false. Is PathSum_2 not valid?"
                    },
                    {
                        "username": "nichita_trifan",
                        "content": "its not a leaf node"
                    },
                    {
                        "username": "leo3065",
                        "content": "I think PathSum_2 is not valid since it does not end in a leaf node"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "If a root has a value of [1] with a target value 1, the expected answer is True for this problem.\\nHowever, this root has no leaf which means it does not satisfy what the question is asking for....\\n\\n[1,2] 1 will result a false case... how is [1] 1 a true case?\\nPlease explain."
                    },
                    {
                        "username": "luqmansen",
                        "content": "[@luqmansen](/luqmansen) okay got it, the answer should be root to leaf.\\n\\nleaf is node with no children \\n\\nin this case, the node is a root and a leaf at the same time"
                    },
                    {
                        "username": "luqmansen",
                        "content": "same here, confused with the expected answer, anyone?"
                    },
                    {
                        "username": "johnny231198",
                        "content": "By definition an empty sum is 0 and this test case says that there is no path in this tree with sum equal to 0. I think this is a mistake... Please correct me if I am wrong."
                    },
                    {
                        "username": "khushiagarwal220",
                        "content": "if there is only root node, then targetSum would be \\nzero"
                    },
                    {
                        "username": "siddh",
                        "content": "Is this case valid tree= [] , sum=0, expected=false, shouldn\\'t this be true"
                    },
                    {
                        "username": "ashwani5",
                        "content": "This question has a lot of inconsistent test cases.\\n\\nroot=[1,2], targetSum=1 is false\\nroot=[1], targetSum=1 is true"
                    },
                    {
                        "username": "leson1106",
                        "content": "it\\'s true because [1, 2] should valid with targetSum = 3 where 1 + 2 = 3 and 2 is a leaf. And [1], yeah there is only 1 leaf so targetSum = 1 is correct"
                    },
                    {
                        "username": "an_98",
                        "content": "Your input\\n[1,2]\\n1\\nOutput : true\\nExpected : false\\n\\nThere is a tree clearly, then how is it false. Please tell me where I am wrong?"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "[@noobcoder1729](/noobcoder1729) definition of leaf : node with has no children --> but here root has one left child .. so it cant be leaf ! "
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "[@noobcoder1729](/noobcoder1729) how root behaves as a leaf, if it has a child node?"
                    },
                    {
                        "username": "NGUgeneral",
                        "content": "There is one single branch in your example. And its path sum is 3. 3 != 1"
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "We have to find path from root to leaf. Root here itself behaves as the leaf also. Therefore true. "
                    }
                ]
            },
            {
                "id": 1566745,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1569579,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 2016906,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1674698,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1574055,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1573928,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1573249,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1571233,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1571234,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 1630176,
                "content": [
                    {
                        "username": "amiyadiwan",
                        "content": "If only strictly positive numbers are allowed as values, then additional pruning of branches can be applied"
                    },
                    {
                        "username": "RandomDev123",
                        "content": "If the tree is empty and the supplied int value is 0, the \"expected\" response is false, but this isn\\'t specified in the question\\'s description. There\\'s a case to be made that the code should return TRUE in that case, as there does exist a path that adds to 0."
                    },
                    {
                        "username": "pavlic148",
                        "content": "In that case there\\'s no such path that adds to 0 since there are no paths at all."
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "Anyone else having issues with this test case \\nroot = [1,2,null,3,null,4,null,5], targetSum = 6, expected false????\\nAm I missing something here?\\n \\nTarget: 6, path: 1->2->3. \\n\\n[Submission](https://leetcode.com/problems/path-sum/submissions/1023144591/)\\n"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) Ahh got it. Yeah, I should have read the problem more carefully. Thanks"
                    },
                    {
                        "username": "sjames8888",
                        "content": "has a root-to-leaf path in question where implication is you must go all way down the side of tree root to leaf where both left right are null as end point \\n```java\\n // a leaf\\n        if (v == target && root.left == null && root.right == null) {\\n            return target;\\n        }\\n```"
                    },
                    {
                        "username": "krenarkrenarshatri",
                        "content": "[@sjames8888](/sjames8888) I\\'m not sure what you mean? The TreeNode is just on the left side(like a linked list) and the sum 1+2+3 should give a target of 6. Or you meant something else?!"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Task :compileTestJava\n> Task :processTestResources NO-SOURCE\n> Task :testClasses\n> Task :test\n\n```txt\n                                    1\n                        /\n                       2\n                   /\n                  3\n                /\n               4\n              /\n             5\n```\n\ngraph is as above \n\n @Test\n    void case5() {\n        final var root = TreeNode.from(new Integer[] {1,2,null,3,null,4,null,5});\n        Assertions.assertNotNull(root);\n        System.out.println(root.prettyPrint());\n        final var res = new PathSum().hasPathSum(root, 6);\n        Assertions.assertFalse(res);\n    }\n\ns\n"
                    },
                    {
                        "username": "wjeevika",
                        "content": "Idk why but I like this question. It\\'s so cute. "
                    },
                    {
                        "username": "akashgkrishnan",
                        "content": "I had run the same code multiple times and found that the same code runs faster then 90 percent of submissions and also slower than 90 percent submissions. is there any particular reason why"
                    },
                    {
                        "username": "max_223",
                        "content": "Below are two related problems and solution in C++/Java/Python if anybody is interested:\\n\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/\">Find maximum sum root-to-leaf path in a binary tree</a>\\n<a href=\"https://www.techiedelight.com/find-maximum-sum-path-between-two-leaves-in-a-binary-tree/\">Find maximum sum path between two leaves in a binary tree</a>"
                    },
                    {
                        "username": "sugikushal",
                        "content": "public boolean hasPathSum(TreeNode root, int sum) {\\n\\tif(root == null) return false;\\n\\tif(root.val == sum && root.right == null && root.left == null) return true;\\n\\tif(root.left != null) root.left.val += root.val;\\n\\tif(root.right != null) root.right.val += root.val;\\n\\treturn hasPathSum(root.left,sum) || hasPathSum(root.right,sum);\\n}"
                    },
                    {
                        "username": "wuhan9087",
                        "content": "What is root node,and its leftchild, rightchild?"
                    },
                    {
                        "username": "heena",
                        "content": "If the tree is empty but the sum is also zero then the function hasPathSum should return true .\\nBut the code is accepted on\\n `if(root==NULL) {\\nreturn false; }`   .I have this doubt that shouldn't this be `if(tree==NULL) return (sum==0);` \\n\\nNote: the code doesnt get accepted with return sum==0 but with return false."
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Python || Easy and Clean Code\\n\\n```\\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if root==None:\\n            return False\\n        \\n        targetSum=targetSum-root.val\\n        \\n        if root.left==None and root.right==None:\\n            return targetSum==0\\n        \\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)\\n        \\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Easy and Clean Rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "noita_verse",
                        "content": "FYI there\\'s a new solutions tab to post your solutions"
                    }
                ]
            },
            {
                "id": 2039961,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2032318,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2020632,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2016841,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2013717,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2008249,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 2003829,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1994356,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1990034,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1972828,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Pretty proud in March April.. I started learn for the first time traversals in trees and now I can approach these types of problems with a good thought what I should do, sometimes I take a peek if isn\\'t working, but wish I was again in my student years to grind this shit non-stop. "
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[1,1,1,1] and target sum 2 is a good test case."
                    },
                    {
                        "username": "TernyavskyIlya",
                        "content": "Where my fail?\\n `def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n        if not root:\\n            return False\\n        def wrap(root, total):\\n            if not root.left and not root.right:\\n                print(total)\\n                if total == targetSum:\\n                    return False\\n            if root.left:\\n                wrap(root.left, total+root.left.val)\\n            if root.right:\\n                wrap(root.right, total+root.right.val)\\n            return True\\n        wrap(root, root.val)\\n`"
                    },
                    {
                        "username": "chahatgupta1060",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "the question has 117 testcases i have passed 99 testcase but my code is break while passing 100 number test case. the question asked you want to check that the binery tree path sum is equal of target sum. \"you should think about decrease the targetsum either think about increment "
                    },
                    {
                        "username": "kush512",
                        "content": "class Solution {\\npublic:\\n\\n    bool solve(TreeNode* root, int targetSum) {\\n        if(root==NULL && targetSum==0) return true;\\n        if(root==NULL) return false;\\n        bool l=hasPathSum(root->left, targetSum-root->val);\\n        bool r=hasPathSum(root->right, targetSum-root->val);\\n        return l || r;\\n    }\\n\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return false; \\n        else return solve(root,targetSum);\\n    }\\n};\\n\\nwhy is it not giving correct answer?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "There is a test case where root=[1,2], and target sum = 1, so it should return true but it expects false, which I can\\'t understand why. This is a weird test case."
                    },
                    {
                        "username": "sjames8888",
                        "content": "That\\u2019s a one sided tree where root 1 has one child 2 and leaf defined as no children nodes so path sum in this case is sum of 2 nodes. You have to include sum of 2 as this has no nodes so sum is 3 in this case "
                    },
                    {
                        "username": "SanjayLakum_011",
                        "content": "testcase 70 has something issue there is expected output is true but while debug my code in visual studio then received correct output but leetcode has something issue"
                    },
                    {
                        "username": "batuczarny",
                        "content": "Why does this code not work? \\nclass Solution:\\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\\n\\n        def check(root, curSum):\\n            if not root:\\n                return False\\n        \\n            if root.left is None and root.right is None and curSum==targetSum:\\n                return True\\n            \\n            left = check(root.left, curSum + root.val)\\n            right = check(root.right, curSum + root.val)\\n            \\n            return left or right\\n\\n        return check(root, 0) \\n\\n        "
                    },
                    {
                        "username": "1valeryvb",
                        "content": "curSum - root.val"
                    },
                    {
                        "username": "sjames8888",
                        "content": "Parsing given array into tree - suggested Java\n\nthe following Java seems to parse correctly.  Probably not best but incase it is useful to somone\n\n```java\nfinal var root = TreeNode.from2(new Integer[]{5,4,8,11,null,13,4,7,2,null,null,null,1});\n```\n\n\n                    5\n                /       \\\n               4         8\n             /         /   \\\n           11        13     4\n           / \\               \\\n          7   2               1\n\n```java\n  public static TreeNode from2(Integer[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n        var ptr = 0;\n        final var root = new TreeNode(arr[ptr++]);\n        final Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n\n        while (ptr < arr.length && !q.isEmpty()) {\n            final var size = q.size();\n            for (var i = 0; i < size; ++i) {\n                final var node = q.remove();\n                ptr = fromConsume(node, ptr, arr, q);\n            }\n        }\n\n        return root;\n    }\n\n    enum Position {\n        Left,\n        Right\n    }\n\n    public static int fromConsume(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q) {\n        if (ptr >= arr.length) return ptr;\n        if (focus == null) return ptr;\n\n        ptr  = fromConsumeOne(focus, ptr, arr,q, Position.Left);\n        if (ptr < arr.length) {\n            ptr  = fromConsumeOne(focus, ptr, arr,q,Position.Right);\n        }\n\n        return ptr;\n    }\n\n    public static TreeNode from(Integer[] arr) {\n        return from2(arr);\n\n    }\n\n    static int fromConsumeOne(TreeNode focus, int ptr, Integer[] arr, Queue<TreeNode> q, Position position) {\n        if (arr[ptr] == null) {\n            ptr++;\n        } else {\n            final var node = new TreeNode(arr[ptr++]);\n            q.add(node);\n            if (position == Position.Left) {\n                focus.left = node;\n            } else {\n                focus.right = node;\n            }\n        }\n        return ptr;\n    } \n```\n"
                    }
                ]
            },
            {
                "id": 1891414,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1875137,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1847826,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1839802,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1833547,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1830752,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1786313,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1757501,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1738580,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1728211,
                "content": [
                    {
                        "username": "divyapbagul",
                        "content": "var hasPathSum = function(root, targetSum) {\\n  root = [1,2,3];\\n  targetSum = 5;\\n    var arr =[];\\n      for(var i = 0;i < root.length;i++){\\n          arr[i] = root[i];\\n        //   console.log(arr);\\n          if(arr.length > 1){\\n              var result = arr[0] + arr[1] ;\\n              var result2 = arr[0] + arr[2] ;\\n                if(result == targetSum){\\n                    console.log(result);\\n                    return true;\\n                    \\n                }else if(result2 == targetSum){\\n                    console.log(result2);\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n             \\n          }\\n      }\\n             \\n          \\n      \\n\\n};\\nhasPathSum([1,2,3],5);"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "thatCoderGirl",
                        "content": "I think there are few incorrect test cases in this question. \\n\\nCase 1: root =[1] , targetSum = 1, expects answer to be true.\\nCase 2: root =[1, 2] , targetSum = 1, expects answer to be false.\\n\\nAre we considering a solution only if it has a root-to-leaf path , or just root as the path also works ? If we are allowing just root also as the answer, then why in case 2, just root is not an answer ?\\n"
                    },
                    {
                        "username": "sujan_mandal",
                        "content": "root = [1,-2,-3,1,3,-2,null,-1]\\ntarget sum = -1\\nhow can this be true?"
                    },
                    {
                        "username": "Ijkeller",
                        "content": "Do we need to construct the tree within the function?  Also, is the input actually an array or is it the root node in a binary tree?"
                    },
                    {
                        "username": "AyushGupta2114",
                        "content": "can somebody tell what is the error in this \\n\\n\\n `\\'class Solution {\\npublic:\\n    long ans=0;\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return false;\\n        return preorder(root,targetSum,ans);\\n    }\\n    bool preorder(TreeNode *root, long targetSum,long ans)\\n    {\\n\\n        if(root!=NULL)\\n        {\\n         ans+=root->val;\\n         cout<<ans<<endl;\\n         if(ans==targetSum)\\n                return true;\\n        preorder(root->left,targetSum,ans);\\n        preorder(root->right,targetSum,ans);\\n        }\\n        return false;\\n    }\\n};.``\\n\\nfor test case 1 getting false\\nbut by cout getting this \\n5\\n9\\n20\\n27\\n22\\n13\\n26\\n17\\n18"
                    },
                    {
                        "username": "ScientificX",
                        "content": "Please why doesnt this code pass all test cases \n\n `your inline code...your inline code...`\n\n `..class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root: return 0\n        ans = False\n        def solve(node, path):\n            nonlocal ans\n            if not node:\n                ans = ans or (sum(path) == targetSum)\n                return\n\n            solve(node.right, path + [node.val])\n            solve(node.left, path + [node.val])\n\n        solve(root, [])\n        return ans.`"
                    },
                    {
                        "username": "sachin2000",
                        "content": "In my first attempt , i cleared 100 test cases but then it got wrong answer in below test case :\n[1,2] \noutput = true;\nexpected output false;\n\nThen I read the question again and found that the sum must be root to leaf not in between .\n\nfor more details find below: \nhttps://leetcode.com/problems/path-sum/submissions/890816375/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/path-sum/solutions/3049936/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "rahulseith",
                        "content": "why A. [1,2] target = 1 : expected is false B.  [1] : target as 1  has expected ans as true.\\nthese two are contradictory"
                    },
                    {
                        "username": "shin_98",
                        "content": "Those are two different situations. As statet in description *A leaf is a node with no children*.\n`[1,2]` - in this situation root with value \"1\" is not a *leaf* because it has left child with value 2. So only path from root to leaf is from 1 to 2. Thus there is only one path with sum 3 = 1 + 2\n3 != 1 (target) so it is expected to be False.\n`[1]` - in this situation root is also a leaf because it has no children. So path from root to leaf has only one step with sum 1\n1 == 1 (target) so it is expected to be True."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Search II",
        "question_content": "<p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>\n\n<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" style=\"width: 322px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]\n<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> is a lowercase English letter.</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are unique.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 59780,
                "title": "java-15ms-easiest-solution-100-00",
                "content": "<h2>Backtracking + Trie</h2>\\n<hr>\\n\\nIntuitively, start from every cell and try to build a word in the dictionary. `Backtracking (dfs)` is the powerful way to exhaust every possible ways. Apparently, we need to do `pruning` when current character is not in any word. \\n\\n1. How do we instantly know the current character is invalid? `HashMap`? \\n2. How do we instantly know what's the next valid character? `LinkedList`?\\n3. But the next character can be chosen from a list of characters. `\"Mutil-LinkedList\"`?\\n\\nCombing them, `Trie` is the natural choice. Notice that:\\n\\n1. `TrieNode` is all we need. `search` and `startsWith` are useless.\\n2. No need to store character at TrieNode. `c.next[i] != null` is enough.\\n3. Never use `c1 + c2 + c3`. Use `StringBuilder`.\\n4. No need to use `O(n^2)` extra space `visited[m][n].` \\n5. No need to use `StringBuilder`. Storing `word` itself at leaf node is enough.\\n6. No need to use `HashSet` to de-duplicate. Use \"one time search\" trie.\\n\\nFor more explanations, check out [dietpepsi's blog][1].\\n\\n<hr>\\n<h2>Code Optimization</h2>\\n<hr>\\n\\nUPDATE: Thanks to @dietpepsi we further improved from `17ms` to `15ms`.\\n\\n1. `59ms`: Use `search` and `startsWith` in Trie class like [this popular solution.][2]\\n2. `33ms`: Remove Trie class which unnecessarily starts from `root` in every `dfs` call. \\n3. `30ms`: Use `w.toCharArray()` instead of `w.charAt(i)`.\\n4. `22ms`: Use `StringBuilder` instead of `c1 + c2 + c3`.\\n5. `20ms`: Remove `StringBuilder` completely by storing `word` instead of `boolean` in TrieNode.\\n6. `20ms`: Remove `visited[m][n]` completely by modifying `board[i][j] = '#'` directly.\\n7. `18ms`: check validity, e.g., `if(i > 0) dfs(...)`, before going to the next `dfs`.\\n8. `17ms`: De-duplicate `c - a` with one variable `i`.\\n9. `15ms`: Remove `HashSet` completely. dietpepsi's idea is awesome. \\n\\nThe final run time is `15ms`. Hope it helps!\\n\\n<hr>\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs (board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == '#' || p.next[c - 'a'] == null) return;\\n        p = p.next[c - 'a'];\\n        if (p.word != null) {   // found one\\n            res.add(p.word);\\n            p.word = null;     // de-duplicate\\n        }\\n\\n        board[i][j] = '#';\\n        if (i > 0) dfs(board, i - 1, j ,p, res); \\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res); \\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); \\n        board[i][j] = c;\\n    }\\n    \\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            TrieNode p = root;\\n            for (char c : w.toCharArray()) {\\n                int i = c - 'a';\\n                if (p.next[i] == null) p.next[i] = new TrieNode();\\n                p = p.next[i];\\n           }\\n           p.word = w;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n\\n\\n  [1]: http://algobox.org/word-search-ii/\\n  [2]: https://leetcode.com/discuss/36337/my-simple-and-clean-java-code-using-dfs-and-trie",
                "solutionTags": [
                    "Java"
                ],
                "code": "<h2>Backtracking + Trie</h2>\\n<hr>\\n\\nIntuitively, start from every cell and try to build a word in the dictionary. `Backtracking (dfs)` is the powerful way to exhaust every possible ways. Apparently, we need to do `pruning` when current character is not in any word. \\n\\n1. How do we instantly know the current character is invalid? `HashMap`? \\n2. How do we instantly know what's the next valid character? `LinkedList`?\\n3. But the next character can be chosen from a list of characters. `\"Mutil-LinkedList\"`?\\n\\nCombing them, `Trie` is the natural choice. Notice that:\\n\\n1. `TrieNode` is all we need. `search` and `startsWith` are useless.\\n2. No need to store character at TrieNode. `c.next[i] != null` is enough.\\n3. Never use `c1 + c2 + c3`. Use `StringBuilder`.\\n4. No need to use `O(n^2)` extra space `visited[m][n].` \\n5. No need to use `StringBuilder`. Storing `word` itself at leaf node is enough.\\n6. No need to use `HashSet` to de-duplicate. Use \"one time search\" trie.\\n\\nFor more explanations, check out [dietpepsi's blog][1].\\n\\n<hr>\\n<h2>Code Optimization</h2>\\n<hr>\\n\\nUPDATE: Thanks to @dietpepsi we further improved from `17ms` to `15ms`.\\n\\n1. `59ms`: Use `search` and `startsWith` in Trie class like [this popular solution.][2]\\n2. `33ms`: Remove Trie class which unnecessarily starts from `root` in every `dfs` call. \\n3. `30ms`: Use `w.toCharArray()` instead of `w.charAt(i)`.\\n4. `22ms`: Use `StringBuilder` instead of `c1 + c2 + c3`.\\n5. `20ms`: Remove `StringBuilder` completely by storing `word` instead of `boolean` in TrieNode.\\n6. `20ms`: Remove `visited[m][n]` completely by modifying `board[i][j] = '#'` directly.\\n7. `18ms`: check validity, e.g., `if(i > 0) dfs(...)`, before going to the next `dfs`.\\n8. `17ms`: De-duplicate `c - a` with one variable `i`.\\n9. `15ms`: Remove `HashSet` completely. dietpepsi's idea is awesome. \\n\\nThe final run time is `15ms`. Hope it helps!\\n\\n<hr>\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs (board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == '#' || p.next[c - 'a'] == null) return;\\n        p = p.next[c - 'a'];\\n        if (p.word != null) {   // found one\\n            res.add(p.word);\\n            p.word = null;     // de-duplicate\\n        }\\n\\n        board[i][j] = '#';\\n        if (i > 0) dfs(board, i - 1, j ,p, res); \\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res); \\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); \\n        board[i][j] = c;\\n    }\\n    \\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            TrieNode p = root;\\n            for (char c : w.toCharArray()) {\\n                int i = c - 'a';\\n                if (p.next[i] == null) p.next[i] = new TrieNode();\\n                p = p.next[i];\\n           }\\n           p.word = w;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n\\n\\n  [1]: http://algobox.org/word-search-ii/\\n  [2]: https://leetcode.com/discuss/36337/my-simple-and-clean-java-code-using-dfs-and-trie",
                "codeTag": "Java"
            },
            {
                "id": 59790,
                "title": "python-dfs-solution-directly-use-trie-implemented",
                "content": "Here is an implementation based on  [Implement Trie][1] in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class Trie():\\n        def __init__(self):\\n            self.root = TrieNode()\\n        \\n        def insert(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n        \\n        def search(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children.get(w)\\n                if not node:\\n                    return False\\n            return node.isWord\\n        \\n    class Solution(object):\\n        def findWords(self, board, words):\\n            res = []\\n            trie = Trie()\\n            node = trie.root\\n            for w in words:\\n                trie.insert(w)\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    self.dfs(board, node, i, j, \"\", res)\\n            return res\\n        \\n        def dfs(self, board, node, i, j, path, res):\\n            if node.isWord:\\n                res.append(path)\\n                node.isWord = False\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\\n                return \\n            tmp = board[i][j]\\n            node = node.children.get(tmp)\\n            if not node:\\n                return \\n            board[i][j] = \"#\"\\n            self.dfs(board, node, i+1, j, path+tmp, res)\\n            self.dfs(board, node, i-1, j, path+tmp, res)\\n            self.dfs(board, node, i, j-1, path+tmp, res)\\n            self.dfs(board, node, i, j+1, path+tmp, res)\\n            board[i][j] = tmp\\n\\n\\n  [1]: https://leetcode.com/problems/implement-trie-prefix-tree/",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "Here is an implementation based on  [Implement Trie][1] in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class Trie():\\n        def __init__(self):\\n            self.root = TrieNode()\\n        \\n        def insert(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n        \\n        def search(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children.get(w)\\n                if not node:\\n                    return False\\n            return node.isWord\\n        \\n    class Solution(object):\\n        def findWords(self, board, words):\\n            res = []\\n            trie = Trie()\\n            node = trie.root\\n            for w in words:\\n                trie.insert(w)\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    self.dfs(board, node, i, j, \"\", res)\\n            return res\\n        \\n        def dfs(self, board, node, i, j, path, res):\\n            if node.isWord:\\n                res.append(path)\\n                node.isWord = False\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\\n                return \\n            tmp = board[i][j]\\n            node = node.children.get(tmp)\\n            if not node:\\n                return \\n            board[i][j] = \"#\"\\n            self.dfs(board, node, i+1, j, path+tmp, res)\\n            self.dfs(board, node, i-1, j, path+tmp, res)\\n            self.dfs(board, node, i, j-1, path+tmp, res)\\n            self.dfs(board, node, i, j+1, path+tmp, res)\\n            board[i][j] = tmp\\n\\n\\n  [1]: https://leetcode.com/problems/implement-trie-prefix-tree/",
                "codeTag": "Java"
            },
            {
                "id": 59841,
                "title": "my-ac-very-clean-c-code",
                "content": "The idea is start from every position of the board, and then see if we can find a word starting from this position with checking if is_end is true in TrieNode structure\\n\\n    class TrieNode{\\n    public:\\n        bool is_end;\\n        vector<TrieNode*> children;\\n        TrieNode(){\\n            is_end=false;\\n            children=vector<TrieNode*>(26, NULL);\\n        }   \\n    };\\n    \\n    class Trie{\\n    public:\\n        TrieNode* getRoot(){return root;}\\n        Trie(vector<string>& words){\\n            root=new TrieNode();\\n            for(int i=0; i<words.size(); ++i)\\n                addWord(words[i]);\\n        }\\n        void addWord(const string& word){\\n            TrieNode* cur=root;\\n            for(int i=0; i<word.size(); ++i){\\n                int index=word[i]-'a';\\n                if(cur->children[index]==NULL)   \\n                   cur->children[index]=new TrieNode();\\n                cur=cur->children[index];    \\n            }\\n            cur->is_end=true;\\n        }\\n    private:\\n        TrieNode* root;\\n    };\\n    \\n    class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie* trie = new Trie(words);\\n            TrieNode* root=trie->getRoot();\\n            set<string> result_set;\\n            for(int x=0; x<board.size(); ++x)\\n                for(int y=0; y<board[0].size(); ++y)\\n                    findWords(board, x, y, root, \"\", result_set);\\n            \\n            vector<string> result;\\n            for(auto it:result_set)    result.push_back(it);\\n            return result;        \\n        }\\n    private:\\n        void findWords(vector<vector<char>>& board, int x, int y, TrieNode* root, string word, set<string>& result){\\n            if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;\\n            \\n            if(root->children[board[x][y]-'a'] != NULL){\\n                word=word+board[x][y];\\n                root=root->children[board[x][y]-'a']; \\n                if(root->is_end) result.insert(word);\\n                char c=board[x][y];\\n                board[x][y]=' ';\\n                findWords(board, x+1, y, root, word, result);\\n                findWords(board, x-1, y, root, word, result);\\n                findWords(board, x, y+1, root, word, result);\\n                findWords(board, x, y-1, root, word, result);\\n                board[x][y]=c;        \\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie* trie = new Trie(words);\\n            TrieNode* root=trie->getRoot();\\n            set<string> result_set;\\n            for(int x=0; x<board.size(); ++x)\\n                for(int y=0; y<board[0].size(); ++y)\\n                    findWords(board, x, y, root, \"\", result_set);\\n            \\n            vector<string> result;\\n            for(auto it:result_set)    result.push_back(it);\\n            return result;        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 59784,
                "title": "my-simple-and-clean-java-code-using-dfs-and-trie",
                "content": "Compared with [Word Search][1], I make my DFS with a tire but a word. The Trie is formed by all the words in given *words*. Then during the DFS, for each current formed word, I check if it is in the Trie.\\n\\n    public class Solution {\\n        Set<String> res = new HashSet<String>();\\n        \\n        public List<String> findWords(char[][] board, String[] words) {\\n            Trie trie = new Trie();\\n            for (String word : words) {\\n                trie.insert(word);\\n            }\\n            \\n            int m = board.length;\\n            int n = board[0].length;\\n            boolean[][] visited = new boolean[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dfs(board, visited, \"\", i, j, trie);\\n                }\\n            }\\n            \\n            return new ArrayList<String>(res);\\n        }\\n        \\n        public void dfs(char[][] board, boolean[][] visited, String str, int x, int y, Trie trie) {\\n            if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n            if (visited[x][y]) return;\\n            \\n            str += board[x][y];\\n            if (!trie.startsWith(str)) return;\\n            \\n            if (trie.search(str)) {\\n                res.add(str);\\n            }\\n            \\n            visited[x][y] = true;\\n            dfs(board, visited, str, x - 1, y, trie);\\n            dfs(board, visited, str, x + 1, y, trie);\\n            dfs(board, visited, str, x, y - 1, trie);\\n            dfs(board, visited, str, x, y + 1, trie);\\n            visited[x][y] = false;\\n        }\\n    }\\n \\n\\n  [1]: https://leetcode.com/problems/word-search/",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n        Set<String> res = new HashSet<String>();\\n        \\n        public List<String> findWords(char[][] board, String[] words) {\\n            Trie trie = new Trie();\\n            for (String word : words) {\\n                trie.insert(word);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 712733,
                "title": "python-trie-solution-with-dfs-explained",
                "content": "One of the efficient ways to solve this problem is to use **Trie**. For more details please look https://en.wikipedia.org/wiki/Trie. In two words, it is a special data structure, similar to trees, but which has letters inside and used to quick search of patterns in strings. For implementation of Trie, please visit problem **208. Implement Trie** (however I put my code here as well)\\n\\nOutline of algorithm:\\n1. For each `word` in our `words` insert it in our Trie.\\n2. Starting with each symbol in our board, start `dfs` (backtracking) which are looking for words in our Trie.\\n\\n**Variables**: \\n`self.num_words` is total number of words we still need to find, in the beginning it is equal to total number of words. \\n`res` is our result, where we keep found words. \\n`trie` is our trie.\\n\\nNow, how our `dfs(self, board, node, i, j, path, res)` works?\\n\\n0. `board` is our original board, `node` is current node of `trie`, `i` and `j` are current coordinates we are it, `path` is word build so far and `res` is global variable for found words.\\n1. First, we check if we still need to look for words, if not, return\\n2. Check if the node we are in currently is **end_node**: it means, that some word was found! We add it to our `res`, mark `node.end_node` as False (we do not want to search it once again) and decrease number of words we still need to find by `1`.\\n3. If we out of border or we inside border, but we can not traverse our `trie` we again do nothing.\\n4. Now, we mark `(i,j)` position in our board as visited: `#`, call our dfs for all neibours, and then restore value ofr `(i,j)` position. (the reason is in pyton if we give list as parameter of recursive method, it will deal as global variable, so we need to fix it when we returned from our recursion).\\n\\n**Complexity**. This is difficult question, space complexity is needed to keep our `trie`, which is `O(k)`, where `k` is sum of length of all words. Time complexity is `O(mn*3^T)`, where `m` and `n` are sizes of our board and `T` is the length of the longest word in `words`. Why? Because we start our `dfs` from all points of our board and do not stop until we make sure that the longest word is checked: if we are not lucky and this word can not be found on board we need to check potentialy to the length `T`. Why `3^T`? Because each time we can choose one of three directions, except the one we came from.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end_node = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass Solution:\\n    def findWords(self, board, words):\\n        self.num_words = len(words)\\n        res, trie = [], Trie()\\n        for word in words: trie.insert(word) \\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(board, trie.root, i, j, \"\", res)\\n        return res\\n\\n    def dfs(self, board, node, i, j, path, res):\\n        if self.num_words == 0: return\\n\\n        if node.end_node:\\n            res.append(path)\\n            node.end_node = False\\n            self.num_words -= 1\\n\\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return \\n        tmp = board[i][j]\\n        if tmp not in node.children: return\\n\\n        board[i][j] = \"#\"\\n        for x,y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n            self.dfs(board, node.children[tmp], i+x, j+y, path+tmp, res)\\n        board[i][j] = tmp\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end_node = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass Solution:\\n    def findWords(self, board, words):\\n        self.num_words = len(words)\\n        res, trie = [], Trie()\\n        for word in words: trie.insert(word) \\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(board, trie.root, i, j, \"\", res)\\n        return res\\n\\n    def dfs(self, board, node, i, j, path, res):\\n        if self.num_words == 0: return\\n\\n        if node.end_node:\\n            res.append(path)\\n            node.end_node = False\\n            self.num_words -= 1\\n\\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return \\n        tmp = board[i][j]\\n        if tmp not in node.children: return\\n\\n        board[i][j] = \"#\"\\n        for x,y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n            self.dfs(board, node.children[tmp], i+x, j+y, path+tmp, res)\\n        board[i][j] = tmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878708,
                "title": "c-python-backtracking-with-trie-clean-concise",
                "content": "**Idea**\\n- Just backtracking to try all possible paths in the board.\\n- To check if the current path exists any word, we can build Trie structure, which can prune early when the current path is not a prefix of any words in our Trie.\\n- Check basic implemetation of Trie Structure under **[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/1509720)**\\n\\n<iframe src=\"https://leetcode.com/playground/UviFN7ns/shared\" frameBorder=\"0\" width=\"100%\" height=\"810\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N * 4 * 3^(L-2) + S)`, where `M*N <= 12*12` is total number of cells in the board, `L <= 10` is the maximum length of words, `S <= 3 * 10^5` is sum length of all words.\\n   Explain: Firstly, we can choose `M*N` cells of the board as starting position, we have `4` choices to go neighbors of the first cell, each of neighbors have total `3` choices to go to their neighbors (exclude their previous neighbor) and so on.\\n![image](https://assets.leetcode.com/users/images/25730536-a35a-469b-94a3-77e24f8e5de6_1601824879.6308603.png)\\n\\n- Space: `O(S)`\\n  Explain: The main space consumed by the algorithm is the Trie data structure we build. In the worst case where there is no overlapping of prefixes among the words, the Trie would have as many nodes as the letters of all words.",
                "solutionTags": [],
                "code": "**Idea**\\n- Just backtracking to try all possible paths in the board.\\n- To check if the current path exists any word, we can build Trie structure, which can prune early when the current path is not a prefix of any words in our Trie.\\n- Check basic implemetation of Trie Structure under **[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/1509720)**\\n\\n<iframe src=\"https://leetcode.com/playground/UviFN7ns/shared\" frameBorder=\"0\" width=\"100%\" height=\"810\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N * 4 * 3^(L-2) + S)`, where `M*N <= 12*12` is total number of cells in the board, `L <= 10` is the maximum length of words, `S <= 3 * 10^5` is sum length of all words.\\n   Explain: Firstly, we can choose `M*N` cells of the board as starting position, we have `4` choices to go neighbors of the first cell, each of neighbors have total `3` choices to go to their neighbors (exclude their previous neighbor) and so on.\\n![image](https://assets.leetcode.com/users/images/25730536-a35a-469b-94a3-77e24f8e5de6_1601824879.6308603.png)\\n\\n- Space: `O(S)`\\n  Explain: The main space consumed by the algorithm is the Trie data structure we build. In the worst case where there is no overlapping of prefixes among the words, the Trie would have as many nodes as the letters of all words.",
                "codeTag": "Unknown"
            },
            {
                "id": 59804,
                "title": "27-lines-uses-complex-numbers",
                "content": "I first build the tree of words with root `root` and also represent the board a different way, namely as one-dimensional dictionary where the keys are complex numbers representing the row/column indexes. That makes further work with it easier. Looping over all board positions is just `for z in board`, the four neighbors of a board position z are just `z + 1j**k` (for k in 0 to 3), and I don't need to check borders because `board.get` just returns \"None\" if I request an invalid position.\\n\\nAfter this preparation, I just take the tree and recursively dive with it into each board position. Similar to how you'd search a single word, but with the tree instead.\\n\\n    class Solution:\\n        def findWords(self, board, words):\\n    \\n            root = {}\\n            for word in words:\\n                node = root\\n                for c in word:\\n                    node = node.setdefault(c, {})\\n                node[None] = True\\n            board = {i + 1j*j: c\\n                     for i, row in enumerate(board)\\n                     for j, c in enumerate(row)}\\n    \\n            found = []\\n            def search(node, z, word):\\n                if node.pop(None, None):\\n                    found.append(word)\\n                c = board.get(z)\\n                if c in node:\\n                    board[z] = None\\n                    for k in range(4):\\n                        search(node[c], z + 1j**k, word + c)\\n                    board[z] = c\\n            for z in board:\\n                search(root, z, '')\\n    \\n            return found",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        def findWords(self, board, words):\\n    \\n            root = {}",
                "codeTag": "Java"
            },
            {
                "id": 59864,
                "title": "python-code-use-trie-and-dfs",
                "content": "```python\\nclass Solution:\\n    # @param {character[][]} board\\n    # @param {string[]} words\\n    # @return {string[]}\\n    def findWords(self, board, words):\\n        #make trie\\n        count = Counter()\\n        for l in board:\\n            count += Counter(l)\\n        trie={}\\n        for w in words:\\n            wc = Counter(w)\\n            for c in wc:\\n\\t\\t\\t\\t# optimization, ignore word if there isn\\'t enough c in board\\n                if wc[c] > count[c]:\\n                    continue\\n            t=trie\\n            for c in w:\\n                if c not in t:\\n                    t[c]={}\\n                t=t[c]\\n            t[\\'#\\']=\\'#\\'\\n        self.res=[]\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.find(board,i,j,trie,[])\\n        return self.res\\n    \\n    def find(self,board,i,j,trie,pre):\\n        if \\'#\\' in trie:\\n\\t\\t\\t# optimization, delete for avoiding duplicated matches\\n            del trie[\"#\"]\\n            self.res.append(\\'\\'.join(pre))\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]):\\n            return\\n        if board[i][j] in trie:\\n            tmp = board[i][j]\\n            board[i][j] = \\'$\\'\\n            pre.append(tmp)\\n            self.find(board,i+1,j,trie[tmp],pre)\\n            self.find(board,i,j+1,trie[tmp],pre)\\n            self.find(board,i-1,j,trie[tmp],pre)\\n            self.find(board,i,j-1,trie[tmp],pre)\\n            board[i][j] = tmp\\n            pre.pop()\\n            if not trie[board[i][j]]:\\n\\t\\t\\t\\t# nothing in trie[board[i][j]] because of matched before, delete node for optimization\\n                del trie[board[i][j]]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    # @param {character[][]} board\\n    # @param {string[]} words\\n    # @return {string[]}\\n    def findWords(self, board, words):\\n        #make trie\\n        count = Counter()\\n        for l in board:\\n            count += Counter(l)\\n        trie={}\\n        for w in words:\\n            wc = Counter(w)\\n            for c in wc:\\n\\t\\t\\t\\t# optimization, ignore word if there isn\\'t enough c in board\\n                if wc[c] > count[c]:\\n                    continue\\n            t=trie\\n            for c in w:\\n                if c not in t:\\n                    t[c]={}\\n                t=t[c]\\n            t[\\'#\\']=\\'#\\'\\n        self.res=[]\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.find(board,i,j,trie,[])\\n        return self.res\\n    \\n    def find(self,board,i,j,trie,pre):\\n        if \\'#\\' in trie:\\n\\t\\t\\t# optimization, delete for avoiding duplicated matches\\n            del trie[\"#\"]\\n            self.res.append(\\'\\'.join(pre))\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]):\\n            return\\n        if board[i][j] in trie:\\n            tmp = board[i][j]\\n            board[i][j] = \\'$\\'\\n            pre.append(tmp)\\n            self.find(board,i+1,j,trie[tmp],pre)\\n            self.find(board,i,j+1,trie[tmp],pre)\\n            self.find(board,i-1,j,trie[tmp],pre)\\n            self.find(board,i,j-1,trie[tmp],pre)\\n            board[i][j] = tmp\\n            pre.pop()\\n            if not trie[board[i][j]]:\\n\\t\\t\\t\\t# nothing in trie[board[i][j]] because of matched before, delete node for optimization\\n                del trie[board[i][j]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262396,
                "title": "c-trie-solution-99-62-faster",
                "content": "C++ implementation in this [post](https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00))\\n```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138279,
                "title": "clean-javascript-solution",
                "content": "```js\\nconst findWords = (board, words) => {\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n  let res = [];\\n\\n  const buildTrie = () => {\\n    const root = {};\\n    for (const w of words) {\\n      let node = root;\\n      for (const c of w) {\\n        if (node[c] == null) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    return root;\\n  };\\n\\n  const search = (node, x, y) => {\\n    if (node.word != null) {\\n      res.push(node.word);\\n      node.word = null; // make sure only print one time for each word\\n    }\\n\\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n    if (node[board[x][y]] == null) return;\\n\\n    const c = board[x][y];\\n    board[x][y] = \\'#\\'; // Mark visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      search(node[c], i, j);\\n    }\\n    board[x][y] = c; // Reset\\n  };\\n\\n  const root = buildTrie();\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      search(root, i, j);\\n    }\\n  }\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```js\\nconst findWords = (board, words) => {\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n  let res = [];\\n\\n  const buildTrie = () => {\\n    const root = {};\\n    for (const w of words) {\\n      let node = root;\\n      for (const c of w) {\\n        if (node[c] == null) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    return root;\\n  };\\n\\n  const search = (node, x, y) => {\\n    if (node.word != null) {\\n      res.push(node.word);\\n      node.word = null; // make sure only print one time for each word\\n    }\\n\\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n    if (node[board[x][y]] == null) return;\\n\\n    const c = board[x][y];\\n    board[x][y] = \\'#\\'; // Mark visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      search(node[c], i, j);\\n    }\\n    board[x][y] = c; // Reset\\n  };\\n\\n  const root = buildTrie();\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      search(root, i, j);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512202,
                "title": "c-trie-dfs-o-m-n-4-length-of-largest-word-time-complexity",
                "content": "**TIME COMPLEXITY EXPLANATION**\\nFor single word search in a 2d matrix in [WORD SEARCH 1](https://leetcode.com/problems/word-search/discuss/1512539/c-dfs-backtracking-nm4size_of_word-time) problem we apply dfs at every point of matrix for that we run 2 for loops and their time complexity is m\\xD7n and in each dfs we visit 4^(sizeofword) because we are applying dfs calls to 4 directions for each character of the given word , so the time complexity for that will be m\\xD7n\\xD74^(sizeofword).Now coming to this problem, if we dont use Trie we will use the code of word search 1 problem but we will run 1 more for loop for each word in words array , so the time complexity of that would be no_of_word\\xD7(m\\xD7n\\xD74^(sum_of_lengths_of_all_words)) .Here, we are using trie because of that we dont need to run the extra for loop for each word due to which time complexity drops to m\\xD7n\\xD74^(length_of_largest_word) where length_of_largest_word is the height of the trie.\\nlink to [WORD SEARCH 1 PROBLEM SOLUTION](https://leetcode.com/problems/word-search/discuss/1512539/c-dfs-backtracking-nm4size_of_word-time) \\n\\n**CODE-**\\n```\\nclass Trie{\\npublic:\\n    string word;\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\n\\nclass Solution {\\nprivate:   \\n    Trie* root=NULL;\\n    \\n    void insert(string &s){\\n        Trie* temp=root;\\n        for(auto &i:s){\\n            int k=i-\\'a\\';\\n            if(temp->children[k]==NULL){\\n                temp->children[k]=new Trie;\\n            }\\n            temp=temp->children[k];\\n        }\\n        temp->word=s;\\n        temp->is_word=true;\\n    }\\n    \\n    void dfs(vector<vector<char>>&board, vector<string>&res, Trie* temp, int i, int j){\\n\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]==\\'*\\' || !(temp->children[board[i][j]-\\'a\\']))\\n            return;\\n        \\n        temp=temp->children[board[i][j]-\\'a\\'];\\n        \\n        if(temp->is_word){\\n            res.push_back(temp->word);\\n            temp->is_word=false;\\n        }\\n        \\n        char temp_char = board[i][j];\\n        board[i][j]=\\'*\\';\\n        \\n        dfs(board, res, temp, i+1, j);\\n        dfs(board, res, temp, i, j+1);\\n        dfs(board, res, temp, i-1, j);\\n        dfs(board, res, temp, i, j-1);\\n        \\n        board[i][j]=temp_char;\\n        \\n        return;\\n    }\\n    \\npublic:\\n    Solution(){\\n        root=new Trie;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto &s:words)\\n            insert(s);\\n        vector<string>res;\\n        Trie* temp=root;\\n        \\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[0].size();j++)\\n                dfs(board, res, temp, i, j);\\n        \\n        return res;\\n    }\\n    \\n/*--------destructor not neccesary-----------\\n    ~Solution(){                      \\n        clear_nodes(root);\\n    }\\n    \\n    void clear_nodes(Trie* root) //\\n    {\\n        for(int i = 0; i<26; i++)\\n            if(root->children[i] != NULL)\\n                clear_nodes(root->children[i]);\\n        delete root;\\n    }\\n-------------------------------------------*/\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Trie{\\npublic:\\n    string word;\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\n\\nclass Solution {\\nprivate:   \\n    Trie* root=NULL;\\n    \\n    void insert(string &s){\\n        Trie* temp=root;\\n        for(auto &i:s){\\n            int k=i-\\'a\\';\\n            if(temp->children[k]==NULL){\\n                temp->children[k]=new Trie;\\n            }\\n            temp=temp->children[k];\\n        }\\n        temp->word=s;\\n        temp->is_word=true;\\n    }\\n    \\n    void dfs(vector<vector<char>>&board, vector<string>&res, Trie* temp, int i, int j){\\n\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]==\\'*\\' || !(temp->children[board[i][j]-\\'a\\']))\\n            return;\\n        \\n        temp=temp->children[board[i][j]-\\'a\\'];\\n        \\n        if(temp->is_word){\\n            res.push_back(temp->word);\\n            temp->is_word=false;\\n        }\\n        \\n        char temp_char = board[i][j];\\n        board[i][j]=\\'*\\';\\n        \\n        dfs(board, res, temp, i+1, j);\\n        dfs(board, res, temp, i, j+1);\\n        dfs(board, res, temp, i-1, j);\\n        dfs(board, res, temp, i, j-1);\\n        \\n        board[i][j]=temp_char;\\n        \\n        return;\\n    }\\n    \\npublic:\\n    Solution(){\\n        root=new Trie;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto &s:words)\\n            insert(s);\\n        vector<string>res;\\n        Trie* temp=root;\\n        \\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[0].size();j++)\\n                dfs(board, res, temp, i, j);\\n        \\n        return res;\\n    }\\n    \\n/*--------destructor not neccesary-----------\\n    ~Solution(){                      \\n        clear_nodes(root);\\n    }\\n    \\n    void clear_nodes(Trie* root) //\\n    {\\n        for(int i = 0; i<26; i++)\\n            if(root->children[i] != NULL)\\n                clear_nodes(root->children[i]);\\n        delete root;\\n    }\\n-------------------------------------------*/\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59881,
                "title": "my-java-solution-using-trie",
                "content": "    public class Solution {\\n        public class TrieNode{\\n            public boolean isWord = false;\\n            public TrieNode[] child = new TrieNode[26];\\n            public TrieNode(){\\n                \\n            }\\n        }\\n        \\n        TrieNode root = new TrieNode();\\n        boolean[][] flag;\\n        public List<String> findWords(char[][] board, String[] words) {\\n            Set<String> result = new HashSet<>();\\n            flag = new boolean[board.length][board[0].length];\\n            \\n            addToTrie(words);\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[0].length; j++){\\n                    if(root.child[board[i][j] - 'a'] != null){\\n                        search(board, i, j, root, \"\", result);\\n                    }\\n                }\\n            }\\n            \\n            return new LinkedList<>(result);\\n        }\\n        \\n        private void addToTrie(String[] words){\\n            for(String word: words){\\n                TrieNode node = root;\\n                for(int i = 0; i < word.length(); i++){\\n                    char ch = word.charAt(i);\\n                    if(node.child[ch - 'a'] == null){\\n                        node.child[ch - 'a'] = new TrieNode();\\n                    }\\n                    node = node.child[ch - 'a'];\\n                }\\n                node.isWord = true;\\n            }\\n        }\\n        \\n        private void search(char[][] board, int i, int j, TrieNode node, String word, Set<String> result){\\n            if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || flag[i][j]){\\n                return;\\n            }\\n            \\n            if(node.child[board[i][j] - 'a'] == null){\\n                return;\\n            }\\n            \\n            flag[i][j] = true;\\n            node = node.child[board[i][j] - 'a'];\\n            if(node.isWord){\\n                result.add(word + board[i][j]);\\n            }\\n            \\n            search(board, i-1, j, node, word + board[i][j], result);\\n            search(board, i+1, j, node, word + board[i][j], result);\\n            search(board, i, j-1, node, word + board[i][j], result);\\n            search(board, i, j+1, node, word + board[i][j], result);\\n            \\n            flag[i][j] = false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public class TrieNode{\\n            public boolean isWord = false;\\n            public TrieNode[] child = new TrieNode[26];\\n            public TrieNode(){\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2779789,
                "title": "python-c-dfs-using-trie-with-removal-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a Depth First Search approach using trie (with removal of words) for fast querying of prefixes that allows pruning of invalid paths. \\n\\n**Python.**\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        trie = Trie(words)                   # trie is initialized with a list of words\\n        seen = set()                         # found words are being collected into a set\\n                \\n        # generator that yields (!) adjacent cells\\n        def adj(x, y):\\n            for i,j in [(0,-1),(0,1),(-1,0),(1,0)]:\\n                if 0 <= x+i < m and 0 <= y+j < n:\\n                    yield (x+i,y+j)\\n        \\n        # DFS search with prefix \\'p\\', last cell (x,y) on board \\'b\\'\\n        def dfs(p, b, x, y):          \\n            \\n            ch, b[x][y] = b[x][y], \"#\"        # [1] mark used cell and save board state\\n            \\n            if trie.search(p):               \\n                seen.add(p)                   # [2] mark word as found and\\n                trie.remove(p)                #     no longer search for it\\n\\n            for i,j in adj(x, y):             # [3] iterate over adjacent cells\\n                if b[i][j] != \"#\":            #     which are still unused\\n                    pp = p + b[i][j]          #     and extend the word\\n                    if trie.starts(pp):       # [4] if the prefix exists in the trie,\\n                        dfs(pp, b, i, j)      #     we should check this branch\\n            \\n            b[x][y] = ch                      # [5] restore board state\\n        \\n        for i in range(m):                    # DFS procedure is initialized starting\\n            for j in range(n):                # from all possible cells (i,j)\\n                dfs(board[i][j], board, i, j)\\n        \\n        return seen\\n```\\nThe trie data structure is implemented using set/dict. It allows to search/remove words and to query prefixes.\\n```\\nclass Trie:\\n    def __init__(self, words=[]):\\n        self.trie = {}\\n        for w in words: self.insert(w)\\n\\n    def insert(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                t[w] = {}\\n            t = t[w]\\n        t[\\'#\\'] = \\'#\\'\\n\\n    def search(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        if \\'#\\' in t:\\n            return True\\n        return False\\n\\n    def starts(self, prefix):\\n        t = self.trie\\n        for w in prefix:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        return True\\n    \\n    def remove(self, word):\\n        t = self.trie\\n        nodes = []\\n        for w in word:\\n            if w not in t: return\\n            t = t[w]\\n            nodes.append((t,w))\\n\\n        if \\'#\\' in t:\\n            p = \\'#\\'\\n            for n,w in nodes[::-1]:\\n                if len(n[p]) == 0 or p == \\'#\\' : del n[p]\\n                p = w                \\n```\\n\\nHere is the same algorithm in other languages (C++ for now).\\n<iframe src=\"https://leetcode.com/playground/XfPDMsKZ/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        trie = Trie(words)                   # trie is initialized with a list of words\\n        seen = set()                         # found words are being collected into a set\\n                \\n        # generator that yields (!) adjacent cells\\n        def adj(x, y):\\n            for i,j in [(0,-1),(0,1),(-1,0),(1,0)]:\\n                if 0 <= x+i < m and 0 <= y+j < n:\\n                    yield (x+i,y+j)\\n        \\n        # DFS search with prefix \\'p\\', last cell (x,y) on board \\'b\\'\\n        def dfs(p, b, x, y):          \\n            \\n            ch, b[x][y] = b[x][y], \"#\"        # [1] mark used cell and save board state\\n            \\n            if trie.search(p):               \\n                seen.add(p)                   # [2] mark word as found and\\n                trie.remove(p)                #     no longer search for it\\n\\n            for i,j in adj(x, y):             # [3] iterate over adjacent cells\\n                if b[i][j] != \"#\":            #     which are still unused\\n                    pp = p + b[i][j]          #     and extend the word\\n                    if trie.starts(pp):       # [4] if the prefix exists in the trie,\\n                        dfs(pp, b, i, j)      #     we should check this branch\\n            \\n            b[x][y] = ch                      # [5] restore board state\\n        \\n        for i in range(m):                    # DFS procedure is initialized starting\\n            for j in range(n):                # from all possible cells (i,j)\\n                dfs(board[i][j], board, i, j)\\n        \\n        return seen\\n```\n```\\nclass Trie:\\n    def __init__(self, words=[]):\\n        self.trie = {}\\n        for w in words: self.insert(w)\\n\\n    def insert(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                t[w] = {}\\n            t = t[w]\\n        t[\\'#\\'] = \\'#\\'\\n\\n    def search(self, word):\\n        t = self.trie\\n        for w in word:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        if \\'#\\' in t:\\n            return True\\n        return False\\n\\n    def starts(self, prefix):\\n        t = self.trie\\n        for w in prefix:\\n            if w not in t:\\n                return False\\n            t = t[w]\\n        return True\\n    \\n    def remove(self, word):\\n        t = self.trie\\n        nodes = []\\n        for w in word:\\n            if w not in t: return\\n            t = t[w]\\n            nodes.append((t,w))\\n\\n        if \\'#\\' in t:\\n            p = \\'#\\'\\n            for n,w in nodes[::-1]:\\n                if len(n[p]) == 0 or p == \\'#\\' : del n[p]\\n                p = w                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59836,
                "title": "my-c-trie-backtrace-based-solution-48-ms",
                "content": "The idea is to use a Trie to build a prefix tree for words to simplify the search and do DFS to search all the possible strings. \\nFor Trie, 26 pointers to point the sub-strings and a bool leaf to indicate whether the current node is a leaf (i.e. a string in words) and also idx is used to save the index of words for the current node.\\nFor DFS, just check if the current position is visited before (board[i][j]=='X'), if so, return, check if there is a string with such prefix (nullptr == root->children[words[idx][pos]-'a']), if not, return; otherwise, check if the current searched string is a leaf of the trie (a string in words), if so, save it to res and set leaf of the trie node to false to indicate such string is already found. At last, move to its neighbors to continue the search. Remember to recover the char [i][j] at the end.    \\n\\n        class Solution {\\n            class Trie{\\n            public:\\n                Trie *children[26]; // pointers to its substrings starting with 'a' to 'z'\\n                bool leaf; // if the node is a leaf, or if there is a word stopping at here\\n                int idx; // if it is a leaf, the string index of the array words\\n                Trie()\\n                {\\n                    this->leaf = false;\\n                    this->idx = 0;\\n                    fill_n(this->children, 26, nullptr);            \\n                }\\n            };\\n            \\n        public:\\n            void insertWords(Trie *root, vector<string>& words, int idx)\\n            {\\n                int pos = 0, len = words[idx].size();\\n                while(pos<len)\\n                {\\n                    if(nullptr == root->children[words[idx][pos]-'a']) root->children[words[idx][pos]-'a'] = new Trie();\\n                    root = root->children[words[idx][pos++]-'a'];\\n                }\\n                root->leaf = true;\\n                root->idx = idx;\\n            }\\n            \\n            Trie *buildTrie(vector<string>& words)\\n            {\\n                Trie *root = new Trie(); \\n                int i;\\n                for(i=0; i<words.size();i++) insertWords(root, words, i);\\n                return root;\\n            }\\n            \\n            void checkWords(vector<vector<char>>& board, int i, int j, int row, int col, Trie *root, vector<string> &res, vector<string>& words)\\n            {\\n                char temp;\\n                if(board[i][j]=='X') return; // visited before;\\n                if(nullptr == root->children[board[i][j]-'a']) return ; // no string with such prefix\\n                else\\n                {\\n                    temp = board[i][j];\\n                    if(root->children[temp-'a']->leaf)  // if it is a leaf\\n                    {\\n                        res.push_back(words[root->children[temp-'a']->idx]);\\n                        root->children[temp-'a']->leaf = false; // set to false to indicate that we found it already\\n                    }\\n                    board[i][j]='X'; //mark the current position as visited\\n    // check all the possible neighbors\\n                    if(i>0) checkWords(board, i-1, j, row, col, root->children[temp-'a'], res, words);\\n                    if((i+1)<row) checkWords(board, i+1, j, row, col,  root->children[temp-'a'], res, words);\\n                    if(j>0) checkWords(board, i, j-1,  row, col, root->children[temp-'a'], res, words);\\n                    if((j+1)<col)  checkWords(board, i, j+1,  row, col, root->children[temp-'a'], res, words);\\n                    board[i][j] = temp; // recover the current position\\n                }\\n            }\\n        \\n            vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n               vector<string> res;\\n               int row = board.size();\\n               if(0==row) return res;\\n               int col = board[0].size();\\n               if(0==col) return res;\\n               int wordCount = words.size();\\n               if(0==wordCount) return res;\\n               \\n               Trie *root = buildTrie(words);\\n               \\n               int i,j;\\n               for(i =0 ; i<row; i++)\\n               {\\n                   for(j=0; j<col && wordCount > res.size(); j++)\\n                   {\\n                       checkWords(board, i, j, row, col, root, res, words);\\n                   }\\n               }\\n               return res;\\n            }\\n     };\\n\\nBased on the comments received. I created another version with Trie node counter (thanks,   zhiqing_xiao and gxyeecspku). However, for the current test set, it doesn't help too much. Anyway, my version with Trie node counter.\\n\\n    class Solution {\\n    private:\\n    class Trie\\n    {\\n    public:    \\n        Trie * children[26];\\n        bool isLeaf;\\n        int  wordIdx;\\n        int prefixCount;\\n        \\n        Trie()\\n        {\\n            isLeaf = false;\\n            wordIdx = 0;\\n            prefixCount = 0;\\n            fill_n(children, 26, nullptr);\\n        }\\n        \\n        ~Trie()\\n        {\\n            for(auto i=0; i<26; ++i) delete children[i];\\n        }\\n    };\\n        void insertWord(Trie *root,  const vector<string>& words, int idx)\\n        {\\n            int i, childID, len = words[idx].size();\\n            for(i=0, root->prefixCount++ ; i<len; ++i)\\n            {\\n                childID = words[idx][i]-'a';\\n                if(!root->children[childID]) root->children[childID] = new Trie();\\n                root = root->children[childID];\\n                ++root->prefixCount;\\n            }\\n            root->isLeaf = true; \\n            root->wordIdx = idx;\\n        }\\n        \\n        Trie *buildTrie(const vector<string> &words)\\n        {\\n            Trie *root = new Trie();\\n            for(int i=0; i < words.size(); ++i) insertWord(root, words, i);\\n            return root;\\n        }\\n        \\n        int dfs_Trie(vector<string> &res, Trie *root, vector<vector<char>>& board, vector<string>& words, int row, int col)\\n        {\\n            int detected = 0;\\n    \\n            if(root->isLeaf)\\n            {\\n                ++detected;\\n                root->isLeaf = false;\\n                res.push_back(words[root->wordIdx]);\\n            }\\n            \\n            if( row<0 || row>=board.size() || col<0 || col>=board[0].size() || board[row][col]=='*' || !root->children[ board[row][col]-'a'] || root->children[ board[row][col]-'a']->prefixCount <= 0 ) return detected;\\n            int curC = board[row][col] - 'a';\\n            board[row][col] = '*';\\n            detected += dfs_Trie(res, root->children[curC], board, words, row-1, col) + \\n                   dfs_Trie(res, root->children[curC], board, words, row+1, col) +    \\n                   dfs_Trie(res, root->children[curC], board, words, row, col - 1) +    \\n                   dfs_Trie(res, root->children[curC], board, words, row, col + 1) ;\\n            root->prefixCount -=detected;\\n            board[row][col] = curC+'a';\\n            return detected;\\n        }\\n        \\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            int M, N, wordNum = words.size();\\n            vector<string> res;\\n            if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res;\\n            Trie *root = buildTrie(words);\\n            for(auto i=0; i<M && root->prefixCount; ++i)\\n                for(auto j=0; j<N; ++j)\\n                    dfs_Trie(res, root, board, words, i, j);\\n            delete root;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n            class Trie{\\n            public:\\n                Trie *children[26]; // pointers to its substrings starting with 'a' to 'z'\\n                bool leaf; // if the node is a leaf, or if there is a word stopping at here\\n                int idx; // if it is a leaf, the string index of the array words\\n                Trie()\\n                {\\n                    this->leaf = false;\\n                    this->idx = 0;\\n                    fill_n(this->children, 26, nullptr);            \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2779665,
                "title": "python-using-tries",
                "content": "If you like, please up vote\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.refs = 0\\n\\n    def addWord(self, word):\\n        cur = self\\n        cur.refs += 1\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        cur.isWord = True\\n\\n    def removeWord(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.addWord(w)\\n\\n        ROWS, COLS = len(board), len(board[0])\\n        res, visit = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r == ROWS\\n                or c == COLS\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in visit\\n            ):\\n                return\\n\\n            visit.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.isWord:\\n                node.isWord = False\\n                res.add(word)\\n                root.removeWord(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            visit.remove((r, c))\\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, root, \"\")\\n\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.refs = 0\\n\\n    def addWord(self, word):\\n        cur = self\\n        cur.refs += 1\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        cur.isWord = True\\n\\n    def removeWord(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.addWord(w)\\n\\n        ROWS, COLS = len(board), len(board[0])\\n        res, visit = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r == ROWS\\n                or c == COLS\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in visit\\n            ):\\n                return\\n\\n            visit.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.isWord:\\n                node.isWord = False\\n                res.add(word)\\n                root.removeWord(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            visit.remove((r, c))\\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, root, \"\")\\n\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870133,
                "title": "c-explanation-with-pictures-trie-backtracking",
                "content": "Prerequisite : https://leetcode.com/problems/implement-trie-prefix-tree/\\nThis will help in trie implementation part. A must do inshort.\\n\\nStructure of Trie Node : \\n```\\nclass trie {\\n    public:\\n    trie *arr[26];\\n    bool end = false; // if a word ends here or not since there can be prefixes as well\\n    string s = \"\"; // to keep track of how far down we have traversed\\n    trie() {\\n        memset(arr, 0, sizeof(arr));\\n    }\\n};\\n```\\n\\nDefinition of trie : \\n```\\nclass Trie {\\n    public:\\n    trie *root;\\n    Trie() {\\n        root = new trie();\\n    }\\n    void insert(string &word)\\n    {\\n        int n = word.size();\\n        trie *temp = root;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(temp->arr[word[i]-\\'a\\'] == NULL)\\n            {\\n                temp->arr[word[i]-\\'a\\'] = new trie();\\n            }\\n            temp = temp->arr[word[i]-\\'a\\'];\\n        }\\n        temp->end = true;\\n\\t\\t// making use of string only here since we don\\'t need it otherwise\\n        temp->s = word;\\n    }\\n};\\n```\\n***Explanation:***\\n![image](https://assets.leetcode.com/users/images/f30984f0-0251-453d-af6f-e41ced1770e4_1647864493.0455797.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/305a5242-c583-4eb0-bbd7-baf4f31770c2_1647864500.991744.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n\\t// we can move in all 4 directions in very less line(s) of code using this\\n    vector<vector<int>> moves{{0,0,-1,1}, {1,-1,0,0}};\\n\\t\\n\\t//our final ans\\n    vector<string> ans;\\n\\t\\n\\t//main function\\n    void dfs(vector<vector<char>>& board, vector<string>& s, trie* ptr, int i, int j)\\n    {\\n        if(i==-1 || i==board.size() || j==-1 || j==board[0].size() || board[i][j]==\\'#\\') return;\\n        \\n\\t\\t//traversing towards the character board[i][j] of the string (if present)\\n\\t\\t//this will be the first character of string when executed the first time (from the main original function)\\n        ptr = ptr->arr[board[i][j]-\\'a\\'];\\n        \\n\\t\\t//if no such word exist then we simply return\\n        if(!ptr) return;\\n\\t\\t\\n\\t\\t//if this is a end that means a word exists so we append it to our ans\\n        if(ptr->end) \\n        {\\n            ptr->end = false;\\n            ans.push_back(ptr->s);\\n        }\\n\\t\\t\\n\\t\\t//since we can\\'t come to a cell once traversed \\n        char el = board[i][j];\\n\\t\\t// we make it unusable for mean time\\n        board[i][j] = \\'#\\';\\n\\t\\t\\n\\t\\t//traversing in all 4 directions with a single line of code !!\\n        for(int x=0; x<4; x++) dfs(board, s, ptr, i+moves[0][x], j+moves[1][x]);\\n\\t\\t\\n\\t\\t//backtracking\\n        board[i][j] = el;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& s) {\\n        int n = board.size(), m = board[0].size(), ss = s.size();\\n        Trie obj\\n\\t\\t//building the trie\\n        for(int k=0; k<ss; k++)\\n        {\\n            obj.insert(s[k]);\\n        }\\n\\t\\t//instead of traversing for all words we just traverse one time across the whole board\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                dfs(board, s, obj.root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nA more cleaner approach:\\n```\\nclass Trie {\\n    public:\\n        unordered_map<char, Trie*> child;\\n        bool isEnd = false;\\n        string word;\\n};\\nclass Solution {\\npublic:\\n    Trie* root = new Trie();\\n\\n    void insertWord(string &s)\\n    {\\n        Trie* temp = root;\\n        for(char c : s)\\n        {\\n            if(temp->child.find(c) == temp->child.end())\\n                temp->child[c] = new Trie();\\n            temp = temp->child[c];\\n        }\\n        temp->isEnd = true;\\n        temp->word = s;\\n    }\\n    vector<string> ans;\\n    bool isValid(int i, int j, int n, int m)\\n    {\\n        return (i >= 0 and j >= 0 and i < n and j < m);\\n    }\\n    void rec(int i, int j, int n, int m, vector<vector<char>> &board, vector<vector<bool>> &vis, Trie* temp)\\n    {\\n        if(temp->isEnd)\\n        {\\n            temp->isEnd = false;\\n            ans.push_back(temp->word);\\n        }\\n        int dir[5] = {-1, 0, 1, 0, -1};\\n\\n        for(int k=0; k<4; ++k)\\n        {\\n            int new_i = i + dir[k];\\n            int new_j = j + dir[k+1];\\n\\n            if(isValid(new_i, new_j, n, m) && temp->child.find(board[new_i][new_j]) != temp->child.end() && !vis[new_i][new_j])\\n            {\\n                vis[new_i][new_j] = true;\\n\\n                rec(new_i, new_j, n, m, board, vis, temp->child[board[new_i][new_j]]);\\n\\n                vis[new_i][new_j] = false;\\n            }\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto s : words)\\n            insertWord(s);\\n\\n        int n = board.size(), m = board[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n\\n        for(int i=0; i<n; ++i)\\n        {\\n            for(int j=0; j<m; ++j)\\n            {\\n                if(root->child.find(board[i][j]) != root->child.end())\\n                {\\n                    Trie* temp = root;\\n                    vis[i][j] = true;\\n                    rec(i, j, n, m, board, vis, temp->child[board[i][j]]);\\n                    vis[i][j] = false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNow the last important thing left to cover is **UPVOTE**. Make sure you do it, if this answer helpful.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\n    public:\\n    trie *arr[26];\\n    bool end = false; // if a word ends here or not since there can be prefixes as well\\n    string s = \"\"; // to keep track of how far down we have traversed\\n    trie() {\\n        memset(arr, 0, sizeof(arr));\\n    }\\n};\\n```\n```\\nclass Trie {\\n    public:\\n    trie *root;\\n    Trie() {\\n        root = new trie();\\n    }\\n    void insert(string &word)\\n    {\\n        int n = word.size();\\n        trie *temp = root;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(temp->arr[word[i]-\\'a\\'] == NULL)\\n            {\\n                temp->arr[word[i]-\\'a\\'] = new trie();\\n            }\\n            temp = temp->arr[word[i]-\\'a\\'];\\n        }\\n        temp->end = true;\\n\\t\\t// making use of string only here since we don\\'t need it otherwise\\n        temp->s = word;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t// we can move in all 4 directions in very less line(s) of code using this\\n    vector<vector<int>> moves{{0,0,-1,1}, {1,-1,0,0}};\\n\\t\\n\\t//our final ans\\n    vector<string> ans;\\n\\t\\n\\t//main function\\n    void dfs(vector<vector<char>>& board, vector<string>& s, trie* ptr, int i, int j)\\n    {\\n        if(i==-1 || i==board.size() || j==-1 || j==board[0].size() || board[i][j]==\\'#\\') return;\\n        \\n\\t\\t//traversing towards the character board[i][j] of the string (if present)\\n\\t\\t//this will be the first character of string when executed the first time (from the main original function)\\n        ptr = ptr->arr[board[i][j]-\\'a\\'];\\n        \\n\\t\\t//if no such word exist then we simply return\\n        if(!ptr) return;\\n\\t\\t\\n\\t\\t//if this is a end that means a word exists so we append it to our ans\\n        if(ptr->end) \\n        {\\n            ptr->end = false;\\n            ans.push_back(ptr->s);\\n        }\\n\\t\\t\\n\\t\\t//since we can\\'t come to a cell once traversed \\n        char el = board[i][j];\\n\\t\\t// we make it unusable for mean time\\n        board[i][j] = \\'#\\';\\n\\t\\t\\n\\t\\t//traversing in all 4 directions with a single line of code !!\\n        for(int x=0; x<4; x++) dfs(board, s, ptr, i+moves[0][x], j+moves[1][x]);\\n\\t\\t\\n\\t\\t//backtracking\\n        board[i][j] = el;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& s) {\\n        int n = board.size(), m = board[0].size(), ss = s.size();\\n        Trie obj\\n\\t\\t//building the trie\\n        for(int k=0; k<ss; k++)\\n        {\\n            obj.insert(s[k]);\\n        }\\n\\t\\t//instead of traversing for all words we just traverse one time across the whole board\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                dfs(board, s, obj.root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Trie {\\n    public:\\n        unordered_map<char, Trie*> child;\\n        bool isEnd = false;\\n        string word;\\n};\\nclass Solution {\\npublic:\\n    Trie* root = new Trie();\\n\\n    void insertWord(string &s)\\n    {\\n        Trie* temp = root;\\n        for(char c : s)\\n        {\\n            if(temp->child.find(c) == temp->child.end())\\n                temp->child[c] = new Trie();\\n            temp = temp->child[c];\\n        }\\n        temp->isEnd = true;\\n        temp->word = s;\\n    }\\n    vector<string> ans;\\n    bool isValid(int i, int j, int n, int m)\\n    {\\n        return (i >= 0 and j >= 0 and i < n and j < m);\\n    }\\n    void rec(int i, int j, int n, int m, vector<vector<char>> &board, vector<vector<bool>> &vis, Trie* temp)\\n    {\\n        if(temp->isEnd)\\n        {\\n            temp->isEnd = false;\\n            ans.push_back(temp->word);\\n        }\\n        int dir[5] = {-1, 0, 1, 0, -1};\\n\\n        for(int k=0; k<4; ++k)\\n        {\\n            int new_i = i + dir[k];\\n            int new_j = j + dir[k+1];\\n\\n            if(isValid(new_i, new_j, n, m) && temp->child.find(board[new_i][new_j]) != temp->child.end() && !vis[new_i][new_j])\\n            {\\n                vis[new_i][new_j] = true;\\n\\n                rec(new_i, new_j, n, m, board, vis, temp->child[board[new_i][new_j]]);\\n\\n                vis[new_i][new_j] = false;\\n            }\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(auto s : words)\\n            insertWord(s);\\n\\n        int n = board.size(), m = board[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n\\n        for(int i=0; i<n; ++i)\\n        {\\n            for(int j=0; j<m; ++j)\\n            {\\n                if(root->child.find(board[i][j]) != root->child.end())\\n                {\\n                    Trie* temp = root;\\n                    vis[i][j] = true;\\n                    rec(i, j, n, m, board, vis, temp->child[board[i][j]]);\\n                    vis[i][j] = false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156559,
                "title": "java-26ms-solution-with-complexity-analysis",
                "content": "```\\n/*\\nIdea: The brute-force solution is to DFS all cells for every word in the dictionary. The time complexity will be O(m * n * wl * l) where \\nm is board.length, n is board[0].length, l is words.length and wl is the average of length of words in \\'words\\'.\\n\\nInstead, we use a Trie to check multiple words at the same time when DFS from a certain cell.\\n\\nComplexity - \\nTime: O(m * n * wl * l) = max(O(wl * l), O(m * n * l * wl)) where\\nO(wl * l) - Build the trie\\nO(m * n * wl * l) - In the worst case where all words start with different chracters, and there is a word starting with a character\\nin the cell board[m - 1][n - 1], we have O(m * n * wl * l). However, if there are words starting with same characters and paths sharing\\ncells, Trie can check multiple words when DFS from a certain cell, rather than check ONLY ONE word when DFS from a certain cell like the \\nbrute-force solution.\\n\\nSpace: O(wl * l) = max(O(wl), O(wl * l)) where\\nO(wl) - The recursive stack can grow at most to wl layers. \\nO(wl * l) - In the worst case when all words start with different characters, the trie has wl * l nodes. Also, since each word\\nis stored in a leaf node, all the leaf nodes require wl * l memory.\\n*/\\npublic class Solution {\\n    private List<String> result = new ArrayList<>();\\n\\t\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || words == null || words.length == 0) {\\n            return result;\\n        }\\n        \\n        TrieNode root = buildTrie(words);\\n        \\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                recursiveFindWords(result, board, root, i, j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void recursiveFindWords(char[][] board, TrieNode parent, int x, int y) {   \\n        if (outOfBounds(board, x, y) || board[x][y] == \\'#\\' || parent.children.get(board[x][y]) == null) {\\n            return; // return if out of bounds, if visited and if current cell is not a character in the trie\\n        }\\n        \\n        char xy = board[x][y];\\n        TrieNode child = parent.children.get(xy);\\n        if (child.isEndOfWord) { // Found a word\\n            result.add(child.word);\\n            child.isEndOfWord = false; // Set to false to avoid adding word to result multiple times\\n            // Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        }\\n        \\n        board[x][y] = \\'#\\'; // \\'#\\' marks a cell as visited\\n        \\n        recursiveFindWords(board, child, x, y - 1); // left\\n        recursiveFindWords(board, child, x - 1, y); // up\\n        recursiveFindWords(board, child, x, y + 1); // right\\n        recursiveFindWords(board, child, x + 1, y); // down\\n        \\n        board[x][y] = xy; // Set as unvisited since we are about to backtracking\\n    }\\n    \\n    private boolean outOfBounds(char[][] board, int x, int y) {\\n        return x < 0 || x >= board.length || y < 0 || y >= board[0].length;\\n    }\\n    \\n    // The trie is represented by a root node, not a Trie object\\n    private TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word : words) {\\n            if (word == null || word.isEmpty()) {\\n                continue;\\n            }\\n            \\n            TrieNode parent = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char cur = word.charAt(i);\\n                \\n                TrieNode child = parent.children.get(cur);\\n                if (child == null) {\\n                    child = new TrieNode();\\n                    parent.children.put(cur, child);\\n                }\\n                \\n                parent = child;\\n            }\\n            \\n            parent.isEndOfWord = true;\\n            parent.word = word; // Store a word at the leaf node\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private class TrieNode {\\n        boolean isEndOfWord; // this.word is null if isEndOfWord is false\\n        String word; // Store the word so that no StringBuilder is needed to build the word char by char\\n        Map<Character, TrieNode> children;\\n        \\n        TrieNode() {\\n            this.children = new HashMap<>();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIdea: The brute-force solution is to DFS all cells for every word in the dictionary. The time complexity will be O(m * n * wl * l) where \\nm is board.length, n is board[0].length, l is words.length and wl is the average of length of words in \\'words\\'.\\n\\nInstead, we use a Trie to check multiple words at the same time when DFS from a certain cell.\\n\\nComplexity - \\nTime: O(m * n * wl * l) = max(O(wl * l), O(m * n * l * wl)) where\\nO(wl * l) - Build the trie\\nO(m * n * wl * l) - In the worst case where all words start with different chracters, and there is a word starting with a character\\nin the cell board[m - 1][n - 1], we have O(m * n * wl * l). However, if there are words starting with same characters and paths sharing\\ncells, Trie can check multiple words when DFS from a certain cell, rather than check ONLY ONE word when DFS from a certain cell like the \\nbrute-force solution.\\n\\nSpace: O(wl * l) = max(O(wl), O(wl * l)) where\\nO(wl) - The recursive stack can grow at most to wl layers. \\nO(wl * l) - In the worst case when all words start with different characters, the trie has wl * l nodes. Also, since each word\\nis stored in a leaf node, all the leaf nodes require wl * l memory.\\n*/\\npublic class Solution {\\n    private List<String> result = new ArrayList<>();\\n\\t\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || words == null || words.length == 0) {\\n            return result;\\n        }\\n        \\n        TrieNode root = buildTrie(words);\\n        \\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                recursiveFindWords(result, board, root, i, j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void recursiveFindWords(char[][] board, TrieNode parent, int x, int y) {   \\n        if (outOfBounds(board, x, y) || board[x][y] == \\'#\\' || parent.children.get(board[x][y]) == null) {\\n            return; // return if out of bounds, if visited and if current cell is not a character in the trie\\n        }\\n        \\n        char xy = board[x][y];\\n        TrieNode child = parent.children.get(xy);\\n        if (child.isEndOfWord) { // Found a word\\n            result.add(child.word);\\n            child.isEndOfWord = false; // Set to false to avoid adding word to result multiple times\\n            // Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        }\\n        \\n        board[x][y] = \\'#\\'; // \\'#\\' marks a cell as visited\\n        \\n        recursiveFindWords(board, child, x, y - 1); // left\\n        recursiveFindWords(board, child, x - 1, y); // up\\n        recursiveFindWords(board, child, x, y + 1); // right\\n        recursiveFindWords(board, child, x + 1, y); // down\\n        \\n        board[x][y] = xy; // Set as unvisited since we are about to backtracking\\n    }\\n    \\n    private boolean outOfBounds(char[][] board, int x, int y) {\\n        return x < 0 || x >= board.length || y < 0 || y >= board[0].length;\\n    }\\n    \\n    // The trie is represented by a root node, not a Trie object\\n    private TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word : words) {\\n            if (word == null || word.isEmpty()) {\\n                continue;\\n            }\\n            \\n            TrieNode parent = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char cur = word.charAt(i);\\n                \\n                TrieNode child = parent.children.get(cur);\\n                if (child == null) {\\n                    child = new TrieNode();\\n                    parent.children.put(cur, child);\\n                }\\n                \\n                parent = child;\\n            }\\n            \\n            parent.isEndOfWord = true;\\n            parent.word = word; // Store a word at the leaf node\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private class TrieNode {\\n        boolean isEndOfWord; // this.word is null if isEndOfWord is false\\n        String word; // Store the word so that no StringBuilder is needed to build the word char by char\\n        Map<Character, TrieNode> children;\\n        \\n        TrieNode() {\\n            this.children = new HashMap<>();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545262,
                "title": "python-100-00-faster-runtime-33-ms-memory-usage-13-7-mb-less-than-98-35",
                "content": "# Please upvote if you find it useful.\\n\\n\\'\\'\\'\\n\\n    def findWords(self, board, words):\\n\\n       m, n = len(board), len(board[0])\\n        dic = defaultdict(set)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dic[board[i][j]].add((i, j))\\n        \\n        results = deque()\\n        \\n        word, lngth, word_isReversed = \\'\\', 0, False\\n        def dfs(cord, indx):\\n            if indx == lngth: \\n                if word_isReversed:\\n                    results.append(word[::-1])\\n                else:\\n                    results.append(word)\\n                return True\\n            \\n            ch = word[indx]\\n            i, j = cord\\n            for cand in [(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]:\\n                if cand in dic[ch]:\\n                    dic[ch].remove(cand)\\n                    flag = dfs(cand, indx + 1)\\n                    dic[ch].add(cand)\\n                    if flag: return True\\n\\n            return False\\n            \\n        \\n        ref = set()\\n        for i in range(m):\\n            for j in range(n - 1):\\n                ref.add(board[i][j] + board[i][j + 1])\\n        for j in range(n):\\n            for i in range(m - 1):\\n                ref.add(board[i][j] + board[i + 1][j])\\n                    \\n        #len_dic = len(dic)\\n        def check(word):\\n            for i in range(len(word) - 1):\\n                if word[i] + word[i + 1] not in ref:\\n                    if word[i + 1] + word[i] not in ref:\\n                        return False\\n            # wordCount = Counter(word)\\n            # if len(wordCount) > len_dic:\\n            #     return False\\n            # for ch, count in wordCount.items():\\n            #     if len(dic[ch]) < count:\\n            #         return False\\n            return True\\n        \\n        \\n        for w in words:\\n            if check(w):\\n                if w[:4] == w[0]*4 or len(dic[w[-1]]) < len(dic[w[0]]):\\n                    word = w[::-1]\\n                    word_isReversed = True\\n                else:\\n                    word = w\\n                    if word_isReversed: word_isReversed = False\\n        \\n                lngth = len(word)\\n                for cord in list(dic[word[0]]):\\n                    dic[word[0]].remove(cord)\\n                    flag = dfs(cord, 1)\\n                    dic[word[0]].add(cord)\\n                    if flag: break\\n            \\n        return results\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "# Please upvote if you find it useful.\\n\\n\\'\\'\\'\\n\\n    def findWords(self, board, words):\\n\\n       m, n = len(board), len(board[0])\\n        dic = defaultdict(set)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dic[board[i][j]].add((i, j))\\n        \\n        results = deque()\\n        \\n        word, lngth, word_isReversed = \\'\\', 0, False\\n        def dfs(cord, indx):\\n            if indx == lngth: \\n                if word_isReversed:\\n                    results.append(word[::-1])\\n                else:\\n                    results.append(word)\\n                return True\\n            \\n            ch = word[indx]\\n            i, j = cord\\n            for cand in [(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]:\\n                if cand in dic[ch]:\\n                    dic[ch].remove(cand)\\n                    flag = dfs(cand, indx + 1)\\n                    dic[ch].add(cand)\\n                    if flag: return True\\n\\n            return False\\n            \\n        \\n        ref = set()\\n        for i in range(m):\\n            for j in range(n - 1):\\n                ref.add(board[i][j] + board[i][j + 1])\\n        for j in range(n):\\n            for i in range(m - 1):\\n                ref.add(board[i][j] + board[i + 1][j])\\n                    \\n        #len_dic = len(dic)\\n        def check(word):\\n            for i in range(len(word) - 1):\\n                if word[i] + word[i + 1] not in ref:\\n                    if word[i + 1] + word[i] not in ref:\\n                        return False\\n            # wordCount = Counter(word)\\n            # if len(wordCount) > len_dic:\\n            #     return False\\n            # for ch, count in wordCount.items():\\n            #     if len(dic[ch]) < count:\\n            #         return False\\n            return True\\n        \\n        \\n        for w in words:\\n            if check(w):\\n                if w[:4] == w[0]*4 or len(dic[w[-1]]) < len(dic[w[0]]):\\n                    word = w[::-1]\\n                    word_isReversed = True\\n                else:\\n                    word = w\\n                    if word_isReversed: word_isReversed = False\\n        \\n                lngth = len(word)\\n                for cord in list(dic[word[0]]):\\n                    dic[word[0]].remove(cord)\\n                    flag = dfs(cord, 1)\\n                    dic[word[0]].add(cord)\\n                    if flag: break\\n            \\n        return results\\n\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 564747,
                "title": "python-3-beats-99-02-trie-and-dfs",
                "content": "```\\nfrom functools import reduce\\nfrom collections import defaultdict\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # create trie\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        END = True\\n        \\n        for word in words:\\n            reduce(dict.__getitem__,word,trie)[END] = word\\n        \\n        res = set()\\n        def findstr(i,j,t):\\n            if END in t:\\n                res.add(t[END])\\n                # return\\n            letter = board[i][j]\\n            board[i][j] = \"\"\\n            if i > 0 and board[i-1][j] in t:\\n                findstr(i-1,j,t[board[i-1][j]])\\n            if j>0 and board[i][j-1] in t:\\n                findstr(i,j-1,t[board[i][j-1]])\\n            if i < len(board)-1 and board[i+1][j] in t:\\n                findstr(i+1,j,t[board[i+1][j]])\\n            if j < len(board[0])-1 and board[i][j+1] in t:\\n                findstr(i,j+1,t[board[i][j+1]])\\n            board[i][j] = letter\\n            \\n            return \\n        \\n        for i, row in enumerate(board):\\n            for j, char in enumerate(row):\\n                if board[i][j] in trie:\\n                    findstr(i,j,trie[board[i][j]])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nfrom functools import reduce\\nfrom collections import defaultdict\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # create trie\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        END = True\\n        \\n        for word in words:\\n            reduce(dict.__getitem__,word,trie)[END] = word\\n        \\n        res = set()\\n        def findstr(i,j,t):\\n            if END in t:\\n                res.add(t[END])\\n                # return\\n            letter = board[i][j]\\n            board[i][j] = \"\"\\n            if i > 0 and board[i-1][j] in t:\\n                findstr(i-1,j,t[board[i-1][j]])\\n            if j>0 and board[i][j-1] in t:\\n                findstr(i,j-1,t[board[i][j-1]])\\n            if i < len(board)-1 and board[i+1][j] in t:\\n                findstr(i+1,j,t[board[i+1][j]])\\n            if j < len(board[0])-1 and board[i][j+1] in t:\\n                findstr(i,j+1,t[board[i][j+1]])\\n            board[i][j] = letter\\n            \\n            return \\n        \\n        for i, row in enumerate(board):\\n            for j, char in enumerate(row):\\n                if board[i][j] in trie:\\n                    findstr(i,j,trie[board[i][j]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780127,
                "title": "c-trie-dfs-backtracking-faster-easy-to-understand",
                "content": "* ***Using Trie + DFS + Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a structure for TrieNode\\n\\n    struct TrieNode\\n    {\\n        bool is_end;\\n\\n        string word;\\n\\n        TrieNode* child[26];\\n\\n        TrieNode()\\n        {\\n            is_end = false;\\n\\n            word = \"\";\\n\\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n\\n    // declare root of the Trie\\n\\n    TrieNode* root = new TrieNode();\\n\\n    // function for inserting word into Trie\\n\\n    void insert(string& str)\\n    {\\n        int n = str.size();\\n\\n        TrieNode* curr = root;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n\\n            // if no subtree is present then insert the new node\\n\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode();\\n            }\\n\\n            curr = curr -> child[idx];\\n        }\\n\\n        // update is_end and word\\n\\n        curr -> is_end = true;\\n\\n        curr -> word = str;\\n    }\\n\\n    // dfs function\\n\\n    vector<string> res;\\n\\n    // direction co-ordinates of all four directions\\n\\n    vector<int> dx = {-1, 0, 1, 0};\\n\\n    vector<int> dy = {0, 1, 0, -1};\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j, int n, int m, TrieNode* curr)\\n    {\\n        // base case\\n         \\n        if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] == \\'#\\')\\n        {\\n            return;\\n        }\\n\\n        int idx = grid[i][j] - \\'a\\';\\n\\n        // if there is no word starting with curr character then return\\n\\n        if(curr -> child[idx] == NULL)\\n        {\\n            return;\\n        }\\n\\n        // move curr\\n\\n        curr = curr -> child[idx];\\n\\n        // if we found a word\\n\\n        if(curr -> is_end)\\n        {\\n            res.push_back(curr -> word);\\n\\n            // mark is_end with false to avoid duplicate result\\n\\n            curr -> is_end = false;\\n        }\\n\\n        // store the val of curr cell\\n\\n        char val = grid[i][j];\\n\\n        // mark the curr cell visited\\n\\n        grid[i][j] = \\'#\\';\\n\\n        // explore all the four directions\\n\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n\\n            int new_j = j + dy[k];\\n\\n            // call dfs\\n\\n            dfs(grid, new_i, new_j, n, m, curr);\\n        }\\n\\n        // backtrack\\n\\n        grid[i][j] = val;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n\\n        // insert all the words into trie\\n\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n\\n        // start dfs from all the cell and find possible result\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dfs(grid, i, j, n, m, root);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // declare a structure for TrieNode\\n\\n    struct TrieNode\\n    {\\n        bool is_end;\\n\\n        string word;\\n\\n        TrieNode* child[26];\\n\\n        TrieNode()\\n        {\\n            is_end = false;\\n\\n            word = \"\";\\n\\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n\\n    // declare root of the Trie\\n\\n    TrieNode* root = new TrieNode();\\n\\n    // function for inserting word into Trie\\n\\n    void insert(string& str)\\n    {\\n        int n = str.size();\\n\\n        TrieNode* curr = root;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n\\n            // if no subtree is present then insert the new node\\n\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode();\\n            }\\n\\n            curr = curr -> child[idx];\\n        }\\n\\n        // update is_end and word\\n\\n        curr -> is_end = true;\\n\\n        curr -> word = str;\\n    }\\n\\n    // dfs function\\n\\n    vector<string> res;\\n\\n    // direction co-ordinates of all four directions\\n\\n    vector<int> dx = {-1, 0, 1, 0};\\n\\n    vector<int> dy = {0, 1, 0, -1};\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j, int n, int m, TrieNode* curr)\\n    {\\n        // base case\\n         \\n        if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] == \\'#\\')\\n        {\\n            return;\\n        }\\n\\n        int idx = grid[i][j] - \\'a\\';\\n\\n        // if there is no word starting with curr character then return\\n\\n        if(curr -> child[idx] == NULL)\\n        {\\n            return;\\n        }\\n\\n        // move curr\\n\\n        curr = curr -> child[idx];\\n\\n        // if we found a word\\n\\n        if(curr -> is_end)\\n        {\\n            res.push_back(curr -> word);\\n\\n            // mark is_end with false to avoid duplicate result\\n\\n            curr -> is_end = false;\\n        }\\n\\n        // store the val of curr cell\\n\\n        char val = grid[i][j];\\n\\n        // mark the curr cell visited\\n\\n        grid[i][j] = \\'#\\';\\n\\n        // explore all the four directions\\n\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n\\n            int new_j = j + dy[k];\\n\\n            // call dfs\\n\\n            dfs(grid, new_i, new_j, n, m, curr);\\n        }\\n\\n        // backtrack\\n\\n        grid[i][j] = val;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n\\n        // insert all the words into trie\\n\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n\\n        // start dfs from all the cell and find possible result\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dfs(grid, i, j, n, m, root);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520723,
                "title": "java-tc-o-rc-3-l-sc-o-n-l-optimal-trie-dfs-solution",
                "content": "```java\\n/**\\n * Create Trie of all words. And then search in Trie.\\n *\\n * Time Complexity: O(R*C * 4*(3^(L-1))) + O(N)\\n *      O(4*(3^(L-1))) ==> For the dfsHelper function, first time we have at most 4 directions\\n *                         to explore, but the choices are reduced to 3 (since no need to go back to the\\n *                         cell from where we came). Therefore, in the worst case, the total number of\\n *                         calls to dfsHelper will be 3^L\\n *      O(N) ==> For building trie\\n *\\n * Space Complexity: O(N + L)\\n *      O(N) ==> For Trie. We are storing reference of word. So no space used by word.\\n *      O(L) ==> For Recursion Depth.\\n *\\n * R = Number of rows. C = Number of columns. N = Total number of chars in words\\n * array. L = Maximum length of a word in the words array.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    class TrieNode {\\n        HashMap<Character, TrieNode> map;\\n        String word;\\n\\t\\t\\n        public TrieNode() {\\n            map = new HashMap<>();\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || board.length == 0 || board[0].length == 0 || words == null || words.length == 0) {\\n            return result;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        TrieNode root = buildTrie(words, rows * cols);\\n        root.word.hashCode();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (root.map.containsKey(board[i][j])) {\\n                    dfsHelper(board, root, i, j, result);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private TrieNode buildTrie(String[] words, int maxLen) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            if (w == null || w.length() == 0 || w.length() > maxLen) {\\n                continue;\\n            }\\n            TrieNode cur = root;\\n            for (int i = 0; i < w.length(); i++) {\\n                char c = w.charAt(i);\\n                if (!cur.map.containsKey(c)) {\\n                    cur.map.put(c, new TrieNode());\\n                }\\n                cur = cur.map.get(c);\\n            }\\n            cur.word = w;\\n        }\\n        return root;\\n    }\\n\\n    private void dfsHelper(char[][] board, TrieNode cur, int x, int y, List<String> result) {\\n        if (cur == null) {\\n            return;\\n        }\\n\\n        if (cur.word != null) {\\n            // A Valid word found. Add to the result.\\n            result.add(cur.word);\\n            // Set this word to null, so that its not added again.\\n            cur.word = null;\\n        }\\n\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || !cur.map.containsKey(board[x][y])) {\\n            return;\\n        }\\n\\n        char curChar = board[x][y];\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            dfsHelper(board, cur.map.get(curChar), x + d[0], y + d[1], result);\\n        }\\n        board[x][y] = curChar;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Word Search question on LeetCode:\\n- [79. Word Search](https://leetcode.com/problems/word-search/discuss/1520705/Java-or-TC%3A-O(RC*(3L))-or-SC%3A-O(L)-or-Optimal-DFS-solution-without-visited-matrix)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Create Trie of all words. And then search in Trie.\\n *\\n * Time Complexity: O(R*C * 4*(3^(L-1))) + O(N)\\n *      O(4*(3^(L-1))) ==> For the dfsHelper function, first time we have at most 4 directions\\n *                         to explore, but the choices are reduced to 3 (since no need to go back to the\\n *                         cell from where we came). Therefore, in the worst case, the total number of\\n *                         calls to dfsHelper will be 3^L\\n *      O(N) ==> For building trie\\n *\\n * Space Complexity: O(N + L)\\n *      O(N) ==> For Trie. We are storing reference of word. So no space used by word.\\n *      O(L) ==> For Recursion Depth.\\n *\\n * R = Number of rows. C = Number of columns. N = Total number of chars in words\\n * array. L = Maximum length of a word in the words array.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    class TrieNode {\\n        HashMap<Character, TrieNode> map;\\n        String word;\\n\\t\\t\\n        public TrieNode() {\\n            map = new HashMap<>();\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> result = new ArrayList<>();\\n        if (board == null || board.length == 0 || board[0].length == 0 || words == null || words.length == 0) {\\n            return result;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        TrieNode root = buildTrie(words, rows * cols);\\n        root.word.hashCode();\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (root.map.containsKey(board[i][j])) {\\n                    dfsHelper(board, root, i, j, result);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private TrieNode buildTrie(String[] words, int maxLen) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            if (w == null || w.length() == 0 || w.length() > maxLen) {\\n                continue;\\n            }\\n            TrieNode cur = root;\\n            for (int i = 0; i < w.length(); i++) {\\n                char c = w.charAt(i);\\n                if (!cur.map.containsKey(c)) {\\n                    cur.map.put(c, new TrieNode());\\n                }\\n                cur = cur.map.get(c);\\n            }\\n            cur.word = w;\\n        }\\n        return root;\\n    }\\n\\n    private void dfsHelper(char[][] board, TrieNode cur, int x, int y, List<String> result) {\\n        if (cur == null) {\\n            return;\\n        }\\n\\n        if (cur.word != null) {\\n            // A Valid word found. Add to the result.\\n            result.add(cur.word);\\n            // Set this word to null, so that its not added again.\\n            cur.word = null;\\n        }\\n\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || !cur.map.containsKey(board[x][y])) {\\n            return;\\n        }\\n\\n        char curChar = board[x][y];\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            dfsHelper(board, cur.map.get(curChar), x + d[0], y + d[1], result);\\n        }\\n        board[x][y] = curChar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637238,
                "title": "c-no-trie-two-different-solutions",
                "content": "## Solution 1\\n**I passed the current word searched by *value* into DFS function, Got 420 ms, 55.4 MB**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {last letter, set of whole words}\\n        unordered_set<string> found; // words already found\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string word, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (word == \"\") {\\n            return true;\\n        }\\n        if (!inside(board, word, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Remove the last letter since we already counted it\\n        word.pop_back();\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, i + 1, j)\\n        || dfs(board, word, i - 1, j) \\n        || dfs(board, word, i, j + 1) \\n        || dfs(board, word, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word.back() != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n## Solution 2 (Optimzed Both Time & Space)\\n**Here, word is passed by *reference* into DFS function, then Got 152 ms, 17 MB**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {first letter, whole word}\\n        unordered_set<string> found;\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        int letterIndex = currentPossibleWord.size() - 1;\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, letterIndex,i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string &word, int letterIndex, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (letterIndex == -1) {\\n            return true;\\n        }\\n        if (!inside(board, word, letterIndex, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Decrease the last letter index\\n        letterIndex--;\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, letterIndex, i + 1, j)\\n        || dfs(board, word, letterIndex, i - 1, j) \\n        || dfs(board, word, letterIndex, i, j + 1) \\n        || dfs(board, word, letterIndex, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int letterIndex, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word[letterIndex] != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {last letter, set of whole words}\\n        unordered_set<string> found; // words already found\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string word, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (word == \"\") {\\n            return true;\\n        }\\n        if (!inside(board, word, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Remove the last letter since we already counted it\\n        word.pop_back();\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, i + 1, j)\\n        || dfs(board, word, i - 1, j) \\n        || dfs(board, word, i, j + 1) \\n        || dfs(board, word, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word.back() != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char, unordered_set<string>> wordMap; // {first letter, whole word}\\n        unordered_set<string> found;\\n        // Inserts each word into map with last letter\\n        for (string word : words) {\\n            if (wordMap.count(word.back())) {\\n                wordMap[word.back()].insert(word);\\n            } \\n            else {\\n                wordMap.insert({ word.back(), {word} });\\n            }\\n        }\\n        vector<string> result;\\n        int M = board.size(); // Rows\\n        int N = board[0].size(); // Columns\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                char currentLetter = board[i][j];\\n                if (wordMap.count(currentLetter) == 1) {\\n                    for (string currentPossibleWord : wordMap[currentLetter]) {\\n                        int letterIndex = currentPossibleWord.size() - 1;\\n                        if (!found.count(currentPossibleWord) && dfs(board, currentPossibleWord, letterIndex,i, j) && currentPossibleWord != \"\") {\\n                            result.push_back(currentPossibleWord);\\n                            found.insert(currentPossibleWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool dfs(vector<vector<char>> &board, string &word, int letterIndex, int i, int j) {\\n        // If we\\'ve found the whole word in the board\\n        if (letterIndex == -1) {\\n            return true;\\n        }\\n        if (!inside(board, word, letterIndex, i, j)) {\\n            return false;    \\n        }\\n        // Save original letter for next searches\\n        char previousLetter = board[i][j];\\n        // Mark letter as visited on board\\n        board[i][j] = \\'*\\';\\n        // Decrease the last letter index\\n        letterIndex--;\\n        // Keep searching\\n        // Backtracking (Revert back previous letter)\\n        bool result = dfs(board, word, letterIndex, i + 1, j)\\n        || dfs(board, word, letterIndex, i - 1, j) \\n        || dfs(board, word, letterIndex, i, j + 1) \\n        || dfs(board, word, letterIndex, i, j - 1);\\n        board[i][j] = previousLetter;\\n        return result;\\n    }\\n    \\n    // Checks borders if we are inside of the grid and check letter if valid\\n    bool inside(vector<vector<char>> &board, string &word, int letterIndex, int &i, int &j) {\\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || word[letterIndex] != board[i][j]) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59852,
                "title": "clean-python-code-with-trie",
                "content": "    class TrieNode(object):\\n        def __init__(self):\\n            self.word = None\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                root = root.children.setdefault(char, TrieNode())\\n            root.word = word\\n    \\n    \\n    class Solution(object):\\n        def search(self, i, j, root, board, m, n, r):\\n            char = board[i][j]\\n            if not (char and char in root.children):\\n                return\\n    \\n            board[i][j], root = None, root.children[char]\\n    \\n            if root.word:\\n                r.append(root.word)\\n                root.word = None\\n    \\n            for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                ii, jj = i + x, j + y\\n                if 0 <= ii < m and 0 <= jj < n:\\n                    self.search(ii, jj, root, board, m, n, r)\\n    \\n            board[i][j] = char\\n    \\n        def findWords(self, board, words):\\n            if not board:\\n                return []\\n    \\n            tree = Trie()\\n            [tree.insert(word) for word in words]\\n    \\n            m, n, r = len(board), len(board[0]), []\\n    \\n            for i, row in enumerate(board):\\n                for j, char in enumerate(row):\\n                    self.search(i, j, tree.root, board, m, n, r)\\n            return r\\n\\nThanks @julien6 for pointing out a corner-case error.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class TrieNode(object):\\n        def __init__(self):\\n            self.word = None\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                root = root.children.setdefault(char, TrieNode())\\n            root.word = word\\n    \\n    \\n    class Solution(object):\\n        def search(self, i, j, root, board, m, n, r):\\n            char = board[i][j]\\n            if not (char and char in root.children):\\n                return\\n    \\n            board[i][j], root = None, root.children[char]\\n    \\n            if root.word:\\n                r.append(root.word)\\n                root.word = None\\n    \\n            for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                ii, jj = i + x, j + y\\n                if 0 <= ii < m and 0 <= jj < n:\\n                    self.search(ii, jj, root, board, m, n, r)\\n    \\n            board[i][j] = char\\n    \\n        def findWords(self, board, words):\\n            if not board:\\n                return []\\n    \\n            tree = Trie()\\n            [tree.insert(word) for word in words]\\n    \\n            m, n, r = len(board), len(board[0]), []\\n    \\n            for i, row in enumerate(board):\\n                for j, char in enumerate(row):\\n                    self.search(i, j, tree.root, board, m, n, r)\\n            return r\\n\\nThanks @julien6 for pointing out a corner-case error.",
                "codeTag": "Java"
            },
            {
                "id": 2779874,
                "title": "without-trie-all-test-pass-easy-solution",
                "content": "This Solution is very helpful for peoples who don\\'t know TRIE. \\n\\n\\n\\n```\\nclass Solution {\\n    \\n     HashMap<String,Integer> map=new HashMap<>();\\n     Set<String> ans=new HashSet<>();\\n    int max=-1;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],1);\\n            max=Math.max(max,words[i].length());\\n        }\\n        \\n        \\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                boolean[][] visited=new boolean[board.length][board[i].length];\\n                check(i,j,\"\",board,visited);\\n            }\\n        }\\n        return new ArrayList<>(ans);\\n    }\\n        \\n        \\n        \\n        public void check(int i,int j,String str,char[][] board,boolean[][] visited){\\n            if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j]==true || str.length()>=max) return;\\n             \\n            visited[i][j]=true;   \\n            str+=board[i][j];\\n            //System.out.println(str);\\n            \\n            if(map.containsKey(str)){\\n                ans.add(str);\\n                // System.out.println(str);\\n                \\n            }\\n            \\n            check(i-1,j,str,board,visited);\\n            check(i+1,j,str,board,visited);\\n            check(i,j-1,str,board,visited);\\n            check(i,j+1,str,board,visited);\\n            \\n            str=str.substring(0, str.length() - 1);\\n            \\n            visited[i][j]=false;\\n        }\\n    }\\n```\\n\\nPlease upvote , If you liked it .",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n     HashMap<String,Integer> map=new HashMap<>();\\n     Set<String> ans=new HashSet<>();\\n    int max=-1;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],1);\\n            max=Math.max(max,words[i].length());\\n        }\\n        \\n        \\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                boolean[][] visited=new boolean[board.length][board[i].length];\\n                check(i,j,\"\",board,visited);\\n            }\\n        }\\n        return new ArrayList<>(ans);\\n    }\\n        \\n        \\n        \\n        public void check(int i,int j,String str,char[][] board,boolean[][] visited){\\n            if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j]==true || str.length()>=max) return;\\n             \\n            visited[i][j]=true;   \\n            str+=board[i][j];\\n            //System.out.println(str);\\n            \\n            if(map.containsKey(str)){\\n                ans.add(str);\\n                // System.out.println(str);\\n                \\n            }\\n            \\n            check(i-1,j,str,board,visited);\\n            check(i+1,j,str,board,visited);\\n            check(i,j-1,str,board,visited);\\n            check(i,j+1,str,board,visited);\\n            \\n            str=str.substring(0, str.length() - 1);\\n            \\n            visited[i][j]=false;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264038,
                "title": "why-trie-brute-force-trie",
                "content": "Hi, \\nI was also thinking about it. Then, I tried to run it with simple optimized Dfs.\\n\\nLook at the code which caused TLE.  You can see that if we did not find the word, we continue our search hoping that next word may match!\\nWhat if there is a way to tell you that stop it here, you do not have to go next! \\nThat\\'s, where Trie is coming to rescue. If this current prefix not in trie, we are sure that there is no possibility of exploration.\\n\\nI hope this will help!\\n\\n    class Solution(object):\\n        def __init__(self):\\n            self.set = None\\n            self.ans = set()   #set to remove duplicates\\n            self.visited = None\\n    \\n        def dfs(self, i, j, string, m , n, board):\\n            #boundary conditions\\n            if i < 0 or j < 0 or i >= m or j >= n or self.visited[i][j] == 1:\\n                return \\n        \\n            #marking visited to remove cycle\\n            self.visited[i][j] = 1\\n        \\n            #checks if the words in set/list, then puts it But we continue exploring. Trie reduces this exploration\\n            if string + board[i][j] in self.set:\\n                self.ans.add(string+board[i][j])\\n        \\n        \\n            #do for dfs\\n            self.dfs(i-1, j, string+board[i][j], m , n, board)\\n            self.dfs(i+1, j, string+board[i][j], m , n, board)\\n            self.dfs(i, j+1, string+board[i][j], m , n, board)\\n            self.dfs(i, j-1, string+board[i][j], m , n, board)\\n        \\n            #unmarking visited\\n            self.visited[i][j] = 0\\n        \\n        \\n        def findWords(self, board, words):\\n            #created set for fast lookup\\n        \\n            self.set = set(words)\\n            m = len(board); n = len(board[0])\\n            self.visited = [[0]*n for i in range(m)]\\n        \\n        \\n            #doing normal dfs\\n            for i in range(m):\\n                for j in range(n):\\n                    self.dfs(i, j, \"\", m, n, board)\\n        \\n    \\n            #returning set as a list\\n            return list(self.ans)",
                "solutionTags": [],
                "code": "Hi, \\nI was also thinking about it. Then, I tried to run it with simple optimized Dfs.\\n\\nLook at the code which caused TLE.  You can see that if we did not find the word, we continue our search hoping that next word may match!\\nWhat if there is a way to tell you that stop it here, you do not have to go next! \\nThat\\'s, where Trie is coming to rescue. If this current prefix not in trie, we are sure that there is no possibility of exploration.\\n\\nI hope this will help!\\n\\n    class Solution(object):\\n        def __init__(self):\\n            self.set = None\\n            self.ans = set()   #set to remove duplicates\\n            self.visited = None\\n    \\n        def dfs(self, i, j, string, m , n, board):\\n            #boundary conditions\\n            if i < 0 or j < 0 or i >= m or j >= n or self.visited[i][j] == 1:\\n                return \\n        \\n            #marking visited to remove cycle\\n            self.visited[i][j] = 1\\n        \\n            #checks if the words in set/list, then puts it But we continue exploring. Trie reduces this exploration\\n            if string + board[i][j] in self.set:\\n                self.ans.add(string+board[i][j])\\n        \\n        \\n            #do for dfs\\n            self.dfs(i-1, j, string+board[i][j], m , n, board)\\n            self.dfs(i+1, j, string+board[i][j], m , n, board)\\n            self.dfs(i, j+1, string+board[i][j], m , n, board)\\n            self.dfs(i, j-1, string+board[i][j], m , n, board)\\n        \\n            #unmarking visited\\n            self.visited[i][j] = 0\\n        \\n        \\n        def findWords(self, board, words):\\n            #created set for fast lookup\\n        \\n            self.set = set(words)\\n            m = len(board); n = len(board[0])\\n            self.visited = [[0]*n for i in range(m)]\\n        \\n        \\n            #doing normal dfs\\n            for i in range(m):\\n                for j in range(n):\\n                    self.dfs(i, j, \"\", m, n, board)\\n        \\n    \\n            #returning set as a list\\n            return list(self.ans)",
                "codeTag": "Java"
            },
            {
                "id": 2780237,
                "title": "dfs-trie-c-soln",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct a trie to determine if we are going on the right path to find a valid word.\\nApply dfs on every cell and traverse the trie node corresponding to it concurrently. For every dfs call , if we are at a particular cell after traversing some characters, then our trie node should also be at the same character. If the node is terminal , we add the word to our list. If such a node does not exist or is NULL then we are on a wrong path and we need to backtrack. Also make a visit array so that we do not go on the same cell again in same path.\\n<!--\\n# Complexity\\n- Time complexity:\\n Add your time complexity here, e.g. $$O(n)$$ \\n\\n- Space complexity:\\n Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{  //*** trie Node\\n    public:\\n        string word;\\n        bool isTerminal;  \\n        vector<Node*> next;\\n        Node():next(26,NULL){\\n            isTerminal = false; \\n            \\n        }\\n};\\n\\nclass Solution {\\n    \\n    void put(string &s,int si, Node* cur){ //** adds a word to the trie \\n            int a = s[si]-\\'a\\';    //*********** also stores the word at the terminal node\\n            if(!cur->next[a]){\\n            Node* newnode = new Node();\\n            cur->next[a] = newnode;\\n            }\\n\\n            if(si != s.size()-1){\\n            put(s,si+1,cur->next[a]); }\\n            else\\n             { cur->next[a]->isTerminal = true;\\n               cur->next[a]->word = s;\\n              }\\n      }\\n\\nvoid dfs(vector<vector<char>>& board,int i,int j,Node* t,set<string>& res,vector<vector<bool>>& visit){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size())return; //** dfs call to search for word\\n    char x = board[i][j]-\\'a\\';\\n    t = t->next[x];\\n    if(visit[i][j] || !t)return ;\\n   \\n    if(t->isTerminal)res.insert((t->word));\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,t,res,visit);\\n    dfs(board,i-1,j,t,res,visit);\\n    dfs(board,i,j+1,t,res,visit);\\n    dfs(board,i,j-1,t,res,visit);\\n    visit[i][j]= false;\\n}\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        set<string> res;\\n        Node* t = new Node();\\n        for(string &s:words){\\n            put(s,0,t);\\n        }\\n       vector<vector<bool>> visit(board.size(),vector<bool>(board[0].size(),false));\\n        for(int i = 0 ;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n               dfs(board,i,j,t,res,visit);\\n            }\\n        }\\n        vector<string> ans(res.begin(),res.end());\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{  //*** trie Node\\n    public:\\n        string word;\\n        bool isTerminal;  \\n        vector<Node*> next;\\n        Node():next(26,NULL){\\n            isTerminal = false; \\n            \\n        }\\n};\\n\\nclass Solution {\\n    \\n    void put(string &s,int si, Node* cur){ //** adds a word to the trie \\n            int a = s[si]-\\'a\\';    //*********** also stores the word at the terminal node\\n            if(!cur->next[a]){\\n            Node* newnode = new Node();\\n            cur->next[a] = newnode;\\n            }\\n\\n            if(si != s.size()-1){\\n            put(s,si+1,cur->next[a]); }\\n            else\\n             { cur->next[a]->isTerminal = true;\\n               cur->next[a]->word = s;\\n              }\\n      }\\n\\nvoid dfs(vector<vector<char>>& board,int i,int j,Node* t,set<string>& res,vector<vector<bool>>& visit){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size())return; //** dfs call to search for word\\n    char x = board[i][j]-\\'a\\';\\n    t = t->next[x];\\n    if(visit[i][j] || !t)return ;\\n   \\n    if(t->isTerminal)res.insert((t->word));\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,t,res,visit);\\n    dfs(board,i-1,j,t,res,visit);\\n    dfs(board,i,j+1,t,res,visit);\\n    dfs(board,i,j-1,t,res,visit);\\n    visit[i][j]= false;\\n}\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        set<string> res;\\n        Node* t = new Node();\\n        for(string &s:words){\\n            put(s,0,t);\\n        }\\n       vector<vector<bool>> visit(board.size(),vector<bool>(board[0].size(),false));\\n        for(int i = 0 ;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n               dfs(board,i,j,t,res,visit);\\n            }\\n        }\\n        vector<string> ans(res.begin(),res.end());\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413504,
                "title": "python-trie-dfs-backtracking-with-pruning-commented-and-explained",
                "content": "**tl;dr**\\n\\n- Create a trie where each node has a pointer to its parent node\\n- Perform DFS traversal on the board with backtracking\\n- When a word is found, attempt to prune trie branches\\n\\n**Solution**\\n```\\nclass TrieNode:\\n    \\n    def __init__(self, val: str = None, parent: Optional[\\'TrieNode\\'] = None):\\n        self.children = {}\\n        self.val = val\\n        self.parent = parent\\n        self.word = None\\n        \\n\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    \\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode(val=c, parent=node)\\n            node = node.children[c]\\n        node.word = word\\n        \\n    \\n    def prune(self, node: TrieNode) -> None:\\n        \"\"\"\\n        When a word is found, we will perform the following actions:\\n        \\n        - Set the word node\\'s \"word\" to None\\n        - If the current word node\\'s child count is 0, we will\\n          traverse up node\\'s parent and \"evict\" the child. We will\\n          perform this check up to trie until we reach a node who\\'s child\\n          count is not zero OR we are at the root\\n          \\n        The reason why we do this is because we only need to match\\n        a word once. So we will improve subsequent word searches by\\n        pruning branches to words we\\'ve already found. We always check if\\n        a node\\'s child count is 0 because we don\\'t want to prune\\n        a branch if there are still words further down.\\n        \\n        For example:\\n            \\n            \"bat\", \"batter\", \"battery\"\\n        \\n        If we found \"bat\", then \"bat\" is no longer an eligible word.\\n        However, \"batter\" and \"battery\" are both further down the\\n        trie, so we don\\'t prune this branch yet.\\n        \\n        If we found \"battery\" next, then this branch would be pruned\\n        to \"bat\", \"batter\".\\n        \\n        Finally, after finding \"batter\", we will prune the entire\\n        \"bat...\" branch.\\n        \"\"\"\\n        # remove current word from possible match later\\n        node.word = None\\n\\n        # prune trie until we reach a node with remaining children\\n        # or the root\\n        child = node\\n        parent = child.parent\\n        while parent and len(child.children) == 0:\\n            del parent.children[child.val]\\n            child = parent\\n            parent = parent.parent\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for word in words:\\n            trie.addWord(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        seen = set()\\n        \\n        def dfs(i, j, node) -> None:\\n            if (i < 0 or i == m or j < 0 or j == n or\\n                (i, j) in seen or board[i][j] not in node.children):\\n                return\\n            \\n            # we can use current board position to (maybe) build a word\\n            seen.add((i, j))\\n            node = node.children[board[i][j]]\\n            \\n            if node.word:\\n                res.append(node.word)\\n                trie.prune(node)\\n\\n            if len(node.children) == 0:\\n                # no more words can be built from here\\n                # no need to dfs further, so we backtrack\\n                seen.remove((i, j))\\n                return\\n\\n            dfs(i + 1, j, node)\\n            dfs(i - 1, j, node)\\n            dfs(i, j + 1, node)\\n            dfs(i, j - 1, node)\\n            \\n            # back track\\n            seen.remove((i, j))\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, trie.root)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    \\n    def __init__(self, val: str = None, parent: Optional[\\'TrieNode\\'] = None):\\n        self.children = {}\\n        self.val = val\\n        self.parent = parent\\n        self.word = None\\n        \\n\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    \\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode(val=c, parent=node)\\n            node = node.children[c]\\n        node.word = word\\n        \\n    \\n    def prune(self, node: TrieNode) -> None:\\n        \"\"\"\\n        When a word is found, we will perform the following actions:\\n        \\n        - Set the word node\\'s \"word\" to None\\n        - If the current word node\\'s child count is 0, we will\\n          traverse up node\\'s parent and \"evict\" the child. We will\\n          perform this check up to trie until we reach a node who\\'s child\\n          count is not zero OR we are at the root\\n          \\n        The reason why we do this is because we only need to match\\n        a word once. So we will improve subsequent word searches by\\n        pruning branches to words we\\'ve already found. We always check if\\n        a node\\'s child count is 0 because we don\\'t want to prune\\n        a branch if there are still words further down.\\n        \\n        For example:\\n            \\n            \"bat\", \"batter\", \"battery\"\\n        \\n        If we found \"bat\", then \"bat\" is no longer an eligible word.\\n        However, \"batter\" and \"battery\" are both further down the\\n        trie, so we don\\'t prune this branch yet.\\n        \\n        If we found \"battery\" next, then this branch would be pruned\\n        to \"bat\", \"batter\".\\n        \\n        Finally, after finding \"batter\", we will prune the entire\\n        \"bat...\" branch.\\n        \"\"\"\\n        # remove current word from possible match later\\n        node.word = None\\n\\n        # prune trie until we reach a node with remaining children\\n        # or the root\\n        child = node\\n        parent = child.parent\\n        while parent and len(child.children) == 0:\\n            del parent.children[child.val]\\n            child = parent\\n            parent = parent.parent\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for word in words:\\n            trie.addWord(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        seen = set()\\n        \\n        def dfs(i, j, node) -> None:\\n            if (i < 0 or i == m or j < 0 or j == n or\\n                (i, j) in seen or board[i][j] not in node.children):\\n                return\\n            \\n            # we can use current board position to (maybe) build a word\\n            seen.add((i, j))\\n            node = node.children[board[i][j]]\\n            \\n            if node.word:\\n                res.append(node.word)\\n                trie.prune(node)\\n\\n            if len(node.children) == 0:\\n                # no more words can be built from here\\n                # no need to dfs further, so we backtrack\\n                seen.remove((i, j))\\n                return\\n\\n            dfs(i + 1, j, node)\\n            dfs(i - 1, j, node)\\n            dfs(i, j + 1, node)\\n            dfs(i, j - 1, node)\\n            \\n            # back track\\n            seen.remove((i, j))\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, trie.root)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875771,
                "title": "java-slow-solution-it-ain-t-much-but-its-honest-work",
                "content": "```\\nclass Solution {\\n    boolean[][] v;\\n    int n,m;\\n    public List<String> findWords(char[][] board, String[] words) {\\n        n = board.length;\\n        m = board[0].length;\\n        Set<String> set = new HashSet<>();\\n        List<String> ans = new ArrayList<>();\\n        for(String word:words){\\n            v = new boolean[n][m];\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(word.charAt(0)==board[i][j] && dfs(i,j,board,0,word) &&                                      !set.contains(word)){\\n                        ans.add(word);\\n                        set.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean dfs(int i,int j,char[][] board,int at,String word){\\n        if(at==word.length()) return true;\\n        if(i>=n || i<0 || j>=m || j<0 || \\n           v[i][j] || board[i][j]!=word.charAt(at)) return false;\\n        \\n        v[i][j] = true;\\n        \\n        if(dfs(i+1,j,board,at+1,word) || dfs(i-1,j,board,at+1,word) ||\\n            dfs(i,j+1,board,at+1,word) || dfs(i,j-1,board,at+1,word)) return true;\\n        \\n        v[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] v;\\n    int n,m;\\n    public List<String> findWords(char[][] board, String[] words) {\\n        n = board.length;\\n        m = board[0].length;\\n        Set<String> set = new HashSet<>();\\n        List<String> ans = new ArrayList<>();\\n        for(String word:words){\\n            v = new boolean[n][m];\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(word.charAt(0)==board[i][j] && dfs(i,j,board,0,word) &&                                      !set.contains(word)){\\n                        ans.add(word);\\n                        set.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean dfs(int i,int j,char[][] board,int at,String word){\\n        if(at==word.length()) return true;\\n        if(i>=n || i<0 || j>=m || j<0 || \\n           v[i][j] || board[i][j]!=word.charAt(at)) return false;\\n        \\n        v[i][j] = true;\\n        \\n        if(dfs(i+1,j,board,at+1,word) || dfs(i-1,j,board,at+1,word) ||\\n            dfs(i,j+1,board,at+1,word) || dfs(i,j-1,board,at+1,word)) return true;\\n        \\n        v[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230245,
                "title": "java-concise-code-very-easy-to-understand",
                "content": "This Question is Actually very similar with 79(Word search)\\nIn backtracing step, seperate the dfs logic and judgment logic will make the code very concise\\n```\\npublic List<String> findWords(char[][] board, String[] words) {\\n\\tList<String> res = new ArrayList<>();\\n\\n\\tfor (String word : words) {\\n\\t\\tboolean[][] visited = new boolean[board.length][board[0].length];\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == word.charAt(0) && exist(board, visited, i, j, word, 0)) {\\n\\t\\t\\t\\t\\tif (!res.contains(word))\\n\\t\\t\\t\\t\\t\\tres.add(word);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nprivate boolean exist(char[][] board, boolean[][] visited, int i, int j, String s, int index) {\\n\\tif (index == s.length())\\n\\t\\treturn true;\\n\\t//false case\\n\\tif (i < 0 || i >= board.length || j < 0 || \\n\\t\\tj >= board[0].length || visited[i][j] || board[i][j] != s.charAt(index)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvisited[i][j] = true;\\n\\tif (exist(board, visited, i + 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i - 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i, j + 1, s, index + 1) ||\\n\\t\\texist(board, visited, i, j - 1, s, index + 1)) {\\n\\t\\treturn true;\\n\\t}\\n\\tvisited[i][j] = false;\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findWords(char[][] board, String[] words) {\\n\\tList<String> res = new ArrayList<>();\\n\\n\\tfor (String word : words) {\\n\\t\\tboolean[][] visited = new boolean[board.length][board[0].length];\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == word.charAt(0) && exist(board, visited, i, j, word, 0)) {\\n\\t\\t\\t\\t\\tif (!res.contains(word))\\n\\t\\t\\t\\t\\t\\tres.add(word);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nprivate boolean exist(char[][] board, boolean[][] visited, int i, int j, String s, int index) {\\n\\tif (index == s.length())\\n\\t\\treturn true;\\n\\t//false case\\n\\tif (i < 0 || i >= board.length || j < 0 || \\n\\t\\tj >= board[0].length || visited[i][j] || board[i][j] != s.charAt(index)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvisited[i][j] = true;\\n\\tif (exist(board, visited, i + 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i - 1, j, s, index + 1) ||\\n\\t\\texist(board, visited, i, j + 1, s, index + 1) ||\\n\\t\\texist(board, visited, i, j - 1, s, index + 1)) {\\n\\t\\treturn true;\\n\\t}\\n\\tvisited[i][j] = false;\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59868,
                "title": "c-48ms-56ms-simple-trie-structure-68lines",
                "content": "    class Trie {\\n        public:\\n        Trie *next[26];\\n        bool exist;\\n        \\n        Trie() {\\n            fill_n(next, 26, nullptr);\\n            exist = false;\\n        }\\n        \\n        ~Trie() {\\n            for (int i = 0; i < 26; ++i)\\n                delete next[i];\\n        }\\n        \\n        void insert(const string &t) {\\n            Trie *iter = this;\\n            for (int i = 0; i < t.size(); ++i) {\\n                if (iter->next[t[i] - 'a'] == nullptr)\\n                    iter->next[t[i] - 'a'] = new Trie();\\n                iter = iter->next[t[i] - 'a'];\\n            }\\n            iter->exist = true;\\n        }\\n    };\\n\\n    class Solution {\\n        public:\\n        int m, n;\\n        \\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie *trie = new Trie();\\n            for (auto &s : words)\\n                trie->insert(s);\\n            m = board.size();\\n            n = board[0].size();\\n            \\n            vector<string> ret;\\n            string sofar;\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    bc(board, ret, sofar, trie, i, j);\\n                }\\n            }\\n            return ret;\\n        }\\n        \\n        void bc(vector<vector<char>> &board, vector<string> &ret, string &sofar, Trie *root, int x, int y) {\\n            if (x < 0 || y < 0 || x >= m || y >= n || board[x][y] == '\\\\0' || root == nullptr)\\n                return ;\\n            if (root->next[board[x][y] - 'a'] == nullptr)\\n                return ;\\n            root = root->next[board[x][y] - 'a'];\\n            char t = '\\\\0';\\n            swap(t, board[x][y]);\\n            sofar.push_back(t);\\n            if (root->exist) {\\n                root->exist = false;\\n                ret.push_back(sofar);\\n            }\\n            bc(board, ret, sofar, root, x, y + 1);\\n            bc(board, ret, sofar, root, x + 1, y);\\n            bc(board, ret, sofar, root, x - 1, y);\\n            bc(board, ret, sofar, root, x, y - 1);\\n            swap(t, board[x][y]);\\n            sofar.pop_back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        int m, n;\\n        \\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie *trie = new Trie();\\n            for (auto &s : words)\\n                trie->insert(s);\\n            m = board.size();\\n            n = board[0].size();\\n            \\n            vector<string> ret;\\n            string sofar;\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    bc(board, ret, sofar, trie, i, j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3224569,
                "title": "212-beats-94-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n94%\\n\\n- Space complexity:\\nBeats\\n81.69%\\n\\n# Code\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # Define a DFS function to traverse the board and search for words\\n        def dfs(x, y, root):\\n            # Get the letter at the current position on the board\\n            letter = board[x][y]\\n            # Traverse the trie to the next node\\n            cur = root[letter]\\n            # Check if the node has a word in it\\n            word = cur.pop(\\'#\\', False)\\n            if word:\\n                # If a word is found, add it to the results list\\n                res.append(word)\\n            # Mark the current position on the board as visited\\n            board[x][y] = \\'*\\'\\n            # Recursively search in all four directions\\n            for dirx, diry in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                curx, cury = x + dirx, y + diry\\n                # Check if the next position is within the board and the next letter is in the trie\\n                if 0 <= curx < m and 0 <= cury < n and board[curx][cury] in cur:\\n                    dfs(curx, cury, cur)\\n            # Restore the original value of the current position on the board\\n            board[x][y] = letter\\n            # If the current node has no children, remove it from the trie\\n            if not cur:\\n                root.pop(letter)\\n                \\n        # Build a trie data structure from the list of words\\n        trie = {}\\n        for word in words:\\n            cur = trie\\n            for letter in word:\\n                cur = cur.setdefault(letter, {})\\n            cur[\\'#\\'] = word\\n            \\n        # Get the dimensions of the board\\n        m, n = len(board), len(board[0])\\n        # Initialize a list to store the results\\n        res = []\\n        \\n        # Traverse the board and search for words\\n        for i in range(m):\\n            for j in range(n):\\n                # Check if the current letter is in the trie\\n                if board[i][j] in trie:\\n                    dfs(i, j, trie)\\n        \\n        # Return the list of results\\n        return res\\n\\n```\\nThe basic idea of the solution is to use a trie data structure to efficiently search for words on the board. We first build the trie from the list of words, where each node in the trie represents a letter in a word and the \\'#\\' symbol indicates the end of a word. Then, we traverse the board and use a depth-first search (DFS) algorithm to search for words starting from each position on the board. We use the trie to efficiently traverse the board and check if each sequence of letters corresponds to a valid word in the trie. When a valid word is found, we add it to the results list. Finally, we return the list of results.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        # Define a DFS function to traverse the board and search for words\\n        def dfs(x, y, root):\\n            # Get the letter at the current position on the board\\n            letter = board[x][y]\\n            # Traverse the trie to the next node\\n            cur = root[letter]\\n            # Check if the node has a word in it\\n            word = cur.pop(\\'#\\', False)\\n            if word:\\n                # If a word is found, add it to the results list\\n                res.append(word)\\n            # Mark the current position on the board as visited\\n            board[x][y] = \\'*\\'\\n            # Recursively search in all four directions\\n            for dirx, diry in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                curx, cury = x + dirx, y + diry\\n                # Check if the next position is within the board and the next letter is in the trie\\n                if 0 <= curx < m and 0 <= cury < n and board[curx][cury] in cur:\\n                    dfs(curx, cury, cur)\\n            # Restore the original value of the current position on the board\\n            board[x][y] = letter\\n            # If the current node has no children, remove it from the trie\\n            if not cur:\\n                root.pop(letter)\\n                \\n        # Build a trie data structure from the list of words\\n        trie = {}\\n        for word in words:\\n            cur = trie\\n            for letter in word:\\n                cur = cur.setdefault(letter, {})\\n            cur[\\'#\\'] = word\\n            \\n        # Get the dimensions of the board\\n        m, n = len(board), len(board[0])\\n        # Initialize a list to store the results\\n        res = []\\n        \\n        # Traverse the board and search for words\\n        for i in range(m):\\n            for j in range(n):\\n                # Check if the current letter is in the trie\\n                if board[i][j] in trie:\\n                    dfs(i, j, trie)\\n        \\n        # Return the list of results\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779776,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        vector<TrieNode*> child;\\n        string word;\\n        TrieNode() : word(\"\"), child(vector<TrieNode*>(26, nullptr)) {}\\n    };\\n    \\n    TrieNode* buildTrie(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for (string w : words) {\\n            TrieNode* curr = root;\\n            for (char c : w) {\\n                int i = c - \\'a\\';\\n                if (curr->child[i] == NULL) curr->child[i] = new TrieNode();\\n                curr = curr->child[i];\\n            }\\n            curr->word = w;\\n        }\\n        return root;\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string> out;\\n        TrieNode* root = buildTrie(words);\\n        for(int i = 0; i < board.size(); ++i) \\n            for(int j = 0; j < board[0].size(); ++j) \\n                dfs(board, i, j, root, out);\\n        return out;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode* curr, vector<string>& out) {\\n        char c = board[i][j];\\n        if(c == \\'#\\' || curr->child[c - \\'a\\'] == NULL) return;\\n        curr = curr->child[c - \\'a\\'];\\n        if (curr->word != \"\") {\\n            out.push_back(curr->word);\\n            curr->word = \"\";\\n        }\\n        board[i][j] = \\'#\\';\\n        if(i > 0) dfs(board, i - 1, j , curr, out); \\n        if(j > 0) dfs(board, i, j - 1, curr, out);\\n        if(i < board.size() - 1) dfs(board, i + 1, j, curr, out); \\n        if(j < board[0].size() - 1) dfs(board, i, j + 1, curr, out); \\n        board[i][j] = c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        vector<TrieNode*> child;\\n        string word;\\n        TrieNode() : word(\"\"), child(vector<TrieNode*>(26, nullptr)) {}\\n    };\\n    \\n    TrieNode* buildTrie(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for (string w : words) {\\n            TrieNode* curr = root;\\n            for (char c : w) {\\n                int i = c - \\'a\\';\\n                if (curr->child[i] == NULL) curr->child[i] = new TrieNode();\\n                curr = curr->child[i];\\n            }\\n            curr->word = w;\\n        }\\n        return root;\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string> out;\\n        TrieNode* root = buildTrie(words);\\n        for(int i = 0; i < board.size(); ++i) \\n            for(int j = 0; j < board[0].size(); ++j) \\n                dfs(board, i, j, root, out);\\n        return out;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode* curr, vector<string>& out) {\\n        char c = board[i][j];\\n        if(c == \\'#\\' || curr->child[c - \\'a\\'] == NULL) return;\\n        curr = curr->child[c - \\'a\\'];\\n        if (curr->word != \"\") {\\n            out.push_back(curr->word);\\n            curr->word = \"\";\\n        }\\n        board[i][j] = \\'#\\';\\n        if(i > 0) dfs(board, i - 1, j , curr, out); \\n        if(j > 0) dfs(board, i, j - 1, curr, out);\\n        if(i < board.size() - 1) dfs(board, i + 1, j, curr, out); \\n        if(j < board[0].size() - 1) dfs(board, i, j + 1, curr, out); \\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779595,
                "title": "java-easy-solution-100-faster",
                "content": "# Upvote if you like the solution\\n# Code\\n```\\nclass Solution {\\n    private static final char HASH_TAG = \\'#\\';\\n    private Tree root = new Tree();\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String word : words) {\\n            Tree temp = root;\\n            // Test case 60/63 \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                int idx = word.charAt(i) - \\'a\\';\\n                if (temp.val[idx] == null) {\\n                    temp.val[idx] = new Tree();\\n                    temp.val[idx].parent = temp;\\n                    temp.val[idx].idx = idx;\\n                }\\n                temp = temp.val[idx];\\n            }\\n            temp.word = word;\\n        }    \\n        return searchWord(board);\\n    }\\n    \\n    private List<String> searchWord(char[][] board) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < board.length; i++)\\n            for (int j = 0; j < board[0].length; j++) {\\n                Tree temp = root;\\n                checkWord(res, i, j, board, temp);\\n            }\\n        \\n        return res;\\n    }\\n    \\n    private void checkWord(List<String> res, int y, int x, char[][] board, Tree temp) {\\n        \\n        if (x >= board[0].length || x < 0\\n            || y >= board.length || y < 0)\\n            return;\\n        \\n        char ch = board[y][x];\\n        if (ch== HASH_TAG || temp.val[ch - \\'a\\'] == null)\\n            return;\\n        \\n        temp = temp.val[ch - \\'a\\'];\\n        \\n        if (temp.word != null) {\\n            res.add(temp.word);\\n            temp.word = null; // Test case 17/63: When there is more than one answer\\n            Tree ptr = temp;\\n            while (ptr.parent != null \\n                    && ptr.isEmpty()) {\\n                int idx = ptr.idx;\\n                ptr = ptr.parent;\\n                ptr.val[idx] = null;\\n            }\\n        }\\n        \\n        board[y][x] = HASH_TAG;\\n\\n        checkWord(res, y, x + 1, board, temp);\\n        checkWord(res, y, x - 1, board, temp);\\n        checkWord(res, y + 1, x, board, temp);\\n        checkWord(res, y - 1, x, board, temp);\\n        \\n        board[y][x] = ch;\\n    }\\n    \\n    class Tree {\\n        Tree parent;\\n        Tree[] val = new Tree[26];\\n        String word;\\n        int idx;\\n\\n        public boolean isEmpty() {\\n            for (int i = 0; i < 26; i++) \\n                if (val[i] != null)\\n                    return false;\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final char HASH_TAG = \\'#\\';\\n    private Tree root = new Tree();\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String word : words) {\\n            Tree temp = root;\\n            // Test case 60/63 \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                int idx = word.charAt(i) - \\'a\\';\\n                if (temp.val[idx] == null) {\\n                    temp.val[idx] = new Tree();\\n                    temp.val[idx].parent = temp;\\n                    temp.val[idx].idx = idx;\\n                }\\n                temp = temp.val[idx];\\n            }\\n            temp.word = word;\\n        }    \\n        return searchWord(board);\\n    }\\n    \\n    private List<String> searchWord(char[][] board) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < board.length; i++)\\n            for (int j = 0; j < board[0].length; j++) {\\n                Tree temp = root;\\n                checkWord(res, i, j, board, temp);\\n            }\\n        \\n        return res;\\n    }\\n    \\n    private void checkWord(List<String> res, int y, int x, char[][] board, Tree temp) {\\n        \\n        if (x >= board[0].length || x < 0\\n            || y >= board.length || y < 0)\\n            return;\\n        \\n        char ch = board[y][x];\\n        if (ch== HASH_TAG || temp.val[ch - \\'a\\'] == null)\\n            return;\\n        \\n        temp = temp.val[ch - \\'a\\'];\\n        \\n        if (temp.word != null) {\\n            res.add(temp.word);\\n            temp.word = null; // Test case 17/63: When there is more than one answer\\n            Tree ptr = temp;\\n            while (ptr.parent != null \\n                    && ptr.isEmpty()) {\\n                int idx = ptr.idx;\\n                ptr = ptr.parent;\\n                ptr.val[idx] = null;\\n            }\\n        }\\n        \\n        board[y][x] = HASH_TAG;\\n\\n        checkWord(res, y, x + 1, board, temp);\\n        checkWord(res, y, x - 1, board, temp);\\n        checkWord(res, y + 1, x, board, temp);\\n        checkWord(res, y - 1, x, board, temp);\\n        \\n        board[y][x] = ch;\\n    }\\n    \\n    class Tree {\\n        Tree parent;\\n        Tree[] val = new Tree[26];\\n        String word;\\n        int idx;\\n\\n        public boolean isEmpty() {\\n            for (int i = 0; i < 26; i++) \\n                if (val[i] != null)\\n                    return false;\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242807,
                "title": "c-easy-trie-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    //we use a trie for storing the words\\n    struct TrieNode{\\n        int endsHere;\\n        TrieNode* child[26];\\n    };\\n     \\n    //create a trieNode and returns it\\n    TrieNode* getNode()\\n    {\\n        TrieNode* newNode=new TrieNode;\\n        newNode->endsHere=0;\\n        for(int i=0;i<26;++i)\\n        {\\n            newNode->child[i]=NULL;\\n        }\\n        return newNode;\\n    }\\n    \\n    TrieNode* root=getNode();\\n    \\n    vector<vector<int>> offset={{0,1},{1,0},{-1,0},{0,-1}}; //useful to move in 4 directions\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        \\n        //insert all the words into the trie\\n        for(auto word:words)\\n        {\\n            addWord(word);\\n        }\\n        \\n        \\n        vector<string> res;\\n        //now search the words in the grid\\n        int rows=board.size();\\n        int cols=board[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(root->child[board[i][j]-\\'a\\']!=NULL){ //if a starting letter of a wod exists in the words dict\\n                    checkWord(root->child[board[i][j]-\\'a\\'],board,i,j,res,\"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    //inserts words into the trie\\n    void addWord(string word)\\n    {\\n        TrieNode* curr=root;\\n        for(int i=0;i<word.length();++i)\\n        {\\n            int ind=word[i]-\\'a\\';\\n            if(curr->child[ind]==NULL) //create if doesnot exists\\n                curr->child[ind]=getNode();\\n            curr=curr->child[ind];\\n        }\\n        curr->endsHere=1; //the word ends here\\n    }\\n    \\n    //check if the char exists in the board\\n    void checkWord(TrieNode* curr,vector<vector<char>>& board,int i,int j,vector<string>& res,string s)\\n    {\\n        \\n        s.push_back(board[i][j]);\\n        if(curr->endsHere>0)\\n        {\\n            //we have got a word\\n            res.push_back(s);\\n            curr->endsHere-=1; //since  not to push again the same word from other possibility\\n        }\\n        char orig=board[i][j];\\n        board[i][j]=\\'#\\';\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=offset[k][0]+i;\\n            int y=offset[k][1]+j;\\n            \\n            //dont move in these directions\\n            if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'#\\' || curr->child[board[x][y]-\\'a\\']==NULL)\\n                continue;\\n            checkWord(curr->child[board[x][y]-\\'a\\'],board,x,y,res,s);\\n        }\\n        board[i][j]=orig;\\n        \\n        \\n    }\\n};\\n```\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we use a trie for storing the words\\n    struct TrieNode{\\n        int endsHere;\\n        TrieNode* child[26];\\n    };\\n     \\n    //create a trieNode and returns it\\n    TrieNode* getNode()\\n    {\\n        TrieNode* newNode=new TrieNode;\\n        newNode->endsHere=0;\\n        for(int i=0;i<26;++i)\\n        {\\n            newNode->child[i]=NULL;\\n        }\\n        return newNode;\\n    }\\n    \\n    TrieNode* root=getNode();\\n    \\n    vector<vector<int>> offset={{0,1},{1,0},{-1,0},{0,-1}}; //useful to move in 4 directions\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        \\n        //insert all the words into the trie\\n        for(auto word:words)\\n        {\\n            addWord(word);\\n        }\\n        \\n        \\n        vector<string> res;\\n        //now search the words in the grid\\n        int rows=board.size();\\n        int cols=board[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(root->child[board[i][j]-\\'a\\']!=NULL){ //if a starting letter of a wod exists in the words dict\\n                    checkWord(root->child[board[i][j]-\\'a\\'],board,i,j,res,\"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    //inserts words into the trie\\n    void addWord(string word)\\n    {\\n        TrieNode* curr=root;\\n        for(int i=0;i<word.length();++i)\\n        {\\n            int ind=word[i]-\\'a\\';\\n            if(curr->child[ind]==NULL) //create if doesnot exists\\n                curr->child[ind]=getNode();\\n            curr=curr->child[ind];\\n        }\\n        curr->endsHere=1; //the word ends here\\n    }\\n    \\n    //check if the char exists in the board\\n    void checkWord(TrieNode* curr,vector<vector<char>>& board,int i,int j,vector<string>& res,string s)\\n    {\\n        \\n        s.push_back(board[i][j]);\\n        if(curr->endsHere>0)\\n        {\\n            //we have got a word\\n            res.push_back(s);\\n            curr->endsHere-=1; //since  not to push again the same word from other possibility\\n        }\\n        char orig=board[i][j];\\n        board[i][j]=\\'#\\';\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=offset[k][0]+i;\\n            int y=offset[k][1]+j;\\n            \\n            //dont move in these directions\\n            if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'#\\' || curr->child[board[x][y]-\\'a\\']==NULL)\\n                continue;\\n            checkWord(curr->child[board[x][y]-\\'a\\'],board,x,y,res,s);\\n        }\\n        board[i][j]=orig;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511657,
                "title": "python-clean-with-trie-pruning-optimization-and-code-comments",
                "content": "The idea is to build a Trie for words, then run dfs at each board location to match the words stored in trie. The time limit is tight, so to avoid TLE, prune the trie once a match is found at the leaf node. \\n\\nIf you are interested, below are some options I tried that lead to TLE:\\n\\n1. Insead build Trie for words, build a Trie for each board location, then match words to all these Tries; this lead to TLE since needs to build many tries, and there are too many paths to store during dfs (at each position has 3 directions to go and explode)\\n\\n2. Use python defaultdict for trie and no pruning (if you use the python native dict() for trie, it can pass even without pruning).\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.is_word = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for w in words:\\n            trie.insert(w)\\n            \\n        m, n = len(board), len(board[0])\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                paths = []\\n                path = \"\"\\n                self.dfs(board, i, j, trie.root, path, paths)\\n                res += paths\\n        return res\\n    \\n    def dfs(self, board, row, col, node, path, paths):\\n        # match words starting from node of the trie, board starting from (row, col)\\n        if node.is_word:\\n            paths.append(path)\\n\\t\\t\\t# set to False so not to repeat the same word\\n            node.is_word = False\\n        \\n        m, n = len(board), len(board[0])\\n\\t\\t# similar to two pointers: here is to check if pointer for board reaches its end, or not a match\\n        if row < 0 or row >=m or col < 0 or col >= n or board[row][col] not in node.children:\\n            return \\n        \\n\\t\\t# This is similar to 2 pointers: now a match is found, move the pointer for trie and pointer for board\\n        tmp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for d in dirs:\\n            r, c = row + d[0], col + d[1]\\n            self.dfs(board, r, c, node.children[tmp], path + tmp, paths)\\n        board[row][col] = tmp\\n        \\n        # pruning: if it is a leaf and a matched word is found for it already, pop it to decrease trie size\\n        if len(node.children[tmp].children) == 0:\\n            del node.children[tmp]\\n",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "The idea is to build a Trie for words, then run dfs at each board location to match the words stored in trie. The time limit is tight, so to avoid TLE, prune the trie once a match is found at the leaf node. \\n\\nIf you are interested, below are some options I tried that lead to TLE:\\n\\n1. Insead build Trie for words, build a Trie for each board location, then match words to all these Tries; this lead to TLE since needs to build many tries, and there are too many paths to store during dfs (at each position has 3 directions to go and explode)\\n\\n2. Use python defaultdict for trie and no pruning (if you use the python native dict() for trie, it can pass even without pruning).\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.is_word = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        trie = Trie()\\n        for w in words:\\n            trie.insert(w)\\n            \\n        m, n = len(board), len(board[0])\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                paths = []\\n                path = \"\"\\n                self.dfs(board, i, j, trie.root, path, paths)\\n                res += paths\\n        return res\\n    \\n    def dfs(self, board, row, col, node, path, paths):\\n        # match words starting from node of the trie, board starting from (row, col)\\n        if node.is_word:\\n            paths.append(path)\\n\\t\\t\\t# set to False so not to repeat the same word\\n            node.is_word = False\\n        \\n        m, n = len(board), len(board[0])\\n\\t\\t# similar to two pointers: here is to check if pointer for board reaches its end, or not a match\\n        if row < 0 or row >=m or col < 0 or col >= n or board[row][col] not in node.children:\\n            return \\n        \\n\\t\\t# This is similar to 2 pointers: now a match is found, move the pointer for trie and pointer for board\\n        tmp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for d in dirs:\\n            r, c = row + d[0], col + d[1]\\n            self.dfs(board, r, c, node.children[tmp], path + tmp, paths)\\n        board[row][col] = tmp\\n        \\n        # pruning: if it is a leaf and a matched word is found for it already, pop it to decrease trie size\\n        if len(node.children[tmp].children) == 0:\\n            del node.children[tmp]\\n",
                "codeTag": "Java"
            },
            {
                "id": 591116,
                "title": "javascript-backtracking-with-trie-comments-video",
                "content": "https://www.youtube.com/watch?v=7XmS8McW_1U\\nsee detailed explanation about trie here\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar findWords = function(board, words) {\\n  let res = [];\\n\\n  const root = buildTrie(words);\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[0].length; col++) {\\n      dfs(root, row, col, board, res);\\n    }\\n  }\\n  return res;\\n\\n};\\n\\n  function dfs(node, row, col, board, res) {\\n    if (node.end) {\\n      res.push(node.end);\\n      node.end = null;   // make sure only print one time for each word\\n    }\\n\\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;\\n    if (!node[board[row][col]]) return;\\n\\n    const c = board[row][col];\\n    board[row][col] = \\'#\\';  // mark visited\\n    dfs(node[c], row + 1, col, board, res); // up\\n    dfs(node[c], row - 1, col, board, res); // down\\n    dfs(node[c], row, col + 1, board, res); // right\\n    dfs(node[c], row, col - 1, board, res); // left\\n    board[row][col] = c;  // reset - back track\\n  }\\n\\nfunction buildTrie(words) {\\n    const root = {};\\n    for (let w of words) {\\n      let pointer = root; // here \\'pointer\\' just a reference, that we use to go down from root till last child node\\n                          // and when we rich last child node - this is the end of the world\\n                          // and instead of setting \"node.end = true\", we set \"node.end = word\"\\n      for (let c of w) {\\n        if (!pointer[c]) pointer[c] = {}; // if we already have such node, lets ignore it creating and just move the pointer\\n        pointer = pointer[c];\\n      }\\n      pointer.end = w; \\n    }\\n    return root;\\n  }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar findWords = function(board, words) {\\n  let res = [];\\n\\n  const root = buildTrie(words);\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[0].length; col++) {\\n      dfs(root, row, col, board, res);\\n    }\\n  }\\n  return res;\\n\\n};\\n\\n  function dfs(node, row, col, board, res) {\\n    if (node.end) {\\n      res.push(node.end);\\n      node.end = null;   // make sure only print one time for each word\\n    }\\n\\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;\\n    if (!node[board[row][col]]) return;\\n\\n    const c = board[row][col];\\n    board[row][col] = \\'#\\';  // mark visited\\n    dfs(node[c], row + 1, col, board, res); // up\\n    dfs(node[c], row - 1, col, board, res); // down\\n    dfs(node[c], row, col + 1, board, res); // right\\n    dfs(node[c], row, col - 1, board, res); // left\\n    board[row][col] = c;  // reset - back track\\n  }\\n\\nfunction buildTrie(words) {\\n    const root = {};\\n    for (let w of words) {\\n      let pointer = root; // here \\'pointer\\' just a reference, that we use to go down from root till last child node\\n                          // and when we rich last child node - this is the end of the world\\n                          // and instead of setting \"node.end = true\", we set \"node.end = word\"\\n      for (let c of w) {\\n        if (!pointer[c]) pointer[c] = {}; // if we already have such node, lets ignore it creating and just move the pointer\\n        pointer = pointer[c];\\n      }\\n      pointer.end = w; \\n    }\\n    return root;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510396,
                "title": "python-going-from-7586-ms-to-300-ms",
                "content": "The idea is the same as mentioned by others, i.e. construct a trie of the given words and then do a DFS + Backtrack from each cell, moving ahead only if the character is in the trie. To maintain a unique set of words, add the discovered words into a set. \\n\\nThe above solution works fine, but gives a runtime of 7586ms in Python. How to improve?\\n\\nNote that only unique words are required, so one **big** optimization would be to delete the words from the trie which are already found. This simple optimization brings down the runtime from 7586ms to 300ms!!\\n\\nDamn, that ended soon. (That\\'s what she said!)\\n\\n```\\nclass TrieNode(object):\\n        def __init__(self, char):\\n            self.char = char\\n            self.isWord = False\\n            self.children = {}\\n\\n        def addNode(self, char, node):\\n            self.children[char] = node\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode(\\'0\\')\\n\\n    def insert(self, word: str) -> None:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                child = TrieNode(c)\\n                cur.addNode(c, child)\\n            cur = cur.children[c]\\n        cur.isWord = True\\n\\n    def search(self, word: str) -> bool:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return cur.isWord\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        cur = self.root\\n        for c in prefix:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return True\\n    \\n    def eraseWord(self, ind, word, cur):\\n        if ind == len(word):\\n            cur.isWord = False\\n            if len(cur.children) == 0:\\n                return True\\n            return False\\n        \\n        canErase = self.eraseWord(ind+1, word, cur.children[word[ind]])\\n        if canErase:\\n            cur.children.pop(word[ind])\\n        \\n        return len(cur.children) == 0\\n            \\n        \\n    \\nclass Solution:\\n    \\n    def getWords(self, x, y, cur, board, vis, word):\\n        \\n        if cur.isWord:\\n            w = \"\".join(word)\\n            self.wordsPresent.append(w)\\n            self.trieOb.eraseWord(0, word, self.trieOb.root)\\n            \\n        vis[x][y] = 1\\n        for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n            if nx >= 0 and nx < self.m and ny >= 0 and ny < self.n and vis[nx][ny] == 0:\\n                nxc = board[nx][ny]\\n                if nxc in cur.children:\\n                    word.append(nxc)\\n                    self.getWords(nx, ny, cur.children[nxc], board, vis, word)\\n                    word.pop()\\n        vis[x][y] = 0\\n        \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.m, self.n = len(board), len(board[0])\\n        self.trieOb = Trie()\\n        for w in words:\\n            self.trieOb.insert(w)\\n        \\n        self.wordsPresent = []\\n        vis = [[0 for _ in range(self.n)] for _ in range(self.m)]\\n        for x in range(self.m):\\n            for y in range(self.n):\\n                c = board[x][y]\\n                if c in self.trieOb.root.children:\\n                    self.getWords(x, y, self.trieOb.root.children[c], board, vis, [c])\\n        return self.wordsPresent\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n        def __init__(self, char):\\n            self.char = char\\n            self.isWord = False\\n            self.children = {}\\n\\n        def addNode(self, char, node):\\n            self.children[char] = node\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode(\\'0\\')\\n\\n    def insert(self, word: str) -> None:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                child = TrieNode(c)\\n                cur.addNode(c, child)\\n            cur = cur.children[c]\\n        cur.isWord = True\\n\\n    def search(self, word: str) -> bool:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return cur.isWord\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        cur = self.root\\n        for c in prefix:\\n            if c not in cur.children:\\n                return False\\n            cur = cur.children[c]\\n        return True\\n    \\n    def eraseWord(self, ind, word, cur):\\n        if ind == len(word):\\n            cur.isWord = False\\n            if len(cur.children) == 0:\\n                return True\\n            return False\\n        \\n        canErase = self.eraseWord(ind+1, word, cur.children[word[ind]])\\n        if canErase:\\n            cur.children.pop(word[ind])\\n        \\n        return len(cur.children) == 0\\n            \\n        \\n    \\nclass Solution:\\n    \\n    def getWords(self, x, y, cur, board, vis, word):\\n        \\n        if cur.isWord:\\n            w = \"\".join(word)\\n            self.wordsPresent.append(w)\\n            self.trieOb.eraseWord(0, word, self.trieOb.root)\\n            \\n        vis[x][y] = 1\\n        for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n            if nx >= 0 and nx < self.m and ny >= 0 and ny < self.n and vis[nx][ny] == 0:\\n                nxc = board[nx][ny]\\n                if nxc in cur.children:\\n                    word.append(nxc)\\n                    self.getWords(nx, ny, cur.children[nxc], board, vis, word)\\n                    word.pop()\\n        vis[x][y] = 0\\n        \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.m, self.n = len(board), len(board[0])\\n        self.trieOb = Trie()\\n        for w in words:\\n            self.trieOb.insert(w)\\n        \\n        self.wordsPresent = []\\n        vis = [[0 for _ in range(self.n)] for _ in range(self.m)]\\n        for x in range(self.m):\\n            for y in range(self.n):\\n                c = board[x][y]\\n                if c in self.trieOb.root.children:\\n                    self.getWords(x, y, self.trieOb.root.children[c], board, vis, [c])\\n        return self.wordsPresent\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482662,
                "title": "javascript-100-clean-code-w-explanation-trie-pruning",
                "content": "![image](https://assets.leetcode.com/users/images/794345da-3575-4594-8ce2-ee19daff7735_1632497992.4097955.png)\\n\\nDoing the Blind 75 List and posting all solutions.\\n\\nHere\\'s the pruning version w/o comments:  (See below for explanation.)\\n```\\nvar findWords = function(board, words) {\\n  const res = [], trie = {};\\n  \\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) {\\n      curNode[char] = curNode[char] || {};\\n      curNode[char].count = curNode[char].count + 1 || 1;\\n      curNode = curNode[char];\\n    };\\n    curNode.end = word;\\n  }\\n  \\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  function traverse(row, col, node = trie) {\\n    if (!board[row][col]) return;\\n    \\n    const char = board[row][col], curNode = node[char];\\n    if (!curNode) return;\\n    \\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      let toDelete = trie;\\n      for (let char of curNode.end) {\\n        toDelete[char].count--;\\n        if (!toDelete[char].count) {\\n          delete(toDelete[char]);\\n          break;\\n        }\\n        toDelete = toDelete[char];\\n      }\\n      curNode.end = null;\\n    }\\n    \\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```\\n\\nHere is - mostly - the same code as above w/ explanation: (Minus pruning.  Sorry, I already had this explanation written up before I implemented it.  That said, to implement pruning, we just added a counter to each trie node that increments so we can tell how many words share the node.  Then, below when we find results, we decrement the count as we push to results.  If count === 0 after, we prune it from the trie so that we don\\'t go down that track again.  And that\\'s it... All we need to take an 85% 440ms solution to a 99% 96ms one.)\\n![image](https://assets.leetcode.com/users/images/09e67c6e-948d-4d30-9d9e-c0d2ff9488f1_1632521543.0135832.png)\\n\\n```\\nvar findWords = function(board, words) {\\n  const trie = {}, res = [];\\n  \\n  //Lines below just populate our trie.  See LC 208. & 211. for a better understanding on tries.\\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) (curNode = curNode[char] = curNode[char] || {});\\n    curNode.end = word;\\n  }\\n  \\n  //Here we loop through entire board, if char at those coords is in \\n  //our trie on the root level, we call our traverse function.\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  //Function takes row, col and node.  First time called, node is root\\n  //level of our trie, as the function runs node stays in sync with where\\n  //our recursive calls are at.\\n  function traverse(row, col, node = trie) {\\n    \\n    //Further down in this function we set board[row][col] to 0 before trying\\n    //neighboring coordinates.  The line below keeps us from visiting the same\\n    //cell more than once.\\n    if (!board[row][col]) return;\\n    \\n    //Here we capture the char on the board at coords, and we also move down\\n    //within the trie to the level that matches that char.\\n    const char = board[row][col], curNode = node[char];\\n    \\n    //If there is no curNode (I.e.- Current letter not within our trie node), \\n    //we return, because our sequence of correct letters has been broken.\\n    if (!curNode) return;\\n    \\n    //If current node has the end property, we push the word that\\'s the value\\n    //for curNode.end (We set this above in the trie).  We then set end to \\n\\t//null to keep from pushing the same word more than once.\\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      curNode.end = null;\\n    }\\n    \\n    //Here we set board[row][col] to 0 in order to keep track of where we \\n    //have already visited.  Then we try all options and set it back afterward.\\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```\\n\\nEdit:\\nSlightly modified version of this code performs Phenomenal for actual wordsearches (Added directions and diagonals so it only searches in straight lines radiating out from found char).  I might make this a RN project with ML Kit to scan in searches and solve on the fly.  Trying to decide if it\\'s a project worth working on or not. lol\\n![image](https://assets.leetcode.com/users/images/e72df208-a87c-49ab-952e-7d45d130159b_1633803539.6985726.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nvar findWords = function(board, words) {\\n  const res = [], trie = {};\\n  \\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) {\\n      curNode[char] = curNode[char] || {};\\n      curNode[char].count = curNode[char].count + 1 || 1;\\n      curNode = curNode[char];\\n    };\\n    curNode.end = word;\\n  }\\n  \\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  function traverse(row, col, node = trie) {\\n    if (!board[row][col]) return;\\n    \\n    const char = board[row][col], curNode = node[char];\\n    if (!curNode) return;\\n    \\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      let toDelete = trie;\\n      for (let char of curNode.end) {\\n        toDelete[char].count--;\\n        if (!toDelete[char].count) {\\n          delete(toDelete[char]);\\n          break;\\n        }\\n        toDelete = toDelete[char];\\n      }\\n      curNode.end = null;\\n    }\\n    \\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```\n```\\nvar findWords = function(board, words) {\\n  const trie = {}, res = [];\\n  \\n  //Lines below just populate our trie.  See LC 208. & 211. for a better understanding on tries.\\n  for (let word of words) {\\n    let curNode = trie;\\n    for (let char of word) (curNode = curNode[char] = curNode[char] || {});\\n    curNode.end = word;\\n  }\\n  \\n  //Here we loop through entire board, if char at those coords is in \\n  //our trie on the root level, we call our traverse function.\\n  for (let row = 0; row < board.length; row++) {\\n    for (let col = 0; col < board[row].length; col++) {\\n      if (trie[board[row][col]]) traverse(row, col);\\n    }\\n  }\\n  \\n  return res;\\n  \\n  //Function takes row, col and node.  First time called, node is root\\n  //level of our trie, as the function runs node stays in sync with where\\n  //our recursive calls are at.\\n  function traverse(row, col, node = trie) {\\n    \\n    //Further down in this function we set board[row][col] to 0 before trying\\n    //neighboring coordinates.  The line below keeps us from visiting the same\\n    //cell more than once.\\n    if (!board[row][col]) return;\\n    \\n    //Here we capture the char on the board at coords, and we also move down\\n    //within the trie to the level that matches that char.\\n    const char = board[row][col], curNode = node[char];\\n    \\n    //If there is no curNode (I.e.- Current letter not within our trie node), \\n    //we return, because our sequence of correct letters has been broken.\\n    if (!curNode) return;\\n    \\n    //If current node has the end property, we push the word that\\'s the value\\n    //for curNode.end (We set this above in the trie).  We then set end to \\n\\t//null to keep from pushing the same word more than once.\\n    if (curNode.end) {\\n      res.push(curNode.end);\\n      curNode.end = null;\\n    }\\n    \\n    //Here we set board[row][col] to 0 in order to keep track of where we \\n    //have already visited.  Then we try all options and set it back afterward.\\n    board[row][col] = 0;\\n    (col - 1 >= 0) && traverse(row, col - 1, curNode);\\n    (col + 1 < board[row].length) && traverse(row, col + 1, curNode);\\n    (row - 1 >= 0) && traverse(row - 1, col, curNode);\\n    (row + 1 < board.length) && traverse(row + 1, col, curNode);\\n    board[row][col] = char;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59877,
                "title": "java-simple-solution-trie-dfs",
                "content": "The Algorithm works as follow:\\n\\n - In the first step we build  a [Trie][1] with the words received as\\n   parameter.\\n - Then for each square in the board, we perform the deep first search only if the next char in the board belongs to a valid branch in the Trie;\\n - At every step in the dfs, we add the current char to the string currentWord, and if the current node in the Trie is a valid word, we add this word to the final list of words.\\n\\nThe class **Move** keeps the coordinates of the next step in the board\\n\\nThe class **TrieSW** implements theTrie\\n\\nThe method **search** performs the DFS\\n\\nThe method **possMoves** retrieves the list of the possible moves from the current square\\n\\nThe method **isInBound** check if the coordinates are in the board\\n\\n    class Move {\\n    \\tint x;\\n    \\tint y;\\n    \\tpublic Move(int x,int y) {\\n    \\t\\tthis.x = x;\\n    \\t\\tthis.y = y;\\n    \\t}\\n    }\\n    \\n    class TrieSW {\\n    \\tMap<Character,TrieSW> children;\\n    \\tboolean isWord;\\n    \\t\\n    \\tpublic TrieSW() {\\n    \\t\\tthis.children = new HashMap<Character, TrieSW>();\\n    \\t\\tthis.isWord = false;\\n    \\t}\\n    \\t\\n    \\tpublic void addWord(String word) {\\n    \\t\\tchar[] chars = word.toCharArray();\\n    \\t\\tTrieSW current = this;\\n    \\t\\tfor(char c:chars) {\\n    \\t\\t\\tif(!current.children.containsKey(c)) current.children.put(c, new TrieSW());\\n    \\t\\t\\tcurrent = current.children.get(c);\\n    \\t\\t}\\n    \\t\\tcurrent.isWord = true;\\n    \\t}\\n    \\t\\n    \\tpublic void addWords(String[] words) {\\n    \\t\\tfor(String w:words) this.addWord(w);\\n    \\t}\\n    }\\n    \\n    public class Solution {\\n    \\t\\n    \\tint[] dx = {0,1,0,-1};\\n    \\tint[] dy = {1,0,-1,0};\\n    \\t\\n    \\tpublic List<String> findWords(char[][] board, String[] words) {\\n            Set<String> foundWords = new HashSet<String>();\\n            if(board==null || words==null || board.length==0 || words.length==0) return new ArrayList<String>(foundWords);\\n            TrieSW trie = new TrieSW();\\n            trie.addWords(words);\\n            StringBuilder currentWord = new StringBuilder();\\n            boolean[][] visited = new boolean[board.length][board[0].length];\\n            for(int i=0;i<board.length;i++) {\\n            \\tfor(int j=0;j<board[i].length;j++) {\\n            \\t\\tif(trie.children.containsKey(board[i][j]))\\n            \\t\\t\\tsearch(board,i,j,visited,trie,currentWord,foundWords);\\n            \\t}\\n            }\\n            return new ArrayList<String>(foundWords);\\n        }\\n    \\t\\n    \\tpublic void search(char[][] board, int y, int x, boolean[][] visited, TrieSW trie, StringBuilder currentWord, Set<String> foundWords) {\\n    \\t\\tchar c = board[y][x];\\n    \\t\\tcurrentWord.append(c);\\n    \\t\\tTrieSW current = trie.children.get(c);\\n    \\t\\tif(current.isWord) foundWords.add(currentWord.toString());\\n    \\t\\tvisited[y][x] = true;\\n    \\t\\tfor(Move m: possMoves(board,y,x,visited,current)) {\\n    \\t\\t\\tsearch(board,m.y,m.x,visited,current,currentWord,foundWords);\\n    \\t\\t}\\n    \\t\\tvisited[y][x] = false;\\n    \\t\\tcurrentWord.deleteCharAt(currentWord.length()-1);\\n    \\t}\\n    \\t\\n    \\tpublic List<Move> possMoves(char[][] board, int y, int x, boolean[][] visited, TrieSW trie) {\\n    \\t\\tList<Move> moves = new ArrayList<Move>();\\n    \\t\\tfor(int d=0; d<dx.length; d++) {\\n    \\t\\t\\tint newX = x+dx[d];\\n    \\t\\t\\tint newY = y+dy[d];\\n    \\t\\t\\tif(isInBound(newY,newX,board) && trie.children.containsKey(board[newY][newX]) && !visited[newY][newX])\\n    \\t\\t\\t\\tmoves.add(new Move(newX,newY));\\n    \\t\\t}\\n    \\t\\treturn moves;\\n    \\t}\\n    \\n    \\tprivate boolean isInBound(int y, int x, char[][] board) {\\n    \\t\\treturn x>=0 && y>=0 && y<board.length && x<board[y].length;\\n    \\t}\\n    \\t\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n    \\t\\n    \\tint[] dx = {0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2780552,
                "title": "python-trie-dfs-53-ms-beats-99-89-optimized-for-leetcode-tests-and-well-commented",
                "content": "### Solution using Trie + DFS + optimizations directed at the LeetCode tests.\\n\\n- Use a trie to do quick lookups of the words, since the words are max 10 characters long, looking up a word in the trie can be done in O(1). \\n- Iterate over all the positions in the matrix doing DFS starting at that position and moving to its neighbors while the words that we are constructing are prefixes found in the trie. \\n- When we find a word, add it to the result set. \\n\\n### If you like this solution, don\\'t forget to \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4DUPVOTE! \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n**NOTE:** Using the trie to do prefix and word lookups is probably all that is expected in an interview, but adding the word removal is an optimization that could be discussed.\\n\\n#### The Trie class\\n\\nThis solution uses a Trie class instead of a TrieNode. This leads to having to check the entire path in the trie at each interation of the DFS, while using a TrieNode allows us to pass the current TrieNode in the recursive call and would seem more optimal. \\n\\nI tested and I was getting worst performance using TrieNode and passing it as a parameter of the `dfs()` call vs using the Trie class and having to check the entire path, of max length 10, on each call, so I went on ahead with using the Trie class.\\n\\nOn an interview I would favor using TrieNodes because they would be more readable and easier to maintain.\\n\\n```\\n# A fast trie implementation, not as readable as using TrieNodes but\\n# more performant.\\n#\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/implement-trie-prefix-tree.py\\n#\\nclass Trie:\\n    def __init__(self, words: List[str] = None):\\n\\t\\t# The variable length stores the total number of children of this node.\\n        self.root = {\"length\": 0}\\n        for word in words:\\n            self.insert(word)\\n\\t\\t\\t\\n\\t# Having a len method helps debug.\\n    def __len__(self) -> int:\\n        return self.root[\"length\"]\\n\\n    # Insert a word into this trie object. O(1) because max word length is 10 chars.\\n    def insert(self, word: str) -> None:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                current[c] = {\"length\": 0}\\n            # There is more complete word under this node.\\n            current[\"length\"] += 1\\n            current = current[c]\\n        current[\"length\"] += 1\\n        current[\"?\"] = True\\n\\n    # Remove a word from this trie object. O(1) because max word length is 10.\\n    def remove(self, word: str) -> None:\\n        current = self.root\\n        current[\"length\"] -= 1\\n        for i, c in enumerate(word):\\n            if c in current:\\n                current[c][\"length\"] -= 1\\n                if current[c][\"length\"] < 1:\\n                    current.pop(c)\\n                    break\\n                else:\\n                    current = current[c]\\n        # If we get to the word leaf but the trie node has children.\\n        if i == len(word) - 1 and \"?\" in current:\\n            current.pop(\"?\")\\n\\n    # Check if a given list of chars is in the trie, it returns 0 if\\n    # not found, 1 if found but not a full word and 2 if a full word.\\n\\t# O(1) because max word length is 10.\\n    def contains(self, word: List[str]) -> int:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                return 0\\n            current = current[c]\\n        return 2 if \"?\" in current else 1\\n```\\n\\n### The Solution class\\n\\nThis is very similar to other solutions here, use the Trie for lookups and do DFS from each cell in the board, the solution was running in 5/6 seconds in average, which placed it in the bottom 70%, until I looked at the tests and saw that a lot of the time was being wasted checking long paths that could not lead to a word.\\n\\n##### Adding two small optimizations led to the running time decreasing from 5/6 seconds to 53ms.\\n\\n**First optimization:** Create a dictionary of all the two letter combinations found in the board, only do this for combinations going right and down. The iterate over all the input words checking if all the sequences of two characters in the word can be found in the lookup dictionary, either in regular or reverse form. We create a list of _candidates_ that are words that could be found in the board, and use this on to fill the trie, instead of all the words in the input.\\n\\n**Second optimization:** Create a lookup of reversed words, when we are adding words to the trie, check if the first character repeats itself at the beginning of the word, I choose 4 times as the limit. If the first 4 characters are the same, then reverse the word, add it to the trie, reversed, and to the reversed words lookup.\\n\\n**NOTE:** Reversing the characters would still work, even if we had a word and its anadrome in the input, because we are removing the reversed words from the lookup once we find one instance of them. By the time we find the anadrome, it would be interpreted as a non-reversed word.\\n\\n**NOTE:** This optimizations, specially the second one, are directed to the LeetCode tests in particular, with other input data, for example dictionary words, I believe that they wouldn\\'t lead to any significant performance improvement.\\n\\n\\n```\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/word-search-ii.py\\n\\n# Time complexity: O(m*n*(4*3^10)) - We iterate over all the positions\\n# on the board, for each, we start a search for any words that can be\\n# constructed from this position, the search will initially move to the\\n# four neighbors, then from there, as long as the characters added are\\n# found in the trie, the search will expand to the three neighbors of\\n# the new cell, since the cell we just came from cannot be visited again.\\n# So, from each position in the matrix, we will potentially do 4*3^10\\n# calls to DFS, since the max depth is equal to the length of the\\n# longest word in the trie and that is a max of 10. In theory that is\\n# still O(1) but it seems significant enough that is worth mentioning it\\n# on the time complexity.\\n#\\n# Space complexity: O(w*c) - The number of characters in all the words\\n# in the input, we store them all in the trie, and potentially also in\\n# the result set even though we would not consider that because it is\\n# used as the output. The call stack will have a max height of 10.\\n#\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Remove words for which one of their two letter combinations\\n        # cannot be found in the board.\\n        seq_two = set()\\n        candidates = []\\n        reversed_words = set()\\n        # Find all sequences of two characters in the board. Only right\\n        # and down.\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS - 1):\\n                seq_two.add(board[i][j] + board[i][j + 1])\\n        for j in range(NUM_COLS):\\n            for i in range(NUM_ROWS - 1):\\n                seq_two.add(board[i][j] + board[i + 1][j])\\n        # Iterate over the words checking if they could be in the board.\\n        for word in words:\\n            in_board = True\\n            for i in range(len(word) - 1):\\n                # For each sequence of two characters in the word, check\\n                # if that sequence or its inverse are in the board.\\n                if (\\n                    word[i : i + 2] not in seq_two\\n                    and word[i + 1] + word[i] not in seq_two\\n                ):\\n                    in_board = False\\n                    break\\n            if not in_board:\\n                continue\\n            # Reverse words with the same character in the first\\n            # four positions.\\n            if word[:4] == word[0] * 4:\\n                word = word[::-1]\\n                reversed_words.add(word)\\n            candidates.append(word)\\n\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Store the words found.\\n        res = set()\\n        # Initialize a Trie with the words in the input that could be in\\n        # the board potentially, the candidates, some of them may have\\n        # been reversed to make finding them more efficient.\\n        trie = Trie(candidates)\\n        # Define a function that explores the board from a given start\\n        # position.\\n        def dfs(row: int, col: int, current: List[str]) -> None:\\n            current.append(board[row][col])\\n            board[row][col] = \".\"\\n            found = trie.contains(current)\\n            # If the current branch is not in the trie, not point on\\n            # exploring any further.\\n            if not found:\\n                board[row][col] = current.pop()\\n                return\\n            # If this is an exact match, add it to the result set.\\n            if found == 2:\\n                w = \"\".join(current)\\n                if w in reversed_words:\\n                    res.add(w[::-1])\\n                    reversed_words.remove(w)\\n                else:\\n                    res.add(w)\\n                trie.remove(w)\\n            # The four directions where neighbors are found.\\n            dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for di, dj in dirs:\\n                i, j = row + di, col + dj\\n                if (\\n                    0 <= i < NUM_ROWS\\n                    and 0 <= j < NUM_COLS\\n                    and board[i][j] != \".\"\\n                ):\\n                    dfs(i, j, current)\\n            # Backtrack.\\n            board[row][col] = current.pop()\\n\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS):\\n                dfs(i, j, [])\\n        return res\\n```\\n\\n#### Runtime: \\n\\nhttps://leetcode.com/problems/word-search-ii/submissions/836918548/\\n\\n![image](https://assets.leetcode.com/users/images/695b2933-f69d-4884-a4b5-322b66aaf94c_1667636295.0872102.png)\\n\\n\\n### If you liked this solution, don\\'t forget to \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4DUPVOTE! \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n# A fast trie implementation, not as readable as using TrieNodes but\\n# more performant.\\n#\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/implement-trie-prefix-tree.py\\n#\\nclass Trie:\\n    def __init__(self, words: List[str] = None):\\n\\t\\t# The variable length stores the total number of children of this node.\\n        self.root = {\"length\": 0}\\n        for word in words:\\n            self.insert(word)\\n\\t\\t\\t\\n\\t# Having a len method helps debug.\\n    def __len__(self) -> int:\\n        return self.root[\"length\"]\\n\\n    # Insert a word into this trie object. O(1) because max word length is 10 chars.\\n    def insert(self, word: str) -> None:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                current[c] = {\"length\": 0}\\n            # There is more complete word under this node.\\n            current[\"length\"] += 1\\n            current = current[c]\\n        current[\"length\"] += 1\\n        current[\"?\"] = True\\n\\n    # Remove a word from this trie object. O(1) because max word length is 10.\\n    def remove(self, word: str) -> None:\\n        current = self.root\\n        current[\"length\"] -= 1\\n        for i, c in enumerate(word):\\n            if c in current:\\n                current[c][\"length\"] -= 1\\n                if current[c][\"length\"] < 1:\\n                    current.pop(c)\\n                    break\\n                else:\\n                    current = current[c]\\n        # If we get to the word leaf but the trie node has children.\\n        if i == len(word) - 1 and \"?\" in current:\\n            current.pop(\"?\")\\n\\n    # Check if a given list of chars is in the trie, it returns 0 if\\n    # not found, 1 if found but not a full word and 2 if a full word.\\n\\t# O(1) because max word length is 10.\\n    def contains(self, word: List[str]) -> int:\\n        current = self.root\\n        for c in word:\\n            if c not in current:\\n                return 0\\n            current = current[c]\\n        return 2 if \"?\" in current else 1\\n```\n```\\n# https://github.com/raul-sauco/coding-challenges/blob/main/leetcode/word-search-ii.py\\n\\n# Time complexity: O(m*n*(4*3^10)) - We iterate over all the positions\\n# on the board, for each, we start a search for any words that can be\\n# constructed from this position, the search will initially move to the\\n# four neighbors, then from there, as long as the characters added are\\n# found in the trie, the search will expand to the three neighbors of\\n# the new cell, since the cell we just came from cannot be visited again.\\n# So, from each position in the matrix, we will potentially do 4*3^10\\n# calls to DFS, since the max depth is equal to the length of the\\n# longest word in the trie and that is a max of 10. In theory that is\\n# still O(1) but it seems significant enough that is worth mentioning it\\n# on the time complexity.\\n#\\n# Space complexity: O(w*c) - The number of characters in all the words\\n# in the input, we store them all in the trie, and potentially also in\\n# the result set even though we would not consider that because it is\\n# used as the output. The call stack will have a max height of 10.\\n#\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Remove words for which one of their two letter combinations\\n        # cannot be found in the board.\\n        seq_two = set()\\n        candidates = []\\n        reversed_words = set()\\n        # Find all sequences of two characters in the board. Only right\\n        # and down.\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS - 1):\\n                seq_two.add(board[i][j] + board[i][j + 1])\\n        for j in range(NUM_COLS):\\n            for i in range(NUM_ROWS - 1):\\n                seq_two.add(board[i][j] + board[i + 1][j])\\n        # Iterate over the words checking if they could be in the board.\\n        for word in words:\\n            in_board = True\\n            for i in range(len(word) - 1):\\n                # For each sequence of two characters in the word, check\\n                # if that sequence or its inverse are in the board.\\n                if (\\n                    word[i : i + 2] not in seq_two\\n                    and word[i + 1] + word[i] not in seq_two\\n                ):\\n                    in_board = False\\n                    break\\n            if not in_board:\\n                continue\\n            # Reverse words with the same character in the first\\n            # four positions.\\n            if word[:4] == word[0] * 4:\\n                word = word[::-1]\\n                reversed_words.add(word)\\n            candidates.append(word)\\n\\n        NUM_ROWS, NUM_COLS = len(board), len(board[0])\\n        # Store the words found.\\n        res = set()\\n        # Initialize a Trie with the words in the input that could be in\\n        # the board potentially, the candidates, some of them may have\\n        # been reversed to make finding them more efficient.\\n        trie = Trie(candidates)\\n        # Define a function that explores the board from a given start\\n        # position.\\n        def dfs(row: int, col: int, current: List[str]) -> None:\\n            current.append(board[row][col])\\n            board[row][col] = \".\"\\n            found = trie.contains(current)\\n            # If the current branch is not in the trie, not point on\\n            # exploring any further.\\n            if not found:\\n                board[row][col] = current.pop()\\n                return\\n            # If this is an exact match, add it to the result set.\\n            if found == 2:\\n                w = \"\".join(current)\\n                if w in reversed_words:\\n                    res.add(w[::-1])\\n                    reversed_words.remove(w)\\n                else:\\n                    res.add(w)\\n                trie.remove(w)\\n            # The four directions where neighbors are found.\\n            dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for di, dj in dirs:\\n                i, j = row + di, col + dj\\n                if (\\n                    0 <= i < NUM_ROWS\\n                    and 0 <= j < NUM_COLS\\n                    and board[i][j] != \".\"\\n                ):\\n                    dfs(i, j, current)\\n            # Backtrack.\\n            board[row][col] = current.pop()\\n\\n        for i in range(NUM_ROWS):\\n            for j in range(NUM_COLS):\\n                dfs(i, j, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516101,
                "title": "c-simple-backtracking-dfs-trie-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node* links[26]={NULL};\\n        string flag;\\n        void put(char ch,Node* node){\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* next(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n        void set(string w){\\n            flag=w;\\n        }\\n        int isEnd(){\\n            return flag.length();\\n        }\\n    };\\n    int dr[4] = {1, -1, 0, 0}; \\n    int dc[4] = {0, 0, -1, 1}; \\n    int n,m;\\n    void dfs(int r, int c, vector<vector<char>>& grid, Node *trie, vector<string>&ans) {\\n        if (r < 0 || r >= n || c < 0 || c >= m || grid[r][c]==\\'0\\' || trie->next(grid[r][c])==nullptr) return;\\n        char ch=grid[r][c];\\n        trie=trie->next(ch);\\n        if(trie->isEnd()){\\n            ans.push_back(trie->flag);\\n            trie->flag=\"\";\\n        }\\n        grid[r][c] = \\'0\\';\\n        for (int i = 0; i < 4; i++) { \\n            dfs(r + dr[i], c + dc[i],grid,trie,ans);\\n        }\\n        grid[r][c]=ch;\\n    }\\n    \\n    void insert(string s,Node *root){\\n        Node *node=root;\\n        for(int i=0;i<s.length();i++){\\n            if(node->links[s[i]-\\'a\\']==nullptr){\\n                node->put(s[i],new Node);\\n            }\\n            node=node->next(s[i]);\\n        }\\n        node->set(s);\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n=board.size();\\n        m=board[0].size();\\n        Node *trie=new Node();\\n        for(auto w:words){\\n            insert(w,trie);\\n        }\\n        vector<string>ans;\\n        for(int j=0;j<n;j++){\\n            for(int k=0;k<m;k++){\\n                    dfs(j,k,board,trie,ans);\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node* links[26]={NULL};\\n        string flag;\\n        void put(char ch,Node* node){\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* next(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n        void set(string w){\\n            flag=w;\\n        }\\n        int isEnd(){\\n            return flag.length();\\n        }\\n    };\\n    int dr[4] = {1, -1, 0, 0}; \\n    int dc[4] = {0, 0, -1, 1}; \\n    int n,m;\\n    void dfs(int r, int c, vector<vector<char>>& grid, Node *trie, vector<string>&ans) {\\n        if (r < 0 || r >= n || c < 0 || c >= m || grid[r][c]==\\'0\\' || trie->next(grid[r][c])==nullptr) return;\\n        char ch=grid[r][c];\\n        trie=trie->next(ch);\\n        if(trie->isEnd()){\\n            ans.push_back(trie->flag);\\n            trie->flag=\"\";\\n        }\\n        grid[r][c] = \\'0\\';\\n        for (int i = 0; i < 4; i++) { \\n            dfs(r + dr[i], c + dc[i],grid,trie,ans);\\n        }\\n        grid[r][c]=ch;\\n    }\\n    \\n    void insert(string s,Node *root){\\n        Node *node=root;\\n        for(int i=0;i<s.length();i++){\\n            if(node->links[s[i]-\\'a\\']==nullptr){\\n                node->put(s[i],new Node);\\n            }\\n            node=node->next(s[i]);\\n        }\\n        node->set(s);\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n=board.size();\\n        m=board[0].size();\\n        Node *trie=new Node();\\n        for(auto w:words){\\n            insert(w,trie);\\n        }\\n        vector<string>ans;\\n        for(int j=0;j<n;j++){\\n            for(int k=0;k<m;k++){\\n                    dfs(j,k,board,trie,ans);\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354804,
                "title": "c-trie-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    class Trie {\\n        public:\\n            Trie *arr[26];\\n            bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(int i=0; i<word.size(); ++i){\\n            int idx = word[i]-\\'a\\';\\n            if(!cur->arr[idx]){\\n                cur->arr[idx] = new Trie();\\n            }\\n            cur=cur->arr[idx];\\n        }\\n        cur->isEnd = true;\\n        return;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board, int x, int y){\\n        int row = board.size(), col = board[0].size();\\n        if(x<0 || x>=row || y<0 || y>=col || board[x][y]==\\'*\\') return false;\\n        return true;\\n    }\\n    \\n    void search(vector<vector<char>>& board, int x, int y, Trie* root, string& str){\\n        if(board[x][y]==\\'*\\') return;\\n        \\n        int idx = board[x][y]-\\'a\\';\\n        if(!root->arr[idx]) return;\\n        \\n        str.push_back(board[x][y]);\\n        \\n        char ch = board[x][y];\\n        board[x][y]=\\'*\\';\\n        \\n        if(root->arr[idx]->isEnd){\\n            ans.push_back(str);\\n            root->arr[idx]->isEnd = false;\\n        }\\n        \\n        for(int i=0;i<4;++i){\\n            int x1 = x+dx[i], y1 = y+dy[i];\\n            if(isValid(board,x1,y1)) search(board,x1,y1,root->arr[idx],str);\\n        }\\n        \\n        board[x][y]=ch;\\n        str.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(auto &word : words) insert(word,root);\\n        \\n        int row = board.size(), col = board[0].size();\\n        string str=\"\";\\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                search(board,i,j,root,str);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    class Trie {\\n        public:\\n            Trie *arr[26];\\n            bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(int i=0; i<word.size(); ++i){\\n            int idx = word[i]-\\'a\\';\\n            if(!cur->arr[idx]){\\n                cur->arr[idx] = new Trie();\\n            }\\n            cur=cur->arr[idx];\\n        }\\n        cur->isEnd = true;\\n        return;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board, int x, int y){\\n        int row = board.size(), col = board[0].size();\\n        if(x<0 || x>=row || y<0 || y>=col || board[x][y]==\\'*\\') return false;\\n        return true;\\n    }\\n    \\n    void search(vector<vector<char>>& board, int x, int y, Trie* root, string& str){\\n        if(board[x][y]==\\'*\\') return;\\n        \\n        int idx = board[x][y]-\\'a\\';\\n        if(!root->arr[idx]) return;\\n        \\n        str.push_back(board[x][y]);\\n        \\n        char ch = board[x][y];\\n        board[x][y]=\\'*\\';\\n        \\n        if(root->arr[idx]->isEnd){\\n            ans.push_back(str);\\n            root->arr[idx]->isEnd = false;\\n        }\\n        \\n        for(int i=0;i<4;++i){\\n            int x1 = x+dx[i], y1 = y+dy[i];\\n            if(isValid(board,x1,y1)) search(board,x1,y1,root->arr[idx],str);\\n        }\\n        \\n        board[x][y]=ch;\\n        str.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(auto &word : words) insert(word,root);\\n        \\n        int row = board.size(), col = board[0].size();\\n        string str=\"\";\\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                search(board,i,j,root,str);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308130,
                "title": "python-trie-and-ordereddict-less-memory-and-not-modifying-the-original-board",
                "content": "In order to avoid reusing the same letters more than once, some solutions temporary modify the array: https://leetcode.com/problems/word-search-ii/discuss/59790/Python-dfs-solution-(directly-use-Trie-implemented).\\n\\nOther solutions keep track of the visited letters in a matrix.\\nhttps://leetcode.com/problems/word-search-ii/discuss/59864/Python-code-use-trie-and-dfs-380ms\\n\\nI simply used an OrderedDict to keep track of the visited letters (and to create the final path for the word):\\n```\\nfrom collections import OrderedDict, defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isEnd = False\\n\\n    def addWord(self, word):\\n        if not word:\\n            self.isEnd = True\\n            return\\n        self.children[word[0]].addWord(word[1:])\\n\\nclass Solution:\\n\\n    def findWords(self, board, words):\\n        self.root = TrieNode(); self.found = set(); self.R = len(board); self.C = len(board[0])\\n        \\n        for word in words:\\n            self.root.addWord(word)\\n\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                self.traverse(board, r, c, self.root, OrderedDict())\\n        return list(self.found)\\n\\n    def traverse(self, board, r, c, trieNode, visited):\\n        \\n        if trieNode.isEnd:\\n            self.found.add(\\'\\'.join(visited.values()))\\n\\n        if r < 0 or c < 0 or r >= self.R or c >= self.C or board[r][c] not in trieNode.children or (r,c) in visited:\\n            return\\n        \\n        visited[(r,c)] = board[r][c]\\n        self.traverse(board, r + 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r - 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c - 1, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c + 1, trieNode.children[board[r][c]], visited)\\n        del visited[(r,c)]\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nfrom collections import OrderedDict, defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.isEnd = False\\n\\n    def addWord(self, word):\\n        if not word:\\n            self.isEnd = True\\n            return\\n        self.children[word[0]].addWord(word[1:])\\n\\nclass Solution:\\n\\n    def findWords(self, board, words):\\n        self.root = TrieNode(); self.found = set(); self.R = len(board); self.C = len(board[0])\\n        \\n        for word in words:\\n            self.root.addWord(word)\\n\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                self.traverse(board, r, c, self.root, OrderedDict())\\n        return list(self.found)\\n\\n    def traverse(self, board, r, c, trieNode, visited):\\n        \\n        if trieNode.isEnd:\\n            self.found.add(\\'\\'.join(visited.values()))\\n\\n        if r < 0 or c < 0 or r >= self.R or c >= self.C or board[r][c] not in trieNode.children or (r,c) in visited:\\n            return\\n        \\n        visited[(r,c)] = board[r][c]\\n        self.traverse(board, r + 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r - 1, c, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c - 1, trieNode.children[board[r][c]], visited)\\n        self.traverse(board, r, c + 1, trieNode.children[board[r][c]], visited)\\n        del visited[(r,c)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265145,
                "title": "swift-solution-with-dfs-trie",
                "content": "> 37 / 37 test cases passed.\\n> **Status**: Accepted\\n> **Runtime**: 404 ms\\n> **Memory Usage**: 25.5 MB\\n\\n```swift\\nclass Solution {\\n    class TrieNode {\\n        var word: String?\\n        var children = [Character: TrieNode]()\\n    }\\n\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        let trieRoot = buildTrie(words)\\n\\n        var board = board\\n        var result = Set<String>()\\n        for i in 0..<board.count {\\n            for j in 0..<board[i].count {\\n                dfs(&board, i, j, trieRoot, &result)\\n            }\\n        }\\n        \\n        return Array(result)\\n    }\\n    \\n    func dfs(_ board: inout [[Character]], _ i: Int, _ j: Int, _ trieNode: TrieNode, _ result: inout Set<String>) {\\n        if let word = trieNode.word {\\n            result.insert(word)\\n        }\\n        \\n        guard i >= 0 && j >= 0 && i < board.count && j < board[i].count else { return }\\n        guard board[i][j] != \"#\" else { return }\\n        \\n        let char = board[i][j]\\n        guard let nextTrieNode = trieNode.children[char] else { return }\\n        \\n        var board = board\\n        board[i][j] = \"#\"\\n        for (nexti, nextj) in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] {\\n            dfs(&board, nexti, nextj, nextTrieNode, &result)\\n        }\\n        board[i][j] = char\\n    }\\n    \\n    func buildTrie(_ words: [String]) -> TrieNode {\\n        let root = TrieNode()\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if node.children[char] == nil {\\n                    node.children[char] = TrieNode()\\n                }\\n                node = node.children[char]!\\n            }\\n            node.word = word\\n        }\\n        return root\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    class TrieNode {\\n        var word: String?\\n        var children = [Character: TrieNode]()\\n    }\\n\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        let trieRoot = buildTrie(words)\\n\\n        var board = board\\n        var result = Set<String>()\\n        for i in 0..<board.count {\\n            for j in 0..<board[i].count {\\n                dfs(&board, i, j, trieRoot, &result)\\n            }\\n        }\\n        \\n        return Array(result)\\n    }\\n    \\n    func dfs(_ board: inout [[Character]], _ i: Int, _ j: Int, _ trieNode: TrieNode, _ result: inout Set<String>) {\\n        if let word = trieNode.word {\\n            result.insert(word)\\n        }\\n        \\n        guard i >= 0 && j >= 0 && i < board.count && j < board[i].count else { return }\\n        guard board[i][j] != \"#\" else { return }\\n        \\n        let char = board[i][j]\\n        guard let nextTrieNode = trieNode.children[char] else { return }\\n        \\n        var board = board\\n        board[i][j] = \"#\"\\n        for (nexti, nextj) in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] {\\n            dfs(&board, nexti, nextj, nextTrieNode, &result)\\n        }\\n        board[i][j] = char\\n    }\\n    \\n    func buildTrie(_ words: [String]) -> TrieNode {\\n        let root = TrieNode()\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if node.children[char] == nil {\\n                    node.children[char] = TrieNode()\\n                }\\n                node = node.children[char]!\\n            }\\n            node.word = word\\n        }\\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227044,
                "title": "c-trie",
                "content": "This is a combination of [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) and [Word Search](https://leetcode.com/problems/word-search/). To remove duplicates in the result, a word is marked as a non-word after it has been added to the result. Also once the size of the result is not smaller than that of the dictionary, we return early.\\n\\n```cpp\\nclass TrieNode {\\npublic:\\n    bool word;\\n    TrieNode* children[26];\\n    TrieNode() : word(false) {\\n        memset(children, 0, sizeof(children));\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {}\\n    \\n    void add(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node -> children[c - \\'a\\']) {\\n                node -> children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node -> children[c - \\'a\\'];\\n        }\\n        node -> word = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode* node = leaf(word);\\n        if (node && node -> word) {\\n            node -> word = false;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool startsWith(string word) {\\n        return leaf(word);\\n    }\\nprivate:\\n    TrieNode* root = new TrieNode();\\n    \\n    TrieNode* leaf(string word) {\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.size() && node; i++) {\\n            node = node -> children[word[i] - \\'a\\'];\\n        }\\n        return node;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie trie = Trie();\\n        for (string word : words) {\\n            trie.add(word);\\n        }\\n        int m = board.size(), n = m ? board[0].size() : 0;\\n        vector<string> ans;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                find(trie, board, ans, \"\", i, j);\\n                if (ans.size() >= words.size()) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void find(Trie& trie, vector<vector<char>>& board, vector<string>& ans, string word, int i, int j) {\\n        int m = board.size(), n = board[0].size();\\n        if (i >= 0 && i < m && j >= 0 && j < n && board[i][j]) {\\n            word += board[i][j];\\n            if (!trie.startsWith(word)) {\\n                return;\\n            }\\n            if (trie.search(word)) {\\n                ans.push_back(word);\\n            }\\n            board[i][j] = 0;\\n            find(trie, board, ans, word, i - 1, j);\\n            find(trie, board, ans, word, i + 1, j);\\n            find(trie, board, ans, word, i, j - 1);\\n            find(trie, board, ans, word, i, j + 1);\\n            board[i][j] = word.back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```cpp\\nclass TrieNode {\\npublic:\\n    bool word;\\n    TrieNode* children[26];\\n    TrieNode() : word(false) {\\n        memset(children, 0, sizeof(children));\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {}\\n    \\n    void add(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node -> children[c - \\'a\\']) {\\n                node -> children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node -> children[c - \\'a\\'];\\n        }\\n        node -> word = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode* node = leaf(word);\\n        if (node && node -> word) {\\n            node -> word = false;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool startsWith(string word) {\\n        return leaf(word);\\n    }\\nprivate:\\n    TrieNode* root = new TrieNode();\\n    \\n    TrieNode* leaf(string word) {\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.size() && node; i++) {\\n            node = node -> children[word[i] - \\'a\\'];\\n        }\\n        return node;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie trie = Trie();\\n        for (string word : words) {\\n            trie.add(word);\\n        }\\n        int m = board.size(), n = m ? board[0].size() : 0;\\n        vector<string> ans;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                find(trie, board, ans, \"\", i, j);\\n                if (ans.size() >= words.size()) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void find(Trie& trie, vector<vector<char>>& board, vector<string>& ans, string word, int i, int j) {\\n        int m = board.size(), n = board[0].size();\\n        if (i >= 0 && i < m && j >= 0 && j < n && board[i][j]) {\\n            word += board[i][j];\\n            if (!trie.startsWith(word)) {\\n                return;\\n            }\\n            if (trie.search(word)) {\\n                ans.push_back(word);\\n            }\\n            board[i][j] = 0;\\n            find(trie, board, ans, word, i - 1, j);\\n            find(trie, board, ans, word, i + 1, j);\\n            find(trie, board, ans, word, i, j - 1);\\n            find(trie, board, ans, word, i, j + 1);\\n            board[i][j] = word.back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59905,
                "title": "python-ac-solution",
                "content": "    class TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.flag = False\\n\\n    class Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.result = []\\n\\n    def insert(self, word):\\n        node = self.root\\n        for letter in word:\\n            node = node.children[letter]\\n        node.flag = True\\n\\n    def findWords(self, board, words):\\n        for w in words:\\n            self.insert(w)\\n        for j in range(len(board)):\\n            for i in range(len(board[0])):\\n                self.dfs(self.root, board, j, i)\\n        return self.result\\n\\n    def dfs(self, node, board, j, i, word=''):\\n        if node.flag:\\n            self.result.append(word)\\n            node.flag = False\\n        if 0 <= j < len(board) and 0 <= i < len(board[0]):\\n            char = board[j][i]\\n            child = node.children.get(char)\\n            if child is not None:\\n                word += char\\n                board[j][i] = None\\n                self.dfs(child, board, j + 1, i, word)\\n                self.dfs(child, board, j - 1, i, word)\\n                self.dfs(child, board, j, i + 1, word)\\n                self.dfs(child, board, j, i - 1, word)\\n                board[j][i] = char",
                "solutionTags": [],
                "code": "    class TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.flag = False\\n\\n    class Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.result = []\\n\\n    def insert(self, word):\\n        node = self.root\\n        for letter in word:\\n            node = node.children[letter]\\n        node.flag = True\\n\\n    def findWords(self, board, words):\\n        for w in words:\\n            self.insert(w)\\n        for j in range(len(board)):\\n            for i in range(len(board[0])):\\n                self.dfs(self.root, board, j, i)\\n        return self.result\\n\\n    def dfs(self, node, board, j, i, word=''):\\n        if node.flag:\\n            self.result.append(word)\\n            node.flag = False\\n        if 0 <= j < len(board) and 0 <= i < len(board[0]):\\n            char = board[j][i]\\n            child = node.children.get(char)\\n            if child is not None:\\n                word += char\\n                board[j][i] = None\\n                self.dfs(child, board, j + 1, i, word)\\n                self.dfs(child, board, j - 1, i, word)\\n                self.dfs(child, board, j, i + 1, word)\\n                self.dfs(child, board, j, i - 1, word)\\n                board[j][i] = char",
                "codeTag": "Java"
            },
            {
                "id": 2781724,
                "title": "c-clean-code-dfs-trie",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply dfs from every cell to find a path that correspond to a string and use trie to check if it is a required string.\\n\\n# Code\\n```\\nclass Solution {\\n    struct trie {\\n        trie *child[26];\\n        bool isEnd;\\n        trie() {\\n            for(int i = 0; i < 26; i++) child[i] = NULL;\\n            isEnd = false;\\n        }\\n    };\\n    trie *root = new trie();\\n    void insert(string s) {\\n        trie *curr = root;\\n        for(int i = 0; i < s.size(); i++) {\\n            int id = s[i] - \\'a\\';\\n            if(curr->child[id] == NULL) curr->child[id] = new trie();\\n            curr = curr->child[id];\\n        }\\n        curr->isEnd = true;\\n    }\\n    vector<vector<char>> board; int n, m; vector<vector<bool>> vis; vector<string> ans;\\n    string str;\\n    void dfs(trie *curr, int y, int x) {\\n        if(curr->isEnd) {\\n            ans.push_back(str);\\n            curr->isEnd = false;\\n        }\\n        if(y < 0 || y >= n || x < 0 || x >= m || vis[y][x]) return;\\n        int id = board[y][x] - \\'a\\';\\n        if(curr->child[id] == NULL) return;\\n        vis[y][x] = true;\\n        str.push_back(board[y][x]);\\n        dfs(curr->child[id], y + 1, x);\\n        dfs(curr->child[id], y - 1, x);\\n        dfs(curr->child[id], y, x + 1);\\n        dfs(curr->child[id], y, x - 1);\\n        str.pop_back();\\n        vis[y][x] = false;\\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for (auto &word: words) insert(word);\\n        this->board = board; n = board.size(); m = board[0].size();\\n        vis.resize(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                dfs(root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct trie {\\n        trie *child[26];\\n        bool isEnd;\\n        trie() {\\n            for(int i = 0; i < 26; i++) child[i] = NULL;\\n            isEnd = false;\\n        }\\n    };\\n    trie *root = new trie();\\n    void insert(string s) {\\n        trie *curr = root;\\n        for(int i = 0; i < s.size(); i++) {\\n            int id = s[i] - \\'a\\';\\n            if(curr->child[id] == NULL) curr->child[id] = new trie();\\n            curr = curr->child[id];\\n        }\\n        curr->isEnd = true;\\n    }\\n    vector<vector<char>> board; int n, m; vector<vector<bool>> vis; vector<string> ans;\\n    string str;\\n    void dfs(trie *curr, int y, int x) {\\n        if(curr->isEnd) {\\n            ans.push_back(str);\\n            curr->isEnd = false;\\n        }\\n        if(y < 0 || y >= n || x < 0 || x >= m || vis[y][x]) return;\\n        int id = board[y][x] - \\'a\\';\\n        if(curr->child[id] == NULL) return;\\n        vis[y][x] = true;\\n        str.push_back(board[y][x]);\\n        dfs(curr->child[id], y + 1, x);\\n        dfs(curr->child[id], y - 1, x);\\n        dfs(curr->child[id], y, x + 1);\\n        dfs(curr->child[id], y, x - 1);\\n        str.pop_back();\\n        vis[y][x] = false;\\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for (auto &word: words) insert(word);\\n        this->board = board; n = board.size(); m = board[0].size();\\n        vis.resize(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                dfs(root, i, j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781438,
                "title": "don-t-know-trie-c-dfs-hashmap",
                "content": "<b>Main Idea:</b>\\nAt first store all the prefixes of  all the words in a hashmap. Now run a dfs from each cell and try to construct string that can be found in the hashmap.\\nAfter running dfs from all cells check if the given words was construced during dfs.\\n<b>Sample Code:</b>\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>vis;//mark the cell during dfs\\n    unordered_map<string,bool>found;//strings found during dfs\\n    unordered_map<string,bool>can;// prefixes of all the words\\n    int n,m;\\n\\tconst int fx[4]={0,0,1,-1};\\n    const int fy[4]={1,-1,0,0};\\npublic:\\n    void dfs(int x,int y,vector<vector<char>>& board,string &s){\\n        if(can.find(s)==can.end())return;// return if the string is invalid\\n        if(s.size()==10)return; // words length won\\'t be greater than 10. so we can just return.\\n        s+=board[x][y];\\n        found[s] = 1;\\n        vis[x][y] = 1;\\n        for(int i=0;i<4;i++){\\n            int dx = x+fx[i];\\n            int dy = y+fy[i];\\n            if(dx>=0 && dx<n && dy>=0 && dy<m){\\n                if(!vis[dx][dy]){\\n                    dfs(dx,dy,board,s);\\n                }\\n            }\\n        }\\n        s.pop_back();\\n        vis[x][y] = 0;\\n        return ;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n = board.size();\\n        m = board[0].size();\\n        vector<pair<int,int>>pos[26];\\n        can[\"\"]=true;\\n        for(auto&s:words){\\n            string ts;\\n            for(auto&c:s){\\n                ts+=c;\\n                can[ts] = 1;\\n            }\\n        }\\n        vis.resize(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                string s;\\n                dfs(i,j,board,s);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto&s:words){\\n          if(found[s])ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>vis;//mark the cell during dfs\\n    unordered_map<string,bool>found;//strings found during dfs\\n    unordered_map<string,bool>can;// prefixes of all the words\\n    int n,m;\\n\\tconst int fx[4]={0,0,1,-1};\\n    const int fy[4]={1,-1,0,0};\\npublic:\\n    void dfs(int x,int y,vector<vector<char>>& board,string &s){\\n        if(can.find(s)==can.end())return;// return if the string is invalid\\n        if(s.size()==10)return; // words length won\\'t be greater than 10. so we can just return.\\n        s+=board[x][y];\\n        found[s] = 1;\\n        vis[x][y] = 1;\\n        for(int i=0;i<4;i++){\\n            int dx = x+fx[i];\\n            int dy = y+fy[i];\\n            if(dx>=0 && dx<n && dy>=0 && dy<m){\\n                if(!vis[dx][dy]){\\n                    dfs(dx,dy,board,s);\\n                }\\n            }\\n        }\\n        s.pop_back();\\n        vis[x][y] = 0;\\n        return ;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        n = board.size();\\n        m = board[0].size();\\n        vector<pair<int,int>>pos[26];\\n        can[\"\"]=true;\\n        for(auto&s:words){\\n            string ts;\\n            for(auto&c:s){\\n                ts+=c;\\n                can[ts] = 1;\\n            }\\n        }\\n        vis.resize(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                string s;\\n                dfs(i,j,board,s);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto&s:words){\\n          if(found[s])ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780879,
                "title": "my-solution-thought-process-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst idea, is simply looping over every word and use the solution found for [Word Search I](https://leetcode.com/problems/word-search/description/).\\nAs expected, TLE...\\n\\nUsing trie is helpful. Because let\\'s say we have a word AAAA and a second word AAAAB, by doing two separate DFS, we have to go over the same prefix \\'AAAA\\' twice. When it gets longer, we waste a lot of time. The trie structure solve this problem, AAAAB is basically AAAA + B in here, and we can do a single branching till the very end and not stopping at the last A. (although marking it as the end of a word)\\n\\nNow that we have constructed the trie, we can build our branching algo that goes throw the trie. DFS for example.\\nHowever doing it naively still gives TLE. (63/64 :d)\\nSay given a trie node \\'a\\', it has the following child nodes: [\\'b\\', \\'c\\']. But we already found the word \\'ab\\' to be valid. If we keep \\'b\\' in the list, everytime we see a \\'b\\', we will explore it again. Basically we are searching on all the child nodes, including the ones that we\\'ve already found a solution, which is again a waste.\\nThe trick is to remove those nodes from the child list if they are finished (namely we already found a solution for it.) We can do that because we know the words are unique. For that, we can use the return value, which is bottom-up.\\n\\nSo below is the final solution:\\n\\n# Code\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.childs = {}\\n        self.end = False\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m, n = len(board), len(board[0])\\n\\n        ### construct trie\\n        self.trie_root = TrieNode()\\n        for word in words:\\n            cur = self.trie_root\\n            for char in word:\\n                if char not in cur.childs:\\n                    cur.childs[char] = TrieNode()\\n                cur = cur.childs[char]\\n            cur.end = True\\n\\n\\n        ### dfs branching algo\\n        def dfs(r, c, node, path):\\n            nonlocal m, n, out\\n            if node.end:\\n                out.add(path)\\n                if len(node.childs) == 0:\\n                    return True  # i.e. we have completed the whole branch (word end at leaf)\\n            \\n            if len(node.childs) > 0:\\n                for rr, cc in [(r-1, c), (r+1, c), (r, c+1), (r, c-1)]:\\n                    if rr >= 0 and rr < m and cc >= 0 and cc < n:\\n                        letter = board[rr][cc]\\n                        if (rr, cc) not in seen and letter in node.childs:\\n                            seen.add((rr, cc))\\n                            done = dfs(rr, cc, node.childs[letter], path+letter)\\n                            if done:  # if the branch is completed, throw it away !\\n                                node.childs.pop(letter)\\n                            seen.remove((rr, cc))  # backtrack\\n            \\n            return len(node.childs)==0  # keep the branch only if not empty (this will backprop to top nodes)\\n            # by structure, a leaf node can only be either a word end, or a branch we started popping already.\\n\\n\\n        ### main\\n        out = set()  # use set to avoid duplicates\\n        for r in range(m):\\n            for c in range(n):\\n                letter = board[r][c]\\n                if letter in self.trie_root.childs:\\n                    seen = set([(r, c)])\\n                    dfs(r, c, self.trie_root.childs[letter], letter)\\n\\n        return list(out)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.childs = {}\\n        self.end = False\\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m, n = len(board), len(board[0])\\n\\n        ### construct trie\\n        self.trie_root = TrieNode()\\n        for word in words:\\n            cur = self.trie_root\\n            for char in word:\\n                if char not in cur.childs:\\n                    cur.childs[char] = TrieNode()\\n                cur = cur.childs[char]\\n            cur.end = True\\n\\n\\n        ### dfs branching algo\\n        def dfs(r, c, node, path):\\n            nonlocal m, n, out\\n            if node.end:\\n                out.add(path)\\n                if len(node.childs) == 0:\\n                    return True  # i.e. we have completed the whole branch (word end at leaf)\\n            \\n            if len(node.childs) > 0:\\n                for rr, cc in [(r-1, c), (r+1, c), (r, c+1), (r, c-1)]:\\n                    if rr >= 0 and rr < m and cc >= 0 and cc < n:\\n                        letter = board[rr][cc]\\n                        if (rr, cc) not in seen and letter in node.childs:\\n                            seen.add((rr, cc))\\n                            done = dfs(rr, cc, node.childs[letter], path+letter)\\n                            if done:  # if the branch is completed, throw it away !\\n                                node.childs.pop(letter)\\n                            seen.remove((rr, cc))  # backtrack\\n            \\n            return len(node.childs)==0  # keep the branch only if not empty (this will backprop to top nodes)\\n            # by structure, a leaf node can only be either a word end, or a branch we started popping already.\\n\\n\\n        ### main\\n        out = set()  # use set to avoid duplicates\\n        for r in range(m):\\n            for c in range(n):\\n                letter = board[r][c]\\n                if letter in self.trie_root.childs:\\n                    seen = set([(r, c)])\\n                    dfs(r, c, self.trie_root.childs[letter], letter)\\n\\n        return list(out)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779728,
                "title": "java-kotlin-clear-trie-back-tracking-solution",
                "content": "Java\\n```\\nclass Solution {\\n    private TrieNode root = new TrieNode();\\n    private int m = 0;\\n    private int n = 0;\\n    private Set<String> set = new HashSet<>();\\n    private int[] dir = new int[] {1, 0, -1, 0, 1};\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String w : words) {\\n            insert(w);\\n        }\\n        m = board.length;\\n        n = board[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bt(i, j, board, new boolean[m][n], root);\\n            }\\n        }\\n        \\n        return new ArrayList<String>(set);\\n    }\\n    \\n    private void bt(int x, int y, char[][] board, boolean[][] visited, TrieNode node) {\\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) {\\n            return;\\n        }\\n        \\n        int idx = board[x][y] - \\'a\\';\\n        if (node.children[idx] == null) {\\n            return;\\n        }\\n        \\n        if (node.children[idx].w != null) {\\n            set.add(node.children[idx].w); // Notice: do not return. cause there may have a longer word!\\n        }\\n        \\n        visited[x][y] = true;\\n        \\n        for (int i = 0; i < dir.length-1; i++) {\\n            bt(x+dir[i], y + dir[i+1], board, visited, node.children[idx]);\\n        }\\n        \\n        visited[x][y] = false;\\n    }\\n    \\n    private void insert(String w) {\\n        TrieNode node = root;\\n        for (char ch : w.toCharArray()) {\\n            int idx = ch - \\'a\\';\\n            if (node.children[idx] == null) {\\n                node.children[idx] = new TrieNode();\\n            }\\n            node = node.children[idx];\\n        }\\n        \\n        node.w = w;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    String w;\\n}\\n```\\nKotlin\\n```\\nclass Solution {\\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        val m = board.size\\n        val n = board[0].size\\n        \\n        val dir = intArrayOf(1, 0, -1, 0, 1)\\n        \\n        val root = TrieNode()\\n        val res = mutableListOf<String>()\\n        \\n        fun insert(w: String) {\\n            var node = root\\n            for (ch in w.toCharArray()) {\\n                node = node.children.getOrPut(ch) { TrieNode() }\\n            }\\n            node.w = w\\n        }\\n        \\n        for (w in words) {\\n            insert(w)\\n        }\\n        \\n        fun bt(x: Int, y: Int, board: Array<CharArray>, visited: Array<BooleanArray>, node: TrieNode) {\\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) return\\n            \\n            val next = node.children.get(board[x][y])\\n            \\n            next ?: return\\n            \\n            next.w?.let {\\n                res.add(it)\\n                next.w = null\\n            }\\n            \\n            visited[x][y] = true\\n            for (i in 0 until dir.size-1) {\\n                bt(x + dir[i], y + dir[i+1], board, visited, next)\\n            }\\n            visited[x][y] = false\\n        }\\n        \\n        for (i in 0 until m) {\\n            for (j in 0 until n) {\\n                bt(i, j, board, Array(m) { BooleanArray(n) }, root)\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n\\nclass TrieNode {\\n    val children = mutableMapOf<Char, TrieNode>()\\n    var w: String? = null\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    private TrieNode root = new TrieNode();\\n    private int m = 0;\\n    private int n = 0;\\n    private Set<String> set = new HashSet<>();\\n    private int[] dir = new int[] {1, 0, -1, 0, 1};\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        for (String w : words) {\\n            insert(w);\\n        }\\n        m = board.length;\\n        n = board[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bt(i, j, board, new boolean[m][n], root);\\n            }\\n        }\\n        \\n        return new ArrayList<String>(set);\\n    }\\n    \\n    private void bt(int x, int y, char[][] board, boolean[][] visited, TrieNode node) {\\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) {\\n            return;\\n        }\\n        \\n        int idx = board[x][y] - \\'a\\';\\n        if (node.children[idx] == null) {\\n            return;\\n        }\\n        \\n        if (node.children[idx].w != null) {\\n            set.add(node.children[idx].w); // Notice: do not return. cause there may have a longer word!\\n        }\\n        \\n        visited[x][y] = true;\\n        \\n        for (int i = 0; i < dir.length-1; i++) {\\n            bt(x+dir[i], y + dir[i+1], board, visited, node.children[idx]);\\n        }\\n        \\n        visited[x][y] = false;\\n    }\\n    \\n    private void insert(String w) {\\n        TrieNode node = root;\\n        for (char ch : w.toCharArray()) {\\n            int idx = ch - \\'a\\';\\n            if (node.children[idx] == null) {\\n                node.children[idx] = new TrieNode();\\n            }\\n            node = node.children[idx];\\n        }\\n        \\n        node.w = w;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    String w;\\n}\\n```\n```\\nclass Solution {\\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        val m = board.size\\n        val n = board[0].size\\n        \\n        val dir = intArrayOf(1, 0, -1, 0, 1)\\n        \\n        val root = TrieNode()\\n        val res = mutableListOf<String>()\\n        \\n        fun insert(w: String) {\\n            var node = root\\n            for (ch in w.toCharArray()) {\\n                node = node.children.getOrPut(ch) { TrieNode() }\\n            }\\n            node.w = w\\n        }\\n        \\n        for (w in words) {\\n            insert(w)\\n        }\\n        \\n        fun bt(x: Int, y: Int, board: Array<CharArray>, visited: Array<BooleanArray>, node: TrieNode) {\\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) return\\n            \\n            val next = node.children.get(board[x][y])\\n            \\n            next ?: return\\n            \\n            next.w?.let {\\n                res.add(it)\\n                next.w = null\\n            }\\n            \\n            visited[x][y] = true\\n            for (i in 0 until dir.size-1) {\\n                bt(x + dir[i], y + dir[i+1], board, visited, next)\\n            }\\n            visited[x][y] = false\\n        }\\n        \\n        for (i in 0 until m) {\\n            for (j in 0 until n) {\\n                bt(i, j, board, Array(m) { BooleanArray(n) }, root)\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n\\nclass TrieNode {\\n    val children = mutableMapOf<Char, TrieNode>()\\n    var w: String? = null\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072973,
                "title": "trie-in-simple-words",
                "content": "**hello guys,**\\nthis is very simple explanation about **trie**\\n\\nstart explaining from basic : \\n**Question link** : https://leetcode.com/problems/implement-trie-prefix-tree/\\n\\n**declare trie like this :**\\n```\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n```\\n\\nimport trie to main class :\\n`Trie* node = new Trie();`\\n\\nuse this to declare as local trie node : \\n`Trie* cr=node;`\\n\\n**if you are already have Trie class then declare trie as :**\\n```\\nbool end=false;\\nTrie* children[27]={};\\n```\\n\\nand use as local node like this : \\n`Trie* node=this;`\\n\\n**insert a string to trie :**\\n```\\nfor(int i=0;i<s.size();++i)\\n{\\n    if(!node->children[s[i]-\\'a\\']) node->children[s[i]-\\'a\\']=new Trie();\\n    node=node->children[s[i]-\\'a\\'];\\n}\\nnode->end=true;\\n```\\n\\n**search string in trie :**\\n\\n        Trie* node=this;\\n        \\n        for(int i=0;i<s.size();++i)\\n        {\\n            if(!node->children[s[i]-\\'a\\']) return false;\\n            node=node->children[s[i]-\\'a\\'];\\n        }\\n        \\n        return node->end;\\n\\n\\n*this is enough for trie.\\nwe can do every question on trie by using just insertion and search part.\\nthere are some variations in different differetn questions.\\nso we can modify as required, but nothing will be new in modifiocation*.\\n\\n\\n**Solution for \"Word search ii\"**\\n**question link** : [https://leetcode.com/problems/word-search-ii/] \\n\\n1. insert all string to trie\\n2. start bfs from every cell of the matrix that if a[i][j] is availabe in trie or not, if a[i][j] is in trie then go for next unvisited cells, when cr->end==true in trie, it means we are at end position of string, that\\'s how we find a string in matrix.\\n\\n\\n**Code :**\\n\\n```\\n#define pb push_back\\nconst int N=14;\\n\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n\\n\\nclass Solution {\\npublic:\\n    Trie* node = new Trie();\\n    \\n    vector<string>ans;\\n    set<string>st;\\n    int vis[N][N];\\n    void fun(Trie* cr, int i, int j, vector<vector<char>>&v, string s)\\n    {\\n        if(i<0 && j<0 && i>=v.size() || j>=v[0].size() || vis[i][j] || !cr->children[v[i][j]-\\'a\\']) return ;\\n        \\n        vis[i][j]=1;\\n        if(cr->children[v[i][j]-\\'a\\']) cr=cr->children[v[i][j]-\\'a\\'], s+=v[i][j];\\n        else return ;\\n        if(cr->end) st.insert(s);\\n        \\n        \\n        if(i+1<v.size() && cr->children[v[i+1][j]-\\'a\\']) fun(cr, i+1, j, v, s);\\n        if(j+1<v[0].size() && cr->children[v[i][j+1]-\\'a\\']) fun(cr, i, j+1, v, s);\\n        if(i-1>=0 && cr->children[v[i-1][j]-\\'a\\']) fun(cr, i-1, j, v, s);\\n        if(j-1>=0 && cr->children[v[i][j-1]-\\'a\\']) fun(cr, i, j-1, v, s);\\n        \\n        vis[i][j]=0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& v, vector<string>& w) {\\n        \\n\\t\\t// make trie for all strings \\n        for(int i=0;i<w.size();++i)\\n        {\\n            string s=w[i];\\n            Trie* cr=node;\\n            for(auto c : s)\\n            {\\n                if(!cr->children[c-\\'a\\']) cr->children[c-\\'a\\']=new Trie();\\n                cr=cr->children[c-\\'a\\'];\\n            }\\n            cr->end=true;\\n        }\\n        \\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<v.size();++i)\\n        {\\n            for(int j=0;j<v[0].size();++j)\\n            {\\n                Trie* cr=node;\\n                string s=\"\";\\n                fun(cr, i, j, v, s);\\n                \\n                if(st.size()==w.size()) break;\\n            }\\n        }\\n        \\n        for(auto it : st) ans.pb(it);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Thanks...**\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n```\n```\\nbool end=false;\\nTrie* children[27]={};\\n```\n```\\nfor(int i=0;i<s.size();++i)\\n{\\n    if(!node->children[s[i]-\\'a\\']) node->children[s[i]-\\'a\\']=new Trie();\\n    node=node->children[s[i]-\\'a\\'];\\n}\\nnode->end=true;\\n```\n```\\n#define pb push_back\\nconst int N=14;\\n\\nclass Trie {\\n    public :\\n    bool end=false;\\n    Trie* children[27]={};\\n};\\n\\n\\nclass Solution {\\npublic:\\n    Trie* node = new Trie();\\n    \\n    vector<string>ans;\\n    set<string>st;\\n    int vis[N][N];\\n    void fun(Trie* cr, int i, int j, vector<vector<char>>&v, string s)\\n    {\\n        if(i<0 && j<0 && i>=v.size() || j>=v[0].size() || vis[i][j] || !cr->children[v[i][j]-\\'a\\']) return ;\\n        \\n        vis[i][j]=1;\\n        if(cr->children[v[i][j]-\\'a\\']) cr=cr->children[v[i][j]-\\'a\\'], s+=v[i][j];\\n        else return ;\\n        if(cr->end) st.insert(s);\\n        \\n        \\n        if(i+1<v.size() && cr->children[v[i+1][j]-\\'a\\']) fun(cr, i+1, j, v, s);\\n        if(j+1<v[0].size() && cr->children[v[i][j+1]-\\'a\\']) fun(cr, i, j+1, v, s);\\n        if(i-1>=0 && cr->children[v[i-1][j]-\\'a\\']) fun(cr, i-1, j, v, s);\\n        if(j-1>=0 && cr->children[v[i][j-1]-\\'a\\']) fun(cr, i, j-1, v, s);\\n        \\n        vis[i][j]=0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& v, vector<string>& w) {\\n        \\n\\t\\t// make trie for all strings \\n        for(int i=0;i<w.size();++i)\\n        {\\n            string s=w[i];\\n            Trie* cr=node;\\n            for(auto c : s)\\n            {\\n                if(!cr->children[c-\\'a\\']) cr->children[c-\\'a\\']=new Trie();\\n                cr=cr->children[c-\\'a\\'];\\n            }\\n            cr->end=true;\\n        }\\n        \\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<v.size();++i)\\n        {\\n            for(int j=0;j<v[0].size();++j)\\n            {\\n                Trie* cr=node;\\n                string s=\"\";\\n                fun(cr, i, j, v, s);\\n                \\n                if(st.size()==w.size()) break;\\n            }\\n        }\\n        \\n        for(auto it : st) ans.pb(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511581,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &board, string &word, int i, int j, int k, vector<vector<bool>> &visited) {\\n        if(k == word.length())\\n            return true;\\n        \\n        if(i<0 || i==board.size() || j<0 || j==board[0].size() || board[i][j] != word[k] || visited[i][j])\\n            return false;\\n        \\n        visited[i][j] = true;\\n        bool l = solve(board, word, i, j-1, k+1, visited);\\n        bool r = solve(board, word, i, j+1, k+1, visited);\\n        bool t = solve(board, word, i-1, j, k+1, visited);\\n        bool b = solve(board, word, i+1, j, k+1, visited);\\n        visited[i][j] = false;\\n        return l || r || t || b;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n                \\n        vector<vector<bool>>visited(board.size(), vector<bool>(board[0].size(), false));\\n        vector<string> res;\\n        \\n        for(auto &word : words) {\\n            int flag = 0;\\n            reverse(word.begin(), word.end());\\n            for (int i=0; i<board.size(); i++) {\\n                for (int j=0; j<board[0].size(); j++) { \\n                    if(solve(board, word, i, j, 0, visited)) {\\n                        flag=1; break;\\n                    }\\n                }\\n                if(flag) break;\\n            }\\n            if(flag) {\\n                reverse(word.begin(), word.end());\\n                res.push_back(word);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &board, string &word, int i, int j, int k, vector<vector<bool>> &visited) {\\n        if(k == word.length())\\n            return true;\\n        \\n        if(i<0 || i==board.size() || j<0 || j==board[0].size() || board[i][j] != word[k] || visited[i][j])\\n            return false;\\n        \\n        visited[i][j] = true;\\n        bool l = solve(board, word, i, j-1, k+1, visited);\\n        bool r = solve(board, word, i, j+1, k+1, visited);\\n        bool t = solve(board, word, i-1, j, k+1, visited);\\n        bool b = solve(board, word, i+1, j, k+1, visited);\\n        visited[i][j] = false;\\n        return l || r || t || b;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n                \\n        vector<vector<bool>>visited(board.size(), vector<bool>(board[0].size(), false));\\n        vector<string> res;\\n        \\n        for(auto &word : words) {\\n            int flag = 0;\\n            reverse(word.begin(), word.end());\\n            for (int i=0; i<board.size(); i++) {\\n                for (int j=0; j<board[0].size(); j++) { \\n                    if(solve(board, word, i, j, 0, visited)) {\\n                        flag=1; break;\\n                    }\\n                }\\n                if(flag) break;\\n            }\\n            if(flag) {\\n                reverse(word.begin(), word.end());\\n                res.push_back(word);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134922,
                "title": "python-trie-98-99-explanation-comments",
                "content": "Approach: DFS + Trie ~ O(MN \\\\* numPaths \\\\* 3^(longestWordLength)) runtime, O(numWords\\\\*longestWord) space - - 24ms(98.99%), 14.6MB (7.90%)\\nHere the worst case runtime is the same (assuming similar words like \"aaaaab\" \"aaaaac\", etc.)\\nBut disregarding the extreme case, it is on average a lot faster due to pruning (i.e. instead of *numWords, it\\'s *numPaths in Trie)\\n\\nInstead of looping through entire board for each word, at every character we check if it matches the first letter of any of the words\\nand the letters that don\\'t match are pruned. \\nEx: let\\'s say we check board[0][0], and found 20/100 words that match on the first letter. That means 80/100 of the words are pruned right away \\n(we didn\\'t even look at the other 80 words due to properties of hashmap).\\n\\nWhat is a Trie?\\nDiagram: https://drive.google.com/file/d/1McwXQIHmsk4sDwoYVNk0MhZFTMaDvnbg/view?usp=sharing\\nIt is a tree where each node stores a dictionary of next possible letters of a word sequence.\\nThis makes it so we can quickly prune and ignore the letters that don\\'t match.\\n\\n```\\nclass TrieNode:\\n    def __init__(self, char=None, letterToChild=None, word=None, prev=None):\\n        self.char = char # this node\\'s current character\\n        self.letterToChild = letterToChild # dictionary that maps child\\'s letter to child\\'s node\\n        self.word = word #  when a word is complete from start to this node, we set what the word is from start to here (note that there can stll be more words down this path)\\n        self.prev = prev # to backtrack and remove words that are already searched\\n\\nclass Solution:\\n    #24ms (faster than 98.86% Python 3) ~ O(MN * numPaths * 3^(longestWordLength)) runtime, O(totalWordLength * numWords) worst case memory\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board[0]) == 0 or not words:\\n            return []\\n\\n        def buildTrie(words: List[str]):\\n            #print(\"using words: {}\".format(words))\\n            # root node is character \"/\"\\n            root = TrieNode(char=\"/\")\\n            for word in words:\\n                # given a word, construct path of the word in Trie\\n                index = 0\\n                curNode = root\\n                while index < len(word):\\n                    #print(\"word[index]: {}\".format(word[index]))\\n                    # prepare childNode\\n                    char = word[index]\\n                    if not curNode.letterToChild:\\n                        curNode.letterToChild = {}\\n                    if char not in curNode.letterToChild:\\n                        # if childNode doesn\\'t exist, create it\\n                        childNode = TrieNode(char=char,letterToChild={},prev=curNode) #for some reason I need the {} otherwise it\\'s stealing from previous node\\n                        curNode.letterToChild[char] = childNode\\n                        #print(\"curNode\\'s child: {}\".format(curNode.letterToChild))\\n                    else:\\n                        childNode = curNode.letterToChild[char]\\n                    \\n                    # if at end of word, update the child node\\n                    if index == len(word) - 1:\\n                        childNode.word = word\\n                        break\\n\\n                    index += 1\\n                    curNode = childNode\\n            return root\\n        #build the Trie\\n        root = buildTrie(words)\\n\\n        #iterate through the board\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        resultList = []\\n        def dfs(x,y,curNode:TrieNode):\\n            #print(\"(x,y)=({},{})\".format(x,y))\\n            boardLetter = board[x][y]\\n            if boardLetter in curNode.letterToChild:\\n                board[x][y] = \"*\" #modify the board letter so we don\\'t reuse during dfs search\\n                # letter matches, get the childNode\\n                nextNode = curNode.letterToChild[boardLetter]\\n                # check if nextNode is at the end of a word; if so, add that to our resultList. Note that there may be more words further along this path.\\n                if nextNode.word:\\n                    resultList.append(nextNode.word)\\n                    nextNode.word = None\\n                    # delete the branch that is no longer needed (to avoid creating the same word again on next board iteration)\\n                    if len(nextNode.letterToChild) == 0:\\n                        #no more children below so need to backtrack and delete\\n                        #backtrack stops if there are 2+ paths down, or if we\\'re at the root node\\n                        parentNode = curNode\\n                        usedChar = nextNode.char\\n                        while len(parentNode.letterToChild) == 1:\\n                            #cut mapping of parentNode to used-childNode\\n                            del parentNode.letterToChild[usedChar]\\n                            usedChar = parentNode.char\\n                            if usedChar == \"/\":\\n                                #reached the top so no need to backtrack anymore\\n                                break\\n                            parentNode = parentNode.prev                            \\n\\n                # keep dfs traversing until end of word(s) in this Trie path\\n                for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                    adjX, adjY = x+dx, y+dy \\n                    # check if adjacent position is in board\\n                    if 0 <= adjX < rows and 0 <= adjY < cols:\\n                        dfs(adjX,adjY,nextNode)\\n            # no match with board or no more letters along this path\\n            # revert back the letter modified by dfs (backtrack)\\n            board[x][y] = boardLetter\\n            return\\n\\n        for x in range(rows):\\n            for y in range(cols):\\n                #check if word match; if so, traverse dfs\\n                curNode = root \\n                dfs(x,y,curNode)\\n        return resultList\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, char=None, letterToChild=None, word=None, prev=None):\\n        self.char = char # this node\\'s current character\\n        self.letterToChild = letterToChild # dictionary that maps child\\'s letter to child\\'s node\\n        self.word = word #  when a word is complete from start to this node, we set what the word is from start to here (note that there can stll be more words down this path)\\n        self.prev = prev # to backtrack and remove words that are already searched\\n\\nclass Solution:\\n    #24ms (faster than 98.86% Python 3) ~ O(MN * numPaths * 3^(longestWordLength)) runtime, O(totalWordLength * numWords) worst case memory\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board[0]) == 0 or not words:\\n            return []\\n\\n        def buildTrie(words: List[str]):\\n            #print(\"using words: {}\".format(words))\\n            # root node is character \"/\"\\n            root = TrieNode(char=\"/\")\\n            for word in words:\\n                # given a word, construct path of the word in Trie\\n                index = 0\\n                curNode = root\\n                while index < len(word):\\n                    #print(\"word[index]: {}\".format(word[index]))\\n                    # prepare childNode\\n                    char = word[index]\\n                    if not curNode.letterToChild:\\n                        curNode.letterToChild = {}\\n                    if char not in curNode.letterToChild:\\n                        # if childNode doesn\\'t exist, create it\\n                        childNode = TrieNode(char=char,letterToChild={},prev=curNode) #for some reason I need the {} otherwise it\\'s stealing from previous node\\n                        curNode.letterToChild[char] = childNode\\n                        #print(\"curNode\\'s child: {}\".format(curNode.letterToChild))\\n                    else:\\n                        childNode = curNode.letterToChild[char]\\n                    \\n                    # if at end of word, update the child node\\n                    if index == len(word) - 1:\\n                        childNode.word = word\\n                        break\\n\\n                    index += 1\\n                    curNode = childNode\\n            return root\\n        #build the Trie\\n        root = buildTrie(words)\\n\\n        #iterate through the board\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        resultList = []\\n        def dfs(x,y,curNode:TrieNode):\\n            #print(\"(x,y)=({},{})\".format(x,y))\\n            boardLetter = board[x][y]\\n            if boardLetter in curNode.letterToChild:\\n                board[x][y] = \"*\" #modify the board letter so we don\\'t reuse during dfs search\\n                # letter matches, get the childNode\\n                nextNode = curNode.letterToChild[boardLetter]\\n                # check if nextNode is at the end of a word; if so, add that to our resultList. Note that there may be more words further along this path.\\n                if nextNode.word:\\n                    resultList.append(nextNode.word)\\n                    nextNode.word = None\\n                    # delete the branch that is no longer needed (to avoid creating the same word again on next board iteration)\\n                    if len(nextNode.letterToChild) == 0:\\n                        #no more children below so need to backtrack and delete\\n                        #backtrack stops if there are 2+ paths down, or if we\\'re at the root node\\n                        parentNode = curNode\\n                        usedChar = nextNode.char\\n                        while len(parentNode.letterToChild) == 1:\\n                            #cut mapping of parentNode to used-childNode\\n                            del parentNode.letterToChild[usedChar]\\n                            usedChar = parentNode.char\\n                            if usedChar == \"/\":\\n                                #reached the top so no need to backtrack anymore\\n                                break\\n                            parentNode = parentNode.prev                            \\n\\n                # keep dfs traversing until end of word(s) in this Trie path\\n                for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                    adjX, adjY = x+dx, y+dy \\n                    # check if adjacent position is in board\\n                    if 0 <= adjX < rows and 0 <= adjY < cols:\\n                        dfs(adjX,adjY,nextNode)\\n            # no match with board or no more letters along this path\\n            # revert back the letter modified by dfs (backtrack)\\n            board[x][y] = boardLetter\\n            return\\n\\n        for x in range(rows):\\n            for y in range(cols):\\n                #check if word match; if so, traverse dfs\\n                curNode = root \\n                dfs(x,y,curNode)\\n        return resultList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004060,
                "title": "simple-java-implementation-using-backtracking-extending-word-search-solution",
                "content": "I used the same concept which I used to solve Word Search problem. Hope it would help.\\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int r = board.length;\\n        int c = board[0].length;\\n        Set<String> result = new HashSet<>();\\n        \\n        for(int i=0;i<r;i++) {\\n            for(int j=0;j<c;j++) {\\n                for(String word : words) {\\n                    if(board[i][j] == word.charAt(0) && dfs(board, word, new boolean[r][c], i, j, 0)) {\\n                        result.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n    private boolean dfs(char[][] board, String word, boolean[][] visited, int i, int j, int index) {\\n        if(word.length() == index)\\n            return true;\\n        \\n        if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j] || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n        visited[i][j] = true;\\n        \\n        if( dfs(board, word, visited, i+1, j, index+1) ||\\n            dfs(board, word, visited, i-1, j, index+1) ||\\n            dfs(board, word, visited, i, j+1, index+1) ||\\n            dfs(board, word, visited, i, j-1, index+1)\\n          )\\n            return true;\\n        \\n        visited[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int r = board.length;\\n        int c = board[0].length;\\n        Set<String> result = new HashSet<>();\\n        \\n        for(int i=0;i<r;i++) {\\n            for(int j=0;j<c;j++) {\\n                for(String word : words) {\\n                    if(board[i][j] == word.charAt(0) && dfs(board, word, new boolean[r][c], i, j, 0)) {\\n                        result.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n    private boolean dfs(char[][] board, String word, boolean[][] visited, int i, int j, int index) {\\n        if(word.length() == index)\\n            return true;\\n        \\n        if(i<0 || j<0 || i>=board.length || j>=board[i].length || visited[i][j] || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n        visited[i][j] = true;\\n        \\n        if( dfs(board, word, visited, i+1, j, index+1) ||\\n            dfs(board, word, visited, i-1, j, index+1) ||\\n            dfs(board, word, visited, i, j+1, index+1) ||\\n            dfs(board, word, visited, i, j-1, index+1)\\n          )\\n            return true;\\n        \\n        visited[i][j] = false;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59805,
                "title": "c-462-ms-brute-force-and-35-ms-trie-solution",
                "content": "**Solution 1**\\n\\nBrute force. Using [solution](https://discuss.leetcode.com/topic/82756/two-9-ms-c-backtrack-solutions)  of [Word Search](https://leetcode.com/problems/word-search/description/).\\nRunime: 462 ms\\n```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<char, vector<string>>m;\\n        for(auto x: words) m[x[0]].push_back(x);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(m[board[i][j]].size() > 0)\\n                    for(auto x: m[board[i][j]]){\\n                        bool found = false;\\n                        backtrack(board, 1, i, j, board.size(), board[0].size(), x, found);\\n                        if(found && find(res.begin(), res.end(), x) == res.end()) res.push_back(x);\\n                    } \\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nAdd Trie, inspired by Trie implementation in this [thread](https://discuss.leetcode.com/topic/13463/maybe-the-code-is-not-too-much-by-using-next-26-c).\\nRuntime: 35 ms. (Beats 95.58% of C++ solutions.)\\n```\\nstruct TrieNode{\\n    string word;\\n    TrieNode* next[26];\\n};\\n\\nclass Solution {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        buildTrie(words);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                backtrack(board, res, i, j, board.size() - 1, board[0].size() - 1, root);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, vector<string>& res, int r, int c, int m, int n, TrieNode* p){\\n        if(r < 0 || c < 0 || r > m || c > n || board[r][c] == '0'|| !p->next[board[r][c] - 'a']) return;\\n        p = p->next[board[r][c] - 'a'];\\n        if(p->word.size() > 0){\\n            res.push_back(p->word);\\n            p->word = \"\";\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        backtrack(board, res, r - 1, c, m, n, p);\\n        backtrack(board, res, r + 1, c, m, n, p);\\n        backtrack(board, res, r, c + 1, m, n, p);\\n        backtrack(board, res, r, c - 1, m, n, p);\\n        board[r][c] = tmp;\\n    }\\n    \\n    void buildTrie(vector<string>& words){\\n        root = new TrieNode();\\n        for(auto x: words){\\n            TrieNode* p = root;\\n            for(auto c: x){\\n                if(!p->next[c - 'a']) p->next[c - 'a'] = new TrieNode();\\n                p = p->next[c - 'a'];\\n            }\\n            p->word = x;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<char, vector<string>>m;\\n        for(auto x: words) m[x[0]].push_back(x);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(m[board[i][j]].size() > 0)\\n                    for(auto x: m[board[i][j]]){\\n                        bool found = false;\\n                        backtrack(board, 1, i, j, board.size(), board[0].size(), x, found);\\n                        if(found && find(res.begin(), res.end(), x) == res.end()) res.push_back(x);\\n                    } \\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\n```\\nstruct TrieNode{\\n    string word;\\n    TrieNode* next[26];\\n};\\n\\nclass Solution {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>res;\\n        buildTrie(words);\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                backtrack(board, res, i, j, board.size() - 1, board[0].size() - 1, root);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, vector<string>& res, int r, int c, int m, int n, TrieNode* p){\\n        if(r < 0 || c < 0 || r > m || c > n || board[r][c] == '0'|| !p->next[board[r][c] - 'a']) return;\\n        p = p->next[board[r][c] - 'a'];\\n        if(p->word.size() > 0){\\n            res.push_back(p->word);\\n            p->word = \"\";\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        backtrack(board, res, r - 1, c, m, n, p);\\n        backtrack(board, res, r + 1, c, m, n, p);\\n        backtrack(board, res, r, c + 1, m, n, p);\\n        backtrack(board, res, r, c - 1, m, n, p);\\n        board[r][c] = tmp;\\n    }\\n    \\n    void buildTrie(vector<string>& words){\\n        root = new TrieNode();\\n        for(auto x: words){\\n            TrieNode* p = root;\\n            for(auto c: x){\\n                if(!p->next[c - 'a']) p->next[c - 'a'] = new TrieNode();\\n                p = p->next[c - 'a'];\\n            }\\n            p->word = x;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781431,
                "title": "kind-of-clumsy-trie-solution-but-it-works",
                "content": "```csharp\\npublic class Solution\\n{\\n    public IList<string> FindWords(char[][] board, string[] words)\\n    {\\n        int m = board.Length;\\n        int n = board[0].Length;\\n        List<string> res = new();\\n\\n        //build trie\\n        Node root = new();\\n        foreach (string word in words)\\n        {\\n            Node node = root;\\n            foreach (char c in word)\\n            {\\n                if (node.Next[c] is null) node.Next[c] = new Node();\\n                node = node.Next[c];\\n            }\\n            node.Word = word;\\n        }\\n\\n        //do dfs\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                Dfs(i, j, root);\\n            }\\n        }\\n\\n        return res;\\n\\n        void Dfs(int i, int j, Node node)\\n        {\\n            if (i < 0 || j < 0 || i == m || j == n) return;\\n            char c = board[i][j];\\n            if (c == \\'/\\' || node.Next[c] is null) return;\\n            node = node.Next[c];\\n\\n            if (node.Word is not null)\\n            {\\n                res.Add(node.Word);\\n                node.Word = null;\\n            }\\n\\n            board[i][j] = \\'/\\';\\n            Dfs(i - 1, j, node);\\n            Dfs(i, j - 1, node);\\n            Dfs(i + 1, j, node);\\n            Dfs(i, j + 1, node);\\n            board[i][j] = c;\\n        }\\n    }\\n}\\n\\npublic class Node\\n{\\n    public Node[] Next { get; } = new Node[\\'z\\' + 1];\\n    public string Word { get; set; }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public IList<string> FindWords(char[][] board, string[] words)\\n    {\\n        int m = board.Length;\\n        int n = board[0].Length;\\n        List<string> res = new();\\n\\n        //build trie\\n        Node root = new();\\n        foreach (string word in words)\\n        {\\n            Node node = root;\\n            foreach (char c in word)\\n            {\\n                if (node.Next[c] is null) node.Next[c] = new Node();\\n                node = node.Next[c];\\n            }\\n            node.Word = word;\\n        }\\n\\n        //do dfs\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                Dfs(i, j, root);\\n            }\\n        }\\n\\n        return res;\\n\\n        void Dfs(int i, int j, Node node)\\n        {\\n            if (i < 0 || j < 0 || i == m || j == n) return;\\n            char c = board[i][j];\\n            if (c == \\'/\\' || node.Next[c] is null) return;\\n            node = node.Next[c];\\n\\n            if (node.Word is not null)\\n            {\\n                res.Add(node.Word);\\n                node.Word = null;\\n            }\\n\\n            board[i][j] = \\'/\\';\\n            Dfs(i - 1, j, node);\\n            Dfs(i, j - 1, node);\\n            Dfs(i + 1, j, node);\\n            Dfs(i, j + 1, node);\\n            board[i][j] = c;\\n        }\\n    }\\n}\\n\\npublic class Node\\n{\\n    public Node[] Next { get; } = new Node[\\'z\\' + 1];\\n    public string Word { get; set; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779871,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs(board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || p.next[c - \\'a\\'] == null) {\\n            return;\\n        }\\n        p = p.next[c - \\'a\\'];\\n        if (p.word != null) {   \\n            res.add(p.word);\\n            p.word = null;     \\n        }\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, res);\\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res);\\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\\n        board[i][j] = c;\\n    }\\n\\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (int i=0; i< words.length; i++) {\\n            TrieNode p = root;\\n            for (int j=0; j<words[i].toCharArray().length; j++) {\\n                int k = words[i].toCharArray()[j]- \\'a\\';\\n                if (p.next[k] == null) {\\n                    p.next[k] = new TrieNode();\\n                }\\n                p = p.next[k];\\n            }\\n            p.word = words[i];\\n        }\\n        return root;\\n    }\\n\\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs(board, i, j, root, res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2779536,
                "title": "daily-leetcoding-challenge-november-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/word-search-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/word-search-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2252022,
                "title": "accepted-java-solution-without-using-trie",
                "content": "Regular backtracking with length pruning\\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        boolean[][] visited = new boolean[row][col];\\n        Set<String> words_set = new HashSet<>();\\n        \\n        int max_len = 0;\\n        for(String w: words) {\\n            words_set.add(w);\\n            max_len = Math.max(max_len, w.length());\\n        }\\n        \\n        Set<String> ans = new HashSet<>(); //de-dup\\n        \\n        for(int i = 0; i < row; i++) \\n            for(int j = 0; j < col; j++)\\n                helper(board, words_set, i, j, visited, new StringBuilder(), ans, 0, max_len);\\n        \\n        List<String> list = new ArrayList<String>();\\n        list.addAll(ans);\\n        return list;\\n    }\\n    \\n    private void helper(\\n        char[][] board, Set<String> words_set, int r, int c, boolean[][] visited, StringBuilder sb, Set<String> ans, int length, int max_len) {\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        if (r < 0 || c < 0 || r == row || c == col) return;\\n        if (length >= max_len) return;\\n        if (visited[r][c]) return;\\n        \\n        visited[r][c] = true;\\n        sb.append(board[r][c]);\\n        \\n        if (words_set.contains(sb.toString()))\\n            ans.add(sb.toString());\\n        \\n        helper(board, words_set, r + 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r - 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c + 1, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c - 1, visited, sb, ans, length + 1, max_len);  \\n        \\n        visited[r][c] = false;\\n        sb.setLength(sb.length() - 1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        boolean[][] visited = new boolean[row][col];\\n        Set<String> words_set = new HashSet<>();\\n        \\n        int max_len = 0;\\n        for(String w: words) {\\n            words_set.add(w);\\n            max_len = Math.max(max_len, w.length());\\n        }\\n        \\n        Set<String> ans = new HashSet<>(); //de-dup\\n        \\n        for(int i = 0; i < row; i++) \\n            for(int j = 0; j < col; j++)\\n                helper(board, words_set, i, j, visited, new StringBuilder(), ans, 0, max_len);\\n        \\n        List<String> list = new ArrayList<String>();\\n        list.addAll(ans);\\n        return list;\\n    }\\n    \\n    private void helper(\\n        char[][] board, Set<String> words_set, int r, int c, boolean[][] visited, StringBuilder sb, Set<String> ans, int length, int max_len) {\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        if (r < 0 || c < 0 || r == row || c == col) return;\\n        if (length >= max_len) return;\\n        if (visited[r][c]) return;\\n        \\n        visited[r][c] = true;\\n        sb.append(board[r][c]);\\n        \\n        if (words_set.contains(sb.toString()))\\n            ans.add(sb.toString());\\n        \\n        helper(board, words_set, r + 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r - 1, c, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c + 1, visited, sb, ans, length + 1, max_len);\\n        helper(board, words_set, r, c - 1, visited, sb, ans, length + 1, max_len);  \\n        \\n        visited[r][c] = false;\\n        sb.setLength(sb.length() - 1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048961,
                "title": "python-trie-dfs-neetcode-optimized-code-no-tle",
                "content": "Optimized the code by Neetcode.io so that it does not get TLE when submitted:\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n    \\n    def add_word(self, word):\\n        node = self\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.end = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.add_word(w)\\n        \\n        rows, cols = len(board), len(board[0])\\n        ans = []\\n        word = []\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def dfs(x, y, node):\\n            if not (0 <= x < rows) or not (0 <= y < cols) or board[x][y] == \"#\":\\n                return\\n            \\n            char = board[x][y]\\n            if char not in node.children:\\n                return\\n\\n            board[x][y] = \"#\"\\n            \\n            node = node.children[char]\\n            word.append(char)\\n            if node.end:\\n                ans.append(\"\".join(word))\\n                node.end = False\\n            \\n            for dx, dy in directions:\\n                dfs(x + dx, y + dy, node)\\n            \\n            word.pop()\\n            board[x][y] = char\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                dfs(i, j, root)\\n        \\n        return ans\\n```\\nMain changes:\\n1. Removed **visited set** and instead used a \"visited char\" (\"#\") in the board, which will tell us if we already visited that position. After we finish the recursion we reset the \"#\" to its original value.\\n2. Changed the **ans set to a list** (we avoid checking duplicates). The way we would manage this is by changing the \"end/end of word\" attribute to False when we add a word, so we verify we don\\'t add it again.\\n3. Converted the \"word\" parameter (string) into a global array/list. **Without this change it will still give TLE.**\\n4. The last change does not affect the overall complexity but makes the code more scalable, which is the directions array/list. This may help in the case the **follow-up** is to verify also the **diagonals** (we can easily add 4 more coordinates to the array).",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n    \\n    def add_word(self, word):\\n        node = self\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.end = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = TrieNode()\\n        for w in words:\\n            root.add_word(w)\\n        \\n        rows, cols = len(board), len(board[0])\\n        ans = []\\n        word = []\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def dfs(x, y, node):\\n            if not (0 <= x < rows) or not (0 <= y < cols) or board[x][y] == \"#\":\\n                return\\n            \\n            char = board[x][y]\\n            if char not in node.children:\\n                return\\n\\n            board[x][y] = \"#\"\\n            \\n            node = node.children[char]\\n            word.append(char)\\n            if node.end:\\n                ans.append(\"\".join(word))\\n                node.end = False\\n            \\n            for dx, dy in directions:\\n                dfs(x + dx, y + dy, node)\\n            \\n            word.pop()\\n            board[x][y] = char\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                dfs(i, j, root)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860991,
                "title": "python3-trie-dfs-pruning",
                "content": "class Node:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    def insert(self,word):\\n        root = self\\n        for w in word:\\n            if w not in root.children:\\n                root.children[w] = Node()\\n            root = root.children[w]\\n        root.endOfWord = True     \\n        \\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for word in words:\\n            root.insert(word)\\n        result,visited=set(),set()\\n        ROWS,COLS=len(board),len(board[0])\\n        def dfs(r,c,node,currWord):\\n            if r in [-1,ROWS] or c in [-1,COLS] or (r,c) in visited or board[r][c] not in node.children:\\n                return False\\n            ele = board[r][c]\\n            currWord+=ele\\n            node = node.children[ele]\\n            flag = True\\n            if node.endOfWord:\\n                result.add(currWord)\\n                if len(node.children)==0:\\n                    flag = False\\n                    del node\\n            if flag:\\n                visited.add((r,c))\\n                dfs(r-1,c,node,currWord)\\n                dfs(r+1,c,node,currWord)\\n                dfs(r,c-1,node,currWord)\\n                dfs(r,c+1,node,currWord)\\n                visited.remove((r,c))\\n                \\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r,c,root,\"\")\\n        \\n        return list(result)",
                "solutionTags": [],
                "code": "class Node:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    def insert(self,word):\\n        root = self\\n        for w in word:\\n            if w not in root.children:\\n                root.children[w] = Node()\\n            root = root.children[w]\\n        root.endOfWord = True     \\n        \\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for word in words:\\n            root.insert(word)\\n        result,visited=set(),set()\\n        ROWS,COLS=len(board),len(board[0])\\n        def dfs(r,c,node,currWord):\\n            if r in [-1,ROWS] or c in [-1,COLS] or (r,c) in visited or board[r][c] not in node.children:\\n                return False\\n            ele = board[r][c]\\n            currWord+=ele\\n            node = node.children[ele]\\n            flag = True\\n            if node.endOfWord:\\n                result.add(currWord)\\n                if len(node.children)==0:\\n                    flag = False\\n                    del node\\n            if flag:\\n                visited.add((r,c))\\n                dfs(r-1,c,node,currWord)\\n                dfs(r+1,c,node,currWord)\\n                dfs(r,c-1,node,currWord)\\n                dfs(r,c+1,node,currWord)\\n                visited.remove((r,c))\\n                \\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r,c,root,\"\")\\n        \\n        return list(result)",
                "codeTag": "Java"
            },
            {
                "id": 1849610,
                "title": "python-trie-solution-with-dfs-backtracking-no-tle",
                "content": "Similar to other solutions. I used seperate TrieNode and Trie classes for clarity. \\n\\nNOTE: I originally got TLE until I added logic to remove nodes from the tree if they do not have children.\\n\\n```\\n\\'\\'\\'\\nInsert all words into Trie. Then DFS. At each cell, we will check to see if its in children of trie node. So, at each cell, we are checking the existance of all words simultaneously. Once we hit a prefix that does not exist in our trie, we backtrack and move to the next cell.\\n\\'\\'\\'\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        current = self.root\\n        \\n        for letter in word:\\n            current = current.children[letter]\\n        \\n        current.word = word\\n            \\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m = len(board)\\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        \\n        for word in words:\\n            trie.insert(word)\\n            \\n        ans = []\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                self.dfs(board, i, j, trie.root, ans)\\n        \\n        return ans\\n        \\n        \\n            \\n    def dfs(self, board, i, j, trie_node, ans):\\n        \\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] not in trie_node.children:\\n            return\\n        \\n        cell_orig = board[i][j]\\n        next_node = trie_node.children[cell_orig]\\n        \\n        if next_node.word != None:\\n            ans.append(next_node.word)\\n            next_node.word = None\\n            \\n            # If this letter has no children, then remove from trie\\n            if not next_node.children.keys():\\n                del trie_node.children[cell_orig]\\n                return\\n                \\n        board[i][j] = \\'#\\'   \\n            \\n        for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n            self.dfs(board, i + x, j + y, next_node, ans)\\n            \\n        # Backtrack\\n        board[i][j] = cell_orig\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\'\\'\\'\\nInsert all words into Trie. Then DFS. At each cell, we will check to see if its in children of trie node. So, at each cell, we are checking the existance of all words simultaneously. Once we hit a prefix that does not exist in our trie, we backtrack and move to the next cell.\\n\\'\\'\\'\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.word = None\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        current = self.root\\n        \\n        for letter in word:\\n            current = current.children[letter]\\n        \\n        current.word = word\\n            \\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m = len(board)\\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        \\n        for word in words:\\n            trie.insert(word)\\n            \\n        ans = []\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                self.dfs(board, i, j, trie.root, ans)\\n        \\n        return ans\\n        \\n        \\n            \\n    def dfs(self, board, i, j, trie_node, ans):\\n        \\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] not in trie_node.children:\\n            return\\n        \\n        cell_orig = board[i][j]\\n        next_node = trie_node.children[cell_orig]\\n        \\n        if next_node.word != None:\\n            ans.append(next_node.word)\\n            next_node.word = None\\n            \\n            # If this letter has no children, then remove from trie\\n            if not next_node.children.keys():\\n                del trie_node.children[cell_orig]\\n                return\\n                \\n        board[i][j] = \\'#\\'   \\n            \\n        for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n            self.dfs(board, i + x, j + y, next_node, ans)\\n            \\n        # Backtrack\\n        board[i][j] = cell_orig\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750819,
                "title": "c-trie-backtracking-without-set",
                "content": "OPTIMIZATIONS:-\\n1. there can be multiple occurences of any word in the matrix. usual solutions handles this by adding the word(if found) to the set to avoid duplicates. the way i do it is set isWord TrieNode flag to false once a word has been found and add directly to the ans vector instead of a set\\n\\n2. instead of keeping a hashset/visited matrix, before applying dfs store the cur char in a temp char and set it to any char that is out of range from the input values. eg \\'@\\'. it acts as a flag whether this cell has been visited in the current dfs iteration. once the dfs call has been completed. restore the value from temp char.\\n\\n3. instead of passing a new current word(pass by value) maintain a global current string or pass by reference and just pop_back the char once its dfs call ends.\\n```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> links;\\n    bool isWord;\\n    TrieNode(){\\n        links.resize(26);\\n        isWord=false;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void addword(string& word){\\n        TrieNode* node = root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->links[word[i]-\\'a\\']) node->links[word[i]-\\'a\\'] = new TrieNode();\\n            node=node->links[word[i]-\\'a\\'];\\n        }\\n        node->isWord=true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> x={-1,1,0,0};\\n    vector<int> y={0,0,-1,1};\\n    vector<string> ans;\\n    string cur;\\n    void dfs(vector<vector<char>>& board,TrieNode* node,int i,int j){\\n        if(i<0 || i==board.size() || j<0 || j==board[i].size() || board[i][j]==\\'@\\' || !node->links[board[i][j]-\\'a\\']) return;\\n        node=node->links[board[i][j]-\\'a\\'];\\n        cur.push_back(board[i][j]);\\n        if(node->isWord){\\n            ans.push_back(cur);\\n            node->isWord=false;\\n        }\\n        board[i][j]=\\'@\\';\\n        for(int z=0;z<4;z++) dfs(board,node,i+x[z],j+y[z]);\\n        board[i][j]=cur.back();\\n        cur.pop_back();\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words){\\n        Trie trie;\\n        cur=\"\";\\n        for(int i=0;i<words.size();i++) trie.addword(words[i]);\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                dfs(board,trie.root,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> links;\\n    bool isWord;\\n    TrieNode(){\\n        links.resize(26);\\n        isWord=false;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void addword(string& word){\\n        TrieNode* node = root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->links[word[i]-\\'a\\']) node->links[word[i]-\\'a\\'] = new TrieNode();\\n            node=node->links[word[i]-\\'a\\'];\\n        }\\n        node->isWord=true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> x={-1,1,0,0};\\n    vector<int> y={0,0,-1,1};\\n    vector<string> ans;\\n    string cur;\\n    void dfs(vector<vector<char>>& board,TrieNode* node,int i,int j){\\n        if(i<0 || i==board.size() || j<0 || j==board[i].size() || board[i][j]==\\'@\\' || !node->links[board[i][j]-\\'a\\']) return;\\n        node=node->links[board[i][j]-\\'a\\'];\\n        cur.push_back(board[i][j]);\\n        if(node->isWord){\\n            ans.push_back(cur);\\n            node->isWord=false;\\n        }\\n        board[i][j]=\\'@\\';\\n        for(int z=0;z<4;z++) dfs(board,node,i+x[z],j+y[z]);\\n        board[i][j]=cur.back();\\n        cur.pop_back();\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words){\\n        Trie trie;\\n        cur=\"\";\\n        for(int i=0;i<words.size();i++) trie.addword(words[i]);\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                dfs(board,trie.root,i,j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688044,
                "title": "c-dfs-memoization-98-runtime-99-memory",
                "content": "```\\nclass Solution {\\n    \\n    bool dfs(vector<vector<char>>& board, const string& s,\\n             unsigned int idx, int i, int j) {\\n        if(idx == s.length()) {\\n            return true;\\n        }\\n        \\n        //Check if we are in bounds.\\n        if(i<0 or j<0) return false;\\n        if(i>=(int)board.size() or j>=(int)board[0].size()) return false;\\n        \\n        //Check if we found the right character/\\n        if(board[i][j] != s[idx]) {\\n            return false;\\n        }\\n        \\n        //Remember which character was at this location,\\n        //then assign a dummy character, to prevent using\\n        //the same character twice.\\n        char c = board[i][j];\\n        board[i][j] = \\'*\\';\\n        \\n        //Search for the next character at the adjacent indexes.\\n        bool good = dfs(board, s, idx+1, i+1, j) or\\n                     dfs(board, s, idx+1, i-1, j) or\\n                     dfs(board, s, idx+1, i, j+1) or\\n                     dfs(board, s, idx+1, i, j-1);\\n        \\n        //Change the character back and return the result.\\n        board[i][j] = c;\\n        return good;\\n    }\\npublic:\\n    typedef pair<int,int> Pair;\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<Pair>> letters;\\n        vector<string> found;\\n        \\n        //Record the indexes of each char.\\n        for(int i = 0; i < (int)board.size(); ++i) {\\n            for(int j = 0; j < (int)board[0].size(); ++j) {\\n                letters[board[i][j]].push_back(Pair(i,j));\\n            }\\n        }\\n        \\n        for(string s: words) {\\n            bool cont = false;\\n            \\n            //If we didn\\'t already find every character in s,\\n            //we can\\'t possibly find the word, so we move on.\\n            for(auto i = 0u; i < s.length(); ++i) {\\n                if(letters.find(s[i]) == letters.end()) {\\n                    cont = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(cont)\\n                continue;\\n            \\n            //We skip to the indexes of the chars that are\\n            //equal to the first character in s.\\n            for(Pair p: letters[s[0]]) {\\n                if(dfs(board, s, 0u, p.first, p.second)) {\\n                    found.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool dfs(vector<vector<char>>& board, const string& s,\\n             unsigned int idx, int i, int j) {\\n        if(idx == s.length()) {\\n            return true;\\n        }\\n        \\n        //Check if we are in bounds.\\n        if(i<0 or j<0) return false;\\n        if(i>=(int)board.size() or j>=(int)board[0].size()) return false;\\n        \\n        //Check if we found the right character/\\n        if(board[i][j] != s[idx]) {\\n            return false;\\n        }\\n        \\n        //Remember which character was at this location,\\n        //then assign a dummy character, to prevent using\\n        //the same character twice.\\n        char c = board[i][j];\\n        board[i][j] = \\'*\\';\\n        \\n        //Search for the next character at the adjacent indexes.\\n        bool good = dfs(board, s, idx+1, i+1, j) or\\n                     dfs(board, s, idx+1, i-1, j) or\\n                     dfs(board, s, idx+1, i, j+1) or\\n                     dfs(board, s, idx+1, i, j-1);\\n        \\n        //Change the character back and return the result.\\n        board[i][j] = c;\\n        return good;\\n    }\\npublic:\\n    typedef pair<int,int> Pair;\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<Pair>> letters;\\n        vector<string> found;\\n        \\n        //Record the indexes of each char.\\n        for(int i = 0; i < (int)board.size(); ++i) {\\n            for(int j = 0; j < (int)board[0].size(); ++j) {\\n                letters[board[i][j]].push_back(Pair(i,j));\\n            }\\n        }\\n        \\n        for(string s: words) {\\n            bool cont = false;\\n            \\n            //If we didn\\'t already find every character in s,\\n            //we can\\'t possibly find the word, so we move on.\\n            for(auto i = 0u; i < s.length(); ++i) {\\n                if(letters.find(s[i]) == letters.end()) {\\n                    cont = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(cont)\\n                continue;\\n            \\n            //We skip to the indexes of the chars that are\\n            //equal to the first character in s.\\n            for(Pair p: letters[s[0]]) {\\n                if(dfs(board, s, 0u, p.first, p.second)) {\\n                    found.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664021,
                "title": "java-trie-dfs-clear-code",
                "content": "```\\nclass Solution {\\n    \\n    List<String> res;\\n    char[][] board;\\n    \\n    \\n    public List<String> findWords(char[][] _board, String[] words) {\\n        res = new ArrayList<String>();\\n        this.board = _board;\\n        TrieNode trie = new TrieNode();\\n        trie.constructTrie(words);\\n        for(int r = 0; r<board.length; r++){\\n            for(int c = 0; c<board[r].length; c++){\\n                helper(r,c,trie);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n    \\n    private void helper(int r, int c,TrieNode trie){\\n        if(r<0 || c<0 || r==board.length || c==board[r].length || board[r][c]==\\'#\\')return;\\n        char currentChar = board[r][c];\\n        TrieNode next = trie.children[currentChar -\\'a\\'];\\n        if(next==null)return;\\n        if(!next.word.equals(\"\")){\\n            res.add(next.word);\\n            next.word = \"\";\\n        }\\n        board[r][c]=\\'#\\';\\n        helper(r+1,c,next);\\n        helper(r-1,c,next);\\n        helper(r,c+1,next);\\n        helper(r,c-1,next);\\n        board[r][c]=currentChar;\\n    }\\n    \\n    class TrieNode{\\n        \\n        TrieNode[] children = new TrieNode[\\'z\\'-\\'a\\'+1];\\n        String word = \"\";\\n        \\n        public void constructTrie(String[] words){\\n            TrieNode current = this;\\n            for(String word : words){\\n                for(char c : word.toCharArray()){\\n                    if(current.children[c - \\'a\\']==null){\\n                       current.children[c - \\'a\\'] = new TrieNode(); \\n                    }\\n                    current = current.children[c - \\'a\\'];\\n                }\\n                current.word = word;\\n                current = this;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> res;\\n    char[][] board;\\n    \\n    \\n    public List<String> findWords(char[][] _board, String[] words) {\\n        res = new ArrayList<String>();\\n        this.board = _board;\\n        TrieNode trie = new TrieNode();\\n        trie.constructTrie(words);\\n        for(int r = 0; r<board.length; r++){\\n            for(int c = 0; c<board[r].length; c++){\\n                helper(r,c,trie);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n    \\n    private void helper(int r, int c,TrieNode trie){\\n        if(r<0 || c<0 || r==board.length || c==board[r].length || board[r][c]==\\'#\\')return;\\n        char currentChar = board[r][c];\\n        TrieNode next = trie.children[currentChar -\\'a\\'];\\n        if(next==null)return;\\n        if(!next.word.equals(\"\")){\\n            res.add(next.word);\\n            next.word = \"\";\\n        }\\n        board[r][c]=\\'#\\';\\n        helper(r+1,c,next);\\n        helper(r-1,c,next);\\n        helper(r,c+1,next);\\n        helper(r,c-1,next);\\n        board[r][c]=currentChar;\\n    }\\n    \\n    class TrieNode{\\n        \\n        TrieNode[] children = new TrieNode[\\'z\\'-\\'a\\'+1];\\n        String word = \"\";\\n        \\n        public void constructTrie(String[] words){\\n            TrieNode current = this;\\n            for(String word : words){\\n                for(char c : word.toCharArray()){\\n                    if(current.children[c - \\'a\\']==null){\\n                       current.children[c - \\'a\\'] = new TrieNode(); \\n                    }\\n                    current = current.children[c - \\'a\\'];\\n                }\\n                current.word = word;\\n                current = this;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632923,
                "title": "one-of-best-use-cases-for-trie-java-beats-99-9",
                "content": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        Trie trie = new Trie();\\n        for(String word:words){\\n            trie.insert(word);\\n        }\\n        List<String> result = new ArrayList<String>();\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(trie.root.childrens[board[i][j] - \\'a\\'] != null){\\n                    trie.search(result,i,j,trie.root,board);\\n                }\\n            }\\n        }\\n        return result;\\n    }   \\n}\\n\\nclass TrieNode {\\n        TrieNode[] childrens;\\n        String word;\\n        TrieNode(){\\n            childrens = new TrieNode[26];\\n        }\\n    }\\nclass Trie {\\n    \\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n   \\n    public void insert(String word) {\\n        \\n        TrieNode ptr = root;\\n        for(int i=0;i<word.length();i++){\\n            int index = word.charAt(i) - \\'a\\';\\n            if(ptr.childrens[index] == null){\\n                ptr.childrens[index] = new TrieNode();\\n            }\\n            ptr = ptr.childrens[index];\\n        }\\n        ptr.word = word;\\n    }\\n    \\n    public void search(List<String> result,int i,int j,TrieNode node,char[][] board) {\\n      \\n      if(i<0 || i>= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'.\\')\\n            return;\\n       \\n        int index = board[i][j] - \\'a\\';\\n        if(node.childrens[index] == null)\\n            return;\\n\\n        if(node.childrens[index].word != null)\\n        {\\n            result.add(node.childrens[index].word);\\n            node.childrens[index].word = null;\\n        }\\n        char current = board[i][j];\\n        board[i][j] = \\'.\\';\\n        \\n        search(result,i+1,j,node.childrens[index],board);\\n        search(result,i,j+1,node.childrens[index],board);\\n        search(result,i-1,j,node.childrens[index],board);\\n        search(result,i,j-1,node.childrens[index],board);\\n        board[i][j] = current;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        Trie trie = new Trie();\\n        for(String word:words){\\n            trie.insert(word);\\n        }\\n        List<String> result = new ArrayList<String>();\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(trie.root.childrens[board[i][j] - \\'a\\'] != null){\\n                    trie.search(result,i,j,trie.root,board);\\n                }\\n            }\\n        }\\n        return result;\\n    }   \\n}\\n\\nclass TrieNode {\\n        TrieNode[] childrens;\\n        String word;\\n        TrieNode(){\\n            childrens = new TrieNode[26];\\n        }\\n    }\\nclass Trie {\\n    \\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n   \\n    public void insert(String word) {\\n        \\n        TrieNode ptr = root;\\n        for(int i=0;i<word.length();i++){\\n            int index = word.charAt(i) - \\'a\\';\\n            if(ptr.childrens[index] == null){\\n                ptr.childrens[index] = new TrieNode();\\n            }\\n            ptr = ptr.childrens[index];\\n        }\\n        ptr.word = word;\\n    }\\n    \\n    public void search(List<String> result,int i,int j,TrieNode node,char[][] board) {\\n      \\n      if(i<0 || i>= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'.\\')\\n            return;\\n       \\n        int index = board[i][j] - \\'a\\';\\n        if(node.childrens[index] == null)\\n            return;\\n\\n        if(node.childrens[index].word != null)\\n        {\\n            result.add(node.childrens[index].word);\\n            node.childrens[index].word = null;\\n        }\\n        char current = board[i][j];\\n        board[i][j] = \\'.\\';\\n        \\n        search(result,i+1,j,node.childrens[index],board);\\n        search(result,i,j+1,node.childrens[index],board);\\n        search(result,i-1,j,node.childrens[index],board);\\n        search(result,i,j-1,node.childrens[index],board);\\n        board[i][j] = current;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542405,
                "title": "go-dfs-trie-solution",
                "content": "```\\ntype TrieNode struct {\\n\\tword     string\\n\\tchildren [26]*TrieNode\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\troot := &TrieNode{}\\n\\tfor _, w := range words {\\n\\t\\tnode := root\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tif node.children[c-\\'a\\'] == nil {\\n\\t\\t\\t\\tnode.children[c-\\'a\\'] = &TrieNode{}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[c-\\'a\\']\\n\\t\\t}\\n\\t\\tnode.word = w\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tdfs(i, j, board, root, &result)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(i, j int, board [][]byte, node *TrieNode, result *[]string) {\\n\\tif i < 0 || j < 0 || i == len(board) || j == len(board[0]) {\\n\\t\\treturn\\n\\t}\\n\\tc := board[i][j]\\n\\tif c == \\'#\\' || node.children[c-\\'a\\'] == nil {\\n\\t\\treturn\\n\\t}\\n\\tnode = node.children[c-\\'a\\']\\n\\tif node.word != \"\" {\\n\\t\\t*result = append(*result, node.word)\\n\\t\\tnode.word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'#\\'\\n\\tdfs(i+1, j, board, node, result)\\n\\tdfs(i-1, j, board, node, result)\\n\\tdfs(i, j+1, board, node, result)\\n\\tdfs(i, j-1, board, node, result)\\n\\tboard[i][j] = c\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype TrieNode struct {\\n\\tword     string\\n\\tchildren [26]*TrieNode\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\troot := &TrieNode{}\\n\\tfor _, w := range words {\\n\\t\\tnode := root\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tif node.children[c-\\'a\\'] == nil {\\n\\t\\t\\t\\tnode.children[c-\\'a\\'] = &TrieNode{}\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[c-\\'a\\']\\n\\t\\t}\\n\\t\\tnode.word = w\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tdfs(i, j, board, root, &result)\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(i, j int, board [][]byte, node *TrieNode, result *[]string) {\\n\\tif i < 0 || j < 0 || i == len(board) || j == len(board[0]) {\\n\\t\\treturn\\n\\t}\\n\\tc := board[i][j]\\n\\tif c == \\'#\\' || node.children[c-\\'a\\'] == nil {\\n\\t\\treturn\\n\\t}\\n\\tnode = node.children[c-\\'a\\']\\n\\tif node.word != \"\" {\\n\\t\\t*result = append(*result, node.word)\\n\\t\\tnode.word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'#\\'\\n\\tdfs(i+1, j, board, node, result)\\n\\tdfs(i-1, j, board, node, result)\\n\\tdfs(i, j+1, board, node, result)\\n\\tdfs(i, j-1, board, node, result)\\n\\tboard[i][j] = c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269110,
                "title": "python-clean-trie-dfs",
                "content": "As each cell value is a character, we can leverage trie to store those target words. And later when we DFS those \"character paths\" in the board, we can check all identical prefixes in the same DFS.\\nE.g. We have target words {\"air\", \"aisle\"}. Without a trie, when we meet an \"a\" in board, we have to perform two seperate DFS for \"air\" and \"aisle\". With a trie, two words share a same prefix of \"a\" and \"i\" so DFS seperates until the 3rd character. This greatly reduces search branch.\\n\\nSo first we store our target words in a trie. I used a \"$\" to mark the end of a word. Later in DFS, when we meet a \"$\" in trie node, we know we have found a word and add it to answer array.\\nThen we run DFS from each cell in the board. In each iteration, we need to temporarily remove the character in the current cell since each character can only be used once. If current cell\\'s character appears in current trie, we go for that subtrie rooted at that node.\\n```\\ndef findWords(board, words):\\n\\ttrie, ans, m, n = {}, set(), len(board), len(board) and len(board[0])\\n\\tfor word in words:\\n\\t\\tnode = trie\\n\\t\\tfor c in word: node = node.setdefault(c, {})\\n\\t\\tnode[\\'$\\'] = None\\n\\tdef dfs(i, j, node, word):\\n\\t\\tif board[i][j] in node:\\n\\t\\t\\tboard[i][j], c = \\'\\', board[i][j]\\n\\t\\t\\tnode, word = node[c], word + c\\n\\t\\t\\tif \\'$\\' in node: ans.add(word)\\n\\t\\t\\tfor x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n: \\n\\t\\t\\t\\t\\tdfs(x, y, node, word)\\n\\t\\t\\tboard[i][j] = c\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdfs(i, j, trie, \\'\\')\\n\\treturn list(ans)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findWords(board, words):\\n\\ttrie, ans, m, n = {}, set(), len(board), len(board) and len(board[0])\\n\\tfor word in words:\\n\\t\\tnode = trie\\n\\t\\tfor c in word: node = node.setdefault(c, {})\\n\\t\\tnode[\\'$\\'] = None\\n\\tdef dfs(i, j, node, word):\\n\\t\\tif board[i][j] in node:\\n\\t\\t\\tboard[i][j], c = \\'\\', board[i][j]\\n\\t\\t\\tnode, word = node[c], word + c\\n\\t\\t\\tif \\'$\\' in node: ans.add(word)\\n\\t\\t\\tfor x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n: \\n\\t\\t\\t\\t\\tdfs(x, y, node, word)\\n\\t\\t\\tboard[i][j] = c\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdfs(i, j, trie, \\'\\')\\n\\treturn list(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3207483,
                "title": "c-dfs-solution-without-using-trie",
                "content": "# Intuition\\nThough the problem requires the knowledge of Trie, it can be done without actually using the Trie as well, but proper optimisations in backtracking is required to pass all cases. \\n\\n# Approach\\nOptimisations done to improve the time.\\n- Used unordered_map instead of map\\n- Used prefix hashmap of all words and retured back as soon as prefix isn\\'t present in the hashmap\\n- Precalculated the max length among all words[i] and returned when the recursive call exceeds the max length.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(vector<vector<char>>&board,unordered_map<string,int>&mp,string &t,int i,int j,unordered_map<string,int>&store,int len){\\n        if(i>=board.size() || j>=board[0].size() || i<0 || j<0 || board[i][j]==\\'0\\'){return;}\\n        if(store[t]==0){return;}\\n        if(t.size()>=len){return;}\\n        char temp1=board[i][j];\\n        t.push_back(board[i][j]);\\n        board[i][j]=\\'0\\';\\n        mp[t]=1;\\n        help(board,mp,t,i+1,j,store,len);\\n        help(board,mp,t,i,j+1,store,len);\\n        help(board,mp,t,i-1,j,store,len);\\n        help(board,mp,t,i,j-1,store,len);\\n        board[i][j]=temp1;\\n        t.pop_back();\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        unordered_map<string,int>store;\\n        int len=0;\\n        string g;\\n        for(int i=0;i<words.size();i++){\\n            g=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                 g+=words[i][j];\\n                 store[g]=1;\\n            }\\n            len=max(len,(int)words[i].size());\\n        }\\n        string t=\"\";\\n        store[t]=1;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                help(board,mp,t,i,j,store,len);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto x:words){\\n            if(mp[x]){\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<vector<char>>&board,unordered_map<string,int>&mp,string &t,int i,int j,unordered_map<string,int>&store,int len){\\n        if(i>=board.size() || j>=board[0].size() || i<0 || j<0 || board[i][j]==\\'0\\'){return;}\\n        if(store[t]==0){return;}\\n        if(t.size()>=len){return;}\\n        char temp1=board[i][j];\\n        t.push_back(board[i][j]);\\n        board[i][j]=\\'0\\';\\n        mp[t]=1;\\n        help(board,mp,t,i+1,j,store,len);\\n        help(board,mp,t,i,j+1,store,len);\\n        help(board,mp,t,i-1,j,store,len);\\n        help(board,mp,t,i,j-1,store,len);\\n        board[i][j]=temp1;\\n        t.pop_back();\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        unordered_map<string,int>store;\\n        int len=0;\\n        string g;\\n        for(int i=0;i<words.size();i++){\\n            g=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                 g+=words[i][j];\\n                 store[g]=1;\\n            }\\n            len=max(len,(int)words[i].size());\\n        }\\n        string t=\"\";\\n        store[t]=1;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                help(board,mp,t,i,j,store,len);\\n            }\\n        }\\n        vector<string>ans;\\n        for(auto x:words){\\n            if(mp[x]){\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954040,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass TrieNode{\\npublic:\\n    bool is_end;\\n    vector<TrieNode*> children;\\n    TrieNode(){\\n        is_end=false;\\n        children=vector<TrieNode*>(26, NULL);\\n    }   \\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        root=new TrieNode();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            TrieNode* cur=root;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                int k=words[i][j]-\\'a\\';\\n                if(cur->children[k]==NULL)\\n                    cur->children[k]=new TrieNode();\\n                cur=cur->children[k];\\n            }\\n            cur->is_end=true;\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                search(board, root, \"\", ans, i, j);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void search(vector<vector<char>>& board, TrieNode* root, string word, vector<string>& s, int x, int y)\\n    {\\n        if(root->is_end)\\n        {\\n            s.push_back(word);\\n            root->is_end = false;\\n        }\\n        if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'.\\')\\n            return;\\n        char c=board[x][y];\\n        int k=c-\\'a\\';\\n        if(root->children[k]==NULL)\\n            return;\\n        root=root->children[k];\\n        board[x][y]=\\'.\\';\\n        word+=c;\\n        search(board, root, word, s, x+1, y);\\n        search(board, root, word, s, x-1, y);\\n        search(board, root, word, s, x, y+1);\\n        search(board, root, word, s, x, y-1);\\n        board[x][y]=c;\\n    }\\n    TrieNode* root;\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    bool is_end;\\n    vector<TrieNode*> children;\\n    TrieNode(){\\n        is_end=false;\\n        children=vector<TrieNode*>(26, NULL);\\n    }   \\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        root=new TrieNode();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            TrieNode* cur=root;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                int k=words[i][j]-\\'a\\';\\n                if(cur->children[k]==NULL)\\n                    cur->children[k]=new TrieNode();\\n                cur=cur->children[k];\\n            }\\n            cur->is_end=true;\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                search(board, root, \"\", ans, i, j);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void search(vector<vector<char>>& board, TrieNode* root, string word, vector<string>& s, int x, int y)\\n    {\\n        if(root->is_end)\\n        {\\n            s.push_back(word);\\n            root->is_end = false;\\n        }\\n        if(x<0 || y<0 || x>=board.size() || y>=board[0].size() || board[x][y]==\\'.\\')\\n            return;\\n        char c=board[x][y];\\n        int k=c-\\'a\\';\\n        if(root->children[k]==NULL)\\n            return;\\n        root=root->children[k];\\n        board[x][y]=\\'.\\';\\n        word+=c;\\n        search(board, root, word, s, x+1, y);\\n        search(board, root, word, s, x-1, y);\\n        search(board, root, word, s, x, y+1);\\n        search(board, root, word, s, x, y-1);\\n        board[x][y]=c;\\n    }\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782247,
                "title": "python-and-golang-4ms-100",
                "content": "<img src=\"https://assets.leetcode.com/users/images/592567a9-4b22-46f1-a1ed-75b7499fbc41_1667673644.841407.png\" width=\"500\"/>\\n\\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        res, trie, has = list(), dict(), set()\\n        \\n        for r in range(m):\\n            for c in range(n - 1):\\n                has.add(board[r][c] + board[r][c + 1])\\n        for r in range(m - 1):\\n            for c in range(n):\\n                has.add(board[r][c] + board[r + 1][c])\\n        \\n        for word in words:\\n            for i in range(len(word) - 1):\\n                a, b = word[i], word[i + 1]\\n                if a + b not in has and b + a not in has:\\n                    break\\n            else:\\n                cur = trie\\n                for c in word:\\n                    if c not in cur: cur[c] = {}\\n                    cur = cur[c]\\n                cur[\\'*\\'] = word\\n        \\n        def dfs(r, c, node):\\n            node = node[board[r][c]]\\n            if \\'*\\' in node:\\n                res.append(node[\\'*\\'])\\n                del node[\\'*\\']\\n            rc = board[r][c]\\n            board[r][c] = \\'*\\'\\n            for i, j in (0, 1), (1, 0), (0, -1), (-1, 0):\\n                dr, dc = r + i, c + j\\n                if dr < 0 or dr >= m or dc < 0 or dc >= n \\\\\\n                or board[dr][dc] not in node:\\n                    continue\\n                dfs(dr, dc, node)\\n                if len(node[board[dr][dc]]) == 0:\\n                    del node[board[dr][dc]]\\n            board[r][c] = rc\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] in trie:\\n                    dfs(r, c, trie)\\n        \\n        return res\\n```\\n```go\\ntype Node struct {\\n\\tchildren [26]*Node\\n\\tword     string\\n}\\n\\nfunc (n *Node) Insert(word string) {\\n\\tcur := n\\n\\tfor _, c := range word {\\n\\t\\tidx := c - \\'a\\'\\n\\t\\tif cur.children[idx] == nil {\\n\\t\\t\\tcur.children[idx] = &Node{}\\n\\t\\t}\\n\\t\\tcur = cur.children[idx]\\n\\t}\\n\\tcur.word = word\\n}\\n\\nfunc (n *Node) IsEmpty() bool {\\n\\tfor _, child := range n.children {\\n\\t\\tif child != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (n *Node) Remove(word string) bool {\\n\\tif len(word) == 0 {\\n\\t\\tn.word = \"\"\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\tchild := n.children[word[0]-\\'a\\']\\n\\tif child.Remove(word[1:]) {\\n\\t\\tn.children[word[0]-\\'a\\'] = nil\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, r, c int, root, cur *Node, res *[]string) {\\n\\trc := board[r][c]\\n\\tboard[r][c] = 0\\n    \\n\\tif cur.word != \"\" {\\n\\t\\t*res = append(*res, cur.word)\\n\\t\\troot.Remove(cur.word)\\n\\t}\\n\\tds := [5]int{0, 1, 0, -1, 0}\\n\\tfor i := 0; i < len(ds)-1; i++ {\\n\\t\\tdr, dc := r+ds[i], c+ds[i+1]\\n\\t\\tif dr < 0 || dr >= len(board) || dc < 0 || dc >= len(board[0]) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tb := board[dr][dc]\\n\\t\\tif b == 0 || cur.children[b-\\'a\\'] == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdfs(board, dr, dc, root, cur.children[b-\\'a\\'], res)\\n\\t}\\n\\tboard[r][c] = rc\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\tm, n := len(board), len(board[0])\\n\\tres, trie, has := []string{}, &Node{}, map[string]bool{}\\n\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n-1; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r][c+1])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m-1; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r+1][c])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tvalid := true\\n\\t\\tfor i := 0; i < len(word)-1; i++ {\\n\\t\\t\\ta, b := string(word[i]), string(word[i+1])\\n\\t\\t\\tif !has[a+b] && !has[b+a] {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif valid {\\n\\t\\t\\ttrie.Insert(word)\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tb := board[r][c]\\n\\t\\t\\tif trie.children[b-\\'a\\'] != nil {\\n\\t\\t\\t\\tdfs(board, r, c, trie, trie.children[b-\\'a\\'], &res)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        \\n        m, n = len(board), len(board[0])\\n        res, trie, has = list(), dict(), set()\\n        \\n        for r in range(m):\\n            for c in range(n - 1):\\n                has.add(board[r][c] + board[r][c + 1])\\n        for r in range(m - 1):\\n            for c in range(n):\\n                has.add(board[r][c] + board[r + 1][c])\\n        \\n        for word in words:\\n            for i in range(len(word) - 1):\\n                a, b = word[i], word[i + 1]\\n                if a + b not in has and b + a not in has:\\n                    break\\n            else:\\n                cur = trie\\n                for c in word:\\n                    if c not in cur: cur[c] = {}\\n                    cur = cur[c]\\n                cur[\\'*\\'] = word\\n        \\n        def dfs(r, c, node):\\n            node = node[board[r][c]]\\n            if \\'*\\' in node:\\n                res.append(node[\\'*\\'])\\n                del node[\\'*\\']\\n            rc = board[r][c]\\n            board[r][c] = \\'*\\'\\n            for i, j in (0, 1), (1, 0), (0, -1), (-1, 0):\\n                dr, dc = r + i, c + j\\n                if dr < 0 or dr >= m or dc < 0 or dc >= n \\\\\\n                or board[dr][dc] not in node:\\n                    continue\\n                dfs(dr, dc, node)\\n                if len(node[board[dr][dc]]) == 0:\\n                    del node[board[dr][dc]]\\n            board[r][c] = rc\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] in trie:\\n                    dfs(r, c, trie)\\n        \\n        return res\\n```\n```go\\ntype Node struct {\\n\\tchildren [26]*Node\\n\\tword     string\\n}\\n\\nfunc (n *Node) Insert(word string) {\\n\\tcur := n\\n\\tfor _, c := range word {\\n\\t\\tidx := c - \\'a\\'\\n\\t\\tif cur.children[idx] == nil {\\n\\t\\t\\tcur.children[idx] = &Node{}\\n\\t\\t}\\n\\t\\tcur = cur.children[idx]\\n\\t}\\n\\tcur.word = word\\n}\\n\\nfunc (n *Node) IsEmpty() bool {\\n\\tfor _, child := range n.children {\\n\\t\\tif child != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc (n *Node) Remove(word string) bool {\\n\\tif len(word) == 0 {\\n\\t\\tn.word = \"\"\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\tchild := n.children[word[0]-\\'a\\']\\n\\tif child.Remove(word[1:]) {\\n\\t\\tn.children[word[0]-\\'a\\'] = nil\\n\\t\\treturn n.IsEmpty()\\n\\t}\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, r, c int, root, cur *Node, res *[]string) {\\n\\trc := board[r][c]\\n\\tboard[r][c] = 0\\n    \\n\\tif cur.word != \"\" {\\n\\t\\t*res = append(*res, cur.word)\\n\\t\\troot.Remove(cur.word)\\n\\t}\\n\\tds := [5]int{0, 1, 0, -1, 0}\\n\\tfor i := 0; i < len(ds)-1; i++ {\\n\\t\\tdr, dc := r+ds[i], c+ds[i+1]\\n\\t\\tif dr < 0 || dr >= len(board) || dc < 0 || dc >= len(board[0]) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tb := board[dr][dc]\\n\\t\\tif b == 0 || cur.children[b-\\'a\\'] == nil {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdfs(board, dr, dc, root, cur.children[b-\\'a\\'], res)\\n\\t}\\n\\tboard[r][c] = rc\\n}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\tm, n := len(board), len(board[0])\\n\\tres, trie, has := []string{}, &Node{}, map[string]bool{}\\n\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n-1; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r][c+1])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m-1; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tp := string(board[r][c]) + string(board[r+1][c])\\n\\t\\t\\thas[p] = true\\n\\t\\t}\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tvalid := true\\n\\t\\tfor i := 0; i < len(word)-1; i++ {\\n\\t\\t\\ta, b := string(word[i]), string(word[i+1])\\n\\t\\t\\tif !has[a+b] && !has[b+a] {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif valid {\\n\\t\\t\\ttrie.Insert(word)\\n\\t\\t}\\n\\t}\\n\\tfor r := 0; r < m; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tb := board[r][c]\\n\\t\\t\\tif trie.children[b-\\'a\\'] != nil {\\n\\t\\t\\t\\tdfs(board, r, c, trie, trie.children[b-\\'a\\'], &res)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780094,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\n    struct TreeNode {\\n        TreeNode *children[26];\\n        string word;\\n\\n        TreeNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TreeNode *root = BuildTree(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *BuildTree(vector<string> &words) {\\n        TreeNode *root = new TreeNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TreeNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TreeNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TreeNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```\\n\\n*Upvote if it helped you!*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\n    struct TreeNode {\\n        TreeNode *children[26];\\n        string word;\\n\\n        TreeNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TreeNode *root = BuildTree(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *BuildTree(vector<string> &words) {\\n        TreeNode *root = new TreeNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TreeNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TreeNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TreeNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779796,
                "title": "optimised-with-trie",
                "content": "## Approach 1 : Brute Force\\n\\nfor every position in the board, dfs with it as the starting point and check if a word from the dictionary can be formed\\n```\\nclass Solution {\\n    void dfs(char board[][], boolean visited[][], int x, int y, String pick, HashSet<String> dictionary, List<String> res)\\n    {\\n        if(dictionary.contains(pick)) {\\n            res.add(pick);\\n        }\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n])\\n                dfs(board, visited, m, n, pick+board[m][n], dictionary, res);\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> dictionary=new HashSet<>();\\n        for(String word : words) dictionary.add(word);\\n        List<String> res=new ArrayList<>();\\n        boolean visited[][]=new boolean[board.length][board[0].length];\\n        \\n        //1. dfs and match\\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n                dfs(board, visited, i, j, Character.toString(board[i][j]), dictionary, res);\\n        }        \\n        \\n        return res;\\n    }\\n}\\n```\\n\\n## Approach 2 : Trie + DP\\nstore the dictionary as a trie instead of a set, and at every state of the search, only go for neighbours that shall end up in forming a word (using trie).\\n```\\nclass Node {\\n    char c;\\n    Node children[];\\n    boolean end;\\n    Node(char c)\\n    {\\n        this.c = c;\\n        children = new Node[26];\\n        end = false;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    void dfs(char board[][], boolean[][] visited, int x, int y, Node node, HashSet<Node> res)\\n    {\\n        if(node.end) res.add(node);\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n] && node.children[board[m][n] - \\'a\\'] != null)\\n            {\\n                dfs(board, visited, m, n, node.children[board[m][n] - \\'a\\'], res);\\n            }\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        //1. make trie, map end nodes with Strings\\n        HashMap<Node, String> nodeString = new HashMap<>();\\n        Node root = new Node(\\'\\\\0\\');\\n        for(String word : words)\\n        {\\n            Node node=root;\\n            for(int i=0; i<word.length(); i++)\\n            {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) node.children[c - \\'a\\'] = new Node (c);\\n                node = node.children[c - \\'a\\'];\\n            }\\n            node.end = true;\\n            nodeString.put(node, word);\\n        }\\n        \\n        //2. make visited board\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        \\n        HashSet<Node> res = new HashSet<>();\\n        //3. greedy dfs board\\n        \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n            {\\n                Node node = root;\\n                if(node.children[board[i][j] - \\'a\\'] != null)\\n                    dfs(board, visited, i, j, node.children[board[i][j] - \\'a\\'], res);\\n            }\\n        }\\n        \\n        //4. result\\n        List<String> ans = new ArrayList<>();\\n        for(Node node : res) ans.add(nodeString.get(node));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(char board[][], boolean visited[][], int x, int y, String pick, HashSet<String> dictionary, List<String> res)\\n    {\\n        if(dictionary.contains(pick)) {\\n            res.add(pick);\\n        }\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n])\\n                dfs(board, visited, m, n, pick+board[m][n], dictionary, res);\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> dictionary=new HashSet<>();\\n        for(String word : words) dictionary.add(word);\\n        List<String> res=new ArrayList<>();\\n        boolean visited[][]=new boolean[board.length][board[0].length];\\n        \\n        //1. dfs and match\\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n                dfs(board, visited, i, j, Character.toString(board[i][j]), dictionary, res);\\n        }        \\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Node {\\n    char c;\\n    Node children[];\\n    boolean end;\\n    Node(char c)\\n    {\\n        this.c = c;\\n        children = new Node[26];\\n        end = false;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    void dfs(char board[][], boolean[][] visited, int x, int y, Node node, HashSet<Node> res)\\n    {\\n        if(node.end) res.add(node);\\n        int dx[]={0, 0, 1, -1}, dy[]={-1, 1, 0, 0};\\n        visited[x][y]=true;\\n        for(int i=0; i<4; i++)\\n        {\\n            int m = x + dx[i], n = y + dy[i];\\n            boolean inBounds = -1<m && m<board.length && -1<n && n<board[m].length;\\n            if(inBounds && !visited[m][n] && node.children[board[m][n] - \\'a\\'] != null)\\n            {\\n                dfs(board, visited, m, n, node.children[board[m][n] - \\'a\\'], res);\\n            }\\n        }\\n        visited[x][y] = false;\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        //1. make trie, map end nodes with Strings\\n        HashMap<Node, String> nodeString = new HashMap<>();\\n        Node root = new Node(\\'\\\\0\\');\\n        for(String word : words)\\n        {\\n            Node node=root;\\n            for(int i=0; i<word.length(); i++)\\n            {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) node.children[c - \\'a\\'] = new Node (c);\\n                node = node.children[c - \\'a\\'];\\n            }\\n            node.end = true;\\n            nodeString.put(node, word);\\n        }\\n        \\n        //2. make visited board\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        \\n        HashSet<Node> res = new HashSet<>();\\n        //3. greedy dfs board\\n        \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[i].length; j++)\\n            {\\n                Node node = root;\\n                if(node.children[board[i][j] - \\'a\\'] != null)\\n                    dfs(board, visited, i, j, node.children[board[i][j] - \\'a\\'], res);\\n            }\\n        }\\n        \\n        //4. result\\n        List<String> ans = new ArrayList<>();\\n        for(Node node : res) ans.add(nodeString.get(node));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779714,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/word-search-ii.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nconst endWord = \\'*\\'\\n\\nclass Trie{\\n    constructor(words){\\n        this.root = {}\\n        this.isWord = false\\n        words.forEach(word => this.addWord(word))\\n    }\\n    \\n    addWord(word){\\n        let current = this.root\\n        \\n        for(const letter of word){\\n            if(!current[letter]){\\n                current[letter] = {}\\n            }\\n            current = current[letter]   \\n        }\\n        current.isWord = true\\n    }\\n    \\n}\\n\\n\\nvar findWords = function(board, words) {\\n    const trie = new Trie(words)\\n    const result = new Set()\\n    \\n    const visited = new Set()\\n    \\n    const dfs = (i, j, node, subResult) => {\\n        //base cases: out of bounds, letter does not exist in next prefix\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node[board[i][j]] || visited.has(`${i} ${j}`)){\\n            return\\n        }\\n        \\n        visited.add(`${i} ${j}`)\\n        subResult += board[i][j]\\n        \\n        node = node[board[i][j]]\\n        \\n        if(node.isWord){\\n            result.add(subResult)    \\n        }\\n        \\n        dfs(i, j+1, node, subResult)\\n        dfs(i, j-1, node, subResult)\\n        dfs(i-1, j, node, subResult)\\n        dfs(i+1, j, node, subResult)\\n        \\n        \\n        visited.delete(`${i} ${j}`)\\n        \\n    }\\n    \\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            if(trie.root[board[i][j]]){\\n                dfs(i, j, trie.root, \"\")\\n            }\\n        }\\n    }\\n    \\n    \\n    return [...result]\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nconst endWord = \\'*\\'\\n\\nclass Trie{\\n    constructor(words){\\n        this.root = {}\\n        this.isWord = false\\n        words.forEach(word => this.addWord(word))\\n    }\\n    \\n    addWord(word){\\n        let current = this.root\\n        \\n        for(const letter of word){\\n            if(!current[letter]){\\n                current[letter] = {}\\n            }\\n            current = current[letter]   \\n        }\\n        current.isWord = true\\n    }\\n    \\n}\\n\\n\\nvar findWords = function(board, words) {\\n    const trie = new Trie(words)\\n    const result = new Set()\\n    \\n    const visited = new Set()\\n    \\n    const dfs = (i, j, node, subResult) => {\\n        //base cases: out of bounds, letter does not exist in next prefix\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node[board[i][j]] || visited.has(`${i} ${j}`)){\\n            return\\n        }\\n        \\n        visited.add(`${i} ${j}`)\\n        subResult += board[i][j]\\n        \\n        node = node[board[i][j]]\\n        \\n        if(node.isWord){\\n            result.add(subResult)    \\n        }\\n        \\n        dfs(i, j+1, node, subResult)\\n        dfs(i, j-1, node, subResult)\\n        dfs(i-1, j, node, subResult)\\n        dfs(i+1, j, node, subResult)\\n        \\n        \\n        visited.delete(`${i} ${j}`)\\n        \\n    }\\n    \\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            if(trie.root[board[i][j]]){\\n                dfs(i, j, trie.root, \"\")\\n            }\\n        }\\n    }\\n    \\n    \\n    return [...result]\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104770,
                "title": "get-to-99-with-one-hack",
                "content": "Just filter out words that are not possible on board and due to the way test cases are structured, just construct trie with words reversed. Just remove reversed keyword to have your old solution xD\\n```\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        boardc = collections.Counter(sum(board,[]))\\n        words = [word for word in words if collections.Counter(word) <= boardc]\\n        trie = {}\\n        for word in words:\\n            node = trie\\n            for c in reversed(word):\\n                node = node.setdefault(c, {})\\n            node[\\'$\\'] = word\\n            \\n        def find(i,j,node):\\n            if \\'$\\' in node: out.append(node.pop(\\'$\\'))\\n            if not node: return\\n            tmp, board[i][j] = board[i][j], \\'#\\'\\n            \\n            for dx,dy in [(i+1, j),(i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=dx<m and 0<=dy<n and board[dx][dy] in node:\\n                    find(dx,dy,node[board[dx][dy]])\\n                    if not node[board[dx][dy]]: node.pop(board[dx][dy])\\n            board[i][j] = tmp\\n            \\n            return 0\\n                    \\n        m, n = len(board), len(board[0])\\n        out = []\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie:\\n                    find(i,j,trie[board[i][j]])\\n                    if not trie[board[i][j]]: trie.pop(board[i][j])\\n                if len(words) == len(out): return out\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        boardc = collections.Counter(sum(board,[]))\\n        words = [word for word in words if collections.Counter(word) <= boardc]\\n        trie = {}\\n        for word in words:\\n            node = trie\\n            for c in reversed(word):\\n                node = node.setdefault(c, {})\\n            node[\\'$\\'] = word\\n            \\n        def find(i,j,node):\\n            if \\'$\\' in node: out.append(node.pop(\\'$\\'))\\n            if not node: return\\n            tmp, board[i][j] = board[i][j], \\'#\\'\\n            \\n            for dx,dy in [(i+1, j),(i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=dx<m and 0<=dy<n and board[dx][dy] in node:\\n                    find(dx,dy,node[board[dx][dy]])\\n                    if not node[board[dx][dy]]: node.pop(board[dx][dy])\\n            board[i][j] = tmp\\n            \\n            return 0\\n                    \\n        m, n = len(board), len(board[0])\\n        out = []\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie:\\n                    find(i,j,trie[board[i][j]])\\n                    if not trie[board[i][j]]: trie.pop(board[i][j])\\n                if len(words) == len(out): return out\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512832,
                "title": "clean-go-solution-using-trie-and-dfs",
                "content": "```\\nvar directions = [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\ttrie := new(TrieNode)\\n\\tfor _, word := range words {\\n\\t\\ttrie.insert(word)\\n\\t}\\n\\n\\tresult := make([]string, 0, len(words))\\n\\tfor i, row := range board {\\n\\t\\tfor j, ch := range row {\\n\\t\\t\\tidx := ch - \\'a\\'\\n\\t\\t\\tif tn := trie.Children[idx]; tn != nil {\\n\\t\\t\\t\\tdfs(board, i, j, trie, &result)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc dfs(board [][]byte, i, j int, node *TrieNode, result *[]string) {\\n\\tletter := board[i][j]\\n\\tnode = node.Children[letter-\\'a\\']\\n\\tif node == nil {\\n\\t\\treturn\\n\\t} else if node.Word != \"\" {\\n\\t\\t*result = append(*result, node.Word)\\n\\t\\tnode.Word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'.\\'\\n\\tfor _, dir := range directions {\\n\\t\\tx, y := i+dir[0], j+dir[1]\\n\\t\\tif x >= 0 && x < len(board) && y >= 0 && y < len(board[0]) && board[x][y] != \\'.\\' {\\n\\t\\t\\tdfs(board, x, y, node, result)\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = letter\\n}\\n\\ntype TrieNode struct {\\n\\tChildren [26]*TrieNode\\n\\tWord     string\\n}\\n\\nfunc (tn *TrieNode) insert(word string) {\\n\\tfor _, ch := range word {\\n\\t\\tidx := ch - \\'a\\'\\n\\t\\tif tn.Children[idx] == nil {\\n\\t\\t\\ttn.Children[idx] = new(TrieNode)\\n\\t\\t}\\n\\t\\ttn = tn.Children[idx]\\n\\t}\\n\\ttn.Word = word\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nvar directions = [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\\n\\nfunc findWords(board [][]byte, words []string) []string {\\n\\ttrie := new(TrieNode)\\n\\tfor _, word := range words {\\n\\t\\ttrie.insert(word)\\n\\t}\\n\\n\\tresult := make([]string, 0, len(words))\\n\\tfor i, row := range board {\\n\\t\\tfor j, ch := range row {\\n\\t\\t\\tidx := ch - \\'a\\'\\n\\t\\t\\tif tn := trie.Children[idx]; tn != nil {\\n\\t\\t\\t\\tdfs(board, i, j, trie, &result)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc dfs(board [][]byte, i, j int, node *TrieNode, result *[]string) {\\n\\tletter := board[i][j]\\n\\tnode = node.Children[letter-\\'a\\']\\n\\tif node == nil {\\n\\t\\treturn\\n\\t} else if node.Word != \"\" {\\n\\t\\t*result = append(*result, node.Word)\\n\\t\\tnode.Word = \"\"\\n\\t}\\n\\n\\tboard[i][j] = \\'.\\'\\n\\tfor _, dir := range directions {\\n\\t\\tx, y := i+dir[0], j+dir[1]\\n\\t\\tif x >= 0 && x < len(board) && y >= 0 && y < len(board[0]) && board[x][y] != \\'.\\' {\\n\\t\\t\\tdfs(board, x, y, node, result)\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = letter\\n}\\n\\ntype TrieNode struct {\\n\\tChildren [26]*TrieNode\\n\\tWord     string\\n}\\n\\nfunc (tn *TrieNode) insert(word string) {\\n\\tfor _, ch := range word {\\n\\t\\tidx := ch - \\'a\\'\\n\\t\\tif tn.Children[idx] == nil {\\n\\t\\t\\ttn.Children[idx] = new(TrieNode)\\n\\t\\t}\\n\\t\\ttn = tn.Children[idx]\\n\\t}\\n\\ttn.Word = word\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511595,
                "title": "simple-to-understand-using-dfs-word-search-i-with-modifications",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n***Updated solution using Trie***\\n\\n```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Add words to the trie\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        var root = trie.GetRoot();\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                DFS(board, rowIndex, colIndex, root, result);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void DFS(char[][] board, int row, int col, TrieNode node, List<string> result) {\\n        // Make sure the search paramaters are in bounds\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return;            \\n        }\\n        // Check to see if this row has been visited\\n        var rowVisitedMarker = \\'@\\';\\n        if (board[row][col] == rowVisitedMarker) {\\n            return;            \\n        } \\n        // Check to see if this character exists in the trie\\n        if (!node.ContainsKey(board[row][col])) {\\n            return;            \\n        }    \\n        \\n        // Get the trie node for this char\\n        node = node.Get(board[row][col]);\\n        \\n        if (!node.visited && !string.IsNullOrEmpty(node.word)) {\\n            result.Add(node.word);\\n            node.visited = true;      \\n        }\\n        \\n        // Mark that this row has been visited\\n        var oldValue = board[row][col];        \\n        board[row][col] = rowVisitedMarker;\\n        \\n        // Search left\\n        DFS(board, row, col - 1, node, result);\\n\\n        // Search right\\n        DFS(board, row, col + 1, node, result);\\n\\n        // Search top\\n        DFS(board, row - 1, col, node, result);\\n\\n        // Search bottom\\n        DFS(board, row + 1, col, node, result);\\n        \\n        // Unmark that this row has been visited\\n        board[row][col] = oldValue;\\n    }   \\n    \\n    \\n    // Trie\\n    public class Trie {\\n        private TrieNode root;\\n\\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        public TrieNode GetRoot() {\\n            return root;\\n        }\\n        public void Insert(string word) {\\n            var node = root;\\n            foreach (var ch in word) {\\n                if (!node.ContainsKey(ch)) {\\n                    node.Add(ch, new TrieNode());\\n                }\\n                node = node.Get(ch);\\n            }\\n            node.word = word;\\n        }\\n    }\\n\\n    // TrieNode\\n    public class TrieNode {\\n        private Dictionary<char, TrieNode> children;\\n        public string word = string.Empty;\\n        public bool visited = false;\\n\\n        public TrieNode() {\\n            children = new Dictionary<char, TrieNode>();\\n        }\\n        public bool ContainsKey(char ch) {\\n            return children.ContainsKey(ch);\\n        }\\n        public TrieNode Get(char ch) {\\n            return children[ch];\\n        }\\n        public void Add(char ch, TrieNode node) {\\n            children[ch] = node;\\n        }\\n    }\\n}\\n```\\n\\n\\n=================================\\n\\n***Original Solution***\\n\\nThis solution uses DFS & Word Search I.\\n\\nThe main change here is that we remove any words that have characters that dont appear on the board.\\n\\nThis speeds things up because it makes it so we only use DFS for the words where all their characters appear on the board\\n\\n```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Remove any words that have characters that dont appear on the board\\n        var validWords = GetValidWords(board, words);\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Find the words that can be constructed\\n        foreach (var word in validWords) {\\n            if (Exist(board, word, rowsVisited)) {\\n                result.Add(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<string> GetValidWords(char[][] board, string[] words) {\\n        // Get all the characters on the board\\n        var boardCharacters = new HashSet<char>();\\n        foreach (var row in board) {\\n            foreach (var ch in row) {\\n                boardCharacters.Add(ch);\\n            }\\n        }\\n        \\n        // Only return the words where all characters appear on the board\\n        var validWords = new List<string>();\\n        foreach (var word in words) {\\n            var valid = true;\\n            foreach (var ch in word) {\\n                if (!boardCharacters.Contains(ch)) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if (valid) {\\n               validWords.Add(word); \\n            }\\n        } \\n        return validWords;\\n    }\\n    \\n    private bool Exist(char[][] board, string word, bool[][] rowsVisited) {        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Add words to the trie\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        var root = trie.GetRoot();\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                DFS(board, rowIndex, colIndex, root, result);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void DFS(char[][] board, int row, int col, TrieNode node, List<string> result) {\\n        // Make sure the search paramaters are in bounds\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return;            \\n        }\\n        // Check to see if this row has been visited\\n        var rowVisitedMarker = \\'@\\';\\n        if (board[row][col] == rowVisitedMarker) {\\n            return;            \\n        } \\n        // Check to see if this character exists in the trie\\n        if (!node.ContainsKey(board[row][col])) {\\n            return;            \\n        }    \\n        \\n        // Get the trie node for this char\\n        node = node.Get(board[row][col]);\\n        \\n        if (!node.visited && !string.IsNullOrEmpty(node.word)) {\\n            result.Add(node.word);\\n            node.visited = true;      \\n        }\\n        \\n        // Mark that this row has been visited\\n        var oldValue = board[row][col];        \\n        board[row][col] = rowVisitedMarker;\\n        \\n        // Search left\\n        DFS(board, row, col - 1, node, result);\\n\\n        // Search right\\n        DFS(board, row, col + 1, node, result);\\n\\n        // Search top\\n        DFS(board, row - 1, col, node, result);\\n\\n        // Search bottom\\n        DFS(board, row + 1, col, node, result);\\n        \\n        // Unmark that this row has been visited\\n        board[row][col] = oldValue;\\n    }   \\n    \\n    \\n    // Trie\\n    public class Trie {\\n        private TrieNode root;\\n\\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        public TrieNode GetRoot() {\\n            return root;\\n        }\\n        public void Insert(string word) {\\n            var node = root;\\n            foreach (var ch in word) {\\n                if (!node.ContainsKey(ch)) {\\n                    node.Add(ch, new TrieNode());\\n                }\\n                node = node.Get(ch);\\n            }\\n            node.word = word;\\n        }\\n    }\\n\\n    // TrieNode\\n    public class TrieNode {\\n        private Dictionary<char, TrieNode> children;\\n        public string word = string.Empty;\\n        public bool visited = false;\\n\\n        public TrieNode() {\\n            children = new Dictionary<char, TrieNode>();\\n        }\\n        public bool ContainsKey(char ch) {\\n            return children.ContainsKey(ch);\\n        }\\n        public TrieNode Get(char ch) {\\n            return children[ch];\\n        }\\n        public void Add(char ch, TrieNode node) {\\n            children[ch] = node;\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new List<string>();\\n        \\n        // Remove any words that have characters that dont appear on the board\\n        var validWords = GetValidWords(board, words);\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Find the words that can be constructed\\n        foreach (var word in validWords) {\\n            if (Exist(board, word, rowsVisited)) {\\n                result.Add(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private List<string> GetValidWords(char[][] board, string[] words) {\\n        // Get all the characters on the board\\n        var boardCharacters = new HashSet<char>();\\n        foreach (var row in board) {\\n            foreach (var ch in row) {\\n                boardCharacters.Add(ch);\\n            }\\n        }\\n        \\n        // Only return the words where all characters appear on the board\\n        var validWords = new List<string>();\\n        foreach (var word in words) {\\n            var valid = true;\\n            foreach (var ch in word) {\\n                if (!boardCharacters.Contains(ch)) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if (valid) {\\n               validWords.Add(word); \\n            }\\n        } \\n        return validWords;\\n    }\\n    \\n    private bool Exist(char[][] board, string word, bool[][] rowsVisited) {        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509296,
                "title": "java-dfs-explains-common-approach-for-such-problems-to-do-using-trie",
                "content": "`````\\n/**\\n * 212. Word Search II\\n *\\n * Similar problems: solved in same way\\n * 79. Word Search\\n * Link: https://leetcode.com/problems/word-search/discuss/1508413/java-easy-dfs-backtracking-with-explanation\\n *\\n * 219. Path with Maximum Gold\\n * Link: https://leetcode.com/problems/path-with-maximum-gold/discuss/1508629/easy-dfs-well-explained-with-similar-pattern-problems-java-solution\\n *\\n * 733. Flood Fill\\n * https://leetcode.com/problems/flood-fill/discuss/1511986/Efficient-easy-well-explained-with-common-pattern-or-Java\\n *\\n  **** Note ***: This is not the most efficient solution.The efficient solution would be to use a Trie.\\n  * This is to show a common pattern with previous question.\\n  * WIll post the trie solution soon.\\n \\n */\\nclass Solution {\\n    private  boolean[][] visited;\\n    int nRow, nCol;\\n    Set<String> result;\\n    int[] xs = {0, -1, 0, 1};\\n    int[] ys = {-1, 0, 1, 0};\\n\\n\\n\\n    /**\\n     * Check for each cell if the char matches then do a dfs if not back track search for other directions\\n     * if none of matches then return and try for another cell from the start.\\n     * @param board\\n     * @param words\\n     * @return\\n     */\\n    public List<String> findWords(char[][] board, String[] words) {\\n        nRow=board.length;\\n        nCol=board[0].length;\\n        visited=new boolean[nRow][nCol];\\n        result=new HashSet<>();\\n        //running for each cell\\n        for(String word: words) {//for each word\\n            for (int i = 0; i < nRow; i++) {\\n                for (int j = 0; j < nCol; j++) {\\n                    dfs(board, word, i, j, 0);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n     /**\\n     * DFS for an array\\n     * @param board\\n     * @param word\\n     * @param x\\n     * @param y\\n     * @param indexWord\\n     */\\n     private void dfs(char[][] board,String word,int x,int y,int indexWord){\\n        if(indexWord>=word.length())\\n            return;\\n        //to check if word is found or not\\n        if(indexWord==word.length()-1 && word.charAt(indexWord)==board[x][y]) {\\n            result.add(word);\\n            return ;\\n        }\\n    \\n        \\n        //boundary condition so that dfs doesnt go out of the grid\\n       // else if(x> nRow-1 || y> nCol-1 || x<0 || y<0 || word.charAt(indexWord)!=board[x][y])\\n        else if(word.charAt(indexWord)!=board[x][y])\\n            return ;\\n      //mark as visited\\n        visited[x][y]=true;\\n        //for all 4 directions call dfs\\n        for(int i=0;i<4;i++){\\n            int row=x+xs[i];\\n            int col=y+ys[i];\\n            //check to see if DFS can be called or not\\n            if(row<= nRow-1 && col<= nCol-1 && row>=0 && col>=0 && !visited[row][col])\\n                dfs(board,word,row,col,indexWord+1);\\n        }\\n        //reset for back track\\n        visited[x][y]=false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private  boolean[][] visited;\\n    int nRow, nCol;\\n    Set<String> result;\\n    int[] xs = {0, -1, 0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1473016,
                "title": "c-trie-dfs-easy-to-understand-290ms",
                "content": "\\nclass Solution {    \\n    struct node{    //TrieNode\\n        char c;\\n        int end;\\n        string word;\\n        node *child[26];\\n    };\\n    struct node *getNode(char c)    //get newnode\\n    {\\n        node *newnode = new node;\\n        newnode->c = c;\\n        newnode->end = 0;\\n        newnode->word = \"\";\\n        for(int i=0;i<26;++i)\\n            newnode->child[i] = NULL;\\n        return newnode;\\n    }\\n    node *root = getNode(\\'/\\');  //root\\n    \\n    //Trie INSERT\\n    void insert(string s)\\n    {\\n        node *cur = root;\\n        int index,i=0;\\n        while(s[i])\\n        {\\n            index = s[i]-\\'a\\';\\n            if(cur->child[index]==NULL){\\n                cur->child[index] = getNode(s[i]);\\n            } \\n            cur=cur->child[index];\\n            i++;\\n        }\\n        cur->end += 1;\\n        cur->word = s;\\n    }\\n    \\n    void solve(vector<vector<char>>& board,int i,int j,vector<string>& ans,node *cur) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        //Base case\\n        //If the trie doesn\\'t have the current char OR cell is Visited\\n        int index = board[i][j]-\\'a\\';\\n        if(board[i][j]==\\'#\\' || cur->child[index]==NULL)  \\n            return;\\n        \\n        cur = cur->child[index];\\n        if(cur->end > 0)\\n        {\\n            ans.push_back(cur->word);\\n            cur->end -=1;\\n        }\\n        \\n        //Body\\n        char ch = board[i][j];   //Store current char\\n        board[i][j] = \\'#\\';  //Mark current node visited\\n        \\n        if(i>0)     //TOP\\n            solve(board,i-1,j,ans,cur);\\n        if(i<r-1)   //DOWN\\n            solve(board,i+1,j,ans,cur);\\n        if(j>0)     //LEFT\\n            solve(board,i,j-1,ans,cur);\\n        if(j<c-1)   //RIGHT\\n            solve(board,i,j+1,ans,cur);\\n        \\n        board[i][j] = ch;    //Mark current node as Unvisited by restoring the value\\n    }\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {        \\n        int r=board.size();\\n        int c=board[0].size();\\n        \\n        //Insert all words in TRIE\\n        for(int i=0;i<words.size();++i){\\n            insert(words[i]);\\n        }\\n            \\n        \\n        //Now search words\\n        vector<string> ans;\\n        for(int i=0;i<r;++i) {\\n            for(int j=0;j<c;++j) {\\n                solve(board,i,j,ans,root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nstatic int fastio = []() {\\n    #define endl \\'\\\\n\\'\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    std::cout.tie(0);\\n    return 0;\\n}();",
                "solutionTags": [],
                "code": "class Solution {    \\n    struct node{    //TrieNode\\n        char c;\\n        int end;\\n        string word;\\n        node *child[26];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 871865,
                "title": "python-3-simple-trie-solution-beats-90-easy-to-understand",
                "content": "```\\nclass trie:\\n    def __init__(self):\\n        self.children=[None]*26\\n        self.isend=False\\n    def insert(self,word):\\n        for i in word:\\n            if self.children[ord(i)-ord(\\'a\\')]==None:\\n                self.children[ord(i)-ord(\\'a\\')]=trie()\\n            self=self.children[ord(i)-ord(\\'a\\')]\\n        self.isend=True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def search(x,y,tre,s):\\n            if board[x][y]==\\'#\\':\\n                return \\n            c=board[x][y]\\n            board[x][y]=\\'#\\'\\n            t=tre.children[ord(c)-ord(\\'a\\')]\\n            if t!=None:\\n                ss=s+c\\n                if t.isend:result.add(ss)\\n                if x>0:search(x-1,y,t,ss)\\n                if y>0:search(x,y-1,t,ss)\\n                if x<len(board)-1:search(x+1,y,t,ss)\\n                if y<len(board[0])-1:search(x,y+1,t,ss)\\n            board[x][y]=c\\n        \\n        m,n=len(board),len(board[0])\\n        if len(words)==0:\\n            return []\\n        t=trie()\\n        for w in words:\\n            t.insert(w)\\n        result=set()\\n        for i in range(m):\\n            for j in range(n):\\n                k=board[i][j]\\n                if t.children[ord(k)-ord(\\'a\\')]!=None:\\n                    search(i,j,t,\"\")\\n        \\n        return list(result)\\n                        \\n```\\nplease upvote if u like..!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass trie:\\n    def __init__(self):\\n        self.children=[None]*26\\n        self.isend=False\\n    def insert(self,word):\\n        for i in word:\\n            if self.children[ord(i)-ord(\\'a\\')]==None:\\n                self.children[ord(i)-ord(\\'a\\')]=trie()\\n            self=self.children[ord(i)-ord(\\'a\\')]\\n        self.isend=True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def search(x,y,tre,s):\\n            if board[x][y]==\\'#\\':\\n                return \\n            c=board[x][y]\\n            board[x][y]=\\'#\\'\\n            t=tre.children[ord(c)-ord(\\'a\\')]\\n            if t!=None:\\n                ss=s+c\\n                if t.isend:result.add(ss)\\n                if x>0:search(x-1,y,t,ss)\\n                if y>0:search(x,y-1,t,ss)\\n                if x<len(board)-1:search(x+1,y,t,ss)\\n                if y<len(board[0])-1:search(x,y+1,t,ss)\\n            board[x][y]=c\\n        \\n        m,n=len(board),len(board[0])\\n        if len(words)==0:\\n            return []\\n        t=trie()\\n        for w in words:\\n            t.insert(w)\\n        result=set()\\n        for i in range(m):\\n            for j in range(n):\\n                k=board[i][j]\\n                if t.children[ord(k)-ord(\\'a\\')]!=None:\\n                    search(i,j,t,\"\")\\n        \\n        return list(result)\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 830313,
                "title": "two-steps-java-solution-explained-with-comments-line-by-line",
                "content": "There are only 2 steps in this solution\\n1. Form the Trie (If you do not know what trie is and how it works please go and check that)\\n2. DFS (Again if you don\\'t know about recursion,backtracking and dfs please go check otherwise you won\\'t understand this or any solution for this problem)\\nHere first we\\'ve formed a trie and searched words from matrix (board) while traversing the trie in all the directions of matrix i.e. normal dfs.\\n```\\nclass Trie{\\n    Trie[] children = new Trie[26];\\n    String wrd; //instead of boolean isEnd as we need to return list<String> it should be a word\\n}\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        Trie root = buildTrie(words); //build trie of words and search in matrix\\n        for(int i = 0;i<board.length;i++){\\n            for(int j = 0;j<board[0].length;j++){\\n                dfs(board,i,j,root,res);\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(char[][] board, int i, int j, Trie p, List<String> res) {\\n        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j] == \\'#\\' || p.children[board[i][j] - \\'a\\'] == null)\\n            return; //if i or j is out of bound or if char(board[i][j]) is already visited(\\'#\\') or its child is null rerturn\\n        char c = board[i][j]; //storing char of board[i][j] to c to restore after backtracking\\n        p = p.children[c - \\'a\\'];//if the char is present in child i.e. not null then move root to char\\n        if (p.wrd != null) {   // check if word is found i.e. reached at end of the word \\n            res.add(p.wrd); //add it to list\\n            p.wrd = null;     // setting word as null to avoid reuse of word and to avoid adding again to list\\n        }\\n        board[i][j] = \\'#\\'; //change char to # to avoid revisiting\\n        dfs(board, i - 1, j ,p, res); //check in all directions\\n        dfs(board, i + 1, j, p, res);\\n        dfs(board, i, j - 1, p, res);\\n        dfs(board, i, j + 1, p, res); \\n        board[i][j] = c; //restoring char after backtracking from # to char\\n}\\n    private Trie buildTrie(String[] words){\\n        Trie root = new Trie();\\n        for(String word : words){\\n            Trie temp = root;\\n            for(char c : word.toCharArray()){\\n                if(temp.children[c-\\'a\\'] == null){//if char is not in the trie\\n                    temp.children[c-\\'a\\'] = new Trie();//create new node for that char\\n                }\\n                temp = temp.children[c-\\'a\\'];//move node to next char\\n            }\\n            temp.wrd = word;//update temp.wrd to current word that can be used later\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    Trie[] children = new Trie[26];\\n    String wrd; //instead of boolean isEnd as we need to return list<String> it should be a word\\n}\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        Trie root = buildTrie(words); //build trie of words and search in matrix\\n        for(int i = 0;i<board.length;i++){\\n            for(int j = 0;j<board[0].length;j++){\\n                dfs(board,i,j,root,res);\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(char[][] board, int i, int j, Trie p, List<String> res) {\\n        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j] == \\'#\\' || p.children[board[i][j] - \\'a\\'] == null)\\n            return; //if i or j is out of bound or if char(board[i][j]) is already visited(\\'#\\') or its child is null rerturn\\n        char c = board[i][j]; //storing char of board[i][j] to c to restore after backtracking\\n        p = p.children[c - \\'a\\'];//if the char is present in child i.e. not null then move root to char\\n        if (p.wrd != null) {   // check if word is found i.e. reached at end of the word \\n            res.add(p.wrd); //add it to list\\n            p.wrd = null;     // setting word as null to avoid reuse of word and to avoid adding again to list\\n        }\\n        board[i][j] = \\'#\\'; //change char to # to avoid revisiting\\n        dfs(board, i - 1, j ,p, res); //check in all directions\\n        dfs(board, i + 1, j, p, res);\\n        dfs(board, i, j - 1, p, res);\\n        dfs(board, i, j + 1, p, res); \\n        board[i][j] = c; //restoring char after backtracking from # to char\\n}\\n    private Trie buildTrie(String[] words){\\n        Trie root = new Trie();\\n        for(String word : words){\\n            Trie temp = root;\\n            for(char c : word.toCharArray()){\\n                if(temp.children[c-\\'a\\'] == null){//if char is not in the trie\\n                    temp.children[c-\\'a\\'] = new Trie();//create new node for that char\\n                }\\n                temp = temp.children[c-\\'a\\'];//move node to next char\\n            }\\n            temp.wrd = word;//update temp.wrd to current word that can be used later\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712977,
                "title": "rust-trie-dfs-solution",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    word: Option<String>,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie: Trie = Default::default();\\n        for word in words.iter() {\\n            let mut node = &mut trie;\\n            for c in word.as_bytes() {\\n                node =\\n                    node.children[(c - b\\'a\\') as usize].get_or_insert(Box::new(Default::default()));\\n            }\\n            node.word = Some(word.clone());\\n        }\\n        let mut answer: HashSet<String> = HashSet::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                let mut visited: Vec<Vec<bool>> = vec![vec![false; board[0].len()]; board.len()];\\n                Solution::dfs(&board, (i, j), &trie, &mut visited, &mut answer);\\n            }\\n        }\\n        answer.into_iter().collect()\\n    }\\n    fn dfs(\\n        board: &[Vec<char>],\\n        pos: (usize, usize),\\n        trie: &Trie,\\n        visited: &mut Vec<Vec<bool>>,\\n        answer: &mut HashSet<String>,\\n    ) {\\n        if visited[pos.0][pos.1] {\\n            return;\\n        }\\n        visited[pos.0][pos.1] = true;\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &trie.children[(c as u8 - b\\'a\\') as usize] {\\n            if let Some(word) = &node.word {\\n                answer.insert(word.clone());\\n            }\\n            if pos.0 > 0 {\\n                Solution::dfs(board, (pos.0 - 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 > 0 {\\n                Solution::dfs(board, (pos.0, pos.1 - 1), node.as_ref(), visited, answer);\\n            }\\n            if pos.0 < board.len() - 1 {\\n                Solution::dfs(board, (pos.0 + 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 < board[0].len() - 1 {\\n                Solution::dfs(board, (pos.0, pos.1 + 1), node.as_ref(), visited, answer);\\n            }\\n        }\\n        visited[pos.0][pos.1] = false;\\n    }\\n}\\n```\\n\\nUpdated:\\n\\n```rust\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    is_end: bool,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie = Trie::default();\\n        for word in &words {\\n            let mut node = &mut trie;\\n            for u in word.bytes() {\\n                node = node.children[(u - b\\'a\\') as usize].get_or_insert(Default::default());\\n            }\\n            node.is_end = true;\\n        }\\n        let mut board = board;\\n        let mut answer = Vec::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                Self::backtrack(\\n                    &mut board,\\n                    &mut trie,\\n                    (i, j),\\n                    &mut String::new(),\\n                    &mut answer,\\n                );\\n            }\\n        }\\n        answer\\n    }\\n    fn backtrack(\\n        board: &mut Vec<Vec<char>>,\\n        trie: &mut Trie,\\n        pos: (usize, usize),\\n        s: &mut String,\\n        answer: &mut Vec<String>,\\n    ) {\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &mut trie.children[(c as u8 - b\\'a\\') as usize] {\\n            s.push(c);\\n            if node.is_end {\\n                answer.push(s.clone());\\n                node.is_end = false;\\n            }\\n            board[pos.0][pos.1] = \\'*\\';\\n            for d in [0, 1, 0, !0, 0].windows(2) {\\n                let i = pos.0.wrapping_add(d[0]);\\n                let j = pos.1.wrapping_add(d[1]);\\n                if (0..board.len()).contains(&i)\\n                    && (0..board[0].len()).contains(&j)\\n                    && board[i][j] != \\'*\\'\\n                {\\n                    Self::backtrack(board, node, (i, j), s, answer);\\n                }\\n            }\\n            board[pos.0][pos.1] = c;\\n            s.pop();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    word: Option<String>,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie: Trie = Default::default();\\n        for word in words.iter() {\\n            let mut node = &mut trie;\\n            for c in word.as_bytes() {\\n                node =\\n                    node.children[(c - b\\'a\\') as usize].get_or_insert(Box::new(Default::default()));\\n            }\\n            node.word = Some(word.clone());\\n        }\\n        let mut answer: HashSet<String> = HashSet::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                let mut visited: Vec<Vec<bool>> = vec![vec![false; board[0].len()]; board.len()];\\n                Solution::dfs(&board, (i, j), &trie, &mut visited, &mut answer);\\n            }\\n        }\\n        answer.into_iter().collect()\\n    }\\n    fn dfs(\\n        board: &[Vec<char>],\\n        pos: (usize, usize),\\n        trie: &Trie,\\n        visited: &mut Vec<Vec<bool>>,\\n        answer: &mut HashSet<String>,\\n    ) {\\n        if visited[pos.0][pos.1] {\\n            return;\\n        }\\n        visited[pos.0][pos.1] = true;\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &trie.children[(c as u8 - b\\'a\\') as usize] {\\n            if let Some(word) = &node.word {\\n                answer.insert(word.clone());\\n            }\\n            if pos.0 > 0 {\\n                Solution::dfs(board, (pos.0 - 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 > 0 {\\n                Solution::dfs(board, (pos.0, pos.1 - 1), node.as_ref(), visited, answer);\\n            }\\n            if pos.0 < board.len() - 1 {\\n                Solution::dfs(board, (pos.0 + 1, pos.1), node.as_ref(), visited, answer);\\n            }\\n            if pos.1 < board[0].len() - 1 {\\n                Solution::dfs(board, (pos.0, pos.1 + 1), node.as_ref(), visited, answer);\\n            }\\n        }\\n        visited[pos.0][pos.1] = false;\\n    }\\n}\\n```\n```rust\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 26],\\n    is_end: bool,\\n}\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\\n        let mut trie = Trie::default();\\n        for word in &words {\\n            let mut node = &mut trie;\\n            for u in word.bytes() {\\n                node = node.children[(u - b\\'a\\') as usize].get_or_insert(Default::default());\\n            }\\n            node.is_end = true;\\n        }\\n        let mut board = board;\\n        let mut answer = Vec::new();\\n        for i in 0..board.len() {\\n            for j in 0..board[0].len() {\\n                Self::backtrack(\\n                    &mut board,\\n                    &mut trie,\\n                    (i, j),\\n                    &mut String::new(),\\n                    &mut answer,\\n                );\\n            }\\n        }\\n        answer\\n    }\\n    fn backtrack(\\n        board: &mut Vec<Vec<char>>,\\n        trie: &mut Trie,\\n        pos: (usize, usize),\\n        s: &mut String,\\n        answer: &mut Vec<String>,\\n    ) {\\n        let c = board[pos.0][pos.1];\\n        if let Some(node) = &mut trie.children[(c as u8 - b\\'a\\') as usize] {\\n            s.push(c);\\n            if node.is_end {\\n                answer.push(s.clone());\\n                node.is_end = false;\\n            }\\n            board[pos.0][pos.1] = \\'*\\';\\n            for d in [0, 1, 0, !0, 0].windows(2) {\\n                let i = pos.0.wrapping_add(d[0]);\\n                let j = pos.1.wrapping_add(d[1]);\\n                if (0..board.len()).contains(&i)\\n                    && (0..board[0].len()).contains(&j)\\n                    && board[i][j] != \\'*\\'\\n                {\\n                    Self::backtrack(board, node, (i, j), s, answer);\\n                }\\n            }\\n            board[pos.0][pos.1] = c;\\n            s.pop();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712826,
                "title": "my-accepted-java-solution-using-simple-recursion-no-trie-and-hashmap-required",
                "content": "```\\n public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        for(String word : words)\\n            if(exist(board,word))\\n                res.add(word);\\n        return res;\\n    }\\n    \\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int i =0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && existWord(board,word,i,j,1))\\n                    return true;\\n            }\\n        return false;\\n    }\\n    \\n    private boolean existWord(char[][] board, String word, int row, int col, int index){\\n        if(index == word.length())\\n            return true;\\n        board[row][col] = \\'.\\';\\n        if(row > 0 && board[row-1][col] == word.charAt(index) && existWord(board,word,row-1,col,index+1)){\\n            board[row][col] = word.charAt(index-1);\\n            return true;\\n        }\\n         if(row<board.length-1 && board[row+1][col] == word.charAt(index) && existWord(board,word,row+1,col,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n         if(col>0 && board[row][col-1] == word.charAt(index) && existWord(board,word,row,col-1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        if(col<board[0].length-1 && board[row][col+1] == word.charAt(index) && existWord(board,word,row,col+1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        board[row][col] = word.charAt(index-1);\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList();\\n        for(String word : words)\\n            if(exist(board,word))\\n                res.add(word);\\n        return res;\\n    }\\n    \\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int i =0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && existWord(board,word,i,j,1))\\n                    return true;\\n            }\\n        return false;\\n    }\\n    \\n    private boolean existWord(char[][] board, String word, int row, int col, int index){\\n        if(index == word.length())\\n            return true;\\n        board[row][col] = \\'.\\';\\n        if(row > 0 && board[row-1][col] == word.charAt(index) && existWord(board,word,row-1,col,index+1)){\\n            board[row][col] = word.charAt(index-1);\\n            return true;\\n        }\\n         if(row<board.length-1 && board[row+1][col] == word.charAt(index) && existWord(board,word,row+1,col,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n         if(col>0 && board[row][col-1] == word.charAt(index) && existWord(board,word,row,col-1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        if(col<board[0].length-1 && board[row][col+1] == word.charAt(index) && existWord(board,word,row,col+1,index+1)){\\n             board[row][col] = word.charAt(index-1);\\n            return true;\\n         }\\n        board[row][col] = word.charAt(index-1);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 693756,
                "title": "python-clean-trie-solution-with-dfs",
                "content": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : TRIE + DFS ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. build trie with all words list\\n\\t\\t#\\t2. start scanning matrix, move in all four directions and check if such combination exists in the trie\\n\\t\\t#\\t3. make sure you donot return when result is found ( case: words = [cat, cattle ] )\\n\\t\\t\\n        ## TIME COMPLEXICITY : O(M(4x3^(L-1))) ## (M is the number of cells in the board and L is the maximum length of words.)\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n\\t    \\n        def dfs(i, j, curr, currNode):\\n            ch = board[i][j]\\n            if( ch not in currNode.children or (i, j) in visited ):\\n                return\\n            if currNode.children[ch].endOfWord:\\n                res.add(curr)\\n                # return                            # edge case\\n            visited.add((i,j))\\n            for x,y in directions:\\n                if 0 <= i + x < m and 0 <= j + y < n:\\n                    dfs( i + x, j + y, curr + board[i + x][j + y], currNode.children[ch])\\n            visited.remove((i,j))   # edge case\\n        \\n        # buid trie data structure\\n        my_trie = Trie()\\n        [ my_trie.insert(word) for word in words ]\\n        rootNode = my_trie.get_rootNode()\\n        \\n        m, n = len(board), len(board[0])\\n        directions = [(0,1), (1,0), (0,-1), (-1,0)]\\n        res = set()                     \\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                visited = set()\\n                dfs(i, j, board[i][j], rootNode)\\n        return res\\n    \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.rootNode = TrieNode()\\n    \\n    def get_rootNode(self):\\n        return self.rootNode\\n    \\n    # Inserts a word into the trie.\\n    def insert(self, word: str) -> None:\\n        currNode = self.rootNode\\n        for idx, ch in enumerate(word):\\n            if( ch not in currNode.children ):\\n                currNode.children[ch] = TrieNode()\\n            currNode = currNode.children[ch]        \\n        currNode.endOfWord = True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : TRIE + DFS ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. build trie with all words list\\n\\t\\t#\\t2. start scanning matrix, move in all four directions and check if such combination exists in the trie\\n\\t\\t#\\t3. make sure you donot return when result is found ( case: words = [cat, cattle ] )\\n\\t\\t\\n        ## TIME COMPLEXICITY : O(M(4x3^(L-1))) ## (M is the number of cells in the board and L is the maximum length of words.)\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n\\t    \\n        def dfs(i, j, curr, currNode):\\n            ch = board[i][j]\\n            if( ch not in currNode.children or (i, j) in visited ):\\n                return\\n            if currNode.children[ch].endOfWord:\\n                res.add(curr)\\n                # return                            # edge case\\n            visited.add((i,j))\\n            for x,y in directions:\\n                if 0 <= i + x < m and 0 <= j + y < n:\\n                    dfs( i + x, j + y, curr + board[i + x][j + y], currNode.children[ch])\\n            visited.remove((i,j))   # edge case\\n        \\n        # buid trie data structure\\n        my_trie = Trie()\\n        [ my_trie.insert(word) for word in words ]\\n        rootNode = my_trie.get_rootNode()\\n        \\n        m, n = len(board), len(board[0])\\n        directions = [(0,1), (1,0), (0,-1), (-1,0)]\\n        res = set()                     \\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                visited = set()\\n                dfs(i, j, board[i][j], rootNode)\\n        return res\\n    \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.rootNode = TrieNode()\\n    \\n    def get_rootNode(self):\\n        return self.rootNode\\n    \\n    # Inserts a word into the trie.\\n    def insert(self, word: str) -> None:\\n        currNode = self.rootNode\\n        for idx, ch in enumerate(word):\\n            if( ch not in currNode.children ):\\n                currNode.children[ch] = TrieNode()\\n            currNode = currNode.children[ch]        \\n        currNode.endOfWord = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382930,
                "title": "easy-peasy-python-dfs-trie-solution-with-trie-implementation",
                "content": "\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children = [None]*26\\n\\t\\t\\tself.end = False\\n\\n\\tclass Trie:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = TrieNode()\\n\\n\\t\\tdef addWord(self, word):\\n\\t\\t\\troot = self.root\\n\\t\\t\\tfor ch in word:\\n\\t\\t\\t\\tidx = ord(ch) - 97\\n\\t\\t\\t\\tif root.children[idx] is None:\\n\\t\\t\\t\\t\\troot.children[idx] = TrieNode()\\n\\t\\t\\t\\troot = root.children[idx]\\n\\n\\t\\t\\troot.end = True\\n    \\n\\t\\tdef getRoot(self):\\n\\t\\t\\treturn self.root\\n\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\tself.rows = len(board)\\n\\t\\t\\tif self.rows == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tself.cols = len(board[0])\\n\\t\\t\\tself.board = board\\n\\n\\t\\t\\tself.res = set()\\n\\t\\t\\tself.resLen = len(words)\\n\\n\\t\\t\\tself.visited = [[False]*self.cols for _ in range(self.rows)]\\n\\n\\t\\t\\tobj = Trie()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tobj.addWord(word)\\n\\n\\t\\t\\troot = obj.getRoot()\\n\\n\\t\\t\\tfor i in range(self.rows):\\n\\t\\t\\t\\tfor j in range(self.cols):\\n\\t\\t\\t\\t\\tidx = ord(self.board[i][j]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(i, j, board[i][j], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = False\\n\\n\\t\\t\\treturn list(self.res)\\n\\n\\n\\t\\tdef dfs(self, i, j, ls, root):\\n\\t\\t\\tif len(self.res) == self.resLen:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif root.end:\\n\\t\\t\\t\\tself.res.add(ls)\\n\\n\\t\\t\\tfor (a, b) in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n\\t\\t\\t\\tif self.isValid(a, b):\\n\\t\\t\\t\\t\\tidx = ord(self.board[a][b]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(a, b, ls + self.board[a][b], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = False\\n\\n\\t\\tdef isValid(self, a, b):\\n\\t\\t\\treturn 0 <= a < self.rows and 0 <= b < self.cols and not self.visited[a][b]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children = [None]*26\\n\\t\\t\\tself.end = False\\n\\n\\tclass Trie:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = TrieNode()\\n\\n\\t\\tdef addWord(self, word):\\n\\t\\t\\troot = self.root\\n\\t\\t\\tfor ch in word:\\n\\t\\t\\t\\tidx = ord(ch) - 97\\n\\t\\t\\t\\tif root.children[idx] is None:\\n\\t\\t\\t\\t\\troot.children[idx] = TrieNode()\\n\\t\\t\\t\\troot = root.children[idx]\\n\\n\\t\\t\\troot.end = True\\n    \\n\\t\\tdef getRoot(self):\\n\\t\\t\\treturn self.root\\n\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\tself.rows = len(board)\\n\\t\\t\\tif self.rows == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tself.cols = len(board[0])\\n\\t\\t\\tself.board = board\\n\\n\\t\\t\\tself.res = set()\\n\\t\\t\\tself.resLen = len(words)\\n\\n\\t\\t\\tself.visited = [[False]*self.cols for _ in range(self.rows)]\\n\\n\\t\\t\\tobj = Trie()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tobj.addWord(word)\\n\\n\\t\\t\\troot = obj.getRoot()\\n\\n\\t\\t\\tfor i in range(self.rows):\\n\\t\\t\\t\\tfor j in range(self.cols):\\n\\t\\t\\t\\t\\tidx = ord(self.board[i][j]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(i, j, board[i][j], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[i][j] = False\\n\\n\\t\\t\\treturn list(self.res)\\n\\n\\n\\t\\tdef dfs(self, i, j, ls, root):\\n\\t\\t\\tif len(self.res) == self.resLen:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif root.end:\\n\\t\\t\\t\\tself.res.add(ls)\\n\\n\\t\\t\\tfor (a, b) in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n\\t\\t\\t\\tif self.isValid(a, b):\\n\\t\\t\\t\\t\\tidx = ord(self.board[a][b]) - 97\\n\\t\\t\\t\\t\\tif root.children[idx]:\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = True\\n\\t\\t\\t\\t\\t\\tself.dfs(a, b, ls + self.board[a][b], root.children[idx])\\n\\t\\t\\t\\t\\t\\tself.visited[a][b] = False\\n\\n\\t\\tdef isValid(self, a, b):\\n\\t\\t\\treturn 0 <= a < self.rows and 0 <= b < self.cols and not self.visited[a][b]",
                "codeTag": "Java"
            },
            {
                "id": 319071,
                "title": "standard-python-solution-with-trie-backtrack-340ms-beat-70-2",
                "content": "Please see and vote for my solutions\\n[79. Word Search](https://leetcode.com/problems/word-search/discuss/318208/Python-DFS-%2B-Backtrack-solution)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n\\n\\nPlease see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def backtrack(node, curr, i, j):\\n            for char in node.children:\\n                if board[i][j] != char:\\n                    continue\\n                curr += char\\n                visited.add((i, j))\\n                nxt = node.children[char]\\n                if nxt.isEnd:\\n                    res.add(curr)\\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    i1, j1 = i + di, j + dj\\n                    if 0 <= i1 < m and 0 <= j1 < n and (i1, j1) not in visited:\\n                        backtrack(nxt, curr, i1, j1)\\n                visited.remove((i, j))\\n                curr = curr[:-1]\\n                \\n        if not board or not board[0] or not words:\\n            return []  \\n        m, n = len(board), len(board[0])\\n        res = set()\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(trie.root, \\'\\', i, j)\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        def backtrack(node, curr, i, j):\\n            for char in node.children:\\n                if board[i][j] != char:\\n                    continue\\n                curr += char\\n                visited.add((i, j))\\n                nxt = node.children[char]\\n                if nxt.isEnd:\\n                    res.add(curr)\\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    i1, j1 = i + di, j + dj\\n                    if 0 <= i1 < m and 0 <= j1 < n and (i1, j1) not in visited:\\n                        backtrack(nxt, curr, i1, j1)\\n                visited.remove((i, j))\\n                curr = curr[:-1]\\n                \\n        if not board or not board[0] or not words:\\n            return []  \\n        m, n = len(board), len(board[0])\\n        res = set()\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(trie.root, \\'\\', i, j)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59850,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "AS I frist meet this question, I think we should grasp to implement Trie in 10 minutes. Then based the Trie,  we construct the Prefix Tree and traverse the board array and check whether the word exist in the dictionary.   \\n\\n\\n    const int MAX_CHARS=26;\\n    \\n    class TrieNode{\\n        public:\\n            TrieNode(string s) : isWord(false), word(s) {\\n                memset(children, 0, sizeof(children));\\n            }\\n        public:\\n            /*** store-the-root-cur-pos-word ***/\\n            string word;\\n            bool isWord;\\n            TrieNode* children[MAX_CHARS];\\n    };\\n    \\n    class TrieTree{\\n        public:\\n            TrieTree():root(new TrieNode(\"\")) {}\\n            ~TrieTree(){ freeTree(root); }\\n            TrieNode* getRoot(){\\n                return root;\\n            }\\n            \\n            void addWord(string& s){\\n                TrieNode* node=root;\\n                string t;\\n                for(int i=0; i<s.size(); i++){\\n                    t+=s[i];\\n                    if(node->children[s[i]-'a']==NULL){\\n                        node->children[s[i]-'a']=new TrieNode(t);\\n                    }\\n                    node=node->children[s[i]-'a'];\\n                }\\n                node->isWord=true;\\n            }\\n        private:\\n            void freeTree(TrieNode* node){\\n                for(int i=0; i<MAX_CHARS; i++){\\n                    if(node->children[i]!=NULL){\\n                        freeTree(node->children[i]);\\n                    }\\n                }\\n                delete node;\\n            }\\n            TrieNode* root;\\n    };\\n    \\n    class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            TrieTree t;\\n            for(int i=0; i<words.size(); i++)   t.addWord(words[i]);\\n            vector<string> result;\\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[i].size(); j++){\\n                    help(board, t.getRoot(), i, j, result);\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        void help(vector<vector<char>>& board, TrieNode* root, int row, int col, vector<string>& result){\\n            if(row<0 || col<0 || row>=board.size() || col>=board[0].size() || board[row][col]=='*')  return;\\n            char ch=board[row][col];\\n            root=root->children[ch-'a'];\\n            if(root==NULL)   return;\\n            if(root->isWord){\\n                result.push_back(root->word);\\n                root->isWord=false;\\n            }\\n            board[row][col]='*';\\n            help(board, root, row+1, col, result);\\n            help(board, root, row-1, col, result);\\n            help(board, root, row, col+1, result);\\n            help(board, root, row, col-1, result);\\n            board[row][col]=ch;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            TrieTree t;\\n            for(int i=0; i<words.size(); i++)   t.addWord(words[i]);\\n            vector<string> result;\\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[i].size(); j++){\\n                    help(board, t.getRoot(), i, j, result);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 59914,
                "title": "java-solution-with-trie-structure",
                "content": "Basically the solution will go in two steps:\\n\\n1. Build up the Trie structure for the dictionary;  \\n2. Search for words starting from each cell on the board, based on the Trie structure obtained above.\\n\\nFor step 1, you may refer to problem \"208 Implement Trie (Prefix Tree)\"(Here we only need the \"insert\" method). \\n\\nFor step 2, we can use a standard backtracing function. Two key points for designing your backtracing function are \"where to start\" and \"when to stop\". For this problem, a straightforward starting point would be   for each cell on the board, try to match the letter at current cell to the first level of the Trie structure (root is defined as the zeroth level). If there is a match, then continue to match the letter at one of its four neighbors to the next level of the Trie and so on. The termination condition is either there is no match in the Trie for the letter at current cell or there are no more available cells out of its four neighbors(all visited). So your Trie structure should provide a quick way to check whether there is a match for current letter. You also need to mark current cell if it has been visited. One more point is when to record the searching result. After each successful match of letter at current cell, your Trie structure should be able to tell whether this letter in the Trie is an end of a word. If so, record the word and remove it from the Trie structure to avoid repetition.\\n\\nThis is the function I used:\\n```\\nvoid findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res);\\n```\\nHere board is the given char board; i and j are the row and column indices of current cell;\\ntrieNode is the matching TrieNode of the letter at current cell in the Trie structure(It is null if there is no such matching); sb will hold a character sequence from root to current level(exclusive) in the Trie structure (depending on your design of Trie structure, you may or may not need this variable); res will hold the searching results.\\n\\nWhen entering the backtracing function,  first check if trieNode is null or not. If it's null, then there is no matching for the letter at current cell in the Trie structure so no further search is needed. Else, we append current letter to sb and check if we have obtained a complete word in the dictionary(record the word and remove it from the Trie if so). After we are done with current character, we modified it to '{' to indicate that current cell has been visited. Here character '{' is chosen for the following reason: In the TrieNode definition, I used an array of length 27 instead of 26. For words containing only lowercase letters, the last element of this array will always be null. For an visited cell on the board, if we set the character at that cell to be '{'  (in terms of ASCII, '{' = 'a' + 26), then whenever it's visited again, the corresponding trieNode will be null and the search will terminate. With current cell marked as visited, we do need further search if any of its four neighbors is available on the board. At last, when we are done with all the neighbors, we restore the letter at current cell and also StringBuilder sb so the backtracing can continue. Here is the complete program:\\n```\\n    // TrieNode for the Trie structure\\n    class TrieNode {\\n        TrieNode[] next;   // next level TrieNodes\\n        boolean isWordEnd; // true if this is the end of a word\\n        \\n        public TrieNode() {\\n            next = new TrieNode[27]; // Here I use an array of length 27 instead of 26 for later use\\n            isWordEnd = false;\\n        }\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {   \\t\\n        int m = board.length;\\n        int n = (m == 0 ? 0 : board[0].length);\\n    \\t\\n    \\tList<String> res = new ArrayList<>();        // holding results\\n        StringBuilder sb = new StringBuilder(m * n); // holding the character sequence from root to current level(exclusive) in the Trie structure(initial capacity equal to the dimension of the board)\\n        TrieNode root = new TrieNode();              // root node for the Trie structure\\n        \\n        // Step 1: build up the Trie structure\\n        for (String word : words) {\\n            TrieNode trieNode = root;\\n        \\t\\n            for (int i = 0; i < word.length(); i++) {\\n        \\tif (trieNode.next[word.charAt(i) - 'a'] == null) {\\n        \\t    trieNode.next[word.charAt(i) - 'a'] = new TrieNode();\\n        \\t}\\n\\n        \\ttrieNode = trieNode.next[word.charAt(i) - 'a'];\\n            }\\n        \\t\\n            trieNode.isWordEnd = true;\\n        }             \\n        \\n        // Step 2: search for words starting from each cell on the board and record the results\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n        \\tfindWordsSub(board, i, j, root.next[board[i][j] - 'a'], sb, res);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // helper function for backtracing searching. \\n    private void findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res) {\\n    \\t// only proceed if there is a match for the letter at current cell\\n    \\tif (trieNode != null) {\\n    \\t    char ch = board[i][j];           // save current letter\\n    \\t    sb.append(ch);                   // append the letter to sb\\n    \\t    if (trieNode.isWordEnd) {        // check if current letter is the end of a word\\n    \\t\\tres.add(sb.toString());      // if so, record the word\\n                trieNode.isWordEnd = false;  // remove this word from the Trie structure to avoid repetition\\n    \\t    }\\n    \\t\\t\\n    \\t    board[i][j] = '{';  // modify current letter to indicate that it's visited. Here '{' = 'a' + 26 (in terms of ASCII).\\n    \\t\\t\\n    \\t    // do further search if there are more cells available out of the four neighbors\\n    \\t    if (i + 1 < board.length) {\\n    \\t\\tfindWordsSub(board, i + 1, j, trieNode.next[board[i + 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (i - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i - 1, j, trieNode.next[board[i - 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j + 1 < board[0].length ) {\\n    \\t\\tfindWordsSub(board, i, j + 1, trieNode.next[board[i][j + 1] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i, j - 1, trieNode.next[board[i][j - 1] - 'a'], sb, res);\\n    \\t    }  \\t\\t\\n    \\t\\t\\n            // restore the letter at current cell and sb for backtracing\\n    \\t    board[i][j] = ch;\\n            sb.deleteCharAt(sb.length() - 1);\\n    \\t}\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res);\\n```\n```\\n    // TrieNode for the Trie structure\\n    class TrieNode {\\n        TrieNode[] next;   // next level TrieNodes\\n        boolean isWordEnd; // true if this is the end of a word\\n        \\n        public TrieNode() {\\n            next = new TrieNode[27]; // Here I use an array of length 27 instead of 26 for later use\\n            isWordEnd = false;\\n        }\\n    }\\n    \\n    public List<String> findWords(char[][] board, String[] words) {   \\t\\n        int m = board.length;\\n        int n = (m == 0 ? 0 : board[0].length);\\n    \\t\\n    \\tList<String> res = new ArrayList<>();        // holding results\\n        StringBuilder sb = new StringBuilder(m * n); // holding the character sequence from root to current level(exclusive) in the Trie structure(initial capacity equal to the dimension of the board)\\n        TrieNode root = new TrieNode();              // root node for the Trie structure\\n        \\n        // Step 1: build up the Trie structure\\n        for (String word : words) {\\n            TrieNode trieNode = root;\\n        \\t\\n            for (int i = 0; i < word.length(); i++) {\\n        \\tif (trieNode.next[word.charAt(i) - 'a'] == null) {\\n        \\t    trieNode.next[word.charAt(i) - 'a'] = new TrieNode();\\n        \\t}\\n\\n        \\ttrieNode = trieNode.next[word.charAt(i) - 'a'];\\n            }\\n        \\t\\n            trieNode.isWordEnd = true;\\n        }             \\n        \\n        // Step 2: search for words starting from each cell on the board and record the results\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n        \\tfindWordsSub(board, i, j, root.next[board[i][j] - 'a'], sb, res);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // helper function for backtracing searching. \\n    private void findWordsSub(char[][] board, int i, int j, TrieNode trieNode, StringBuilder sb, List<String> res) {\\n    \\t// only proceed if there is a match for the letter at current cell\\n    \\tif (trieNode != null) {\\n    \\t    char ch = board[i][j];           // save current letter\\n    \\t    sb.append(ch);                   // append the letter to sb\\n    \\t    if (trieNode.isWordEnd) {        // check if current letter is the end of a word\\n    \\t\\tres.add(sb.toString());      // if so, record the word\\n                trieNode.isWordEnd = false;  // remove this word from the Trie structure to avoid repetition\\n    \\t    }\\n    \\t\\t\\n    \\t    board[i][j] = '{';  // modify current letter to indicate that it's visited. Here '{' = 'a' + 26 (in terms of ASCII).\\n    \\t\\t\\n    \\t    // do further search if there are more cells available out of the four neighbors\\n    \\t    if (i + 1 < board.length) {\\n    \\t\\tfindWordsSub(board, i + 1, j, trieNode.next[board[i + 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (i - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i - 1, j, trieNode.next[board[i - 1][j] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j + 1 < board[0].length ) {\\n    \\t\\tfindWordsSub(board, i, j + 1, trieNode.next[board[i][j + 1] - 'a'], sb, res);\\n    \\t    }\\n    \\t\\t\\n    \\t    if (j - 1 >= 0) {\\n    \\t\\tfindWordsSub(board, i, j - 1, trieNode.next[board[i][j - 1] - 'a'], sb, res);\\n    \\t    }  \\t\\t\\n    \\t\\t\\n            // restore the letter at current cell and sb for backtracing\\n    \\t    board[i][j] = ch;\\n            sb.deleteCharAt(sb.length() - 1);\\n    \\t}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900776,
                "title": "only-backtracking-no-tle-no-trie-used-c-java",
                "content": "# Intuition \\n**``` Find out all possible strings of size less than or equal to 10 and if it is in the words array then adding it ans```**\\n# Approach\\n**```To find all the possible strings we can use basic backtracking approach as shown in the below code```**\\n\\n** Start from every index of the matrix and make words of length less than equal to 10**\\n\\n# Complexity\\n**- Time complexity:**\\n**```The overall time complexity of the code is O(N * M * 4^10)```**\\n\\n**- Space complexity:**\\n**```Since we are using the dp table space complexity goes up to O(N * 2) => O(N) ```**\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool isSafe(int x, int y, vector<vector<char>> &board)\\n    {\\n        int n = board.size(), m = board[0].size();\\n        return (x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\');\\n    }\\n    vector<pair<int, int>> movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    void func(int x, int y, string &curr, vector<vector<char>> &board, unordered_set<string> &st)\\n    {\\n        if (curr.size() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr += board[x][y];\\n        if (st.find(curr) != st.end())\\n        {\\n            st.erase(curr);\\n            ans.push_back(curr);\\n        }\\n        curr.pop_back();\\n        char ch = board[x][y];\\n        for (auto it : movements)\\n        {\\n            int nx = x + it.first;\\n            int ny = y + it.second;\\n            curr += board[x][y];\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.pop_back();\\n            board[x][y] = ch;\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto it : words)\\n            st.insert(it);\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                string curr = \"\";\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code (Java)\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    int[][] movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    boolean isSafe(int x, int y, char[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        return x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\';\\n    }\\n\\n    void func(int x, int y, StringBuilder curr, char[][] board, HashSet<String> st) {\\n        if (curr.length() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr.append(board[x][y]);\\n        if (st.contains(curr.toString())) {\\n            st.remove(curr.toString());\\n            ans.add(curr.toString());\\n        }\\n        curr.deleteCharAt(curr.length() - 1);\\n        char ch = board[x][y];\\n        for (int[] it : movements) {\\n            int nx = x + it[0];\\n            int ny = y + it[1];\\n            curr.append(board[x][y]);\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.deleteCharAt(curr.length() - 1);\\n            board[x][y] = ch;\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> st = new HashSet<>();\\n        for (String it : words)\\n            st.add(it);\\n        int n = board.length, m = board[0].length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                StringBuilder curr = new StringBuilder();\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n``` Please Upvote if it was helpful ```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` Find out all possible strings of size less than or equal to 10 and if it is in the words array then adding it ans```\n```To find all the possible strings we can use basic backtracking approach as shown in the below code```\n```The overall time complexity of the code is O(N * M * 4^10)```\n```Since we are using the dp table space complexity goes up to O(N * 2) => O(N) ```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    bool isSafe(int x, int y, vector<vector<char>> &board)\\n    {\\n        int n = board.size(), m = board[0].size();\\n        return (x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\');\\n    }\\n    vector<pair<int, int>> movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    void func(int x, int y, string &curr, vector<vector<char>> &board, unordered_set<string> &st)\\n    {\\n        if (curr.size() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr += board[x][y];\\n        if (st.find(curr) != st.end())\\n        {\\n            st.erase(curr);\\n            ans.push_back(curr);\\n        }\\n        curr.pop_back();\\n        char ch = board[x][y];\\n        for (auto it : movements)\\n        {\\n            int nx = x + it.first;\\n            int ny = y + it.second;\\n            curr += board[x][y];\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.pop_back();\\n            board[x][y] = ch;\\n        }\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto it : words)\\n            st.insert(it);\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                string curr = \"\";\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    int[][] movements = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    boolean isSafe(int x, int y, char[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        return x >= 0 && y >= 0 && x < n && y < m && board[x][y] != \\'#\\';\\n    }\\n\\n    void func(int x, int y, StringBuilder curr, char[][] board, HashSet<String> st) {\\n        if (curr.length() >= 10)\\n            return;\\n        if (!isSafe(x, y, board))\\n            return;\\n        curr.append(board[x][y]);\\n        if (st.contains(curr.toString())) {\\n            st.remove(curr.toString());\\n            ans.add(curr.toString());\\n        }\\n        curr.deleteCharAt(curr.length() - 1);\\n        char ch = board[x][y];\\n        for (int[] it : movements) {\\n            int nx = x + it[0];\\n            int ny = y + it[1];\\n            curr.append(board[x][y]);\\n            board[x][y] = \\'#\\';\\n            func(nx, ny, curr, board, st);\\n            curr.deleteCharAt(curr.length() - 1);\\n            board[x][y] = ch;\\n        }\\n    }\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        HashSet<String> st = new HashSet<>();\\n        for (String it : words)\\n            st.add(it);\\n        int n = board.length, m = board[0].length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                StringBuilder curr = new StringBuilder();\\n                func(i, j, curr, board, st);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n``` Please Upvote if it was helpful ```",
                "codeTag": "Java"
            },
            {
                "id": 3781916,
                "title": "simple-c-map-solution-without-trie",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nunordered_map<string,int> m;\\n\\nvoid solve(int i,int j,string s,vector<vector<char>>& board,\\nvector<string> &ans,unordered_map<string,int> &mp){\\n     if(mp.find(s)==mp.end()) return; \\n    if(i<0 || j<0 || j>=board[0].size() || i>=board.size()) return;\\n\\n    char old=board[i][j];\\n    board[i][j]=\\'*\\';\\n   \\n    if(m.find(s)!=m.end()){ ans.push_back(s);\\n    m.erase(s);}\\n    if(i-1>=0 && board[i-1][j]!=\\'*\\'){\\n        solve(i-1,j,s+board[i-1][j],board,ans,mp);\\n    }\\n    if(i+1<board.size() && board[i+1][j]!=\\'*\\'){\\n        solve(i+1,j,s+board[i+1][j],board,ans,mp);\\n    }\\n    if(j-1>=0 && board[i][j-1]!=\\'*\\'){\\n        solve(i,j-1,s+board[i][j-1],board,ans,mp);\\n    }\\n    if(j+1<board[0].size() && board[i][j+1]!=\\'*\\'){\\n        solve(i,j+1,s+board[i][j+1],board,ans,mp);\\n    }\\n    board[i][j]=old;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            m[words[i]]++;\\n        }\\n       \\n        vector<string> ans;\\n        unordered_map<string,int> mp; //for storing prefixes of words \\n        for(auto i:words)\\n        {\\n            string t=\"\";\\n            for(int j=0;j<i.size();j++)\\n            {\\n                t+=i[j];\\n                mp[t]=1;\\n            }\\n        }\\n     \\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(m.size()==0) return ans;\\n                    string temp=\"\";\\n\\n                    temp+=board[i][j];\\n                    solve(i,j,temp,board,ans,mp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_map<string,int> m;\\n\\nvoid solve(int i,int j,string s,vector<vector<char>>& board,\\nvector<string> &ans,unordered_map<string,int> &mp){\\n     if(mp.find(s)==mp.end()) return; \\n    if(i<0 || j<0 || j>=board[0].size() || i>=board.size()) return;\\n\\n    char old=board[i][j];\\n    board[i][j]=\\'*\\';\\n   \\n    if(m.find(s)!=m.end()){ ans.push_back(s);\\n    m.erase(s);}\\n    if(i-1>=0 && board[i-1][j]!=\\'*\\'){\\n        solve(i-1,j,s+board[i-1][j],board,ans,mp);\\n    }\\n    if(i+1<board.size() && board[i+1][j]!=\\'*\\'){\\n        solve(i+1,j,s+board[i+1][j],board,ans,mp);\\n    }\\n    if(j-1>=0 && board[i][j-1]!=\\'*\\'){\\n        solve(i,j-1,s+board[i][j-1],board,ans,mp);\\n    }\\n    if(j+1<board[0].size() && board[i][j+1]!=\\'*\\'){\\n        solve(i,j+1,s+board[i][j+1],board,ans,mp);\\n    }\\n    board[i][j]=old;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            m[words[i]]++;\\n        }\\n       \\n        vector<string> ans;\\n        unordered_map<string,int> mp; //for storing prefixes of words \\n        for(auto i:words)\\n        {\\n            string t=\"\";\\n            for(int j=0;j<i.size();j++)\\n            {\\n                t+=i[j];\\n                mp[t]=1;\\n            }\\n        }\\n     \\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(m.size()==0) return ans;\\n                    string temp=\"\";\\n\\n                    temp+=board[i][j];\\n                    solve(i,j,temp,board,ans,mp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711288,
                "title": "w-explanation-c-backtracking-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a Trie data structure to efficiently find words in a given board. It performs a depth-first search on the board, tracking visited cells and matching word paths in the Trie. The found words are stored and returned as the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe depth-first search (DFS) function explores the board starting from a specific cell. It checks for boundary conditions and visited cells. If the current cell\\'s character matches a link in the Trie, it continues the search in that direction. If a word is found, it is added to the result. The function backtracks by undoing cell modifications to explore other paths.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N * 4^m)$ where N is the number of cells in the board and m is the maximum length of the words. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(total word length + N)\\n# Code\\n```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {};\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\';\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie();\\n            }\\n            node = node->links[i];\\n        }\\n        node->isEnd = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\';// Mark as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c;//Backtracking\\n        word.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# code for class Trie with Explanation in comments\\n```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {}; // Array of Trie pointers to child nodes\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\'; // Calculate the index for the character\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie(); // Create a new Trie node if the link is empty\\n            }\\n            node = node->links[i]; // Move to the next Trie node\\n        }\\n        node->isEnd = 1; // Mark the last Trie node as the end of a word\\n    }\\n};\\n\\n```\\n# Solution part with comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\'; // Mark the cell as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c; // Backtrack by restoring the cell value\\n        word.pop_back(); // Remove the last character from the word\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {};\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\';\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie();\\n            }\\n            node = node->links[i];\\n        }\\n        node->isEnd = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\';// Mark as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c;//Backtracking\\n        word.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Trie {\\npublic:\\n    bool isEnd = 0;\\n    array<Trie*, 26> links = {}; // Array of Trie pointers to child nodes\\n\\n    Trie() {}\\n\\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            int i = c - \\'a\\'; // Calculate the index for the character\\n            if (node->links[i] == NULL) {\\n                node->links[i] = new Trie(); // Create a new Trie node if the link is empty\\n            }\\n            node = node->links[i]; // Move to the next Trie node\\n        }\\n        node->isEnd = 1; // Mark the last Trie node as the end of a word\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<char>> board;\\n    vector<string> ans;\\n    int n, m;\\n\\n    void dfs(int i, int j, Trie* cur, string& word) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || board[i][j] == \\'@\\')\\n            return;\\n\\n        char c = board[i][j];\\n\\n        if (cur->links[c - \\'a\\'] == NULL)\\n            return;\\n\\n        word.push_back(c);\\n        cur = cur->links[c - \\'a\\'];\\n        if (cur->isEnd) {\\n            ans.push_back(word);\\n            cur->isEnd = 0;\\n        }\\n       \\n        board[i][j] = \\'@\\'; // Mark the cell as visited\\n        \\n        dfs(i + 1, j, cur, word);\\n        dfs(i, j + 1, cur, word);\\n        dfs(i - 1, j, cur, word);\\n        dfs(i, j - 1, cur, word);\\n\\n        board[i][j] = c; // Backtrack by restoring the cell value\\n        word.pop_back(); // Remove the last character from the word\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& _board, vector<string>& _words) {\\n        board = _board;\\n        n = board.size();\\n        m = board[0].size();\\n        Trie* root = new Trie();\\n\\n        for (auto& w : _words)\\n            root->insert(w);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                string word;\\n                dfs(i, j, root, word);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156803,
                "title": "highly-commented-solution-using-trie",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    4 parts\\n    TrieNode definition and declaration of root\\n    dfs traversal logic\\n    insert word logic\\n    main function\\n    */\\n    //new trienode() ka syntax matlab?\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];//node pointing to other 26 possible nodes...if they dont exist then null\\n        bool flag=false;//for knowing if the node is the end of a possible word or not\\n        bool Inserted=false;//to avoid duplicates in ans...if the word already inserted\\n        string str;//keeping record of string that has made its way to here\\n        bool containChar(char character)\\n        {\\n            return (child[character-\\'a\\']!=NULL);//to see if the node contains the character as next node\\n        }\\n        void putNode(char nxtchar,TrieNode* node)\\n        {\\n            child[nxtchar-\\'a\\']=node;//if next character doesnt exist in trie the to insert\\n        }\\n        TrieNode* getNode(char character)\\n        {\\n            return child[character-\\'a\\'];//maybe traverse the trie further if we get our way in dfs\\n        }\\n        void setEnd()\\n        {\\n            flag=true;//sets end tag to node denoting it being end of one word\\n        }\\n        bool isEnd()\\n        {\\n            return flag;//to know if its the end or not\\n        }\\n        bool didInsert()\\n        {\\n            return Inserted;//self explanatory\\n        }\\n        void setdidInsert()\\n        {\\n            Inserted=true;//      \"\\n        }\\n    };\\n    TrieNode* root=new TrieNode();//publicly define root of our Trie\\n    void insertWord(string word)//insert words from vector given into our Trie\\n    {\\n        TrieNode* node=root;\\n        int i;\\n        for(i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i]) ==false)\\n            {\\n                node->putNode(word[i],new TrieNode());//if not present then insert\\n            }\\n            node=node->getNode(word[i]);//traverse further in trie (now that the character is inserted if it didnt exist before)\\n        }\\n        node->setEnd();//set end to final node after traversal of word\\n        node->str=word;//assign str\\n    }\\n    void dfs(vector<vector<char>>&board,int i,int j,TrieNode* node,vector<string>&ans,vector<vector<bool>>&visited)\\n    {\\n        if((i<0)||(j<0)||(i>board.size()-1)||(j>board[0].size()-1))\\n        {\\n            return;//since while doing dfs we call in all four directions\\n            //like this we dont have to take caution while calling dfs in which directions\\n        }\\n        if(visited[i][j])\\n        {\\n            return;//if already visited then return\\n        }\\n        node=node->getNode(board[i][j]);\\n        if(node==NULL)\\n        {\\n            return;//if the node for that further character doesnt exist\\n        }\\n        if(node->isEnd() && !(node->Inserted))\\n        {\\n            ans.push_back(node->str);//if is end and not inserted before\\n            node->Inserted=true;//so no re pushing of same word back possibly\\n        }\\n        visited[i][j]=true;\\n        dfs(board,i+1,j,node,ans,visited);\\n        dfs(board,i,j+1,node,ans,visited);\\n        dfs(board,i-1,j,node,ans,visited);\\n        dfs(board,i,j-1,node,ans,visited);//calling in all 4 directions\\n        visited[i][j]=false;//while backtracking in dfs...it re assigns the previous value of false to assigned ones\\n    }\\n    vector<string> findWords(vector<vector<char>>& board,vector<string>& words) \\n    {\\n        vector<string>ans;\\n        for(string word:words)\\n        {\\n            insertWord(word);//makes our Trie/Inserting words one by one\\n        }\\n        vector<vector<bool>>visited(board.size(),vector<bool>(board[0].size(),false));//to avoid infinite looping in dfs and keep record of visited ones\\n        // size, value(size,value)\\n        int i,j;\\n        for(i=0;i<board.size();i++)\\n        {\\n            for(j=0;j<board[0].size();j++)//traverse matrix and check for all words but efficiently bcoz of trie\\n            {\\n                dfs(board,i,j,root,ans,visited);\\n                // board to traverse,i and j to know current position, root to check in trie,push word if found,visited to keep record\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    4 parts\\n    TrieNode definition and declaration of root\\n    dfs traversal logic\\n    insert word logic\\n    main function\\n    */\\n    //new trienode() ka syntax matlab?\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];//node pointing to other 26 possible nodes...if they dont exist then null\\n        bool flag=false;//for knowing if the node is the end of a possible word or not\\n        bool Inserted=false;//to avoid duplicates in ans...if the word already inserted\\n        string str;//keeping record of string that has made its way to here\\n        bool containChar(char character)\\n        {\\n            return (child[character-\\'a\\']!=NULL);//to see if the node contains the character as next node\\n        }\\n        void putNode(char nxtchar,TrieNode* node)\\n        {\\n            child[nxtchar-\\'a\\']=node;//if next character doesnt exist in trie the to insert\\n        }\\n        TrieNode* getNode(char character)\\n        {\\n            return child[character-\\'a\\'];//maybe traverse the trie further if we get our way in dfs\\n        }\\n        void setEnd()\\n        {\\n            flag=true;//sets end tag to node denoting it being end of one word\\n        }\\n        bool isEnd()\\n        {\\n            return flag;//to know if its the end or not\\n        }\\n        bool didInsert()\\n        {\\n            return Inserted;//self explanatory\\n        }\\n        void setdidInsert()\\n        {\\n            Inserted=true;//      \"\\n        }\\n    };\\n    TrieNode* root=new TrieNode();//publicly define root of our Trie\\n    void insertWord(string word)//insert words from vector given into our Trie\\n    {\\n        TrieNode* node=root;\\n        int i;\\n        for(i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i]) ==false)\\n            {\\n                node->putNode(word[i],new TrieNode());//if not present then insert\\n            }\\n            node=node->getNode(word[i]);//traverse further in trie (now that the character is inserted if it didnt exist before)\\n        }\\n        node->setEnd();//set end to final node after traversal of word\\n        node->str=word;//assign str\\n    }\\n    void dfs(vector<vector<char>>&board,int i,int j,TrieNode* node,vector<string>&ans,vector<vector<bool>>&visited)\\n    {\\n        if((i<0)||(j<0)||(i>board.size()-1)||(j>board[0].size()-1))\\n        {\\n            return;//since while doing dfs we call in all four directions\\n            //like this we dont have to take caution while calling dfs in which directions\\n        }\\n        if(visited[i][j])\\n        {\\n            return;//if already visited then return\\n        }\\n        node=node->getNode(board[i][j]);\\n        if(node==NULL)\\n        {\\n            return;//if the node for that further character doesnt exist\\n        }\\n        if(node->isEnd() && !(node->Inserted))\\n        {\\n            ans.push_back(node->str);//if is end and not inserted before\\n            node->Inserted=true;//so no re pushing of same word back possibly\\n        }\\n        visited[i][j]=true;\\n        dfs(board,i+1,j,node,ans,visited);\\n        dfs(board,i,j+1,node,ans,visited);\\n        dfs(board,i-1,j,node,ans,visited);\\n        dfs(board,i,j-1,node,ans,visited);//calling in all 4 directions\\n        visited[i][j]=false;//while backtracking in dfs...it re assigns the previous value of false to assigned ones\\n    }\\n    vector<string> findWords(vector<vector<char>>& board,vector<string>& words) \\n    {\\n        vector<string>ans;\\n        for(string word:words)\\n        {\\n            insertWord(word);//makes our Trie/Inserting words one by one\\n        }\\n        vector<vector<bool>>visited(board.size(),vector<bool>(board[0].size(),false));//to avoid infinite looping in dfs and keep record of visited ones\\n        // size, value(size,value)\\n        int i,j;\\n        for(i=0;i<board.size();i++)\\n        {\\n            for(j=0;j<board[0].size();j++)//traverse matrix and check for all words but efficiently bcoz of trie\\n            {\\n                dfs(board,i,j,root,ans,visited);\\n                // board to traverse,i and j to know current position, root to check in trie,push word if found,visited to keep record\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780345,
                "title": "c-2-approaches-dfs-trie-map",
                "content": "**Approach 1: (DFS + Map) TLE**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    void search(int i, int j, int ind, vector<vector<char>>& board, string &word, bool &found)\\n    {\\n        if(board[i][j]==\\'1\\' || found)     return;\\n        if(ind == word.size())\\n        { \\n            found = true;\\n            return;\\n        }\\n        char temp = board[i][j];\\n        board[i][j] = \\'1\\';\\n        if(i-1>=0 && board[i-1][j]==word[ind]) search(i-1,j,ind+1,board,word,found);\\n        if(i+1<n && board[i+1][j]==word[ind]) search(i+1,j,ind+1,board,word,found);\\n        if(j+1<m && board[i][j+1]==word[ind]) search(i,j+1,ind+1,board,word,found);\\n        if(j-1>=0 && board[i][j-1]==word[ind]) search(i,j-1,ind+1,board,word,found);\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<string>>mp;\\n        vector<string> ans;\\n        n = board.size();\\n        m = board[0].size();\\n        for(int i=0;i<words.size();i++)     mp[words[i][0]].push_back(words[i]);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mp[board[i][j]].size() > 0)\\n                {\\n                    for(auto m:mp[board[i][j]])\\n                    {\\n                        bool found = false;\\n                        search(i,j,1,board,m,found);\\n                        if(found && find(ans.begin(), ans.end(), m)==ans.end()) \\n                            ans.push_back(m);\\n\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2: (DFS + Trie) \\u2705**\\n```\\nclass Solution {\\n    struct node{\\n        char c;\\n        int ends;\\n        string word;\\n        node *child[26];\\n    };\\n    struct node *getNode(char c)\\n    {\\n        node *newnode = new node;\\n        newnode->c = c;\\n        newnode->ends = 0;\\n         newnode->word = \"\";\\n        for(int i=0;i<26;++i)\\n            newnode->child[i] = NULL;\\n        return newnode;\\n    }\\n    node *root = getNode(\\'/\\');  //root\\n    \\n    //Trie INSERT\\n    void insert(string s)\\n    {\\n        node *curr=root;\\n        int index,i=0;\\n        while(s[i])\\n        {\\n            index = s[i]-\\'a\\';\\n            if(curr->child[index]==NULL)\\n                curr->child[index] = getNode(s[i]);\\n            \\n            curr=curr->child[index];\\n            i+=1;\\n        }\\n        curr->ends += 1;\\n        curr->word = s;\\n    }\\n    \\n    void solve(vector<vector<char>>& board,int i,int j,int r,int c,vector<string>& ans,node *curr)\\n    {\\n        //Base case\\n        //If the trie doesn\\'t have the current char OR cell is Visited\\n        int index = board[i][j]-\\'a\\';\\n        if(board[i][j]==\\'$\\' || curr->child[index]==NULL)  \\n            return;\\n        \\n        curr = curr->child[index];\\n        if(curr->ends > 0)\\n        {\\n            ans.push_back(curr->word);\\n            curr->ends -=1;\\n        }\\n        \\n        //Body\\n        char ch = board[i][j];   //Store current char\\n        board[i][j] = \\'$\\';  //Mark current node visited\\n        \\n        if(i>0)     //TOP\\n            solve(board,i-1,j,r,c,ans,curr);\\n        if(i<r-1)   //DOWN\\n            solve(board,i+1,j,r,c,ans,curr);\\n        if(j>0)     //LEFT\\n            solve(board,i,j-1,r,c,ans,curr);\\n        if(j<c-1)   //RIGHT\\n            solve(board,i,j+1,r,c,ans,curr);\\n        \\n        board[i][j] = ch;    //Mark current node as Unvisited by restoring the value\\n    }\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {        \\n        int r=board.size();\\n        int c=board[0].size();\\n        \\n        //Insert all words in TRIE\\n        for(int i=0;i<words.size();++i)\\n            insert(words[i]);\\n        \\n        //Now search words\\n        vector<string> ans;\\n        for(int i=0;i<r;++i)\\n        {\\n            for(int j=0;j<c;++j)\\n                solve(board,i,j,r,c,ans,root);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    void search(int i, int j, int ind, vector<vector<char>>& board, string &word, bool &found)\\n    {\\n        if(board[i][j]==\\'1\\' || found)     return;\\n        if(ind == word.size())\\n        { \\n            found = true;\\n            return;\\n        }\\n        char temp = board[i][j];\\n        board[i][j] = \\'1\\';\\n        if(i-1>=0 && board[i-1][j]==word[ind]) search(i-1,j,ind+1,board,word,found);\\n        if(i+1<n && board[i+1][j]==word[ind]) search(i+1,j,ind+1,board,word,found);\\n        if(j+1<m && board[i][j+1]==word[ind]) search(i,j+1,ind+1,board,word,found);\\n        if(j-1>=0 && board[i][j-1]==word[ind]) search(i,j-1,ind+1,board,word,found);\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        unordered_map<char,vector<string>>mp;\\n        vector<string> ans;\\n        n = board.size();\\n        m = board[0].size();\\n        for(int i=0;i<words.size();i++)     mp[words[i][0]].push_back(words[i]);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mp[board[i][j]].size() > 0)\\n                {\\n                    for(auto m:mp[board[i][j]])\\n                    {\\n                        bool found = false;\\n                        search(i,j,1,board,m,found);\\n                        if(found && find(ans.begin(), ans.end(), m)==ans.end()) \\n                            ans.push_back(m);\\n\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    struct node{\\n        char c;\\n        int ends;\\n        string word;\\n        node *child[26];\\n    };\\n    struct node *getNode(char c)\\n    {\\n        node *newnode = new node;\\n        newnode->c = c;\\n        newnode->ends = 0;\\n         newnode->word = \"\";\\n        for(int i=0;i<26;++i)\\n            newnode->child[i] = NULL;\\n        return newnode;\\n    }\\n    node *root = getNode(\\'/\\');  //root\\n    \\n    //Trie INSERT\\n    void insert(string s)\\n    {\\n        node *curr=root;\\n        int index,i=0;\\n        while(s[i])\\n        {\\n            index = s[i]-\\'a\\';\\n            if(curr->child[index]==NULL)\\n                curr->child[index] = getNode(s[i]);\\n            \\n            curr=curr->child[index];\\n            i+=1;\\n        }\\n        curr->ends += 1;\\n        curr->word = s;\\n    }\\n    \\n    void solve(vector<vector<char>>& board,int i,int j,int r,int c,vector<string>& ans,node *curr)\\n    {\\n        //Base case\\n        //If the trie doesn\\'t have the current char OR cell is Visited\\n        int index = board[i][j]-\\'a\\';\\n        if(board[i][j]==\\'$\\' || curr->child[index]==NULL)  \\n            return;\\n        \\n        curr = curr->child[index];\\n        if(curr->ends > 0)\\n        {\\n            ans.push_back(curr->word);\\n            curr->ends -=1;\\n        }\\n        \\n        //Body\\n        char ch = board[i][j];   //Store current char\\n        board[i][j] = \\'$\\';  //Mark current node visited\\n        \\n        if(i>0)     //TOP\\n            solve(board,i-1,j,r,c,ans,curr);\\n        if(i<r-1)   //DOWN\\n            solve(board,i+1,j,r,c,ans,curr);\\n        if(j>0)     //LEFT\\n            solve(board,i,j-1,r,c,ans,curr);\\n        if(j<c-1)   //RIGHT\\n            solve(board,i,j+1,r,c,ans,curr);\\n        \\n        board[i][j] = ch;    //Mark current node as Unvisited by restoring the value\\n    }\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {        \\n        int r=board.size();\\n        int c=board[0].size();\\n        \\n        //Insert all words in TRIE\\n        for(int i=0;i<words.size();++i)\\n            insert(words[i]);\\n        \\n        //Now search words\\n        vector<string> ans;\\n        for(int i=0;i<r;++i)\\n        {\\n            for(int j=0;j<c;++j)\\n                solve(board,i,j,r,c,ans,root);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077152,
                "title": "python3-trie-dfs-easy-to-understand-solution",
                "content": "```\\n\\'\\'\\'\\nIn Brute Force DFS time complexity: O(k * m * n * 4^(m*n)) where k = len(words)\\nBut we can remove the k if we store all the words into a TRIE.\\n\\'\\'\\'\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.endOfWord = True\\n    \\nclass Solution:\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.addWord(word)\\n        \\n        row = len(board); col = len(board[0])\\n        res = set()\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or c < 0 or r >= row or c >= col or \\n                board[r][c] not in node.children or board[r][c] == \\'#\\'):\\n                return\\n            \\n            word += board[r][c]\\n            node = node.children[board[r][c]]\\n            if node.endOfWord:\\n                res.add(word)\\n                node.endOfWord = False\\n            tmp = board[r][c]\\n            board[r][c] = \\'#\\'\\n            dfs(r-1, c, node, word)\\n            dfs(r+1, c, node, word)\\n            dfs(r, c-1, node, word)\\n            dfs(r, c+1, node, word)\\n            board[r][c] = tmp\\n            \\n        for r in range(row):\\n            for c in range(col):\\n                dfs(r, c, root, \"\")\\n        \\n        return res\\n    \\n# Time: O(m * n * 4^(m*n))\\n# Space: O(m*n + k)\\n```\\n**NOTE:** The above solution will pass all 63 / 63 test cases but takes too much time.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n\\'\\'\\'\\nIn Brute Force DFS time complexity: O(k * m * n * 4^(m*n)) where k = len(words)\\nBut we can remove the k if we store all the words into a TRIE.\\n\\'\\'\\'\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.endOfWord = True\\n    \\nclass Solution:\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.addWord(word)\\n        \\n        row = len(board); col = len(board[0])\\n        res = set()\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or c < 0 or r >= row or c >= col or \\n                board[r][c] not in node.children or board[r][c] == \\'#\\'):\\n                return\\n            \\n            word += board[r][c]\\n            node = node.children[board[r][c]]\\n            if node.endOfWord:\\n                res.add(word)\\n                node.endOfWord = False\\n            tmp = board[r][c]\\n            board[r][c] = \\'#\\'\\n            dfs(r-1, c, node, word)\\n            dfs(r+1, c, node, word)\\n            dfs(r, c-1, node, word)\\n            dfs(r, c+1, node, word)\\n            board[r][c] = tmp\\n            \\n        for r in range(row):\\n            for c in range(col):\\n                dfs(r, c, root, \"\")\\n        \\n        return res\\n    \\n# Time: O(m * n * 4^(m*n))\\n# Space: O(m*n + k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858797,
                "title": "java-trie-dfs-simple-easy-explained-with-diagram-on-paper",
                "content": "If you like the explanation/diagram, do **UpVote** :)\\n\\n**Note**: There are many ways to shorten the Runtime, as I see many have mentioned Runtime of less than 50 or 100ms. But the overall runtime Complexity is still same/similar.\\n                Please note, in coding interview, interviewer may ask us to implement in various ways. \\n\\t\\t\\t\\t   a.   Example, we may be asked, not to replace character by some symbol like \"#\", but instead to use some extra space. Hence, I have used extra 2D matrix named \"visited\" to keep track of visited ones.\\n\\t\\t\\t\\t   b. I have tried to keep logic quite simple and commented it, for easy understanding. Hope that helps.\\n\\n## Explanation:\\nCheck the diagram, and the comments for explanation. Let me know and I can provide detailed explanation, if needed :)\\n## Trie Diagram (first test case)  \\n![image](https://assets.leetcode.com/users/images/ea0eadfa-9943-407d-88a4-3ced933c5796_1647541617.3269982.png)\\n\\n## Code\\n\\tclass Solution {\\n\\t\\tpublic List<String> findWords(char[][] board, String[] words) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\t\\tTrie trie = new Trie();\\n\\n\\t\\t\\tfillTrie(trie, words);                                                                                            // First, we will fill up the Trie with all words.  \\n\\t\\t\\treturn findWordInBoard(board, trie, rows, cols, new ArrayList<>());                                               // Then, call method to \"find Word In Board\"\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic List<String> findWordInBoard(char[][] board, Trie trie, int rows, int cols, List<String> resultList){\\n\\t\\t\\tTrie.TrieNode node;\\n\\t\\t\\tfor(int r = 0; r < rows; r++){\\n\\t\\t\\t\\tfor(int c = 0; c < cols; c++){                                                                                 // traverese each char in Board.\\n\\t\\t\\t\\t\\tchar ch = board[r][c];\\n\\t\\t\\t\\t\\tnode = trie.root;                                                                                          // we need to reset node each time to root.\\n\\t\\t\\t\\t\\tif(node.children[ch - \\'a\\'] == null){ continue; }                                                           // if child exists at children[o - \\'a\\']. children[111-97] = children[14]\\n\\t\\t\\t\\t\\tresultList = dfsOnBoard(board, node.children[ch - \\'a\\'], new boolean[rows][cols], r, c, resultList);        // call method, DFS on board \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn resultList;\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic List<String> dfsOnBoard(char[][] board, Trie.TrieNode node, boolean[][] visited, int row, int col, List<String> resultList){\\n\\t\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\t\\tif( row < 0   ||   row >= rows   ||  col < 0   ||  col >= cols   ||   \\n\\t\\t\\t\\tvisited[row][col] == true    ||    board[row][col] != node.val ){\\n\\t\\t\\t\\treturn resultList;                                                                                             // check bounds, where it returns false   \\n\\t\\t\\t}\\n\\t\\t\\tif(node!= null && ! node.wordEnd.isEmpty() ){                                                                      // when we reach node in Trie, where we have got a word. \\n\\t\\t\\t\\tif(! node.isDone){                                                                                             // initially isDone = false            \\n\\t\\t\\t\\t\\tresultList.add(node.wordEnd);\\n\\t\\t\\t\\t\\tnode.isDone = true;                                                                                        // once we add this word to resultList, mark isDone = true. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// So, we can avoid duplicate word (in case if same \"words\" array has duplicate words).\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvisited[row][col] = true;\\n\\t\\t\\tfor(Trie.TrieNode childNode : node.children){\\n\\t\\t\\t\\tif(childNode == null){ continue; }\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row, col-1, resultList);                                 // DFS on Left\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row, col+1, resultList);                                 // DFS on Right\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row-1, col, resultList);                                 // DFS on Up\\n\\t\\t\\t\\tdfsOnBoard(board, childNode, visited, row+1, col, resultList);                                 // DFS on Down                \\n\\t\\t\\t}        \\n\\t\\t\\tvisited[row][col] = false;\\n\\t\\t\\treturn resultList;\\n\\t\\t}\\n\\n\\t\\t// -----------------------------------------------------------------------\\n\\t\\tpublic void fillTrie(Trie trie, String[] words){\\n\\t\\t\\tfor(String word : words){\\n\\t\\t\\t\\ttrie.insert(word, trie.root);                                                                                   //  insert each word to Trie\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\t// ---------------------------------------------------------------------- TRIE ------------------------------------------------------------------------ //\\n\\t\\tstatic class Trie{\\n\\t\\t\\tTrieNode root;\\n\\t\\t\\tpublic Trie(){\\n\\t\\t\\t\\troot = new TrieNode(\\' \\');\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ----------------------------------------------------------\\n\\t\\t\\tpublic void insert(String word, TrieNode node){\\n\\t\\t\\t\\tfor( char ch : word.toCharArray() ){\\n\\t\\t\\t\\t\\tnode = insertCharInTrie(node, ch);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode.wordEnd = word;\\n\\t\\t\\t}\\n\\t\\t\\tpublic TrieNode insertCharInTrie(TrieNode node, char ch){\\n\\t\\t\\t\\tif(node.children[ch - \\'a\\'] == null){\\n\\t\\t\\t\\t\\tnode.children[ch - \\'a\\'] = new TrieNode(ch);                                \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode = node.children[ch - \\'a\\'];\\n\\t\\t\\t\\treturn node;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ---------------- TRIENODE ----------------------\\n\\t\\t\\tstatic class TrieNode{\\n\\t\\t\\t\\tchar val;                                                                                       // node\\'s char value e.g. \\'o\\'\\n\\t\\t\\t\\tString wordEnd = \"\";\\n\\t\\t\\t\\tboolean isDone = false;\\n\\t\\t\\t\\tTrieNode[] children;\\n\\t\\t\\t\\tTrieNode(char val){                                                                             // pass val in the constructor \\n\\t\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t\\t\\tchildren = new TrieNode[26];                                                                // each node can have upto 26 children.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\nIf you like the explanation, do **UpVote** :)\\nIf you need more explanation or, if there is more optimized way, **comment** below.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<String> findWords(char[][] board, String[] words) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\t\\tTrie trie = new Trie();\\n\\n\\t\\t\\tfillTrie(trie, words);                                                                                            // First, we will fill up the Trie with all words.  \\n\\t\\t\\treturn findWordInBoard(board, trie, rows, cols, new ArrayList<>());                                               // Then, call method to \"find Word In Board\"\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1513064,
                "title": "dfs-runtime-4-ms-faster-than-98-23-of-c-online-submissions",
                "content": "- Variation of [word search-i](https://leetcode.com/problems/word-search) \\n```cpp\\nclass Solution {\\nprivate:\\n    //DFS :  if we get word of first letter seach all possible path upto its length\\n    bool searchWord(vector<vector<char>>&board,long long i,long long j,long long count,string word){\\n        //Base case : we get all the char of words \\n        if(count==word.length()){\\n            return true;\\n        }\\n\\n        //case : out of bound like i and j must be in board and word[count]==bord[i][j] other wise false return false\\n        if(i<0 or i>=board.size() or j<0 or j>=board[i].size() or board[i][j]!=word[count]){\\n            return false;    \\n        }\\n\\n        //mark for not visiting duplicate :\\n        char temp = board[i][j];\\n        board[i][j]=\\' \\';\\n\\n        //search for possible paths :\\n        bool found = searchWord(board,i+1,j,count+1,word) ||  //right\\n\\t\\t\\t\\t\\t searchWord(board,i-1,j,count+1,word) ||  //left\\n\\t\\t\\t\\t\\t searchWord(board,i,j+1,count+1,word)||  //down\\n\\t\\t\\t\\t\\t searchWord(board,i,j-1,count+1,word);   //up \\n        \\n        //unmark the word for next call  : \\n        board[i][j] = temp;\\n\\n        return found; \\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>ans;\\n        string temp;\\n        for(int w=0;w<words.size();w++){\\n            bool flag=false;\\n            temp=words[w];\\n            reverse(temp.begin(),temp.end());\\n            for(long long i=0;i<board.size();i++){\\n                for(long long j=0;j<board[i].size();j++){\\n                    if(board[i][j] == temp[0] and searchWord(board,i,j,0,temp)){\\n                        reverse(temp.begin(),temp.end());\\n                        ans.push_back(temp);\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n                if(flag==true){\\n                    break;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    //DFS :  if we get word of first letter seach all possible path upto its length\\n    bool searchWord(vector<vector<char>>&board,long long i,long long j,long long count,string word){\\n        //Base case : we get all the char of words \\n        if(count==word.length()){\\n            return true;\\n        }\\n\\n        //case : out of bound like i and j must be in board and word[count]==bord[i][j] other wise false return false\\n        if(i<0 or i>=board.size() or j<0 or j>=board[i].size() or board[i][j]!=word[count]){\\n            return false;    \\n        }\\n\\n        //mark for not visiting duplicate :\\n        char temp = board[i][j];\\n        board[i][j]=\\' \\';\\n\\n        //search for possible paths :\\n        bool found = searchWord(board,i+1,j,count+1,word) ||  //right\\n\\t\\t\\t\\t\\t searchWord(board,i-1,j,count+1,word) ||  //left\\n\\t\\t\\t\\t\\t searchWord(board,i,j+1,count+1,word)||  //down\\n\\t\\t\\t\\t\\t searchWord(board,i,j-1,count+1,word);   //up \\n        \\n        //unmark the word for next call  : \\n        board[i][j] = temp;\\n\\n        return found; \\n    }\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        vector<string>ans;\\n        string temp;\\n        for(int w=0;w<words.size();w++){\\n            bool flag=false;\\n            temp=words[w];\\n            reverse(temp.begin(),temp.end());\\n            for(long long i=0;i<board.size();i++){\\n                for(long long j=0;j<board[i].size();j++){\\n                    if(board[i][j] == temp[0] and searchWord(board,i,j,0,temp)){\\n                        reverse(temp.begin(),temp.end());\\n                        ans.push_back(temp);\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n                if(flag==true){\\n                    break;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511731,
                "title": "java-7ms-beat-98-trietree-node-with-counter-pruning",
                "content": "```\\nclass Solution {\\n    \\n    public class TrieNode {\\n        TrieNode[] next;\\n        String word;\\n        int refCnt;\\n        public TrieNode() {\\n            this.next = new TrieNode[26];   \\n        }\\n    }\\n    int[][] dirs = new int[][] {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n    \\n    TrieNode root;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        root = new TrieNode();\\n        for (String word: words) {\\n            buildTree(word);\\n        }\\n        List<String> res = new ArrayList<>();\\n        int n = board.length;\\n        int m = board[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (root.next[board[i][j] - \\'a\\'] != null && root.next[board[i][j] - \\'a\\'].refCnt > 0) {\\n                    dfs(board, i, j, root, res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(char[][] board, int i, int j, TrieNode cur, List<String> res) {\\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'@\\'  || cur.next[board[i][j] - \\'a\\'] == null || cur.next[board[i][j] - \\'a\\'].refCnt == 0) {\\n            return;\\n        }\\n        cur = cur.next[board[i][j] - \\'a\\'];\\n        if (cur != null && cur.word != null) {\\n            res.add(cur.word);\\n            subtract(cur.word);\\n            cur.word = null;\\n        }\\n\\n        char temp = board[i][j];\\n        board[i][j] = \\'@\\';\\n        for (int[] dir: dirs) {\\n            int x = i + dir[0];\\n            int y = j + dir[1];\\n            dfs(board, x, y, cur, res);\\n        }\\n        board[i][j] = temp;\\n    }\\n    \\n    private void buildTree(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                cur.next[word.charAt(i) - \\'a\\'] = new TrieNode();\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt += 1;\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        cur.word = word;\\n    }\\n    \\n    private void subtract(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur == null) {\\n                return;\\n            }\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                return;\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt -= 1;\\n            if (cur.next[word.charAt(i) - \\'a\\'].refCnt == 0) {\\n                cur.next[word.charAt(i) - \\'a\\'] = null;\\n            }\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        if (cur != null && cur.refCnt == 0) {\\n            cur = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public class TrieNode {\\n        TrieNode[] next;\\n        String word;\\n        int refCnt;\\n        public TrieNode() {\\n            this.next = new TrieNode[26];   \\n        }\\n    }\\n    int[][] dirs = new int[][] {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};\\n    \\n    TrieNode root;\\n    \\n    public List<String> findWords(char[][] board, String[] words) {\\n        root = new TrieNode();\\n        for (String word: words) {\\n            buildTree(word);\\n        }\\n        List<String> res = new ArrayList<>();\\n        int n = board.length;\\n        int m = board[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (root.next[board[i][j] - \\'a\\'] != null && root.next[board[i][j] - \\'a\\'].refCnt > 0) {\\n                    dfs(board, i, j, root, res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(char[][] board, int i, int j, TrieNode cur, List<String> res) {\\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'@\\'  || cur.next[board[i][j] - \\'a\\'] == null || cur.next[board[i][j] - \\'a\\'].refCnt == 0) {\\n            return;\\n        }\\n        cur = cur.next[board[i][j] - \\'a\\'];\\n        if (cur != null && cur.word != null) {\\n            res.add(cur.word);\\n            subtract(cur.word);\\n            cur.word = null;\\n        }\\n\\n        char temp = board[i][j];\\n        board[i][j] = \\'@\\';\\n        for (int[] dir: dirs) {\\n            int x = i + dir[0];\\n            int y = j + dir[1];\\n            dfs(board, x, y, cur, res);\\n        }\\n        board[i][j] = temp;\\n    }\\n    \\n    private void buildTree(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                cur.next[word.charAt(i) - \\'a\\'] = new TrieNode();\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt += 1;\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        cur.word = word;\\n    }\\n    \\n    private void subtract(String word) {\\n        TrieNode cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cur == null) {\\n                return;\\n            }\\n            if (cur.next[word.charAt(i) - \\'a\\'] == null) {\\n                return;\\n            }\\n            cur.next[word.charAt(i) - \\'a\\'].refCnt -= 1;\\n            if (cur.next[word.charAt(i) - \\'a\\'].refCnt == 0) {\\n                cur.next[word.charAt(i) - \\'a\\'] = null;\\n            }\\n            cur = cur.next[word.charAt(i) - \\'a\\'];\\n        }\\n        if (cur != null && cur.refCnt == 0) {\\n            cur = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510652,
                "title": "c-easy-clean-solution-fastest-dfs-backtracking-trie-detailed",
                "content": "```\\n// NOTE: we have used inserted flag in trie node to make sure\\n// that one word is inserted into ans vec only once o.w below \\n// commented testcase fails in which \"oa\" is inserted twice.\\n// trie node class\\nclass TrieNode {\\npublic:\\n    bool end, inserted;\\n    vector<TrieNode*> letters;\\n    TrieNode (bool end=false, bool inserted=false, int size=26) {\\n        this->end = end;\\n        this->inserted = inserted;\\n        this->letters = vector<TrieNode*>(size, NULL);\\n    }\\n};\\n// soluton class\\nclass Solution {\\n    typedef TrieNode node;\\npublic:\\n    // trie\\n    node* troot = NULL;\\n    node* insertWord(node *root, string &word, int i=0) {\\n        if (!root) return insertWord(new node(), word, i);\\n        if (i == word.size()) root->end = true;\\n        else root->letters[word[i] - \\'a\\'] = insertWord(root->letters[word[i] - \\'a\\'], word, i + 1);\\n        return root;\\n    }\\n    // solution\\n    char fill = \\'#\\';    // assuming # doesn\\'t exist in board\\n    vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\\n    string word;\\n    vector<string> ans;\\n    /*  testcase:\\n    [\"o\",\"a\",\"b\",\"n\"]\\n    [\"o\",\"t\",\"a\",\"e\"]\\n    [\"a\",\"h\",\"k\",\"r\"]\\n    [\"a\",\"f\",\"l\",\"v\"]\\n    [\"oa\",\"oaa\"]\\n    */\\n    // main func.\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // IDEA is to use trie to optimise T(n) as it can be possible that in words list\\n        // we have prefixes present repeatedly of a word. Eg: [\\'u\\', \\'um\\', \\'ume\\', \\'umes\\', \\'umesh\\']\\n        // in that case, searching words one by one is not good method, instead, search from prefix to word\\n        // which can be done using help of trie. Trie also make sure that only unique words are searched i.e\\n        // if list is: [\\'o\\', \\'o\\', \\'o\\', oo\\'] trie will be: [\\'o\\', \\'oo\\'] only.\\n        // build Trie\\n        for (auto &word: words)\\n            troot = insertWord(troot, word);\\n        // build answer using dfs\\n        for (int row = 0; row < board.size(); row++)\\n            for (int col = 0; col < board[0].size(); col++)\\n                if (troot->letters[board[row][col] - \\'a\\'])\\n                    dfs(board, row, col, troot);\\n        return ans;\\n    }\\n    void dfs(vector<vector<char>> &board, int x, int y, node *root) {\\n        // base case\\n        if (!root or x < 0 or x >= board.size() or y < 0 or y >= board[0].size())\\n            return;\\n        // below cond.: board[x][y] == fill is IMP\\n        if (board[x][y] == fill or !root->letters[board[x][y] - \\'a\\'])\\n            return;\\n        // build word\\n        word.push_back(board[x][y]);\\n        // update root\\n        root = root->letters[board[x][y] - \\'a\\'];\\n        // if word exist in trie then push it to result and mark its inserted as true\\n        // so that this word is not inserted again into the result\\n        if (root->end and not root->inserted) {\\n            root->inserted = true;\\n            ans.push_back(word);\\n        }\\n        // save the original cell and fill it\\n        char orig = board[x][y];\\n        board[x][y] = fill;\\n        for (int d = 0; d < 4; d++)\\n            dfs(board, x + dx[d], y + dy[d], root);\\n        // Backtrack\\n        board[x][y] = orig;\\n        word.pop_back();\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [],
                "code": "```\\n// NOTE: we have used inserted flag in trie node to make sure\\n// that one word is inserted into ans vec only once o.w below \\n// commented testcase fails in which \"oa\" is inserted twice.\\n// trie node class\\nclass TrieNode {\\npublic:\\n    bool end, inserted;\\n    vector<TrieNode*> letters;\\n    TrieNode (bool end=false, bool inserted=false, int size=26) {\\n        this->end = end;\\n        this->inserted = inserted;\\n        this->letters = vector<TrieNode*>(size, NULL);\\n    }\\n};\\n// soluton class\\nclass Solution {\\n    typedef TrieNode node;\\npublic:\\n    // trie\\n    node* troot = NULL;\\n    node* insertWord(node *root, string &word, int i=0) {\\n        if (!root) return insertWord(new node(), word, i);\\n        if (i == word.size()) root->end = true;\\n        else root->letters[word[i] - \\'a\\'] = insertWord(root->letters[word[i] - \\'a\\'], word, i + 1);\\n        return root;\\n    }\\n    // solution\\n    char fill = \\'#\\';    // assuming # doesn\\'t exist in board\\n    vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\\n    string word;\\n    vector<string> ans;\\n    /*  testcase:\\n    [\"o\",\"a\",\"b\",\"n\"]\\n    [\"o\",\"t\",\"a\",\"e\"]\\n    [\"a\",\"h\",\"k\",\"r\"]\\n    [\"a\",\"f\",\"l\",\"v\"]\\n    [\"oa\",\"oaa\"]\\n    */\\n    // main func.\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // IDEA is to use trie to optimise T(n) as it can be possible that in words list\\n        // we have prefixes present repeatedly of a word. Eg: [\\'u\\', \\'um\\', \\'ume\\', \\'umes\\', \\'umesh\\']\\n        // in that case, searching words one by one is not good method, instead, search from prefix to word\\n        // which can be done using help of trie. Trie also make sure that only unique words are searched i.e\\n        // if list is: [\\'o\\', \\'o\\', \\'o\\', oo\\'] trie will be: [\\'o\\', \\'oo\\'] only.\\n        // build Trie\\n        for (auto &word: words)\\n            troot = insertWord(troot, word);\\n        // build answer using dfs\\n        for (int row = 0; row < board.size(); row++)\\n            for (int col = 0; col < board[0].size(); col++)\\n                if (troot->letters[board[row][col] - \\'a\\'])\\n                    dfs(board, row, col, troot);\\n        return ans;\\n    }\\n    void dfs(vector<vector<char>> &board, int x, int y, node *root) {\\n        // base case\\n        if (!root or x < 0 or x >= board.size() or y < 0 or y >= board[0].size())\\n            return;\\n        // below cond.: board[x][y] == fill is IMP\\n        if (board[x][y] == fill or !root->letters[board[x][y] - \\'a\\'])\\n            return;\\n        // build word\\n        word.push_back(board[x][y]);\\n        // update root\\n        root = root->letters[board[x][y] - \\'a\\'];\\n        // if word exist in trie then push it to result and mark its inserted as true\\n        // so that this word is not inserted again into the result\\n        if (root->end and not root->inserted) {\\n            root->inserted = true;\\n            ans.push_back(word);\\n        }\\n        // save the original cell and fill it\\n        char orig = board[x][y];\\n        board[x][y] = fill;\\n        for (int d = 0; d < 4; d++)\\n            dfs(board, x + dx[d], y + dy[d], root);\\n        // Backtrack\\n        board[x][y] = orig;\\n        word.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497520,
                "title": "c-backtracking",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\nWe can use backtracking approach in an optimized manner, instead of searching for a word in complete matrix, we can store Last Character of every word in a Set. Later while traversing through matrix we can store Index where these words might end and while searching for word in a matrrix we will only need to start searching from these particular Indexes in grid rather than traversing whole grid again n again for each word.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int dxy[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n    bool solve(vector<vector<char>>& grid, int i, int j, string &s, int idx){\\n        int n=grid.size(), m=grid[0].size();\\n        if(idx==-1) return true;\\n        if(i<0 || j<0 || i==n || j==m || grid[i][j]!=s[idx]) return false;\\n        \\n        bool ans=false;\\n        char ch=grid[i][j];\\n        grid[i][j]=\\'*\\';\\n        for(int k=0;k<4;k++){\\n            int x=i+dxy[k][0], y=j+dxy[k][1];\\n            ans |= solve(grid,x,y,s,idx-1);\\n        }\\n        grid[i][j]=ch; // backtrack\\n        \\n        return ans;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        vector<string> ans;\\n        set<char> st;\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1]; // TLE happens if we insert first char to identify occurance of a word\\n            st.insert(ch);\\n        }\\n        map<char,vector<pair<int,int>>> mp;\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char ch=grid[i][j];\\n                if(st.find(ch)!=st.end()){\\n                    mp[ch].push_back({i,j});  Index where words ending at this charcter might end\\n                }\\n            }\\n        }\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1];\\n            vector<pair<int,int>> v=mp[ch];\\n            for(int i=0;i<v.size();i++){\\n                int x=v[i].first, y=v[i].second;\\n                bool found=solve(grid,x,y,s,s.length()-1);\\n                if(found){\\n                    ans.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dxy[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n    bool solve(vector<vector<char>>& grid, int i, int j, string &s, int idx){\\n        int n=grid.size(), m=grid[0].size();\\n        if(idx==-1) return true;\\n        if(i<0 || j<0 || i==n || j==m || grid[i][j]!=s[idx]) return false;\\n        \\n        bool ans=false;\\n        char ch=grid[i][j];\\n        grid[i][j]=\\'*\\';\\n        for(int k=0;k<4;k++){\\n            int x=i+dxy[k][0], y=j+dxy[k][1];\\n            ans |= solve(grid,x,y,s,idx-1);\\n        }\\n        grid[i][j]=ch; // backtrack\\n        \\n        return ans;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        vector<string> ans;\\n        set<char> st;\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1]; // TLE happens if we insert first char to identify occurance of a word\\n            st.insert(ch);\\n        }\\n        map<char,vector<pair<int,int>>> mp;\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                char ch=grid[i][j];\\n                if(st.find(ch)!=st.end()){\\n                    mp[ch].push_back({i,j});  Index where words ending at this charcter might end\\n                }\\n            }\\n        }\\n        for(int k=0;k<words.size();k++){\\n            string s=words[k];\\n            char ch=s[s.length()-1];\\n            vector<pair<int,int>> v=mp[ch];\\n            for(int i=0;i<v.size();i++){\\n                int x=v[i].first, y=v[i].second;\\n                bool found=solve(grid,x,y,s,s.length()-1);\\n                if(found){\\n                    ans.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178002,
                "title": "js-pruning-advanced-optimization-100",
                "content": "Most of the solutions*, including the top rated one do not implement pruning. The reason is because it\\'s quite a bit more difficult to reason about. **However**, pruning improves the runtime massively. It is most likely the difference between a hire vs a **strong** hire when interviewing.\\n\\nFor Javascript,\\n1. Without pruning: 900ms\\n2. With pruning: 130ms\\n\\n*The leetcode official solution does implement pruning, but we can prune even **more aggressively**. The official solution also requires keeping track of the parent node, which I find a little confusing. Tbh, I\\'m a little unsure of how my solution compares with the official solution. The official solution travels down unnecessary paths, but leaf node removal is very efficient. On the other hand, my solution\\'s **remove()** method is a little expensive every time we find a word, but could possibly be worth it due to better pruning. Please let me know in comments what you think. \\n\\n**Algorithm**\\n1. The main algorithm is still pretty standard, but we introduce **prefixCount** and **remove()** method to our Trie. **prefixCount** = how many words current prefix is a part of. (Should be familiar if you did other Leetcode Trie problems). Now, whenever we find a word, we remove it from our Trie *immediately* (as opposed to the official solution, which does it \"lazily\"). By doing so, we can prune entire subtrees when prefixCount drops to 0.\\n\\n2. With **prefixCount**, we also now know exactly the max number of words we may find given a certain node. So now, we track how many words we have found while recursing. And we **break early** when we have found the **prefixCount**! This way, we do not unnecessarily recurse deeper when there are no more words to be found.\\n\\n```\\nclass Trie {\\n  constructor() {\\n    this.root = {};\\n  }\\n  \\n  insert(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      if(!node[char]) {\\n        node[char] = {};\\n      }\\n      \\n      node = node[char];\\n      node.prefixCount = (node.prefixCount || 0) + 1;\\n    }\\n    \\n    node.word = word;\\n  }\\n  \\n  remove(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      node[char].prefixCount--;\\n      \\n      if(node[char].prefixCount === 0) {\\n        delete node[char];\\n        return;\\n      }\\n      node = node[char];\\n    }\\n    \\n    delete node.word;\\n  }\\n}\\n\\nvar findWords = function(board, words) {\\n  const ROWS = board.length;\\n  const COLS = board[0].length;\\n  const foundWords = [];\\n  const trie = new Trie();\\n  \\n  // 1) construct the trie\\n  for(const word of words) {\\n    trie.insert(word);\\n  }\\n  \\n  const directions = [[1,0],[-1,0],[0,1],[0,-1]];\\n  function dfs(r, c, node) {\\n    let numFound1 = 0;\\n    \\n    if(node.word) {\\n      foundWords.push(node.word);\\n      trie.remove(node.word);\\n      numFound1++;\\n    }\\n    \\n    // coordinate (r,c) not within bounds\\n    if(r < 0 || r >= ROWS || c < 0 || c >= COLS) {\\n      return numFound1;\\n    }\\n    \\n    const char = board[r][c];\\n    // char continuation at (r,c) is not in trie\\n    if(!node[char]) {\\n      return numFound1;\\n    }\\n  \\n    // at this point, board[r][c] is a valid character continuation in trie\\n    board[r][c] = \\'#\\';\\n    // record max number of words we can find with current prefix\\n    const PREFIX_COUNT = node[char].prefixCount;\\n    let numFound2 = 0;\\n    for(const [dr, dc] of directions) {\\n      numFound2 += dfs(r + dr, c + dc, node[char]); \\n      \\n      // found all possible words with this prefix. Break early.\\n      if(numFound2 === PREFIX_COUNT) break;\\n    }\\n    \\n    board[r][c] = char;\\n    return numFound1 + numFound2;\\n  }\\n  \\n  // 2) iterate through board recursively square by square\\n  for(let r = 0; r < ROWS; r++) {\\n    for(let c = 0; c < COLS; c++) {\\n      dfs(r, c, trie.root);\\n    }\\n  }\\n  \\n  return foundWords;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Trie {\\n  constructor() {\\n    this.root = {};\\n  }\\n  \\n  insert(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      if(!node[char]) {\\n        node[char] = {};\\n      }\\n      \\n      node = node[char];\\n      node.prefixCount = (node.prefixCount || 0) + 1;\\n    }\\n    \\n    node.word = word;\\n  }\\n  \\n  remove(word) {\\n    let node = this.root;\\n    \\n    for(const char of word) {\\n      node[char].prefixCount--;\\n      \\n      if(node[char].prefixCount === 0) {\\n        delete node[char];\\n        return;\\n      }\\n      node = node[char];\\n    }\\n    \\n    delete node.word;\\n  }\\n}\\n\\nvar findWords = function(board, words) {\\n  const ROWS = board.length;\\n  const COLS = board[0].length;\\n  const foundWords = [];\\n  const trie = new Trie();\\n  \\n  // 1) construct the trie\\n  for(const word of words) {\\n    trie.insert(word);\\n  }\\n  \\n  const directions = [[1,0],[-1,0],[0,1],[0,-1]];\\n  function dfs(r, c, node) {\\n    let numFound1 = 0;\\n    \\n    if(node.word) {\\n      foundWords.push(node.word);\\n      trie.remove(node.word);\\n      numFound1++;\\n    }\\n    \\n    // coordinate (r,c) not within bounds\\n    if(r < 0 || r >= ROWS || c < 0 || c >= COLS) {\\n      return numFound1;\\n    }\\n    \\n    const char = board[r][c];\\n    // char continuation at (r,c) is not in trie\\n    if(!node[char]) {\\n      return numFound1;\\n    }\\n  \\n    // at this point, board[r][c] is a valid character continuation in trie\\n    board[r][c] = \\'#\\';\\n    // record max number of words we can find with current prefix\\n    const PREFIX_COUNT = node[char].prefixCount;\\n    let numFound2 = 0;\\n    for(const [dr, dc] of directions) {\\n      numFound2 += dfs(r + dr, c + dc, node[char]); \\n      \\n      // found all possible words with this prefix. Break early.\\n      if(numFound2 === PREFIX_COUNT) break;\\n    }\\n    \\n    board[r][c] = char;\\n    return numFound1 + numFound2;\\n  }\\n  \\n  // 2) iterate through board recursively square by square\\n  for(let r = 0; r < ROWS; r++) {\\n    for(let c = 0; c < COLS; c++) {\\n      dfs(r, c, trie.root);\\n    }\\n  }\\n  \\n  return foundWords;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062830,
                "title": "swift-trie-with-the-speed-up-trick-explained",
                "content": "The folowing is not my own solution. Copied it from the fastest solution and added comments for the speed up trick. Scroll down to the bottom and check the inline comments.\\n```\\nclass Solution {\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        var root = TrieNode()\\n        // Building the Trie\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if let child = node.children[char] {\\n                    node = child\\n                } else {\\n                    let newNode = TrieNode()\\n                    node.children[char] = newNode\\n                    node = newNode\\n                }\\n            }\\n            node.word = word\\n        }\\n        \\n        var res: [String] = []\\n        var copy = board\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if root.children[board[i][j]] != nil {\\n                    backtrack(i, j, root, &copy, &res)\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func backtrack(_ row: Int, _ col: Int, _ parent: TrieNode, _ board: inout [[Character]], _ res: inout [String]) {\\n        let letter = board[row][col]\\n        if let node = parent.children[letter] {\\n            \\n            if let word = node.word {\\n                res.append(word)\\n                node.word = nil\\n            }\\n            \\n            // Marking the current location as visited\\n            board[row][col] = \"#\"\\n            \\n            let rowOffset = [-1, 0, 1, 0]\\n            let colOffset = [0, 1, 0, -1]\\n            for i in 0..<4 {\\n                let newRow = row + rowOffset[i]\\n                let newCol = col + colOffset[i]\\n                if newRow < 0 || newRow >= board.count || newCol < 0 || newCol >= board[0].count {\\n                    continue\\n                }\\n                if node.children[board[newRow][newCol]] != nil {\\n                    backtrack(newRow, newCol, node, &board, &res)\\n                }\\n            }\\n            \\n            board[row][col] = letter\\n\\t\\t\\t// SPEED UP TRICK:\\n            // What are we doing here?\\n            // While backtracking we removing all the leaf nodes and as we go up we would be also be removing some of\\n            // parent nodes that now became leaf nodes because of the removal of the children. By doing this we are making the \\n            // Trie much smaller \\n            \\n            // Now we know what we are doing here\\n            // Lets understand why we are doing this\\n            // We reach a leaf node only if we found a string matching that leaf node on the board\\n            // All leaf nodes would be the end of a complete word, so after we find the word there is no need to \\n            // keep the elements of the word as we dont need duplicates. Finding the word once is enough. Incase we also wanted\\n            // how many times a particular word occured in the board we should not do this but in this case we dont need that. So we can safely remove the leaf node and we would also be removing its parent while we backtrack till the beginning of the word until we see that the parent has atleast one child.\\n            \\n            // This severely speeds up the algorithm 2400ms -> 4ms!!!!!!\\n            if node.children.isEmpty {\\n                parent.children[letter] = nil\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    var children: [Character: TrieNode] = [:] \\n    var word: String?\\n    init() {}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n        var root = TrieNode()\\n        // Building the Trie\\n        for word in words {\\n            var node = root\\n            for char in word {\\n                if let child = node.children[char] {\\n                    node = child\\n                } else {\\n                    let newNode = TrieNode()\\n                    node.children[char] = newNode\\n                    node = newNode\\n                }\\n            }\\n            node.word = word\\n        }\\n        \\n        var res: [String] = []\\n        var copy = board\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if root.children[board[i][j]] != nil {\\n                    backtrack(i, j, root, &copy, &res)\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func backtrack(_ row: Int, _ col: Int, _ parent: TrieNode, _ board: inout [[Character]], _ res: inout [String]) {\\n        let letter = board[row][col]\\n        if let node = parent.children[letter] {\\n            \\n            if let word = node.word {\\n                res.append(word)\\n                node.word = nil\\n            }\\n            \\n            // Marking the current location as visited\\n            board[row][col] = \"#\"\\n            \\n            let rowOffset = [-1, 0, 1, 0]\\n            let colOffset = [0, 1, 0, -1]\\n            for i in 0..<4 {\\n                let newRow = row + rowOffset[i]\\n                let newCol = col + colOffset[i]\\n                if newRow < 0 || newRow >= board.count || newCol < 0 || newCol >= board[0].count {\\n                    continue\\n                }\\n                if node.children[board[newRow][newCol]] != nil {\\n                    backtrack(newRow, newCol, node, &board, &res)\\n                }\\n            }\\n            \\n            board[row][col] = letter\\n\\t\\t\\t// SPEED UP TRICK:\\n            // What are we doing here?\\n            // While backtracking we removing all the leaf nodes and as we go up we would be also be removing some of\\n            // parent nodes that now became leaf nodes because of the removal of the children. By doing this we are making the \\n            // Trie much smaller \\n            \\n            // Now we know what we are doing here\\n            // Lets understand why we are doing this\\n            // We reach a leaf node only if we found a string matching that leaf node on the board\\n            // All leaf nodes would be the end of a complete word, so after we find the word there is no need to \\n            // keep the elements of the word as we dont need duplicates. Finding the word once is enough. Incase we also wanted\\n            // how many times a particular word occured in the board we should not do this but in this case we dont need that. So we can safely remove the leaf node and we would also be removing its parent while we backtrack till the beginning of the word until we see that the parent has atleast one child.\\n            \\n            // This severely speeds up the algorithm 2400ms -> 4ms!!!!!!\\n            if node.children.isEmpty {\\n                parent.children[letter] = nil\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    var children: [Character: TrieNode] = [:] \\n    var word: String?\\n    init() {}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061088,
                "title": "python-ac-backtracking-in-three-steps-terminate-success-backtrack",
                "content": "- Create our backtracking function\\n- First condition is `terminate`\\n\\t- When do we want to terminate our backtracking?\\n- Second condition is `success`\\n\\t- When and how should we update our successful finding of a word?\\n- Third is `backtrack`\\n\\t- Use backtracking to explore and avoid going in circles\\n\\n```python\\nclass Solution:\\n    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:    \\n        \\n                     \\n        @functools.lru_cache(None)\\n        def backtrack(i, j, path):\\n            \\n            # 1) terminate\\n            if i not in range(0, len(board)): return\\n            if j not in range(0, len(board[0])): return\\n            if board[i][j] == \"#\": return\\n            \\n            # 2) success\\n            path += board[i][j]\\n            if path in self.words:\\n                self.result.add(path)\\n                \\n            # 3) backtrack\\n            c = board[i][j]\\n            board[i][j] = \"#\"\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n                backtrack(x, y, path)\\n            \\n            board[i][j] = c\\n            \\n    \\n    \\n        self.words = set(words)\\n        self.result = set()\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                backtrack(i, j, \"\")        \\n        \\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:    \\n        \\n                     \\n        @functools.lru_cache(None)\\n        def backtrack(i, j, path):\\n            \\n            # 1) terminate\\n            if i not in range(0, len(board)): return\\n            if j not in range(0, len(board[0])): return\\n            if board[i][j] == \"#\": return\\n            \\n            # 2) success\\n            path += board[i][j]\\n            if path in self.words:\\n                self.result.add(path)\\n                \\n            # 3) backtrack\\n            c = board[i][j]\\n            board[i][j] = \"#\"\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n                backtrack(x, y, path)\\n            \\n            board[i][j] = c\\n            \\n    \\n    \\n        self.words = set(words)\\n        self.result = set()\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                backtrack(i, j, \"\")        \\n        \\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011904,
                "title": "python-dfs-beats-60",
                "content": "* Similar to [Word Search - 1](https://leetcode.com/problems/word-search/)\\n* Pass each **board[ i ][ j ]** to DFS function and check if it\\'s equal to current slicing of **word**\\n\\t* i.e. word[1:] = \"ello\" and board[i][j] = \"e\" indicates possibilites.\\n\\t* i.e. word[1:] = \"llo\" and board[i][j] = \"l\" indicates possibilites.\\n* Recusively call DFS until word has no slices left, return **True**\\n* Else return **False**\\n```\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\n\\t\\t\\tdef DFS(board, i, j, word):\\n\\t\\t\\t\\tif len(word) == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or word[0] != board[i][j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttemp = board[i][j]\\n\\t\\t\\t\\tboard[i][j] = \"#\"\\n\\t\\t\\t\\tres = DFS(board, i + 1, j, word[1:]) or DFS(board, i - 1, j, word[1:]) or DFS(board, i, j + 1, word[1:]) or DFS(board, i, j - 1, word[1:])\\n\\t\\t\\t\\tboard[i][j] = temp\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tres = []\\n\\t\\t\\ttemp_board = []\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\ttemp_board[:] = board\\n\\t\\t\\t\\tfor i in range(len(temp_board)):\\n\\t\\t\\t\\t\\tfor j in range(len(temp_board[0])):\\n\\t\\t\\t\\t\\t\\tif DFS(temp_board, i, j, word):\\n\\t\\t\\t\\t\\t\\t\\tif word not in res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres.append(word)\\n\\t\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tclass Solution:\\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\n\\t\\t\\tdef DFS(board, i, j, word):\\n\\t\\t\\t\\tif len(word) == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or word[0] != board[i][j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ttemp = board[i][j]\\n\\t\\t\\t\\tboard[i][j] = \"#\"\\n\\t\\t\\t\\tres = DFS(board, i + 1, j, word[1:]) or DFS(board, i - 1, j, word[1:]) or DFS(board, i, j + 1, word[1:]) or DFS(board, i, j - 1, word[1:])\\n\\t\\t\\t\\tboard[i][j] = temp\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\tres = []\\n\\t\\t\\ttemp_board = []\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\ttemp_board[:] = board\\n\\t\\t\\t\\tfor i in range(len(temp_board)):\\n\\t\\t\\t\\t\\tfor j in range(len(temp_board[0])):\\n\\t\\t\\t\\t\\t\\tif DFS(temp_board, i, j, word):\\n\\t\\t\\t\\t\\t\\t\\tif word not in res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres.append(word)\\n\\t\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939445,
                "title": "c-fast-95-just-dfs",
                "content": "\\tpublic class Solution \\n\\t{\\n\\t\\tpublic IList<string> FindWords(char[][] board, string[] words) \\n\\t\\t{\\n\\t\\t\\tvar res = new List<string>();\\n\\n\\t\\t\\tforeach(var word in words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar found = false;\\n\\t\\t\\t\\tfor (var i = 0; i < board.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (var j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t   if ( board[i][j] == word[0] && Dfs(i,j,word, 0))\\n\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\tres.Add(word);\\n\\t\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (found == true) break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t\\tbool Dfs(int i, int j, string word, int start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (start == word.Length) return true;\\n\\n\\t\\t\\t\\t if (i < 0 || i >= board.Length || j < 0 || j >= board[i].Length \\n\\t\\t\\t\\t\\t || board[i][j] != word[start])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tboard[i][j] = \\'#\\';\\n\\t\\t\\t\\tvar result = Dfs(i - 1, j, word, start + 1)\\n\\t\\t\\t\\t\\t\\t\\t|| Dfs(i + 1, j, word, start + 1)\\n\\t\\t\\t\\t\\t\\t\\t|| Dfs(i, j + 1, word, start + 1)\\n\\t\\t\\t\\t\\t\\t\\t|| Dfs(i, j - 1, word, start + 1);\\n\\t\\t\\t\\tboard[i][j] = word[start];\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic IList<string> FindWords(char[][] board, string[] words) \\n\\t\\t{\\n\\t\\t\\tvar res = new List<string>();\\n\\n\\t\\t\\tforeach(var word in words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar found = false;\\n\\t\\t\\t\\tfor (var i = 0; i < board.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (var j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t   if ( board[i][j] == word[0] && Dfs(i,j,word, 0))\\n\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\tres.Add(word);\\n\\t\\t\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 803052,
                "title": "easy-to-understand-python-3-solution-with-backtracking-trie",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.word = \"\"\\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board) == 0 or not words or len(words) == 0:\\n            return []\\n        \\n        root = TrieNode()\\n        \\n        for word in words:\\n            temp = root\\n            for letter in word:\\n                if letter in temp.children:\\n                    temp = temp.children[letter]\\n                else:\\n                    currWord = temp.word\\n                    temp.children[letter] = TrieNode()\\n                    temp = temp.children[letter]\\n                    temp.word = currWord + letter\\n            temp.isWord = True\\n        res = []\\n        \\n        def backtrack(r, c, node):\\n            if node.isWord:\\n                res.append(node.word)\\n                node.isWord = False\\n            if r < 0 or r > len(board)-1 or c < 0 or c > len(board[r])-1:\\n                return\\n            if board[r][c] not in node.children:\\n                return\\n            \\n            tmpLetter = board[r][c]\\n            board[r][c] = \\'$\\'\\n            backtrack(r+1, c, node.children[tmpLetter])\\n            backtrack(r-1, c, node.children[tmpLetter])\\n            backtrack(r, c+1, node.children[tmpLetter])\\n            backtrack(r, c-1, node.children[tmpLetter])\\n            board[r][c] = tmpLetter\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c] in root.children:\\n                    backtrack(r, c, root)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.word = \"\"\\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board or len(board) == 0 or not words or len(words) == 0:\\n            return []\\n        \\n        root = TrieNode()\\n        \\n        for word in words:\\n            temp = root\\n            for letter in word:\\n                if letter in temp.children:\\n                    temp = temp.children[letter]\\n                else:\\n                    currWord = temp.word\\n                    temp.children[letter] = TrieNode()\\n                    temp = temp.children[letter]\\n                    temp.word = currWord + letter\\n            temp.isWord = True\\n        res = []\\n        \\n        def backtrack(r, c, node):\\n            if node.isWord:\\n                res.append(node.word)\\n                node.isWord = False\\n            if r < 0 or r > len(board)-1 or c < 0 or c > len(board[r])-1:\\n                return\\n            if board[r][c] not in node.children:\\n                return\\n            \\n            tmpLetter = board[r][c]\\n            board[r][c] = \\'$\\'\\n            backtrack(r+1, c, node.children[tmpLetter])\\n            backtrack(r-1, c, node.children[tmpLetter])\\n            backtrack(r, c+1, node.children[tmpLetter])\\n            backtrack(r, c-1, node.children[tmpLetter])\\n            board[r][c] = tmpLetter\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c] in root.children:\\n                    backtrack(r, c, root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713181,
                "title": "simple-to-understand-java-solution-bactracking-trie-explanation",
                "content": "Video Explanation:\\n[Word Search II](https://www.youtube.com/watch?v=ZoMJbbYTWUo)\\n\\nThis question is basically asking you how to **stop before your recursion goes too far**. Therefore, a ***Trie structure*** would be perfect to do the job. After implementing the Trie structure all you need to do is to do a dfs of the grid, if the prefix doesn\\'t match during the recursion, then return. If it does, keep going until it finds the word, or it starts to not match. Other than understanding and implementing this concept, this quesion is relatively easy to do. Below, I implemented a Trie structure and did a search of the grid to find the words.\\n\\n```\\nclass Trie {\\n    Set<String> word;\\n    Set<String> pre;\\n    public Trie() {\\n        word = new HashSet<>();\\n        pre = new HashSet<>();\\n    }\\n\\n    public void insert(String word) {\\n        this.word.add(word);\\n        for(int i = 0; i<=word.length(); i++){\\n            pre.add(word.substring(0, i));\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        return this.word.contains(word);\\n    }\\n\\n    public boolean startsWith(String prefix) {\\n        return pre.contains(prefix);\\n    }\\n}\\n\\nclass Solution {\\n    Trie prefix = new Trie();\\n    char[][] gBoard;\\n    Set<String> rep = new HashSet<>();\\n    List<String> res = new ArrayList<>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        gBoard = board;\\n        for(int i = 0; i<words.length; i++){\\n            prefix.insert(words[i]);\\n        }\\n        for(int i = 0; i<board.length; i++){\\n            for(int j = 0; j<board[0].length; j++){\\n                if(prefix.startsWith(board[i][j]+\"\")){\\n                    dfs(i, j, \"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int i, int j, String store){\\n        if(i < 0 || j < 0 || j>=gBoard[0].length || i >= gBoard.length){\\n            return ;\\n        }\\n        if(gBoard[i][j] == \\'A\\'){\\n            return ;\\n        }\\n        if(!prefix.startsWith(store)){\\n            return ;\\n        }\\n        store += gBoard[i][j]+\"\";\\n        if(prefix.search(store) && !rep.contains(store)){\\n            res.add(store);\\n            rep.add(store);\\n        }\\n        char temp = gBoard[i][j];\\n        \\n        gBoard[i][j] = \\'A\\';\\n        dfs(i, j-1, store);\\n        dfs(i, j+1, store);\\n        dfs(i-1, j, store);\\n        dfs(i+1, j, store);\\n        gBoard[i][j] = temp;\\n        store = store.substring(0, store.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    Set<String> word;\\n    Set<String> pre;\\n    public Trie() {\\n        word = new HashSet<>();\\n        pre = new HashSet<>();\\n    }\\n\\n    public void insert(String word) {\\n        this.word.add(word);\\n        for(int i = 0; i<=word.length(); i++){\\n            pre.add(word.substring(0, i));\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        return this.word.contains(word);\\n    }\\n\\n    public boolean startsWith(String prefix) {\\n        return pre.contains(prefix);\\n    }\\n}\\n\\nclass Solution {\\n    Trie prefix = new Trie();\\n    char[][] gBoard;\\n    Set<String> rep = new HashSet<>();\\n    List<String> res = new ArrayList<>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        gBoard = board;\\n        for(int i = 0; i<words.length; i++){\\n            prefix.insert(words[i]);\\n        }\\n        for(int i = 0; i<board.length; i++){\\n            for(int j = 0; j<board[0].length; j++){\\n                if(prefix.startsWith(board[i][j]+\"\")){\\n                    dfs(i, j, \"\");\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int i, int j, String store){\\n        if(i < 0 || j < 0 || j>=gBoard[0].length || i >= gBoard.length){\\n            return ;\\n        }\\n        if(gBoard[i][j] == \\'A\\'){\\n            return ;\\n        }\\n        if(!prefix.startsWith(store)){\\n            return ;\\n        }\\n        store += gBoard[i][j]+\"\";\\n        if(prefix.search(store) && !rep.contains(store)){\\n            res.add(store);\\n            rep.add(store);\\n        }\\n        char temp = gBoard[i][j];\\n        \\n        gBoard[i][j] = \\'A\\';\\n        dfs(i, j-1, store);\\n        dfs(i, j+1, store);\\n        dfs(i-1, j, store);\\n        dfs(i+1, j, store);\\n        gBoard[i][j] = temp;\\n        store = store.substring(0, store.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712869,
                "title": "c-using-backtracking-and-trie-data-structure-concise-code-and-well-commented",
                "content": "```\\nstruct TrieNode {\\n    unordered_map<char, TrieNode *> dict;   // hold mapping between character and child TrieNode\\n    bool endOfWord;                         // marks end of word\\n    string word;                            // holds complete word when marked as end\\n    TrieNode(): endOfWord(false) {}\\n};\\n\\nclass Solution {    \\npublic:\\n    // build trie data structure from words to search\\n    TrieNode *buildTrie(vector<string> words) {\\n        TrieNode *root = new TrieNode();\\n        // for each word in dictionary\\n        for(string w: words) {\\n            TrieNode *node = root;\\n            // iteratively populate trie nodes\\n            for(char c: w) {\\n                // if character does not exist in map of current trie node\\n                if(node->dict.empty() || node->dict.find(c) == node->dict.end()) {\\n                    node->dict.insert({c, new TrieNode});   // add character with new child trie node\\n                }\\n                node = node->dict[c];   // move trie node pointer to child node\\n            }\\n            node->endOfWord = true;     // mark node as end of word\\n            node->word = w;             // store complete word in that node\\n        }\\n        return root;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *root = buildTrie(words);      // returns root of trie data structure after building\\n        \\n        int m = board.size(), n = board[0].size();\\n        set<string> s;      // store found words in set to avoid duplicates\\n        // for each cell of the board recursively check if character is present in trie nodes\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dfs(board, root, i, j, s);\\n            }\\n        }\\n            \\n        // throw every found word in vector and return\\n        vector<string> res;\\n        for(string word: s)     res.push_back(word);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>> &board, TrieNode *node, int i, int j, set<string> &s) {\\n        // handles out of bounds or if board character is not present in trie node\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || node->dict.find(board[i][j]) == node->dict.end())     return;\\n        \\n        // if current board character is found in trie node move node control to child of that character\\n        node = node->dict[board[i][j]];      \\n        if(node->endOfWord)     s.insert(node->word);   // check if node is marked as end of word and push word stored in that node to set of found words\\n        \\n        char c = board[i][j];   // store cell temporarily\\n        board[i][j] = \\' \\';      // mark cell as visited by invalidating\\n        \\n        // recursively check if characters to the up, right, down or left of current board character can be included in words to search\\n        dfs(board, node, i-1, j, s);\\n        dfs(board, node, i, j+1, s);\\n        dfs(board, node, i+1, j, s);\\n        dfs(board, node, i, j-1, s);\\n        \\n        board[i][j] = c;        // undo/backtrack changes to cell\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode {\\n    unordered_map<char, TrieNode *> dict;   // hold mapping between character and child TrieNode\\n    bool endOfWord;                         // marks end of word\\n    string word;                            // holds complete word when marked as end\\n    TrieNode(): endOfWord(false) {}\\n};\\n\\nclass Solution {    \\npublic:\\n    // build trie data structure from words to search\\n    TrieNode *buildTrie(vector<string> words) {\\n        TrieNode *root = new TrieNode();\\n        // for each word in dictionary\\n        for(string w: words) {\\n            TrieNode *node = root;\\n            // iteratively populate trie nodes\\n            for(char c: w) {\\n                // if character does not exist in map of current trie node\\n                if(node->dict.empty() || node->dict.find(c) == node->dict.end()) {\\n                    node->dict.insert({c, new TrieNode});   // add character with new child trie node\\n                }\\n                node = node->dict[c];   // move trie node pointer to child node\\n            }\\n            node->endOfWord = true;     // mark node as end of word\\n            node->word = w;             // store complete word in that node\\n        }\\n        return root;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *root = buildTrie(words);      // returns root of trie data structure after building\\n        \\n        int m = board.size(), n = board[0].size();\\n        set<string> s;      // store found words in set to avoid duplicates\\n        // for each cell of the board recursively check if character is present in trie nodes\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dfs(board, root, i, j, s);\\n            }\\n        }\\n            \\n        // throw every found word in vector and return\\n        vector<string> res;\\n        for(string word: s)     res.push_back(word);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>> &board, TrieNode *node, int i, int j, set<string> &s) {\\n        // handles out of bounds or if board character is not present in trie node\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || node->dict.find(board[i][j]) == node->dict.end())     return;\\n        \\n        // if current board character is found in trie node move node control to child of that character\\n        node = node->dict[board[i][j]];      \\n        if(node->endOfWord)     s.insert(node->word);   // check if node is marked as end of word and push word stored in that node to set of found words\\n        \\n        char c = board[i][j];   // store cell temporarily\\n        board[i][j] = \\' \\';      // mark cell as visited by invalidating\\n        \\n        // recursively check if characters to the up, right, down or left of current board character can be included in words to search\\n        dfs(board, node, i-1, j, s);\\n        dfs(board, node, i, j+1, s);\\n        dfs(board, node, i+1, j, s);\\n        dfs(board, node, i, j-1, s);\\n        \\n        board[i][j] = c;        // undo/backtrack changes to cell\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654563,
                "title": "pure-evil-test-case",
                "content": "It should probably be illegal to have a test case like :\\n```\\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\\n[\"aaaaaaaaaaaa\",\"aaaaaaaaaaaaa\",\"aaaaaaaaaaab\"]\\n```\\n\\nSome of us have families you know. \\n\\nBut in all seriousness, is it a big red flag if I could not think about this test case on my own and had to rely on WA solution to find it?",
                "solutionTags": [],
                "code": "```\\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\\n[\"aaaaaaaaaaaa\",\"aaaaaaaaaaaaa\",\"aaaaaaaaaaab\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 428405,
                "title": "intuitive-python-solution-trie-backtrack-97",
                "content": "```python\\nclass Trie:\\n    WORD = \\'\\' # use empty string to mark end of a word\\n    \\n    def __init__(self):\\n        self.root = {}\\n\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        for char in word:\\n            if char not in node:\\n                node[char] = {}\\n            node = node[char]\\n        node[self.WORD] = word # save the word itself to node[\\'\\']\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        results = set()\\n        m = len(board)    \\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n            \\n        def backtrack(i: int, j: int, node: dict) -> None:\\n            char = board[i][j]\\n            if char not in node:\\n                return\\n            \\n            node = node[char]\\n            if trie.WORD in node:\\n                results.add(node[trie.WORD]) # node[\\'\\'] contains the word\\n\\n            board[i][j] = None\\n            if i > 0:\\n                backtrack(i-1, j, node)\\n            if i < m - 1:\\n                backtrack(i+1, j, node)\\n            if j > 0:\\n                backtrack(i, j-1, node)\\n            if j < n - 1:\\n                backtrack(i, j+1, node)\\n            board[i][j] = char\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(i, j, trie.root)\\n                \\n        return results\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Trie:\\n    WORD = \\'\\' # use empty string to mark end of a word\\n    \\n    def __init__(self):\\n        self.root = {}\\n\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        for char in word:\\n            if char not in node:\\n                node[char] = {}\\n            node = node[char]\\n        node[self.WORD] = word # save the word itself to node[\\'\\']\\n        \\n        \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        results = set()\\n        m = len(board)    \\n        n = len(board[0])\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n            \\n        def backtrack(i: int, j: int, node: dict) -> None:\\n            char = board[i][j]\\n            if char not in node:\\n                return\\n            \\n            node = node[char]\\n            if trie.WORD in node:\\n                results.add(node[trie.WORD]) # node[\\'\\'] contains the word\\n\\n            board[i][j] = None\\n            if i > 0:\\n                backtrack(i-1, j, node)\\n            if i < m - 1:\\n                backtrack(i+1, j, node)\\n            if j > 0:\\n                backtrack(i, j-1, node)\\n            if j < n - 1:\\n                backtrack(i, j+1, node)\\n            board[i][j] = char\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                backtrack(i, j, trie.root)\\n                \\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303250,
                "title": "c-faster-than-96-dfs-trie-with-comments",
                "content": "* Build a trie from the dictionary\\n* Starting from each cell, recursively visit all neighbors, check the next symbol in the trie\\n\\n```\\n    struct TrieNode{\\n        bool word = false;\\n        vector<TrieNode*> nodes = vector<TrieNode*>(26);\\n    };    \\n    \\n\\t// visit every adjansent cell, checking that the next symbol exists in trie\\n    void visit(vector<vector<char>>& board, \\n               TrieNode* node, \\n               int i, int j, \\n               string& word, \\n               vector<bool>& visited,\\n               unordered_set<string>& result)\\n    {\\n        int h = board.size();\\n        int w = board[0].size();\\n        if (i<0||j<0||i>=h||j>=w||visited[i*w+j]||!node->nodes[ board[i][j]-\\'a\\' ])\\n            return;\\n        \\n        visited[i*w+j] = true;\\n        word += board[i][j];\\n        \\n        node = node->nodes[board[i][j]-\\'a\\'];\\n        \\n        if (node->word)\\n            result.insert(word);\\n        \\n        visit(board, node, i+1, j, word, visited, result);\\n        visit(board, node, i-1, j, word, visited, result);\\n        visit(board, node, i, j+1, word, visited, result);\\n        visit(board, node, i, j-1, word, visited, result);\\n        \\n        word.pop_back();\\n        visited[i*w+j] = false;\\n    }\\n\\n\\t// buid trie data structure recursively \\n    void trie_insert_word(TrieNode* node, const char* word){\\n        if (!*word)\\n            node->word = true;\\n        else{\\n            int pos = *word-\\'a\\';\\n            if (!node->nodes[pos])\\n                node->nodes[pos] = new TrieNode;\\n\\n            trie_insert_word(node->nodes[pos], word+1);\\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        if (board.empty()||board[0].empty())\\n            return vector<string>();        \\n        \\n        TrieNode root;\\n        for (string& s: words)\\n            trie_insert_word(&root, s.c_str());\\n        \\n\\t\\t// visit every board cell and run dfs\\n        unordered_set<string> result;\\n        string word;\\n        vector<bool> visited(board.size()*board[0].size());\\n        for (int i=0;i<board.size();++i)\\n            for (int j=0;j<board[0].size();++j)\\n                visit(board, &root, i, j, word, visited, result);\\n        \\n        return vector<string>(result.begin(), result.end());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    struct TrieNode{\\n        bool word = false;\\n        vector<TrieNode*> nodes = vector<TrieNode*>(26);\\n    };    \\n    \\n\\t// visit every adjansent cell, checking that the next symbol exists in trie\\n    void visit(vector<vector<char>>& board, \\n               TrieNode* node, \\n               int i, int j, \\n               string& word, \\n               vector<bool>& visited,\\n               unordered_set<string>& result)\\n    {\\n        int h = board.size();\\n        int w = board[0].size();\\n        if (i<0||j<0||i>=h||j>=w||visited[i*w+j]||!node->nodes[ board[i][j]-\\'a\\' ])\\n            return;\\n        \\n        visited[i*w+j] = true;\\n        word += board[i][j];\\n        \\n        node = node->nodes[board[i][j]-\\'a\\'];\\n        \\n        if (node->word)\\n            result.insert(word);\\n        \\n        visit(board, node, i+1, j, word, visited, result);\\n        visit(board, node, i-1, j, word, visited, result);\\n        visit(board, node, i, j+1, word, visited, result);\\n        visit(board, node, i, j-1, word, visited, result);\\n        \\n        word.pop_back();\\n        visited[i*w+j] = false;\\n    }\\n\\n\\t// buid trie data structure recursively \\n    void trie_insert_word(TrieNode* node, const char* word){\\n        if (!*word)\\n            node->word = true;\\n        else{\\n            int pos = *word-\\'a\\';\\n            if (!node->nodes[pos])\\n                node->nodes[pos] = new TrieNode;\\n\\n            trie_insert_word(node->nodes[pos], word+1);\\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        if (board.empty()||board[0].empty())\\n            return vector<string>();        \\n        \\n        TrieNode root;\\n        for (string& s: words)\\n            trie_insert_word(&root, s.c_str());\\n        \\n\\t\\t// visit every board cell and run dfs\\n        unordered_set<string> result;\\n        string word;\\n        vector<bool> visited(board.size()*board[0].size());\\n        for (int i=0;i<board.size();++i)\\n            for (int j=0;j<board[0].size();++j)\\n                visit(board, &root, i, j, word, visited, result);\\n        \\n        return vector<string>(result.begin(), result.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295076,
                "title": "c-trie-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new HashSet<string>();\\n        var n = board.Length;\\n        if (n == 0) return new List<string>();\\n        var m = board[0].Length;\\n\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n\\n        var isVisited = new bool[n, m];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                var index = board[i][j] - \\'a\\';\\n                if (trie.root.nodes[index] != null) {\\n                    DFS(i, j, trie.root, board, isVisited, result);\\n                }\\n            }\\n        }\\n\\n        return result.ToList();\\n    }\\n\\n    private void DFS(int x, int y, TrieNode node, char[][] board, bool[,] isVisited, HashSet<string> result) {\\n        var n = board.Length;\\n        var m = board[0].Length;\\n\\n        if (node.isWord) {\\n            result.Add(node.word);\\n        }\\n\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n        if (isVisited[x, y]) return;\\n        var index = board[x][y] - \\'a\\';\\n        if (node.nodes[index] == null) return;\\n\\n        var next = node.nodes[index];\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(nextX, nextY, next, board, isVisited, result);\\n        }\\n\\n        isVisited[x, y] = false;\\n    }\\n}\\n\\nclass Trie {\\n\\n    public TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    public void Insert(string word) {\\n        var n = word.Length;\\n        TrieNode curNode = root;\\n        for (int i = 0; i < n; i++) {\\n            var index = word[i] - \\'a\\';\\n            if (curNode.nodes[index] == null) {\\n                curNode.nodes[index] = new TrieNode();\\n            }\\n            curNode = curNode.nodes[index];\\n\\n            if (i == n - 1) {\\n                curNode.isWord = true;\\n                curNode.word = word;\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    public TrieNode[] nodes;\\n    public bool isWord;\\n    public string word;\\n\\n    public TrieNode() {\\n        nodes = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindWords(char[][] board, string[] words) {\\n        var result = new HashSet<string>();\\n        var n = board.Length;\\n        if (n == 0) return new List<string>();\\n        var m = board[0].Length;\\n\\n        var trie = new Trie();\\n        foreach (var word in words) {\\n            trie.Insert(word);\\n        }\\n\\n        var isVisited = new bool[n, m];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                var index = board[i][j] - \\'a\\';\\n                if (trie.root.nodes[index] != null) {\\n                    DFS(i, j, trie.root, board, isVisited, result);\\n                }\\n            }\\n        }\\n\\n        return result.ToList();\\n    }\\n\\n    private void DFS(int x, int y, TrieNode node, char[][] board, bool[,] isVisited, HashSet<string> result) {\\n        var n = board.Length;\\n        var m = board[0].Length;\\n\\n        if (node.isWord) {\\n            result.Add(node.word);\\n        }\\n\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n        if (isVisited[x, y]) return;\\n        var index = board[x][y] - \\'a\\';\\n        if (node.nodes[index] == null) return;\\n\\n        var next = node.nodes[index];\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(nextX, nextY, next, board, isVisited, result);\\n        }\\n\\n        isVisited[x, y] = false;\\n    }\\n}\\n\\nclass Trie {\\n\\n    public TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    public void Insert(string word) {\\n        var n = word.Length;\\n        TrieNode curNode = root;\\n        for (int i = 0; i < n; i++) {\\n            var index = word[i] - \\'a\\';\\n            if (curNode.nodes[index] == null) {\\n                curNode.nodes[index] = new TrieNode();\\n            }\\n            curNode = curNode.nodes[index];\\n\\n            if (i == n - 1) {\\n                curNode.isWord = true;\\n                curNode.word = word;\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    public TrieNode[] nodes;\\n    public bool isWord;\\n    public string word;\\n\\n    public TrieNode() {\\n        nodes = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248096,
                "title": "javascript-using-dfs-and-trie-beats-100",
                "content": "\\n\\n```javascript\\nvar findWords = function(board, words) {\\n    const ans = [];\\n    \\n    if (!board || !words || board.length < 1) return [];\\n    \\n    const root = buildTrie(words);\\n    \\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            dfs(board, i, j, root, ans);\\n        }\\n    }\\n    \\n    return ans;\\n};\\n\\nfunction dfs(board, i, j, trie, ans) {\\n    const w = board[i][j];\\n    \\n    if (!trie.children.has(w)) return;\\n    \\n    trie = trie.children.get(w);\\n    \\n    if (trie.word) {\\n        ans.push(trie.word);\\n        trie.word = null;\\n    }\\n    \\n    board[i][j] = \\'#\\';\\n    if (i > 0) dfs(board, i - 1, j, trie, ans); \\n    if (j > 0) dfs(board, i, j - 1, trie, ans);\\n    if (i < board.length - 1) dfs(board, i + 1, j, trie, ans); \\n    if (j < board[0].length - 1) dfs(board, i, j + 1, trie, ans); \\n    board[i][j] = w;\\n}\\n\\nfunction buildTrie(words) {\\n    const root = new TrieNode();\\n    \\n    words.forEach(w => {\\n        let node = root;\\n        \\n        for (let i = 0; i < w.length; i++) {\\n            let c = w[i];\\n            \\n            if (!node.children.has(c)) node.children.set(c, new TrieNode());\\n\\n            node = node.children.get(c);\\n        }\\n        \\n         node.word = w;\\n    })\\n    \\n    return root;\\n}\\n\\nclass TrieNode {\\n    constructor() {\\n        this.word = null;\\n        this.children = new Map();\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```javascript\\nvar findWords = function(board, words) {\\n    const ans = [];\\n    \\n    if (!board || !words || board.length < 1) return [];\\n    \\n    const root = buildTrie(words);\\n    \\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board[0].length; j++) {\\n            dfs(board, i, j, root, ans);\\n        }\\n    }\\n    \\n    return ans;\\n};\\n\\nfunction dfs(board, i, j, trie, ans) {\\n    const w = board[i][j];\\n    \\n    if (!trie.children.has(w)) return;\\n    \\n    trie = trie.children.get(w);\\n    \\n    if (trie.word) {\\n        ans.push(trie.word);\\n        trie.word = null;\\n    }\\n    \\n    board[i][j] = \\'#\\';\\n    if (i > 0) dfs(board, i - 1, j, trie, ans); \\n    if (j > 0) dfs(board, i, j - 1, trie, ans);\\n    if (i < board.length - 1) dfs(board, i + 1, j, trie, ans); \\n    if (j < board[0].length - 1) dfs(board, i, j + 1, trie, ans); \\n    board[i][j] = w;\\n}\\n\\nfunction buildTrie(words) {\\n    const root = new TrieNode();\\n    \\n    words.forEach(w => {\\n        let node = root;\\n        \\n        for (let i = 0; i < w.length; i++) {\\n            let c = w[i];\\n            \\n            if (!node.children.has(c)) node.children.set(c, new TrieNode());\\n\\n            node = node.children.get(c);\\n        }\\n        \\n         node.word = w;\\n    })\\n    \\n    return root;\\n}\\n\\nclass TrieNode {\\n    constructor() {\\n        this.word = null;\\n        this.children = new Map();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193926,
                "title": "concise-python-with-trie-and-dfs",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self, is_leaf = False):\\n        self.children = dict()\\n        self.is_leaf = is_leaf\\n        \\n    def add_s(self, s):\\n        curr = self\\n        for c in s:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            curr = curr.children[c]\\n        curr.is_leaf = True\\n    \\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        trie_root = TrieNode()\\n        for w in words:\\n            trie_root.add_s(w)\\n            \\n        result = set()\\n\\n        height = len(board)\\n        width = len(board[0])\\n        \\n        def go(i, j, node, word):\\n            \\n            if node.is_leaf:\\n                result.add(word)\\n                \\n            if i < 0 or i >= height or j < 0 or j >= width:\\n                return \\n            \\n            if board[i][j] in node.children:\\n                c = board[i][j]\\n                board[i][j] = \\'-\\'\\n                go(i + 1, j, node.children[c], word + c)\\n                go(i - 1, j, node.children[c], word + c)\\n                go(i, j + 1, node.children[c], word + c)\\n                go(i, j - 1, node.children[c], word + c)\\n                board[i][j] = c\\n            \\n            if word == \\'\\':\\n                go(i, j + 1, node, word) if j + 1 < width else go(i + 1, 0, node, word)\\n            \\n        go(0, 0, trie_root, \\'\\')    \\n        \\n        return list(result)\\n    \\n            \\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self, is_leaf = False):\\n        self.children = dict()\\n        self.is_leaf = is_leaf\\n        \\n    def add_s(self, s):\\n        curr = self\\n        for c in s:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            curr = curr.children[c]\\n        curr.is_leaf = True\\n    \\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        trie_root = TrieNode()\\n        for w in words:\\n            trie_root.add_s(w)\\n            \\n        result = set()\\n\\n        height = len(board)\\n        width = len(board[0])\\n        \\n        def go(i, j, node, word):\\n            \\n            if node.is_leaf:\\n                result.add(word)\\n                \\n            if i < 0 or i >= height or j < 0 or j >= width:\\n                return \\n            \\n            if board[i][j] in node.children:\\n                c = board[i][j]\\n                board[i][j] = \\'-\\'\\n                go(i + 1, j, node.children[c], word + c)\\n                go(i - 1, j, node.children[c], word + c)\\n                go(i, j + 1, node.children[c], word + c)\\n                go(i, j - 1, node.children[c], word + c)\\n                board[i][j] = c\\n            \\n            if word == \\'\\':\\n                go(i, j + 1, node, word) if j + 1 < width else go(i + 1, 0, node, word)\\n            \\n        go(0, 0, trie_root, \\'\\')    \\n        \\n        return list(result)\\n    \\n            \\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59808,
                "title": "python-dfs-362ms",
                "content": "Used the quick and dirty trie building from here: Re: Python code use trie and dfs 380ms\\n\\nMain difference is I exit out of the current recursive call by checking if the following \"Trie Node\" is empty.\\n\\nImproved performance slightly.\\n\\n```\\nclass Solution(object):\\n    def checkList(self, board, row, col, word, trie, rList):\\n        if row<0 or row>=len(board) or col<0 or col>=len(board[0]) or board[row][col] == '.' or board[row][col] not in trie: return\\n        c = board[row][col]\\n        _word= word + c\\n        if '#' in trie[c]: \\n            rList.add(_word)\\n            if len(trie[c]) == 1: return # if next node is empty, return as no there is no need to search further\\n        board[row][col] = '.'\\n        self.checkList(board, row-1, col, _word, trie[c], rList) #up\\n        self.checkList(board, row+1, col, _word, trie[c], rList) #down\\n        self.checkList(board, row, col-1, _word, trie[c], rList) #left\\n        self.checkList(board, row, col+1, _word, trie[c], rList) #right\\n        board[row][col] = c\\n    \\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        # building Trie\\n        trie, rList = {}, set()\\n        for word in words:\\n            t = trie\\n            for c in word:\\n                if c not in t: t[c] = {}\\n                t = t[c]\\n            t['#'] = None\\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                if board[row][col] not in trie: continue\\n                self.checkList(board, row, col, \"\", trie, rList)\\n        return list(rList)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkList(self, board, row, col, word, trie, rList):\\n        if row<0 or row>=len(board) or col<0 or col>=len(board[0]) or board[row][col] == '.' or board[row][col] not in trie: return\\n        c = board[row][col]\\n        _word= word + c\\n        if '#' in trie[c]: \\n            rList.add(_word)\\n            if len(trie[c]) == 1: return # if next node is empty, return as no there is no need to search further\\n        board[row][col] = '.'\\n        self.checkList(board, row-1, col, _word, trie[c], rList) #up\\n        self.checkList(board, row+1, col, _word, trie[c], rList) #down\\n        self.checkList(board, row, col-1, _word, trie[c], rList) #left\\n        self.checkList(board, row, col+1, _word, trie[c], rList) #right\\n        board[row][col] = c\\n    \\n    def findWords(self, board, words):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not board or not words: return []\\n        # building Trie\\n        trie, rList = {}, set()\\n        for word in words:\\n            t = trie\\n            for c in word:\\n                if c not in t: t[c] = {}\\n                t = t[c]\\n            t['#'] = None\\n        for row in range(len(board)):\\n            for col in range(len(board[0])):\\n                if board[row][col] not in trie: continue\\n                self.checkList(board, row, col, \"\", trie, rList)\\n        return list(rList)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475805,
                "title": "java-solution-for-word-search-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find all the words in the given words list that can be formed using the letters present on the given board matrix. We can use the Trie data structure to efficiently search for words in the given board\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in the solution is to first build a Trie using the words list, and then perform a depth-first search (DFS) on the board matrix to find all the valid words.\\n\\nThe Trie data structure is built using the insert function, which inserts a word into the Trie by creating a new node for each character in the word. The search function checks if a given word exists in the Trie by traversing the Trie and checking if the end node of the word contains the word itself. The startsWith function checks if a given prefix exists in the Trie by traversing the Trie until the end of the prefix.\\n\\nThe findWords function initializes an empty set result, builds the Trie using the words list, and initializes a boolean matrix visited to keep track of the visited cells in the board matrix. It then performs a DFS on each cell in the board matrix, starting with an empty string str, and checks if the current prefix str exists in the Trie. If it does, it checks if str is a valid word by checking if the end node of str contains the word itself. If it is a valid word, it adds str to the result set. Finally, it marks the current cell as visited, and recursively performs DFS on its neighboring cells, adding the current cell\\'s character to the str prefix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M(4\\u22C53^(L\\u22121))), where M is the number of cells in the board, L is the maximum length of a word, and 4\\u22C53^(L\\u22121) is the maximum number of child nodes in the Trie\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(N), where N is the total number of characters in the words list, which is used to build the Trie.\\n\\n# Code\\n```\\nclass Solution {\\n    Set<String> result = new HashSet<String>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        //HashSet<String> result = new HashSet<String>();\\n        Trie trie = new Trie();\\n        for(String word: words)\\n        {\\n            trie.insert(word);\\n        }\\n        int m=board.length;\\n        int n=board[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                dfs(board, visited, \"\", i, j, trie);\\n            }\\n        }\\n        return new ArrayList<String>(result);\\n    }\\n    public void dfs(char[][] board, boolean[][] visited, String str, int i, int j, Trie trie)\\n    {\\n        int m=board.length;\\n        int n=board[0].length;\\n        if(i<0 || j<0||i>=m||j>=n)\\n        {\\n            return;\\n        }\\n        if(visited[i][j])\\n            return;\\n        str = str + board[i][j];\\n        if(!trie.startsWith(str))\\n            return;\\n        if(trie.search(str))\\n        {\\n            result.add(str);\\n        }\\n        visited[i][j]=true;\\n        dfs(board, visited, str, i-1, j, trie);\\n        dfs(board, visited, str, i+1, j, trie);\\n        dfs(board, visited, str, i, j-1, trie);\\n        dfs(board, visited, str, i, j+1, trie);\\n        visited[i][j]=false;\\n    }\\n}\\nclass TrieNode\\n{\\n    public TrieNode[] children = new TrieNode[26];\\n    public String item = \"\";\\n}\\n//Trie\\nclass Trie\\n{\\n    public TrieNode root = new TrieNode();\\n    public void insert(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            {\\n                node.children[c-\\'a\\']= new TrieNode();\\n            }\\n            node = node.children[c-\\'a\\'];\\n        }\\n        node.item = word;\\n    }\\n    public boolean search(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n                return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        if(node.item.equals(word))\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public boolean startsWith(String prefix)\\n    {\\n        TrieNode node = root;\\n        for(char c: prefix.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<String> result = new HashSet<String>();\\n    public List<String> findWords(char[][] board, String[] words) {\\n        //HashSet<String> result = new HashSet<String>();\\n        Trie trie = new Trie();\\n        for(String word: words)\\n        {\\n            trie.insert(word);\\n        }\\n        int m=board.length;\\n        int n=board[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                dfs(board, visited, \"\", i, j, trie);\\n            }\\n        }\\n        return new ArrayList<String>(result);\\n    }\\n    public void dfs(char[][] board, boolean[][] visited, String str, int i, int j, Trie trie)\\n    {\\n        int m=board.length;\\n        int n=board[0].length;\\n        if(i<0 || j<0||i>=m||j>=n)\\n        {\\n            return;\\n        }\\n        if(visited[i][j])\\n            return;\\n        str = str + board[i][j];\\n        if(!trie.startsWith(str))\\n            return;\\n        if(trie.search(str))\\n        {\\n            result.add(str);\\n        }\\n        visited[i][j]=true;\\n        dfs(board, visited, str, i-1, j, trie);\\n        dfs(board, visited, str, i+1, j, trie);\\n        dfs(board, visited, str, i, j-1, trie);\\n        dfs(board, visited, str, i, j+1, trie);\\n        visited[i][j]=false;\\n    }\\n}\\nclass TrieNode\\n{\\n    public TrieNode[] children = new TrieNode[26];\\n    public String item = \"\";\\n}\\n//Trie\\nclass Trie\\n{\\n    public TrieNode root = new TrieNode();\\n    public void insert(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            {\\n                node.children[c-\\'a\\']= new TrieNode();\\n            }\\n            node = node.children[c-\\'a\\'];\\n        }\\n        node.item = word;\\n    }\\n    public boolean search(String word)\\n    {\\n        TrieNode node = root;\\n        for(char c: word.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n                return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        if(node.item.equals(word))\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public boolean startsWith(String prefix)\\n    {\\n        TrieNode node = root;\\n        for(char c: prefix.toCharArray())\\n        {\\n            if(node.children[c-\\'a\\']==null)\\n            return false;\\n            node = node.children[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309961,
                "title": "easy-to-understand-code-trie-and-dfs",
                "content": "```\\nstruct Node{\\n    Node* trie[26];\\n    bool flag = false;\\n    \\n    bool containsChar(char c){\\n        if(c ==\\'0\\') return false;\\n        return trie[c-\\'a\\'] != NULL;\\n    }\\n    \\n    void addNewChar(char c, Node* ref){\\n        trie[c-\\'a\\'] = ref;\\n    }\\n    Node* getToNode(char c){\\n        return trie[c-\\'a\\'];\\n    }\\n    \\n    void setEnd(){\\n        flag = true;\\n    }\\n    void resetEnd(){\\n        flag = false;\\n    }\\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void insert(string word, Node* root) {\\n        Node *head = root;\\n        int n = word.length();\\n        for(int i = 0; i < n; i++){\\n            if(!head->containsChar(word[i]))\\n                head->addNewChar(word[i], new Node());\\n            head = head->getToNode(word[i]);\\n        }\\n        head->setEnd();\\n    }\\n    \\n    vector<string>ans;\\n    void f(vector<vector<char>>& board, int i, int j, int m, int n, string s, Node* trie)\\n    {\\n        if(i < 0 || i >= m || j < 0 || j >= n || board[i][j] == \\'0\\') return;\\n        \\n        s += board[i][j];\\n        if(trie->containsChar(board[i][j]))\\n        {\\n            char temp = board[i][j];\\n            trie = trie->getToNode(temp);\\n            if(trie->isEnd()){\\n                ans.emplace_back(s);\\n                trie->resetEnd();\\n            }\\n            board[i][j] = \\'0\\';\\n            f(board, i-1, j, m, n, s, trie);\\n            f(board, i+1, j, m, n, s, trie);\\n            f(board, i, j-1, m, n, s, trie);\\n            f(board, i, j+1, m, n, s, trie);\\n            board[i][j] = temp;\\n            \\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& word) {\\n        int m = board.size(), n = board[0].size();  \\n        Node* root = new Node();\\n        \\n        for(int i = 0; i < word.size(); i++){\\n            insert(word[i], root);\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(root->containsChar(board[i][j]))\\n                   f(board, i, j, m, n, \"\", root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nstruct Node{\\n    Node* trie[26];\\n    bool flag = false;\\n    \\n    bool containsChar(char c){\\n        if(c ==\\'0\\') return false;\\n        return trie[c-\\'a\\'] != NULL;\\n    }\\n    \\n    void addNewChar(char c, Node* ref){\\n        trie[c-\\'a\\'] = ref;\\n    }\\n    Node* getToNode(char c){\\n        return trie[c-\\'a\\'];\\n    }\\n    \\n    void setEnd(){\\n        flag = true;\\n    }\\n    void resetEnd(){\\n        flag = false;\\n    }\\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void insert(string word, Node* root) {\\n        Node *head = root;\\n        int n = word.length();\\n        for(int i = 0; i < n; i++){\\n            if(!head->containsChar(word[i]))\\n                head->addNewChar(word[i], new Node());\\n            head = head->getToNode(word[i]);\\n        }\\n        head->setEnd();\\n    }\\n    \\n    vector<string>ans;\\n    void f(vector<vector<char>>& board, int i, int j, int m, int n, string s, Node* trie)\\n    {\\n        if(i < 0 || i >= m || j < 0 || j >= n || board[i][j] == \\'0\\') return;\\n        \\n        s += board[i][j];\\n        if(trie->containsChar(board[i][j]))\\n        {\\n            char temp = board[i][j];\\n            trie = trie->getToNode(temp);\\n            if(trie->isEnd()){\\n                ans.emplace_back(s);\\n                trie->resetEnd();\\n            }\\n            board[i][j] = \\'0\\';\\n            f(board, i-1, j, m, n, s, trie);\\n            f(board, i+1, j, m, n, s, trie);\\n            f(board, i, j-1, m, n, s, trie);\\n            f(board, i, j+1, m, n, s, trie);\\n            board[i][j] = temp;\\n            \\n        }\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& word) {\\n        int m = board.size(), n = board[0].size();  \\n        Node* root = new Node();\\n        \\n        for(int i = 0; i < word.size(); i++){\\n            insert(word[i], root);\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(root->containsChar(board[i][j]))\\n                   f(board, i, j, m, n, \"\", root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134511,
                "title": "simple-algorithm-using-trie-data-structure-in-c-no-pruning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use the trie data-structure to store all the words, and iterate over the same to search for words in the board. \\nNote: No pruning is done, just simple plain algorithm! :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMain Algorithm:- \\n1. Create an unordered set \\n2. Create a trie data-structure and store all the words in it\\n3. Now iterate through each cell in the word and see if any word starts from it in trie\\n    3.1 if it does, then call a search function for that letter node in trie\\n4. Create an answer vector and copy the set to it\\n5. retur the answer\\n\\nSearch() algorithm:-\\n1. Store the char at current position in board and replace it with some temperory symbol like dollar ( this is done to avoid multiple traversals through the same branch ) \\n2. If the current word is complete, add it to the answer set\\n3. Now for each of the four sides of current cell (right, above, left, below) - if it matches with next child of trie node, call function search on it recursively\\n4. replace the current position in board with its original symbol\\n\\n\\n# Complexity\\n- Time complexity: O(m*n*m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(w*l)\\n    where w=number of words, and l= average length of a word\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node {    // a trie node\\npublic:\\n    char letter;\\n    bool isComplete;\\n    string word;\\n    unordered_map<char, Node*> childList;\\n\\n    Node(char c) {\\n        letter=c;\\n        isComplete=false;\\n        word=\"\";\\n    }\\n    bool hasChild(char c) {\\n        if(childList.find(c)==childList.end()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    Node* getChild(char c) {\\n        return childList.at(c);\\n    }\\n    void putNewChild(char c) {\\n        childList.insert({c, new Node(c)});\\n    }\\n};\\n\\n// functions to perform upon trie \\nvoid insert(string word, Node* root) {\\n    Node* ptr=root;\\n    for(int i=0; i<word.length(); i++) {\\n        if(ptr->hasChild(word[i])==true) {\\n            ptr=ptr->getChild(word[i]);\\n        }\\n        else {\\n            ptr->putNewChild(word[i]);\\n            ptr=ptr->getChild(word[i]);\\n        }\\n    }\\n    ptr->isComplete=true;\\n    ptr->word=word;\\n    return;\\n}\\n\\nvoid search(Node* curr, int i, int j, unordered_set<string>& ans, vector<vector<char>>& board) {\\n    int m=board.size(), n=board[0].size();  // m*n matrix board \\n    // store value of current position in board and mark it as \\'\\n``` \\n        char c=board[i][j];\\n        board[i][j]=\\'\\n```;\\n    // check if current word complete \\n        // if yes, insert it to answer set\\n        if(curr->isComplete==true) {\\n            ans.insert(curr->word);\\n        }\\n    // check for each of the four sides if it matches the next child \\n        // if it does match, then recursively call search for it\\n            if(j+1<n && curr->hasChild(board[i][j+1]) )// right-side \\n                search(curr->getChild(board[i][j+1]), i, j+1, ans, board);\\n            if(i-1>=0 && curr->hasChild(board[i-1][j]))// above\\n                search(curr->getChild(board[i-1][j]), i-1, j, ans, board);\\n            if(j-1>=0 && curr->hasChild(board[i][j-1]))// left-side\\n                search(curr->getChild(board[i][j-1]), i, j-1, ans, board);\\n            if(i+1<m && curr->hasChild(board[i+1][j]))// below\\n                search(curr->getChild(board[i+1][j]), i+1, j, ans, board);\\n    // unmark the current position by its previous value\\n        board[i][j]=c;\\n}\\n\\n// Question -->\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // Create a unordered set \\n            unordered_set<string> uset;\\n        // create a trie and store all words in it\\n            Node* trie= new Node(\\'0\\');\\n            for(int i=0; i<words.size(); i++) {\\n                insert(words[i], trie);\\n            }\\n        // now go through each cell in board and find if a word matches in it\\n            // if it does match, then insert it to the set\\n            int r=board.size(), c=board[0].size();\\n            for(int i=0; i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    // for cell <i, j>, if any word starts with this letter -->\\n                        if(trie->hasChild(board[i][j])) {\\n                            // start searching through all paths ... \\n                                search(trie->getChild(board[i][j]), i, j, uset, board);\\n                        }\\n\\n                }\\n            }\\n        // Create a vector and copy set to it\\n            vector<string> ans;\\n            unordered_set<string>::iterator itr;\\n            for(itr=uset.begin(); itr!=uset.end(); itr++) {\\n                ans.push_back(*itr);\\n            }\\n        // return the vector\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Node {    // a trie node\\npublic:\\n    char letter;\\n    bool isComplete;\\n    string word;\\n    unordered_map<char, Node*> childList;\\n\\n    Node(char c) {\\n        letter=c;\\n        isComplete=false;\\n        word=\"\";\\n    }\\n    bool hasChild(char c) {\\n        if(childList.find(c)==childList.end()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    Node* getChild(char c) {\\n        return childList.at(c);\\n    }\\n    void putNewChild(char c) {\\n        childList.insert({c, new Node(c)});\\n    }\\n};\\n\\n// functions to perform upon trie \\nvoid insert(string word, Node* root) {\\n    Node* ptr=root;\\n    for(int i=0; i<word.length(); i++) {\\n        if(ptr->hasChild(word[i])==true) {\\n            ptr=ptr->getChild(word[i]);\\n        }\\n        else {\\n            ptr->putNewChild(word[i]);\\n            ptr=ptr->getChild(word[i]);\\n        }\\n    }\\n    ptr->isComplete=true;\\n    ptr->word=word;\\n    return;\\n}\\n\\nvoid search(Node* curr, int i, int j, unordered_set<string>& ans, vector<vector<char>>& board) {\\n    int m=board.size(), n=board[0].size();  // m*n matrix board \\n    // store value of current position in board and mark it as \\'\\n```\n```;\\n    // check if current word complete \\n        // if yes, insert it to answer set\\n        if(curr->isComplete==true) {\\n            ans.insert(curr->word);\\n        }\\n    // check for each of the four sides if it matches the next child \\n        // if it does match, then recursively call search for it\\n            if(j+1<n && curr->hasChild(board[i][j+1]) )// right-side \\n                search(curr->getChild(board[i][j+1]), i, j+1, ans, board);\\n            if(i-1>=0 && curr->hasChild(board[i-1][j]))// above\\n                search(curr->getChild(board[i-1][j]), i-1, j, ans, board);\\n            if(j-1>=0 && curr->hasChild(board[i][j-1]))// left-side\\n                search(curr->getChild(board[i][j-1]), i, j-1, ans, board);\\n            if(i+1<m && curr->hasChild(board[i+1][j]))// below\\n                search(curr->getChild(board[i+1][j]), i+1, j, ans, board);\\n    // unmark the current position by its previous value\\n        board[i][j]=c;\\n}\\n\\n// Question -->\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // Create a unordered set \\n            unordered_set<string> uset;\\n        // create a trie and store all words in it\\n            Node* trie= new Node(\\'0\\');\\n            for(int i=0; i<words.size(); i++) {\\n                insert(words[i], trie);\\n            }\\n        // now go through each cell in board and find if a word matches in it\\n            // if it does match, then insert it to the set\\n            int r=board.size(), c=board[0].size();\\n            for(int i=0; i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    // for cell <i, j>, if any word starts with this letter -->\\n                        if(trie->hasChild(board[i][j])) {\\n                            // start searching through all paths ... \\n                                search(trie->getChild(board[i][j]), i, j, uset, board);\\n                        }\\n\\n                }\\n            }\\n        // Create a vector and copy set to it\\n            vector<string> ans;\\n            unordered_set<string>::iterator itr;\\n            for(itr=uset.begin(); itr!=uset.end(); itr++) {\\n                ans.push_back(*itr);\\n            }\\n        // return the vector\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783455,
                "title": "python-3-one-line",
                "content": "First, we check it passes recent tests without TLE:\\n\\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        board = {i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}\\n        res, trie = [], (Trie:=lambda: defaultdict(Trie))()\\n        any(reduce(dict.__getitem__, w, trie).__setitem__(\\'$\\', w) for w in words)\\n        def dfs(z, parent):\\n            if not (c:=board.get(z)) in parent:\\n                return\\n            if (word:=(node:=parent[c]).pop(\\'$\\', None)):\\n                res.append(word)\\n            board[z] = None\\n            any(dfs(z+1j**k, node) for k in range(4))\\n            board[z] = c\\n            if not node:\\n                parent.pop(c)\\n        any(dfs(z, trie) for z in board)\\n        return res\\n```\\n\\nThen we put it all into a single line:\\n\\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        return ([b:={i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}, r:=[], t:=(T:=lambda: defaultdict(T))(), [reduce(dict.__getitem__, w, t).__setitem__(\\'$\\',w) for w in words], (f:=lambda z,p: (c:=b.get(z)) in p and (((w:=(n:=p[c]).pop(\\'$\\',0)) and r.append(w)) or ((b.__setitem__(z,0) or [f(z+1j**k, n) for k in range(4)] and b.__setitem__(z,c)) or (n or p.pop(c)))))] and [f(z,t) for z in b] and r)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        board = {i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}\\n        res, trie = [], (Trie:=lambda: defaultdict(Trie))()\\n        any(reduce(dict.__getitem__, w, trie).__setitem__(\\'$\\', w) for w in words)\\n        def dfs(z, parent):\\n            if not (c:=board.get(z)) in parent:\\n                return\\n            if (word:=(node:=parent[c]).pop(\\'$\\', None)):\\n                res.append(word)\\n            board[z] = None\\n            any(dfs(z+1j**k, node) for k in range(4))\\n            board[z] = c\\n            if not node:\\n                parent.pop(c)\\n        any(dfs(z, trie) for z in board)\\n        return res\\n```\n```python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        return ([b:={i+j*1j: c for i, row in enumerate(board) for j, c in enumerate(row)}, r:=[], t:=(T:=lambda: defaultdict(T))(), [reduce(dict.__getitem__, w, t).__setitem__(\\'$\\',w) for w in words], (f:=lambda z,p: (c:=b.get(z)) in p and (((w:=(n:=p[c]).pop(\\'$\\',0)) and r.append(w)) or ((b.__setitem__(z,0) or [f(z+1j**k, n) for k in range(4)] and b.__setitem__(z,c)) or (n or p.pop(c)))))] and [f(z,t) for z in b] and r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782712,
                "title": "python-backtracking-and-trie-plus-advice-for-tle",
                "content": "I was getting `Time Limit Exceeded `until I added word counts to the trie. Specifically, each node in the trie stores the number of words at or beneath that node. When a word is found, the word is removed from the trie, and all the relevant word counts are decremented. This allows us to detect when there are no more words in the current branch of the trie, at which point we can backtrack.\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:       \\n        num_rows = len(board)\\n        num_cols = len(board[0])\\n        res = set()\\n        \\n        def find_words(row, col, letters_so_far, used_squares, trie):\\n            if not (0 <= row < num_rows) or not (0 <= col < num_cols):\\n                return\\n            if (row, col) in used_squares:\\n                return\\n            if not trie[\"NUM WORDS\"]:\\n                return\\n            \\n            letter = board[row][col]\\n            if letter not in trie:\\n                return\\n            \\n            new_trie = trie[letter]            \\n            letters_so_far.append(letter)\\n            used_squares.add((row, col))\\n            \\n            if \"END\" in new_trie:\\n                res.add(\"\".join(letters_so_far))\\n                del new_trie[\"END\"]\\n                \\n                trie_to_update = new_trie\\n                while trie_to_update:                    \\n                    trie_to_update[\"NUM WORDS\"] -= 1                        \\n                    trie_to_update = trie_to_update[\"PARENT\"]                    \\n            \\n            find_words(row + 1, col, letters_so_far, used_squares, new_trie)\\n            find_words(row - 1, col, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col + 1, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col - 1, letters_so_far, used_squares, new_trie)\\n            \\n            letters_so_far.pop()\\n            used_squares.remove((row, col))            \\n            \\n        trie = self.make_trie(words)\\n        for start_row in range(num_rows):\\n            for start_col in range(num_cols):\\n                find_words(start_row, start_col, [], set(), trie)\\n        \\n        return list(res)\\n    \\n    def make_trie(self, words):\\n        trie = {\"NUM WORDS\": 0, \"PARENT\": None}\\n        for word in words:\\n            trie_pos = trie\\n            trie_pos[\"NUM WORDS\"] += 1\\n\\n            for letter in word:\\n                if letter not in trie_pos:\\n                    trie_pos[letter] = {\"NUM WORDS\": 0, \"PARENT\": trie_pos}\\n                trie_pos = trie_pos[letter]\\n                trie_pos[\"NUM WORDS\"] += 1\\n\\n            trie_pos[\"END\"] = \"END\"     \\n            \\n        return trie\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:       \\n        num_rows = len(board)\\n        num_cols = len(board[0])\\n        res = set()\\n        \\n        def find_words(row, col, letters_so_far, used_squares, trie):\\n            if not (0 <= row < num_rows) or not (0 <= col < num_cols):\\n                return\\n            if (row, col) in used_squares:\\n                return\\n            if not trie[\"NUM WORDS\"]:\\n                return\\n            \\n            letter = board[row][col]\\n            if letter not in trie:\\n                return\\n            \\n            new_trie = trie[letter]            \\n            letters_so_far.append(letter)\\n            used_squares.add((row, col))\\n            \\n            if \"END\" in new_trie:\\n                res.add(\"\".join(letters_so_far))\\n                del new_trie[\"END\"]\\n                \\n                trie_to_update = new_trie\\n                while trie_to_update:                    \\n                    trie_to_update[\"NUM WORDS\"] -= 1                        \\n                    trie_to_update = trie_to_update[\"PARENT\"]                    \\n            \\n            find_words(row + 1, col, letters_so_far, used_squares, new_trie)\\n            find_words(row - 1, col, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col + 1, letters_so_far, used_squares, new_trie)    \\n            find_words(row, col - 1, letters_so_far, used_squares, new_trie)\\n            \\n            letters_so_far.pop()\\n            used_squares.remove((row, col))            \\n            \\n        trie = self.make_trie(words)\\n        for start_row in range(num_rows):\\n            for start_col in range(num_cols):\\n                find_words(start_row, start_col, [], set(), trie)\\n        \\n        return list(res)\\n    \\n    def make_trie(self, words):\\n        trie = {\"NUM WORDS\": 0, \"PARENT\": None}",
                "codeTag": "Java"
            },
            {
                "id": 2782656,
                "title": "python-trie-dfs-solution-faster-than-25",
                "content": "I tried Word Search II with a Word Search I level solution, of course it TLEd - went to NeetCode to see their solution, implemented it for myself - It TLEd. This code is based off of their solution with a few small changes.\\n\\n\\n1) The important change: after we check if the current node `is_word`, we also check if it has any children, in which case we may prune it (`del node`) to save unnecessary traversals for future DFS calls. Else, we DFS onwards.\\n\\nThe following changes are minor.\\n\\n2) We use a list to track the results rather than a set, and avoid adding the same word twice by setting `is_word` to False instead.\\n3) Instead of using a set to track visited chars, we modify the cell to `\" \"`, and set things right before we leave the DFS function call. \\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n    \\n    def add_word(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.is_word = True\\n\\nclass Solution:    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ROWS, COLS = len(board), len(board[0])\\n        results = []\\n        \\n        trie = TrieNode()\\n        for word in words:\\n            trie.add_word(word)\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or r == ROWS or\\n                c < 0 or c == COLS or\\n                board[r][c] == \" \" or board[r][c] not in node.children):\\n                return\\n            temp_char = board[r][c]\\n            board[r][c] = \" \"\\n            node = node.children[temp_char]\\n            word += temp_char\\n            \\n            if node.is_word:\\n                results.append(word)\\n                node.is_word = False\\n            \\n            if not node.children:\\n                del node\\n            else:\\n                dfs(r + 1, c, node, word)\\n                dfs(r - 1, c, node, word)\\n                dfs(r, c + 1, node, word)\\n                dfs(r, c - 1, node, word)\\n            \\n            board[r][c] = temp_char\\n            \\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, trie, \"\")\\n        return results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n    \\n    def add_word(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.is_word = True\\n\\nclass Solution:    \\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        ROWS, COLS = len(board), len(board[0])\\n        results = []\\n        \\n        trie = TrieNode()\\n        for word in words:\\n            trie.add_word(word)\\n        \\n        def dfs(r, c, node, word):\\n            if (r < 0 or r == ROWS or\\n                c < 0 or c == COLS or\\n                board[r][c] == \" \" or board[r][c] not in node.children):\\n                return\\n            temp_char = board[r][c]\\n            board[r][c] = \" \"\\n            node = node.children[temp_char]\\n            word += temp_char\\n            \\n            if node.is_word:\\n                results.append(word)\\n                node.is_word = False\\n            \\n            if not node.children:\\n                del node\\n            else:\\n                dfs(r + 1, c, node, word)\\n                dfs(r - 1, c, node, word)\\n                dfs(r, c + 1, node, word)\\n                dfs(r, c - 1, node, word)\\n            \\n            board[r][c] = temp_char\\n            \\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                dfs(r, c, trie, \"\")\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782488,
                "title": "c-solution-without-trie",
                "content": "**Algorithm Overview**\\nDfs generates all string possible starting in each char of board, if any string matches then it is added to solution.\\n\\n**Optimizations**\\nUsing dfs for all possible string causes tle. So, max length of input string is found is used to limit the dfs calls.\\n\\n**Code**\\n```cpp\\nclass Solution {\\n    // stores words in a map, so that lookup in dfs can be done in O(1) time\\n    unordered_set<string> mp;\\n    // global state is used for easy insertion of ans by dfs\\n    vector<string> ans;\\n    // stores the maximum length of string\\n    int mx;\\n    \\nvoid dfs(vector<vector<char>>& board,int i,int j,vector<vector<bool>>& visit, string &word){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size()) return ;\\n    if(visit[i][j] || word.length() >= mx)return ;\\n    \\n    word.push_back(board[i][j]);\\n    \\n    // if mp contains the word, it is added to the answer\\n    // also, word is removed imediately from the map, to prevent duplicates\\n    // in answer\\n    if(mp.count(word)){\\n        ans.push_back(word);\\n        mp.erase(word);\\n    }\\n    \\n    //dfs calls\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,visit, word);\\n    dfs(board,i-1,j,visit, word);\\n    dfs(board,i,j+1,visit, word);\\n    dfs(board,i,j-1,visit, word);\\n    \\n    // reverting visit and word to previous state\\n    visit[i][j]= false;\\n    word.pop_back();\\n}\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // visit array for dfs calls\\n        vector<vector<bool>> visit(board.size(), vector<bool>(board[0].size(), false));\\n        mx = 0;\\n        \\n        // this loop adds words to the mp, and finds the max length string\\n        for(auto word: words){\\n            mp.insert(word);\\n            mx = max(mx, (int)word.length());\\n        }\\n            \\n        // this loop calls dfs for all cells of the board\\n        string s = \"\";\\n        for(int i = 0;i < board.size(); i++){\\n            for(int j = 0; j < board[0].size(); j++){\\n                dfs(board, i, j, visit, s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    // stores words in a map, so that lookup in dfs can be done in O(1) time\\n    unordered_set<string> mp;\\n    // global state is used for easy insertion of ans by dfs\\n    vector<string> ans;\\n    // stores the maximum length of string\\n    int mx;\\n    \\nvoid dfs(vector<vector<char>>& board,int i,int j,vector<vector<bool>>& visit, string &word){ \\n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size()) return ;\\n    if(visit[i][j] || word.length() >= mx)return ;\\n    \\n    word.push_back(board[i][j]);\\n    \\n    // if mp contains the word, it is added to the answer\\n    // also, word is removed imediately from the map, to prevent duplicates\\n    // in answer\\n    if(mp.count(word)){\\n        ans.push_back(word);\\n        mp.erase(word);\\n    }\\n    \\n    //dfs calls\\n    visit[i][j] = true;\\n    dfs(board,i+1,j,visit, word);\\n    dfs(board,i-1,j,visit, word);\\n    dfs(board,i,j+1,visit, word);\\n    dfs(board,i,j-1,visit, word);\\n    \\n    // reverting visit and word to previous state\\n    visit[i][j]= false;\\n    word.pop_back();\\n}\\n    \\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // visit array for dfs calls\\n        vector<vector<bool>> visit(board.size(), vector<bool>(board[0].size(), false));\\n        mx = 0;\\n        \\n        // this loop adds words to the mp, and finds the max length string\\n        for(auto word: words){\\n            mp.insert(word);\\n            mx = max(mx, (int)word.length());\\n        }\\n            \\n        // this loop calls dfs for all cells of the board\\n        string s = \"\";\\n        for(int i = 0;i < board.size(); i++){\\n            for(int j = 0; j < board[0].size(); j++){\\n                dfs(board, i, j, visit, s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781988,
                "title": "c-backtracking-stl",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string str;\\n    bool vis[13][13];\\n\\n    unordered_set<string> res;\\n    unordered_set<string> toFound;\\n    unordered_map<string, int> m;\\n\\n    void rec(int i, int j, vector<vector<char>> &a)\\n    {\\n        if (toFound.find(str) != toFound.end())\\n        {\\n            string curr;\\n\\n            for (auto x : str)\\n            {\\n                curr += x;\\n                m[curr]--;\\n            }\\n\\n            toFound.erase(curr);\\n            res.insert(str);\\n        }\\n\\n        if (i < 0 || j < 0 || i >= a.size() || j >= a[0].size() || vis[i][j] || m[str] == 0)\\n        {\\n            return;\\n        }\\n\\n        vis[i][j] = 1;\\n\\n        str += a[i][j];\\n\\n        rec(i + 1, j, a);\\n        rec(i, j + 1, a);\\n        rec(i, j - 1, a);\\n        rec(i - 1, j, a);\\n\\n        vis[i][j] = 0;\\n\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& a, vector<string>& words) {\\n\\n\\n        for (auto x : words)\\n        {\\n            string curr;\\n\\n            toFound.insert(x);\\n\\n            for (auto y : x)\\n            {\\n                curr += y;\\n                m[curr]++;\\n            }\\n        }\\n\\n        m[\"\"]++;\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            for (int j = 0; j < a[0].size(); j++)\\n            {\\n                memset(vis, 0, sizeof(vis));\\n                rec(i, j, a);\\n            }\\n        }\\n\\n        vector<string> ans;\\n\\n        for (auto x : res)\\n        {\\n            ans.push_back(x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string str;\\n    bool vis[13][13];\\n\\n    unordered_set<string> res;\\n    unordered_set<string> toFound;\\n    unordered_map<string, int> m;\\n\\n    void rec(int i, int j, vector<vector<char>> &a)\\n    {\\n        if (toFound.find(str) != toFound.end())\\n        {\\n            string curr;\\n\\n            for (auto x : str)\\n            {\\n                curr += x;\\n                m[curr]--;\\n            }\\n\\n            toFound.erase(curr);\\n            res.insert(str);\\n        }\\n\\n        if (i < 0 || j < 0 || i >= a.size() || j >= a[0].size() || vis[i][j] || m[str] == 0)\\n        {\\n            return;\\n        }\\n\\n        vis[i][j] = 1;\\n\\n        str += a[i][j];\\n\\n        rec(i + 1, j, a);\\n        rec(i, j + 1, a);\\n        rec(i, j - 1, a);\\n        rec(i - 1, j, a);\\n\\n        vis[i][j] = 0;\\n\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& a, vector<string>& words) {\\n\\n\\n        for (auto x : words)\\n        {\\n            string curr;\\n\\n            toFound.insert(x);\\n\\n            for (auto y : x)\\n            {\\n                curr += y;\\n                m[curr]++;\\n            }\\n        }\\n\\n        m[\"\"]++;\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            for (int j = 0; j < a[0].size(); j++)\\n            {\\n                memset(vis, 0, sizeof(vis));\\n                rec(i, j, a);\\n            }\\n        }\\n\\n        vector<string> ans;\\n\\n        for (auto x : res)\\n        {\\n            ans.push_back(x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781881,
                "title": "c-dfs-trie-backtracking-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node *child[26];\\n        string word;\\n        bool end;\\n        Node()\\n        {\\n            end = false;\\n            word = \"\";\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;    \\n        }\\n    };\\n    \\n    Node *root = new Node();\\n    void insert(string &s)\\n    {\\n        Node *curr = root;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            int idx = s[i] - \\'a\\';\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new Node();\\n            }\\n            curr = curr -> child[idx];\\n        }\\n        curr -> end = true;\\n        curr -> word = s;\\n    }\\n    vector<string> ans;\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n, Node *curr)\\n    {\\n        if(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \\'#\\')\\n            return;\\n        int idx = grid[i][j] - \\'a\\';\\n        if(curr -> child[idx] == NULL)\\n            return;\\n        curr = curr -> child[idx];\\n        if(curr -> end == true)\\n        {\\n            ans.push_back(curr -> word);\\n            curr -> end = false;\\n        }\\n        char val = grid[i][j];\\n        grid[i][j] = \\'#\\';\\n        dfs(grid, i + 1, j, m, n, curr);\\n        dfs(grid, i, j + 1, m , n, curr);\\n        dfs(grid, i - 1, j, m , n , curr);\\n        dfs(grid, i, j - 1, m, n, curr);\\n        grid[i][j] = val;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                dfs(grid, i, j, m ,n , root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node *child[26];\\n        string word;\\n        bool end;\\n        Node()\\n        {\\n            end = false;\\n            word = \"\";\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;    \\n        }\\n    };\\n    \\n    Node *root = new Node();\\n    void insert(string &s)\\n    {\\n        Node *curr = root;\\n        for(int i = 0 ; i < s.size(); i++)\\n        {\\n            int idx = s[i] - \\'a\\';\\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new Node();\\n            }\\n            curr = curr -> child[idx];\\n        }\\n        curr -> end = true;\\n        curr -> word = s;\\n    }\\n    vector<string> ans;\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n, Node *curr)\\n    {\\n        if(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \\'#\\')\\n            return;\\n        int idx = grid[i][j] - \\'a\\';\\n        if(curr -> child[idx] == NULL)\\n            return;\\n        curr = curr -> child[idx];\\n        if(curr -> end == true)\\n        {\\n            ans.push_back(curr -> word);\\n            curr -> end = false;\\n        }\\n        char val = grid[i][j];\\n        grid[i][j] = \\'#\\';\\n        dfs(grid, i + 1, j, m, n, curr);\\n        dfs(grid, i, j + 1, m , n, curr);\\n        dfs(grid, i - 1, j, m , n , curr);\\n        dfs(grid, i, j - 1, m, n, curr);\\n        grid[i][j] = val;\\n    }\\n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(auto word : words)\\n        {\\n            insert(word);\\n        }\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                dfs(grid, i, j, m ,n , root);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780046,
                "title": "cleanest-c-code-detailed-youtube-explanation",
                "content": "```\\n//YouTube Link : https://www.youtube.com/watch?v=DMP2bqW6URA\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    int r, c;\\n    vector<pair<int, int>> directions{{-1, 0},{1, 0},{0, 1},{0, -1}};\\n    struct trieNode {\\n        bool endOfWord;\\n        trieNode* children[26];\\n        string word;\\n    };\\n\\n    trieNode* getNode() {\\n        trieNode* temp = new trieNode();\\n        temp->endOfWord = false;\\n        for(int i = 0; i<26; i++) {\\n            temp->children[i] = NULL;\\n        }\\n        temp->word = \"\";\\n        return temp;\\n    }\\n\\n    void insert(trieNode* root, string str) {\\n        trieNode* pCrawl = root;\\n        for(char ch:str) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL) {\\n                pCrawl->children[ch-\\'a\\'] = getNode();\\n            }\\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        pCrawl->endOfWord = true;\\n        pCrawl->word = str;\\n    }\\n\\n    void DFS(vector<vector<char>>& board, int i, int j, trieNode* root) {\\n        if(i<0 || i >= r || j<0 || j >= c || board[i][j] == \\'$\\' || root->children[board[i][j]- \\'a\\'] == NULL) {\\n            return;\\n        }\\n        root = root->children[board[i][j]- \\'a\\'];\\n        if(root->endOfWord == true) {\\n            result.push_back(root->word);\\n            root->endOfWord = false;\\n        }\\n        char temp     = board[i][j];\\n        \\n        board[i][j] = \\'$\\';\\n        for(pair<int, int> p:directions) {\\n            int new_i = i+p.first;\\n            int new_j = j+p.second;\\n            DFS(board, new_i, new_j, root);\\n        }\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        r = board.size();\\n        c = board[0].size();\\n\\n        trieNode* root = getNode();\\n        for(string str:words) {\\n            insert(root, str);\\n        }\\n\\n        for(int i = 0; i<r; i++) {\\n            for(int j = 0; j<c; j++) {\\n                char ch = board[i][j];\\n                if(root->children[ch-\\'a\\'] != NULL) {\\n                    DFS(board, i, j, root);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n//YouTube Link : https://www.youtube.com/watch?v=DMP2bqW6URA\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    int r, c;\\n    vector<pair<int, int>> directions{{-1, 0},{1, 0},{0, 1},{0, -1}};\\n    struct trieNode {\\n        bool endOfWord;\\n        trieNode* children[26];\\n        string word;\\n    };\\n\\n    trieNode* getNode() {\\n        trieNode* temp = new trieNode();\\n        temp->endOfWord = false;\\n        for(int i = 0; i<26; i++) {\\n            temp->children[i] = NULL;\\n        }\\n        temp->word = \"\";\\n        return temp;\\n    }\\n\\n    void insert(trieNode* root, string str) {\\n        trieNode* pCrawl = root;\\n        for(char ch:str) {\\n            if(pCrawl->children[ch-\\'a\\'] == NULL) {\\n                pCrawl->children[ch-\\'a\\'] = getNode();\\n            }\\n            pCrawl = pCrawl->children[ch-\\'a\\'];\\n        }\\n        pCrawl->endOfWord = true;\\n        pCrawl->word = str;\\n    }\\n\\n    void DFS(vector<vector<char>>& board, int i, int j, trieNode* root) {\\n        if(i<0 || i >= r || j<0 || j >= c || board[i][j] == \\'$\\' || root->children[board[i][j]- \\'a\\'] == NULL) {\\n            return;\\n        }\\n        root = root->children[board[i][j]- \\'a\\'];\\n        if(root->endOfWord == true) {\\n            result.push_back(root->word);\\n            root->endOfWord = false;\\n        }\\n        char temp     = board[i][j];\\n        \\n        board[i][j] = \\'$\\';\\n        for(pair<int, int> p:directions) {\\n            int new_i = i+p.first;\\n            int new_j = j+p.second;\\n            DFS(board, new_i, new_j, root);\\n        }\\n        board[i][j] = temp;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        r = board.size();\\n        c = board[0].size();\\n\\n        trieNode* root = getNode();\\n        for(string str:words) {\\n            insert(root, str);\\n        }\\n\\n        for(int i = 0; i<r; i++) {\\n            for(int j = 0; j<c; j++) {\\n                char ch = board[i][j];\\n                if(root->children[ch-\\'a\\'] != NULL) {\\n                    DFS(board, i, j, root);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780015,
                "title": "cpp-solution-using-trie-data-structure-trie-dfs",
                "content": "Here we are adding words in trie and than going through every cell of the grid and if we are at the end of the string of the trie than we add that to our result.\\n\\n```\\nclass TrieNode {\\n    public : \\n    TrieNode *next[26] = {};\\n    string s;\\n    bool endHere = false;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    int vis[12][12];\\n    TrieNode *root;\\n    \\n    void insert(string s) {\\n        int n = s.size();\\n        TrieNode *cur = root;\\n        for(int i = 0; i < n; i++) {\\n            int val = s[i] - \\'a\\';\\n            if(!cur->next[val]) { \\n                cur->next[val] = new TrieNode();\\n            }\\n            cur = cur->next[val];\\n        }\\n        cur->endHere = true;\\n        cur->s = s;\\n    }\\n    \\n    void run(int i, int j, TrieNode* r, vector<vector<char>>& board) {\\n        if(r->endHere) {\\n            res.push_back(r->s);\\n            r->endHere = false;\\n        }\\n        \\n        int n = board.size(), m = board[0].size();\\n        if(i < 0 || i >= n || j < 0 || j >= m || vis[i][j]) return;\\n        \\n        vis[i][j] = 1;\\n        int val = board[i][j] - \\'a\\';\\n        if(r->next[val]) {\\n            int dx[4] = {1, -1, 0, 0};\\n            int dy[4] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; t++){\\n                int nx = i + dx[t];\\n                int ny = j + dy[t];\\n                run(nx, ny, r->next[val], board);\\n            }\\n        }\\n        vis[i][j] = 0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        res.clear();\\n        memset(vis, 0, sizeof(vis));\\n        root = new TrieNode();\\n        for(auto word : words) insert(word);\\n        int n = board.size(), m = board[0].size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                run(i, j, root, board);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    public : \\n    TrieNode *next[26] = {};\\n    string s;\\n    bool endHere = false;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    int vis[12][12];\\n    TrieNode *root;\\n    \\n    void insert(string s) {\\n        int n = s.size();\\n        TrieNode *cur = root;\\n        for(int i = 0; i < n; i++) {\\n            int val = s[i] - \\'a\\';\\n            if(!cur->next[val]) { \\n                cur->next[val] = new TrieNode();\\n            }\\n            cur = cur->next[val];\\n        }\\n        cur->endHere = true;\\n        cur->s = s;\\n    }\\n    \\n    void run(int i, int j, TrieNode* r, vector<vector<char>>& board) {\\n        if(r->endHere) {\\n            res.push_back(r->s);\\n            r->endHere = false;\\n        }\\n        \\n        int n = board.size(), m = board[0].size();\\n        if(i < 0 || i >= n || j < 0 || j >= m || vis[i][j]) return;\\n        \\n        vis[i][j] = 1;\\n        int val = board[i][j] - \\'a\\';\\n        if(r->next[val]) {\\n            int dx[4] = {1, -1, 0, 0};\\n            int dy[4] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; t++){\\n                int nx = i + dx[t];\\n                int ny = j + dy[t];\\n                run(nx, ny, r->next[val], board);\\n            }\\n        }\\n        vis[i][j] = 0;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        res.clear();\\n        memset(vis, 0, sizeof(vis));\\n        root = new TrieNode();\\n        for(auto word : words) insert(word);\\n        int n = board.size(), m = board[0].size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                run(i, j, root, board);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779919,
                "title": "python-trie-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        res = []\\n        Trie = lambda : defaultdict(Trie)\\n        root = Trie()\\n        def add(s):\\n            cur = root\\n            for c in s: cur = cur[c]\\n            cur[\\'$\\'] = s\\n                \\n        for word in words: add(word)\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(i, j, root):\\n            ch = board[i][j]\\n            cur = root.get(ch)\\n            if not cur: return \\n\\n            if \\'$\\' in cur: \\n                res.append(cur[\\'$\\'])\\n                del cur[\\'$\\']\\n            \\n            board[i][j] = \\'#\\'\\n            if i<m-1: dfs(i+1, j, cur)\\n            if i>0: dfs(i-1, j, cur)\\n            if j<n-1: dfs(i, j+1, cur)\\n            if j>0: dfs(i, j-1, cur)\\n            board[i][j] = ch\\n\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, root)\\n        return res\\n    \\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        res = []\\n        Trie = lambda : defaultdict(Trie)\\n        root = Trie()\\n        def add(s):\\n            cur = root\\n            for c in s: cur = cur[c]\\n            cur[\\'$\\'] = s\\n                \\n        for word in words: add(word)\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(i, j, root):\\n            ch = board[i][j]\\n            cur = root.get(ch)\\n            if not cur: return \\n\\n            if \\'$\\' in cur: \\n                res.append(cur[\\'$\\'])\\n                del cur[\\'$\\']\\n            \\n            board[i][j] = \\'#\\'\\n            if i<m-1: dfs(i+1, j, cur)\\n            if i>0: dfs(i-1, j, cur)\\n            if j<n-1: dfs(i, j+1, cur)\\n            if j>0: dfs(i, j-1, cur)\\n            board[i][j] = ch\\n\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, root)\\n        return res\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779704,
                "title": "python-accepted-2022-backtracking-tries",
                "content": "1. build tries\\n2. do backtracking based on each node.child\\n\\nIt\\'s my first post, seeking for votes. Thank you all!\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.child = {}\\n        self.end = None  # word\\n        \\nclass Tries:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def inser_word(self, word):\\n        \\n        cur = self.root\\n        for c in word:\\n            if c in cur.child:\\n                cur = cur.child[c]\\n            else:\\n                cur.child[c] = Node()\\n                cur = cur.child[c]\\n        cur.end = word\\n\\n    # O(M(4(3**L-1)))\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n    \\n        # tries build tries\\n        # backtracking in each node\\n        # if neibor in node.child\\n        Rows, Cols = len(board), len(board[0])\\n        \\n        tries = Tries()\\n        visited = set()\\n        RR = set(range(Rows))\\n        CC = set(range(Cols))\\n        \\n        for word in words:\\n            tries.inser_word(word)\\n            \\n        words = set(words)\\n        direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        res = set()\\n        \\n        def backtracking(r, c, node):\\n            \\n            if node.end:\\n                res.add(node.end)\\n                \\n            if not node.child:\\n                return\\n            \\n            for dr, dc in direction:\\n                row, col = r + dr, c + dc\\n                if row in RR and col in CC and (row, col) not in visited and board[row][col] in node.child:\\n                    visited.add((row, col))\\n                    backtracking(row, col, node.child[board[row][col]])\\n                    visited.remove((row, col))\\n            \\n\\n        for i in range(Rows):\\n            for j in range(Cols):\\n                if board[i][j] in tries.root.child:\\n                    visited.add((i, j))\\n                    backtracking(i, j, tries.root.child[board[i][j]])\\n                    visited.remove((i, j))\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.child = {}\\n        self.end = None  # word\\n        \\nclass Tries:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def inser_word(self, word):\\n        \\n        cur = self.root\\n        for c in word:\\n            if c in cur.child:\\n                cur = cur.child[c]\\n            else:\\n                cur.child[c] = Node()\\n                cur = cur.child[c]\\n        cur.end = word\\n\\n    # O(M(4(3**L-1)))\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n    \\n        # tries build tries\\n        # backtracking in each node\\n        # if neibor in node.child\\n        Rows, Cols = len(board), len(board[0])\\n        \\n        tries = Tries()\\n        visited = set()\\n        RR = set(range(Rows))\\n        CC = set(range(Cols))\\n        \\n        for word in words:\\n            tries.inser_word(word)\\n            \\n        words = set(words)\\n        direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        res = set()\\n        \\n        def backtracking(r, c, node):\\n            \\n            if node.end:\\n                res.add(node.end)\\n                \\n            if not node.child:\\n                return\\n            \\n            for dr, dc in direction:\\n                row, col = r + dr, c + dc\\n                if row in RR and col in CC and (row, col) not in visited and board[row][col] in node.child:\\n                    visited.add((row, col))\\n                    backtracking(row, col, node.child[board[row][col]])\\n                    visited.remove((row, col))\\n            \\n\\n        for i in range(Rows):\\n            for j in range(Cols):\\n                if board[i][j] in tries.root.child:\\n                    visited.add((i, j))\\n                    backtracking(i, j, tries.root.child[board[i][j]])\\n                    visited.remove((i, j))\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779588,
                "title": "python-backtracking-with-trie",
                "content": "**Imports and constants**\\n```\\nfrom collections import deque\\nfrom dataclasses import dataclass, field\\nfrom itertools import product\\nfrom typing import Iterable, Optional\\n\\nMOVES = [\\n    (1, 0),\\n    (-1, 0),\\n    (0, 1),\\n    (0, -1),\\n]\\n\\nSPECIAL_CHR = \\'-\\'\\n```\\n\\n**The Solution**\\n```python\\nclass Solution:\\n    def findWords(self, B: list[list[str]], words: list[str]) -> list[str]:\\n        \"\"\"\\n        :param B:\\n        :param words:\\n        :return:\\n        \"\"\"\\n        trie = Trie()\\n        trie.insert_all(words)\\n\\n        m, n = len(B), len(B[0])\\n        output, cur_word = [], deque()\\n\\n        def dfs(x: int, y: int, rt: Node):\\n            if 0 <= x < m and 0 <= y < n and (c := B[x][y]) in rt:\\n                cur_word.append(c)\\n\\n                if (c_node := rt[c]).is_end_of_word:  # current traversal met the end of some word\\n                    output.append(word := \\'\\'.join(cur_word))\\n                    trie.delete(word)\\n\\n                # ------------------------------------------------------#\\n                B[x][y] = SPECIAL_CHR\\n\\n                for dx, dy in MOVES:\\n                    dfs(x + dx, y + dy, c_node)\\n\\n                B[x][y] = c\\n                # ------------------------------------------------------#\\n\\n                cur_word.pop()\\n\\n        for i, j in product(range(m), range(n)):\\n            if trie:  # there are some words in trie\\n                dfs(i, j, trie.root)\\n            else:\\n                # all the words from trie have been removed\\n                break\\n\\n        return output\\n```\\n\\n**Trie Implementation**\\n```python\\n@dataclass\\nclass Node:\\n    \"\"\"\\n    If we only need to do insertion and check if a text is prefix of some word in\\n    the trie, then we do not need \"is_end_of_word\" as well as \"char\"\\n    \"\"\"\\n    char: str = field(default=None)\\n    is_end_of_word: bool = field(default=False)  # True if \"char\" is end of some word in Trie\\n    children: dict[str, \\'Node\\'] = field(default_factory=dict)\\n\\n    def get_or_set(self, c: str) -> \\'Node\\':\\n        if c not in self.children:\\n            self.children[c] = Node(c)\\n\\n        return self.children[c]\\n\\n    def get(self, c: str) -> Optional[\\'Node\\']:\\n        return self.children.get(c)\\n\\n    def delete(self, c: str):\\n        self.children.pop(c)\\n\\n    def __contains__(self, c: str) -> bool:\\n        return c in self.children\\n\\n    def __getitem__(self, c: str) -> \\'Node\\':\\n        return self.children[c]\\n\\n\\n@dataclass\\nclass Trie:\\n    # for root, char is None and is_end_of_word is False, and it can not change ever\\n    root: Node = field(default_factory=Node, init=False)\\n\\n    def insert(self, text: str) -> bool:\\n        \"\"\"\\n        inserting this text into trie.\\n        :param text:\\n        :return: True if text is inserted into the Trie else False\\n        \"\"\"\\n        if not text:  # no text\\n            # inserting this in tries, will make root.is_end_of_word to True,\\n            # so better to return False at this stage\\n            return False\\n\\n        rt = self.root\\n\\n        for c in text:\\n            rt = rt.get_or_set(c)\\n\\n        rt.is_end_of_word = True\\n\\n        return True\\n\\n    def insert_all(self, words: Iterable[str]):\\n        for word in words:\\n            self.insert(word)\\n\\n    def delete(self, text: str) -> bool:\\n        \"\"\"\\n        :param text:\\n        :return: True if this text exists and gets deleted else False\\n        \"\"\"\\n        stk = deque([self.root])\\n\\n        for c in text:\\n            nxt = stk[-1].get(c)\\n\\n            if nxt is None:  # \"text\" is not even a prefix\\n                return False\\n\\n            stk.append(nxt)\\n\\n        peek = stk[-1]\\n\\n        if not peek.is_end_of_word:  # \"text\" is not in trie\\n            return False\\n\\n        peek.is_end_of_word = False\\n\\n        while peek is not self.root and not peek.children and not peek.is_end_of_word:\\n            node = stk.pop()\\n\\n            peek = stk[-1]\\n            peek.delete(node.char)\\n\\n        return True\\n\\n    def __bool__(self) -> bool:\\n        return bool(self.root.children)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nfrom dataclasses import dataclass, field\\nfrom itertools import product\\nfrom typing import Iterable, Optional\\n\\nMOVES = [\\n    (1, 0),\\n    (-1, 0),\\n    (0, 1),\\n    (0, -1),\\n]\\n\\nSPECIAL_CHR = \\'-\\'\\n```\n```python\\nclass Solution:\\n    def findWords(self, B: list[list[str]], words: list[str]) -> list[str]:\\n        \"\"\"\\n        :param B:\\n        :param words:\\n        :return:\\n        \"\"\"\\n        trie = Trie()\\n        trie.insert_all(words)\\n\\n        m, n = len(B), len(B[0])\\n        output, cur_word = [], deque()\\n\\n        def dfs(x: int, y: int, rt: Node):\\n            if 0 <= x < m and 0 <= y < n and (c := B[x][y]) in rt:\\n                cur_word.append(c)\\n\\n                if (c_node := rt[c]).is_end_of_word:  # current traversal met the end of some word\\n                    output.append(word := \\'\\'.join(cur_word))\\n                    trie.delete(word)\\n\\n                # ------------------------------------------------------#\\n                B[x][y] = SPECIAL_CHR\\n\\n                for dx, dy in MOVES:\\n                    dfs(x + dx, y + dy, c_node)\\n\\n                B[x][y] = c\\n                # ------------------------------------------------------#\\n\\n                cur_word.pop()\\n\\n        for i, j in product(range(m), range(n)):\\n            if trie:  # there are some words in trie\\n                dfs(i, j, trie.root)\\n            else:\\n                # all the words from trie have been removed\\n                break\\n\\n        return output\\n```\n```python\\n@dataclass\\nclass Node:\\n    \"\"\"\\n    If we only need to do insertion and check if a text is prefix of some word in\\n    the trie, then we do not need \"is_end_of_word\" as well as \"char\"\\n    \"\"\"\\n    char: str = field(default=None)\\n    is_end_of_word: bool = field(default=False)  # True if \"char\" is end of some word in Trie\\n    children: dict[str, \\'Node\\'] = field(default_factory=dict)\\n\\n    def get_or_set(self, c: str) -> \\'Node\\':\\n        if c not in self.children:\\n            self.children[c] = Node(c)\\n\\n        return self.children[c]\\n\\n    def get(self, c: str) -> Optional[\\'Node\\']:\\n        return self.children.get(c)\\n\\n    def delete(self, c: str):\\n        self.children.pop(c)\\n\\n    def __contains__(self, c: str) -> bool:\\n        return c in self.children\\n\\n    def __getitem__(self, c: str) -> \\'Node\\':\\n        return self.children[c]\\n\\n\\n@dataclass\\nclass Trie:\\n    # for root, char is None and is_end_of_word is False, and it can not change ever\\n    root: Node = field(default_factory=Node, init=False)\\n\\n    def insert(self, text: str) -> bool:\\n        \"\"\"\\n        inserting this text into trie.\\n        :param text:\\n        :return: True if text is inserted into the Trie else False\\n        \"\"\"\\n        if not text:  # no text\\n            # inserting this in tries, will make root.is_end_of_word to True,\\n            # so better to return False at this stage\\n            return False\\n\\n        rt = self.root\\n\\n        for c in text:\\n            rt = rt.get_or_set(c)\\n\\n        rt.is_end_of_word = True\\n\\n        return True\\n\\n    def insert_all(self, words: Iterable[str]):\\n        for word in words:\\n            self.insert(word)\\n\\n    def delete(self, text: str) -> bool:\\n        \"\"\"\\n        :param text:\\n        :return: True if this text exists and gets deleted else False\\n        \"\"\"\\n        stk = deque([self.root])\\n\\n        for c in text:\\n            nxt = stk[-1].get(c)\\n\\n            if nxt is None:  # \"text\" is not even a prefix\\n                return False\\n\\n            stk.append(nxt)\\n\\n        peek = stk[-1]\\n\\n        if not peek.is_end_of_word:  # \"text\" is not in trie\\n            return False\\n\\n        peek.is_end_of_word = False\\n\\n        while peek is not self.root and not peek.children and not peek.is_end_of_word:\\n            node = stk.pop()\\n\\n            peek = stk[-1]\\n            peek.delete(node.char)\\n\\n        return True\\n\\n    def __bool__(self) -> bool:\\n        return bool(self.root.children)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779573,
                "title": "javascript-trie-valid-true",
                "content": "```\\nvar findWords = function(board, words) {\\n    var i, j, tr;\\n    let used = new Array(board.length);\\n    let trie = {};\\n    let results = new Set();\\n    \\n    for( i of words ) {\\n        tr = trie;\\n        for( j=0; j<i.length; j++ ) {\\n            if( !(i[j] in tr) ) tr[i[j]] = {};\\n            tr = tr[i[j]];\\n        }\\n        tr.valid = i;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        used[i] = new Array(board[0].length);\\n    }\\n        \\n    let search = function(i, j, trie) {\\n        var tr;\\n        if( i >= board.length || j >= board[0].length || i < 0 || j < 0 ) return;\\n        if( used[i][j] === true ) return;\\n        if( !(board[i][j] in trie) ) return;\\n\\n        tr = trie[ board[i][j] ];\\n        used[i][j] = true;\\n        if( \\'valid\\' in tr )\\n            results.add(tr.valid);\\n        search(i+1, j, tr);\\n        search(i-1, j, tr);\\n        search(i, j+1, tr);\\n        search(i, j-1, tr);\\n        used[i][j] = false;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        for( j=0; j<board[0].length; j++ ) {\\n            search(i, j, trie);\\n        }\\n    }\\n    \\n    return [...results];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findWords = function(board, words) {\\n    var i, j, tr;\\n    let used = new Array(board.length);\\n    let trie = {};\\n    let results = new Set();\\n    \\n    for( i of words ) {\\n        tr = trie;\\n        for( j=0; j<i.length; j++ ) {\\n            if( !(i[j] in tr) ) tr[i[j]] = {};\\n            tr = tr[i[j]];\\n        }\\n        tr.valid = i;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        used[i] = new Array(board[0].length);\\n    }\\n        \\n    let search = function(i, j, trie) {\\n        var tr;\\n        if( i >= board.length || j >= board[0].length || i < 0 || j < 0 ) return;\\n        if( used[i][j] === true ) return;\\n        if( !(board[i][j] in trie) ) return;\\n\\n        tr = trie[ board[i][j] ];\\n        used[i][j] = true;\\n        if( \\'valid\\' in tr )\\n            results.add(tr.valid);\\n        search(i+1, j, tr);\\n        search(i-1, j, tr);\\n        search(i, j+1, tr);\\n        search(i, j-1, tr);\\n        used[i][j] = false;\\n    }\\n    \\n    for( i=0; i<board.length; i++ ) {\\n        for( j=0; j<board[0].length; j++ ) {\\n            search(i, j, trie);\\n        }\\n    }\\n    \\n    return [...results];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778092,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    struct TrieNode {\\n        TrieNode *children[26];\\n        string word;\\n\\n        TrieNode() : word(\"\") {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = nullptr;\\n            }\\n        }\\n    };\\n\\npublic:\\n    vector<string> findWords(vector<vector<char>> &board, vector<string> &words) {\\n        TrieNode *root = buildTrie(words);\\n        vector<string> result;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                dfs(board, i, j, root, result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    TrieNode *buildTrie(vector<string> &words) {\\n        TrieNode *root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            string word = words[j];\\n            TrieNode *curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word[i] - \\'a\\';\\n                if (curr->children[c] == nullptr) {\\n                    curr->children[c] = new TrieNode();\\n                }\\n                curr = curr->children[c];\\n            }\\n            curr->word = word;\\n        }\\n        return root;\\n    }\\n\\n    void dfs(vector<vector<char>> &board, int i, int j, TrieNode *p, vector<string> &result) {\\n        char c = board[i][j];\\n        if (c == \\'#\\' || !p->children[c - \\'a\\']) return;\\n        p = p->children[c - \\'a\\'];\\n        if (p->word.size() > 0) {\\n            result.push_back(p->word);\\n            p->word = \"\";\\n        }\\n\\n        board[i][j] = \\'#\\';\\n        if (i > 0) dfs(board, i - 1, j, p, result);\\n        if (j > 0) dfs(board, i, j - 1, p, result);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, p, result);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, p, result);\\n        board[i][j] = c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678311,
                "title": "java-optimized-solution-with-easy-steps-and-tc-analysis",
                "content": "**UPVOTE if you found it helpful**\\n```\\n1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the answers.\\n```\\n```\\nclass Solution {\\n    \\n    class TrieNode{\\n        HashMap<Character, TrieNode> chain;\\n        boolean isWord;\\n        String word;\\n        \\n        public TrieNode(){\\n            this.chain = new HashMap<>();\\n            isWord = false;\\n            word = \"\";\\n        }\\n        public boolean contains(char c){\\n            return this.chain.containsKey(c);\\n        }\\n        public void put(char c, TrieNode n){\\n            this.chain.put(c, n);\\n            n.word = this.word + c;\\n        }\\n        public TrieNode get(char c){\\n            return this.chain.get(c);\\n        }\\n        public void setWord(boolean b){\\n            this.isWord = b;\\n            \\n        }\\n        public boolean isWord(){\\n            return this.isWord;\\n        }\\n        public String getWord(){\\n            return this.word.toString();\\n        }\\n    }\\n    \\n    private TrieNode addWords(String [] words){\\n        TrieNode root = new TrieNode();\\n        \\n        for(String word : words){\\n            TrieNode curr = root;\\n            for(char c : word.toCharArray()){\\n                if(!curr.contains(c)){\\n                    curr.put(c, new TrieNode());\\n                }\\n                curr = curr.get(c);\\n            }\\n            curr.setWord(true);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    //[OPTIMIZED] TC = O(m * n * dfs( min(4^word, m * n )) <- m = board.length, n = board[0].length, word = longest(length of word in words)\\n    // SC = min(word, m*n)\\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        \\n        /*\\n            1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the anwsers.\\n        */\\n        \\n        List<String> ans = new ArrayList<>();\\n        TrieNode root = addWords(words);\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                backtrack(board, root, i, j, ans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void backtrack(char[][]board, TrieNode node, int i, int j, List<String>ans){\\n\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length ||\\n           !node.contains(board[i][j]) || board[i][j] == \\'#\\'){\\n            return;\\n        }\\n        \\n        char c  = board[i][j];\\n        \\n        node = node.get(c);\\n        \\n        if(node.isWord()){\\n            ans.add(node.getWord());\\n            node.setWord(false);\\n        }\\n\\n        board[i][j] = \\'#\\'; // visited;\\n        \\n        backtrack(board, node, i+1, j, ans);\\n        backtrack(board, node, i-1, j, ans);\\n        backtrack(board, node, i, j+1, ans);\\n        backtrack(board, node, i, j-1, ans);\\n\\n        board[i][j] = c; // removed from visited        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the answers.\\n```\n```\\nclass Solution {\\n    \\n    class TrieNode{\\n        HashMap<Character, TrieNode> chain;\\n        boolean isWord;\\n        String word;\\n        \\n        public TrieNode(){\\n            this.chain = new HashMap<>();\\n            isWord = false;\\n            word = \"\";\\n        }\\n        public boolean contains(char c){\\n            return this.chain.containsKey(c);\\n        }\\n        public void put(char c, TrieNode n){\\n            this.chain.put(c, n);\\n            n.word = this.word + c;\\n        }\\n        public TrieNode get(char c){\\n            return this.chain.get(c);\\n        }\\n        public void setWord(boolean b){\\n            this.isWord = b;\\n            \\n        }\\n        public boolean isWord(){\\n            return this.isWord;\\n        }\\n        public String getWord(){\\n            return this.word.toString();\\n        }\\n    }\\n    \\n    private TrieNode addWords(String [] words){\\n        TrieNode root = new TrieNode();\\n        \\n        for(String word : words){\\n            TrieNode curr = root;\\n            for(char c : word.toCharArray()){\\n                if(!curr.contains(c)){\\n                    curr.put(c, new TrieNode());\\n                }\\n                curr = curr.get(c);\\n            }\\n            curr.setWord(true);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    //[OPTIMIZED] TC = O(m * n * dfs( min(4^word, m * n )) <- m = board.length, n = board[0].length, word = longest(length of word in words)\\n    // SC = min(word, m*n)\\n    public List<String> findWords(char[][] board, String[] words) {\\n       \\n        \\n        /*\\n            1 -> Create Trie with words\\n            2 -> iterate through the board \\n                -> run dfs (backtracking) for every pos pasing the root of the Trie\\n                    3 -> check if the current char is in the Trie and mark it as visited\\n                            -> if the current char forms a Word from the Trie\\n                                -> add it to ans list\\n                                -> remove the word from the Trie (duplicate, word apper in board > 1)\\n                            -> backtrack in all 4 directions\\n                                -> mark it as unvisted (remove it from visited)\\n\\n            4 -> return the list with the anwsers.\\n        */\\n        \\n        List<String> ans = new ArrayList<>();\\n        TrieNode root = addWords(words);\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                backtrack(board, root, i, j, ans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void backtrack(char[][]board, TrieNode node, int i, int j, List<String>ans){\\n\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length ||\\n           !node.contains(board[i][j]) || board[i][j] == \\'#\\'){\\n            return;\\n        }\\n        \\n        char c  = board[i][j];\\n        \\n        node = node.get(c);\\n        \\n        if(node.isWord()){\\n            ans.add(node.getWord());\\n            node.setWord(false);\\n        }\\n\\n        board[i][j] = \\'#\\'; // visited;\\n        \\n        backtrack(board, node, i+1, j, ans);\\n        backtrack(board, node, i-1, j, ans);\\n        backtrack(board, node, i, j+1, ans);\\n        backtrack(board, node, i, j-1, ans);\\n\\n        board[i][j] = c; // removed from visited        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375535,
                "title": "python-dfs-trie-exhaustion",
                "content": "Idea 1: The idea is to trim the trie branches once all the words in the branch are found.\\nIdea 2: sort the words in reverse order to help trie trimming faster\\n\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        solution = set()\\n        trie = self.make_trie(words)\\n        visited = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(i,j,board,trie,visited,\"\",solution)\\n        return solution\\n    \\n    def dfs(self,i,j,board,trie,visited,word,solution):\\n        if \"*\" in trie:\\n            if len(trie.keys()) == 0:\\n                return\\n            else:\\n                solution.add(word)\\n                del trie[\"*\"]\\n        if (i,j) in visited:\\n            return\\n        if (i < 0 or i == len(board) or j < 0 or j == len(board[0])):\\n            return\\n        if board[i][j] not in trie:\\n            return\\n        if len(trie[board[i][j]]) == 0:\\n            del trie[board[i][j]]\\n            return\\n        visited.add((i,j))\\n        neighbours = [(i,j-1),(i-1,j),(i,j+1),(i+1,j)]\\n        for n_x,n_y in neighbours:\\n            self.dfs(n_x,n_y,board,trie[board[i][j]],visited,word+board[i][j],solution)    \\n        visited.remove((i,j))\\n        \\n    def make_trie(self,words):\\n        trie = {}\\n        for word in words:\\n            current = trie\\n            for char in word:\\n                if char not in current:\\n                    current[char] = {}\\n                current = current[char]\\n            current[\"*\"] = \"*\"\\n        return trie\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        solution = set()\\n        trie = self.make_trie(words)\\n        visited = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                self.dfs(i,j,board,trie,visited,\"\",solution)\\n        return solution\\n    \\n    def dfs(self,i,j,board,trie,visited,word,solution):\\n        if \"*\" in trie:\\n            if len(trie.keys()) == 0:\\n                return\\n            else:\\n                solution.add(word)\\n                del trie[\"*\"]\\n        if (i,j) in visited:\\n            return\\n        if (i < 0 or i == len(board) or j < 0 or j == len(board[0])):\\n            return\\n        if board[i][j] not in trie:\\n            return\\n        if len(trie[board[i][j]]) == 0:\\n            del trie[board[i][j]]\\n            return\\n        visited.add((i,j))\\n        neighbours = [(i,j-1),(i-1,j),(i,j+1),(i+1,j)]\\n        for n_x,n_y in neighbours:\\n            self.dfs(n_x,n_y,board,trie[board[i][j]],visited,word+board[i][j],solution)    \\n        visited.remove((i,j))\\n        \\n    def make_trie(self,words):\\n        trie = {}\\n        for word in words:\\n            current = trie\\n            for char in word:\\n                if char not in current:\\n                    current[char] = {}\\n                current = current[char]\\n            current[\"*\"] = \"*\"\\n        return trie\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370977,
                "title": "c-trie-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    \\n    struct Trie {\\n        Trie *child[26];\\n        bool isEndOfWord;\\n        string str;\\n        \\n        Trie(){\\n            isEndOfWord = false;\\n            str = \"\";\\n            for(int i=0; i<26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie *root = new Trie();\\n    \\n    void insert(string &word) {\\n        \\n        Trie *curr = root;\\n        \\n        for(int i=0; i<word.size(); i++) {\\n            int index = word[i]-\\'a\\';\\n            \\n            if(!curr->child[index])\\n                curr->child[index] = new Trie();\\n            \\n            curr = curr->child[index];\\n        }\\n        \\n        curr->isEndOfWord = true;\\n        curr->str = word;\\n    }\\n    \\n    void trieSearchDFS(vector<vector<char>>& board, Trie *curr, int i, int j, int row, int col) {\\n        \\n        if(i<0 || i>row || j<0 || j>col || board[i][j] == \\'@\\')\\n            return;\\n        \\n        //int index = board[i][j]-\\'a\\';\\n        curr = curr->child[board[i][j]-\\'a\\'];\\n        \\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->isEndOfWord){\\n            result.push_back(curr->str);\\n            curr->isEndOfWord = false;\\n        }\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'@\\';\\n        \\n        if(i-1>=0)\\n            trieSearchDFS(board,curr,i-1,j,row,col);\\n        if(j+1<col)\\n            trieSearchDFS(board,curr,i,j+1,row,col);\\n        if(i+1<row)\\n            trieSearchDFS(board,curr,i+1,j,row,col);\\n        if(j-1>=0)\\n            trieSearchDFS(board,curr,i,j-1,row,col);\\n        \\n        board[i][j] = ch;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        int row = board.size();\\n        int col = board[0].size();\\n        \\n        for(int i=0; i<words.size(); i++)\\n            insert(words[i]);\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                trieSearchDFS(board,root,i,j,row,col);\\n            }\\n        }\\n       return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    \\n    struct Trie {\\n        Trie *child[26];\\n        bool isEndOfWord;\\n        string str;\\n        \\n        Trie(){\\n            isEndOfWord = false;\\n            str = \"\";\\n            for(int i=0; i<26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie *root = new Trie();\\n    \\n    void insert(string &word) {\\n        \\n        Trie *curr = root;\\n        \\n        for(int i=0; i<word.size(); i++) {\\n            int index = word[i]-\\'a\\';\\n            \\n            if(!curr->child[index])\\n                curr->child[index] = new Trie();\\n            \\n            curr = curr->child[index];\\n        }\\n        \\n        curr->isEndOfWord = true;\\n        curr->str = word;\\n    }\\n    \\n    void trieSearchDFS(vector<vector<char>>& board, Trie *curr, int i, int j, int row, int col) {\\n        \\n        if(i<0 || i>row || j<0 || j>col || board[i][j] == \\'@\\')\\n            return;\\n        \\n        //int index = board[i][j]-\\'a\\';\\n        curr = curr->child[board[i][j]-\\'a\\'];\\n        \\n        if(curr == NULL)\\n            return;\\n        \\n        if(curr->isEndOfWord){\\n            result.push_back(curr->str);\\n            curr->isEndOfWord = false;\\n        }\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'@\\';\\n        \\n        if(i-1>=0)\\n            trieSearchDFS(board,curr,i-1,j,row,col);\\n        if(j+1<col)\\n            trieSearchDFS(board,curr,i,j+1,row,col);\\n        if(i+1<row)\\n            trieSearchDFS(board,curr,i+1,j,row,col);\\n        if(j-1>=0)\\n            trieSearchDFS(board,curr,i,j-1,row,col);\\n        \\n        board[i][j] = ch;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        int row = board.size();\\n        int col = board[0].size();\\n        \\n        for(int i=0; i<words.size(); i++)\\n            insert(words[i]);\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                trieSearchDFS(board,root,i,j,row,col);\\n            }\\n        }\\n       return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351408,
                "title": "python3-solution-99-more-faster-39-ms",
                "content": "![image](https://assets.leetcode.com/users/images/2c44c6a0-dbce-459d-a577-ef38d01bdcde_1659111005.250889.png)\\n```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m = len(board)\\n        n = len(board[0])\\n        res = []\\n\\n        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n        ref = set()\\n        for i in range(m):\\n            for j in range(n-1):\\n                ref.add(board[i][j] + board[i][j+1])\\n        for j in range(n):\\n            for i in range(m-1):\\n                ref.add(board[i][j] + board[i+1][j])\\n\\n        for word in words:\\n            f = True\\n            for i in range(len(word)-1):\\n                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:\\n                    f = False\\n                    break\\n            if not f:\\n                continue\\n            if self.findWord(word, m, n, board, d):\\n                res.append(word)\\n        return res\\n    \\n    def findWord(self, word, m, n, board, d) -> bool:\\n        if word[:4] == word[0] * 4:\\n            word = \\'\\'.join([c for c in reversed(word)])\\n        starts = []\\n        stack = []\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    if len(word) == 1:\\n                        return True\\n                    starts.append((i, j))\\n        for start in starts:\\n            stack.append(start)\\n            visited.add((start, ))\\n            l = 1\\n            while stack != [] and l < len(word):\\n                x, y = stack[-1]\\n                for dxy in d:\\n                    nx, ny = x + dxy[0], y + dxy[1]\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        if board[nx][ny] == word[l]:\\n                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:\\n                                stack.append((nx, ny))\\n                                visited.add(tuple(stack))\\n                                l += 1\\n                                if l == len(word):\\n                                    return True\\n                                break\\n                else:\\n                    stack.pop()\\n                    l -= 1\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m = len(board)\\n        n = len(board[0])\\n        res = []\\n\\n        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n        ref = set()\\n        for i in range(m):\\n            for j in range(n-1):\\n                ref.add(board[i][j] + board[i][j+1])\\n        for j in range(n):\\n            for i in range(m-1):\\n                ref.add(board[i][j] + board[i+1][j])\\n\\n        for word in words:\\n            f = True\\n            for i in range(len(word)-1):\\n                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:\\n                    f = False\\n                    break\\n            if not f:\\n                continue\\n            if self.findWord(word, m, n, board, d):\\n                res.append(word)\\n        return res\\n    \\n    def findWord(self, word, m, n, board, d) -> bool:\\n        if word[:4] == word[0] * 4:\\n            word = \\'\\'.join([c for c in reversed(word)])\\n        starts = []\\n        stack = []\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    if len(word) == 1:\\n                        return True\\n                    starts.append((i, j))\\n        for start in starts:\\n            stack.append(start)\\n            visited.add((start, ))\\n            l = 1\\n            while stack != [] and l < len(word):\\n                x, y = stack[-1]\\n                for dxy in d:\\n                    nx, ny = x + dxy[0], y + dxy[1]\\n                    if 0 <= nx < m and 0 <= ny < n:\\n                        if board[nx][ny] == word[l]:\\n                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:\\n                                stack.append((nx, ny))\\n                                visited.add(tuple(stack))\\n                                l += 1\\n                                if l == len(word):\\n                                    return True\\n                                break\\n                else:\\n                    stack.pop()\\n                    l -= 1\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041937,
                "title": "python-dfs-trie-99-with-trie-optimization",
                "content": "this solution is like the top [solution](https://leetcode.com/problems/word-search-ii/discuss/59790/Python-dfs-solution-(directly-use-Trie-implemented).) from OldCodingFarmer with an extra trick (TLE - 10% -> 80% - 100%).\\n\\nThe idea is to count the number of words with a specific prefix in the Trie.\\nThen at remove time, we traverse the Trie and delete a node if it has a count of 1 (the path contains only the word we want to remove).\\n\\nThis makes the DFS run way faster (since it will know earlier if a path doesn\\'t contain any word).\\n\\ncomment out the line `root.remove(s)` to see the effect of this optimization.\\n\\ncode:\\n\\n```\\nclass Trie(collections.defaultdict):\\n    def __init__(self):\\n        super().__init__(lambda: Trie())\\n        self._is_word = False\\n        self._count = 0\\n    \\n    def add(self, word):\\n        runner = self\\n        runner._count += 1\\n        for c in word:\\n            runner = runner[c]\\n            runner._count += 1\\n        runner._is_word = True\\n        \\n    def remove(self, word):\\n        runner = self\\n        runner._count -= 1\\n        for c in word:\\n            if runner[c]._count == 1:\\n                del runner[c]\\n                return\\n            runner = runner[c]\\n            runner._count -= 1\\n        runner._is_word = False\\n        \\n    def contains(self, word):\\n        runner = self\\n        for c in word:\\n            if runner._count == 0 or c not in runner:\\n                return False\\n            runner = runner[c]\\n        return runner._is_word\\n    \\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        n, m = len(board), len(board[0])\\n        root = Trie()\\n        for word in words:\\n            root.add(word)\\n            \\n        def dfs(i, j, trie, s):\\n            s.append(board[i][j])\\n            trie = trie[board[i][j]]\\n            if trie._is_word:\\n                root.remove(s)\\n                trie._is_word = False\\n                res.append(\"\".join(s))\\n\\n            board[i][j] = \\'#\\'\\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                ni, nj = i+di, j+dj\\n                if 0 <= ni < n and 0 <= nj < m and board[ni][nj] in trie:\\n                    dfs(ni, nj, trie, s)\\n            board[i][j] = s.pop()\\n                \\n        res = []    \\n        for i in range(n):\\n            for j in range(m):\\n                if board[i][j] in root:\\n                    dfs(i, j, root, [])\\n                 \\n        return res           \\n ```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie(collections.defaultdict):\\n    def __init__(self):\\n        super().__init__(lambda: Trie())\\n        self._is_word = False\\n        self._count = 0\\n    \\n    def add(self, word):\\n        runner = self\\n        runner._count += 1\\n        for c in word:\\n            runner = runner[c]\\n            runner._count += 1\\n        runner._is_word = True\\n        \\n    def remove(self, word):\\n        runner = self\\n        runner._count -= 1\\n        for c in word:\\n            if runner[c]._count == 1:\\n                del runner[c]\\n                return\\n            runner = runner[c]\\n            runner._count -= 1\\n        runner._is_word = False\\n        \\n    def contains(self, word):\\n        runner = self\\n        for c in word:\\n            if runner._count == 0 or c not in runner:\\n                return False\\n            runner = runner[c]\\n        return runner._is_word\\n    \\n\\n\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        n, m = len(board), len(board[0])\\n        root = Trie()\\n        for word in words:\\n            root.add(word)\\n            \\n        def dfs(i, j, trie, s):\\n            s.append(board[i][j])\\n            trie = trie[board[i][j]]\\n            if trie._is_word:\\n                root.remove(s)\\n                trie._is_word = False\\n                res.append(\"\".join(s))\\n\\n            board[i][j] = \\'#\\'\\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                ni, nj = i+di, j+dj\\n                if 0 <= ni < n and 0 <= nj < m and board[ni][nj] in trie:\\n                    dfs(ni, nj, trie, s)\\n            board[i][j] = s.pop()\\n                \\n        res = []    \\n        for i in range(n):\\n            for j in range(m):\\n                if board[i][j] in root:\\n                    dfs(i, j, root, [])\\n                 \\n        return res           \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2011717,
                "title": "c-simple-solution-using-trie-dfs",
                "content": "**[C++] Simple solution for searching words on board using DFS & Trie:**\\n\\n```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26] = {};\\n    bool isEnd = false;\\n    \\n    TrieNode() {}\\n    \\n    void addWord(string word) {\\n        TrieNode* curr = this;\\n        for(auto c: word) {\\n            if (!curr->children[c-\\'a\\']) curr->children[c-\\'a\\'] = new TrieNode();\\n            curr = curr->children[c-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* dictionary = new TrieNode();\\n        for (string word: words) {\\n            dictionary->addWord(word);\\n        }\\n        \\n        int m = board.size(), n = board[0].size();\\n        vector<string> result;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                searchRecursively(board, i, j, dictionary, \"\", result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void searchRecursively(vector<vector<char>>& board, int x, int y, TrieNode* dict, string s, vector<string>& result) {\\n        int m = board.size(), n = board[0].size();\\n        if (board[x][y]==\\'#\\' || !dict->children[board[x][y]-\\'a\\']) return;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'#\\';\\n        \\n        if (dict->children[temp-\\'a\\']->isEnd) {\\n            dict->children[temp-\\'a\\']->isEnd = false;\\n            result.push_back(s+temp);\\n        }\\n        \\n        if(x-1>=0) searchRecursively(board, x-1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(x+1<m) searchRecursively(board, x+1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y-1>=0) searchRecursively(board, x, y-1, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y+1<n) searchRecursively(board, x, y+1, dict->children[temp-\\'a\\'], s+temp, result);\\n        \\n        board[x][y] = temp;\\n    }\\n};\\n```\\n\\nPlease do **upvote** if you find this helpful.\\nFeel free to ask queries or share feedback in comments.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26] = {};\\n    bool isEnd = false;\\n    \\n    TrieNode() {}\\n    \\n    void addWord(string word) {\\n        TrieNode* curr = this;\\n        for(auto c: word) {\\n            if (!curr->children[c-\\'a\\']) curr->children[c-\\'a\\'] = new TrieNode();\\n            curr = curr->children[c-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* dictionary = new TrieNode();\\n        for (string word: words) {\\n            dictionary->addWord(word);\\n        }\\n        \\n        int m = board.size(), n = board[0].size();\\n        vector<string> result;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                searchRecursively(board, i, j, dictionary, \"\", result);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void searchRecursively(vector<vector<char>>& board, int x, int y, TrieNode* dict, string s, vector<string>& result) {\\n        int m = board.size(), n = board[0].size();\\n        if (board[x][y]==\\'#\\' || !dict->children[board[x][y]-\\'a\\']) return;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'#\\';\\n        \\n        if (dict->children[temp-\\'a\\']->isEnd) {\\n            dict->children[temp-\\'a\\']->isEnd = false;\\n            result.push_back(s+temp);\\n        }\\n        \\n        if(x-1>=0) searchRecursively(board, x-1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(x+1<m) searchRecursively(board, x+1, y, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y-1>=0) searchRecursively(board, x, y-1, dict->children[temp-\\'a\\'], s+temp, result);\\n        if(y+1<n) searchRecursively(board, x, y+1, dict->children[temp-\\'a\\'], s+temp, result);\\n        \\n        board[x][y] = temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862785,
                "title": "python-trie-dfs-solution",
                "content": "I used separate TrieNode to define the node and addword method in Trie.\\nInsert all words into Trie using addword method. \\nThen DFS. Check at each cell if its in  children of trie node by travesering through borad in all 4 directions.\\n\\n\\n\\t\\n\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children={}\\n\\t\\t\\tself.endOfWord=False\\n\\n\\t\\tdef insert(self,word):\\n\\t\\t\\troot = self\\n\\t\\t\\tfor c in word:\\n\\t\\t\\t\\tif c not in root.children:\\n\\t\\t\\t\\t\\troot.children[c]=TrieNode()\\n\\t\\t\\t\\troot=root.children[c]\\n\\t\\t\\troot.endOfWord = True\\n\\n\\tclass Solution:    \\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\troot = TrieNode()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\troot.insert(word)\\n\\n\\t\\t\\tresult,visit=set(),set()\\n\\t\\t\\tROWS,COLS=len(board),len(board[0])\\n\\n\\t\\t\\tdef dfs(row,col,node,word):\\n\\t\\t\\t\\tif row<0 or col<0  or row==ROWS  or col==COLS or (row,col) in visit or board[row][col] not in node.children:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tnode = node.children[board[row][col]] #update node to current character we just visited\\n\\t\\t\\t\\tword += board[row][col] # we are adding the new character we just visited to the existing word\\n\\t\\t\\t\\tflag=True\\n\\t\\t\\t\\tif node.endOfWord:  #is it end of word\\n\\t\\t\\t\\t\\tresult.add(word) #add the word we built in the result\\n\\t\\t\\t\\t\\tif len(node.children)==0:\\n\\t\\t\\t\\t\\t\\tdel node\\n\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\tif flag:\\n\\t\\t\\t\\t\\tvisit.add((row,col))\\n\\n\\t\\t\\t\\t\\t  # Traverse the words in 4 direction\\n\\t\\t\\t\\t\\tdfs(row+1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row-1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col+1,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col-1,node,word)\\n\\t\\t\\t\\t\\tvisit.remove((row,col))\\n\\n\\t\\t\\tfor row in range(ROWS):\\n\\t\\t\\t\\tfor col in range(COLS):\\n\\t\\t\\t\\t\\tdfs(row,col,root,\"\") #call froom each starting position and word is gonna be empty\\n\\n\\t\\t\\treturn list(result) #cast to list as result is a set\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "I used separate TrieNode to define the node and addword method in Trie.\\nInsert all words into Trie using addword method. \\nThen DFS. Check at each cell if its in  children of trie node by travesering through borad in all 4 directions.\\n\\n\\n\\t\\n\\tclass TrieNode:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.children={}\\n\\t\\t\\tself.endOfWord=False\\n\\n\\t\\tdef insert(self,word):\\n\\t\\t\\troot = self\\n\\t\\t\\tfor c in word:\\n\\t\\t\\t\\tif c not in root.children:\\n\\t\\t\\t\\t\\troot.children[c]=TrieNode()\\n\\t\\t\\t\\troot=root.children[c]\\n\\t\\t\\troot.endOfWord = True\\n\\n\\tclass Solution:    \\n\\t\\tdef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n\\t\\t\\troot = TrieNode()\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\troot.insert(word)\\n\\n\\t\\t\\tresult,visit=set(),set()\\n\\t\\t\\tROWS,COLS=len(board),len(board[0])\\n\\n\\t\\t\\tdef dfs(row,col,node,word):\\n\\t\\t\\t\\tif row<0 or col<0  or row==ROWS  or col==COLS or (row,col) in visit or board[row][col] not in node.children:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tnode = node.children[board[row][col]] #update node to current character we just visited\\n\\t\\t\\t\\tword += board[row][col] # we are adding the new character we just visited to the existing word\\n\\t\\t\\t\\tflag=True\\n\\t\\t\\t\\tif node.endOfWord:  #is it end of word\\n\\t\\t\\t\\t\\tresult.add(word) #add the word we built in the result\\n\\t\\t\\t\\t\\tif len(node.children)==0:\\n\\t\\t\\t\\t\\t\\tdel node\\n\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\tif flag:\\n\\t\\t\\t\\t\\tvisit.add((row,col))\\n\\n\\t\\t\\t\\t\\t  # Traverse the words in 4 direction\\n\\t\\t\\t\\t\\tdfs(row+1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row-1,col,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col+1,node,word)\\n\\t\\t\\t\\t\\tdfs(row,col-1,node,word)\\n\\t\\t\\t\\t\\tvisit.remove((row,col))\\n\\n\\t\\t\\tfor row in range(ROWS):\\n\\t\\t\\t\\tfor col in range(COLS):\\n\\t\\t\\t\\t\\tdfs(row,col,root,\"\") #call froom each starting position and word is gonna be empty\\n\\n\\t\\t\\treturn list(result) #cast to list as result is a set\\n",
                "codeTag": "Java"
            },
            {
                "id": 1771671,
                "title": "js-beats-100",
                "content": "Using two simple optimizations: \\n- We delete words from the Trie once they have been found.\\n\\t- This means that we will no longer search fruitlessly for them.\\n\\t- This also means that we do not need to use a Set but can instead simply append to an Array.\\n- We keep track of what the complete word looks like for each potential completion spot, so that we do not need to reconstruct it\\n\\n```\\nclass Trie {\\n    constructor(words) {\\n        this.data = {};\\n        for(let word of words) {\\n            let current = this.data;\\n            for(let c of word) {\\n                if(!current[c]) current[c] = {count:0};\\n                current = current[c];\\n                // Keep track of how many words are under each node for easy deletion\\n                current.count++;\\n            }\\n            current.complete = word;        \\n        }\\n    }\\n    \\n    remove(word)  {\\n        let current = this.data;\\n        for(let c of word) {\\n            // This method is reliant on Trie keeping a count of how many words are under each node\\n            if(current[c].count === 1) {\\n                // We don\\'t return here because we need to propagate the deletion down the entire chain\\n                let tmp = current;\\n                current = current[c];\\n                tmp[c] = null;\\n            } else {\\n                current[c].count--;\\n                current = current[c];                \\n            }\\n        }\\n        current.complete = null;\\n    }\\n}\\n\\nconst DIRECTIONS = [[0,1],[0,-1],[1,0],[-1,0]];\\n\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst findWords = (board, words) => {\\n    // build Trie\\n    const trie = new Trie(words);\\n    // Need to track visited locations\\n    const visited = Array.from({length: board.length}, \\n                               () => Array.from({length: board[0].length}, () => false));   \\n    // Result array\\n    const result = [];\\n\\n    const dfs = (i, j, trieNode) => {\\n        // Stop here if we have already traversed this location\\n        if(visited[i][j]) return 0;\\n        const c = board[i][j];\\n        // Stop here if we can\\'t continue down the Trie using this letter\\n        if(!trieNode[c]) return 0;\\n        const nextTrie = trieNode[c];\\n        \\n        if(nextTrie.complete) {\\n            result.push(nextTrie.complete);\\n            trie.remove(nextTrie.complete);\\n        }\\n        \\n        // Backtracking recursion in all 4 directions\\n        visited[i][j] = true;\\n        for(let direction of DIRECTIONS) {\\n            const nextI = i + direction[0];\\n            const nextJ = j + direction[1];\\n            if(nextI > -1 && nextI < board.length && \\n               nextJ > -1 && nextJ < board[0].length) {\\n                dfs(nextI, nextJ, nextTrie);\\n            }\\n        }\\n        visited[i][j] = false;\\n    }\\n\\n    // DFS starting at each board position\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            dfs(i,j,trie.data);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Trie {\\n    constructor(words) {\\n        this.data = {};\\n        for(let word of words) {\\n            let current = this.data;\\n            for(let c of word) {\\n                if(!current[c]) current[c] = {count:0};\\n                current = current[c];\\n                // Keep track of how many words are under each node for easy deletion\\n                current.count++;\\n            }\\n            current.complete = word;        \\n        }\\n    }\\n    \\n    remove(word)  {\\n        let current = this.data;\\n        for(let c of word) {\\n            // This method is reliant on Trie keeping a count of how many words are under each node\\n            if(current[c].count === 1) {\\n                // We don\\'t return here because we need to propagate the deletion down the entire chain\\n                let tmp = current;\\n                current = current[c];\\n                tmp[c] = null;\\n            } else {\\n                current[c].count--;\\n                current = current[c];                \\n            }\\n        }\\n        current.complete = null;\\n    }\\n}\\n\\nconst DIRECTIONS = [[0,1],[0,-1],[1,0],[-1,0]];\\n\\n/**\\n * @param {character[][]} board\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst findWords = (board, words) => {\\n    // build Trie\\n    const trie = new Trie(words);\\n    // Need to track visited locations\\n    const visited = Array.from({length: board.length}, \\n                               () => Array.from({length: board[0].length}, () => false));   \\n    // Result array\\n    const result = [];\\n\\n    const dfs = (i, j, trieNode) => {\\n        // Stop here if we have already traversed this location\\n        if(visited[i][j]) return 0;\\n        const c = board[i][j];\\n        // Stop here if we can\\'t continue down the Trie using this letter\\n        if(!trieNode[c]) return 0;\\n        const nextTrie = trieNode[c];\\n        \\n        if(nextTrie.complete) {\\n            result.push(nextTrie.complete);\\n            trie.remove(nextTrie.complete);\\n        }\\n        \\n        // Backtracking recursion in all 4 directions\\n        visited[i][j] = true;\\n        for(let direction of DIRECTIONS) {\\n            const nextI = i + direction[0];\\n            const nextJ = j + direction[1];\\n            if(nextI > -1 && nextI < board.length && \\n               nextJ > -1 && nextJ < board[0].length) {\\n                dfs(nextI, nextJ, nextTrie);\\n            }\\n        }\\n        visited[i][j] = false;\\n    }\\n\\n    // DFS starting at each board position\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            dfs(i,j,trie.data);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667325,
                "title": "python-solution-with-optimization-and-comments",
                "content": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = collections.defaultdict(TrieNode)\\n        self.isEnd = False\\n        self.word = None\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for ch in word:\\n            node = node.child[ch]\\n        node.isEnd = True\\n        node.word = word\\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if len(board) == 0 or len(words) == 0:\\n            return []\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie.root.child:\\n                    self.dfs(board, trie.root, m, n, i, j, res)\\n        return res\\n    \\n    def dfs(self, board, parent, m, n, x, y, res):\\n        ch = board[x][y]\\n        node = parent.child[ch]\\n        \\n        if node.isEnd:\\n            res.append(node.word)\\n            node.isEnd = False # avoid duplicates\\n            # Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        \\n        board[x][y] = \"#\"\\n        for new_x, new_y in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:\\n            if 0 <= new_x < m and 0 <= new_y < n and board[new_x][new_y] in node.child:\\n                self.dfs(board, node, m, n, new_x, new_y, res)\\n        board[x][y] = ch\\n        \\n        # hit the end of trie leaf node, if already checking \"abcd\" in trie leaf, (whether it works or not)\\n        # we don\\'t need to spend time checking \"abcde\" word \\n        if not node.child:\\n            parent.child.pop(ch)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = collections.defaultdict(TrieNode)\\n        self.isEnd = False\\n        self.word = None\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for ch in word:\\n            node = node.child[ch]\\n        node.isEnd = True\\n        node.word = word\\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if len(board) == 0 or len(words) == 0:\\n            return []\\n        \\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        \\n        res = []\\n        m, n = len(board), len(board[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] in trie.root.child:\\n                    self.dfs(board, trie.root, m, n, i, j, res)\\n        return res\\n    \\n    def dfs(self, board, parent, m, n, x, y, res):\\n        ch = board[x][y]\\n        node = parent.child[ch]\\n        \\n        if node.isEnd:\\n            res.append(node.word)\\n            node.isEnd = False # avoid duplicates\\n            # Don\\'t RETURN since child.word can be a prefix of other words, e.g., \\'ane\\' and \\'aneis\\'\\n        \\n        board[x][y] = \"#\"\\n        for new_x, new_y in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:\\n            if 0 <= new_x < m and 0 <= new_y < n and board[new_x][new_y] in node.child:\\n                self.dfs(board, node, m, n, new_x, new_y, res)\\n        board[x][y] = ch\\n        \\n        # hit the end of trie leaf node, if already checking \"abcd\" in trie leaf, (whether it works or not)\\n        # we don\\'t need to spend time checking \"abcde\" word \\n        if not node.child:\\n            parent.child.pop(ch)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354554,
                "title": "hack-reverse-search-python3",
                "content": "Consider this simple algorithm:\\n\\n```\\nfor i in range(rows):\\n\\tfor j in range(cols):\\n\\t    for word in words:\\n\\t\\t    search(board[i][j], word)\\n```\\n\\nSimply, we are searching every cell for every word. This algorithm will fail on the final test case. Why?\\n\\nConsider this `board[][]` with `words[]`.\\n\\n```\\n words[] = [                +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzo\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzp\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzq\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzr\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzs\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzt\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzu\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzv\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzw\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzx\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzy\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzz\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n ]                          | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n```\\n\\nThe simple approach from before will fail because the worst-case inputs, `\"ababab...\"`, were deliberately crafted to increase our search time exponentially. But wait, notice how the last few characters of each `word` in `words[]` **have** to be distinct from the `\"ababab...\"` pattern? Do you know why this has to be the case? What do you think will happen if we search each cell for `reverse(word)` instead of `word`? The full solution, along with a screenshot of its performance, are attached at the bottom.\\n\\nThe [Trie](https://en.wikipedia.org/wiki/Trie) data structure, which is part of the intended solution, is extremely powerful. It can be used to solve a great number of complex problems. For this problem, however, the sample answer overly engineered.\\n\\n```Python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        visited = set()\\n        results = set()\\n        \\n        # Hack. Reverse the string to look for.\\n        for i in range(len(words)):\\n            words[i] = words[i][::-1]\\n        \\n        # Normal dfs.\\n        def dfs(i, j, idx, word):\\n            if word in results   : return\\n            if i < 0 or rows <= i: return\\n            if j < 0 or cols <= j: return\\n            \\n            visited.add((i, j))\\n            \\n            if board[i][j] != word[idx]:\\n                pass\\n                \\n            elif idx == len(word)-1:\\n                results.add(word)\\n            \\n            else:\\n                if (i-1, j) not in visited: dfs(i-1, j, idx+1, word)\\n                if (i+1, j) not in visited: dfs(i+1, j, idx+1, word)\\n                if (i, j-1) not in visited: dfs(i, j-1, idx+1, word)\\n                if (i, j+1) not in visited: dfs(i, j+1, idx+1, word)\\n            \\n            visited.remove((i, j))\\n        \\n        # For every cell, search every word.\\n        for i in range(rows):\\n            for j in range(cols):\\n                for word in words:\\n                    if word not in results:\\n                        dfs(i, j, 0, word)\\n            \\n        return [word[::-1] for word in results]\\n```\\n![image](https://assets.leetcode.com/users/images/f609fc9f-7332-4007-a390-6d4e551ca55f_1626943852.1561491.png)",
                "solutionTags": [],
                "code": "```\\nfor i in range(rows):\\n\\tfor j in range(cols):\\n\\t    for word in words:\\n\\t\\t    search(board[i][j], word)\\n```\n```\\n words[] = [                +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzo\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzp\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzq\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzr\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzs\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzt\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzu\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzv\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzw\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzx\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n     \"ababababzy\",          | a | b | a | b | a | b | a | b | a | b | a | \\n     \"ababababzz\",          +---+---+---+---+---+---+---+---+---+---+---+ \\n ]                          | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n                            | a | b | a | b | a | b | a | b | a | b | a | \\n                            +---+---+---+---+---+---+---+---+---+---+---+ \\n```\n```Python\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        visited = set()\\n        results = set()\\n        \\n        # Hack. Reverse the string to look for.\\n        for i in range(len(words)):\\n            words[i] = words[i][::-1]\\n        \\n        # Normal dfs.\\n        def dfs(i, j, idx, word):\\n            if word in results   : return\\n            if i < 0 or rows <= i: return\\n            if j < 0 or cols <= j: return\\n            \\n            visited.add((i, j))\\n            \\n            if board[i][j] != word[idx]:\\n                pass\\n                \\n            elif idx == len(word)-1:\\n                results.add(word)\\n            \\n            else:\\n                if (i-1, j) not in visited: dfs(i-1, j, idx+1, word)\\n                if (i+1, j) not in visited: dfs(i+1, j, idx+1, word)\\n                if (i, j-1) not in visited: dfs(i, j-1, idx+1, word)\\n                if (i, j+1) not in visited: dfs(i, j+1, idx+1, word)\\n            \\n            visited.remove((i, j))\\n        \\n        # For every cell, search every word.\\n        for i in range(rows):\\n            for j in range(cols):\\n                for word in words:\\n                    if word not in results:\\n                        dfs(i, j, 0, word)\\n            \\n        return [word[::-1] for word in results]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323358,
                "title": "c-simple-and-easy-trie-dfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        unordered_map <char, TrieNode*> children;\\n        bool endofword;\\n        string word = \"\";\\n    };\\n    \\n    TrieNode* getNewNode(){\\n        TrieNode *new_node= new TrieNode();\\n        new_node->endofword=false;\\n        return new_node;\\n    }\\n    \\n    void insertInTrie(string s, TrieNode **root){\\n        if(*root==NULL) *root= getNewNode();\\n        TrieNode* ptr= *root;\\n        for(int i=0;i<s.length();i++){\\n            if(ptr->children.find(s[i])==ptr->children.end()){\\n                ptr->children[s[i]]=getNewNode();\\n            }\\n            ptr= ptr->children[s[i]];\\n        }\\n        ptr->endofword=true;   \\n        ptr->word=s;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode *root, vector <string> &res){\\n        char c= board[i][j];\\n        if(c==\\'#\\' || root->children.find(c)==root->children.end()) return;\\n        \\n        root = root->children[c];\\n        \\n        board[i][j]= \\'#\\';\\n        if(root->endofword==true) root->endofword=false, res.push_back(root->word);\\n        \\n        if (i > 0) dfs(board, i - 1, j, root, res);\\n        if (j > 0) dfs(board, i, j - 1, root, res);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, root, res);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, root, res);\\n        board[i][j] = c;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *head= NULL;\\n        vector <string> res;\\n        int m= board.size();\\n        int n= board[0].size();\\n        for(int i=0;i<words.size();i++){\\n            insertInTrie(words[i], &head);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dfs(board, i, j, head, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        unordered_map <char, TrieNode*> children;\\n        bool endofword;\\n        string word = \"\";\\n    };\\n    \\n    TrieNode* getNewNode(){\\n        TrieNode *new_node= new TrieNode();\\n        new_node->endofword=false;\\n        return new_node;\\n    }\\n    \\n    void insertInTrie(string s, TrieNode **root){\\n        if(*root==NULL) *root= getNewNode();\\n        TrieNode* ptr= *root;\\n        for(int i=0;i<s.length();i++){\\n            if(ptr->children.find(s[i])==ptr->children.end()){\\n                ptr->children[s[i]]=getNewNode();\\n            }\\n            ptr= ptr->children[s[i]];\\n        }\\n        ptr->endofword=true;   \\n        ptr->word=s;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode *root, vector <string> &res){\\n        char c= board[i][j];\\n        if(c==\\'#\\' || root->children.find(c)==root->children.end()) return;\\n        \\n        root = root->children[c];\\n        \\n        board[i][j]= \\'#\\';\\n        if(root->endofword==true) root->endofword=false, res.push_back(root->word);\\n        \\n        if (i > 0) dfs(board, i - 1, j, root, res);\\n        if (j > 0) dfs(board, i, j - 1, root, res);\\n        if (i < board.size() - 1) dfs(board, i + 1, j, root, res);\\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, root, res);\\n        board[i][j] = c;\\n        \\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode *head= NULL;\\n        vector <string> res;\\n        int m= board.size();\\n        int n= board[0].size();\\n        for(int i=0;i<words.size();i++){\\n            insertInTrie(words[i], &head);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dfs(board, i, j, head, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186193,
                "title": "c-using-trie-dfs-set-for-storing-unique-result-mark-terminal-false-once-stored",
                "content": "int rows[]={1,-1,0,0};\\nint cols[]={0,0,1,-1};\\nclass node{\\npublic:\\n\\n\\tchar ch;\\n\\tbool isTerminal;\\n\\tstring name;\\n\\tunordered_map<char,node*> child;\\t\\n\\tnode(char ch){\\n\\t\\tthis->ch=ch;\\n\\t\\tisTerminal=false;\\n\\t}\\n};\\n\\nclass Trie{\\npublic:\\n\\n\\tnode*root;\\n\\tTrie(){\\n\\t\\troot=new node(\\'\\\\0\\');\\n\\t}\\n\\tvoid insert(string str){\\n\\t\\tnode*temp=root;\\n\\t\\tfor(int i=0;i<str.length();i++){\\n\\t\\t\\tchar ch=str[i];\\n\\t\\t\\tif(temp->child[ch]!=0){\\n\\t\\t\\t\\ttemp=temp->child[ch];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\ttemp->child[ch]=new node(ch);\\n\\t\\t\\t\\ttemp=temp->child[ch];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttemp->isTerminal=true;\\n\\t\\ttemp->name=str;\\n\\t}\\n};\\nclass Solution {\\npublic:\\n\\n\\tbool visited[1000][1000]={false};\\n\\tvoid find_word(vector<vector<char>>&board,int i,int j,node*temp,set<string>&s){\\n\\t\\tif(temp->isTerminal){\\n\\t\\t\\tif(i<0 or j<0 or i>=board.size() or j>=board[i].size() ){\\n\\t\\t\\t\\ts.insert(temp->name);\\n\\t\\t\\t\\ttemp->isTerminal=false;\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tif(temp->child.count(board[i][j])!=0){\\n\\t\\t\\t\\tfor(int k=0;k<4;k++){\\n\\t\\t\\t\\t\\tfind_word(board,i+rows[k],j+cols[k],temp->child[board[i][j]],s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\ts.insert(temp->name);\\n\\t\\t\\ttemp->isTerminal=false;\\n\\t\\t    return ;\\n\\t\\t}\\n\\t\\tif(i<0 or j<0 or i>=board.size() or j>=board[i].size() or visited[i][j]){\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tchar ch=board[i][j];\\n\\t\\tvisited[i][j]=true;\\n\\t\\tif(temp->child.count(ch)==0){\\n\\t\\t\\tvisited[i][j]=false;\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\n\\t\\tfor(int k=0;k<4;k++){\\n\\t\\t\\tfind_word(board,i+rows[k],j+cols[k],temp->child[ch],s);\\n\\t\\t}\\n\\t\\tvisited[i][j]=false;\\n\\t\\treturn;\\n\\t}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words){\\n    \\tTrie t;\\n    \\tfor(auto&it:words){\\n    \\t\\tt.insert(it);\\n    \\t}\\n    \\tvector<string> ans;\\n    \\tset<string> s;\\n    \\tfor(int i=0;i<board.size();i++){\\n    \\t\\tfor(int j=0;j<board[i].size();j++){\\n    \\t\\t\\tfind_word(board,i,j,t.root,s);\\n    \\t\\t}\\n    \\t}\\n    \\tfor(auto&it:s){\\n    \\t\\tans.push_back(it);\\n    \\t}\\n    \\treturn ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\tbool visited[1000][1000]={false}",
                "codeTag": "Java"
            },
            {
                "id": 1008081,
                "title": "1ms-beats-94-06-simplest-java-backtracking-without-using-a-trie-explanation",
                "content": "An alternative to building the trie is to loop through the words array and try to build that word starting at each cell in the board. This solution, however, will do some duplicate work as it will repeat the same search sequence for substrings of previously searched words. \\n\\nThe time complexity for searching one word starting at any arbitrary cell (which is in this case calling ```findWord(board, word, i, j, 0)```) is O(4^L) where L is the length of the word. This is because we are branching at most four times for the four neighbors of the starting cell, with a maximum search depth of L. We do this at most M * N times, where M is the number of rows and N is the number of columns in the board.\\n\\nSo, the time complexity to search for one word is O((M * N) * 4^L).\\n\\nIf we redefine L to be the length of the longest string in the array, we can define the overall time complexity as O(S * (M * N) * 4^L) where S is the number of words in the array.\\n\\nIf we don\\'t consider stack space, the space complexity is O(S), assuming worst case that every word ends up in our result array. \\n\\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : words) {\\n            if (this.findWord(board, word)) {\\n                res.add(word);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (findWord(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word, int rowIdx, int colIdx, int charIdx) {\\n        if (rowIdx < 0 || colIdx < 0 || rowIdx == board.length || colIdx == board[0].length) {\\n            return false;\\n        }\\n        \\n        if (charIdx == word.length() - 1 && board[rowIdx][colIdx] == word.charAt(charIdx)) {\\n            return true;\\n        }\\n        \\n        if (charIdx == word.length()) {\\n            return false;\\n        }\\n        \\n        if (board[rowIdx][colIdx] == \\' \\' || board[rowIdx][colIdx] != word.charAt(charIdx)) {\\n            return false;\\n        }\\n        \\n        boolean res = false;\\n        char temp = board[rowIdx][colIdx];\\n        board[rowIdx][colIdx] = \\' \\';\\n        \\n        // go left, right, up, down\\n        if (findWord(board, word, rowIdx, colIdx - 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx, colIdx + 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx + 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx - 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        }\\n        \\n        board[rowIdx][colIdx] = temp;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```findWord(board, word, i, j, 0)```\n```\\nclass Solution {\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : words) {\\n            if (this.findWord(board, word)) {\\n                res.add(word);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (findWord(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean findWord(char[][] board, String word, int rowIdx, int colIdx, int charIdx) {\\n        if (rowIdx < 0 || colIdx < 0 || rowIdx == board.length || colIdx == board[0].length) {\\n            return false;\\n        }\\n        \\n        if (charIdx == word.length() - 1 && board[rowIdx][colIdx] == word.charAt(charIdx)) {\\n            return true;\\n        }\\n        \\n        if (charIdx == word.length()) {\\n            return false;\\n        }\\n        \\n        if (board[rowIdx][colIdx] == \\' \\' || board[rowIdx][colIdx] != word.charAt(charIdx)) {\\n            return false;\\n        }\\n        \\n        boolean res = false;\\n        char temp = board[rowIdx][colIdx];\\n        board[rowIdx][colIdx] = \\' \\';\\n        \\n        // go left, right, up, down\\n        if (findWord(board, word, rowIdx, colIdx - 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx, colIdx + 1, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx + 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        } else if (findWord(board, word, rowIdx - 1, colIdx, charIdx + 1)) {\\n            res = true;\\n        }\\n        \\n        board[rowIdx][colIdx] = temp;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938208,
                "title": "kotlin-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        \\n        if(board.isEmpty()) return listOf()\\n        if(words.all{ it.isEmpty() }) return listOf()\\n        \\n        val result = HashSet<String>()\\n        \\n        for(i in 0 until board.size){\\n            for(j in 0 until board[0].size){\\n                words\\n                    .filter{ it[0] == board[i][j] && dfs(board, i , j, it, 0)}\\n                    .forEach{\\n                        result.add(it)\\n                    }\\n            }\\n        } \\n        return result.toList()\\n    }\\n    \\n    \\n    private fun dfs(board: Array<CharArray>, row: Int, col: Int,\\n                   word: String, index: Int): Boolean{\\n        \\n        if(row < 0 || row > board.lastIndex || col < 0 || col > board[0].lastIndex\\n                    || word[index] != board[row][col])\\n            return false\\n        \\n        if(index == word.lastIndex) return true\\n        \\n        val temp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        \\n        val found = dfs(board, row + 1, col, word, index + 1)\\n                    || dfs(board, row - 1, col, word, index + 1)\\n                    || dfs(board, row, col + 1, word, index + 1)\\n                    || dfs(board, row, col - 1, word, index + 1)\\n        \\n        board[row][col] = temp\\n        return found\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\\n        \\n        if(board.isEmpty()) return listOf()\\n        if(words.all{ it.isEmpty() }) return listOf()\\n        \\n        val result = HashSet<String>()\\n        \\n        for(i in 0 until board.size){\\n            for(j in 0 until board[0].size){\\n                words\\n                    .filter{ it[0] == board[i][j] && dfs(board, i , j, it, 0)}\\n                    .forEach{\\n                        result.add(it)\\n                    }\\n            }\\n        } \\n        return result.toList()\\n    }\\n    \\n    \\n    private fun dfs(board: Array<CharArray>, row: Int, col: Int,\\n                   word: String, index: Int): Boolean{\\n        \\n        if(row < 0 || row > board.lastIndex || col < 0 || col > board[0].lastIndex\\n                    || word[index] != board[row][col])\\n            return false\\n        \\n        if(index == word.lastIndex) return true\\n        \\n        val temp = board[row][col]\\n        board[row][col] = \\'#\\'\\n        \\n        val found = dfs(board, row + 1, col, word, index + 1)\\n                    || dfs(board, row - 1, col, word, index + 1)\\n                    || dfs(board, row, col + 1, word, index + 1)\\n                    || dfs(board, row, col - 1, word, index + 1)\\n        \\n        board[row][col] = temp\\n        return found\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934641,
                "title": "python-solution-with-trie-28-ms",
                "content": "Basic algo overview:\\n1. Setup trie with words\\n2. Iterate through board and explore possible words. We take advantage of Trie structure to quickly stop searching when no words start with a given prefix. We also keep state so we don\\'t start from the beginning of a prefix each time, instead we continue from the previous prefix\\n3. When a word is found, remove it from the Trie (unless it is a prefix to another word) and append it to list of answers\\n```\\nclass Node:\\n    def __init__(self, prev):\\n        self.children = {}\\n        self.isWord = False\\n        self.prev = prev\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n### curNode keeps track of last character searched\\n        self.curNode = None\\n        \\n    def addWord(self,word):\\n        node = self.root\\n        for char in word:\\n            node = node.children.setdefault(char,Node(node))\\n        node.isWord = True\\n        \\n    def startsWith(self, prefix):\\n        node = self.curNode or self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n\\t### Once we\\'ve checked if a prefix is valid, we keep track of it with curNode\\n        self.curNode = node\\n        return True\\n    \\n    def remove(self, word):\\n        node = self.root\\n\\t### DFS to end of word, and only remove characters if they have no children AKA no other words start with the current prefix\\n        for char in word:\\n            if char not in node.children:\\n                return\\n            node = node.children[char]\\n    ### Set isWord to false, in case the word is a prefix to other words and we don\\'t remove it\\n        node.isWord = False\\n        for char in word[::-1]:\\n            if not node.children:\\n                node = node.prev\\n                del node.children[char]\\n            \\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.trie = Trie()\\n\\t### Directions we can move to construct a word on the board\\n        self.dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        self.ans = []\\n\\t### Add words to our Trie\\n        for word in words:\\n            self.trie.addWord(word)\\n\\t### Iterate through board and explore possible words that start with each character\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                self.explore(board,[r,c],\"\")\\n        return self.ans\\n            \\n    \\n    def explore(self,board, pos, word):\\n        r, c = pos\\n\\t### Keep track of curNode to reset it back to this after we\\'ve finished searching\\n        curNode = self.trie.curNode\\n\\t### Make sure position is within board params\\n        if 0 <= r < len(board) and 0 <= c < len(board[r]):\\n\\t### board[r][c] is only None if we have visited it, will see this later\\n            if board[r][c] is None: return\\n\\t### Keep track of what the current word is \\n            curWord = word + board[r][c]\\n\\t### Only continue exploring if the current word  continues to be a valid prefix\\n            if self.trie.startsWith(board[r][c]):\\n    ### If the curNode is the end of a word and the word has not been found yet, then we:\\n\\t\\t\\t# Add to our answer list\\n\\t\\t\\t# Remove the word from our Trie\\n                if self.trie.curNode.isWord:\\n                        self.ans.append(curWord)\\n                        self.trie.remove(curWord)\\n    ### Continue exploring and temporarily set the current position to None to indicate it has been explored\\n                temp = board[r][c]\\n                board[r][c] = None\\n\\t### Exploring in all directions\\n                for dir in self.dirs:\\n                    newPos = [pos[0] + dir[0], pos[1] + dir[1]]\\n                    self.explore(board, newPos, curWord)\\n\\t### After exploring in all directions, we reset board[r][c] so that it is no longer considered explored\\n\\t### Also reset the trie curNode because the current prefix is done being explored\\n                board[r][c] = temp\\n                self.trie.curNode = curNode\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, prev):\\n        self.children = {}\\n        self.isWord = False\\n        self.prev = prev\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n### curNode keeps track of last character searched\\n        self.curNode = None\\n        \\n    def addWord(self,word):\\n        node = self.root\\n        for char in word:\\n            node = node.children.setdefault(char,Node(node))\\n        node.isWord = True\\n        \\n    def startsWith(self, prefix):\\n        node = self.curNode or self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n\\t### Once we\\'ve checked if a prefix is valid, we keep track of it with curNode\\n        self.curNode = node\\n        return True\\n    \\n    def remove(self, word):\\n        node = self.root\\n\\t### DFS to end of word, and only remove characters if they have no children AKA no other words start with the current prefix\\n        for char in word:\\n            if char not in node.children:\\n                return\\n            node = node.children[char]\\n    ### Set isWord to false, in case the word is a prefix to other words and we don\\'t remove it\\n        node.isWord = False\\n        for char in word[::-1]:\\n            if not node.children:\\n                node = node.prev\\n                del node.children[char]\\n            \\n    \\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        self.trie = Trie()\\n\\t### Directions we can move to construct a word on the board\\n        self.dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        self.ans = []\\n\\t### Add words to our Trie\\n        for word in words:\\n            self.trie.addWord(word)\\n\\t### Iterate through board and explore possible words that start with each character\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                self.explore(board,[r,c],\"\")\\n        return self.ans\\n            \\n    \\n    def explore(self,board, pos, word):\\n        r, c = pos\\n\\t### Keep track of curNode to reset it back to this after we\\'ve finished searching\\n        curNode = self.trie.curNode\\n\\t### Make sure position is within board params\\n        if 0 <= r < len(board) and 0 <= c < len(board[r]):\\n\\t### board[r][c] is only None if we have visited it, will see this later\\n            if board[r][c] is None: return\\n\\t### Keep track of what the current word is \\n            curWord = word + board[r][c]\\n\\t### Only continue exploring if the current word  continues to be a valid prefix\\n            if self.trie.startsWith(board[r][c]):\\n    ### If the curNode is the end of a word and the word has not been found yet, then we:\\n\\t\\t\\t# Add to our answer list\\n\\t\\t\\t# Remove the word from our Trie\\n                if self.trie.curNode.isWord:\\n                        self.ans.append(curWord)\\n                        self.trie.remove(curWord)\\n    ### Continue exploring and temporarily set the current position to None to indicate it has been explored\\n                temp = board[r][c]\\n                board[r][c] = None\\n\\t### Exploring in all directions\\n                for dir in self.dirs:\\n                    newPos = [pos[0] + dir[0], pos[1] + dir[1]]\\n                    self.explore(board, newPos, curWord)\\n\\t### After exploring in all directions, we reset board[r][c] so that it is no longer considered explored\\n\\t### Also reset the trie curNode because the current prefix is done being explored\\n                board[r][c] = temp\\n                self.trie.curNode = curNode\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906795,
                "title": "rust-8-ms-solution-beats-all",
                "content": "I used Trie for words (as everyone) and special CPU-optimized matrix for board.\\nYou can learn about trie in [other discussions](https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00) ) so I would concentrate on board.\\n\\nBoard is made as flattened matrix (Vec) of submatrices. Since it flattened, it uses one allocation instead of many default provided by input.\\nTo get position in flattened you can just calc `y*width + x`.\\nAlso I made matrix of smaller matrices 8x8. Its size is choosen as 8x8 because it would be 64 bytes which fit to the CPU cache-line. It is effective, because during backtracking we traverse from each cell to 4 different directions and some time we are in one smaller submatrix. So in most cases we never move far away from starting memory location.\\n\\nYou can learn more about data locality here: http://ithare.com/c-for-games-performance-allocations-and-data-locality/\\n\\n```rust\\nuse std::collections::HashSet;\\nuse std::ops::{Index, IndexMut};\\n\\nconst INNER_SIDE: usize = 8;\\nconst RANGE: usize = (b\\'z\\' - b\\'a\\') as usize + 1;\\n\\n#[inline(always)]\\nfn alph_to_idx(c: u8) -> usize {\\n    (c - b\\'a\\').into()\\n}\\n\\nstruct Board<T>\\nwhere\\n    T: Copy + Default,\\n{\\n    b_width: usize,\\n    width: usize,\\n    height: usize,\\n    buff: Vec<[[T; INNER_SIDE]; INNER_SIDE]>,\\n}\\n\\nimpl<T: Copy + Default> Board<T> {\\n    fn zeroed(width: usize, height: usize) -> Self {\\n        assert!(width > 0 && height > 0);\\n        let b_width = width / INNER_SIDE + if width % INNER_SIDE > 0 { 1 } else { 0 };\\n        let b_height = height / INNER_SIDE + if height % INNER_SIDE > 0 { 1 } else { 0 };\\n        Self {\\n            b_width,\\n            width,\\n            height,\\n            buff: vec![[[T::default(); INNER_SIDE]; INNER_SIDE]; b_height * b_width],\\n        }\\n    }\\n}\\n\\nfn from_chars(board: Vec<Vec<char>>) -> Board<u8> {\\n    assert!(board.len() > 0, \"Expected square\");\\n    assert!(board.first().unwrap().len() > 0, \"Expected square\");\\n    assert!(\\n        board.windows(2).all(|w| w[0].len() == w[1].len()),\\n        \"Expected square\"\\n    );\\n    assert!(\\n        board\\n            .iter()\\n            .all(|sub| sub.iter().all(char::is_ascii_lowercase)),\\n        \"Expected ascii lowercase\"\\n    );\\n    let width = board[0].len();\\n    let height = board.len();\\n    let mut res = Board::zeroed(width, height);\\n    for (y, row) in board.into_iter().enumerate() {\\n        for (x, elem) in row.into_iter().enumerate() {\\n            res[(x, y)] = elem as u8;\\n        }\\n    }\\n    res\\n}\\n\\nfn calc_existing_chars(board: &Board<u8>) -> [usize; RANGE] {\\n    let mut result = [0; RANGE];\\n    for block in board.buff.iter() {\\n        if block.iter().flatten().any(|&x| x == 0) {\\n            for b in block\\n                .iter()\\n                .flatten()\\n                .copied()\\n                .filter(|&x| x != 0)\\n                .map(alph_to_idx)\\n            {\\n                result[b] += 1;\\n            }\\n        } else {\\n            for b in block.iter().flatten().copied().map(alph_to_idx) {\\n                result[b] += 1;\\n            }\\n        }\\n    }\\n    result\\n}\\n\\nimpl<T: Copy + Default> Index<(usize, usize)> for Board<T> {\\n    type Output = T;\\n\\n    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &self.buff[self.b_width * block_y + block_x];\\n        &block[inner_y][inner_x]\\n    }\\n}\\n\\nimpl<T: Copy + Default> IndexMut<(usize, usize)> for Board<T> {\\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &mut self.buff[self.b_width * block_y + block_x];\\n        &mut block[inner_y][inner_x]\\n    }\\n}\\n\\nfn remove_all_invalid_words(words: &mut Vec<String>, board: &Board<u8>) {\\n    let allowed_chars = calc_existing_chars(board);\\n    words.retain(|w| {\\n        if w.as_bytes()\\n            .iter()\\n            .any(|&c| allowed_chars[alph_to_idx(c)] == 0)\\n        {\\n            return false;\\n        }\\n        let mut chars = [0usize; RANGE];\\n        for b in w.as_bytes().iter().copied().map(alph_to_idx) {\\n            chars[b] += 1;\\n        }\\n        chars.iter().zip(&allowed_chars).all(|(&a, &b)| a <= b)\\n    });\\n}\\n\\n#[derive(Default)]\\nstruct TrieNode<\\'a> {\\n    children: [Option<Box<TrieNode<\\'a>>>; RANGE],\\n    word: Option<&\\'a str>,\\n}\\n\\nimpl<\\'a> TrieNode<\\'a> {\\n    fn produce(words: &\\'a [String]) -> Box<Self> {\\n        let mut root = Self::default();\\n        for w in words {\\n            let word = w.as_str();\\n            let bytes = word.as_bytes();\\n            let mut current = &mut root;\\n            for &b in bytes {\\n                let idx = alph_to_idx(b);\\n                if current.children[idx].is_none() {\\n                    current.children[idx] = Some(Box::new(Self::default()));\\n                }\\n                let next = current.children[idx].as_mut().unwrap().as_mut();\\n                current = next;\\n            }\\n            current.word = Some(word);\\n        }\\n        Box::new(root)\\n    }\\n}\\n\\nfn traverse<\\'a>(\\n    pos: (usize, usize),\\n    board: &Board<u8>,\\n    visited: &mut Board<bool>,\\n    found: &mut HashSet<&\\'a str>,\\n    trie: &TrieNode<\\'a>,\\n) {\\n    let c = board[pos];\\n    if let Some(ref next) = trie.children[alph_to_idx(c)] {\\n        let next = next.as_ref();\\n        if let Some(w) = next.word {\\n            found.insert(w);\\n        }\\n        visited[pos] = true;\\n\\n        if pos.0 > 0 {\\n            let candidate = (pos.0 - 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 > 0 {\\n            let candidate = (pos.0, pos.1 - 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.0 + 1 < board.width {\\n            let candidate = (pos.0 + 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 + 1 < board.height {\\n            let candidate = (pos.0, pos.1 + 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n\\n        visited[pos] = false;\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, mut words: Vec<String>) -> Vec<String> {\\n        words.sort_unstable();\\n        words.dedup();\\n\\n        assert!(words\\n            .iter()\\n            .flat_map(|w| w.as_bytes())\\n            .all(|&b| b.is_ascii_lowercase()));\\n\\n        let board = from_chars(board);\\n        words.retain(|x| x.len() <= board.width * board.height);\\n\\n        remove_all_invalid_words(&mut words, &board);\\n\\n        if words.is_empty() {\\n            return words;\\n        }\\n\\n        let mut result = HashSet::new();\\n        let trie = TrieNode::produce(&words);\\n        let mut visited: Board<bool> = Board::zeroed(board.width, board.height);\\n        for y in 0..board.height {\\n            for x in 0..board.width {\\n                if result.len() == words.len() {\\n                    return words;\\n                }\\n                traverse((x, y), &board, &mut visited, &mut result, trie.as_ref());\\n            }\\n        }\\n        result.into_iter().map(|x| x.to_string()).collect()\\n    }\\n}\\n\\n```\\n\\nAnd, finally, the pic :)\\n![image](https://assets.leetcode.com/users/images/25729a7e-ae0d-4182-95fc-4e629221b2fe_1603438722.3488445.png)\\n",
                "solutionTags": [
                    "Rust",
                    "Trie",
                    "Matrix"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\nuse std::ops::{Index, IndexMut};\\n\\nconst INNER_SIDE: usize = 8;\\nconst RANGE: usize = (b\\'z\\' - b\\'a\\') as usize + 1;\\n\\n#[inline(always)]\\nfn alph_to_idx(c: u8) -> usize {\\n    (c - b\\'a\\').into()\\n}\\n\\nstruct Board<T>\\nwhere\\n    T: Copy + Default,\\n{\\n    b_width: usize,\\n    width: usize,\\n    height: usize,\\n    buff: Vec<[[T; INNER_SIDE]; INNER_SIDE]>,\\n}\\n\\nimpl<T: Copy + Default> Board<T> {\\n    fn zeroed(width: usize, height: usize) -> Self {\\n        assert!(width > 0 && height > 0);\\n        let b_width = width / INNER_SIDE + if width % INNER_SIDE > 0 { 1 } else { 0 };\\n        let b_height = height / INNER_SIDE + if height % INNER_SIDE > 0 { 1 } else { 0 };\\n        Self {\\n            b_width,\\n            width,\\n            height,\\n            buff: vec![[[T::default(); INNER_SIDE]; INNER_SIDE]; b_height * b_width],\\n        }\\n    }\\n}\\n\\nfn from_chars(board: Vec<Vec<char>>) -> Board<u8> {\\n    assert!(board.len() > 0, \"Expected square\");\\n    assert!(board.first().unwrap().len() > 0, \"Expected square\");\\n    assert!(\\n        board.windows(2).all(|w| w[0].len() == w[1].len()),\\n        \"Expected square\"\\n    );\\n    assert!(\\n        board\\n            .iter()\\n            .all(|sub| sub.iter().all(char::is_ascii_lowercase)),\\n        \"Expected ascii lowercase\"\\n    );\\n    let width = board[0].len();\\n    let height = board.len();\\n    let mut res = Board::zeroed(width, height);\\n    for (y, row) in board.into_iter().enumerate() {\\n        for (x, elem) in row.into_iter().enumerate() {\\n            res[(x, y)] = elem as u8;\\n        }\\n    }\\n    res\\n}\\n\\nfn calc_existing_chars(board: &Board<u8>) -> [usize; RANGE] {\\n    let mut result = [0; RANGE];\\n    for block in board.buff.iter() {\\n        if block.iter().flatten().any(|&x| x == 0) {\\n            for b in block\\n                .iter()\\n                .flatten()\\n                .copied()\\n                .filter(|&x| x != 0)\\n                .map(alph_to_idx)\\n            {\\n                result[b] += 1;\\n            }\\n        } else {\\n            for b in block.iter().flatten().copied().map(alph_to_idx) {\\n                result[b] += 1;\\n            }\\n        }\\n    }\\n    result\\n}\\n\\nimpl<T: Copy + Default> Index<(usize, usize)> for Board<T> {\\n    type Output = T;\\n\\n    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &self.buff[self.b_width * block_y + block_x];\\n        &block[inner_y][inner_x]\\n    }\\n}\\n\\nimpl<T: Copy + Default> IndexMut<(usize, usize)> for Board<T> {\\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {\\n        assert!(x < self.width && y < self.height, \"Should be in bounds\");\\n        let block_x = x / INNER_SIDE;\\n        let inner_x = x % INNER_SIDE;\\n        let block_y = y / INNER_SIDE;\\n        let inner_y = y % INNER_SIDE;\\n        let block = &mut self.buff[self.b_width * block_y + block_x];\\n        &mut block[inner_y][inner_x]\\n    }\\n}\\n\\nfn remove_all_invalid_words(words: &mut Vec<String>, board: &Board<u8>) {\\n    let allowed_chars = calc_existing_chars(board);\\n    words.retain(|w| {\\n        if w.as_bytes()\\n            .iter()\\n            .any(|&c| allowed_chars[alph_to_idx(c)] == 0)\\n        {\\n            return false;\\n        }\\n        let mut chars = [0usize; RANGE];\\n        for b in w.as_bytes().iter().copied().map(alph_to_idx) {\\n            chars[b] += 1;\\n        }\\n        chars.iter().zip(&allowed_chars).all(|(&a, &b)| a <= b)\\n    });\\n}\\n\\n#[derive(Default)]\\nstruct TrieNode<\\'a> {\\n    children: [Option<Box<TrieNode<\\'a>>>; RANGE],\\n    word: Option<&\\'a str>,\\n}\\n\\nimpl<\\'a> TrieNode<\\'a> {\\n    fn produce(words: &\\'a [String]) -> Box<Self> {\\n        let mut root = Self::default();\\n        for w in words {\\n            let word = w.as_str();\\n            let bytes = word.as_bytes();\\n            let mut current = &mut root;\\n            for &b in bytes {\\n                let idx = alph_to_idx(b);\\n                if current.children[idx].is_none() {\\n                    current.children[idx] = Some(Box::new(Self::default()));\\n                }\\n                let next = current.children[idx].as_mut().unwrap().as_mut();\\n                current = next;\\n            }\\n            current.word = Some(word);\\n        }\\n        Box::new(root)\\n    }\\n}\\n\\nfn traverse<\\'a>(\\n    pos: (usize, usize),\\n    board: &Board<u8>,\\n    visited: &mut Board<bool>,\\n    found: &mut HashSet<&\\'a str>,\\n    trie: &TrieNode<\\'a>,\\n) {\\n    let c = board[pos];\\n    if let Some(ref next) = trie.children[alph_to_idx(c)] {\\n        let next = next.as_ref();\\n        if let Some(w) = next.word {\\n            found.insert(w);\\n        }\\n        visited[pos] = true;\\n\\n        if pos.0 > 0 {\\n            let candidate = (pos.0 - 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 > 0 {\\n            let candidate = (pos.0, pos.1 - 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.0 + 1 < board.width {\\n            let candidate = (pos.0 + 1, pos.1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n        if pos.1 + 1 < board.height {\\n            let candidate = (pos.0, pos.1 + 1);\\n            if !visited[candidate] {\\n                traverse(candidate, board, visited, found, next);\\n            }\\n        }\\n\\n        visited[pos] = false;\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn find_words(board: Vec<Vec<char>>, mut words: Vec<String>) -> Vec<String> {\\n        words.sort_unstable();\\n        words.dedup();\\n\\n        assert!(words\\n            .iter()\\n            .flat_map(|w| w.as_bytes())\\n            .all(|&b| b.is_ascii_lowercase()));\\n\\n        let board = from_chars(board);\\n        words.retain(|x| x.len() <= board.width * board.height);\\n\\n        remove_all_invalid_words(&mut words, &board);\\n\\n        if words.is_empty() {\\n            return words;\\n        }\\n\\n        let mut result = HashSet::new();\\n        let trie = TrieNode::produce(&words);\\n        let mut visited: Board<bool> = Board::zeroed(board.width, board.height);\\n        for y in 0..board.height {\\n            for x in 0..board.width {\\n                if result.len() == words.len() {\\n                    return words;\\n                }\\n                traverse((x, y), &board, &mut visited, &mut result, trie.as_ref());\\n            }\\n        }\\n        result.into_iter().map(|x| x.to_string()).collect()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889671,
                "title": "easy-backtracking-trie-c-solution",
                "content": "```\\nclass Trie{\\n    public:\\n    unordered_map<char, Trie*> children;\\n    bool isEnd=false;\\n    \\n    void insert(string word){\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                node->children[c]=new Trie();\\n            node=node->children[c];\\n        }\\n        node->isEnd=true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> direction={0, -1, 0, 1, 0};\\n    void Backtracking(vector<vector<char>>& board, Trie* trie, int i, int j, string& partial, vector<string>& result){\\n        if(trie->isEnd==true){\\n            result.push_back(partial);\\n            trie->isEnd=false;\\n        }\\n        \\n        for(int d=0; d<4; d++){\\n            int row=i+direction[d];\\n            int col=j+direction[d+1];\\n            if(row>=0 && col>=0 && row<board.size() && col<board[0].size() && board[row][col]!=\\'#\\' && \\n               trie->children.find(board[row][col])!=trie->children.end()){\\n                char temp=board[row][col];\\n                board[row][col]=\\'#\\';\\n                partial.push_back(temp);\\n                \\n                Backtracking(board, trie->children[temp], row, col, partial, result); \\n                \\n                partial.pop_back();\\n                board[row][col]=temp;\\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> exist(vector<vector<char>>& board, Trie* trie){\\n        int m=board.size(), n=board[0].size();\\n        \\n        vector<string> result;\\n        string partial;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++){\\n                if(trie->children.find(board[i][j])!=trie->children.end()){\\n                    char temp=board[i][j];\\n                    board[i][j]=\\'#\\';\\n                    partial.push_back(temp);\\n\\n                    Backtracking(board, trie->children[temp], i, j, partial, result);\\n\\n                    partial.pop_back();\\n                    board[i][j]=temp;\\n                }\\n                \\n            }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie* trie=new Trie();\\n        for(string word : words)\\n            trie->insert(word);\\n        \\n        return exist(board, trie);\\n    }\\n};\\n```\\nI appreciate yoru upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    unordered_map<char, Trie*> children;\\n    bool isEnd=false;\\n    \\n    void insert(string word){\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                node->children[c]=new Trie();\\n            node=node->children[c];\\n        }\\n        node->isEnd=true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> direction={0, -1, 0, 1, 0};\\n    void Backtracking(vector<vector<char>>& board, Trie* trie, int i, int j, string& partial, vector<string>& result){\\n        if(trie->isEnd==true){\\n            result.push_back(partial);\\n            trie->isEnd=false;\\n        }\\n        \\n        for(int d=0; d<4; d++){\\n            int row=i+direction[d];\\n            int col=j+direction[d+1];\\n            if(row>=0 && col>=0 && row<board.size() && col<board[0].size() && board[row][col]!=\\'#\\' && \\n               trie->children.find(board[row][col])!=trie->children.end()){\\n                char temp=board[row][col];\\n                board[row][col]=\\'#\\';\\n                partial.push_back(temp);\\n                \\n                Backtracking(board, trie->children[temp], row, col, partial, result); \\n                \\n                partial.pop_back();\\n                board[row][col]=temp;\\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> exist(vector<vector<char>>& board, Trie* trie){\\n        int m=board.size(), n=board[0].size();\\n        \\n        vector<string> result;\\n        string partial;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++){\\n                if(trie->children.find(board[i][j])!=trie->children.end()){\\n                    char temp=board[i][j];\\n                    board[i][j]=\\'#\\';\\n                    partial.push_back(temp);\\n\\n                    Backtracking(board, trie->children[temp], i, j, partial, result);\\n\\n                    partial.pop_back();\\n                    board[i][j]=temp;\\n                }\\n                \\n            }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        Trie* trie=new Trie();\\n        for(string word : words)\\n            trie->insert(word);\\n        \\n        return exist(board, trie);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802511,
                "title": "complete-process-to-do-with-well-comment-using-unordered-map-dfs-tries",
                "content": "This question is basically of DFS but the problem is we have to reduce in dfs(recall we were exploring all the path into DFS) but here we can not do like that cause that would TLE..\\nSo i decided to insert all the words into tries first and we will explore only those path which has a prefix in tries .. and we are storing the number of prefix in tries because it will reduce again extra calls..\\nEach time when we counter the end of word we store the word(since we are storing the index of that word or we can store as char extra in tries class)..\\nAvoid recursive call:-\\n1. if we have 0 prefix counter on current node because we don\\'t need any word with such prefix just return\\n2. if we don\\'t have any next node in tries because we don\\'t need any word more than that or we our tries has no node with such char that\\'s means we don\\'t have requirement with a word which start with char board[i][j]  for which we don\\'t have any node in tries for particular root\\n3. all the boundry condition as we did in dfs and if any position is allready visited then avoid to call\\nRest of job my comment should do:)\\n```\\nclass Trie{\\n  public:\\n    unordered_map<char , Trie*> leaf;\\n    bool endOfWord;\\n    int wordIdx;\\n    int prefixCount;\\n    Trie(){\\n      endOfWord=false;\\n      wordIdx=0;\\n      prefixCount=0;\\n    }\\n  ~Trie(){\\n    for(auto x : leaf) delete x.second;\\n  }\\n};\\nclass Solution {\\npublic:\\nvoid insert(Trie *root , string& word  , int index , int len=0){\\n  if(len==word.size()){\\n    //mark current root as end of word and assign the index value\\n    root->endOfWord=true;\\n    root->wordIdx=index;\\n    return;\\n  }\\n  root->prefixCount+=1;\\n  if(!root->leaf[word[len]]){\\n    //make a root value\\n    root->leaf[word[len]]=new Trie();\\n  }\\n  root=root->leaf[word[len]];\\n  root->prefixCount +=1;\\n  insert(root , word , index , len+1);\\n}\\nvoid buildTrie(vector<string>& words , Trie *root){\\n  for(int i=0 ; i<words.size() ;i++) insert(root , words[i] , i);\\n}\\n\\nint dfs_tries(vector<string>&output , Trie *root , vector<vector<char>>& board ,vector<string>& words , int i , int j){\\n  //cout<<i<<\" \"<<j<<\\'\\\\n\\';\\n  int detected=0;//how many word is detected till now\\n  if(root->endOfWord){\\n    //then we have a word which needs to find let\\'s store that word\\n    output.push_back(words[root->wordIdx]);\\n    //and unmark the current root as not end of word\\n    root->endOfWord=false;\\n    //increase detected cause we found one word\\n    detected++;\\n  }\\n  //boundry condition\\n  if(i<0 || j<0 || i>=board.size() || j>=board[0].size()){\\n    return detected;\\n  }\\n  //shift root\\n  Trie *child=root->leaf[board[i][j]];\\n  //base case(invalid condition)\\n  if( board[i][j]==\\'*\\' || !child || child->prefixCount<=0 ){\\n    return detected;\\n  }\\n  char temp=board[i][j];\\n  board[i][j]=\\'*\\';//mark as visited\\n  //explore all the path from i and j\\n  detected += dfs_tries(output , child , board , words , i+1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j+1);\\n  detected += dfs_tries(output , child , board , words , i-1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j-1);\\n  //while backtracking we are going to reduce detected with prefixCount\\n  root->prefixCount -= detected;\\n  //and reset the val what i changed for further use\\n  board[i][j]=temp;\\n  return detected;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n  int row , col , wordLen=words.size();\\n  vector<string> output;\\n  //base case\\n  if( !(row=board.size()) || !(col=board[0].size()) || !wordLen){\\n    return output;\\n  }\\n  Trie *root=new Trie();\\n  //build the tree i.e. insert all words into the tries\\n  buildTrie(words , root);\\n  //do dfs\\n  //if no prefix count then we have not any element in words which is in board\\n  for(int i=0 ; i<row  && root->prefixCount; i++){\\n    for(int j=0 ; j<col ; j++){\\n     int x= dfs_tries(output , root  , board , words , i ,j);\\n    }\\n  }\\n  delete root;\\n  return output;\\n    }\\n};\\n```\\nPlease vote if it helps you..\\nHappy coding:)",
                "solutionTags": [],
                "code": "```\\nclass Trie{\\n  public:\\n    unordered_map<char , Trie*> leaf;\\n    bool endOfWord;\\n    int wordIdx;\\n    int prefixCount;\\n    Trie(){\\n      endOfWord=false;\\n      wordIdx=0;\\n      prefixCount=0;\\n    }\\n  ~Trie(){\\n    for(auto x : leaf) delete x.second;\\n  }\\n};\\nclass Solution {\\npublic:\\nvoid insert(Trie *root , string& word  , int index , int len=0){\\n  if(len==word.size()){\\n    //mark current root as end of word and assign the index value\\n    root->endOfWord=true;\\n    root->wordIdx=index;\\n    return;\\n  }\\n  root->prefixCount+=1;\\n  if(!root->leaf[word[len]]){\\n    //make a root value\\n    root->leaf[word[len]]=new Trie();\\n  }\\n  root=root->leaf[word[len]];\\n  root->prefixCount +=1;\\n  insert(root , word , index , len+1);\\n}\\nvoid buildTrie(vector<string>& words , Trie *root){\\n  for(int i=0 ; i<words.size() ;i++) insert(root , words[i] , i);\\n}\\n\\nint dfs_tries(vector<string>&output , Trie *root , vector<vector<char>>& board ,vector<string>& words , int i , int j){\\n  //cout<<i<<\" \"<<j<<\\'\\\\n\\';\\n  int detected=0;//how many word is detected till now\\n  if(root->endOfWord){\\n    //then we have a word which needs to find let\\'s store that word\\n    output.push_back(words[root->wordIdx]);\\n    //and unmark the current root as not end of word\\n    root->endOfWord=false;\\n    //increase detected cause we found one word\\n    detected++;\\n  }\\n  //boundry condition\\n  if(i<0 || j<0 || i>=board.size() || j>=board[0].size()){\\n    return detected;\\n  }\\n  //shift root\\n  Trie *child=root->leaf[board[i][j]];\\n  //base case(invalid condition)\\n  if( board[i][j]==\\'*\\' || !child || child->prefixCount<=0 ){\\n    return detected;\\n  }\\n  char temp=board[i][j];\\n  board[i][j]=\\'*\\';//mark as visited\\n  //explore all the path from i and j\\n  detected += dfs_tries(output , child , board , words , i+1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j+1);\\n  detected += dfs_tries(output , child , board , words , i-1 , j);\\n  detected += dfs_tries(output , child , board , words , i , j-1);\\n  //while backtracking we are going to reduce detected with prefixCount\\n  root->prefixCount -= detected;\\n  //and reset the val what i changed for further use\\n  board[i][j]=temp;\\n  return detected;\\n}\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n  int row , col , wordLen=words.size();\\n  vector<string> output;\\n  //base case\\n  if( !(row=board.size()) || !(col=board[0].size()) || !wordLen){\\n    return output;\\n  }\\n  Trie *root=new Trie();\\n  //build the tree i.e. insert all words into the tries\\n  buildTrie(words , root);\\n  //do dfs\\n  //if no prefix count then we have not any element in words which is in board\\n  for(int i=0 ; i<row  && root->prefixCount; i++){\\n    for(int j=0 ; j<col ; j++){\\n     int x= dfs_tries(output , root  , board , words , i ,j);\\n    }\\n  }\\n  delete root;\\n  return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 748617,
                "title": "c-trie-dfs-backtracking-with-comments-and-explanation",
                "content": "We can go for normal DFS search with backtracking but that would not be efficient since for every string in words we would have to do dfs on the whole board again.\\nBy making a trie of the words we can check for every character and move to that as and when it matches so only need one dfs for the board.\\n```\\n//Trie Node Class\\nclass TrieNode{\\n    public:\\n\\t// To Store Child Nodes\\n    unordered_map<char,TrieNode*> children;\\n    bool isLeaf;\\n    // To check if found\\n\\tbool found;\\n    TrieNode() {\\n        isLeaf = false;\\n        found = false;\\n    }\\n    void insert(string s) {\\n        TrieNode* current = this;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t\\t// if node doesnt exist\\n            if(current->children.find(s[i]) == current->children.end()){\\n                current->children[s[i]] = new TrieNode();\\n            }\\n\\t\\t\\t// move to next node\\n            current = current->children[s[i]];\\n        }\\n\\t\\t// make it leaf node\\n        current->isLeaf = true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* trie = new TrieNode();\\n        for(int i=0;i<words.size();i++) {\\n\\t\\t\\t// adding all words to trie\\n            trie->insert(words[i]);\\n        }\\n\\t\\t// visited 2d vector for dfs\\n        vector<vector<bool>> visited;\\n        for(int i=0;i<board.size();i++) {\\n            vector<bool> v;\\n            for(int j=0;j<board[0].size();j++) {\\n                v.push_back(false);\\n            }\\n            visited.push_back(v);\\n        }\\n\\t\\t// find first matching character and call dfs\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[0].size();j++) {\\n                if(trie->children.find(board[i][j]) != trie->children.end()) {\\n                    visited[i][j] = true;\\n                    dfs(trie->children[board[i][j]],board,i,j,visited);\\n\\t\\t\\t\\t\\t//set visited false for the next word\\n                    visited[i][j] = false;\\n                }\\n            }\\n        }\\n        vector<string> foundStrings;\\n        addFoundStrings(foundStrings,\"\",trie);\\n        return foundStrings;\\n    }\\n\\t// add all strings with found == true\\n    void addFoundStrings(vector<string>& foundStrings,string s,TrieNode* trie) {\\n        if(trie->isLeaf == true && trie->found == true) {\\n            foundStrings.push_back(s);\\n        }\\n        for(auto it = trie->children.begin();it!= trie->children.end();it++) {\\n            addFoundStrings(foundStrings,s+it->first,it->second);\\n        }\\n    }\\n\\t// to check if we are out of the board or not\\n    bool isSafe(int i,int j,vector<vector<char>>& board) {\\n        if(i>=0 && j>=0 && i<board.size() && j<board[0].size()) \\n            return true;\\n        return false;\\n    }\\n    void dfs(TrieNode* trie,vector<vector<char>>& board,int i,int j,vector<vector<bool>> visited) {\\n        if(trie->isLeaf == true) {\\n\\t\\t\\t// setting found\\n            trie->found = true;\\n        }\\n\\t\\t// adjacent moves\\n        int x[] = {1,0,-1,0};\\n        int y[] = {0,1,0,-1};\\n        for(int k=0;k<4;k++) {\\n            int newi = i + x[k];\\n            int newj = j + y[k];\\n\\t\\t\\t// first check i,j to be safe then check if they are visited and then check if child exists for this character\\n            if(isSafe(newi,newj,board) && !visited[newi][newj] && trie->children.find(board[newi][newj]) != trie->children.end()) {\\n                visited[newi][newj] = true;\\n                dfs(trie->children[board[newi][newj]],board,newi,newj,visited);\\n                //set visited false for the next word\\n\\t\\t\\t\\tvisited[newi][newj] = false;\\n            }\\n        }\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n//Trie Node Class\\nclass TrieNode{\\n    public:\\n\\t// To Store Child Nodes\\n    unordered_map<char,TrieNode*> children;\\n    bool isLeaf;\\n    // To check if found\\n\\tbool found;\\n    TrieNode() {\\n        isLeaf = false;\\n        found = false;\\n    }\\n    void insert(string s) {\\n        TrieNode* current = this;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t\\t// if node doesnt exist\\n            if(current->children.find(s[i]) == current->children.end()){\\n                current->children[s[i]] = new TrieNode();\\n            }\\n\\t\\t\\t// move to next node\\n            current = current->children[s[i]];\\n        }\\n\\t\\t// make it leaf node\\n        current->isLeaf = true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        TrieNode* trie = new TrieNode();\\n        for(int i=0;i<words.size();i++) {\\n\\t\\t\\t// adding all words to trie\\n            trie->insert(words[i]);\\n        }\\n\\t\\t// visited 2d vector for dfs\\n        vector<vector<bool>> visited;\\n        for(int i=0;i<board.size();i++) {\\n            vector<bool> v;\\n            for(int j=0;j<board[0].size();j++) {\\n                v.push_back(false);\\n            }\\n            visited.push_back(v);\\n        }\\n\\t\\t// find first matching character and call dfs\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[0].size();j++) {\\n                if(trie->children.find(board[i][j]) != trie->children.end()) {\\n                    visited[i][j] = true;\\n                    dfs(trie->children[board[i][j]],board,i,j,visited);\\n\\t\\t\\t\\t\\t//set visited false for the next word\\n                    visited[i][j] = false;\\n                }\\n            }\\n        }\\n        vector<string> foundStrings;\\n        addFoundStrings(foundStrings,\"\",trie);\\n        return foundStrings;\\n    }\\n\\t// add all strings with found == true\\n    void addFoundStrings(vector<string>& foundStrings,string s,TrieNode* trie) {\\n        if(trie->isLeaf == true && trie->found == true) {\\n            foundStrings.push_back(s);\\n        }\\n        for(auto it = trie->children.begin();it!= trie->children.end();it++) {\\n            addFoundStrings(foundStrings,s+it->first,it->second);\\n        }\\n    }\\n\\t// to check if we are out of the board or not\\n    bool isSafe(int i,int j,vector<vector<char>>& board) {\\n        if(i>=0 && j>=0 && i<board.size() && j<board[0].size()) \\n            return true;\\n        return false;\\n    }\\n    void dfs(TrieNode* trie,vector<vector<char>>& board,int i,int j,vector<vector<bool>> visited) {\\n        if(trie->isLeaf == true) {\\n\\t\\t\\t// setting found\\n            trie->found = true;\\n        }\\n\\t\\t// adjacent moves\\n        int x[] = {1,0,-1,0};\\n        int y[] = {0,1,0,-1};\\n        for(int k=0;k<4;k++) {\\n            int newi = i + x[k];\\n            int newj = j + y[k];\\n\\t\\t\\t// first check i,j to be safe then check if they are visited and then check if child exists for this character\\n            if(isSafe(newi,newj,board) && !visited[newi][newj] && trie->children.find(board[newi][newj]) != trie->children.end()) {\\n                visited[newi][newj] = true;\\n                dfs(trie->children[board[newi][newj]],board,newi,newj,visited);\\n                //set visited false for the next word\\n\\t\\t\\t\\tvisited[newi][newj] = false;\\n            }\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 745010,
                "title": "swift-minimal-solution-with-dfs-and-trie-with-complexity-analysis-100",
                "content": "Let \\nm,n be the width and height of the 2D array\\nL be the average length of words in \"words\"\\nW be the number of words\\n\\n1. *result*: takes O(W) space\\n2. *buildTrie()*: takes O(LW) runtime and O(LW) space\\n3. going through every cell takes O(mn) runtime\\n4. *check():* at each cell, we *check* until we either reach all possible leaf nodes OR reach the end of the board (in case one word is longer than the size of the board) => takes O(min(LW, mn)) runtime,  O(L) call stack space\\n\\nIn total,\\n**Time: O(mn * min(LW, mn) + LW), Space: O(LW)**\\nor simpler: **Time: O(mn * LW), Space: O(LW)**\\n\\n\\n```\\nclass TrieNode {\\n\\tvar word: String?\\n\\tvar children = [Character: TrieNode]()\\n}\\n\\nfunc findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n\\tif board.isEmpty { return [] }\\n\\n\\tvar result = [String]()\\n\\tvar board = board\\n\\tlet root = buildTrie(with: words)\\n\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board[0].count {\\n\\t\\t\\tcheck(&board, i, j, root, &result)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc buildTrie(with words: [String]) -> TrieNode {\\n\\tlet root = TrieNode()\\n\\n\\tfor word in words {\\n\\t\\tvar node = root\\n\\t\\tfor char in word {\\n\\t\\t\\tif node.children[char] == nil{\\n\\t\\t\\t\\tnode.children[char] = TrieNode()\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[char]!\\n\\t\\t}\\n\\t\\tnode.word = word\\n\\t}\\n\\n\\treturn root\\n}\\n\\nfunc check(_ board: inout [[Character]], _ i: Int, _ j: Int, _ node: TrieNode, _ result: inout [String]) {\\n\\tif i < 0 || j < 0 || i >= board.count || j >= board[0].count { return }\\n\\tguard let currNode = node.children[board[i][j]] else { return }\\n\\n\\tif let word = currNode.word { \\n\\t\\tresult.append(word) \\n\\t\\tcurrNode.word = nil\\n\\t}\\n\\tlet char = board[i][j]\\n\\tboard[i][j] = \"0\"\\n\\n\\tcheck(&board, i - 1, j, currNode, &result)\\n\\tcheck(&board, i + 1, j, currNode, &result)\\n\\tcheck(&board, i, j - 1, currNode, &result)\\n\\tcheck(&board, i, j + 1, currNode, &result)\\n\\tboard[i][j] = char\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n\\tvar word: String?\\n\\tvar children = [Character: TrieNode]()\\n}\\n\\nfunc findWords(_ board: [[Character]], _ words: [String]) -> [String] {\\n\\tif board.isEmpty { return [] }\\n\\n\\tvar result = [String]()\\n\\tvar board = board\\n\\tlet root = buildTrie(with: words)\\n\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board[0].count {\\n\\t\\t\\tcheck(&board, i, j, root, &result)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc buildTrie(with words: [String]) -> TrieNode {\\n\\tlet root = TrieNode()\\n\\n\\tfor word in words {\\n\\t\\tvar node = root\\n\\t\\tfor char in word {\\n\\t\\t\\tif node.children[char] == nil{\\n\\t\\t\\t\\tnode.children[char] = TrieNode()\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[char]!\\n\\t\\t}\\n\\t\\tnode.word = word\\n\\t}\\n\\n\\treturn root\\n}\\n\\nfunc check(_ board: inout [[Character]], _ i: Int, _ j: Int, _ node: TrieNode, _ result: inout [String]) {\\n\\tif i < 0 || j < 0 || i >= board.count || j >= board[0].count { return }\\n\\tguard let currNode = node.children[board[i][j]] else { return }\\n\\n\\tif let word = currNode.word { \\n\\t\\tresult.append(word) \\n\\t\\tcurrNode.word = nil\\n\\t}\\n\\tlet char = board[i][j]\\n\\tboard[i][j] = \"0\"\\n\\n\\tcheck(&board, i - 1, j, currNode, &result)\\n\\tcheck(&board, i + 1, j, currNode, &result)\\n\\tcheck(&board, i, j - 1, currNode, &result)\\n\\tcheck(&board, i, j + 1, currNode, &result)\\n\\tboard[i][j] = char\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576003,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671852,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671886,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1672262,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566849,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1574381,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1676645,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1567225,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566535,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1570400,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1576003,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671852,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1671886,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1672262,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566849,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1574381,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1676645,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1567225,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1566535,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 1570400,
                "content": [
                    {
                        "username": "okinawa",
                        "content": "This question is the reason I lost Uber interview.\\nRead the solution well guys and don\\'t be in my position \\uD83D\\uDE13"
                    },
                    {
                        "username": "arjun202",
                        "content": "which region was it for ? Was it India or somewhere else?"
                    },
                    {
                        "username": "palakons",
                        "content": "finally avoid TLE with Trie (with capability to remove)\\nthe last eight hours has been fun"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Lol \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "bonagirimahaveer",
                        "content": "\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "\\uD83D\\uDC80"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seriously. So frustrating. I had the optimal algorithm pretty quickly, but it still TLE'd. Then I spent hours trying to figure out which optimization to apply.\n\nI finally figured out how to implemented removal, and it immediately passed. It didn't even help that much on the test case I TLE'd on. It was probably a cumulative thing where it helped a little on each test case."
                    },
                    {
                        "username": "ahmdsolmn",
                        "content": "I believe the description of this problem should be changed to clearly explain that the output should not contain duplicate words."
                    },
                    {
                        "username": "shamoonmohd",
                        "content": "Yeah in question it says that you can\\'t use same character in a word again, but official testcase fails if you do so,\\ninstead it should be no repeated word in the result."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I feel like the question description can be more explicit instead of making us discover certain requirements (no duplicates etc) on our own."
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am trying to understand the time complexity of searching one single word (forget about tires and so).\\n\\nSo if we have a \\n- One single word of lenght = l   \\n- A boar of M x N. \\nUsingl DFS with 4 directions to search for that word, what should be the time complexity??\\n\\nM * N * 4^l?\\nM * N *  M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI hvae seen all those different complexities for the same code\\nIf you can help to clarify that would be great!\\n"
                    },
                    {
                        "username": "JackingChen",
                        "content": "I think it\\'s the worst case of dfs times the board size. Please correct me if I have missed anything"
                    },
                    {
                        "username": "palakons",
                        "content": "[@shyam-2002](/shyam-2002) good thing I mention \"big oh\", lol. just kidding, yours will be a more conservative (better) estimate"
                    },
                    {
                        "username": "shyam-2002",
                        "content": "It will be m*n*3^l as you wouldn\\'t go in the direction from where you have come."
                    },
                    {
                        "username": "palakons",
                        "content": "M * N * 4^l  for single word with length l"
                    },
                    {
                        "username": "mickey3d",
                        "content": "The problem statement implies that you have to put words into a Trie and run DFS on the adjacent letters on board, with checking if given DFS iteration backtracked solution is included in a Trie, built with words.\\n\\nI was trying to do vise versa and ended up with time-exceeded error, cos if you try to build a Trie with all combinations of adjacent letter on the board, you end up with really big Trie and instant search. The majority of time is spent building Trie and few last leetcode tests time out during this stage.\\n\\nThere is tradeoff b/w search time of dfs based on the board info (leetcode accepted)  and time spent on building Trie based on board letters (leetcode does not accept this solution)."
                    },
                    {
                        "username": "anwei40",
                        "content": "Wondered about that - in the case of relatively small grid, relatively big dictionary, it\\'s still faster to build a board Trie and search words instead of the accepted way."
                    },
                    {
                        "username": "Anthony-Eid",
                        "content": "[@charant587](/charant587) \\n\\nThis is problematic\\n\\n```py\\ndef remove(self, word):\\n    cur = self\\n    cur.refs -= 1\\n    for c in word:\\n        if c in cur.children:\\n            cur = cur.children[c]\\n            cur.refs -= 1\\n```\\n\\nlet\\'s say c isn\\'t in cur.children, what happens? cur doesn\\'t change and it checks if the next c is in cur. This could potentially result in cur.refs being wrong for multiple curs. \\n\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "bro can you tell me please why this code is not giving output                                                                                            class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I guess can\\'t avoid Trie anymore."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen man... I thought I could avoid it too "
                    },
                    {
                        "username": "icehcamp",
                        "content": "Input:\\t[\"a\"], [\"a\",\"a\"]\\nOutput:\\t[\"a\",\"a\"]\\nExpected:\\t[\"a\"]\\n\\nNot quite sure why this output is incorrect. Can someone help clarify the question."
                    },
                    {
                        "username": "Finesse",
                        "content": "The result must contain each of the `words` at most once"
                    },
                    {
                        "username": "Praval791",
                        "content": "Cause \"a\" is uniquely present in words and your answer tells that there are 2 \"a\" words.\\nYou have to delete your string from trie after successully finding it."
                    },
                    {
                        "username": "scy_2020",
                        "content": "I have thought the Trie to build the board and use words to query the Trie. The time complexity is exponential. So I gave up. Then for the standard solution of this question, which is backtrack + Trie, the complexity should be exponential as well since the dfs tree size is O(4^n). I am wondering during the interview, whether it is  a good solution or not???\\n\\nThanks in advance."
                    },
                    {
                        "username": "palakons",
                        "content": "I am not sure, but I think a huge help would be pruning (i.e., removing the visited word from trie) That would make search space shrinks as the search goes on"
                    },
                    {
                        "username": "chui",
                        "content": "In the description, it says the longest word length will be 10. If you also keep getting TLE, maybe try this trick, works for mine."
                    }
                ]
            },
            {
                "id": 2050697,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1927304,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1899346,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1839998,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1979900,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1952808,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1672515,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1572999,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1572494,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1571438,
                "content": [
                    {
                        "username": "ak_3101",
                        "content": "After 2.5 hours of debugging and struggle, I officially hate this question. "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand testcase 65 / 65.\\nI\\'ve got TLE.\\nBut what does it mean:\\n\\nboard =\\n\\n?\\nWhit empty info about this testcase..."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This is ridiculous. How am I supposed to solve this in an interview if I\\'ve never seen it before lol"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "you dont"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Test case 65 is broken?\\nBoard is empty and no words input is provided"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "Yeah. I think so"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Getting TLE at 65th testcase"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Solve this one before :https://leetcode.com/problems/word-search/"
                    },
                    {
                        "username": "JorgeLDB",
                        "content": "![image](https://i.ibb.co/FHXHs0d/leet.jpg)\\n\\nHmm... at least I\\'m almost there. "
                    },
                    {
                        "username": "Gizmy",
                        "content": "![image](https://assets.leetcode.com/users/gizmy/image_1568395306.png)\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Going from `b` to `c` is a diagonal move which is forbidden"
                    },
                    {
                        "username": "durgaprasad1541996",
                        "content": "This problem do not expect you to traverse diagonally, that is the reason expected is empty."
                    },
                    {
                        "username": "lance6716",
                        "content": "That\\'s deliberately introduce trie, I can\\'t agree that query words share a long prefix without clearly stated in problem description. If we should consider these case, we should also consider words share suffix, common substring, etc. and trie won\\'t help."
                    },
                    {
                        "username": "piggysolucky",
                        "content": "Because the normal backtracking gave me an error (stack overflow) here."
                    }
                ]
            },
            {
                "id": 1863478,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1722308,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1676889,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1671781,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1573745,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1572943,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1572554,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1572547,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1571436,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1573996,
                "content": [
                    {
                        "username": "Heisenburgerrr",
                        "content": "Solving this question made me feel so high lol"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I don\\'t think use of tries is at all intuitive because generally words don\\'t share this big prefixes. I feel it should be mentioned somewhere in the question. \\nboard = [[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"],[\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\"],[\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]]\\n\\nwords = [\"ababababaa\",\"ababababab\",\"ababababac\",\"ababababad\",\"ababababae\",\"ababababaf\",\"ababababag\",\"ababababah\",\"ababababai\",\"ababababaj\",\"ababababak\",\"ababababal\",\"ababababam\",\"ababababan\",\"ababababao\",\"ababababap\",\"ababababaq\",\"ababababar\",\"ababababas\",\"ababababat\",\"ababababau\",\"ababababav\",\"ababababaw\",\"ababababax\",\"ababababay\",\"ababababaz\",\"ababababba\",\"ababababbb\",\"ababababbc\",\"ababababbd\",\"ababababbe\",\"ababababbf\",\"ababababbg\",\"ababababbh\",\"ababababbi\",\"ababababbj\",\"ababababbk\",\"ababababbl\",\"ababababbm\",\"ababababbn\",\"ababababbo\",\"ababababbp\",\"ababababbq\",\"ababababbr\",\"ababababbs\",\"ababababbt\",\"ababababbu\",\"ababababbv\",\"ababababbw\",\"ababababbx\",\"ababababby\",\"ababababbz\",\"ababababca\",\"ababababcb\",\"ababababcc\",\"ababababcd\",\"ababababce\",\"ababababcf\",\"ababababcg\",\"ababababch\",\"ababababci\",\"ababababcj\",\"ababababck\",\"ababababcl\",\"ababababcm\",\"ababababcn\",\"ababababco\",\"ababababcp\",\"ababababcq\",\"ababababcr\",\"ababababcs\",\"ababababct\",\"ababababcu\",\"ababababcv\",\"ababababcw\",\"ababababcx\",\"ababababcy\",\"ababababcz\",\"ababababda\",\"ababababdb\",\"ababababdc\",\"ababababdd\",\"ababababde\",\"ababababdf\",\"ababababdg\",\"ababababdh\",\"ababababdi\",\"ababababdj\",\"ababababdk\",\"ababababdl\",\"ababababdm\",\"ababababdn\",\"ababababdo\",\"ababababdp\",\"ababababdq\",\"ababababdr\",\"ababababds\",\"ababababdt\",\"ababababdu\",\"ababababdv\",\"ababababdw\",\"ababababdx\",\"ababababdy\",\"ababababdz\",\"ababababea\",\"ababababeb\",\"ababababec\",\"ababababed\",\"ababababee\",\"ababababef\",\"ababababeg\",\"ababababeh\",\"ababababei\",\"ababababej\",\"ababababek\",\"ababababel\",\"ababababem\",\"ababababen\",\"ababababeo\",\"ababababep\",\"ababababeq\",\"ababababer\",\"ababababes\",\"ababababet\",\"ababababeu\",\"ababababev\",\"ababababew\",\"ababababex\",\"ababababey\",\"ababababez\",\"ababababfa\",\"ababababfb\",\"ababababfc\",\"ababababfd\",\"ababababfe\",\"ababababff\",\"ababababfg\",\"ababababfh\",\"ababababfi\",\"ababababfj\",\"ababababfk\",\"ababababfl\",\"ababababfm\",\"ababababfn\",\"ababababfo\",\"ababababfp\",\"ababababfq\",\"ababababfr\",\"ababababfs\",\"ababababft\",\"ababababfu\",\"ababababfv\",\"ababababfw\",\"ababababfx\",\"ababababfy\",\"ababababfz\",\"ababababga\",\"ababababgb\",\"ababababgc\",\"ababababgd\",\"ababababge\",\"ababababgf\",\"ababababgg\",\"ababababgh\",\"ababababgi\",\"ababababgj\",\"ababababgk\",\"ababababgl\",\"ababababgm\",\"ababababgn\",\"ababababgo\",\"ababababgp\",\"ababababgq\",\"ababababgr\",\"ababababgs\",\"ababababgt\",\"ababababgu\",\"ababababgv\",\"ababababgw\",\"ababababgx\",\"ababababgy\",\"ababababgz\",\"ababababha\",\"ababababhb\",\"ababababhc\",\"ababababhd\",\"ababababhe\",\"ababababhf\",\"ababababhg\",\"ababababhh\",\"ababababhi\",\"ababababhj\",\"ababababhk\",\"ababababhl\",\"ababababhm\",\"ababababhn\",\"ababababho\",\"ababababhp\",\"ababababhq\",\"ababababhr\",\"ababababhs\",\"ababababht\",\"ababababhu\",\"ababababhv\",\"ababababhw\",\"ababababhx\",\"ababababhy\",\"ababababhz\",\"ababababia\",\"ababababib\",\"ababababic\",\"ababababid\",\"ababababie\",\"ababababif\",\"ababababig\",\"ababababih\",\"ababababii\",\"ababababij\",\"ababababik\",\"ababababil\",\"ababababim\",\"ababababin\",\"ababababio\",\"ababababip\",\"ababababiq\",\"ababababir\",\"ababababis\",\"ababababit\",\"ababababiu\",\"ababababiv\",\"ababababiw\",\"ababababix\",\"ababababiy\",\"ababababiz\",\"ababababja\",\"ababababjb\",\"ababababjc\",\"ababababjd\",\"ababababje\",\"ababababjf\",\"ababababjg\",\"ababababjh\",\"ababababji\",\"ababababjj\",\"ababababjk\",\"ababababjl\",\"ababababjm\",\"ababababjn\",\"ababababjo\",\"ababababjp\",\"ababababjq\",\"ababababjr\",\"ababababjs\",\"ababababjt\",\"ababababju\",\"ababababjv\",\"ababababjw\",\"ababababjx\",\"ababababjy\",\"ababababjz\",\"ababababka\",\"ababababkb\",\"ababababkc\",\"ababababkd\",\"ababababke\",\"ababababkf\",\"ababababkg\",\"ababababkh\",\"ababababki\",\"ababababkj\",\"ababababkk\",\"ababababkl\",\"ababababkm\",\"ababababkn\",\"ababababko\",\"ababababkp\",\"ababababkq\",\"ababababkr\",\"ababababks\",\"ababababkt\",\"ababababku\",\"ababababkv\",\"ababababkw\",\"ababababkx\",\"ababababky\",\"ababababkz\",\"ababababla\",\"abababablb\",\"abababablc\",\"ababababld\",\"abababable\",\"abababablf\",\"abababablg\",\"abababablh\",\"ababababli\",\"abababablj\",\"abababablk\",\"ababababll\",\"abababablm\",\"ababababln\",\"abababablo\",\"abababablp\",\"abababablq\",\"abababablr\",\"ababababls\",\"abababablt\",\"abababablu\",\"abababablv\",\"abababablw\",\"abababablx\",\"abababably\",\"abababablz\",\"ababababma\",\"ababababmb\",\"ababababmc\",\"ababababmd\",\"ababababme\",\"ababababmf\",\"ababababmg\",\"ababababmh\",\"ababababmi\",\"ababababmj\",\"ababababmk\",\"ababababml\",\"ababababmm\",\"ababababmn\",\"ababababmo\",\"ababababmp\",\"ababababmq\",\"ababababmr\",\"ababababms\",\"ababababmt\",\"ababababmu\",\"ababababmv\",\"ababababmw\",\"ababababmx\",\"ababababmy\",\"ababababmz\",\"ababababna\",\"ababababnb\",\"ababababnc\",\"ababababnd\",\"ababababne\",\"ababababnf\",\"ababababng\",\"ababababnh\",\"ababababni\",\"ababababnj\",\"ababababnk\",\"ababababnl\",\"ababababnm\",\"ababababnn\",\"ababababno\",\"ababababnp\",\"ababababnq\",\"ababababnr\",\"ababababns\",\"ababababnt\",\"ababababnu\",\"ababababnv\",\"ababababnw\",\"ababababnx\",\"ababababny\",\"ababababnz\",\"ababababoa\",\"ababababob\",\"ababababoc\",\"ababababod\",\"ababababoe\",\"ababababof\",\"ababababog\",\"ababababoh\",\"ababababoi\",\"ababababoj\",\"ababababok\",\"ababababol\",\"ababababom\",\"ababababon\",\"ababababoo\",\"ababababop\",\"ababababoq\",\"ababababor\",\"ababababos\",\"ababababot\",\"ababababou\",\"ababababov\",\"ababababow\",\"ababababox\",\"ababababoy\",\"ababababoz\",\"ababababpa\",\"ababababpb\",\"ababababpc\",\"ababababpd\",\"ababababpe\",\"ababababpf\",\"ababababpg\",\"ababababph\",\"ababababpi\",\"ababababpj\",\"ababababpk\",\"ababababpl\",\"ababababpm\",\"ababababpn\",\"ababababpo\",\"ababababpp\",\"ababababpq\",\"ababababpr\",\"ababababps\",\"ababababpt\",\"ababababpu\",\"ababababpv\",\"ababababpw\",\"ababababpx\",\"ababababpy\",\"ababababpz\",\"ababababqa\",\"ababababqb\",\"ababababqc\",\"ababababqd\",\"ababababqe\",\"ababababqf\",\"ababababqg\",\"ababababqh\",\"ababababqi\",\"ababababqj\",\"ababababqk\",\"ababababql\",\"ababababqm\",\"ababababqn\",\"ababababqo\",\"ababababqp\",\"ababababqq\",\"ababababqr\",\"ababababqs\",\"ababababqt\",\"ababababqu\",\"ababababqv\",\"ababababqw\",\"ababababqx\",\"ababababqy\",\"ababababqz\",\"ababababra\",\"ababababrb\",\"ababababrc\",\"ababababrd\",\"ababababre\",\"ababababrf\",\"ababababrg\",\"ababababrh\",\"ababababri\",\"ababababrj\",\"ababababrk\",\"ababababrl\",\"ababababrm\",\"ababababrn\",\"ababababro\",\"ababababrp\",\"ababababrq\",\"ababababrr\",\"ababababrs\",\"ababababrt\",\"ababababru\",\"ababababrv\",\"ababababrw\",\"ababababrx\",\"ababababry\",\"ababababrz\",\"ababababsa\",\"ababababsb\",\"ababababsc\",\"ababababsd\",\"ababababse\",\"ababababsf\",\"ababababsg\",\"ababababsh\",\"ababababsi\",\"ababababsj\",\"ababababsk\",\"ababababsl\",\"ababababsm\",\"ababababsn\",\"ababababso\",\"ababababsp\",\"ababababsq\",\"ababababsr\",\"ababababss\",\"ababababst\",\"ababababsu\",\"ababababsv\",\"ababababsw\",\"ababababsx\",\"ababababsy\",\"ababababsz\",\"ababababta\",\"ababababtb\",\"ababababtc\",\"ababababtd\",\"ababababte\",\"ababababtf\",\"ababababtg\",\"ababababth\",\"ababababti\",\"ababababtj\",\"ababababtk\",\"ababababtl\",\"ababababtm\",\"ababababtn\",\"ababababto\",\"ababababtp\",\"ababababtq\",\"ababababtr\",\"ababababts\",\"ababababtt\",\"ababababtu\",\"ababababtv\",\"ababababtw\",\"ababababtx\",\"ababababty\",\"ababababtz\",\"ababababua\",\"ababababub\",\"ababababuc\",\"ababababud\",\"ababababue\",\"ababababuf\",\"ababababug\",\"ababababuh\",\"ababababui\",\"ababababuj\",\"ababababuk\",\"ababababul\",\"ababababum\",\"ababababun\",\"ababababuo\",\"ababababup\",\"ababababuq\",\"ababababur\",\"ababababus\",\"ababababut\",\"ababababuu\",\"ababababuv\",\"ababababuw\",\"ababababux\",\"ababababuy\",\"ababababuz\",\"ababababva\",\"ababababvb\",\"ababababvc\",\"ababababvd\",\"ababababve\",\"ababababvf\",\"ababababvg\",\"ababababvh\",\"ababababvi\",\"ababababvj\",\"ababababvk\",\"ababababvl\",\"ababababvm\",\"ababababvn\",\"ababababvo\",\"ababababvp\",\"ababababvq\",\"ababababvr\",\"ababababvs\",\"ababababvt\",\"ababababvu\",\"ababababvv\",\"ababababvw\",\"ababababvx\",\"ababababvy\",\"ababababvz\",\"ababababwa\",\"ababababwb\",\"ababababwc\",\"ababababwd\",\"ababababwe\",\"ababababwf\",\"ababababwg\",\"ababababwh\",\"ababababwi\",\"ababababwj\",\"ababababwk\",\"ababababwl\",\"ababababwm\",\"ababababwn\",\"ababababwo\",\"ababababwp\",\"ababababwq\",\"ababababwr\",\"ababababws\",\"ababababwt\",\"ababababwu\",\"ababababwv\",\"ababababww\",\"ababababwx\",\"ababababwy\",\"ababababwz\",\"ababababxa\",\"ababababxb\",\"ababababxc\",\"ababababxd\",\"ababababxe\",\"ababababxf\",\"ababababxg\",\"ababababxh\",\"ababababxi\",\"ababababxj\",\"ababababxk\",\"ababababxl\",\"ababababxm\",\"ababababxn\",\"ababababxo\",\"ababababxp\",\"ababababxq\",\"ababababxr\",\"ababababxs\",\"ababababxt\",\"ababababxu\",\"ababababxv\",\"ababababxw\",\"ababababxx\",\"ababababxy\",\"ababababxz\",\"ababababya\",\"ababababyb\",\"ababababyc\",\"ababababyd\",\"ababababye\",\"ababababyf\",\"ababababyg\",\"ababababyh\",\"ababababyi\",\"ababababyj\",\"ababababyk\",\"ababababyl\",\"ababababym\",\"ababababyn\",\"ababababyo\",\"ababababyp\",\"ababababyq\",\"ababababyr\",\"ababababys\",\"ababababyt\",\"ababababyu\",\"ababababyv\",\"ababababyw\",\"ababababyx\",\"ababababyy\",\"ababababyz\",\"ababababza\",\"ababababzb\",\"ababababzc\",\"ababababzd\",\"ababababze\",\"ababababzf\",\"ababababzg\",\"ababababzh\",\"ababababzi\",\"ababababzj\",\"ababababzk\",\"ababababzl\",\"ababababzm\",\"ababababzn\",\"ababababzo\",\"ababababzp\",\"ababababzq\",\"ababababzr\",\"ababababzs\",\"ababababzt\",\"ababababzu\",\"ababababzv\",\"ababababzw\",\"ababababzx\",\"ababababzy\",\"ababababzz\"]"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hashmap fails at this test case:)"
                    },
                    {
                        "username": "keidakira1412",
                        "content": "After solving this problem, I can\\n- Build a crossword puzzle app\\n- Add it to my resume\\n- Hope to get a job"
                    },
                    {
                        "username": "Vikas_Sen",
                        "content": "can not this question be solved without Trie. I have not covered this topic yet. I\\'ve solved word search problem-I easily. how can this question be solved with that methos?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Vikas Sen](/Codeverse_1) Yes!"
                    },
                    {
                        "username": "zooperman",
                        "content": "Hello Mods,\\n\\nthe program seems to run fine with TC-3, when run stand-alone, or with other TC\\'s, but when this is submitted for evaluation, it fails.\\nPlease check this.\\nThe TC-3, runs as expected on my laptop as well, along with other TC\\'s.![image](https://assets.leetcode.com/users/zooperman/image_1589425337.png)\\n"
                    },
                    {
                        "username": "greedycat",
                        "content": "They seem the same but Q212 is ranked hard and Q079 is ranked medium. Am I missing something? The only difference I can spot is in Q212 you search for multiple words in a list. But isn\\'t this change trivial because I can just repeat Q079 for the list?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@greedycat](/greedycat) For P79: length.word is15 and board is 6*6, only a single word. A mere DFS can pass without TLE. But for a list of words, Trie/treenode or dict are far from good. \nI try so hard to improve my DFS/path&graph. Finally, It works! But it's nothing compare to Trie."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Yes but I think they want something else, it looks like a trie or something. for multiple words that starts with same prefix rather than applying 79 on each word, use the prefix and search for both words."
                    },
                    {
                        "username": "user5502m",
                        "content": "I was thinking that too"
                    },
                    {
                        "username": "sarthak13",
                        "content": "[[\"a\"]]\\n[\"a\",\"a\"]\\n\\nOutput is \"a\".\\nAs per the question it should be \"a\",\"a\".\\n\\nAm I missing anything?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "How is the matching any different than https://leetcode.com/problems/word-break-ii/ ?"
                    },
                    {
                        "username": "gglmg",
                        "content": "Question  says you cannot use same letter more than once but the example given has used 't' in both oath and eat.\\n\\nWhat am I missing here.\\n'"
                    },
                    {
                        "username": "palakons",
                        "content": "also, not the same letter per se, but same (row,col) position"
                    },
                    {
                        "username": "AyushSinha",
                        "content": "I think the same letter shouldn\\'t be used twice in the same word."
                    },
                    {
                        "username": "dskloet",
                        "content": "Why is this problem about speed? The inputs were crafted to fail some non-optimized solutions but not others. I bet none of the posted solutions pass this input:\\n\\n[[\"x\",\"x\",\"a\",\"x\",\"x\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"o\",\"o\",\"o\",\"o\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"x\"],[\"x\",\"x\",\"o\",\"x\",\"x\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"o\"],[\"o\",\"o\",\"o\",\"o\",\"b\"]]\\n[\"aooooooooooooooooooooooooooooooooooooooooooooooooooooob\"]"
                    },
                    {
                        "username": "charonme",
                        "content": "it says: \"Invalid Testcase\\nexpected \\'board\\' to have 1 <= size <= 12 but got 15\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@dskloet](/dskloet)\nMy pure DFS solution 989ms in Leetcode, solve your problem only: 1.9944 miliseconds\n\ncheck data  # | i&j = [14, 4], word= b b 54\n['aooooooooooooooooooooooooooooooooooooooooooooooooooooob']\n\nBut Trie gets TLE for sure.\n\t"
                    },
                    {
                        "username": "echobeacon",
                        "content": "Problem constraints say all words are 10 characters or less"
                    },
                    {
                        "username": "Fluffy_Memory_6238",
                        "content": "If word exceeds m or n we can simply leave that one? also m,n<=12"
                    }
                ]
            },
            {
                "id": 1567917,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2030936,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2028010,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2010884,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1962211,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1944125,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1933664,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1889051,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1840446,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757517,
                "content": [
                    {
                        "username": "scott",
                        "content": "my submitted code  was using pure back track and passed OJ \\n\\nI cannot see any need of using trie for the problem"
                    },
                    {
                        "username": "omkashyap007",
                        "content": "Anyone please help . Why this is not working . I made a simple dfs solution with backtracking . It seems to work with 58 test cases but fails at 59 .\\n\\nthis is board : [[\"a\",\"b\",\"c\"],[\"a\",\"e\",\"d\"],[\"a\",\"f\",\"g\"]]\\nwords : [\"abcdefg\",\"gfedcbaaa\",\"eaabcdgfa\",\"befa\",\"dgc\",\"ade\"]\\noutput : [\"gfedcbaaa\",\"abcdefg\",\"befa\"]\\nexpected : [\"abcdefg\",\"befa\",\"eaabcdgfa\",\"gfedcbaaa\"]\\n\\nwhat is wrong with the code : \\ncode : \\n ```\\nclass Solution:\\n\\n    def inside(self , i , j , grid):\\n        if i>= 0 and i < len(grid) and j>=0 and j < len(grid[0]) :\\n            return True\\n        return False\\n\\n    def dfs(self , i , j , index , word , grid , visited):\\n        if index >= len(word) : \\n            return True\\n        elif self.inside(i , j , grid) and not visited[i][j] and word[index] == grid[i][j] : \\n            found = False\\n            visited[i][j] = True\\n            found = any(\\n                [\\n                    self.dfs(i+1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i-1 , j , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j+1 , index+1 , word , grid , visited) ,\\n                    self.dfs(i , j-1 , index+1 , word , grid , visited) ,\\n                ]\\n            )\\n            visited = False\\n            return found\\n        else :\\n            return False\\n\\n    def findWords(self, grid: List[List[str]], words: List[str]) -> List[str]:\\n        wordMap = {}\\n        for word in words : \\n            char = word[0]\\n            wordMap[char] = wordMap.get(char , []) + [word]\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        answer = set()\\n        for i in range(rows) :\\n            for j in range(cols) :\\n                start_char = grid[i][j]\\n                if start_char not in wordMap :\\n                    continue\\n                wordList = wordMap[start_char]\\n                for word in wordList : \\n                    visited = [[False for _ in range(cols)] for _ in range(rows)]\\n                    if self.dfs(i , j , 0 , word , grid , visited) :\\n                        answer.add(word)\\n        return answer\\n```"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "- You have set visited = False, it should be visited[i][j] = False \\n- While returning answer as list(answer) for convert set to list for the final result"
                    },
                    {
                        "username": "deadpool1205",
                        "content": "There should not be any duplicate words in answer keep that in mind for avoiding wrong submissions  :)"
                    },
                    {
                        "username": "user2075nF",
                        "content": "is the only way to pass last few test cases is to use prefix tree? or is there any other magic available?"
                    },
                    {
                        "username": "Jagadish_Shankar",
                        "content": "class Solution {\\n\\n    public boolean recursive_function(int i , int j , int rows , int columns , char[][] board , boolean[][] visited_cells , int index , String word , int word_length) {\\n\\n        if(index == word_length){\\n            return true;\\n        }\\n\\n        visited_cells[i][j] = true;\\n\\n        boolean top = (((i - 1) >= 0) && (word.charAt(index) == board[(i - 1)][j]) && (!visited_cells[(i - 1)][j]) && (recursive_function((i - 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean bottom = (((i + 1) < rows) && (word.charAt(index) == board[(i + 1)][j]) && (!visited_cells[(i + 1)][j]) && (recursive_function((i + 1) , j , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean left = (((j - 1) >= 0) && (word.charAt(index) == board[i][(j - 1)]) && (!visited_cells[i][(j - 1)]) && (recursive_function(i , (j - 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        boolean right = (((j + 1) < columns) && (word.charAt(index) == board[i][(j + 1)]) && (!visited_cells[i][(j + 1)]) && (recursive_function(i , (j + 1) , rows , columns , board , visited_cells , (index + 1) , word , word_length)));\\n\\n        visited_cells[i][j] = false;\\n\\n        return (top || bottom || left || right);\\n    }\\n\\n    public List<String> findWords(char[][] board , String[] words) {\\n\\n        int rows = board.length;\\n        \\n        int columns = board[0].length;\\n\\n        Set<String> all_words_in_board = new HashSet<String>();\\n        \\n        for(String word : (new HashSet<String>(Arrays.asList(words)))){\\n\\n            boolean word_found_flag = false;\\n            \\n            for (int i=0 ; (i < rows) ; i++) {\\n                \\n                for (int j=0 ; (j < columns) ; j++) {\\n                    \\n                    if((board[i][j] == word.charAt(0)) && (recursive_function(i , j , rows , columns , board , (new boolean[rows][columns]) , 1 , word , (word.length())))){\\n                        all_words_in_board.add(word);\\n                        word_found_flag = true;\\n                        break;\\n                    }\\n                }\\n\\n                if(word_found_flag){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return (new ArrayList<String>(all_words_in_board));\\n    }\\n}\\n\\ncan somebody help me to optimize my program since it\\'s failing the last 3 test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "can some one tell why this code is not giving output \\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.istrue = False\\n        self.refs = 0\\n\\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n            cur.refs += 1\\n        self.istrue = True\\n\\n    def remove(self, word):\\n        cur = self\\n        cur.refs -= 1\\n        for c in word:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                cur.refs -= 1\\n\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        root = TrieNode()\\n        for word in words:\\n            root.insert(word)\\n        rows, cols = len(board), len(board[0])\\n        output, path = set(), set()\\n\\n        def dfs(r, c, node, word):\\n            if (\\n                r < 0\\n                or c < 0\\n                or r >= rows\\n                or c >= cols\\n                or board[r][c] not in node.children\\n                or node.children[board[r][c]].refs < 1\\n                or (r, c) in path\\n            ):\\n                return\\n\\n            path.add((r, c))\\n            node = node.children[board[r][c]]\\n            word += board[r][c]\\n            if node.istrue:\\n                output.add(word)\\n                node.istrue = False\\n                \\n                node.remove(word)\\n\\n            dfs(r + 1, c, node, word)\\n            dfs(r - 1, c, node, word)\\n            dfs(r, c + 1, node, word)\\n            dfs(r, c - 1, node, word)\\n            path.remove((r, c))\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, root, \"\")\\n\\n        return list(output)\\n"
                    },
                    {
                        "username": "arushi-08",
                        "content": "I have spent a lot of time trying to debug this solution, but I am still facing TLE error while submitting code (while the testcase itself gets accepted). Please suggest an optimization:\\n\\nPython:\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.endofword = False\\n\\n    def addWord(self, word):\\n        curr = self\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = Node()\\n            curr = curr.children[c]\\n        curr.endofword = True\\n\\nclass Solution:\\n\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        root = Node()\\n        for w in words:\\n            root.addWord(w)\\n        \\n        self.res = []\\n        word = \\'\\'\\n        visited = set()\\n        rows = len(board)\\n        cols = len(board[0])\\n\\n        def dfs(x, y, node, word):\\n            if (x,y) in visited or board[x][y] not in node.children:\\n                return\\n            \\n            visited.add((x,y))\\n            node = node.children[board[x][y]]\\n            word += board[x][y]\\n            \\n            if node.endofword:\\n                self.res.append(word)\\n\\n            rrows = [-1, 0, 1, 0]\\n            ccols = [0, 1, 0, -1]\\n            for r,c in zip(rrows, ccols):\\n                if x+r >= 0 and y+c >= 0 and x+r < rows and y+c < cols:\\n                    dfs(x+r, y+c, node, word)\\n\\n            visited.remove((x,y))\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if board[i][j] in root.children:\\n                    dfs(i, j, root, word)\\n        \\n        return list(set(self.res))\\n\\n```"
                    },
                    {
                        "username": "sianliu1997",
                        "content": "\\nIn PyCharm, my code works fine, but when I submit it to LeetCode, an extra \\'oa\\' is added to the output. Why is this happening?\\n\\n```py\\nclass Solution:\\n    def findWords(self, board, words):\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(board, i, j, word, k=0):\\n            b = copy.deepcopy(board)\\n            if k == len(word):\\n                return True\\n            if not 0 <= i < m or not 0 <= j < n or b[i][j] == \\'#\\' or b[i][j] != word[k]:\\n                return False\\n            b[i][j] = \\'#\\'\\n            return dfs(b, i + 1, j, word, k + 1) or \\\\\\n                   dfs(b, i - 1, j, word, k + 1) or \\\\\\n                   dfs(b, i, j + 1, word, k + 1) or \\\\\\n                   dfs(b, i, j - 1, word, k + 1)\\n\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                for w in words:\\n                    if board[i][j] == w[0] and dfs(board, i, j, w):\\n                        res.append(w)\\n        return res\\n```"
                    },
                    {
                        "username": "cagils",
                        "content": "Tips for general algorithm structure using Trie, Backtracing, and DFS with JS:\\n\\n```js\\nvar findWords = function (board, words) {\\n    const contains = []\\n    const trie = {} // A simple object is enough for a simple trie here\\n\\n    buildTrie()\\n\\n    *** HERE CALL DFS() ON EACH CELL ***\\n\\n    return contains\\n\\n    function buildTrie() {\\n        *** HERE BUILD TRIE FOR WORDS IN WORDS LIST ***\\n    }\\n\\n    function dfs(i, j, node, word) {\\n        *** HERE RECURSIVE DFS ON EACH DIRECTION ***\\n        *** IF WORD FINISHES ADD TO CONTAINS ***\\n        *** STORE CURRENT CHAR ON TEMP AND CHANGE IT TO INVALID CHARACTER ***\\n        *** AFTER DFS CALLS RESTORE THE CHARACTER (BACKTRACING) ***\\n    }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1751965,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1734144,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1730080,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1719253,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1714251,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1702647,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1676756,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1672541,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1672404,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            },
            {
                "id": 1672255,
                "content": [
                    {
                        "username": "ramadanizm",
                        "content": "What is the wrong with my solution ? why some test cases do not pass\\n```\\nclass TrieNode{\\n    Map<Character , TrieNode> children;\\n    boolean endOfWord;\\n\\n   public TrieNode(){ // no input  :) \\n        children = new HashMap<>();\\n        endOfWord = false;\\n   }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = this;\\n        for(char c : word.toCharArray() ){\\n            if (curr.children.get(c) == null){\\n                curr.children.put(c , new TrieNode());\\n            }\\n            curr = curr.children.get(c);\\n        }\\n        curr.endOfWord = true;\\n    }\\n}\\n    \\nclass Solution {\\n    static final int[][] DIRECTIONS = new int [][]{{1,0} , {-1,0} , {0,1}, {0,-1}};\\n         public List<String> findWords(char[][] board, String[] words) {\\n            int rows = board.length ; int cols = board[0].length;\\n            TrieNode root = new TrieNode();\\n             for(String word : words){\\n                root.addWord(word);\\n             }\\n\\n             boolean [][] visit  = new boolean[rows][cols];\\n             for(boolean[] row: visit)\\n                Arrays.fill(row , false);\\n           \\n\\n             Set<String> result  = new HashSet<>();\\n             for (int r= 0 ; r < rows ; r++){\\n                 for(int c= 0 ; c < cols ; c++){\\n\\n                     dfs(board , r, c , visit , new StringBuilder()  , result, root );\\n                 }\\n             }\\n         /*\\n            System.out.print(result );\\n            List<String> list = new ArrayList<>();\\n            for(String word:words){\\n                if (result.contains(word)){\\n                  list.add(word);  \\n                } \\n                    \\n            }\\n            */\\n            \\n             return new ArrayList<>(result);\\n             \\n\\n}\\n\\nvoid dfs(char[][] board, int r, int c ,boolean [][] visit , StringBuilder path ,  Set<String>  result, TrieNode root   ){\\n\\nif (outOfBound(board  , r, c) || visit[r][c] || root.children.get(board[r][c])  == null){\\n    return ;\\n}\\n\\npath.append(board[r][c]);\\nvisit[r][c] = true;\\nroot = root.children.get(board[r][c]);\\nif (root.endOfWord){\\n    result.add(path.toString());\\n}\\n\\nfor(int[] dir:DIRECTIONS){\\n    dfs(board, r+ dir[0] , c+dir[1] , visit, path,result ,root );\\n}\\n\\nvisit[r][c] = false; // the c could be used in another path (backtracking )\\n\\n}\\n\\nprivate boolean outOfBound(char [][] board , int r , int c){\\n    if ( r < 0 || c < 0 || r >= board.length || c >= board[0].length){\\n        return true;\\n    }\\n    return false;\\n}\\n\\n}\\n```"
                    },
                    {
                        "username": "ababuji",
                        "content": "Language specific TLE  shouldn\\'t be happening. I see asymptotic time complexities being the same regardless of whether the solution is being implemented in Python or Java. \\n\\n"
                    },
                    {
                        "username": "heckervarun",
                        "content": "guys i\\'m getting TLE , can anyone give me some reason why ?, i used dfs on the matrix, any idea to reduce time complexity ?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@VaruN](/heckervarun) Trie, or you need to improve your dfs function if you dont want to use Trie-dic/set.\\nHope you will get new ideas for dfs algorithm, I would like to share my solution on Python3 for 2 direction searchs.\\nhttps://leetcode.com/problems/word-search-ii/solutions/2998236/dfs-no-trie-python-3-path-following-beats-96-12-95-0/"
                    },
                    {
                        "username": "pratikvijayakar31",
                        "content": "I am confused. For example 1, why do we output \"oath\" and \"eat\". Since \"t\" alphabet is common in both strings and hence I believe it cannot be used for both words. Can someone clarify the rule \"The same letter cell may not be used more than once in a word.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Pratik Vijayakar](/pratikvijayakar31) \"not be used more than once in a word\", t may be presented once in _previous_ \"oath\", then you should not count it on _new_ word search, i.e. \"eat\"!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "Test case 22 is evil.\n\nEdit: managed to pass it by removing nodes from the prefix tree once I've already seen it and it doesnt have any children of its own."
                    },
                    {
                        "username": "pankajnegi010795",
                        "content": "Can anybody tell that why my following code showing TLE and same code in java accepted all test cases.\\n java code ref  https://leetcode.com/problems/word-search-ii/solutions/59780/java-15ms-easiest-solution-100-00/\\n\\nMy code\\n\\nclass Solution {\\n    struct Node\\n    {\\n        Node * next[26];\\n       string isend;\\n    };\\npublic:\\n    Node * newnode()\\n    {\\n        Node * node=new Node();\\n        for(int i=0;i<26;i++)\\n        node->next[i]=nullptr;\\n        node->isend=\"\";\\n        return node;\\n    }\\n    void createtrie(Node* head,string s1)\\n    {\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(head->next[s1[i]-\\'a\\']==nullptr)\\n            head->next[s1[i]-\\'a\\']=newnode();\\n            head=head->next[s1[i]-\\'a\\'];\\n        }\\n        head->isend=s1;\\n    }\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n      vector<string> res;\\n       Node * head=newnode();\\n       unordered_set<string> ve;\\n        for(int i=0;i<words.size();i++)\\n       {\\n           createtrie(head,words[i]);\\n       }\\n\\n        \\n            for(int l=0;l<board.size();l++)\\n            {\\n                for(int m=0;m<board[0].size();m++)\\n                {\\n                   \\n             vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n                checkfor(board,l,m,vis,ve,head);\\n   \\n                }\\n           \\n            }\\n            for(auto i=ve.begin();i!=ve.end();i++)\\n            {\\n                res.push_back(*i);\\n            }\\n        \\n        return res;\\n        \\n    }\\n   void checkfor(vector<vector<char>>& b,int i,int j,vector<vector<int>> vis,unordered_set<string>&ve,Node* head)\\n    {\\n        if(i>=b.size() or i<0 or j<0 or j>=b[0].size() )\\n            return ;\\n       if(vis[i][j]==true)\\n            return ;\\n\\n        if(head->next[b[i][j]-\\'a\\']==nullptr)\\n        return ;\\n              head=head->next[b[i][j]-\\'a\\'];\\n        if(head->isend.size()>0)\\n        {\\n            ve.insert(head->isend);\\n            head->isend=\"\";\\n        }\\n        vis[i][j]=true;\\n       checkfor(b,i+1,j,vis,ve,head) ;\\n       checkfor(b,i,j+1,vis,ve,head);\\n        checkfor(b,i-1,j,vis,ve,head) ;\\n        checkfor(b,i,j-1,vis,ve,head);\\n\\n\\n        vis[i][j]=false;\\n       return ;\\n    }\\n};\\n"
                    },
                    {
                        "username": "nickpavini",
                        "content": "Here is a DP solution I am working on that currently passes 55 of 64 cases. It fails on the test:\\n\\n`board =\\n[[\"a\",\"a\"]]\\nwords =\\n[\"aaa\"]\\nExpected = \\n[]`\\n\\nBasically we break words down and check if the left overs have been found and if this current letter is next to a location of the rest of the word.\\n\\nThe issue I have right now with that test case, is that after `aa` is found going 2 directions, the third `a` doesnt realize that we have overlap.\\n\\nAny ideas on a way to close off this solution?\\n\\n```\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        if not board:\\n            return []\\n\\n        rtn = []\\n        memo = {}\\n        for word in words:\\n            self.dp(board, word, memo)\\n            if not (-1,-1) in memo[word]:\\n                rtn.append(word)        \\n        return rtn\\n\\n    def dp(self, board, word,  memo):\\n        if word in memo:\\n            return\\n\\n        leftOver = word[1:]\\n        if leftOver != \\'\\':\\n            self.dp(board, leftOver, memo)\\n            if (-1, -1) in memo[leftOver]:\\n                memo[word] = {(-1,-1): 1}\\n                return\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    if leftOver == \\'\\' or (i,j+1) in memo[leftOver] or (i,j-1) in memo[leftOver] or (i+1,j) in memo[leftOver] or (i-1,j) in memo[leftOver]:\\n                        if word in memo:\\n                            memo[word][(i,j)] = 1\\n                        else:\\n                            memo[word] = {(i,j): 1}\\n                    \\n\\n        if not word in memo:\\n            memo[word] = {(-1,-1): 1}\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I dont really understand how a trie is faster than a set. I was able to get my python version running with a set of acceptable prefixes... once. Everytime after that I got TLE. But isnt a tree pretty much a hashed set anyhow? I thought set lookups were O(1). I dont understand how looking up a given prefix in the Trie, returning a small set of acceptable \"following\" letters, and comparing neighbors to the current cell to see if they fall in this set is any different than looking up the entire prefix so far + one of the neighbors in a big list of acceptable prefixes. Both involve at least one set check, and as a hashed structure, should take the same amount of time? Similarly, how does pruning help? It doesnt take less time to find inclusion in a hashed set if the set is smaller I thought? Look ups HASH the target and see if it exists, regardless of other hashed values: its the entire point of hashing, so look ups are O(1)"
                    },
                    {
                        "username": "palakons",
                        "content": "pruning helps, and prefix \"set\" would work f you could prune the prefix set... which is difficult"
                    },
                    {
                        "username": "drap5468",
                        "content": "The way pruning works for this problem is you *entirely* remove a word you already visited, including its prefixes. That way in future traversal you'll know to stop if the only valid route remaining leads to a used word.\n\nIf you never prune, that means you keep traversing routes that are no longer useful to you. Specifically in your code, the condition to continue down a path is whether the current sequence is in prefix_set. Since you never update prefix_set, you end up with a lot of very expensive false positives, going down paths that *used to be* relevant, but no longer are, since that word has been used up.\n\nI agree that your hashing method probably simulates a trie closely enough to work for this problem, so if you implement pruning I bet it will consistently finish running on time."
                    },
                    {
                        "username": "siseendri",
                        "content": " @ `your inline code...your inline code...` `your inline code...your inline code...` @"
                    },
                    {
                        "username": "Ar_2000",
                        "content": "can anyone help me why am I getting TLE for this solution -\\n\\n  class trieNode {\\n    public:\\n        char ch;\\n        vector<trieNode*> child;\\n        bool isEnd;\\n\\n        trieNode() {\\n            for (int i = 0; i < 26; i++) {\\n                child.push_back(NULL);\\n            }\\n\\n            isEnd = false;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> change = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void buildTrie (trieNode* root, string& s, int i) {\\n        if (i == s.size()) {\\n            root->isEnd = true;\\n            return;\\n        }\\n\\n        trieNode* child = new trieNode();\\n        if (root->child[s[i]-\\'a\\'] == NULL) {\\n            child->ch = s[i];\\n            root->child[s[i]-\\'a\\'] = child;\\n        } else {\\n            child = root->child[s[i]-\\'a\\'];\\n        }\\n\\n        buildTrie(child, s, i+1);\\n    }\\n\\n    void p (vector<vector<char>>& b, int i, int j, trieNode* node, set<string>& ans, string& str) {\\n        int n = b.size(), m = b[0].size();\\n        str += node->ch;\\n\\n        b[i][j] = \\'?\\';\\n\\n        if (node->isEnd) ans.insert(str);\\n\\n        for (vector<int> a : change) {\\n            int nx = i+a[0], ny = j+a[1];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && b[nx][ny] != \\'?\\') {\\n                if (node->child[b[nx][ny]-\\'a\\'] != NULL)  p (b, nx, ny, node->child[b[nx][ny]-\\'a\\'], ans, str);\\n            }\\n        }\\n\\n        b[i][j] = node->ch;\\n        str.pop_back();\\n    }\\n\\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n        // time complexity -> words.length * words[i].length = 3*(10^5)\\n        trieNode* root = new trieNode();\\n        root->ch = \\'$\\';\\n        for (string& w : words) {\\n            buildTrie(root, w, 0);\\n        }\\n\\n        set<string> ans;\\n        int n = board.size(), m = board[0].size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char ch = board[i][j];\\n                if (root->child[ch-\\'a\\'] != NULL) {\\n                    string str = \"\";\\n                    p(board, i, j, root->child[ch-\\'a\\'], ans, str);\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n\\n        for (string s : ans) {\\n            res.push_back(s);\\n        }\\n\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "[@Ar_2000](/Ar_2000) I implemented in the similar way you did in java that gave me TLE when I implemented in the way I told you that accepted my solution. If you want I can give you my java based solution so that you can compare where you are going wrong."
                    },
                    {
                        "username": "Ar_2000",
                        "content": "[@nikhil97agra](/nikhil97agra) but it still gives tle. and it should be. Adding and poping in and from a string in O(1) operation only"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I\\'m not sure but I think variable str you used to append character at each and every call that is causing you TLE.  Instead try this : instead isEnd variable in your class make it a string variable with initial value as null and when you are constructing your trie whenever some word ends just assign that variable to that word so what will happen is when you do recursion call to search for the word and you come at that trie node whose string variable is not null that means your word exist in the list in this way that extra overhead of appending and removing character from str variable will not be there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Burst Balloons",
        "question_content": "<p>You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.</p>\n\n<p>If you burst the <code>i<sup>th</sup></code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds of the array, then treat it as if there is a balloon with a <code>1</code> painted on it.</p>\n\n<p>Return <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,5,8]\n<strong>Output:</strong> 167\n<strong>Explanation:</strong>\nnums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 76228,
                "title": "share-some-analysis-and-explanations",
                "content": "**See [here for a better view](http://algobox.org/burst-balloons/)**\\n\\n**Be Naive First**\\n\\nWhen I first get this problem, it is far from dynamic programming to me. I started with the most naive idea the backtracking.\\n\\nWe have n balloons to burst, which mean we have n steps in the game. In the i th step we have n-i balloons to burst, i = 0~n-1. Therefore we are looking at an algorithm of O(n!). Well, it is slow, probably works for n < 12 only.\\n\\nOf course this is not the point to implement it. We need to identify the redundant works we did in it and try to optimize.\\n\\nWell, we can find that for any balloons left the maxCoins does not depends on the balloons already bursted. This indicate that we can use memorization (top down) or dynamic programming (bottom up) for all the cases from small numbers of balloon until n balloons. How many cases are there?  For k balloons there are C(n, k) cases and for each case it need to scan the k balloons to compare. The sum is quite big still. It is better than O(n!) but worse than O(2^n).\\n\\n\\n**Better idea**\\n\\nWe then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis.\\n\\nWell,  the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future.\\n\\nThen another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore\\ninstead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst. \\n\\nWhy is that? Because only the first and last balloons we are sure of their adjacent balloons before hand!\\n\\nFor the first we have `nums[i-1]*nums[i]*nums[i+1]` for the last we have `nums[-1]*nums[i]*nums[n]`.\\n\\n\\nOK. Think about n balloons if i is the last one to burst, what now?\\n\\nWe can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp.\\n\\n**Final**\\n\\nHere comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won't give any coins.\\nThe algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution.\\n\\n**Java D&C with Memoization**\\n\\n    public int maxCoins(int[] iNums) {\\n        int[] nums = new int[iNums.length + 2];\\n        int n = 1;\\n        for (int x : iNums) if (x > 0) nums[n++] = x;\\n        nums[0] = nums[n++] = 1;\\n\\n\\n        int[][] memo = new int[n][n];\\n        return burst(memo, nums, 0, n - 1);\\n    }\\n\\n    public int burst(int[][] memo, int[] nums, int left, int right) {\\n        if (left + 1 == right) return 0;\\n        if (memo[left][right] > 0) return memo[left][right];\\n        int ans = 0;\\n        for (int i = left + 1; i < right; ++i)\\n            ans = Math.max(ans, nums[left] * nums[i] * nums[right] \\n            + burst(memo, nums, left, i) + burst(memo, nums, i, right));\\n        memo[left][right] = ans;\\n        return ans;\\n    }\\n    // 12 ms\\n\\n**Java DP**\\n\\n    public int maxCoins(int[] iNums) {\\n        int[] nums = new int[iNums.length + 2];\\n        int n = 1;\\n        for (int x : iNums) if (x > 0) nums[n++] = x;\\n        nums[0] = nums[n++] = 1;\\n\\n\\n        int[][] dp = new int[n][n];\\n        for (int k = 2; k < n; ++k)\\n            for (int left = 0; left < n - k; ++left) {\\n                int right = left + k;\\n                for (int i = left + 1; i < right; ++i)\\n                    dp[left][right] = Math.max(dp[left][right], \\n                    nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]);\\n            }\\n\\n        return dp[0][n - 1];\\n    }\\n    // 17 ms\\n\\n**C++ DP**\\n\\n    int maxCoinsDP(vector<int> &iNums) {\\n        int nums[iNums.size() + 2];\\n        int n = 1;\\n        for (int x : iNums) if (x > 0) nums[n++] = x;\\n        nums[0] = nums[n++] = 1;\\n\\n\\n        int dp[n][n] = {};\\n        for (int k = 2; k < n; ++k) {\\n            for (int left = 0; left < n - k; ++left)\\n                int right = left + k;\\n                for (int i = left + 1; i < right; ++i)\\n                    dp[left][right] = max(dp[left][right],\\n                         nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]);\\n            }\\n\\n        return dp[0][n - 1];\\n    }\\n    // 16 ms\\n\\n**Python DP**\\n\\n    def maxCoins(self, iNums):\\n        nums = [1] + [i for i in iNums if i > 0] + [1]\\n        n = len(nums)\\n        dp = [[0]*n for _ in xrange(n)]\\n\\n        for k in xrange(2, n):\\n            for left in xrange(0, n - k):\\n                right = left + k\\n                for i in xrange(left + 1,right):\\n                    dp[left][right] = max(dp[left][right],\\n                           nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\\n        return dp[0][n - 1]\\n\\n    # 528ms",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "**See [here for a better view](http://algobox.org/burst-balloons/)**\\n\\n**Be Naive First**\\n\\nWhen I first get this problem, it is far from dynamic programming to me. I started with the most naive idea the backtracking.\\n\\nWe have n balloons to burst, which mean we have n steps in the game. In the i th step we have n-i balloons to burst, i = 0~n-1. Therefore we are looking at an algorithm of O(n!). Well, it is slow, probably works for n < 12 only.\\n\\nOf course this is not the point to implement it. We need to identify the redundant works we did in it and try to optimize.\\n\\nWell, we can find that for any balloons left the maxCoins does not depends on the balloons already bursted. This indicate that we can use memorization (top down) or dynamic programming (bottom up) for all the cases from small numbers of balloon until n balloons. How many cases are there?  For k balloons there are C(n, k) cases and for each case it need to scan the k balloons to compare. The sum is quite big still. It is better than O(n!) but worse than O(2^n).\\n\\n\\n**Better idea**\\n\\nWe then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis.\\n\\nWell,  the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future.\\n\\nThen another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore\\ninstead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst. \\n\\nWhy is that? Because only the first and last balloons we are sure of their adjacent balloons before hand!\\n\\nFor the first we have `nums[i-1]*nums[i]*nums[i+1]` for the last we have `nums[-1]*nums[i]*nums[n]`.\\n\\n\\nOK. Think about n balloons if i is the last one to burst, what now?\\n\\nWe can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp.\\n\\n**Final**\\n\\nHere comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won't give any coins.\\nThe algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution.\\n\\n**Java D&C with Memoization**\\n\\n    public int maxCoins(int[] iNums) {\\n        int[] nums = new int[iNums.length + 2];\\n        int n = 1;\\n        for (int x : iNums) if (x > 0) nums[n++] = x;\\n        nums[0] = nums[n++] = 1;\\n\\n\\n        int[][] memo = new int[n][n];\\n        return burst(memo, nums, 0, n - 1);\\n    }\\n\\n    public int burst(int[][] memo, int[] nums, int left, int right) {\\n        if (left + 1 == right) return 0;\\n        if (memo[left][right] > 0) return memo[left][right];\\n        int ans = 0;\\n        for (int i = left + 1; i < right; ++i)\\n            ans = Math.max(ans, nums[left] * nums[i] * nums[right] \\n            + burst(memo, nums, left, i) + burst(memo, nums, i, right));\\n        memo[left][right] = ans;\\n        return ans;\\n    }\\n    // 12 ms\\n\\n**Java DP**\\n\\n    public int maxCoins(int[] iNums) {\\n        int[] nums = new int[iNums.length + 2];\\n        int n = 1;\\n        for (int x : iNums) if (x > 0) nums[n++] = x;\\n        nums[0] = nums[n++] = 1;\\n\\n\\n        int[][] dp = new int[n][n];\\n        for (int k = 2; k < n; ++k)\\n            for (int left = 0; left < n - k; ++left) {\\n                int right = left + k;\\n                for (int i = left + 1; i < right; ++i)\\n                    dp[left][right] = Math.max(dp[left][right], \\n                    nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]);\\n            }\\n\\n        return dp[0][n - 1];\\n    }\\n    // 17 ms\\n\\n**C++ DP**\\n\\n    int maxCoinsDP(vector<int> &iNums) {\\n        int nums[iNums.size() + 2];\\n        int n = 1;\\n        for (int x : iNums) if (x > 0) nums[n++] = x;\\n        nums[0] = nums[n++] = 1;\\n\\n\\n        int dp[n][n] = {};\\n        for (int k = 2; k < n; ++k) {\\n            for (int left = 0; left < n - k; ++left)\\n                int right = left + k;\\n                for (int i = left + 1; i < right; ++i)\\n                    dp[left][right] = max(dp[left][right],\\n                         nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]);\\n            }\\n\\n        return dp[0][n - 1];\\n    }\\n    // 16 ms\\n\\n**Python DP**\\n\\n    def maxCoins(self, iNums):\\n        nums = [1] + [i for i in iNums if i > 0] + [1]\\n        n = len(nums)\\n        dp = [[0]*n for _ in xrange(n)]\\n\\n        for k in xrange(2, n):\\n            for left in xrange(0, n - k):\\n                right = left + k\\n                for i in xrange(left + 1,right):\\n                    dp[left][right] = max(dp[left][right],\\n                           nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\\n        return dp[0][n - 1]\\n\\n    # 528ms",
                "codeTag": "Python3"
            },
            {
                "id": 892552,
                "title": "for-those-who-are-not-able-to-understand-any-solution-with-diagram",
                "content": "I saw multiple solutions on the discussions forum and was not able to figure out what they were trying to explain. So, I came up with solution myself and will try to explain it in the simplest way. If you are clear with the subproblems and are just confused with the implementation, you can jump directly to the diagram below.\\n<BR>\\n\\n**Bruteforce:** Generate all permutations for the ordering of balloons and check which permutation yields the best profit. But it will take O(n!) time.\\n<br>\\n\\n**DP Solution:** For a DP solution to exist, we need to define the subproblems. Let\\'s define the problem first as:\\n\\n\\tsolve(nums, i, j)\\n\\nby which I mean that we need to burst balloons starting from index i to index j. At the beginning, they\\'ll be 0, nums.size()  -1 respectively. Let\\'s suppose we burst the kth balloon in the first chance. We will get **nums[k-1] * nums[k] * nums[k+1]** coins. Now let\\'s define the subproblems as:\\n```\\nsolve(nums, i, k - 1) , solve(nums, k + 1, j)\\n```\\nAs the balloon k is already burst, we solve the subproblems from i to k -1 and k + 1 to j. But wait, what\\'s going wrong here? The subproblem **solve(nums, i, k - 1)** and **solve(nums, k + 1, j)** are not independent since after bursting **kth balloon**, balloon k - 1 and k + 1 have become adjacent and they will need each other in order to calculate the profit.\\n\\nSo, as we saw that if we choose the kth balloon to be the first one to be burst, we can\\'t make the subproblems independent. Let\\'s try the other way round. We choose the kth balloon as the **last one to be burst**. Now the subproblems will become independent since **(k - 1)th balloon** and **(k + 1)th balloon** won\\'t need each other in order to calculate the answer.  (Try it out using pen and paper). \\n\\nNow for each **k** starting from i to j, we choose the kth balloon to be the last one to be burst and calculate the profit by solving the subproblems recursively. Whichever choice of k gives us the best answer, we store it and return. \\nImportant point to be noted here is that the balloons in the range **(i, k - 1) and (k + 1, j)** will be burst **BEFORE** kth balloon. So, when we burst the kth balloon, the profit will be ***nums[i - 1] * nums[k] * nums[j + 1]*** PROVIDED that index i - 1 and j + 1 are valid. \\n<br>\\n\\n**STILL CONFUSED?**\\n---\\nDon\\'t worry, the example given in the diagram below will make things SUPER CLEAR! 2 dummy balloons each with value 1 are inserted to handle the corner balloons in the original array. \\n***[Choices of **k** in the below diagram are random and don\\'t necessarily yield the optimal solution.]***\\n\\n![image](https://assets.leetcode.com/users/images/1bafbe44-cb85-4ade-adb5-54ee5095baea_1602579692.7557607.png)\\n\\n<br>\\n\\nCODE\\n---\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[501][501]; // For memoization\\n    int solve(vector<int> &nums, int i, int j){\\n\\t\\t// BASE CASES\\n\\t\\tif(i > j)\\n\\t\\t\\treturn 0;\\n        if(i == j){    // Only one element exists\\n            int temp = nums[i];\\n            if(i - 1 >= 0)  \\n                temp *= nums[i - 1];\\n            if(i + 1 < n)\\n                temp *= nums[i + 1];\\n            return temp;\\n        }\\n\\t\\tif(t[i][j] != -1)  // Check if the solution is already stored for this subproblem\\n\\t\\t\\treturn t[i][j];\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// For all elements in the range i to j, we choose all of them one by one \\n\\t\\t// to make them the last balloon to be burst. \\n        for(int k = i; k <= j; k++){\\n\\t\\t\\n\\t\\t    // Burst the kth balloon after bursting (i, k - 1) and (k + 1, j) balloons\\n            int temp = nums[k];\\n\\t\\t\\t\\n            if(j + 1 < n)  // As balloon j + 1 will become adjacent to k after bursting  k + 1 to j balloons\\n                temp *= nums[j + 1];\\n\\t\\t\\t\\t\\n            if(i - 1 >= 0) // As balloon i- 1 will become adjacent to k after bursting  i  to k -1 balloons\\n                temp *= nums[i - 1];\\n\\t\\t\\t\\t\\n\\t\\t\\t// Recursively solve the left and right subproblems and add their contribution\\n            temp += (solve(nums, i, k - 1) + solve(nums, k + 1, j));\\n\\t\\t\\t\\n\\t\\t\\t// If this choice of k yields a better answer\\n            ans = max(ans, temp);\\n        }\\n        return t[i][j] = ans;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        memset(t, -1, sizeof(t));\\n\\t\\t\\n        // Insert two dummy balloons of value 1 to handle the balloons on the corner.\\n\\t\\tvector<int> arr = {1};\\n        for(int x: nums) \\n\\t\\t\\tarr.push_back(x);\\n        arr.push_back(1);\\n        n = arr.size();\\n\\t\\t\\n\\t\\t//Start from i = 1 and j = arr.size() - 2 since first and last balloons are dummy.\\n        return solve(arr, 1, arr.size() - 2);\\n    }\\n};\\n```\\nPlease don\\'t go without upvoting if it helped you!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nsolve(nums, i, k - 1) , solve(nums, k + 1, j)\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[501][501]; // For memoization\\n    int solve(vector<int> &nums, int i, int j){\\n\\t\\t// BASE CASES\\n\\t\\tif(i > j)\\n\\t\\t\\treturn 0;\\n        if(i == j){    // Only one element exists\\n            int temp = nums[i];\\n            if(i - 1 >= 0)  \\n                temp *= nums[i - 1];\\n            if(i + 1 < n)\\n                temp *= nums[i + 1];\\n            return temp;\\n        }\\n\\t\\tif(t[i][j] != -1)  // Check if the solution is already stored for this subproblem\\n\\t\\t\\treturn t[i][j];\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// For all elements in the range i to j, we choose all of them one by one \\n\\t\\t// to make them the last balloon to be burst. \\n        for(int k = i; k <= j; k++){\\n\\t\\t\\n\\t\\t    // Burst the kth balloon after bursting (i, k - 1) and (k + 1, j) balloons\\n            int temp = nums[k];\\n\\t\\t\\t\\n            if(j + 1 < n)  // As balloon j + 1 will become adjacent to k after bursting  k + 1 to j balloons\\n                temp *= nums[j + 1];\\n\\t\\t\\t\\t\\n            if(i - 1 >= 0) // As balloon i- 1 will become adjacent to k after bursting  i  to k -1 balloons\\n                temp *= nums[i - 1];\\n\\t\\t\\t\\t\\n\\t\\t\\t// Recursively solve the left and right subproblems and add their contribution\\n            temp += (solve(nums, i, k - 1) + solve(nums, k + 1, j));\\n\\t\\t\\t\\n\\t\\t\\t// If this choice of k yields a better answer\\n            ans = max(ans, temp);\\n        }\\n        return t[i][j] = ans;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        memset(t, -1, sizeof(t));\\n\\t\\t\\n        // Insert two dummy balloons of value 1 to handle the balloons on the corner.\\n\\t\\tvector<int> arr = {1};\\n        for(int x: nums) \\n\\t\\t\\tarr.push_back(x);\\n        arr.push_back(1);\\n        n = arr.size();\\n\\t\\t\\n\\t\\t//Start from i = 1 and j = arr.size() - 2 since first and last balloons are dummy.\\n        return solve(arr, 1, arr.size() - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76229,
                "title": "for-anyone-that-is-still-confused-after-reading-all-kinds-of-explanations",
                "content": "I think the most upvoted post didn't talk about what dp[i][j] represent and what exactly does the transition function : \\n\\n**for (int k = left; k <= right; ++k)\\n                    dp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])****\\n means.  \\n\\nOr maybe it did talk about it but I miss it. But anyway here is my understand of this problem after reading countless of posts and comments : \\n\\nFirst of all, dp[i][j] in here means, the maximum coins we get after we burst **all** the balloons between i and j in the original array. \\n\\nFor example with input [3,1,5,8] :\\n\\ndp[0][0] means we burst ballons between [0,0], which means we only burst the first balloon in original array. So dp[0][0] is 1 * 3 * 1 = 3.\\n\\ndp[1][1] means we burst balloons between [1][1], which means we only burst the second ballon in the original array. So dp[1][1] is 3 * 1 * 5 = 15.\\n\\nSo in the end for this problem we want to find out dp[0][ arr.length - 1 ], which is the maximum value we can get when we burst all the balloon between [0 , length -1]\\n\\nTo get that we need the transition function :\\n\\n**for (int k = left; k <= right; ++k)\\n                    dp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])****\\n\\nThis transition function basically says in order to get the maximum value we can get for bursting all the balloons between  [ i , j] , we just loop through each balloon between these two indexes and make them to be the last balloon to be burst, \\n\\nwhy we pick it as the last balloon to burst ?\\n\\nFor example when calculating dp[0,3] and picking index 2 as the last balloon to burst, \\n\\n [ 3 , 1 , 5 , 8] ,  that means 5 is the last balloon to burst between [0,3] , to get the maximum value when picking 5 as the last balloon to burst :\\n\\nmax = maximum value of bursting all the balloon on the left side of 5 + maximum value of bursting all the balloon on the right side of 5 + bursting balloon 5 when left side and right side are gone. \\n\\nThat is dp[0, 1]  + nums[0 - 1] * nums[2] * nums[3 + 1] + + dp[3,3];  \\n \\nThat is dp[left, k - 1]  + nums[left - 1] * nums[k] * nums[right + 1] + dp[k+1, right] ; \\n\\nto get the maximum dp[left, right] we just loop through all the possible value of k to get the maximum.\\n\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "I think the most upvoted post didn't talk about what dp[i][j] represent and what exactly does the transition function : \\n\\n**for (int k = left; k <= right; ++k)\\n                    dp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])****\\n means.  \\n\\nOr maybe it did talk about it but I miss it. But anyway here is my understand of this problem after reading countless of posts and comments : \\n\\nFirst of all, dp[i][j] in here means, the maximum coins we get after we burst **all** the balloons between i and j in the original array. \\n\\nFor example with input [3,1,5,8] :\\n\\ndp[0][0] means we burst ballons between [0,0], which means we only burst the first balloon in original array. So dp[0][0] is 1 * 3 * 1 = 3.\\n\\ndp[1][1] means we burst balloons between [1][1], which means we only burst the second ballon in the original array. So dp[1][1] is 3 * 1 * 5 = 15.\\n\\nSo in the end for this problem we want to find out dp[0][ arr.length - 1 ], which is the maximum value we can get when we burst all the balloon between [0 , length -1]\\n\\nTo get that we need the transition function :\\n\\n**for (int k = left; k <= right; ++k)\\n                    dp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])****\\n\\nThis transition function basically says in order to get the maximum value we can get for bursting all the balloons between  [ i , j] , we just loop through each balloon between these two indexes and make them to be the last balloon to be burst, \\n\\nwhy we pick it as the last balloon to burst ?\\n\\nFor example when calculating dp[0,3] and picking index 2 as the last balloon to burst, \\n\\n [ 3 , 1 , 5 , 8] ,  that means 5 is the last balloon to burst between [0,3] , to get the maximum value when picking 5 as the last balloon to burst :\\n\\nmax = maximum value of bursting all the balloon on the left side of 5 + maximum value of bursting all the balloon on the right side of 5 + bursting balloon 5 when left side and right side are gone. \\n\\nThat is dp[0, 1]  + nums[0 - 1] * nums[2] * nums[3 + 1] + + dp[3,3];  \\n \\nThat is dp[left, k - 1]  + nums[left - 1] * nums[k] * nums[right + 1] + dp[k+1, right] ; \\n\\nto get the maximum dp[left, right] we just loop through all the possible value of k to get the maximum.\\n\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 76245,
                "title": "easiest-java-solution",
                "content": "The subproblems are overlapped. So we can use divide and conquer + cache.\\n* Balloons `0, 1, ..., n - 1`\\n* What is the max value if we burst  all of them `[0,  n - 1]`?\\n* Let's first consider bursting `[start, end]`\\n* Imagine we burst index `i` at the end\\n* `[start, ... i - 1, (i), i + 1 ... end]`\\n* Before the end, we already bursted `[start, i - 1]` and `[i + 1, end]`\\n* Before the end, boundaries `start - 1`, `i`, `end + 1` are always there\\n* This helps us calculate coins without worrying about details inside `[start, i - 1]` and `[i + 1, end]`\\n* So the range can be divided into\\n* `start - 1`, `maxCoin(start, i - 1)`, `i`, `maxCoins(i + 1, end)`, `end + 1`\\n\\nHope it helps!\\n\\n    public int maxCoins(int[] nums) {\\n        int[][] dp = new int[nums.length][nums.length];\\n        return maxCoins(nums, 0, nums.length - 1, dp);\\n    }\\n    \\n    public int maxCoins(int[] nums, int start, int end, int[][] dp) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        int max = nums[start];\\n        for (int i = start; i <= end; i++) {\\n            int val = maxCoins(nums, start, i - 1, dp) + \\n                      get(nums, i) * get(nums, start - 1) * get(nums, end + 1) + \\n                      maxCoins(nums, i + 1, end, dp);\\n                      \\n            max = Math.max(max, val);\\n        }\\n        dp[start][end] = max;\\n        return max;\\n    }\\n    \\n    public int get(int[] nums, int i) {\\n        if (i == -1 || i == nums.length) {\\n            return 1;\\n        }\\n        return nums[i];\\n    }",
                "solutionTags": [],
                "code": "The subproblems are overlapped. So we can use divide and conquer + cache.\\n* Balloons `0, 1, ..., n - 1`\\n* What is the max value if we burst  all of them `[0,  n - 1]`?\\n* Let's first consider bursting `[start, end]`\\n* Imagine we burst index `i` at the end\\n* `[start, ... i - 1, (i), i + 1 ... end]`\\n* Before the end, we already bursted `[start, i - 1]` and `[i + 1, end]`\\n* Before the end, boundaries `start - 1`, `i`, `end + 1` are always there\\n* This helps us calculate coins without worrying about details inside `[start, i - 1]` and `[i + 1, end]`\\n* So the range can be divided into\\n* `start - 1`, `maxCoin(start, i - 1)`, `i`, `maxCoins(i + 1, end)`, `end + 1`\\n\\nHope it helps!\\n\\n    public int maxCoins(int[] nums) {\\n        int[][] dp = new int[nums.length][nums.length];\\n        return maxCoins(nums, 0, nums.length - 1, dp);\\n    }\\n    \\n    public int maxCoins(int[] nums, int start, int end, int[][] dp) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        int max = nums[start];\\n        for (int i = start; i <= end; i++) {\\n            int val = maxCoins(nums, start, i - 1, dp) + \\n                      get(nums, i) * get(nums, start - 1) * get(nums, end + 1) + \\n                      maxCoins(nums, i + 1, end, dp);\\n                      \\n            max = Math.max(max, val);\\n        }\\n        dp[start][end] = max;\\n        return max;\\n    }\\n    \\n    public int get(int[] nums, int i) {\\n        if (i == -1 || i == nums.length) {\\n            return 1;\\n        }\\n        return nums[i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 970727,
                "title": "python-5-lines-dp-explained",
                "content": "This is quite difficult problem! Let us consider `dp[i][j]` the maximum number of coins we can get, popping balls from `i` to `j`, **not including** `i` and `j`. Why it is enough to keep these values? Let us look at the **last** popped balloon with number `k`. Then our balloons are separated into two groups: to the left of this balloon and the the right and we can write:\\n \\n`dp[i][j] = max(nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]) for k in (i+1,j)`, \\n\\nwhere `k` is the index of the last balloon burst in `(i, j)`. \\n\\n**Complexity**: time complexity is `O(n^3)` and space complexity is `O(n^2)`.\\n\\nYou can see that code is very short, but it is in my opinion very diffucult to find this solution. How you can think in problems like this? First of all we are given, that `n<500`, which is quite small and we can try to understand what complexity we can expect. It is for sure not `2^500`, so what is rest some polynomials and/or logarithms.  So what we can expect is either `O(n^2)` or `O(n^3)`, but no more than this. So at this moment we usually have `2` choises: either greedy or dp. It is not obvious how to do greedy for me, so the choise is dp. Now we can think that repeating subproblem is what is the answer on range `(i, j)`. However the last step is something you can not invent quickly if you do not have experience in these type of problems. I can give you only intuition here: it is good idea to look at some **extremal** characteristic here: by this word I mean some object, which is either first/last, biggest/smallest and so on. Here our characteristic is **last** popped ballon on range, not the **first** we expect in simpler dp problems. Once you understand this logic, some other problems similar to this will be slightly simpler.\\n\\n**664** Strange Printer\\n**546** Remove Boxes\\n**1000** Minimum Cost to Merge Stones\\n\\n```\\nclass Solution:\\n    def maxCoins(self, nums):\\n        A = [1] + nums + [1]\\n        \\n        @lru_cache(None)\\n        def dfs(i, j):\\n            return max([A[i]*A[k]*A[j] + dfs(i,k) + dfs(k,j) for k in range(i+1, j)] or [0])\\n        \\n        return dfs(0, len(A) - 1)\\n```\\n\\n#### Solution 2\\nAfter leetcode added new tests, previous elegant approach not working anymore, so we need to do it in classical dp table. Complexity is the same, but it get AC now. Thanks **rowe1227** for providing the code.\\n\\n```python\\nclass Solution:\\n    def maxCoins(self, A):\\n        A, n = [1] + A + [1], len(A) + 2\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n - 2, -1, -1):\\n            for j in range(i + 2, n):\\n                dp[i][j] = max(A[i]*A[k]*A[j] + dp[i][k] + dp[k][j] for k in range(i + 1, j))\\n        \\n        return dp[0][n-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums):\\n        A = [1] + nums + [1]\\n        \\n        @lru_cache(None)\\n        def dfs(i, j):\\n            return max([A[i]*A[k]*A[j] + dfs(i,k) + dfs(k,j) for k in range(i+1, j)] or [0])\\n        \\n        return dfs(0, len(A) - 1)\\n```\n```python\\nclass Solution:\\n    def maxCoins(self, A):\\n        A, n = [1] + A + [1], len(A) + 2\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n - 2, -1, -1):\\n            for j in range(i + 2, n):\\n                dp[i][j] = max(A[i]*A[k]*A[j] + dp[i][k] + dp[k][j] for k in range(i + 1, j))\\n        \\n        return dp[0][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659162,
                "title": "java-dp-divide-and-conquer-sliding-window-detailed-explanation-using-image",
                "content": "**Intution:** Suppose you have been given array [1,2,3,4] which u can see as [1,1,2,3,4,1] (padded by 1 on both side). So now if u decide to burst baloon with value 3 at last then that means all other baloons will already burst and so total value to burst the baloons will be = (1 * 3 * 1 + left + right) where left will be max cost of bursting baloons left to 3 i.e., [1,2] and right will be max cost of bursting baloons t the right of 3 i.e., [4].\\nSo here we can clearly observe that to get the answer for window of size n we need to have the answer for window of size 2(left) and 1(right) that is smaller subproblems. So here we can definitely think of DP.(Divide and Conquer DP)\\n\\n**Explanation of Approach:**\\n* Since we need smaller window answer for larger windows, so we have to store the answer for window of each size from 1 to n.\\n* Then we will have two pointers left and right to point at the two ends of our current window. For example if we have array [1,1,2,3,4,5,1] and we have to get the answer for subarray [2,3,4] then left will point at index 2and right at index 4.\\n* Now in the current window we have to burst baloons in such sequence that we get the max value. And for this we have to check for each baloon in that window whether it can give the max value if burst at last.\\n* So for this we have to traverse from left to right in the window and each time calculate the value assuming ith baloon is burst at last.\\n* So while filling Dp we will be filling values for left to right window , i.e., \\n\\tdp[left][right] = Max(already calculated value, burst this ith baloon last and add left and right subarray points within the window)\\n* dp[left][right] = max(dp[left][right], arr[left-1] * arr[i] * arr[right+1] + dp[left][i-1] + dp[i+1][right])\\n\\n![image](https://assets.leetcode.com/users/images/f4759f64-98cb-4493-9ed7-5a50251cdfc1_1641000994.937502.jpeg)\\n\\nSo now we just need to apply 3 loops:\\n1. 1st for window size from 1 to n\\n2.  then for left pointer from 1 to (n-window+1)\\n3.  Now right is already fixed i.e., (left+window-1), so now third loop from left to right.\\nEach time update the value in dp for left to right.\\n4. Time Complexity : O(N^3)\\n\\n\\n\\u274C**Approach 0: Recursion (Here we will only understand why to not do using recusrion)**\\n\\n**For that Lets first see the power of DP over recursion:**\\nif we do it by recusrion then we have to make N! calls to cover all the permutations of N sized array and then to calculate points for each permutation we need O(N). So by recursion Time Complexity will be O(N!N)\\nSo now if N=20,\\nthen N! = 2.43 * 10^18 => N!N = 4.86 * 10^19\\nand if we assume we can do 10^8 computations in 1sec then the above value of N!N gonaa take approx 3168 years to compute!! LOL!!\\n\\nAnd at the same time for DP the Time Complexity is N^3 = 8000 < 1sec\\n##### From 3168 years to less than 1sec => I think this is more than enough to understand the power of DP.\\n\\n\\n**Approach1 : Memoization**\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int[n+2];\\n        arr[0] = arr[n+1] = 1;\\n        for(int i=1;i<=n;i++){\\n            arr[i] = nums[i-1];\\n        }\\n        \\n        int memo[][] = new int[n+2][n+2];\\n        return burst(memo, arr, 0, n + 1);\\n        \\n    }\\n    public int burst(int[][] memo, int[] nums, int left, int right) {\\n        if (left + 1 == right) return 0;\\n        \\n        if (memo[left][right] > 0) return memo[left][right];\\n        \\n        int ans = 0;\\n        \\n        for (int i = left + 1; i < right; ++i){\\n            ans = Math.max(ans, nums[left] * nums[i] * nums[right] \\n            + burst(memo, nums, left, i) + burst(memo, nums, i, right));\\n        }\\n        memo[left][right] = ans;\\n        \\n        return ans;\\n    }\\n    \\n}\\n```\\n\\n**Approach2 : DP**\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int[n+2];\\n        arr[0] = arr[n+1] = 1;   // Giving padding of 1 to the corner elements\\n        for(int i=1;i<=n;i++){\\n            arr[i] = nums[i-1];   //final padded array\\n        }\\n        \\n        int dp[][] = new int[n+2][n+2];\\n        \\n        for(int window = 1;window<=n;window++){     // window size\\n\\t\\t\\n            for(int left = 1;left<=n-window+1;left++){    // left pointer\\n\\t\\t\\t\\n                int right = left+window-1;               // right pointer\\n\\t\\t\\t\\t\\n                for(int i=left;i<=right;i++){           // iterate from left to right\\n\\t\\t\\t\\t\\n                    dp[left][right] = Math.max(dp[left][right], (arr[left-1]*arr[i]*arr[right+1]) + dp[left][i-1] + dp[i+1][right]);\\n                                    \\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```\\n\\n**I hope it helps u....and wishing everyone an awsome and joyful New Year!!**",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int[n+2];\\n        arr[0] = arr[n+1] = 1;\\n        for(int i=1;i<=n;i++){\\n            arr[i] = nums[i-1];\\n        }\\n        \\n        int memo[][] = new int[n+2][n+2];\\n        return burst(memo, arr, 0, n + 1);\\n        \\n    }\\n    public int burst(int[][] memo, int[] nums, int left, int right) {\\n        if (left + 1 == right) return 0;\\n        \\n        if (memo[left][right] > 0) return memo[left][right];\\n        \\n        int ans = 0;\\n        \\n        for (int i = left + 1; i < right; ++i){\\n            ans = Math.max(ans, nums[left] * nums[i] * nums[right] \\n            + burst(memo, nums, left, i) + burst(memo, nums, i, right));\\n        }\\n        memo[left][right] = ans;\\n        \\n        return ans;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int[n+2];\\n        arr[0] = arr[n+1] = 1;   // Giving padding of 1 to the corner elements\\n        for(int i=1;i<=n;i++){\\n            arr[i] = nums[i-1];   //final padded array\\n        }\\n        \\n        int dp[][] = new int[n+2][n+2];\\n        \\n        for(int window = 1;window<=n;window++){     // window size\\n\\t\\t\\n            for(int left = 1;left<=n-window+1;left++){    // left pointer\\n\\t\\t\\t\\n                int right = left+window-1;               // right pointer\\n\\t\\t\\t\\t\\n                for(int i=left;i<=right;i++){           // iterate from left to right\\n\\t\\t\\t\\t\\n                    dp[left][right] = Math.max(dp[left][right], (arr[left-1]*arr[i]*arr[right+1]) + dp[left][i-1] + dp[i+1][right]);\\n                                    \\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659268,
                "title": "c-easy-to-understand-all-intuitions-step-by-step-with-detailed-explanations",
                "content": "\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#All the intuitions from start till the end\\n***\\n**Reframing the question :-**\\nWe are given n balloons indexed from 0 to n-1.Each balloon carry\\'s a number with it representedd by `nums` array . If we burst a balloon we need to multiply the number of that balloon with the neighbouring left and right ballons. \\n```\\nFor example :-\\nnums => [2,3,4,5]\\nsay we bursted the 2nd ballon i.e the balloon with number 3 \\nthen we need to multiply the left and right neighbours i.e  2 * 3 * 4 which gives us 24 coins .\\n```\\nIn the end we need to burst all the balloons wisely so that we can get maximum number of coins from them .\\n* **Edge case:-** The balloons which after bursting creates an out of bound condition then we need to treat out of bound index as a virtual balloon with number 1 .\\nFor example:-\\nIn the above example if we burst the balloon with number 2 the left neighbour will go out of bound thus during calculations we will treat the out of bound index as a virtual balloon with number 1 i.e  1[Vritual balloon with out of bound index] * 2 * 3 .\\n\\nSo this completes the entire question .\\n***\\n\\n**1st Intuition:-**\\n* After understanding the entire question the first intuition that we may got is backtracking .But after seeing the constraints my eye balls popped out to floor. The reason behind this is that we have `n balloons` so the number of permutaions that will be in the worst case scenerio is O(n!) .\\n*  That\\'s super high . Maybe it will work for constraints till 15 but the question maker has gifted us with a constraint like this `1 <= n <= 500` So in the end say goodbye to backtracking .\\n***\\n**2nd Intuition:-**\\n* The sacrifice of backtrack should not go to vein. So after this we all thought of dp but not sure how to implement dp. After some huge brainstorming and taking hints from others <mark>I got an observation i.e That the ballons that were already bursted can be ignored for finding the maxcoins for the ballons that we will be bursting in future</mark>\\n* This observation gives us a green signal for using DP\\'s bottom up approach . \\n***\\n**3rd Intuition:-**\\n* Now to think for time complexity, we have C(n,k) cases for k balloons and for each case it need to scan the k balloons to compare. Still it\\'s too high but It\\'s better than O(n!) but worse than O(2^n) or maybe O(3^n).   \\n***\\n**4th Intuition:-**\\n* One thing we all may have understood till now is that there seems to be many sub-similar problems from previous approaches. Somehow if we can cut down those time execution we may get an optimized approach .\\n***\\n**5th Intuition:-**\\n**i ..........k-1....k...k+1.......... j\\n[- - - - - - - - - - - - - - - - - -]**\\n\\n* Till now we are bursting a balloon let\\'s say k\\'th balloon and we are getting the coins by multiplying the (k-1)th * k\\'th * (k+1)th balloons . As the balloon k is already burst, we solve the subproblems from i to k -1 and k + 1 to j. But wait, what\\'s going wrong here? The subproblem solve(nums, i, k - 1) and solve(nums, k + 1, j) are not independent since after bursting kth balloon, balloon k - 1 and k + 1 have become adjacent and they will need each other in order to calculate the max profit of coins . \\n* So in the end we are facing a new isusue in this problem. The issue is that as the left and right become adjacent they will effect the maxCoins in the future calculation . We don\\'t want this thing to happen .\\n***\\n**6th Intuition:-**\\n* The above issue will happen in every kth balloon but but there is one exception to this i.e if We choose the kth balloon as the last one to be burst then the subproblems will become independent since (k - 1)th balloon and (k + 1)th balloon won\\'t need each other in order to calculate the answer. WHY? THINK MY FRIENDS!!!\\n***\\n**7th Intuition:-**\\n* So to answer the 6th Intuition, if we think with a pen and paper we get that becuase only the first and last balloons are the balloons where we are sure of their adjacent balloons before hand! Because\\nFor the first we have nums[k-1] * nums[k] * nums[k+1]  and for the last we have nums[-1] * nums[k] * nums[n] . \\n* OKkk. Now think about n balloons if j is the last one to burst,  We can see that the balloons are again getting separated into 2 sections. But this time since the balloon j is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other!\\n*  Thus now we can do either recursive with memoization or our favourite dp .\\n***\\n**Final Intuition**\\nLet\\'s recap a bit:\\n* **Edge case:** Pad the beginning + end of the array with a virtual 1, since the problem defines it this way, it won\\'t affect the final value, and most importantly it eliminates the need to deal with these special cases\\n* Realized that **working backwards** will allow us to **cleanly divide the array** into subproblems \\n* **Pop all the 0 balloons first** and remove them from the array (since they are worth nothing)\\n* Now **there are 3 variables** in our main equation: the values of the 3 balloons to pop. Again, we use the two 1\\'s we just padded the array with to eliminate two of those variables off the bat\\n* Now just **try all the possible middle balloons to pop** (the 3rd variable). For each balloon we choose, use it as the right and left ballon of the next level of recursion, along with the padded 1\\'s, and so forth.\\n* **Base case** is when there are no more balloons between the left and right balloon indexes (left+1 == right)\\n* **Time complexity** will be *`O(N^3)`*\\n***\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        //including the nums[-1] and nums[n]\\n        int n = nums.size() + 2;        \\n        vector<vector<int>> dp(n, vector<int>(n));\\n        vector<int> new_nums(n, 1);\\n        int i = 1;\\n        for(auto num : nums) {\\n            new_nums[i++] = num;\\n        }\\n        for(int len = 2; len <= n; len++) { \\n            //iterate from interval length from 2 to n\\n            for(int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                //select between left and right boundary (i, j)\\n                for(int k = i + 1; k < j; k++) { \\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + new_nums[i] * new_nums[k] * new_nums[j]);\\n                }\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n};\\n```\\n\\n***\\n**Feel free to comment or Upvote if you liked my post ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nFor example :-\\nnums => [2,3,4,5]\\nsay we bursted the 2nd ballon i.e the balloon with number 3 \\nthen we need to multiply the left and right neighbours i.e  2 * 3 * 4 which gives us 24 coins .\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        //including the nums[-1] and nums[n]\\n        int n = nums.size() + 2;        \\n        vector<vector<int>> dp(n, vector<int>(n));\\n        vector<int> new_nums(n, 1);\\n        int i = 1;\\n        for(auto num : nums) {\\n            new_nums[i++] = num;\\n        }\\n        for(int len = 2; len <= n; len++) { \\n            //iterate from interval length from 2 to n\\n            for(int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                //select between left and right boundary (i, j)\\n                for(int k = i + 1; k < j; k++) { \\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + new_nums[i] * new_nums[k] * new_nums[j]);\\n                }\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76232,
                "title": "c-dynamic-programming-o-n-3-32-ms-with-comments",
                "content": "    int maxCoins(vector<int>& nums) {\\n        int N = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n    \\n        // rangeValues[i][j] is the maximum # of coins that can be obtained\\n        // by popping balloons only in the range [i,j]\\n        vector<vector<int>> rangeValues(nums.size(), vector<int>(nums.size(), 0));\\n        \\n        // build up from shorter ranges to longer ranges\\n        for (int len = 1; len <= N; ++len) {\\n            for (int start = 1; start <= N - len + 1; ++start) {\\n                int end = start + len - 1;\\n                // calculate the max # of coins that can be obtained by\\n                // popping balloons only in the range [start,end].\\n                // consider all possible choices of final balloon to pop\\n                int bestCoins = 0;\\n                for (int final = start; final <= end; ++final) {\\n                    int coins = rangeValues[start][final-1] + rangeValues[final+1][end]; // coins from popping subranges\\n                    coins += nums[start-1] * nums[final] * nums[end+1]; // coins from final pop\\n                    if (coins > bestCoins) bestCoins = coins;\\n                }\\n                rangeValues[start][end] = bestCoins;\\n            }\\n        }\\n        return rangeValues[1][N];\\n    }",
                "solutionTags": [],
                "code": "    int maxCoins(vector<int>& nums) {\\n        int N = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n    \\n        // rangeValues[i][j] is the maximum # of coins that can be obtained\\n        // by popping balloons only in the range [i,j]\\n        vector<vector<int>> rangeValues(nums.size(), vector<int>(nums.size(), 0));\\n        \\n        // build up from shorter ranges to longer ranges\\n        for (int len = 1; len <= N; ++len) {\\n            for (int start = 1; start <= N - len + 1; ++start) {\\n                int end = start + len - 1;\\n                // calculate the max # of coins that can be obtained by\\n                // popping balloons only in the range [start,end].\\n                // consider all possible choices of final balloon to pop\\n                int bestCoins = 0;\\n                for (int final = start; final <= end; ++final) {\\n                    int coins = rangeValues[start][final-1] + rangeValues[final+1][end]; // coins from popping subranges\\n                    coins += nums[start-1] * nums[final] * nums[end+1]; // coins from final pop\\n                    if (coins > bestCoins) bestCoins = coins;\\n                }\\n                rangeValues[start][end] = bestCoins;\\n            }\\n        }\\n        return rangeValues[1][N];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76243,
                "title": "python-dp-n-3-solutions",
                "content": "Analysis:\\nWe need to find a way to divide the problems. If we start from the first balloon, we can't determine the left/right for the number in each sub-problem, If we start from the last balloon, we can. \\nWe can see the transformation equation is very similar to the one for matrix multiplication.\\n\\n    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]) # i < k < j\\n\\nThis is a typical interval DP problem. Because the order of the number extracted matters, we need to do a O(n^3) DP. If we only need to expand the interval to the left or right, we only need to do a O(n^2) DP. \\n\\nTop-down:\\n\\n    class Solution(object):\\n        def maxCoins(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            nums = [1] + nums + [1]\\n            n = len(nums)\\n            dp = [[0] * n for _ in xrange(n)]\\n    \\n            def calculate(i, j):\\n                if dp[i][j] or j == i + 1: # in memory or gap < 2\\n                    return dp[i][j]\\n                coins = 0\\n                for k in xrange(i+1, j): # find the last balloon\\n                    coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j))\\n                dp[i][j] = coins\\n                return coins\\n    \\n            return calculate(0, n-1)\\n\\nBottom-up:\\n   \\n\\n     class Solution(object):\\n            def maxCoins(self, nums):\\n                \"\"\"\\n                :type nums: List[int]\\n                :rtype: int\\n                \"\"\"\\n                nums = [1] + nums + [1] # build the complete array \\n                n = len(nums)\\n                dp = [[0] * n for _ in xrange(n)]\\n        \\n                for gap in xrange(2, n):\\n                    for i in xrange(n-gap):\\n                        j = i + gap\\n                        for k in xrange(i+1, j):\\n                            dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\\n                return dp[0][n-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Analysis:\\nWe need to find a way to divide the problems. If we start from the first balloon, we can't determine the left/right for the number in each sub-problem, If we start from the last balloon, we can. \\nWe can see the transformation equation is very similar to the one for matrix multiplication.\\n\\n    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]) # i < k < j\\n\\nThis is a typical interval DP problem. Because the order of the number extracted matters, we need to do a O(n^3) DP. If we only need to expand the interval to the left or right, we only need to do a O(n^2) DP. \\n\\nTop-down:\\n\\n    class Solution(object):\\n        def maxCoins(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            nums = [1] + nums + [1]\\n            n = len(nums)\\n            dp = [[0] * n for _ in xrange(n)]\\n    \\n            def calculate(i, j):\\n                if dp[i][j] or j == i + 1: # in memory or gap < 2\\n                    return dp[i][j]\\n                coins = 0\\n                for k in xrange(i+1, j): # find the last balloon\\n                    coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j))\\n                dp[i][j] = coins\\n                return coins\\n    \\n            return calculate(0, n-1)\\n\\nBottom-up:\\n   \\n\\n     class Solution(object):\\n            def maxCoins(self, nums):\\n                \"\"\"\\n                :type nums: List[int]\\n                :rtype: int\\n                \"\"\"\\n                nums = [1] + nums + [1] # build the complete array \\n                n = len(nums)\\n                dp = [[0] * n for _ in xrange(n)]\\n        \\n                for gap in xrange(2, n):\\n                    for i in xrange(n-gap):\\n                        j = i + gap\\n                        for k in xrange(i+1, j):\\n                            dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\\n                return dp[0][n-1]",
                "codeTag": "Java"
            },
            {
                "id": 76230,
                "title": "c-dp-detailed-explanation",
                "content": "the visualization help me to understand hope it can help you too.\\n\\n   1\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb71 \\n\\nadd two 1 at beginning and end of nums, each \\xb7 represent each number in nums.\\n\\n   len is the subinterval length, it grows from 1 to full length of orignal nums string.\\n\\n   the following illustrations demonstrate how the subinterval shift from left to right. (len = 7 in the illustration)\\n\\n   for each len, when shifted to rightmost, increase len and do the shift again. this way we can evaluate all possible subintervals.\\n\\n   for each subinterval, in the innermost for loop, find which balloon to burst LAST that will give us the most coins for that subinterval. <- IMPORTANT TO UNDERSTAND THIS\\n\\n   `dp[left][right]` is the maximum coins we can get from left to right. note when  left > right, it is 0\\n    \\n       1\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb71    (len = 7)\\n        |     |\\n      left  right\\n      \\n       1\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb71\\n               |     |\\n             left  right\\n              \\n       1\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb7\\xb71\\n                    |     |\\n                  left  right\\n\\n   \\n   for the example [3, 1, 5, 8], the dp matrix is updated like this\\n\\n    0    0    0    0    0    0\\n    0    3    0    0    0    0\\n    0    0    15   0    0    0\\n    0    0    0    40   0    0\\n    0    0    0    0    40   0\\n    0    0    0    0    0    0\\n\\nthen\\n\\n    0    0    0    0    0    0\\n    0    3    30   0    0    0\\n    0    0    15   135  0    0\\n    0    0    0    40   48   0\\n    0    0    0    0    40   0\\n    0    0    0    0    0    0\\n\\nat last\\n   \\n    0    0    0    0    0    0\\n    0    3    30   159  167  0\\n    0    0    15   135  159  0\\n    0    0    0    40   48   0\\n    0    0    0    0    40   0\\n    0    0    0    0    0    0\\nthe code is like most others.\\n\\n    class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int n = nums.size();\\n            nums.insert(nums.begin(), 1);\\n            nums.push_back(1);\\n            vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), 0));\\n            for (int len = 1; len <= n; ++len)\\n                for (int left = 1; left <= n - len + 1; ++left) {\\n                    int right = left + len - 1;\\n                    for (int k = left; k <= right; ++k)\\n                        dp[left][right] = max(dp[left][right], nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]);\\n                }\\n            return dp[1][n];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int n = nums.size();\\n            nums.insert(nums.begin(), 1);\\n            nums.push_back(1);\\n            vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), 0));\\n            for (int len = 1; len <= n; ++len)\\n                for (int left = 1; left <= n - len + 1; ++left) {\\n                    int right = left + len - 1;\\n                    for (int k = left; k <= right; ++k)\\n                        dp[left][right] = max(dp[left][right], nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 76227,
                "title": "java-dp-solution-with-detailed-explanation-o-n-3",
                "content": "This solution is inspired by The_Duck with his C++ solution\\n\\nhttps://leetcode.com/discuss/72186/c-dynamic-programming-o-n-3-1100-ms-with-comments\\n\\nHowever, I would give an explanation based on my own understanding. \\n\\nThe basic idea is that we can find the maximal coins of a subrange by trying every possible final burst within that range. Final burst means that we should burst balloon i as the very last one and burst all the other balloons in whatever order. dp[i][j] means the maximal coins for range [i...j]. In this case, our final answer is dp[0][nums.length - 1]. \\n\\nWhen finding the maximal coins within a range [start...end], since balloon i is the last one to burst, we know that in previous steps we have already got maximal coins of range[start .. i - 1] and range[i + 1 .. start], and the last step is to burst ballon i and get the product of balloon to the left of i, balloon i, and ballon to the right of i. In this case, balloon to the left/right of i is balloon start - 1 and balloon end + 1. Why? Why not choosing other balloon in range [0...start - 1] and [end + 1...length] because the maximal coins may need other balloon as final burst?\\n\\nIn my opinion, it's because this subrange will only be used by a larger range when it's trying for every possible final burst. It will be like [larger start.....start - 1, [start .. end] end + 1/ larger end], when final burst is at index start - 1, the result of this sub range will be used, and at this moment, start - 1 will be there because it's the final burst and end + 1 will also be there because is out of range. Then we can guarantee start - 1 and end + 1 will be there as adjacent balloons of balloon i for coins. That's the answer for the question in previous paragraph.\\n\\n\\n    public class Solution {\\n    public int maxCoins(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        int[][] dp = new int[nums.length][nums.length];\\n        for (int len = 1; len <= nums.length; len++) {\\n            for (int start = 0; start <= nums.length - len; start++) {\\n                int end = start + len - 1;\\n                for (int i = start; i <= end; i++) {\\n                    int coins = nums[i] * getValue(nums, start - 1) * getValue(nums, end + 1);\\n                    coins += i != start ? dp[start][i - 1] : 0; // If not first one, we can add subrange on its left.\\n                    coins += i != end ? dp[i + 1][end] : 0; // If not last one, we can add subrange on its right\\n                    dp[start][end] = Math.max(dp[start][end], coins);\\n                }\\n            }\\n        }\\n        return dp[0][nums.length - 1];\\n    }\\n    \\n    private int getValue(int[] nums, int i) { // Deal with num[-1] and num[num.length]\\n        if (i < 0 || i >= nums.length) {\\n            return 1;\\n        }\\n        return nums[i];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        int[][] dp = new int[nums.length][nums.length];\\n        for (int len = 1; len <= nums.length; len++) {\\n            for (int start = 0; start <= nums.length - len; start++) {\\n                int end = start + len - 1;\\n                for (int i = start; i <= end; i++) {\\n                    int coins = nums[i] * getValue(nums, start - 1) * getValue(nums, end + 1);\\n                    coins += i != start ? dp[start][i - 1] : 0; // If not first one, we can add subrange on its left.\\n                    coins += i != end ? dp[i + 1][end] : 0; // If not last one, we can add subrange on its right\\n                    dp[start][end] = Math.max(dp[start][end], coins);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 194608,
                "title": "dp-solution-with-detailed-text-and-video-explanation",
                "content": "## LeetCode 312. Burst Balloons\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=o3-PUPXiVfI\\nwhich has the same content as follows.\\n### Explanation\\n```java\\nindex:      0   1   2   3\\n          +---------------+\\nnums:   1 | 3 | 1 | 5 | 8 | 1\\n          +---------------+\\n          \\n// It may be easier to figure out the recurrence relation by looking at the last step.\\n// At the last step, you only have one ballon (3, 1, 5 or 8) to burst, right?\\n// So let\\'s have something like opt(END) to denote max coins we can get at the end,\\n// we know this opt(END) must come from one of the above 4 cases (by bursting 3, 1, 5 or 8)\\n\\n// So it seems like a good idea to use opt(i, j) to represent the max coins we can get from bursting balloons[i, j],\\n// let\\'s change opt(END) to opt(i, j) accordingly\\nopt(0, 3) = max(\\n    // If 3 is the last ballon, this means balloons[1, 5, 8] have been burst already, \\n    // since we don\\'t know the max coins we got by bursting[1, 5, 8], we\\'ll\\n    // use opt(1, 3) to denote max coins we can get by bursing balloons from 1 to 3, which is [1, 5, 8]\\n    1 * 3 * 1 + opt(1, 3),\\n    // Similarily, we have\\n    1 * 1 * 1 + opt(0, 0) + opt(2, 3),\\n    1 * 5 * 1 + opt(0, 1) + opt(3, 3),\\n    1 * 8 * 1 + opt(0, 2)    \\n    )\\n\\n// You may have figured out the recurrence relation from the above equation, if not,\\n// let\\'s look at how we\\'ll calculate opt(1, 3)\\n// Similar to the above equation, \\nopt(1, 3) = max(\\n    3 * 1 * 1 + opt(2, 3),\\n    3 * 5 * 1 + opt(1, 1) + opt(3, 3),\\n    3 * 8 * 1 + opt(1, 2)\\n    )\\n\\n// Thus, we have\\n>> state: \\nopt[i][j] denotes the max coins we can get by bursting balloons[i, j]\\n\\n>> recurrence relationship:\\nfor k from i to j\\nmax(\\n    // Edge cases are not considered in the below equation!\\n    nums[i - 1] * nums[k] * nums[j + 1] + opt[i][k - 1] + opt[k + 1][j]\\n)\\n```\\n### Code\\n```java\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int N = nums.length;\\n        if(N == 0) return 0;\\n\\n        int[][] opt = new int[N][N];\\n\\n        for(int len = 0; len < N; ++len){\\n            for(int i = 0; i + len < N; ++i){\\n                int j = i + len;\\n                for(int k = i; k <= j; ++k){\\n                    // numbers on left ballon and right ballon.\\n                    int left_num = i == 0 ? 1 : nums[i - 1];\\n                    int right_num = j == N - 1 ? 1 : nums[j + 1];\\n\\n                    // left opt and right opt\\n                    int left_opt = k == i ? 0 : opt[i][k - 1];\\n                    int right_opt = k == j ? 0 : opt[k + 1][j];\\n\\n                    opt[i][j] = Math.max(\\n                        opt[i][j], \\n                        left_num * nums[k] * right_num + left_opt + right_opt);\\n                }\\n            }\\n        }\\n\\n        return opt[0][N - 1];\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\'",
                "solutionTags": [],
                "code": "```java\\nindex:      0   1   2   3\\n          +---------------+\\nnums:   1 | 3 | 1 | 5 | 8 | 1\\n          +---------------+\\n          \\n// It may be easier to figure out the recurrence relation by looking at the last step.\\n// At the last step, you only have one ballon (3, 1, 5 or 8) to burst, right?\\n// So let\\'s have something like opt(END) to denote max coins we can get at the end,\\n// we know this opt(END) must come from one of the above 4 cases (by bursting 3, 1, 5 or 8)\\n\\n// So it seems like a good idea to use opt(i, j) to represent the max coins we can get from bursting balloons[i, j],\\n// let\\'s change opt(END) to opt(i, j) accordingly\\nopt(0, 3) = max(\\n    // If 3 is the last ballon, this means balloons[1, 5, 8] have been burst already, \\n    // since we don\\'t know the max coins we got by bursting[1, 5, 8], we\\'ll\\n    // use opt(1, 3) to denote max coins we can get by bursing balloons from 1 to 3, which is [1, 5, 8]\\n    1 * 3 * 1 + opt(1, 3),\\n    // Similarily, we have\\n    1 * 1 * 1 + opt(0, 0) + opt(2, 3),\\n    1 * 5 * 1 + opt(0, 1) + opt(3, 3),\\n    1 * 8 * 1 + opt(0, 2)    \\n    )\\n\\n// You may have figured out the recurrence relation from the above equation, if not,\\n// let\\'s look at how we\\'ll calculate opt(1, 3)\\n// Similar to the above equation, \\nopt(1, 3) = max(\\n    3 * 1 * 1 + opt(2, 3),\\n    3 * 5 * 1 + opt(1, 1) + opt(3, 3),\\n    3 * 8 * 1 + opt(1, 2)\\n    )\\n\\n// Thus, we have\\n>> state: \\nopt[i][j] denotes the max coins we can get by bursting balloons[i, j]\\n\\n>> recurrence relationship:\\nfor k from i to j\\nmax(\\n    // Edge cases are not considered in the below equation!\\n    nums[i - 1] * nums[k] * nums[j + 1] + opt[i][k - 1] + opt[k + 1][j]\\n)\\n```\n```java\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int N = nums.length;\\n        if(N == 0) return 0;\\n\\n        int[][] opt = new int[N][N];\\n\\n        for(int len = 0; len < N; ++len){\\n            for(int i = 0; i + len < N; ++i){\\n                int j = i + len;\\n                for(int k = i; k <= j; ++k){\\n                    // numbers on left ballon and right ballon.\\n                    int left_num = i == 0 ? 1 : nums[i - 1];\\n                    int right_num = j == N - 1 ? 1 : nums[j + 1];\\n\\n                    // left opt and right opt\\n                    int left_opt = k == i ? 0 : opt[i][k - 1];\\n                    int right_opt = k == j ? 0 : opt[k + 1][j];\\n\\n                    opt[i][j] = Math.max(\\n                        opt[i][j], \\n                        left_num * nums[k] * right_num + left_opt + right_opt);\\n                }\\n            }\\n        }\\n\\n        return opt[0][N - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659527,
                "title": "c-python-java-2-simple-solutions-dp-and-recursion-detailed-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n* The overall idea is **divide and conquer**\\n\\t* but we cannot select forward sequentially, because after bursting a balloon, its left and right sides are connected.\\n\\t* We first select the last bursted balloon, and then find the entire sequence from back to front one by one. \\n\\t* **Once we tried a certain balloon as the last one to be bursted, before it is bursted, its left and right sides are not connected until the left side left a single one and the right side left a single one too.** \\n\\t\\t* This is the most important observation to solve this problem.\\n\\t\\t* Before you really understand it, you may not find the correct solution easily.\\n\\t* We can also modify the code to non-recursive style.\\n\\n**Python3**\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        @cache\\n        def search(nums):\\n            return 0 if len(nums) < 3 else max([search(nums[:i + 1]) + search(nums[i:]) \\n\\t\\t\\t        + nums[0] * nums[i] * nums[-1] for i in range(1, len(nums) - 1)])\\n        return search(tuple([1] + nums + [1]))\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  # add the dummy head and tail, both are left till end and DO NOT burst them.\\n        dp = [[0] * len(nums) for _ in nums]  \\n        def search(i, j):\\n            if j - i < 2: return 0\\n            if dp[i][j] > 0: return dp[i][j] \\n            for k in range(i + 1, j):\\n                dp[i][j] = max(dp[i][j], search(i, k) + search(k, j) + nums[i] * nums[k] * nums[j])\\n            return dp[i][j]\\n        return search(0, len(nums) - 1)\\n```\\n**Python Non-recursive**\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  # add the dummy head and tail, both are left till end and DO NOT burst them.\\n        dp = [[0] * len(nums) for _ in nums]\\n        for i in range(len(nums) - 3, -1, -1):\\n            for j in range(i + 2, len(nums)):\\n                dp[i][j] = max([dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j] for k in range(i + 1, j)])\\n        return dp[0][len(nums) - 1]\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        vector<vector<int> > dp(nums.size(), vector<int>(nums.size(), 0));\\n        for (int i = nums.size() - 3; i >= 0; i --) {\\n            for (int j = i + 2; j < nums.size();j ++) {\\n                for (int k = i + 1; k < j; k ++)\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);\\n            }\\n        }\\n        return dp[0][nums.size() - 1];\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int[] dummy_num = new int[nums.length + 2];\\n        dummy_num[0] = dummy_num[dummy_num.length - 1] = 1;\\n        for(int i = 1;i <= nums.length;i ++)\\n            dummy_num[i] = nums[i - 1];\\n        int[][] dp = new int[dummy_num.length][dummy_num.length];\\n        for (int i = dummy_num.length - 3; i >= 0; i --) {\\n            for (int j = i + 2; j < dummy_num.length;j ++) {\\n                for (int k = i + 1; k < j; k ++)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + dummy_num[i] * dummy_num[k] * dummy_num[j]);\\n            }\\n        }\\n        return dp[0][dummy_num.length - 1];\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        @cache\\n        def search(nums):\\n            return 0 if len(nums) < 3 else max([search(nums[:i + 1]) + search(nums[i:]) \\n\\t\\t\\t        + nums[0] * nums[i] * nums[-1] for i in range(1, len(nums) - 1)])\\n        return search(tuple([1] + nums + [1]))\\n```\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  # add the dummy head and tail, both are left till end and DO NOT burst them.\\n        dp = [[0] * len(nums) for _ in nums]  \\n        def search(i, j):\\n            if j - i < 2: return 0\\n            if dp[i][j] > 0: return dp[i][j] \\n            for k in range(i + 1, j):\\n                dp[i][j] = max(dp[i][j], search(i, k) + search(k, j) + nums[i] * nums[k] * nums[j])\\n            return dp[i][j]\\n        return search(0, len(nums) - 1)\\n```\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        nums = [1] + nums + [1]  # add the dummy head and tail, both are left till end and DO NOT burst them.\\n        dp = [[0] * len(nums) for _ in nums]\\n        for i in range(len(nums) - 3, -1, -1):\\n            for j in range(i + 2, len(nums)):\\n                dp[i][j] = max([dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j] for k in range(i + 1, j)])\\n        return dp[0][len(nums) - 1]\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        vector<vector<int> > dp(nums.size(), vector<int>(nums.size(), 0));\\n        for (int i = nums.size() - 3; i >= 0; i --) {\\n            for (int j = i + 2; j < nums.size();j ++) {\\n                for (int k = i + 1; k < j; k ++)\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);\\n            }\\n        }\\n        return dp[0][nums.size() - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int[] dummy_num = new int[nums.length + 2];\\n        dummy_num[0] = dummy_num[dummy_num.length - 1] = 1;\\n        for(int i = 1;i <= nums.length;i ++)\\n            dummy_num[i] = nums[i - 1];\\n        int[][] dp = new int[dummy_num.length][dummy_num.length];\\n        for (int i = dummy_num.length - 3; i >= 0; i --) {\\n            for (int j = i + 2; j < dummy_num.length;j ++) {\\n                for (int k = i + 1; k < j; k ++)\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + dummy_num[i] * dummy_num[k] * dummy_num[j]);\\n            }\\n        }\\n        return dp[0][dummy_num.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76272,
                "title": "my-c-recursive-solution-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            // preprocessing: remove all zeros, insert 1 into the begin and the end\\n            vector<int> cleaned = {1};\\n            for (auto &num : nums)\\n                if (num) cleaned.push_back(num);\\n            cleaned.push_back(1);\\n\\n            int n = cleaned.size()-2;\\n            // dp[start][end] means the max score we can get from bursting [start, end] balloons.\\n            vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n\\n            return maxCoins(1, n, cleaned, dp);\\n        }\\n    private:\\n        // the real workhorse\\n        int maxCoins(int start, int end, vector<int> &nums, vector<vector<int>> &dp) {\\n            // empty\\n            if (start>end) return 0;\\n\\n            // if the result is ready, return it directly.\\n            if (dp[start][end]!=-1)\\n                return dp[start][end];\\n\\n            // the boundary of recursion.\\n            if (start == end) {\\n                dp[start][end] = nums[start-1]*nums[start]*nums[start+1];\\n                return dp[start][end];\\n            }\\n\\n            /**\\n             *\\n             * max score of [start, end] can be obtained as follow:\\n             * let lastBurst point to the last balloon to be bursted,\\n             * the score is the sum of:\\n             *  1. left part to the lastBurst, i.e, [start, lastBurst-1]\\n             *  2. the score of nums[start-1], nums[lastBurst], nums[end+1],\\n             *     since all the balloons in [start, lastBurst-1] and [lastBurst+1, end] are bursted.\\n             *  3. right part from the lastBurst, i.e, [lastBurst+1, end]\\n             * Just iterate lastBurst from start to end to calculate the max score of [start, end]\\n             *\\n             */\\n            for (int lastBurst=start; lastBurst<=end; ++lastBurst) {\\n                dp[start][end] = max(dp[start][end],\\n                                    nums[start-1]*nums[lastBurst]*nums[end+1] +\\n                                        maxCoins(start, lastBurst-1, nums, dp) +\\n                                        maxCoins(lastBurst+1, end, nums, dp));\\n            }\\n            return dp[start][end];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            // preprocessing: remove all zeros, insert 1 into the begin and the end\\n            vector<int> cleaned = {1}",
                "codeTag": "Java"
            },
            {
                "id": 531519,
                "title": "matrix-chain-multiplication",
                "content": "given array nums = {3,1,5,8}\\n* Since bursting any baloon at any index ,say 1 : 3X1X5 is similar to matrix multiplication 3X1 and 1X5 \\n* therefore, we can think of this problem as **MAXIMIZING** the operations in matrix chain multiplication\\n* Expand nums array by adding 1 at begining and end as bursting first and last baloon is similar to multiplication 1Xcurrent valueXnext value or prev valueXcurrent valueX1\\nThink of it as  nums = {**1**,3,1,5,8,**1**}\\n//n is the size of nums\\n* Now algo :\\n1. expand nums : by adding 1 at start and end\\n2. set dp[i][i] = 0    //*where dp[i][j] means max profit obtained by bursting baloons from i to j*\\n3. for len = 2 to n-1 :\\n\\t\\t for i=1 to n-2 :\\n\\t\\t\\t j = i - len + 1\\n\\t\\t\\t dp[i][j] = -INFINITY\\n\\t\\t\\t for k = i to j-1 :\\n\\t\\t\\t\\t dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + nums[i-1][k][j])\\n4. return dp[1][n-1]",
                "solutionTags": [],
                "code": "given array nums = {3,1,5,8}\\n* Since bursting any baloon at any index ,say 1 : 3X1X5 is similar to matrix multiplication 3X1 and 1X5 \\n* therefore, we can think of this problem as **MAXIMIZING** the operations in matrix chain multiplication\\n* Expand nums array by adding 1 at begining and end as bursting first and last baloon is similar to multiplication 1Xcurrent valueXnext value or prev valueXcurrent valueX1\\nThink of it as  nums = {**1**,3,1,5,8,**1**}\\n//n is the size of nums\\n* Now algo :\\n1. expand nums : by adding 1 at start and end\\n2. set dp[i][i] = 0    //*where dp[i][j] means max profit obtained by bursting baloons from i to j*\\n3. for len = 2 to n-1 :\\n\\t\\t for i=1 to n-2 :\\n\\t\\t\\t j = i - len + 1\\n\\t\\t\\t dp[i][j] = -INFINITY\\n\\t\\t\\t for k = i to j-1 :\\n\\t\\t\\t\\t dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + nums[i-1][k][j])\\n4. return dp[1][n-1]",
                "codeTag": "Unknown"
            },
            {
                "id": 1659892,
                "title": "happy-new-year-my-understanding-to-solve-this-problem-similar-pattern-to-solve-other",
                "content": "# *HAPPY NEW YEAR* \\uD83C\\uDF89\\uD83C\\uDF89\\n---\\n**I can assure You that if u solve any dp subarray problem , I can make You understand this problem and You are able to write your own code**\\n\\n---\\n\\n## Some basic question trying to answer in this post\\n**question1** :   Is this problem different from other dp subarray problem or same ?\\n**question2** :   How to come up with solution if solved other dp subarrays problem ?\\n**question3** :  Is there any pattern to solve such kind of problem ?\\n\\n**Let\\'s Discuss all of these questions**\\n\\n---\\n* This is problem is almost similar to other subarray problem, where we find answer for smaller size subarray then using the answer of these smaller size problem we answer for bigger size problem.\\n\\n* But the new thing in this question is after bursting all **n-1**  balloons , for the last balloons there is no one in it\\'s neighbour.\\n* And to solve this problem we add two padded balloons at both end , so when last balloon burst then these padding balloons with acts neighbour for it. \\n\\nwe will genrate all subarray of len 1 to n  , this will we done by using gap strategy \\n```\\nwlen -  subarray window len\\n\\tfor(int wlen=1;wlen<=n;wlen++ ){\\n\\t\\t\\tfor(int left =  1;left<=n-wlen+1;left++){\\n\\t\\t\\t\\t\\tint right =  left+wlen-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n```\\nThis is how we will genrate all subarray \\n\\n* Remeber That point again to answer larger size problem we need to use smaller size problem.\\n* so if we fill dp for one size subarry,then we can answer for 2 size subarray and so on...\\n                               (and for one size subarray single balloons with be last balloon.)\\n* our dp[i][j] = maximum coins earn when bursting all balloons in that subarray\\n* as dp[i][j] representing only max coin earn in i to j size subarray\\n* **we need one equation to fill dp[i][j]** Suppose we burst kth index at last , we need answer for smaller size array which is already calculated\\n```\\nNow itertate subarray form left to right, kth index balloons will burst array \\nk=left to k =  right\\n\\n dp[left][right]  = Math.max(dp[left][right],\\n                             dp[left][k-1]+ // left subarray already calculated\\n                             dp[k+1][right]+ // right subarray  already calculated\\n                             (arr[k]*arr[left-1]*arr[right+1]) // last burst balloons\\n```\\n\\n---\\nComplete Code:\\n\\n---\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        \\n        int n =  nums.length;\\n        int arr[] =  new int[n+2]; \\n        for(int i=0;i<n;i++){\\n            arr[i+1] = nums[i];\\n        }\\n        arr[0]=1;arr[n+1] =  1;\\n        int dp[][]  = new int[n+2][n+2];\\n        //  dp[i][j]  -  storing the max coins u can earn in  this interval/subarray\\n        \\n        for(int wlen=1;wlen<=n;wlen++ ){\\n            for(int left =  1;left<=n-wlen+1;left++){\\n                int right =  left+wlen-1;\\n                \\n                // now iterate this window, and give chance to every ballon to burst at last\\n                for(int k=left;k<=right;k++){\\n                    dp[left][right]  = Math.max(dp[left][right],\\n                                               dp[left][k-1]+ // left subarray \\n                                                dp[k+1][right]+ // right subarray\\n                                                (arr[k]*arr[left-1]*arr[right+1]) // bursting k index ballon at last , and intervals side balloons will bust with last balloon \\n                                               )        ;                                    \\n                }                                                \\n            }\\n        }\\n        \\n         return dp[1][n]; // returning answer stored for orginal size problem\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\n\\n**Overall conclusion :**\\n* Add padding balloons so we have neighbour balloons for last remaining balloons.\\n* **given chance to every balloons to burst at last in subarray of len wlen**\\n* and rest things same as dp , to answer larger problem we need answer of smaller problem store them to use later \\n* More problem solved by gap strategy Longest increasing subsequnce , longes palindrom string\\n\\n\\t\\t\\t\\t\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwlen -  subarray window len\\n\\tfor(int wlen=1;wlen<=n;wlen++ ){\\n\\t\\t\\tfor(int left =  1;left<=n-wlen+1;left++){\\n\\t\\t\\t\\t\\tint right =  left+wlen-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n```\n```\\nNow itertate subarray form left to right, kth index balloons will burst array \\nk=left to k =  right\\n\\n dp[left][right]  = Math.max(dp[left][right],\\n                             dp[left][k-1]+ // left subarray already calculated\\n                             dp[k+1][right]+ // right subarray  already calculated\\n                             (arr[k]*arr[left-1]*arr[right+1]) // last burst balloons\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        \\n        int n =  nums.length;\\n        int arr[] =  new int[n+2]; \\n        for(int i=0;i<n;i++){\\n            arr[i+1] = nums[i];\\n        }\\n        arr[0]=1;arr[n+1] =  1;\\n        int dp[][]  = new int[n+2][n+2];\\n        //  dp[i][j]  -  storing the max coins u can earn in  this interval/subarray\\n        \\n        for(int wlen=1;wlen<=n;wlen++ ){\\n            for(int left =  1;left<=n-wlen+1;left++){\\n                int right =  left+wlen-1;\\n                \\n                // now iterate this window, and give chance to every ballon to burst at last\\n                for(int k=left;k<=right;k++){\\n                    dp[left][right]  = Math.max(dp[left][right],\\n                                               dp[left][k-1]+ // left subarray \\n                                                dp[k+1][right]+ // right subarray\\n                                                (arr[k]*arr[left-1]*arr[right+1]) // bursting k index ballon at last , and intervals side balloons will bust with last balloon \\n                                               )        ;                                    \\n                }                                                \\n            }\\n        }\\n        \\n         return dp[1][n]; // returning answer stored for orginal size problem\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76263,
                "title": "my-readable-python-500ms-accepted-solution-with-explanation",
                "content": "Before started, I removed all balloons with number 0, and put an additional \"1\" at the beginning and end, for that based on the definition of this problem, one can imagine there're implicitly two \"1\" balloons at the beginning and end but would never be burst. The balloon array now becomes: [1,...,x,x,x,x,x,x,...,1], where the x's are original nonzero balloons.\\n\\nI feel the trickiest part is to sort out what you really need to calculate in each DP sub-problem. In each sub-problem I have 3 pointers \"l\", \"m\" and \"r\" located as below:\\n\\n           l   m     r\\n      [...,x,x,x,x,x,x,...]\\nI focus on the region (l,r), and assign m as the last balloon to be burst in this region. I need to calculate:\\n\\n- max coins after the balloons in region (l,m) are burst\\n\\n- max coins after the balloons in region (m,r) are burst\\n\\n- nums[l]*nums[m]*nums[r]\\n\\nNote I'm using exclusive region notation, which means the lth and rth balloons are not burst in this sub-problem.\\n\\nWith each iteration I gradually increase the interval between balloons l and r. Such process is equivalent to beginning from the 1st burst balloon. As the interval to be considered increases, all the possible combination of sub-intervals within current interval would have been calculated in previous iterations.\\n\\nIn the end I just return the regional max coins excluding the first and the last balloons, which are the 2 extra balloons I appended before started (now you can see why they're needed).\\n\\n    def maxCoins(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = [1]+[n for n in nums if n!=0]+[1]\\n        regional_max_coins = [[0 for i in xrange(len(nums))] for j in xrange(len(nums))]\\n        for balloons_to_burst in xrange(1, len(nums)-1): # number of balloons in (l,r) region\\n            for l in xrange(0, len(nums)-balloons_to_burst-1): # for m and r to be assigned legally\\n                r = l+balloons_to_burst+1\\n                for m in xrange(l+1,r):\\n                    regional_max_coins[l][r] = max(regional_max_coins[l][r], regional_max_coins[l][m]+regional_max_coins[m][r]+nums[l]*nums[m]*nums[r])\\n        return regional_max_coins[0][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Before started, I removed all balloons with number 0, and put an additional \"1\" at the beginning and end, for that based on the definition of this problem, one can imagine there're implicitly two \"1\" balloons at the beginning and end but would never be burst. The balloon array now becomes: [1,...,x,x,x,x,x,x,...,1], where the x's are original nonzero balloons.\\n\\nI feel the trickiest part is to sort out what you really need to calculate in each DP sub-problem. In each sub-problem I have 3 pointers \"l\", \"m\" and \"r\" located as below:\\n\\n           l   m     r\\n      [...,x,x,x,x,x,x,...]\\nI focus on the region (l,r), and assign m as the last balloon to be burst in this region. I need to calculate:\\n\\n- max coins after the balloons in region (l,m) are burst\\n\\n- max coins after the balloons in region (m,r) are burst\\n\\n- nums[l]*nums[m]*nums[r]\\n\\nNote I'm using exclusive region notation, which means the lth and rth balloons are not burst in this sub-problem.\\n\\nWith each iteration I gradually increase the interval between balloons l and r. Such process is equivalent to beginning from the 1st burst balloon. As the interval to be considered increases, all the possible combination of sub-intervals within current interval would have been calculated in previous iterations.\\n\\nIn the end I just return the regional max coins excluding the first and the last balloons, which are the 2 extra balloons I appended before started (now you can see why they're needed).\\n\\n    def maxCoins(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = [1]+[n for n in nums if n!=0]+[1]\\n        regional_max_coins = [[0 for i in xrange(len(nums))] for j in xrange(len(nums))]\\n        for balloons_to_burst in xrange(1, len(nums)-1): # number of balloons in (l,r) region\\n            for l in xrange(0, len(nums)-balloons_to_burst-1): # for m and r to be assigned legally\\n                r = l+balloons_to_burst+1\\n                for m in xrange(l+1,r):\\n                    regional_max_coins[l][r] = max(regional_max_coins[l][r], regional_max_coins[l][m]+regional_max_coins[m][r]+nums[l]*nums[m]*nums[r])\\n        return regional_max_coins[0][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1524512,
                "title": "c-using-matrix-chain-multiplication",
                "content": "**Please Upvote if you like the Solution!**\\n\\n**C++**\\n\\n    class Solution {\\n    public:\\n    int MCM(vector<int>& nums, int left,int right, vector<vector<int>>& mem)//Matrix Chain Multiplication Problem\\n    {\\n        if(left>=right)//Invalid Condition\\n            return 0;\\n        \\n        if(mem[left][right]!=-1)\\n            return mem[left][right];\\n        \\n        int max_cost=INT_MIN;\\n        \\n        for(int k=left;k<right;k++)//Start iterating from left(1) to right(n-1)\\n        {\\n           int total_cost=MCM(nums,left,k,mem)+MCM(nums,k+1,right,mem)+nums[left-1]*nums[k]*nums[right];  //after traversing any element from left to right, \\n\\t\\t   //Assume that the traversed element is no more in nums array and find product of current element and its adjacent element\\n            \\n           max_cost=max(max_cost,total_cost);\\n           \\n            mem[left][right]=max_cost;\\n        }\\n       return mem[left][right];\\n    }\\n    int maxCoins(vector<int>& nums) \\n    {\\n        nums.insert(nums.begin(),1);//for inserting value in front of vector array by vec_name.insert(pos,val);\\n        nums.push_back(1);//Inserting 1 at the end of nums vector array\\n        \\n        int n=nums.size();\\n        vector<vector<int>> mem(n,vector<int>(n,-1));\\n        \\n        return MCM(nums,1,n-1,mem);\\n    }\\n    };\\n\\t\\n**Java**\\n\\t\\n\\tpublic class Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Extend the input array with 1s at both ends\\n        int[] newArr = new int[n + 2];\\n        newArr[0] = 1;\\n        newArr[n + 1] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            newArr[i] = nums[i - 1];\\n        }\\n        \\n        int m = newArr.length;\\n        \\n        int[][] dp = new int[m][m];\\n        \\n        // Initialize dp array with -1 to indicate that values have not been computed yet.\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        // Call the recursive function to find the maximum coins.\\n        return matrixChainMultiplication(1, m - 1, newArr, dp);\\n    }\\n    \\n    private int matrixChainMultiplication(int left, int right, int[] nums, int[][] mem) {\\n        // If left index is greater than or equal to right, there are no matrices to multiply, return 0.\\n        if (left >= right)\\n            return 0;\\n    \\n        // If this subproblem has already been solved, return the previously computed result.\\n        if (mem[left][right] != -1)\\n            return mem[left][right];\\n\\n        int max_cost = Integer.MIN_VALUE;\\n\\n        for (int k = left; k < right; k++) {\\n            // Calculate the total cost for multiplying matrices from left to right through index k.\\n            int total_cost = matrixChainMultiplication(left, k, nums, mem) + \\n                             matrixChainMultiplication(k + 1, right, nums, mem) + \\n                             nums[left - 1] * nums[k] * nums[right]; \\n\\n            // Update the maximum cost found so far.\\n            max_cost = Math.max(max_cost, total_cost);\\n        }\\n\\n        // Store the result in the memoization table for future reference.\\n        mem[left][right] = max_cost;\\n        return mem[left][right];\\n    }\\n\\t}\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public:\\n    int MCM(vector<int>& nums, int left,int right, vector<vector<int>>& mem)//Matrix Chain Multiplication Problem\\n    {\\n        if(left>=right)//Invalid Condition\\n            return 0;\\n        \\n        if(mem[left][right]!=-1)\\n            return mem[left][right];\\n        \\n        int max_cost=INT_MIN;\\n        \\n        for(int k=left;k<right;k++)//Start iterating from left(1) to right(n-1)\\n        {\\n           int total_cost=MCM(nums,left,k,mem)+MCM(nums,k+1,right,mem)+nums[left-1]*nums[k]*nums[right];  //after traversing any element from left to right, \\n\\t\\t   //Assume that the traversed element is no more in nums array and find product of current element and its adjacent element\\n            \\n           max_cost=max(max_cost,total_cost);\\n           \\n            mem[left][right]=max_cost;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 930945,
                "title": "dfs-dp-progression-with-explanation-o-n-3-o-n-2",
                "content": "In this problem, we are tasked with finding the combination of balloon poppings that yield the highest score.  Thus, we can solve this problem by looking through all combinations of balloons to pop and returning the highest scoring combination.  DFS is a great tool for this as we can imagine an instance of the function as the current state, and each recursive call as a possible action to another state.  To look through all combinations, the branching would look as follows\\n![image](https://assets.leetcode.com/users/images/8983a4d2-6bb3-41b2-a234-e807307cbd27_1604976784.859566.png)\\nFrom this, we can derive the dfs solutions with some boundary conditions\\n```\\ndef dfs(nums):\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tif len(nums) == 1:\\n\\t\\treturn nums[0]\\n\\tscore = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tcurr = nums[i]\\n\\t\\tif i - 1 >= 0:\\n\\t\\t\\tcurr *= nums[i - 1]\\n\\t\\tif i + 1 < len(nums):\\n\\t\\t\\tcurr *= nums[i + 1]\\n\\t\\tcurr += dfs(nums[:i] + nums[i + 1:])\\n\\t\\tscore = max(score, curr)\\n\\treturn score\\nreturn dfs(nums)\\n```\\nThis follows the usual DFS pattern, where we traverse from the root -> leaf, and acquire some _cost_ at each node.  In this case, the cost would be the score from bursting a certain balloon.  Therefore this problem is looking the root -> leaf path that has a maximal cost.  However, this DFS implementation is far too slow and times out.  Why is that?  Imagine we had the following paths:\\n```\\nnums=[a,b,c,d,e]\\n[a,b,c,d,e] --- a ---> [b,c,d,e] --- b ---> [c,d,e]\\n[a,b,c,d,e] --- b ---> [a,c,d,e] --- a ---> [c,d,e]\\n```\\nAfter two steps, both of these paths have popped `a` and `b` and have `[c,d,e]` balloons remaining.  Up to this point the two path\\'s scores can be different, but from `[c,d,e]` onwards, both paths will return the same answer.  Our implementation of DFS is not aware of this, and will waste time calculating the same answer for subproblem `[c,d,e]`.  Instead, we can save the solution to a subproblem so we can simply reference it later instead of recalculating it.  This is where the DP approach comes in.\\n\\nUnfortunately, the DP approach for this problem is **hard**, but also quite revealing.  Usually in dynamic programming problems, we can solve a problem `[a,b,c]` by looking at its subproblems `[a,b]` and `[b,c]`.  This is fine as at this point, we know the solution to `[a,b]` and `[b,c]` which can nicely be stored in a 2D array.  The issue we have with our balloon problem is we need to **also** consider `[a,c]` as a viable subproblem.  This is because we have the recusive relation `dfs(nums[:i] + nums[i + 1:]`, rather than something like `dfs(nums[i + 1:]` or `dfs(nums[:i]`.\\nThe solution to this problem is similar to a method used in _chain matrix multiplication_, described in pages 174-175 [here](http://algorithmics.lsi.upc.edu/docs/Dasgupta-Papadimitriou-Vazirani.pdf).  In essense, we have some some array `[a,b,c]`, and we want to find the index `k` that leads us to the maximal score path.  We iterate over the array `let k = [0, 1, 2]` and make the calculations based on popping the `kth` balloon.  Well what happens when we pop the `k = 1` `b` balloon?  This would result in `[a,c] + (a * b * c)`.  But wait!  We run into the same subproblem from earlier `[a,c]` which doesn\\'t fit into our 2D array.  How can we retain the balloons positions but still recurse down to find the solution?\\nInstead of popping the `kth` balloon and looking at the resulting balloons we have left, let\\'s instead say we will pop the `kth` balloon _last_, popping every other balloon in the array before the `kth` balloon.  For an array `[a,b,c,d]`, picking `k` at random would look like\\n![image](https://assets.leetcode.com/users/images/fca87669-adcc-461a-87d8-27d7dca1f280_1605029091.778375.png)\\nNotice that popping the `kth` balloon results in multiplying by `nums[i - 1] * nums[j + 1]` which are the balloons that would be present if you popped the `kth` balloon last.  In code, we would then have\\n```\\ndef dp(nums):\\n\\tA = [[0] * len(nums) for _ in range(len(nums))]\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tfor j in range(i, len(nums)):\\n\\t\\t\\tfor k in range(i, j + 1):\\n\\t\\t\\t\\tleft = right = 0\\n\\t\\t\\t\\tif k > i:\\n\\t\\t\\t\\t\\tleft = A[i][k - 1]\\n\\t\\t\\t\\tif k < j:\\n\\t\\t\\t\\t\\tright = A[k + 1][j]\\n\\t\\t\\t\\tmid = nums[k]\\n\\t\\t\\t\\tif i - 1 >= 0:\\n\\t\\t\\t\\t\\tmid *= nums[i - 1]\\n\\t\\t\\t\\tif j + 1 < len(nums):\\n\\t\\t\\t\\t\\tmid *= nums[j + 1]\\n\\t\\t\\t\\tA[i][j] = max(A[i][j], left + mid + right)\\n\\treturn A[0][-1]\\nreturn dp(nums)\\n```\\nThis problem is definitely hard and unusual, but the principles of DP are the same.  We want to find some way to utilize subproblems to solve larger problems, where we can conveniently save the subproblems in an array.  Of course, this problem could also be solved efficiently if we simply introduced memoization with DFS.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(nums):\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tif len(nums) == 1:\\n\\t\\treturn nums[0]\\n\\tscore = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tcurr = nums[i]\\n\\t\\tif i - 1 >= 0:\\n\\t\\t\\tcurr *= nums[i - 1]\\n\\t\\tif i + 1 < len(nums):\\n\\t\\t\\tcurr *= nums[i + 1]\\n\\t\\tcurr += dfs(nums[:i] + nums[i + 1:])\\n\\t\\tscore = max(score, curr)\\n\\treturn score\\nreturn dfs(nums)\\n```\n```\\nnums=[a,b,c,d,e]\\n[a,b,c,d,e] --- a ---> [b,c,d,e] --- b ---> [c,d,e]\\n[a,b,c,d,e] --- b ---> [a,c,d,e] --- a ---> [c,d,e]\\n```\n```\\ndef dp(nums):\\n\\tA = [[0] * len(nums) for _ in range(len(nums))]\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tfor j in range(i, len(nums)):\\n\\t\\t\\tfor k in range(i, j + 1):\\n\\t\\t\\t\\tleft = right = 0\\n\\t\\t\\t\\tif k > i:\\n\\t\\t\\t\\t\\tleft = A[i][k - 1]\\n\\t\\t\\t\\tif k < j:\\n\\t\\t\\t\\t\\tright = A[k + 1][j]\\n\\t\\t\\t\\tmid = nums[k]\\n\\t\\t\\t\\tif i - 1 >= 0:\\n\\t\\t\\t\\t\\tmid *= nums[i - 1]\\n\\t\\t\\t\\tif j + 1 < len(nums):\\n\\t\\t\\t\\t\\tmid *= nums[j + 1]\\n\\t\\t\\t\\tA[i][j] = max(A[i][j], left + mid + right)\\n\\treturn A[0][-1]\\nreturn dp(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 733279,
                "title": "dp-intuitive-explannations-complete-demo-never-confused-with-dp-again",
                "content": "Strategy Descriptions:\\n\\t\\n\\ti,j  represent the left and right closed interval of str.\\n\\tdp[i][j]: the max coins of [i,j] using specific delete order.\\n\\tk: the idx of the last one we delete \\n\\t\\n\\tRecurrence Formula: \\tdp[i][j] = dp[i][k-1] + dp[k][k] + dp[k+1][j]\\n\\t\\t\\t\\t\\t\\t\\t\\tif(k=i)\\tdp[i][j] = 0 + nums[i-1]/0*nums[k]*nums[j+1]/0 + dp[k+1][j];\\n\\t\\t\\t\\t\\t\\t\\t\\tif(k=j)\\tdp[i][j] = dp[i][k-1] + nums[i-1]/0*nums[k]*nums[j+1]/0 + 0;\\n\\n\\ti: from len-1 to 0, \\t(direction of i never mind) \\n\\tj: from i to len-1,\\t(direction of j should start from i)\\n\\tk: from i to j.\\t(direction of k never mind)\\n\\n\\twe fill the dp[][] table like:\\n       j,\\u2192,\\u2192,\\u2192,len-1\\n    0 [x,\\u2192,\\u2192,\\u2192,len-1]\\n\\t\\u2191 [\\\\,x,\\u2192,\\u2192,len-1]\\n    \\u2191 [\\\\,\\\\,x,\\u2192,len-1]\\n    \\u2191 [\\\\,\\\\,\\\\,x,len-1]\\n    i [\\\\,\\\\,\\\\,\\\\,x]\\t\\t\\tdirection of k never mind)\\n\\n     or\\n\\n\\t i      [x,\\\\,\\\\,\\\\,\\\\]\\n\\t \\u2193 \\t    [0,x,\\\\,\\\\,\\\\]\\n\\t \\u2193 \\t    [0,\\u2190,x,\\\\,\\\\]\\n\\t \\u2193 \\t    [0,\\u2190,\\u2190,x,\\\\]\\n     len-1 \\t[0,\\u2190,\\u2190,\\u2190,x]\\n\\t 0,\\u2190,\\u2190,\\u2190,j\\t\\t        direction of k never mind\\n\\n\\tusing [3,1,5,8] as an example, direction of i from len-1 to 0.\\n\\ti=3,j=3,k=3: \\t\\tget dp[3][3],\\n\\ti=2,j=2,k=2: \\t\\tget dp[2][2],\\n    j=3,k=2/3:\\t\\t    get dp[2][3] relied on dp[3][3] and dp[2][2]\\n\\ti=1,j=1,k=1: \\t\\tget dp[1][1]\\n    j=2,k=1/2:\\t\\t    get dp[1][2] relied on dp[2][2] and dp[1][1]\\n    j=3,k=1/2/3:\\t    get dp[1][3] relied on dp[2][3] and dp[1][1],dp[3][3] and dp[1][2]\\n\\t\\u2026\\n\\t\\n\\tMaximum Order: using [3,1,5,8] as example.    \\n\\t\\tdp[0][3]\\t= 1*8*1 + dp[0][2]\\tselect 8 as the last one\\t/ forth\\n\\t\\t\\t\\t\\t= 1*8*1 + 1*3*8 + dp[1][2]\\t\\tselect 3 as the last two\\t/ third\\n\\t\\t\\t\\t\\t= 1*8*1 + 1*3*8 + 3*5*8 + dp[1][1]\\tselect 5 as the last three \\t/ secon\\n\\t\\t\\t\\t\\t= 1*8*1 + 1*3*8 + 3*5*8 + 3*1*5\\tselect 1 as the last four \\t/ first\\n\\t\\n\\tRecurrence Formula: \\t\\tdp[i][j] = dp[i][k-1] + dp[k][k] + dp[k+1][j]\\n\\t\\t\\tif(k=i)\\tdp[i][j] = 0 + nums[i-1]/0*nums[k]*nums[j+1]/0 + dp[k+1][j];\\n\\t\\t\\tif(k=j)\\tdp[i][j] = dp[i][k-1] + nums[i-1]/0*nums[k]*nums[j+1]/0 + 0;\\n\\n\\n\\nCode:\\n\\t\\t\\t\\t\\t\\n```\\npublic int maxCoins(int[] nums) {\\n\\t// Corner Case\\n\\tif(nums == null || nums.length == 0) return 0;\\n\\t\\n\\tint len = nums.length;\\n\\tint[][] dp = new int[len][len];\\n\\t\\n\\n\\tfor(int i = nums.length - 1; i >= 0; i--) {\\t// i represent the left closed idx of str\\n\\t\\tfor(int j = i; j <= nums.length - 1; j++) { // j represent the right closed idx \\n\\t\\t\\tfor(int k = i; k <= j; k++) {\\n\\t\\t\\t\\tint val = 0;\\n\\t\\t\\t\\tval += (k == i) ? 0 : dp[i][k-1];\\n\\t\\t\\t\\tval += (k == j) ? 0 : dp[k+1][j];\\n\\t\\n\\t\\t\\t\\t// Here is nums[i-1/j+1] instead of nums[k-1/k+1]\\n\\t\\t\\t\\t// Since ?*nums[k]*? executed at last.\\n\\t\\t\\t\\tval += ((i==0) ? 1 : nums[i-1]) * nums[k] * ((j==len-1) ? 1 : nums[j+1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j], val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][len-1];\\n}\\n```\\n\\n\\nDemo:\\n```\\nusing [3,1,5,8] as an example, direction of i from len-1 to 0.\\n\\ni=3>=0;\\tj=3<=3; max=0; dp[3][3] = max = 40. // [8]\\n\\t\\t\\t\\tk=3<=3, val=0, val = 5*8*1 = 40.\\n\\t\\t\\t\\tk=4>3. \\ni=2>=0;\\tj=2<=3; max=0; dp[2][2] = max = 40. // [5]\\n\\t\\t\\t\\tk=2<=2, val=0, val = 1*5*8 = 40, update max.\\n\\t\\t\\t\\tk=3>2. \\n        j=3<=3; max=0; dp[2][3] = max = 48. // [5,8]\\n\\t\\t\\t\\t// delete [3,3] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=3, val=0, val = 0 + dp[3][3] + 1*5*1 = 40 + 5 = 45, update max.\\n\\t\\t\\t\\t// delete [2,2] first then delete [3,3]\\n\\t\\t\\t\\tk=3<=3, val=0, val = dp[2][2] + 0 + 1*8*1 = 40 + 8 = 48, update max.\\n\\t\\t\\t\\tk=4>3.\\n\\t    j=4>3.\\ni=1>=0;\\tj=1<=3; max=0; dp[1][1] = max = 15. // [1]\\n\\t\\t\\t\\tk=1<=1, val=0, val = 3*1*5 = 15, update max.\\n\\t\\t\\t\\tk=2>1. \\n        j=2<=3; max=0; dp[1][2] = max = 135. // [1,5]\\n\\t\\t\\t\\t// delete [2,2] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=2, val=0, val = 0 + dp[2][2] + 3*1*8 = 40 + 24 = 64, update max.\\n\\t\\t\\t\\t// delete [1,1] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=2, val=0, val = dp[1][1] + 0 + 3*5*8 = 15 + 120 = 135, update max.\\n\\t\\t\\t\\tk=3>2.\\n        j=3<=3; max=0; dp[1][3] = max = 159. // [1,5,8]\\n\\t\\t\\t\\t// delete max of [2,3] fist then delete [1,1]\\n\\t\\t\\t\\tk=1<=3, val=0, val = 0 + dp[2][3] + 3*1*1 = 48 + 3 = 51, update max.\\n\\t\\t\\t\\t// delete [1,1] and [3,3] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=3, val=0, val = dp[1][1] + dp[3][3] + 3*5*1 = 15 + 40 + 15 = 70, update max.\\n\\t\\t\\t\\t// delete max of [1,2] first then delete [3,3]\\n\\t\\t\\t\\tk=3<=3, val=0, val = dp[1][2] + 0 + 3*8*1 = 135 + 24 = 159, update max.\\n\\t\\t\\t\\tk=4>3. \\n        j=4>3.\\ni=0>=0;\\tj=0<=3; max=0; dp[0][0] = max = 3. // [3]\\n\\t\\t\\t\\tk=0<=0, val=0, val = 0 + 0 + 1*3*1 = 3, update max.\\n\\t\\t\\t\\tk=1>0. \\n        j=1<=3; max=0; dp[0][1] = max = 30. // [3,1]\\n\\t\\t\\t\\t// delete [1,1] first then delete [0,0]\\n\\t\\t\\t\\tk=0<=1, val=0, val = 0 + dp[1][1] + 1*3*5 = 15 + 15 = 30, update max.\\n\\t\\t\\t\\t// delete [0,0] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=1, val=0, val = dp[0][0] + 0 + 1*1*5 = 3 + 5 = 8, update max.\\n\\t\\t\\t\\tk=2>1.\\n        j=2<=3; max=0; dp[0][2] = max = 159. // [3,1,5]\\n\\t\\t\\t\\t// delete max of [1,2] first then delete [0,0]\\n\\t\\t\\t\\tk=0<=2, val=0, val = 0 + dp[1][2] + 1*3*8 = 135 + 24 = 159, update max.\\n\\t\\t\\t\\t// delete [0,0] and [2,2] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=2, val=0, val = dp[0][0] + dp[2][2] + 1*1*8 = 30 + 40 + 8 = 78, update max.\\n\\t\\t\\t\\t// delete max of [0,1] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=2, val=0, val = dp[0][1] + 0 + 1*5*8 = 30 + 40 = 70, update max.\\n\\t\\t\\t\\tk=3>2.\\n        j=3<=3; max=0; dp[0][3] = max = 167. // [3,1,5,8]\\n\\t\\t\\t\\t// delete max of [1,3] first then delete [0,0]\\n\\t\\t\\t\\tk=0<=3, val=0, val = 0 + dp[1][3] + 1*3*1 = 159 + 3 = 162, update max.\\n\\t\\t\\t\\t// delete [0,0] and max of [2,3] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=3, val=0, val = dp[0][0] + dp[2][3] + 1*1*1 = 3 + 48 + 1 = 52, update max.\\n\\t\\t\\t\\t// delete max of [0,1] and [3,3] then delete [2,2]\\n\\t\\t\\t\\tk=2<=3, val=0, val = dp[0][1] + dp[3][3] + 1*5*1 = 30 +_40 + 5 = 75, update max.\\n\\t\\t\\t\\t// delete max of [0,2] then delete [3,3]\\n\\t\\t\\t\\tk=3<=3, val=0, val = dp[0][2] + 0 + 1*8*1 =159 + 8 = 167, update max.\\n\\t\\t\\t\\tk=4>3.\\n        j=4>3.\\ni=-1<0.\\nreturn dp[0][3] = 167.\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxCoins(int[] nums) {\\n\\t// Corner Case\\n\\tif(nums == null || nums.length == 0) return 0;\\n\\t\\n\\tint len = nums.length;\\n\\tint[][] dp = new int[len][len];\\n\\t\\n\\n\\tfor(int i = nums.length - 1; i >= 0; i--) {\\t// i represent the left closed idx of str\\n\\t\\tfor(int j = i; j <= nums.length - 1; j++) { // j represent the right closed idx \\n\\t\\t\\tfor(int k = i; k <= j; k++) {\\n\\t\\t\\t\\tint val = 0;\\n\\t\\t\\t\\tval += (k == i) ? 0 : dp[i][k-1];\\n\\t\\t\\t\\tval += (k == j) ? 0 : dp[k+1][j];\\n\\t\\n\\t\\t\\t\\t// Here is nums[i-1/j+1] instead of nums[k-1/k+1]\\n\\t\\t\\t\\t// Since ?*nums[k]*? executed at last.\\n\\t\\t\\t\\tval += ((i==0) ? 1 : nums[i-1]) * nums[k] * ((j==len-1) ? 1 : nums[j+1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j], val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][len-1];\\n}\\n```\n```\\nusing [3,1,5,8] as an example, direction of i from len-1 to 0.\\n\\ni=3>=0;\\tj=3<=3; max=0; dp[3][3] = max = 40. // [8]\\n\\t\\t\\t\\tk=3<=3, val=0, val = 5*8*1 = 40.\\n\\t\\t\\t\\tk=4>3. \\ni=2>=0;\\tj=2<=3; max=0; dp[2][2] = max = 40. // [5]\\n\\t\\t\\t\\tk=2<=2, val=0, val = 1*5*8 = 40, update max.\\n\\t\\t\\t\\tk=3>2. \\n        j=3<=3; max=0; dp[2][3] = max = 48. // [5,8]\\n\\t\\t\\t\\t// delete [3,3] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=3, val=0, val = 0 + dp[3][3] + 1*5*1 = 40 + 5 = 45, update max.\\n\\t\\t\\t\\t// delete [2,2] first then delete [3,3]\\n\\t\\t\\t\\tk=3<=3, val=0, val = dp[2][2] + 0 + 1*8*1 = 40 + 8 = 48, update max.\\n\\t\\t\\t\\tk=4>3.\\n\\t    j=4>3.\\ni=1>=0;\\tj=1<=3; max=0; dp[1][1] = max = 15. // [1]\\n\\t\\t\\t\\tk=1<=1, val=0, val = 3*1*5 = 15, update max.\\n\\t\\t\\t\\tk=2>1. \\n        j=2<=3; max=0; dp[1][2] = max = 135. // [1,5]\\n\\t\\t\\t\\t// delete [2,2] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=2, val=0, val = 0 + dp[2][2] + 3*1*8 = 40 + 24 = 64, update max.\\n\\t\\t\\t\\t// delete [1,1] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=2, val=0, val = dp[1][1] + 0 + 3*5*8 = 15 + 120 = 135, update max.\\n\\t\\t\\t\\tk=3>2.\\n        j=3<=3; max=0; dp[1][3] = max = 159. // [1,5,8]\\n\\t\\t\\t\\t// delete max of [2,3] fist then delete [1,1]\\n\\t\\t\\t\\tk=1<=3, val=0, val = 0 + dp[2][3] + 3*1*1 = 48 + 3 = 51, update max.\\n\\t\\t\\t\\t// delete [1,1] and [3,3] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=3, val=0, val = dp[1][1] + dp[3][3] + 3*5*1 = 15 + 40 + 15 = 70, update max.\\n\\t\\t\\t\\t// delete max of [1,2] first then delete [3,3]\\n\\t\\t\\t\\tk=3<=3, val=0, val = dp[1][2] + 0 + 3*8*1 = 135 + 24 = 159, update max.\\n\\t\\t\\t\\tk=4>3. \\n        j=4>3.\\ni=0>=0;\\tj=0<=3; max=0; dp[0][0] = max = 3. // [3]\\n\\t\\t\\t\\tk=0<=0, val=0, val = 0 + 0 + 1*3*1 = 3, update max.\\n\\t\\t\\t\\tk=1>0. \\n        j=1<=3; max=0; dp[0][1] = max = 30. // [3,1]\\n\\t\\t\\t\\t// delete [1,1] first then delete [0,0]\\n\\t\\t\\t\\tk=0<=1, val=0, val = 0 + dp[1][1] + 1*3*5 = 15 + 15 = 30, update max.\\n\\t\\t\\t\\t// delete [0,0] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=1, val=0, val = dp[0][0] + 0 + 1*1*5 = 3 + 5 = 8, update max.\\n\\t\\t\\t\\tk=2>1.\\n        j=2<=3; max=0; dp[0][2] = max = 159. // [3,1,5]\\n\\t\\t\\t\\t// delete max of [1,2] first then delete [0,0]\\n\\t\\t\\t\\tk=0<=2, val=0, val = 0 + dp[1][2] + 1*3*8 = 135 + 24 = 159, update max.\\n\\t\\t\\t\\t// delete [0,0] and [2,2] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=2, val=0, val = dp[0][0] + dp[2][2] + 1*1*8 = 30 + 40 + 8 = 78, update max.\\n\\t\\t\\t\\t// delete max of [0,1] first then delete [2,2]\\n\\t\\t\\t\\tk=2<=2, val=0, val = dp[0][1] + 0 + 1*5*8 = 30 + 40 = 70, update max.\\n\\t\\t\\t\\tk=3>2.\\n        j=3<=3; max=0; dp[0][3] = max = 167. // [3,1,5,8]\\n\\t\\t\\t\\t// delete max of [1,3] first then delete [0,0]\\n\\t\\t\\t\\tk=0<=3, val=0, val = 0 + dp[1][3] + 1*3*1 = 159 + 3 = 162, update max.\\n\\t\\t\\t\\t// delete [0,0] and max of [2,3] first then delete [1,1]\\n\\t\\t\\t\\tk=1<=3, val=0, val = dp[0][0] + dp[2][3] + 1*1*1 = 3 + 48 + 1 = 52, update max.\\n\\t\\t\\t\\t// delete max of [0,1] and [3,3] then delete [2,2]\\n\\t\\t\\t\\tk=2<=3, val=0, val = dp[0][1] + dp[3][3] + 1*5*1 = 30 +_40 + 5 = 75, update max.\\n\\t\\t\\t\\t// delete max of [0,2] then delete [3,3]\\n\\t\\t\\t\\tk=3<=3, val=0, val = dp[0][2] + 0 + 1*8*1 =159 + 8 = 167, update max.\\n\\t\\t\\t\\tk=4>3.\\n        j=4>3.\\ni=-1<0.\\nreturn dp[0][3] = 167.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261095,
                "title": "after-3-days-of-thinking-got-the-solution-with-full-intiution-dp-memoization",
                "content": "**so I\\'ve been solving this problem from past 3 days and finally get to know the correct intution so this is a partition problem as you can see you have to calculate the cost for each and every balloon burst right? so the intution is quite different from other questions you have to assume that the balloon you gonna burst is the last one therefore it\\'s left part and right part already got burst since there is no one to combine with that last balloon you would get the cost to burst that balloon is  1 x balloon x 1 and the total cost is { left part cost + 1 x balloon x 1 + right part cost } and you have to do this thing for all the partitions I guess it\\'s enough intution let back to the code right? with comments ofc**\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;    // this is the new vector with new modification as [ 1 , oldArray , 1 ] because the question already said this if your i-1 or i +1 goes out of bound you have 1 to multiply with \\n    int dp[505][505];\\n    //matrix-chain-multiplication\\n    int go( int si, int ei){\\n        if(dp[si][ei]!=-1)return dp[si][ei];\\n       if(si>ei)return 0;\\n       if(si==ei)return v[si-1]*v[si]*v[si+1];    //if you only have 1 element in your array\\n        int ans = INT_MIN;\\n       for(int k = si ; k<=ei ; k++){ \\n\\t\\t   //let suppose the last balloon is at kth position to \\n\\t\\t   //burst how will you burst this balloon? ofc with v[si-1] * v[ k ] * v[ ei +1 ] \\n\\t\\t   //now please dry run this step in your notebook \\n\\t\\t   //as v[ si -1 ] = v[ ei + 1 ] = 1 so basically it\\'s 1 * v[k] * 1\\n\\t\\t   int cur = v[si-1]*v[k]*v[ei+1]; \\n           int pre = go(si,k-1);     // the cost from it\\'s left part\\n           int post = go(k+1,ei); // the cost from it\\'s right part \\n           int total = cur+pre+post;  //total cost is the sum of all the combinations \\n           ans = max(ans,total);  // store the maximum one \\n       }\\n        return dp[si][ei] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        v.clear();\\n        v.push_back(1);                 // creating a new vector v so that it will contain 1 at both the ends of array \\n        for(auto val : nums)\\n            v.push_back(val);\\n        v.push_back(1);\\n        return go(1,nums.size());\\n    }\\n};\\n```\\n\\n**hope y\\'all like this please don\\'t downvote it even if you didn\\'t understand because  it took 15 minutes to write this Updated the comment Section**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;    // this is the new vector with new modification as [ 1 , oldArray , 1 ] because the question already said this if your i-1 or i +1 goes out of bound you have 1 to multiply with \\n    int dp[505][505];\\n    //matrix-chain-multiplication\\n    int go( int si, int ei){\\n        if(dp[si][ei]!=-1)return dp[si][ei];\\n       if(si>ei)return 0;\\n       if(si==ei)return v[si-1]*v[si]*v[si+1];    //if you only have 1 element in your array\\n        int ans = INT_MIN;\\n       for(int k = si ; k<=ei ; k++){ \\n\\t\\t   //let suppose the last balloon is at kth position to \\n\\t\\t   //burst how will you burst this balloon? ofc with v[si-1] * v[ k ] * v[ ei +1 ] \\n\\t\\t   //now please dry run this step in your notebook \\n\\t\\t   //as v[ si -1 ] = v[ ei + 1 ] = 1 so basically it\\'s 1 * v[k] * 1\\n\\t\\t   int cur = v[si-1]*v[k]*v[ei+1]; \\n           int pre = go(si,k-1);     // the cost from it\\'s left part\\n           int post = go(k+1,ei); // the cost from it\\'s right part \\n           int total = cur+pre+post;  //total cost is the sum of all the combinations \\n           ans = max(ans,total);  // store the maximum one \\n       }\\n        return dp[si][ei] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        v.clear();\\n        v.push_back(1);                 // creating a new vector v so that it will contain 1 at both the ends of array \\n        for(auto val : nums)\\n            v.push_back(val);\\n        v.push_back(1);\\n        return go(1,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325192,
                "title": "simple-python-dp-solutions",
                "content": "Key point: reverse thinking. \\nThink about n balloons if k is the last one to burst, last_burn = nums[-1] * nums[k] * nums[n]. \\nWe can see that the balloons is again separated into 2 sections. The left and right section \\nnow has well defined boundary and do not affect each other! Therefore we can use dynamic algorithm.\\n\\nTime complexity: O(n^3) because of O(n^2) subproblem, O(n) for each subproblem\\nSpace complexity: O(n^2)\\n\\nTop-down approach:\\n```\\n    def maxCoins(self, nums):\\n        def recursive(i, j):\\n            if i >= j - 1:\\n                return 0\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n            tmp = 0\\n            for k in range(i + 1, j):\\n                last_burn = nums[i] * nums[k] * nums[j]\\n                tmp = max(tmp, recursive(i, k) + recursive(k, j) + last_burn)\\n            dp[(i, j)] = tmp\\n            return dp[(i, j)]\\n        \\n        nums = [1] + [x for x in nums if x > 0] + [1]\\n        dp = {}\\n        return recursive(0, len(nums) - 1)\\n```\\n\\nBottom-up approach:\\n```\\n    def maxCoins(self, nums):\\n        nums = [1] + [x for x in nums if x > 0] + [1]\\n        n = len(nums)\\n        dp = [[0] * n for _ in range(n)]\\n        for d in range(2, n):\\n            for i in range(0, n - d):\\n                j = i + d\\n                for k in range(i + 1, j):\\n                    last_burn = nums[i] * nums[k] * nums[j]\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + last_burn)\\n        return dp[0][n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxCoins(self, nums):\\n        def recursive(i, j):\\n            if i >= j - 1:\\n                return 0\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n            tmp = 0\\n            for k in range(i + 1, j):\\n                last_burn = nums[i] * nums[k] * nums[j]\\n                tmp = max(tmp, recursive(i, k) + recursive(k, j) + last_burn)\\n            dp[(i, j)] = tmp\\n            return dp[(i, j)]\\n        \\n        nums = [1] + [x for x in nums if x > 0] + [1]\\n        dp = {}\\n        return recursive(0, len(nums) - 1)\\n```\n```\\n    def maxCoins(self, nums):\\n        nums = [1] + [x for x in nums if x > 0] + [1]\\n        n = len(nums)\\n        dp = [[0] * n for _ in range(n)]\\n        for d in range(2, n):\\n            for i in range(0, n - d):\\n                j = i + d\\n                for k in range(i + 1, j):\\n                    last_burn = nums[i] * nums[k] * nums[j]\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + last_burn)\\n        return dp[0][n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1659427,
                "title": "python-beginner-brute-force-recursion-brute-better-memoization-dp",
                "content": "* dp[left][right] =  coins obtained from bursting all the balloons between left and right (not including left or right)\\n* dp[left][right] = max(nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]) for i in (left+1,right)\\n\\n* If i is the index of the last balloon burst in (left, right), the coins that burst will get are nums[left] * nums[i] * nums[right], and to calculate dp[left][right], we also need to add the coins obtained from bursting balloons between left and i, and between i and right, i.e., dp[left][i] and dp[i][right]\\n\\n```\\n# Brute force recursion\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        return self.recurse(nums, 0, len(nums)-1)\\n    \\n    def recurse(self, nums, left, right):\\n        \\n        res = 0\\n        for i in range(left+1, right):\\n            coins = nums[left] * nums[i] * nums[right]\\n            leftRes = self.recurse(nums, left, i)\\n            rightRes = self.recurse(nums, i, right)\\n            res = max(res, coins + leftRes + rightRes)\\n        \\n        return res\\n\\n    \\n# Brute Better Memoization (69/70 Passed)\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        self.dp = [[-1 for _ in range(len(nums))] for _ in range(len(nums))]\\n        return self.recurse(nums, 0, len(nums)-1)\\n    \\n    def recurse(self, nums, left, right):\\n        \\n        if self.dp[left][right] != -1:\\n            return self.dp[left][right]\\n        \\n        res = 0\\n        for i in range(left+1, right):\\n            coins = nums[left] * nums[i] * nums[right]\\n            leftRes = self.recurse(nums, left, i)\\n            rightRes = self.recurse(nums, i, right)\\n            res = max(res, coins + leftRes + rightRes)\\n        \\n        self.dp[left][right] = res\\n        return res\\n\\n    \\n# Top down DP (Accepted)\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0 for _ in range(len(nums))] for _ in range(len(nums))]\\n        \\n        for gap in range(len(nums)):\\n            for left in range(len(nums)-gap):\\n                right = left + gap\\n                \\n                res = 0\\n                for i in range(left+1, right):\\n                    coins = nums[left] * nums[i] * nums[right]\\n                    res = max(res, coins + dp[left][i] + dp[i][right])\\n                dp[left][right] = res\\n                \\n        return dp[0][len(nums)-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# Brute force recursion\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        return self.recurse(nums, 0, len(nums)-1)\\n    \\n    def recurse(self, nums, left, right):\\n        \\n        res = 0\\n        for i in range(left+1, right):\\n            coins = nums[left] * nums[i] * nums[right]\\n            leftRes = self.recurse(nums, left, i)\\n            rightRes = self.recurse(nums, i, right)\\n            res = max(res, coins + leftRes + rightRes)\\n        \\n        return res\\n\\n    \\n# Brute Better Memoization (69/70 Passed)\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        self.dp = [[-1 for _ in range(len(nums))] for _ in range(len(nums))]\\n        return self.recurse(nums, 0, len(nums)-1)\\n    \\n    def recurse(self, nums, left, right):\\n        \\n        if self.dp[left][right] != -1:\\n            return self.dp[left][right]\\n        \\n        res = 0\\n        for i in range(left+1, right):\\n            coins = nums[left] * nums[i] * nums[right]\\n            leftRes = self.recurse(nums, left, i)\\n            rightRes = self.recurse(nums, i, right)\\n            res = max(res, coins + leftRes + rightRes)\\n        \\n        self.dp[left][right] = res\\n        return res\\n\\n    \\n# Top down DP (Accepted)\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0 for _ in range(len(nums))] for _ in range(len(nums))]\\n        \\n        for gap in range(len(nums)):\\n            for left in range(len(nums)-gap):\\n                right = left + gap\\n                \\n                res = 0\\n                for i in range(left+1, right):\\n                    coins = nums[left] * nums[i] * nums[right]\\n                    res = max(res, coins + dp[left][i] + dp[i][right])\\n                dp[left][right] = res\\n                \\n        return dp[0][len(nums)-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76275,
                "title": "java-solution-with-explanations",
                "content": "This is the kind of problem we use dynamic programming. WHY? it's very challenging to figure out what's the pattern of optimal burst order. In fact, there's no clear rule that makes sense. Shall we burst the balloon with maximum coins? Or shall we burst the one with least. This is the time we introduce Dynamic Programming, as we want to solve the big problem from small subproblem. It is clear that the amount of coins you gain relies on your previous steps. This is a clear signal of using DP.\\n\\nThe hard part is to define the subproblem. Think out what is clear in this problem? Let's scale this problem down. What is the fact you know for sure? Say if the array has only 1 balloon. The maximum coin would be the coin inside this ballon. This is the starting point! So let's move on to array with 2 balloons. Here, we have 2 cases, which of the balloon is the last one. The last one times the coins in boundary is the gain we get in the end. That is to say, last balloon is the key. Since we don't know the pattern of optimal. We just blindly iterate each balloon and check what's total gain if it's the last ballon.\\n\\nLet's use dp[i][j] to denote maximum gain from balloon range i to j. We try out each balloon as last burst in this range. Then the subproblem relation would be:\\n\\nforeach k in i to j:\\n dp[j][i] = max(array[j-1]*array[k]*array[i+1] + dp[j][k-1] + dp[k+1][i], dp[j][i]);\\n\\n    public class Solution {\\n    public int maxCoins(int[] nums) {\\n        // Extend list with head and tail (both are 1), index starts at 1\\n        int array[] = new int[nums.length + 2];\\n        array[0] = 1;\\n        array[array.length-1] = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            array[i+1] = nums[i];\\n        }\\n\\n        // Initialize DP arrays, 1 index based\\n        int dp[][] = new int[array.length][array.length]; //dp[i][j] stands for max coins at i step, burst j\\n        for (int i =0; i < array.length; i++) {\\n            for (int j = 0; j < array.length; j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n        for (int i=1; i< array.length-1; i++) {\\n            for (int j=i; j >=1; j--) {\\n                // k as last\\n                for (int k=j; k <= i; k++) {\\n                    dp[j][i] = Math.max(array[j-1]*array[k]*array[i+1] + dp[j][k-1] + dp[k+1][i], dp[j][i]);\\n                }\\n            }\\n        }\\n\\n        return dp[1][array.length-2];\\n    }\\n}\\n\\n\\n\\n\\n  [1]: http://easyleetcode.blogspot.com/?view=classic",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maxCoins(int[] nums) {\\n        // Extend list with head and tail (both are 1), index starts at 1\\n        int array[] = new int[nums.length + 2];\\n        array[0] = 1;\\n        array[array.length-1] = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            array[i+1] = nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 971203,
                "title": "burst-balloons-recursion-with-memorization",
                "content": "At first I thought i will try for recursive approach then add memorization to it but I have done a mistake I used arraylist and ost the track of index it is recursively correct but time limit exceeded because of O(n!) time complexity then I have changed my storing metho and done simple recursively with memorization.\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i :nums)\\n            arr.add(i);\\n        return getMaxCoins(arr,0);\\n    }\\n\\n    public int getMaxCoins(ArrayList<Integer> arr,int ans){\\n        if(arr.size()==0)\\n            return ans;\\n        int max=0;\\n        for(int i=0;i<arr.size();i++){\\n            int mul=1,val=arr.get(i);\\n            if(i!=0) mul*=arr.get(i-1);\\n            if(i<arr.size()-1) mul*=arr.get(i+1);\\n            int sum=ans+val*mul;\\n            arr.remove(i);\\n            max=Math.max(max,getMaxCoins(arr,sum));\\n            arr.add(i,val);\\n        }\\n        return max;\\n    }\\n}\\n```\\nCode below is recursion with memorization simple as possible.\\nFor the above soln we have `nums[i-1]*nums[i]*nums[i+1]` for the below soln we have `nums[-1]*nums[i]*nums[n].` .there are n balloons and `i ` will be the last one to burst.\\n\\nWe can see that the balloons is again separated into 2 sections. But this time since the balloon `i ` is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other.\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n=nums.length;\\n        int []extended=new int[n+2];\\n        extended[0]=extended[n+1]=1;\\n        for(int i=1;i<n+1;i++)\\n            extended[i]=nums[i-1];\\n        \\n        int [][]memoriz=new int[n+2][n+2];\\n        return getMaxCoins(extended,memoriz,0,n+1);\\n    }\\n\\n    public int getMaxCoins(int []extended,int [][]memoriz,int left,int right){\\n        if(left==right) return 0;\\n        if(memoriz[left][right]>0) return memoriz[left][right];\\n        int max=0;    \\n        for(int i=left+1;i<right;i++)\\n            max=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n        \\n        memoriz[left][right]=max;\\n        return max;\\n    }\\n}\\n```\\nThe below statement is crux of whole solution `extended[left]*extended[i]*extended[right]` this will account for last step where we have 1 as boundaries. Think in this way we break big problem into two small problems, take an example for n=5 elements **loop will be for 1-5** At `i =1` get ans of 0-1  ->`getMaxCoins(extended,memoriz,left,i)` and 1-5->`getMaxCoins(extended ,memoriz,i,right)` and add them as whole and find the maximum of all taking i=1,2,3,4,5..n as first step and boom we got the ans and in intermediate steps we store values into array for duplicate steps.\\n```\\nmax=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n```\\nHere is dp solution too with same intution same explanation with a slider that is used for filling 2D matrix diagonally .DP soln is bit complex if you jump previous parts I had visualize how values are filling in  matrix in memorization and then able to wrote DP soln .\\n```\\nclass Solution {\\n   public int maxCoins(int[] nums) {\\n\\tint n=nums.length;\\n    int []extended=new int[n+2];\\n     extended[0]=extended[n+1]=1;\\n     for(int i=1;i<n+1;i++)\\n         extended[i]=nums[i-1];\\n        \\n    int[][] dp = new int[n+2][n+2];\\n    for (int slider = 2; slider < n+ 2; slider++){\\n        for (int left = 0; left < n +2 - slider; left++) {\\n            int right = left + slider;\\n            for (int i = left + 1; i < right; i++)\\n                dp[left][right] = Math.max(dp[left][right],extended[left] * extended[i] * extended[right] \\n                                           + dp[left][i] + dp[i][right]);\\n            \\n        }\\n    }\\n\\n    return dp[0][n +1];\\n    }\\n}\\n```\\n**If you like my explaination and hardwork please upvote it,will motivate and inspire me.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i :nums)\\n            arr.add(i);\\n        return getMaxCoins(arr,0);\\n    }\\n\\n    public int getMaxCoins(ArrayList<Integer> arr,int ans){\\n        if(arr.size()==0)\\n            return ans;\\n        int max=0;\\n        for(int i=0;i<arr.size();i++){\\n            int mul=1,val=arr.get(i);\\n            if(i!=0) mul*=arr.get(i-1);\\n            if(i<arr.size()-1) mul*=arr.get(i+1);\\n            int sum=ans+val*mul;\\n            arr.remove(i);\\n            max=Math.max(max,getMaxCoins(arr,sum));\\n            arr.add(i,val);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n=nums.length;\\n        int []extended=new int[n+2];\\n        extended[0]=extended[n+1]=1;\\n        for(int i=1;i<n+1;i++)\\n            extended[i]=nums[i-1];\\n        \\n        int [][]memoriz=new int[n+2][n+2];\\n        return getMaxCoins(extended,memoriz,0,n+1);\\n    }\\n\\n    public int getMaxCoins(int []extended,int [][]memoriz,int left,int right){\\n        if(left==right) return 0;\\n        if(memoriz[left][right]>0) return memoriz[left][right];\\n        int max=0;    \\n        for(int i=left+1;i<right;i++)\\n            max=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n        \\n        memoriz[left][right]=max;\\n        return max;\\n    }\\n}\\n```\n```\\nmax=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n```\n```\\nclass Solution {\\n   public int maxCoins(int[] nums) {\\n\\tint n=nums.length;\\n    int []extended=new int[n+2];\\n     extended[0]=extended[n+1]=1;\\n     for(int i=1;i<n+1;i++)\\n         extended[i]=nums[i-1];\\n        \\n    int[][] dp = new int[n+2][n+2];\\n    for (int slider = 2; slider < n+ 2; slider++){\\n        for (int left = 0; left < n +2 - slider; left++) {\\n            int right = left + slider;\\n            for (int i = left + 1; i < right; i++)\\n                dp[left][right] = Math.max(dp[left][right],extended[left] * extended[i] * extended[right] \\n                                           + dp[left][i] + dp[i][right]);\\n            \\n        }\\n    }\\n\\n    return dp[0][n +1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691390,
                "title": "c-dp-i-think-a-lot-of-time-to-understand-how-to-use-dp",
                "content": "![image](https://assets.leetcode.com/users/xdh1cat/image_1592371264.png)\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int len = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n         \\n        vector<vector<int>> dp(len+2, vector<int>(len+2,0));\\n        for (int iv = 0; iv<len;iv++ ) {   \\n            for (int left = 1; left <=len-iv;left++) {\\n                int right = left + iv;\\n                for (int k = left; k<=right; k++) {\\n                    dp[left][right] = max(dp[left][right], nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] +dp[k+1][right]);\\n                }\\n            }    \\n        }\\n        return dp[1][len];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int len = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n         \\n        vector<vector<int>> dp(len+2, vector<int>(len+2,0));\\n        for (int iv = 0; iv<len;iv++ ) {   \\n            for (int left = 1; left <=len-iv;left++) {\\n                int right = left + iv;\\n                for (int k = left; k<=right; k++) {\\n                    dp[left][right] = max(dp[left][right], nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] +dp[k+1][right]);\\n                }\\n            }    \\n        }\\n        return dp[1][len];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519207,
                "title": "python-solutions-with-visualized-explanations",
                "content": "1. Refer to the example of balloons `[3,1,5,8]` where `n=4`. Append a balloon painted with `1` in the head (`nums[-1] = 1`), and a balloon painted with `1` in the tail (`nums[n] = 1`):\\n\\n   ### \\uD83C\\uDF88  \\uD83C\\uDF88  \\uD83C\\uDF88  \\uD83C\\uDF88  \\uD83C\\uDF88  \\uD83C\\uDF88\\n\\n     1    &nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;     1&nbsp;&nbsp;&nbsp;     5&nbsp;&nbsp;&nbsp;     8&nbsp;&nbsp;&nbsp;    1\\n\\n   Now we have `n=6` balloons in total, starting from index `0` to index `5`.\\n\\n2. Define `dp` as an `n * n `(or `6 * 6`) matrix, where `dp[i][j]` is the maximum coins we can collect by bursting balloons from index `i` to index `j`. For example, `dp[3][3]=5`,`dp[0][1]=3`. Note that the balloon `0` and `5` can never be bursted for coins.\\n\\n   Now the question has been reduced to how to compute `dp[1][4]` for the maximum coins we can collect by bursting balloons from index `1` to index `4`.\\n\\n3. Assume the **last** balloon we burst is `k (i <= k <= j)`. We have the following transition function:\\n\\n   ```python\\n   left = nums[i-1]\\n   right = nums[j+1]\\n   dp[i][j] = dp[i, k-1] + left * nums[k] * right + dp[k+1, j]\\n   ```\\n\\n   For example, suppose `i=1, j=4, k=3`. We burst from index `1` to index `2` for the coins of`dp[i, k-1]`:\\n\\n   ### \\uD83C\\uDF88  \\u2716\\uFE0F  \\u2716\\uFE0F  \\uD83C\\uDF88  \\uD83C\\uDF88  \\uD83C\\uDF88\\n\\n     1    &nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;     1&nbsp;&nbsp;&nbsp;     5&nbsp;&nbsp;&nbsp;     8&nbsp;&nbsp;&nbsp;    1\\n\\n   And subsequently we burst from index `4` to index `4` for the coins of `dp[k+1, j]`:\\n\\n   ### \\uD83C\\uDF88  \\u2716\\uFE0F  \\u2716\\uFE0F  \\uD83C\\uDF88  \\u2716\\uFE0F  \\uD83C\\uDF88\\n\\n     1    &nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;     1&nbsp;&nbsp;&nbsp;     5&nbsp;&nbsp;&nbsp;     8&nbsp;&nbsp;&nbsp;    1\\n\\n   **At last** we burst the balloon of index `k=3`, whose left balloon is of index `i-1=0`, and the right balloon is of index `j+1=5`. The coins for this burst is `nums[i-1]*nums[k]*nums[j+1]`:\\n\\n   ### \\uD83C\\uDF88  \\u2716\\uFE0F  \\u2716\\uFE0F  \\u2716\\uFE0F  \\u2716\\uFE0F  \\uD83C\\uDF88\\n\\n     1    &nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;     1&nbsp;&nbsp;&nbsp;     5&nbsp;&nbsp;&nbsp;     8&nbsp;&nbsp;&nbsp;    1\\n\\n4. How many possible positions for `k` when computing `dp[i][j]`? We loop through `i` to `j`, and there are `(j+1-i)` positions, or `(j+1-i)` possible ways to earn coins. We look for the way to collect the maximum coins.\\n\\n   ```python\\n   coins_max = 0\\n   for k in range(i, j + 1):\\n     left = nums[i-1]\\n     right = nums[j+1]\\n     coins_k_max = cal(i, k - 1) + left * nums[k] * right + cal(k + 1, j)\\n     coins_max = max(coins_max, coins_k_max)\\n   ```\\n\\nCodes:\\n```python\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        # Append a balloon painted with `1` in the head, and a balloon painted with `1` in the tail:\\n        nums = [1] + nums + [1]\\n        # current balloons (with two `vitural` ballons)\\n        n = len(nums)\\n        # dp[i][j]: the maximum coins we can collect by bursting balloons from index `i` to index `j`\\n        dp = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # compute dp[i][j]\\n        def cal(i, j):\\n            # memory\\n            if dp[i][j]:\\n                return dp[i][j]\\n            # Meaningless case. Just return 0. \\n            elif i > j:\\n                return dp[i][j]\\n            else:\\n                coins_max = 0\\n                # loop through (j+1-i) possible positions for the last balloon\\n                for k in range(i, j + 1):\\n                    left = nums[i-1]\\n                    right = nums[j+1]\\n                    coins_k_max = cal(i, k - 1) + left * nums[k] * right + cal(k + 1, j)\\n                    coins_max = max(coins_max, coins_k_max)\\n                # update the memory\\n                dp[i][j] = coins_max\\n                return dp[i][j]\\n        # compute dp[1][n-2]\\n        return cal(1, n - 2)\\n\\t",
                "solutionTags": [],
                "code": "```python\\n   left = nums[i-1]\\n   right = nums[j+1]\\n   dp[i][j] = dp[i, k-1] + left * nums[k] * right + dp[k+1, j]\\n   ```\n```python\\n   coins_max = 0\\n   for k in range(i, j + 1):\\n     left = nums[i-1]\\n     right = nums[j+1]\\n     coins_k_max = cal(i, k - 1) + left * nums[k] * right + cal(k + 1, j)\\n     coins_max = max(coins_max, coins_k_max)\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524408,
                "title": "detailed-explanation-readable-explained-code",
                "content": "Intuition-\\n\\t1) Clearly the brute force solution would be to try all possible combinations of popping the balloons and so First we have n choices to select 1 to burst and then in the next step n-1 choices ,,,,,,,,and in the end we are left with the only balloon ..So clearly it\\'s a n! solution which will work for n<=10\\n\\t2) So clearly we have to find a way to break this problem into smaller parts.  A natural approach would be to separate the array on the basis of what if we pop a particular balloon first and then separate the array into 2 parts.  SO if i have 3,1,4,8,9 and i guess that a balloon 4 should be popped first ,would it make the 2 parts [3,1] &[8,9] results independent of each other.I mean can we forget while calculating [3,1] that [8,9] exists. Clearly Not, \\nWhy?\\nbecause even if we knew in [3,1] the correct order we have to pop these balloons we still dont know the exact right neighbor of these elements ,rigght neighbor could be 8 or 9 depending on which one is popped earlier.\\nSo what if ,we could find a definition of dp that could help us make these 2 parts independent of each other.\\n\\n3) So instead of picking or guessing which balloon to pop first we guess which balloon is popped last. So it means if [1,2,3,4,5] if in this array we knew that element 3 was the last one to be popped and then we would know that subparts[1,2] would always have right border as 3 because it\\'s the last one to be popped  and similarly the right part[4,5] would always know it\\'s left border\\n\\nNow onto the solution->\\nwe define **dp[left][right]to be maximum value we can get on bursting thee balloons in the subarray nums[left,right](inclusive) considering the fact that other balloons are still not burst ..**\\nAnd so \\nHere\\'s the code\\n```\\nint f(vector<int>&nums,vector<vector<int>>&dp)\\n    {\\n        int n=nums.size();\\n        for(int k=1;k<n-2;k++)\\n        {\\n            for(int j=1;j<n-k-1;j++)\\n            {\\n                for(int i=j+1;i<j+k;i++)\\n                {\\n                    dp[j][j+k]=max(dp[j][j+k],dp[j][i-1]+dp[i+1][j+k]+nums[j-1]*nums[j+k+1]*nums[i]);\\n                }\\n                dp[j][j+k]=max(dp[j][j+k],nums[j]*nums[j-1]*nums[j+k+1]+dp[j+1][j+k]);\\n                dp[j][j+k]=max(dp[j][j+k],nums[j+k]*nums[j-1]*nums[j+k+1]+dp[j][j+k-1]);\\n            }\\n        }\\n        return dp[1][n-2];\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(nums.size(),vector<int>(nums.size()));\\n        for(int i=1;i<nums.size()-1;i++)\\n            dp[i][i]=nums[i]*nums[i+1]*nums[i-1];\\n        return f(nums,dp);\\n    }\\n```\\nCode Explanation->we have added fake nodes or balloons with value 1 so that we dont have to check for out of bound error again and again.\\nk is the length of the interval .\\nwhy is it kept in outer bracket because once we pop a balloon the length of subparts will decrease by 1 atleast,\\nso solutions of smaller interval are needed.\\nnow j is the starting point of the interval and so naturally j+k is the endpoint \\nnow we consider each balloon to be popped last and use the solution to the solved subproblem\\nNow explaining the dp recurrence relation->\\ndp[left][right]=max(dp[left][right],dp[left,i-1]+dp[i+1,right]+nums[i]*nums[left-1]*nums[right+1]);\\nthe first term of max is a no brainer.However the second term implies that if we knew that ith was the last burst balloon .like for ex nums=[1,2,3,4,5]\\nand we are calculating dp[1,3](0 based indexing) and we knew that 2nd index element is the last balloon so in the end nums =[1,3,5] so popping 3 (2nd index element ) would yield product of nums[left-1] which is nums[0]=1 , nums[right+1] which is nums[4]=5 and nums[2]=3\\nso before breaking into subparts we take this factor nums[i]*nums[left-1]*nums[right+1] into consideration.\\n\\nUpvote if you like my explanation and if you are still confused ,feel free to ask any questions.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint f(vector<int>&nums,vector<vector<int>>&dp)\\n    {\\n        int n=nums.size();\\n        for(int k=1;k<n-2;k++)\\n        {\\n            for(int j=1;j<n-k-1;j++)\\n            {\\n                for(int i=j+1;i<j+k;i++)\\n                {\\n                    dp[j][j+k]=max(dp[j][j+k],dp[j][i-1]+dp[i+1][j+k]+nums[j-1]*nums[j+k+1]*nums[i]);\\n                }\\n                dp[j][j+k]=max(dp[j][j+k],nums[j]*nums[j-1]*nums[j+k+1]+dp[j+1][j+k]);\\n                dp[j][j+k]=max(dp[j][j+k],nums[j+k]*nums[j-1]*nums[j+k+1]+dp[j][j+k-1]);\\n            }\\n        }\\n        return dp[1][n-2];\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(nums.size(),vector<int>(nums.size()));\\n        for(int i=1;i<nums.size()-1;i++)\\n            dp[i][i]=nums[i]*nums[i+1]*nums[i-1];\\n        return f(nums,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986771,
                "title": "mcm-memorisation-simple-and-elegent-solution-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  //MCM +memo taking every kth balloon bursting in the last;\\n  \\n  \\n  int memo[501][501];\\n  int solve(vector<int> &nums,int i ,int j){\\n    if(i>j)return 0;\\n    if(memo[i][j]!=-1)return memo[i][j];\\n    \\n    int max_score=INT_MIN;\\n    for(int k=i;k<=j;k++){\\n      int curr_score=nums[i-1]*nums[k]*nums[j+1];\\n      int temp_score=curr_score+solve(nums,i,k-1)+solve(nums,k+1,j);\\n      if(temp_score>max_score)max_score=temp_score;\\n    }\\n    return memo[i][j]=max_score;\\n  }\\n    int maxCoins(vector<int>& nums) {\\n      memset(memo,-1,sizeof(memo));\\n      //-1 th position pe && nth pos pe 1 score milega (by example)\\n      nums.insert(nums.begin(),1);\\n      nums.push_back(1);\\n      \\n      return solve(nums,1,nums.size()-2);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  //MCM +memo taking every kth balloon bursting in the last;\\n  \\n  \\n  int memo[501][501];\\n  int solve(vector<int> &nums,int i ,int j){\\n    if(i>j)return 0;\\n    if(memo[i][j]!=-1)return memo[i][j];\\n    \\n    int max_score=INT_MIN;\\n    for(int k=i;k<=j;k++){\\n      int curr_score=nums[i-1]*nums[k]*nums[j+1];\\n      int temp_score=curr_score+solve(nums,i,k-1)+solve(nums,k+1,j);\\n      if(temp_score>max_score)max_score=temp_score;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 76279,
                "title": "my-understanding-of-the-n-3-dp-solution-comments-explanation",
                "content": "Honestly, I was a little confused when I read the most voted solution. I get the idea, but I had no clue how to fill in the dynamic matrix, so if you have the same confusion here, my comment might help you understand how to actually fill in the blanks.\\n\\n 1. Burst all the zeros to avoid hassles. Pad 1 on the both sides of the array, that's my `padded_arr`, and I use `nonZeroNum ` to represent the actual non-zero numbers.\\nReturn when there is 0/1 non-zero numbers.\\n\\n 2. create a dp matrix using the dimension`nonZeroNum + 2` x   `nonZeroNum + 2`, the reason is that, on the boundary condition, a.k.a, you are at the `1` on either end of the  `padded_arr`, those  `1` doesn't contribute to the coins. Since the element in the matrix is default to 0, you don't even have to internalize those elements.\\n\\n 3. In this dp matrix, we only update half of the elements, and that's the half upper triangle, when we do the update, it's from left to right, and from **bottom up**, so the last element updated is the element in the up right corner.\\n\\n 4. Ok, now comes the **important** part... The `dp[start][end] ` represents the maximum coins when you burst and only burst all the elements in the range of `[start, end], 'start' and 'end' inclusive`. In the inner loop, recursive from `start `to `end`, and that recursive element  `lastBurst` represents the last element to burst in this range. Since at that point of time, either both of   `start` and  `end` are already burst, or the `lastBurst` itself is  `start` or `end`, either way, the left and right neighbor should be `padded_arr[start -1] and padded_arr[end+1]`, rather than  `padded_arr[start] and padded_arr[end]`\\n\\n\\n        public class Solution {\\n        public int maxCoins(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n    \\n        int[] padded_arr = new int[nums.length+2];\\n        int idx = 1;\\n        padded_arr[0] = 1;\\n        \\n        for(int n:nums){\\n            if(n != 0){\\n                padded_arr[idx++] = n;\\n            }\\n        }\\n        if(idx == 1) return 0;\\n        if(idx == 2) return padded_arr[1];\\n        \\n        int nonZeroNum = idx-1;\\n        padded_arr[idx++] = 1;\\n        \\n        //System.out.println(\"nonZeroNum = \"+ nonZeroNum);\\n\\n\\n        \\n        int[][] dp = new int[nonZeroNum+2][nonZeroNum+2];\\n        \\n        for(int len = 1; len<=nums.length; len++){\\n            for(int start = 1; start<=nonZeroNum-len+1; start++){\\n                int end = start + len -1;\\n                int curMaxCoin = -1;\\n                for(int lastBurset = start; lastBurset<=end; lastBurset++){\\n                    curMaxCoin = Math.max(curMaxCoin, dp[start][lastBurset-1] + dp[lastBurset+1][end] + padded_arr[lastBurset]* padded_arr[start -1] * padded_arr[end+1]);\\n                }\\n                dp[start][end] = curMaxCoin;\\n            }\\n        }\\n        \\n        return dp[1][nonZeroNum];\\n        } \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxCoins(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n    \\n        int[] padded_arr = new int[nums.length+2];\\n        int idx = 1;\\n        padded_arr[0] = 1;\\n        \\n        for(int n:nums){\\n            if(n != 0){\\n                padded_arr[idx++] = n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76242,
                "title": "backtracking-solution-tle-of-course-in-case-you-are-curious",
                "content": "Typical DP/DC problem, but providing one possible backtracking solution just in case you are curious. TLE. \\n\\n```\\npublic class Solution {\\n    boolean[] used; \\n    int[] nums; \\n    public int maxCoins(int[] nums) {\\n        this.used = new boolean[nums.length];\\n        this.nums = nums; \\n        int max = 0; \\n        for(int i = 0; i<nums.length; i++){\\n            used[i] = true;  \\n            max = Math.max(helper(i), max);\\n            used[i] = false; \\n        }\\n        return max;\\n    }\\n    private int helper(int cur){\\n        int left = cur-1, right = cur+1; \\n        while(left>=0 && used[left]) left--; \\n        left = (left == -1) ? 1 : nums[left]; \\n        while(right<nums.length && used[right]) right++; \\n        right = (right == nums.length) ? 1 : nums[right]; \\n        \\n        int max = 0; \\n        for(int i = 0; i<nums.length; i++){\\n            if(used[i]) continue; \\n            used[i] = true; \\n            max = Math.max(helper(i), max); \\n            used[i] = false; \\n        }\\n        \\n        return nums[cur] * left * right + max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    boolean[] used; \\n    int[] nums; \\n    public int maxCoins(int[] nums) {\\n        this.used = new boolean[nums.length];\\n        this.nums = nums; \\n        int max = 0; \\n        for(int i = 0; i<nums.length; i++){\\n            used[i] = true;  \\n            max = Math.max(helper(i), max);\\n            used[i] = false; \\n        }\\n        return max;\\n    }\\n    private int helper(int cur){\\n        int left = cur-1, right = cur+1; \\n        while(left>=0 && used[left]) left--; \\n        left = (left == -1) ? 1 : nums[left]; \\n        while(right<nums.length && used[right]) right++; \\n        right = (right == nums.length) ? 1 : nums[right]; \\n        \\n        int max = 0; \\n        for(int i = 0; i<nums.length; i++){\\n            if(used[i]) continue; \\n            used[i] = true; \\n            max = Math.max(helper(i), max); \\n            used[i] = false; \\n        }\\n        \\n        return nums[cur] * left * right + max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794486,
                "title": "python-solution-with-simple-explanation",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:                \\n        # number of real balloons ( no padding fake ones)\\n        n = len(nums)\\n        \\n        if n <= 0:\\n            return 0\\n\\n        # add 1 padding (fake balloon) on each side\\n        nums = [1] + nums + [1]\\n        \\n        # number of all balloons (fake and real)\\n        m = len(nums)\\n        \\n        # create table with default value 0\\n        dp = [[0 for x in range(m)] for y in range(m)]\\n        \\n        # fill dp table with sliding window\\n        \\n        # create window size from 1 till amount of real balloons, (-1 to be exclude the fake right balloon padding)\\n        for window_size in range(1, m-1):\\n            # left border slides from 1 to the end until the right border hits the last real balloon\\n            for left in range(1, (m - window_size)):\\n                # right border is the left border plus the windows size ( -1 to only use balloons in window)\\n                right = left + window_size - 1\\n                # go from left to right ( +1 to include the right balloon)\\n                # i is the index of the balloon which gets burst last in the selected window (left,right)\\n                for i in range(left,right+1):\\n                    # max sum of the values left to i in the selected window\\n                    l_value = dp[left][i-1]\\n                    # max sum of the values right to i in the selected window\\n                    r_value = dp[i+1][right]\\n                    # calculate the sum if balloon at i gets bursted last (meaning all other elements in the window are not existend)\\n                    element_value = nums[left-1] * nums[i] * nums[right+1]\\n                    # add up all the results\\n                    i_sum = l_value + element_value + r_value\\n                    \\n                    # fill the table with the max value for the selected window\\n                    dp[left][right] = max(dp[left][right], i_sum)\\n                    \\n\\n        return dp[1][n]         \\n```\\n\\nhttps://www.youtube.com/watch?v=uG_MtaCJIrM : Great tutorial which helped me to understand this problem",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:                \\n        # number of real balloons ( no padding fake ones)\\n        n = len(nums)\\n        \\n        if n <= 0:\\n            return 0\\n\\n        # add 1 padding (fake balloon) on each side\\n        nums = [1] + nums + [1]\\n        \\n        # number of all balloons (fake and real)\\n        m = len(nums)\\n        \\n        # create table with default value 0\\n        dp = [[0 for x in range(m)] for y in range(m)]\\n        \\n        # fill dp table with sliding window\\n        \\n        # create window size from 1 till amount of real balloons, (-1 to be exclude the fake right balloon padding)\\n        for window_size in range(1, m-1):\\n            # left border slides from 1 to the end until the right border hits the last real balloon\\n            for left in range(1, (m - window_size)):\\n                # right border is the left border plus the windows size ( -1 to only use balloons in window)\\n                right = left + window_size - 1\\n                # go from left to right ( +1 to include the right balloon)\\n                # i is the index of the balloon which gets burst last in the selected window (left,right)\\n                for i in range(left,right+1):\\n                    # max sum of the values left to i in the selected window\\n                    l_value = dp[left][i-1]\\n                    # max sum of the values right to i in the selected window\\n                    r_value = dp[i+1][right]\\n                    # calculate the sum if balloon at i gets bursted last (meaning all other elements in the window are not existend)\\n                    element_value = nums[left-1] * nums[i] * nums[right+1]\\n                    # add up all the results\\n                    i_sum = l_value + element_value + r_value\\n                    \\n                    # fill the table with the max value for the selected window\\n                    dp[left][right] = max(dp[left][right], i_sum)\\n                    \\n\\n        return dp[1][n]         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 655397,
                "title": "c-dp-solution-with-very-detailed-explanation-starting-from-dfs",
                "content": "So, the solution I have started with was DFS solution where at every level of recursion you pick an unused baloon, find its left and right neighbors\\nThen, you compute how much coins you are going to earn by doing that and make a recursive call to compute the rest.\\nAgain, you do it for EVERY balloon on this recursive level. \\nThis way we are trying all permutations of the baloons of size n.\\nWhat is the complexity of this? \\nAt the top level, your branch factor is n because there are n baloons to burst. Then, on the next level for each of those n branches, the branching factor is n-1 and so on and so forth until branch factor becomes 0 when you have burst all the balloons. The depth of this tree is n.\\nThe number of leafs will be n*(n-1)*(n-2)...1 which is n!. Now, every time you branch out, you do O(n) to find left and right baloons that haven\\'t been used yet(assuming you are marking baloons with -1 rather than passing the memory). For each node in this tree, you are doing O(n). So, for each leaf, you are doing n*n work because n is the depth and n is the work at each level. So, it seems like it is n^2 * n!.\\nHorrible!\\nIf you try to use this recurrence relation for DP, you will end up with a much better solution but still not perfect.\\n\\nNow, the key here is to use another recurrence relation. Instead of choosing the first baloon to burst and then going from there, use the last baloon to burst and use that. \\nWhy is that? \\nWell, because it is very easy to compute coins for the last baloon. That\\'s one part but not the most important one.\\nBy bursting left subarray and right subarrays before you burst yourself, you are not letting them intermix the orderings. To intermix, they need to break the wall between them which is you. And you burst yourself last. So, all you need to know is the best score for the left subarray, then right subarrray and then add yourself. The order left, rigth or right, left doesn\\'t matter.\\nI will also quote from top solution:\\n```\\nThen another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore\\ninstead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst.\\n```\\nMoving on to the logic.\\nLet\\'s say you had \\n[3, 1, 5, 8]\\nIf you choose 5 as your last baloon, then score is 1 * 5 * 1, where ones are virtual bounds as the rest are burst because this is your last baloon.\\nAgain, you do this for every baloon and ask left left subarray to compute best possible coin sum by bursting all of them and right subarray to compute best possible coin sum by bursting all of them.\\nOn the topmost level, you are going to try out all permutations ending with 0,1,2,3..n-1 baloon.\\nThis works because let\\'s say when you are trying out to burst baloon at index 4, you make recursive call to the part [0,3] and [5, end]. They will also try out all possible ordering of baloons in their subarray and return the result to you. \\nSo, this way we are also considering all the options except that now, at every level we are spending constant time instead of O(n).\\nThis is great!\\nHere is where comes DP.\\nHow, do you compute best for subarray of size 1? You ask what is the best left subarray score and it is zero because it is empty. Same with the right one. Now, you have to compute coins you are bringing to the table. Again, [1, coins, 1] which is 1 * coins * 1. Cool.\\nYou have solved the problem for all sizes of 1. Do the same for size 2.\\nExample with size 3:\\nNow, imagine we have array of size 3 [3, 1, 5] and you have computed the results for all subarrays of sizes 1 and 2.\\nYou go through each element in it and try that element as last one to burst.\\nFor example, let\\'s burst 3 as last. Then, left gives us nothing because there is nothing to the left. 3 brings total of 1(left virtual boundary)*3(coins)*8 (because this is the first value outside of our burst range to the right). Then, we ask how much right subarray [1, 5] is going to bring us. Doing this, you will get bottom up DP solution. It is O(n^3) time and O(n^2) space. where dp[i][j] represents max amount of coins to burst baloons in range [i, j].\\n```\\n    int maxCoins(vector<int>& nums) {\\n        int orig_size = nums.size();\\n\\t\\t// virtual bounds for simplicity\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), 0));\\n        int len = 1;\\n\\t\\t// compute all possible sizes as subarray of size len needs to know results for len-1, len-2 and etc.\\n        while(len <= orig_size){\\n\\t\\t    // start is i\\n            int i = 1;\\n\\t\\t\\t// end included\\n            int end = i + len - 1;\\n\\t\\t\\t// this window has size len, then slide it to the left by for as long as you can.\\n            for(; end < (nums.size() - 1); i++, end++){\\n\\t\\t\\t    // in each range, try every element as last baloon to burst, compute what it brings \\n\\t\\t\\t\\t// and you computed results for left and right parts\\n                for(int last = i; last <= end; last++){\\n                    int left_range_res = dp[i][last - 1];\\n                    int right_range_res = dp[last + 1][end];\\n                    int coins_in_last = nums[last];\\n\\t\\t\\t\\t\\t// nums[i - 1] is the first baloon to the left that isn\\'t burst so it is your left boundary(it might be virtual)\\n\\t\\t\\t\\t\\t// nums[end + 1] is the first baloon to the right that isn\\'t burst so it is your right boundary(it might be virtual)\\n                    int last_burst_score = nums[i - 1] * coins_in_last * nums[end + 1];\\n                    dp[i][end] = max(dp[i][end], left_range_res + last_burst_score + right_range_res);\\n                }\\n            }\\n\\t\\t\\t// now find results for len+1 using what we have computed.\\n            len++;\\n        }\\n\\t\\t// this is because we have added two virtual bounds.\\n        return dp[1][orig_size];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nThen another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore\\ninstead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst.\\n```\n```\\n    int maxCoins(vector<int>& nums) {\\n        int orig_size = nums.size();\\n\\t\\t// virtual bounds for simplicity\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), 0));\\n        int len = 1;\\n\\t\\t// compute all possible sizes as subarray of size len needs to know results for len-1, len-2 and etc.\\n        while(len <= orig_size){\\n\\t\\t    // start is i\\n            int i = 1;\\n\\t\\t\\t// end included\\n            int end = i + len - 1;\\n\\t\\t\\t// this window has size len, then slide it to the left by for as long as you can.\\n            for(; end < (nums.size() - 1); i++, end++){\\n\\t\\t\\t    // in each range, try every element as last baloon to burst, compute what it brings \\n\\t\\t\\t\\t// and you computed results for left and right parts\\n                for(int last = i; last <= end; last++){\\n                    int left_range_res = dp[i][last - 1];\\n                    int right_range_res = dp[last + 1][end];\\n                    int coins_in_last = nums[last];\\n\\t\\t\\t\\t\\t// nums[i - 1] is the first baloon to the left that isn\\'t burst so it is your left boundary(it might be virtual)\\n\\t\\t\\t\\t\\t// nums[end + 1] is the first baloon to the right that isn\\'t burst so it is your right boundary(it might be virtual)\\n                    int last_burst_score = nums[i - 1] * coins_in_last * nums[end + 1];\\n                    dp[i][end] = max(dp[i][end], left_range_res + last_burst_score + right_range_res);\\n                }\\n            }\\n\\t\\t\\t// now find results for len+1 using what we have computed.\\n            len++;\\n        }\\n\\t\\t// this is because we have added two virtual bounds.\\n        return dp[1][orig_size];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425051,
                "title": "clean-javascript-solution",
                "content": "**Idea**\\n\\ndp[i][j] = maxCoins(nums[i:j])\\ndp[i][j] = max { dp[i][k - 1] + vals[i - 1] * vals[k] * vals[j + 1] + dp[k + 1][j], i <= k <= j }\\n\\nres = dp[1][n]\\n\\n```\\nconst maxCoins = (nums) => {\\n  const vals = [1, ...nums, 1];\\n  const n = nums.length;\\n  const dp = [...Array(n + 2)].map(() => Array(n + 2).fill(0));\\n  for (let len = 1; len <= n; len++) {\\n    for (let i = 1; i + len <= n + 1; i++) {\\n      const j = i + len - 1;\\n      for (let k = i; k <= j; k++) {\\n        dp[i][j] = Math.max(\\n          dp[i][j],\\n          dp[i][k - 1] + vals[i - 1] * vals[k] * vals[j + 1] + dp[k + 1][j],\\n        );\\n      }\\n    }\\n  }\\n  return dp[1][n];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst maxCoins = (nums) => {\\n  const vals = [1, ...nums, 1];\\n  const n = nums.length;\\n  const dp = [...Array(n + 2)].map(() => Array(n + 2).fill(0));\\n  for (let len = 1; len <= n; len++) {\\n    for (let i = 1; i + len <= n + 1; i++) {\\n      const j = i + len - 1;\\n      for (let k = i; k <= j; k++) {\\n        dp[i][j] = Math.max(\\n          dp[i][j],\\n          dp[i][k - 1] + vals[i - 1] * vals[k] * vals[j + 1] + dp[k + 1][j],\\n        );\\n      }\\n    }\\n  }\\n  return dp[1][n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246529,
                "title": "python3-solution-top-down-dp",
                "content": "```Python\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        @lru_cache(None)\\n        def dp(i, j):\\n            \"\"\"dp(i, j) represents the maximum coins after bursting all baloons between i and j.\"\"\"\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return nums[i-1] * nums[i] * nums[i+1]\\n            return max(dp(i, k-1) + dp(k+1, j) + nums[i-1] * nums[k] * nums[j+1] for k in range(i, j+1))\\n        return dp(1, len(nums) - 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        @lru_cache(None)\\n        def dp(i, j):\\n            \"\"\"dp(i, j) represents the maximum coins after bursting all baloons between i and j.\"\"\"\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return nums[i-1] * nums[i] * nums[i+1]\\n            return max(dp(i, k-1) + dp(k+1, j) + nums[i-1] * nums[k] * nums[j+1] for k in range(i, j+1))\\n        return dp(1, len(nums) - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240545,
                "title": "312-time-90-16-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to use dynamic programming to solve the problem. We define dp[i][j] as the maximum coins we can get by bursting all balloons between index i and j (exclusive). We want to compute dp[0][n-1] as the result of the original problem.\\n\\nTo fill the dp table, we need to find the last balloon to burst. We iterate k from i+1 to j-1, and for each k, we compute the maximum coins we can get by bursting the balloon at k last. This involves the coins we get by bursting the balloon at k, plus the maximum coins we can get for the balloons to the left of k and to the right of k. We add up these three parts to get the maximum coins for subproblems.\\n\\nThe time complexity of the algorithm is O(n^3), which is acceptable given the constraints of the problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        # Add padding to the input array\\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        # Initialize a dp table to store the maximum coins for subproblems\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        # Iterate the input array in reverse order to fill the dp table\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+2, n):\\n                # Iterate k from i+1 to j-1 to find the last balloon to burst\\n                for k in range(i+1, j):\\n                    # Compute the maximum coins for subproblems\\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\\n        \\n        # The result is the maximum coins for the original problem\\n        return dp[0][n-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        # Add padding to the input array\\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        # Initialize a dp table to store the maximum coins for subproblems\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        # Iterate the input array in reverse order to fill the dp table\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+2, n):\\n                # Iterate k from i+1 to j-1 to find the last balloon to burst\\n                for k in range(i+1, j):\\n                    # Compute the maximum coins for subproblems\\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\\n        \\n        # The result is the maximum coins for the original problem\\n        return dp[0][n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659214,
                "title": "simple-gap-strategy-dp-well-explained",
                "content": "**Before moving towards solution, let me Wishes you a Happy New Year 2022**\\n![image](https://assets.leetcode.com/users/images/4ffaf13f-7e07-4990-8572-e0b2c265df1e_1641006205.1184082.gif)\\n\\n```\\nStrategy Explained :\\n```\\nFirst of all, dp[i][j] in here means, the maximum coins we get after we burst all the balloons between i and j in the original array.\\n\\nFor example with input [3,1,5,8] :\\n\\ndp[0][0] means we burst ballons between [0,0], which means we only burst the first balloon in original array. So dp[0][0] is 1 * 3 * 1 = 3.\\n\\ndp[1][1] means we burst balloons between [1][1], which means we only burst the second ballon in the original array. So dp[1][1] is 3 * 1 * 5 = 15.\\n\\nSo in the end for this problem we want to find out dp[0][ arr.length - 1 ], which is the maximum value we can get when we burst all the balloon between [0 , length -1]\\n\\nTo get that we need the transition function :\\n\\n```\\nfor (int k = left; k <= right; ++k)\\ndp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])**\\n```\\n\\nThis transition function basically says in order to get the maximum value we can get for bursting all the balloons between [ i , j] , we just loop through each balloon between these two indexes and make them to be the last balloon to be burst,\\n\\nwhy we pick it as the last balloon to burst ?\\n\\nFor example when calculating dp[0,3] and picking index 2 as the last balloon to burst,\\n\\n[ 3 , 1 , 5 , 8] , that means 5 is the last balloon to burst between [0,3] , to get the maximum value when picking 5 as the last balloon to burst :\\n\\nmax = maximum value of bursting all the balloon on the left side of 5 + maximum value of bursting all the balloon on the right side of 5 + bursting balloon 5 when left side and right side are gone.\\n\\nThat is dp[0, 1] + nums[0 - 1] * nums[2] * nums[3 + 1] + + dp[3,3];\\n\\nThat is dp[left, k - 1] + nums[left - 1] * nums[k] * nums[right + 1] + dp[k+1, right] ;\\n\\nto get the maximum dp[left, right] we just loop through all the possible value of k to get the maximum.\\n\\nThanks to @hi-malik\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int dp[][] = new int[nums.length][nums.length];\\n        \\n        for(int g = 0; g < dp.length; g++){ // where g represent gap;\\n            for(int i = 0, j = g; j < dp.length; i++, j++){\\n                int max = Integer.MIN_VALUE;\\n                for(int k = i; k <= j; k++){\\n                    int left = k == i ? 0 : dp[i][k - 1];\\n                    int right = k == j ? 0 : dp[k + 1][j];\\n                    int val = (i == 0 ? 1 : nums[i - 1]) * nums[k] * (j == nums.length - 1 ? 1 : nums[j + 1]);\\n                    int total = left + right + val;\\n                    if(total > max) max = total;\\n                }\\n                dp[i][j] = max;\\n            }\\n        }\\n        return dp[0][dp.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nStrategy Explained :\\n```\n```\\nfor (int k = left; k <= right; ++k)\\ndp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])**\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int dp[][] = new int[nums.length][nums.length];\\n        \\n        for(int g = 0; g < dp.length; g++){ // where g represent gap;\\n            for(int i = 0, j = g; j < dp.length; i++, j++){\\n                int max = Integer.MIN_VALUE;\\n                for(int k = i; k <= j; k++){\\n                    int left = k == i ? 0 : dp[i][k - 1];\\n                    int right = k == j ? 0 : dp[k + 1][j];\\n                    int val = (i == 0 ? 1 : nums[i - 1]) * nums[k] * (j == nums.length - 1 ? 1 : nums[j + 1]);\\n                    int total = left + right + val;\\n                    if(total > max) max = total;\\n                }\\n                dp[i][j] = max;\\n            }\\n        }\\n        return dp[0][dp.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290257,
                "title": "c-solution-bottom-up-approach",
                "content": "*Bottom up  Approach *\\n*using gap strategy*\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n][n];\\n        for(int gap =0; gap <n; gap++){\\n            for(int i =0 , j = gap; j<n; i++,j++){\\n                int max_ = INT_MIN;\\n                for(int k = i ; k<=j; k++) {\\n                    int left = k ==i ?0 : dp[i][k-1];\\n                    int right = k == j?0 : dp[k+1][j];\\n                    int val = (i==0? 1: nums[i-1]) * nums[k] * (j==nums.size() -1? 1: nums[j+1]);\\n                    int total = left+ right + val;\\n                    if(total > max_) max_ = total;\\n                    \\n               }\\n            dp[i][j] = max_;   \\n            } \\n        }\\n       return dp[0][n-1];\\n    }\\n};\\n```\\ncomment below if have dobuts and upvote!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n][n];\\n        for(int gap =0; gap <n; gap++){\\n            for(int i =0 , j = gap; j<n; i++,j++){\\n                int max_ = INT_MIN;\\n                for(int k = i ; k<=j; k++) {\\n                    int left = k ==i ?0 : dp[i][k-1];\\n                    int right = k == j?0 : dp[k+1][j];\\n                    int val = (i==0? 1: nums[i-1]) * nums[k] * (j==nums.size() -1? 1: nums[j+1]);\\n                    int total = left+ right + val;\\n                    if(total > max_) max_ = total;\\n                    \\n               }\\n            dp[i][j] = max_;   \\n            } \\n        }\\n       return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965082,
                "title": "java-o-n-3-dp-clean-code-with-explanation",
                "content": "If you have some experience solving DP problems, you\\'ll quickly realize that it is a DP problem.\\n\\nLet ```dp[i][j]``` =maximum value we can obtain by bursting all balloons from ```i``` to ```j``` given that balloons ```i-1``` and ```j+1``` are unburst.\\n\\nIf balloon ```k``` is the last to burst between ```i``` and ```j```, then ```dp[i][j]``` can be written as:\\n```dp[i][j]``` = max value of ( ```dp[i][k-1] + nums[i-1] * nums[k] * nums[j+1] + dp[k+1][j]``` ) for all ```k``` where ```k``` goes from ```i``` to ```j```\\n\\nNote that ```dp[i][k-1]``` and ```dp[k+1][j]``` are independent subproblems of each other because balloon ```k``` exists when calculating either of them. Remember balloons in ```dp[i][k-1]``` and ```dp[k+1][j]``` get burst **before** balloon ```k``` so balloon ```k``` exists for them.\\nThis is precisely why we have defined balloon ```k``` to be the **last** balloon to burst between ```i``` and ```j``` and **not the first**. If we had defined balloon ```k``` to be the first, then balloons ```k-1``` and ```k+1``` will become adjacent and then ```dp[i][k-1]``` and ```dp[k+1][j]``` subproblems will overlap.\\n\\nIn order to avoid lot of checks for valid indices in the code, we can copy ```nums``` into another array and prepend and append a balloon of cost 1 as stated in the problem. Then we can calculate ```dp[i][j]``` on 1-based ```i``` and ```j``` so that ```dp[1][n]``` gives the answer.\\n\\n```\\npublic int maxCoins(int[] nums) {\\n    int n = nums.length;\\n    int[] A = new int[n + 2];\\n    for(int i = 1; i <= n; i++) A[i] = nums[i-1];\\n    A[0] = A[n + 1] = 1;\\n    int[][] dp = new int[n + 2][n + 2];\\n    for(int j = 1; j <= n; j++) {\\n        for(int i = j; i >= 1; i--) {\\n            for(int k = i; k <= j; k++) {\\n                dp[i][j] = Math.max(dp[i][j], dp[i][k-1] + dp[k+1][j] + A[i-1] * A[k] * A[j+1]);\\n            }\\n        }\\n    }\\n    return dp[1][n];\\n}\\n```\\n\\nFYI: In case you\\'re interested, code without creating another array:\\n\\n```\\npublic int maxCoins(int[] nums) {\\n    int n = nums.length;\\n    int[][] dp = new int[n][n];\\n    for(int j = 0; j < n; j++) {\\n        for(int i = j; i >= 0; i--) {\\n            for(int k = i; k <= j; k++) {\\n                dp[i][j] = Math.max(dp[i][j], (k == i ? 0 : dp[i][k-1]) + (k == j ? 0 : dp[k+1][j]) + (i == 0 ? 1 : nums[i-1]) * nums[k] * (j == n-1 ? 1 : nums[j+1]));\\n            }\\n        }\\n    }\\n    return n == 0 ? 0 : dp[0][n-1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```i```\n```j```\n```i-1```\n```j+1```\n```k```\n```i```\n```j```\n```dp[i][j]```\n```dp[i][j]```\n```dp[i][k-1] + nums[i-1] * nums[k] * nums[j+1] + dp[k+1][j]```\n```k```\n```k```\n```i```\n```j```\n```dp[i][k-1]```\n```dp[k+1][j]```\n```k```\n```dp[i][k-1]```\n```dp[k+1][j]```\n```k```\n```k```\n```k```\n```i```\n```j```\n```k```\n```k-1```\n```k+1```\n```dp[i][k-1]```\n```dp[k+1][j]```\n```nums```\n```dp[i][j]```\n```i```\n```j```\n```dp[1][n]```\n```\\npublic int maxCoins(int[] nums) {\\n    int n = nums.length;\\n    int[] A = new int[n + 2];\\n    for(int i = 1; i <= n; i++) A[i] = nums[i-1];\\n    A[0] = A[n + 1] = 1;\\n    int[][] dp = new int[n + 2][n + 2];\\n    for(int j = 1; j <= n; j++) {\\n        for(int i = j; i >= 1; i--) {\\n            for(int k = i; k <= j; k++) {\\n                dp[i][j] = Math.max(dp[i][j], dp[i][k-1] + dp[k+1][j] + A[i-1] * A[k] * A[j+1]);\\n            }\\n        }\\n    }\\n    return dp[1][n];\\n}\\n```\n```\\npublic int maxCoins(int[] nums) {\\n    int n = nums.length;\\n    int[][] dp = new int[n][n];\\n    for(int j = 0; j < n; j++) {\\n        for(int i = j; i >= 0; i--) {\\n            for(int k = i; k <= j; k++) {\\n                dp[i][j] = Math.max(dp[i][j], (k == i ? 0 : dp[i][k-1]) + (k == j ? 0 : dp[k+1][j]) + (i == 0 ? 1 : nums[i-1]) * nums[k] * (j == n-1 ? 1 : nums[j+1]));\\n            }\\n        }\\n    }\\n    return n == 0 ? 0 : dp[0][n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809177,
                "title": "explaination-video-simple-top-down-code-memoization-c-mcm-based",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500][500];\\n    int helper(vector<int>& nums,int i,int j){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n            int curr=nums[i-1]*nums[k]*nums[j+1];\\n            ans=max(ans,helper(nums,i,k-1)+helper(nums,k+1,j)+curr);\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,1,nums.size()-2);\\n    }\\n};\\n```\\n\\nBest Explaination Video\\nhttps://www.youtube.com/watch?v=KWPat-qNAGI",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500][500];\\n    int helper(vector<int>& nums,int i,int j){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n            int curr=nums[i-1]*nums[k]*nums[j+1];\\n            ans=max(ans,helper(nums,i,k-1)+helper(nums,k+1,j)+curr);\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(nums,1,nums.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76281,
                "title": "neat-java-solution",
                "content": "    public int maxCoins(int[] nums) {\\n        //DP: the result depends on the last burst balloon, which seprate the array into 2 subarray. \\n        //DP: by adding 1 to head and tail, DP[i,i]=0 and DP[i,i+2]=num[i]*num[i+1]*num[i+2]\\n        int n=nums.length+2;\\n        int[] newnums=new int[n];\\n        for(int i=0;i<n-2;i++){\\n            newnums[i+1]=nums[i];\\n        }\\n        newnums[0]=newnums[n-1]=1;\\n        int[][] DP=new int[n][n];\\n        for(int k=2;k<n;k++){\\n            for(int l=0;l+k<n;l++){\\n                int h=l+k;\\n                for(int m=l+1;m<h;m++){\\n                    DP[l][h]=Math.max(DP[l][h],newnums[l]*newnums[m]*newnums[h]+DP[l][m]+DP[m][h]);\\n                }\\n            }\\n        }\\n        return DP[0][n-1];\\n    }",
                "solutionTags": [],
                "code": "    public int maxCoins(int[] nums) {\\n        //DP: the result depends on the last burst balloon, which seprate the array into 2 subarray. \\n        //DP: by adding 1 to head and tail, DP[i,i]=0 and DP[i,i+2]=num[i]*num[i+1]*num[i+2]\\n        int n=nums.length+2;\\n        int[] newnums=new int[n];\\n        for(int i=0;i<n-2;i++){\\n            newnums[i+1]=nums[i];\\n        }\\n        newnums[0]=newnums[n-1]=1;\\n        int[][] DP=new int[n][n];\\n        for(int k=2;k<n;k++){\\n            for(int l=0;l+k<n;l++){\\n                int h=l+k;\\n                for(int m=l+1;m<h;m++){\\n                    DP[l][h]=Math.max(DP[l][h],newnums[l]*newnums[m]*newnums[h]+DP[l][m]+DP[m][h]);\\n                }\\n            }\\n        }\\n        return DP[0][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1659216,
                "title": "c-dp-solution-top-down-approach-w-explanation",
                "content": "We need to find the maximum possible coins we can earn by bursting sll the balloons in the array. \\n\\n* Clearly, the brute force approach would try all possible combinations of popping the balloons and sofirst we have n choices to select 1 to burst and then in the next step n-1 choices and so on and in the end we are left with the only balloon.\\n* We need to find a way to solve this problem for higher numbers. Intuitively, we would try separate the array by popping a particular balloon first so we\\'re left with the left & right parts of that element. So if we have ```nums = [3, 1, 5, 8, 7]``` and we try to pop balloon 4 first, would it make the 2 parts [3, 1] & [8, 7] results independent of each other. We cannot forget while calculating [3,1] that [8,9] exists. Why?\\n* Because even if we knew in [3,1] in the correct order, we still dont know the exact right neighbor of these elements, right neighbor could be 8 or 7 depending on which of those 2 is popped first.\\n* So we need to find a state of dp that could make these 2 parts independent of each other.\\n* So instead guessing which balloon to pop first we guess which balloon to pop last. \\n* That is, if ```nums =  [3, 1, 5, 8, 7]```  in this array let\\'s say  ```3``` was the last one to be popped and then we would know that the left subarray ```[3, 1]``` would always have it\\'s right element as 3 because it\\'s the last one to be popped and similarly the right subarray [4, 5] would always know it\\'s left element.\\n* So we\\'re going to define a state of dp in which ```dp[l][r]``` = The max no. of coins that can be earned by popping any of the elements in this range at last. \\n* Finally ```dp[1][n-1]``` will be our answer (After adding ```1``` to the beginning and end of the array, so each time we wouldn\\'t have to check for an out of bound exception).\\n* Now, this problem is similar to Matrix Chain Multiplication because, here the main question is how to chose to place the paranthesis. Suppose we have matrices 1, 2, 3, 4, k is the place where the separating paranthesis is placed. When k = 1 then (1) (2, 3, 4) is how the paranthesis are placed. Therefore cost of multiplying all matrices is cost of multiplying matrices frombeginning to k, + cost of multiplying matrices from k+1 to end + cost of multplying both the matrices together (matrix[beginning to k] * matrix[k+1 to end]).\\n* So ```total cost = dp[i][k] + dp[k+1][j] + nums[i-1]*nums[k]*nums[j]```.\\n\\n**Time Complexity :** O(n^3)\\n\\n**Space Complexity :** O(n^2)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) \\n    {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return solve(nums, 1, n-1, dp);\\n    }\\n    \\n    int solve(vector<int>& nums, int l, int r, vector<vector<int>> &dp){\\n        if(l >= r) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int ans = 0; \\n        \\n        for(int i = l; i<r; i++){\\n            int temp = solve(nums, l, i, dp) + solve(nums, i+1, r, dp) + nums[l-1]*nums[i]*nums[r];\\n            ans = max(ans, temp);\\n        }\\n        return dp[l][r] = ans;\\n    } \\n};\\n```\\n\\nIf you like my solution & explanation, please upvote my post :)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```nums = [3, 1, 5, 8, 7]```\n```nums =  [3, 1, 5, 8, 7]```\n```3```\n```[3, 1]```\n```dp[l][r]```\n```dp[1][n-1]```\n```1```\n```total cost = dp[i][k] + dp[k+1][j] + nums[i-1]*nums[k]*nums[j]```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) \\n    {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return solve(nums, 1, n-1, dp);\\n    }\\n    \\n    int solve(vector<int>& nums, int l, int r, vector<vector<int>> &dp){\\n        if(l >= r) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int ans = 0; \\n        \\n        for(int i = l; i<r; i++){\\n            int temp = solve(nums, l, i, dp) + solve(nums, i+1, r, dp) + nums[l-1]*nums[i]*nums[r];\\n            ans = max(ans, temp);\\n        }\\n        return dp[l][r] = ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473225,
                "title": "mcm-little-variation-aditya-verma-style-c",
                "content": "class Solution {\\npublic:\\n    \\n     int dp[502][502];\\n    \\n    int solve_memo(vector<int>&arr,int i,int j)\\n    {\\n        // base condition \\n        if(i>=j) return 0;\\n        \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans =INT_MIN;\\n        for(int k=i;k<j;k++)\\n        {\\n            int tempAns = solve_memo(arr,i,k)+solve_memo(arr,k+1,j) + (arr[i-1]*arr[k]*arr[j]);\\n            \\n            ans=max(ans,tempAns);\\n        }\\n        return dp[i][j]=ans;\\n        \\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        memset(dp,-1,sizeof(dp));\\n        return solve_memo(nums,1,nums.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n     int dp[502][502];\\n    \\n    int solve_memo(vector<int>&arr,int i,int j)\\n    {\\n        // base condition \\n        if(i>=j) return 0;\\n        \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans =INT_MIN;\\n        for(int k=i;k<j;k++)\\n        {\\n            int tempAns = solve_memo(arr,i,k)+solve_memo(arr,k+1,j) + (arr[i-1]*arr[k]*arr[j]);\\n            \\n            ans=max(ans,tempAns);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1339904,
                "title": "c-aditya-verma-solution",
                "content": "If you are thinking why the movement is from i to k-1 and k+1 to j it is because we are consuming an element of an array rather than adding a bracket or a paranthesis\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[502][502];\\n    int help(vector<int>&nums,int i,int j)\\n    {\\n        if(i>j)\\n            return 0;\\n            if(dp[i][j]!=-1)\\n                return dp[i][j];\\n        int maxi=INT_MIN;\\n        \\n        for(int k=i;k<=j;k++)\\n        {\\n            int temp=help(nums,i,k-1)+help(nums,k+1,j);\\n            int l=1,r=1;\\n            if(i-1>=0)\\n                l=nums[i-1];\\n            if(j+1<nums.size())\\n                r=nums[j+1];\\n            temp+=l*r*nums[k];\\n            maxi=max(maxi,temp);\\n        }\\n        return dp[i][j]=maxi;\\n        \\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        int n=nums.size();\\n        return help(nums,0,n-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[502][502];\\n    int help(vector<int>&nums,int i,int j)\\n    {\\n        if(i>j)\\n            return 0;\\n            if(dp[i][j]!=-1)\\n                return dp[i][j];\\n        int maxi=INT_MIN;\\n        \\n        for(int k=i;k<=j;k++)\\n        {\\n            int temp=help(nums,i,k-1)+help(nums,k+1,j);\\n            int l=1,r=1;\\n            if(i-1>=0)\\n                l=nums[i-1];\\n            if(j+1<nums.size())\\n                r=nums[j+1];\\n            temp+=l*r*nums[k];\\n            maxi=max(maxi,temp);\\n        }\\n        return dp[i][j]=maxi;\\n        \\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        int n=nums.size();\\n        return help(nums,0,n-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971179,
                "title": "c-dp-28ms-solution",
                "content": "We define window size as `gap` in the code, representing the value of `right-left`. We also define dp as a 2d vector, `dp[left][right]` is the max cost of `arr[left]*arr[mid]*arr[right]` where `mid` goes from `left+1` to `right-1`. `dp[0][len-1]` is the returned value.\\n\\nFor example, given `nums` as {1,6,4,2,9}, if we select `1` and `9` as left and right index, `4` as middle index, max cost is `1*4*9 + dp[0][2] + dp[2][4]`.\\n\\nFirst we loop over `gap` from `2` to `len-1`. Given `gap`, we loop over `left` from `0` to `len-gap`. Given `gap` and `left`, `right` is just `left+gap`. Then we loop over `mid` from `left+1` to `right-1`. For each `mid`, `cur` is defined as `dp[left][mid]+dp[mid][right]+arr[left]*arr[mid]*arr[right]`. We assign the max value of `cur` to `dp[left][right]`.\\n\\n**If it helps, plz upvote!**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        int len = n+2;\\n        vector<int> arr = {1};\\n        for(auto& num : nums)\\n            arr.push_back(num);\\n        arr.push_back(1);\\n        \\n        vector<vector<int>> dp(len, vector<int>(len, 0));\\n        \\n        for(int gap = 2; gap < len; gap++) {\\n            for(int left = 0; left < len-gap; left++) {\\n                int right = left+gap;\\n                int cur = 0;\\n                for(int mid = left+1; mid < right; mid++) {\\n                    cur = max(cur, dp[left][mid]+dp[mid][right]+arr[left]*arr[mid]*arr[right]);\\n                }\\n                dp[left][right] = cur;\\n            }\\n        }\\n        return dp[0][len-1];\\n    }\\n};\\n//IO\\nint _IO=[](){\\n\\tios::sync_with_stdio(0);\\n\\tcin.tie(0); //cout.tie(0);\\n\\treturn 0;\\n}();\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        int len = n+2;\\n        vector<int> arr = {1};\\n        for(auto& num : nums)\\n            arr.push_back(num);\\n        arr.push_back(1);\\n        \\n        vector<vector<int>> dp(len, vector<int>(len, 0));\\n        \\n        for(int gap = 2; gap < len; gap++) {\\n            for(int left = 0; left < len-gap; left++) {\\n                int right = left+gap;\\n                int cur = 0;\\n                for(int mid = left+1; mid < right; mid++) {\\n                    cur = max(cur, dp[left][mid]+dp[mid][right]+arr[left]*arr[mid]*arr[right]);\\n                }\\n                dp[left][right] = cur;\\n            }\\n        }\\n        return dp[0][len-1];\\n    }\\n};\\n//IO\\nint _IO=[](){\\n\\tios::sync_with_stdio(0);\\n\\tcin.tie(0); //cout.tie(0);\\n\\treturn 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 888389,
                "title": "c-recursion-with-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500][500] = {0};\\n    int func(int start, int end, vector<int>& nums){\\n        if(start > end)return 0;\\n        if(dp[start][end] != 0)return dp[start][end];\\n        int ret = 0;\\n        int left = 1, right = 1;\\n        if(start - 1 >= 0)left = nums[start-1];\\n        if(end + 1 < nums.size()) right = nums[end + 1];\\n        for(int i=start; i<=end; i++){\\n            ret = max(ret, nums[i] * left * right + func(start, i-1, nums) + func(i+1, end, nums));\\n        }\\n        dp[start][end] = ret;\\n        return ret;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        if(nums.size() == 0)return 0;\\n        return func(0,nums.size()-1, nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500][500] = {0};\\n    int func(int start, int end, vector<int>& nums){\\n        if(start > end)return 0;\\n        if(dp[start][end] != 0)return dp[start][end];\\n        int ret = 0;\\n        int left = 1, right = 1;\\n        if(start - 1 >= 0)left = nums[start-1];\\n        if(end + 1 < nums.size()) right = nums[end + 1];\\n        for(int i=start; i<=end; i++){\\n            ret = max(ret, nums[i] * left * right + func(start, i-1, nums) + func(i+1, end, nums));\\n        }\\n        dp[start][end] = ret;\\n        return ret;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        if(nums.size() == 0)return 0;\\n        return func(0,nums.size()-1, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765478,
                "title": "c-easy-recursive-solution-with-explnation",
                "content": "This question is a variation of matrix multiplication problem. In that problem we need to find the minimum cost of multiplying the matrices. In this we have to found the maximum instead of minimum.. First, we need to add one element in left side and right side of the array. Now we need to find the maximum cost by moving K from i to j.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n        vector<int> v(nums.size()+2,1);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[i+1]=nums[i];\\n        }\\n        vector<vector<int>> dp(v.size(),vector<int> (v.size(),-1));\\n        return helper(v,1,v.size()-1,dp);\\n    }\\n    \\n    int helper(vector<int> &v, int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j]>=0)\\n            return dp[i][j];\\n        int cost=INT_MIN;\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            cost=max(cost, helper(v,i,k,dp)+helper(v,k+1,j,dp)+ v[i-1]*v[k]*v[j]);\\n        }\\n        dp[i][j]=cost;\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        if(nums.size()==0)\\n            return 0;\\n        vector<int> v(nums.size()+2,1);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[i+1]=nums[i];\\n        }\\n        vector<vector<int>> dp(v.size(),vector<int> (v.size(),-1));\\n        return helper(v,1,v.size()-1,dp);\\n    }\\n    \\n    int helper(vector<int> &v, int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j]>=0)\\n            return dp[i][j];\\n        int cost=INT_MIN;\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            cost=max(cost, helper(v,i,k,dp)+helper(v,k+1,j,dp)+ v[i-1]*v[k]*v[j]);\\n        }\\n        dp[i][j]=cost;\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670467,
                "title": "c-dp-solution-o-n-3",
                "content": "dp[i][j] represents the maximum coins we get after we burst all the balloons from i to j.\\nLet Kth is the last balloon to be burst in thr interval [i,j] then,\\ndp[i][j] = maximum value of bursting all the balloon on the left side of \\'K\\' + maximum value of bursting all the balloon on the right side of \\'K\\' + bursting balloon \\'K\\' when left side and right side are gone.\\ndp[i][j] = dp[i][K-1] + (A[i-1] * A[K] * A[j+1]) + dp[K+1][j]\\n```\\nint maxCoins(vector<int>& A) {\\n\\tint n = A.size();\\n\\tA.insert(A.begin(), 1);\\n\\tA.push_back(1);\\n\\tvector<vector<int>> dp(n+2, vector<int>(n+2, 0));\\n\\tfor(int len = 1; len <= n; len++) {\\n\\t\\tfor(int start = 1; start <= n-len+1; start++) {\\n\\t\\t\\tint end = start + len -1;\\n\\t\\t\\tfor(int k = start; k <= end; k++) {\\n\\t\\t\\t\\tdp[start][end] = max(dp[start][end], dp[start][k-1] + (A[start-1] * A[k] * A[end+1]) + dp[k+1][end]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n];\\n}\\n```\\nRecursive Solution\\n```\\nint maxCoins(vector<int>& A) {\\n\\tint n = A.size();\\n\\tA.insert(A.begin(), 1);\\n\\tA.push_back(1);\\n\\tvector<vector<int>> dp(n+2, vector<int>(n+2, -1));\\n\\treturn helper(A, dp, 1, n);\\n}\\n\\nint helper(vector<int>& A, vector<vector<int>>& dp, int start, int end) {\\n\\tif (start > end) return 0;\\n\\tif (dp[start][end] != -1) return dp[start][end];\\n\\tfor (int k = start; k <= end; k++)\\n\\t\\tdp[start][end] = max(dp[start][end], helper(A, dp, start, k-1) + helper(A, dp, k+1, end) + A[start-1] * A[k] * A[end+1]);\\n\\treturn dp[start][end];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint maxCoins(vector<int>& A) {\\n\\tint n = A.size();\\n\\tA.insert(A.begin(), 1);\\n\\tA.push_back(1);\\n\\tvector<vector<int>> dp(n+2, vector<int>(n+2, 0));\\n\\tfor(int len = 1; len <= n; len++) {\\n\\t\\tfor(int start = 1; start <= n-len+1; start++) {\\n\\t\\t\\tint end = start + len -1;\\n\\t\\t\\tfor(int k = start; k <= end; k++) {\\n\\t\\t\\t\\tdp[start][end] = max(dp[start][end], dp[start][k-1] + (A[start-1] * A[k] * A[end+1]) + dp[k+1][end]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n];\\n}\\n```\n```\\nint maxCoins(vector<int>& A) {\\n\\tint n = A.size();\\n\\tA.insert(A.begin(), 1);\\n\\tA.push_back(1);\\n\\tvector<vector<int>> dp(n+2, vector<int>(n+2, -1));\\n\\treturn helper(A, dp, 1, n);\\n}\\n\\nint helper(vector<int>& A, vector<vector<int>>& dp, int start, int end) {\\n\\tif (start > end) return 0;\\n\\tif (dp[start][end] != -1) return dp[start][end];\\n\\tfor (int k = start; k <= end; k++)\\n\\t\\tdp[start][end] = max(dp[start][end], helper(A, dp, start, k-1) + helper(A, dp, k+1, end) + A[start-1] * A[k] * A[end+1]);\\n\\treturn dp[start][end];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389338,
                "title": "python3-complete-thinking-with-explanation-o-n-to-o-n-3",
                "content": "> **I. Brute-force:** try every balloon on by one, then solve the sub problem recursively.\\n>\\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            k, dp = \"1\"*len(nums), {}\\n            nis = [(i,c) for i, c in enumerate(nums)]\\n\\n            def _max(sub_nis, k, dp):\\n                if not sub_nis:\\n                    return 0\\n                if k in dp:\\n                    return dp[k]\\n                x = 0\\n                for i in range(len(sub_nis)):\\n                    left, it, right = _coin(sub_nis, i-1), _coin(sub_nis, i), _coin(sub_nis, i+1)\\n                    sub = sub_nis[:i] + sub_nis[i+1:]\\n                    x = max(x, left[1]*it[1]*right[1]+_max(sub, k[:it[0]]+\"0\"+k[it[0]+1:], dp))\\n                dp[k] = x\\n                return x\\n\\n            def _coin(nis, i):\\n                if i < 0 or i >= len(nis):\\n                    return (-1, 1)\\n                return nis[i]\\n\\n            x = _max(nis, k, dp)\\n            return x\\n```\\n>\\n> recursive expresion of this brutal idea is:  \\n\\n![image](https://assets.leetcode.com/users/pizzacrystal/image_1569314831.png)\\n\\n> easy to figure out its time complexity is $O(n!)$, hereby it no doubt exceeds time limitation.  \\n\\n> **II. Optimized Brute-force:** omits array slices by delaying calculation until getting valid $X_{right}$.\\n>\\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            if not nums:\\n                return 0\\n            k, dp = \"1\"*len(nums), {}\\n\\n            def _burst(nums, k, dp):\\n                if k in dp:\\n                    return dp[k]\\n                l2left, left, _max, _len, j = None, 1, 0, len(nums), -1\\n                for i in range(_len):\\n                    if k[i] == \\'0\\':\\n                        continue\\n                    if l2left is not None:\\n                        _max = max(_max, l2left*left*nums[i]+_burst(nums, k[:j]+\"0\"+k[j+1:], dp))\\n                    l2left, left, j = left, nums[i], i\\n                else:\\n                    if j != -1:\\n                        _max = max(_max, l2left*left+_burst(nums, k[:j]+\"0\"+k[j+1:], dp))\\n                dp[k] = _max\\n                return _max\\n\\n            x = _burst(nums, k, dp)\\n            return x\\n```\\n>\\n> time complexity is still $O(n!)$, though this implementation has higher performance.  \\n\\n> **III. DP (top down):** thinking of selecting the first balloon is inevitably TLE, which prompts us to address it in another way -- consider the case of picking the last one. if we knew $X$ should be picked in the end, we get the transition equation as below:  \\n\\n![image](https://assets.leetcode.com/users/pizzacrystal/image_1569314893.png)\\n\\n> apparently, we need to examine every $X$ in $A$, but it is remarkably faster than brute-force method because of \"devide and conquer\". As for memoization, we could use a 2-D array $dp[i][j]$ to cache results of left and right sub arrays. Here is the implementation:  \\n>\\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            if not nums:\\n                return 0\\n            _len = len(nums)\\n            dp = [[-1]*_len for _ in range(_len)]\\n\\n            def _burst(left, right, b, e):\\n                if e < b:\\n                    return 0\\n                if dp[b][e] != -1:\\n                    return dp[b][e]\\n                _max = 0\\n                if b == e:\\n                    dp[b][e] = left * nums[b] * right\\n                else:\\n                    for i in range(b, e+1):\\n                        last = left * nums[i] * right\\n                        lhalf = _burst(left, nums[i], b, i-1)\\n                        rhalf = _burst(nums[i], right, i+1, e)\\n                        _max = max(_max, last+lhalf+rhalf)\\n                    dp[b][e] = _max\\n                return dp[b][e]\\n\\n            return _burst(1, 1, 0, _len-1)\\n```\\n>\\n> recursion tree is in need to analyse time complexity, omitted here.  \\n\\n> **IV. DP (bottom up):** By translating recursion cycles to for-loops, we get the final solution.\\n>\\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            if not nums:\\n                return 0\\n            nums = [1] + nums + [1]\\n            _len = len(nums)\\n            dp = [[0]*_len for _ in range(_len)]\\n\\n            for l in range(1, _len+1):\\n                for i in range(1, _len-l):\\n                    j = i + l - 1\\n                    for k in range(i, j+1):\\n                        dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j])\\n            return dp[1][_len-2]\\n```\\n>\\n> the inner loop calculates coins of specific array, while the outer two loops examine all sub arrays that are of length $1$ to length $n$, thereby we get correct result finally. Time complexity is $O(n^3)$, which is overwhelming compared to $O(n!)$.\\n",
                "solutionTags": [],
                "code": "```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            k, dp = \"1\"*len(nums), {}\\n            nis = [(i,c) for i, c in enumerate(nums)]\\n\\n            def _max(sub_nis, k, dp):\\n                if not sub_nis:\\n                    return 0\\n                if k in dp:\\n                    return dp[k]\\n                x = 0\\n                for i in range(len(sub_nis)):\\n                    left, it, right = _coin(sub_nis, i-1), _coin(sub_nis, i), _coin(sub_nis, i+1)\\n                    sub = sub_nis[:i] + sub_nis[i+1:]\\n                    x = max(x, left[1]*it[1]*right[1]+_max(sub, k[:it[0]]+\"0\"+k[it[0]+1:], dp))\\n                dp[k] = x\\n                return x\\n\\n            def _coin(nis, i):\\n                if i < 0 or i >= len(nis):\\n                    return (-1, 1)\\n                return nis[i]\\n\\n            x = _max(nis, k, dp)\\n            return x\\n```\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            if not nums:\\n                return 0\\n            k, dp = \"1\"*len(nums), {}\\n\\n            def _burst(nums, k, dp):\\n                if k in dp:\\n                    return dp[k]\\n                l2left, left, _max, _len, j = None, 1, 0, len(nums), -1\\n                for i in range(_len):\\n                    if k[i] == \\'0\\':\\n                        continue\\n                    if l2left is not None:\\n                        _max = max(_max, l2left*left*nums[i]+_burst(nums, k[:j]+\"0\"+k[j+1:], dp))\\n                    l2left, left, j = left, nums[i], i\\n                else:\\n                    if j != -1:\\n                        _max = max(_max, l2left*left+_burst(nums, k[:j]+\"0\"+k[j+1:], dp))\\n                dp[k] = _max\\n                return _max\\n\\n            x = _burst(nums, k, dp)\\n            return x\\n```\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            if not nums:\\n                return 0\\n            _len = len(nums)\\n            dp = [[-1]*_len for _ in range(_len)]\\n\\n            def _burst(left, right, b, e):\\n                if e < b:\\n                    return 0\\n                if dp[b][e] != -1:\\n                    return dp[b][e]\\n                _max = 0\\n                if b == e:\\n                    dp[b][e] = left * nums[b] * right\\n                else:\\n                    for i in range(b, e+1):\\n                        last = left * nums[i] * right\\n                        lhalf = _burst(left, nums[i], b, i-1)\\n                        rhalf = _burst(nums[i], right, i+1, e)\\n                        _max = max(_max, last+lhalf+rhalf)\\n                    dp[b][e] = _max\\n                return dp[b][e]\\n\\n            return _burst(1, 1, 0, _len-1)\\n```\n```python\\n    class Solution:\\n        def maxCoins(self, nums) -> int:\\n            if not nums:\\n                return 0\\n            nums = [1] + nums + [1]\\n            _len = len(nums)\\n            dp = [[0]*_len for _ in range(_len)]\\n\\n            for l in range(1, _len+1):\\n                for i in range(1, _len-l):\\n                    j = i + l - 1\\n                    for k in range(i, j+1):\\n                        dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j])\\n            return dp[1][_len-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343337,
                "title": "python-dp-solutions-two-implementation-to-help-you-understand",
                "content": "I understand how to solve the problem by reading the most 2 upvoted post.\\nI write two diffenrent code to make sure I got the idea.\\nThe only difference is the defination of the dp[i][j]\\n```python\\n    # dp[i][j] means the maximum coins we get after we burst all the balloons between i and j in the original array.\\n    # between i and j means not include i and j, which means j-i >= 2 (let gap = j-i >=2)\\n    # DP: dp[i][j] = max(nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])(k in (i,j)]   Note: i<k<j\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n        \\n        for gap in range(2,len(nums)):\\n            for i in range(0,len(nums)-gap):\\n                j = i+gap\\n                for k in range(i+1,j):\\n                    dp[i][j] = max(dp[i][j],nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\\n                    \\n        return dp[0][len(nums)-1]\\n\\t\\t\\n\\t# Another implementation\\t\\n\\tdef maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n\\t\\t\\n        for i in range(len(nums)-1,-1,-1):\\n            for j in range(i+2,len(nums)):\\n                for k in range(i+1,j):\\n                    dp[i][j] = max(dp[i][j],nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\\n        \\n        return dp[0][len(nums)-1]\\n\\n```\\n\\n```python\\n    # dp[i][j] means the maximum coins we get after we burst all the balloons between i and j in the original array.\\n    # between i and j means include i and j, j-i >=0  (let gap = j-i >=0)\\n\\t# DP: dp[i][j] = max(nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j])(k in [i,j])  Note: i<=k<=j\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n        \\n        for gap in range(0,len(nums)-2):\\n            for i in range(1,len(nums)-1-gap):\\n                j = i+gap\\n                for k in range(i,j+1):\\n                    a = dp[i][k-1] if k>i else 0\\n                    b = dp[k+1][j] if k<j else 0\\n                    dp[i][j] = max(dp[i][j],nums[i-1]*nums[k]*nums[j+1] + a + b)\\n                    \\n        return dp[1][len(nums)-2]\\n\\t\\t\\n\\t# Another implementation\\t\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n        \\n        for i in range(len(nums)-2,0,-1):\\n            for j in range(i,len(nums)-1):\\n                for k in range(i,j+1):\\n                    a = dp[i][k-1] if k>i else 0\\n                    b = dp[k+1][j] if k<j else 0\\n                    dp[i][j] = max(dp[i][j],nums[i-1]*nums[k]*nums[j+1] + a + b)\\n                    \\n        return dp[1][len(nums)-2]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    # dp[i][j] means the maximum coins we get after we burst all the balloons between i and j in the original array.\\n    # between i and j means not include i and j, which means j-i >= 2 (let gap = j-i >=2)\\n    # DP: dp[i][j] = max(nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])(k in (i,j)]   Note: i<k<j\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n        \\n        for gap in range(2,len(nums)):\\n            for i in range(0,len(nums)-gap):\\n                j = i+gap\\n                for k in range(i+1,j):\\n                    dp[i][j] = max(dp[i][j],nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\\n                    \\n        return dp[0][len(nums)-1]\\n\\t\\t\\n\\t# Another implementation\\t\\n\\tdef maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n\\t\\t\\n        for i in range(len(nums)-1,-1,-1):\\n            for j in range(i+2,len(nums)):\\n                for k in range(i+1,j):\\n                    dp[i][j] = max(dp[i][j],nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\\n        \\n        return dp[0][len(nums)-1]\\n\\n```\n```python\\n    # dp[i][j] means the maximum coins we get after we burst all the balloons between i and j in the original array.\\n    # between i and j means include i and j, j-i >=0  (let gap = j-i >=0)\\n\\t# DP: dp[i][j] = max(nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j])(k in [i,j])  Note: i<=k<=j\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n        \\n        for gap in range(0,len(nums)-2):\\n            for i in range(1,len(nums)-1-gap):\\n                j = i+gap\\n                for k in range(i,j+1):\\n                    a = dp[i][k-1] if k>i else 0\\n                    b = dp[k+1][j] if k<j else 0\\n                    dp[i][j] = max(dp[i][j],nums[i-1]*nums[k]*nums[j+1] + a + b)\\n                    \\n        return dp[1][len(nums)-2]\\n\\t\\t\\n\\t# Another implementation\\t\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        dp = [[0]*len(nums) for i in range(len(nums))]\\n        \\n        for i in range(len(nums)-2,0,-1):\\n            for j in range(i,len(nums)-1):\\n                for k in range(i,j+1):\\n                    a = dp[i][k-1] if k>i else 0\\n                    b = dp[k+1][j] if k<j else 0\\n                    dp[i][j] = max(dp[i][j],nums[i-1]*nums[k]*nums[j+1] + a + b)\\n                    \\n        return dp[1][len(nums)-2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 298013,
                "title": "this-is-a-textbook-example-question-variation-clrs-15-2",
                "content": "\\n```\\n/*\\nThis question is the variation of the textbook question 15.2 how to minimize the sum of mutiplication.\\nWhich is a classic dp problem.\\n\\nhere is how to maxmize the sum of multiplication \\n\\nthe relation ship is :\\ndp[i][j]= min{dp[i][k-1]+dp[k+1][j]+ nums[i-1]*nums[k]*nums[j+1]} \\nwhere k is{i,i+1,,,,j} and if(i-1)<0 nums[i-1]=1,if(j+1>=nums.length)(nums[j+1]=1)\\nwe try all the dp[i][j] length from 1 to nums.length;\\nand return the dp[0][nums.length-1]\\n\\nthe key loop is\\nfor(int len=0; len<nums.lenth; len++){\\n    for(int start=0; start<=nums.length-len; start++)\\n        end =start+len-1;\\n        for(int k=start; k<=end; k++)\\n        dp[start][end]= Math.min(dp[start][end], dp[start][k-1]+dp[k+1][end]+nums[start-1]*nums[k]*nums[end+1]);\\n}\\nso this is a n^3 algrithm\\n*/\\n\\n\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n    if (nums == null || nums.length == 0) return 0;\\n    \\n    int[][] dp = new int[nums.length][nums.length];\\n    for (int len = 1; len <= nums.length; len++) {\\n        for (int start = 0; start <= nums.length - len; start++) {\\n            int end = start + len - 1;\\n            for (int i = start; i <= end; i++) {\\n                int pre= start-1<0? 1: nums[start-1];\\n                int next= end+1>=nums.length? 1: nums[end+1];\\n                int coins = nums[i] * pre * next;\\n                coins += i != start ? dp[start][i - 1] : 0; // If not first one, we can add subrange on its left.\\n                coins += i != end ? dp[i + 1][end] : 0; // If not last one, we can add subrange on its right\\n                dp[start][end] = Math.max(dp[start][end], coins);\\n            }\\n        }\\n    }\\n    return dp[0][nums.length - 1];\\n }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nThis question is the variation of the textbook question 15.2 how to minimize the sum of mutiplication.\\nWhich is a classic dp problem.\\n\\nhere is how to maxmize the sum of multiplication \\n\\nthe relation ship is :\\ndp[i][j]= min{dp[i][k-1]+dp[k+1][j]+ nums[i-1]*nums[k]*nums[j+1]} \\nwhere k is{i,i+1,,,,j} and if(i-1)<0 nums[i-1]=1,if(j+1>=nums.length)(nums[j+1]=1)\\nwe try all the dp[i][j] length from 1 to nums.length;\\nand return the dp[0][nums.length-1]\\n\\nthe key loop is\\nfor(int len=0; len<nums.lenth; len++){\\n    for(int start=0; start<=nums.length-len; start++)\\n        end =start+len-1;\\n        for(int k=start; k<=end; k++)\\n        dp[start][end]= Math.min(dp[start][end], dp[start][k-1]+dp[k+1][end]+nums[start-1]*nums[k]*nums[end+1]);\\n}\\nso this is a n^3 algrithm\\n*/\\n\\n\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n    if (nums == null || nums.length == 0) return 0;\\n    \\n    int[][] dp = new int[nums.length][nums.length];\\n    for (int len = 1; len <= nums.length; len++) {\\n        for (int start = 0; start <= nums.length - len; start++) {\\n            int end = start + len - 1;\\n            for (int i = start; i <= end; i++) {\\n                int pre= start-1<0? 1: nums[start-1];\\n                int next= end+1>=nums.length? 1: nums[end+1];\\n                int coins = nums[i] * pre * next;\\n                coins += i != start ? dp[start][i - 1] : 0; // If not first one, we can add subrange on its left.\\n                coins += i != end ? dp[i + 1][end] : 0; // If not last one, we can add subrange on its right\\n                dp[start][end] = Math.max(dp[start][end], coins);\\n            }\\n        }\\n    }\\n    return dp[0][nums.length - 1];\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057990,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n       int n=nums.size();\\n       nums.insert(nums.begin(), 1);\\n       nums.push_back(1);\\n       vector<vector<int>> dp(n+2, vector<int>(n+2, 0));\\n       for(int l=1;l<=n;l++) {\\n           for(int i=1;i<=n-l+1;i++) {\\n               int j=i+l-1;\\n               for(int k=i;k<=j;k++)\\n               {\\n                   int cost=nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j];\\n                   dp[i][j]=max(dp[i][j], cost);\\n               }\\n           }\\n       }\\n       return dp[1][n];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n       int n=nums.size();\\n       nums.insert(nums.begin(), 1);\\n       nums.push_back(1);\\n       vector<vector<int>> dp(n+2, vector<int>(n+2, 0));\\n       for(int l=1;l<=n;l++) {\\n           for(int i=1;i<=n-l+1;i++) {\\n               int j=i+l-1;\\n               for(int k=i;k<=j;k++)\\n               {\\n                   int cost=nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j];\\n                   dp[i][j]=max(dp[i][j], cost);\\n               }\\n           }\\n       }\\n       return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075544,
                "title": "c-clean-code-all-approaches",
                "content": "```\\n//Recursive code:\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<int>& nums){\\n        if(i>j)\\n            return 0;\\n        int maxi = INT_MIN;\\n        for(int k = i; k<=j; k++){\\n            int cost = nums[i-1]*nums[k]*nums[j+1] + solve(i, k-1, nums) + solve(k+1, j, nums);\\n            maxi = max(maxi, cost);\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        \\n        return solve(1, n, nums);\\n    }\\n};\\n\\n\\n//Memoization [Accepted]:\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<int>& nums, vector<vector<int>>& memo){\\n        if(i>j)\\n            return 0;\\n        if(memo[i][j]!=-1){\\n            return memo[i][j];\\n        }\\n        int maxi = INT_MIN;\\n        for(int k = i; k<=j; k++){\\n            int cost = nums[i-1]*nums[k]*nums[j+1] + solve(i, k-1, nums, memo) + solve(k+1, j, nums, memo);\\n            maxi = max(maxi, cost);\\n        }\\n        \\n        return memo[i][j] = maxi;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        vector<vector<int>> memo(n+1, vector<int> (n+1, -1));\\n        return solve(1, n, nums, memo);\\n    }\\n};\\n\\n\\n//Tabulation DP[Accepted]:\\nclass Solution {\\npublic:\\n   \\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        vector<vector<int>> dp(n+2, vector<int> (n+2, 0));\\n        \\n        for(int i= n; i>=1; i--){\\n            for(int j = 1; j<=n; j++){\\n                if(i>j) continue;\\n                int maxi = INT_MIN;\\n                for(int k = i; k<=j; k++){\\n                    int cost = nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j];\\n                    maxi = max(maxi, cost);\\n                }\\n\\n                dp[i][j] = maxi;\\n            }\\n                \\n        }\\n        \\n        return dp[1][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n//Recursive code:\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<int>& nums){\\n        if(i>j)\\n            return 0;\\n        int maxi = INT_MIN;\\n        for(int k = i; k<=j; k++){\\n            int cost = nums[i-1]*nums[k]*nums[j+1] + solve(i, k-1, nums) + solve(k+1, j, nums);\\n            maxi = max(maxi, cost);\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        \\n        return solve(1, n, nums);\\n    }\\n};\\n\\n\\n//Memoization [Accepted]:\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<int>& nums, vector<vector<int>>& memo){\\n        if(i>j)\\n            return 0;\\n        if(memo[i][j]!=-1){\\n            return memo[i][j];\\n        }\\n        int maxi = INT_MIN;\\n        for(int k = i; k<=j; k++){\\n            int cost = nums[i-1]*nums[k]*nums[j+1] + solve(i, k-1, nums, memo) + solve(k+1, j, nums, memo);\\n            maxi = max(maxi, cost);\\n        }\\n        \\n        return memo[i][j] = maxi;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        vector<vector<int>> memo(n+1, vector<int> (n+1, -1));\\n        return solve(1, n, nums, memo);\\n    }\\n};\\n\\n\\n//Tabulation DP[Accepted]:\\nclass Solution {\\npublic:\\n   \\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        vector<vector<int>> dp(n+2, vector<int> (n+2, 0));\\n        \\n        for(int i= n; i>=1; i--){\\n            for(int j = 1; j<=n; j++){\\n                if(i>j) continue;\\n                int maxi = INT_MIN;\\n                for(int k = i; k<=j; k++){\\n                    int cost = nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j];\\n                    maxi = max(maxi, cost);\\n                }\\n\\n                dp[i][j] = maxi;\\n            }\\n                \\n        }\\n        \\n        return dp[1][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662243,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, nums):\\n        nums, N = [1] + nums + [1], len(nums) + 2 #array with 1,1 balloons at the end and length as N\\n        dp = [[0] * N for _ in range(N)] # table full of zeros\\n        \\n        for left in range(N - 2, -1, -1):\\n            for right in range(left + 2, N):\\n                dp[left][right] = max(nums[left]*nums[i]*nums[right] + dp[left][i] + dp[i][right] for i in range(left + 1, right))\\n        \\n        return dp[0][N-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums):\\n        nums, N = [1] + nums + [1], len(nums) + 2 #array with 1,1 balloons at the end and length as N\\n        dp = [[0] * N for _ in range(N)] # table full of zeros\\n        \\n        for left in range(N - 2, -1, -1):\\n            for right in range(left + 2, N):\\n                dp[left][right] = max(nums[left]*nums[i]*nums[right] + dp[left][i] + dp[i][right] for i in range(left + 1, right))\\n        \\n        return dp[0][N-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661662,
                "title": "java-easy-solution-done-in-mcm-dp",
                "content": "```\\nHAPPY NEW YEAR TO MY LEETCODE FAMILY\\n\\nso this problem can be solved using MCM but a small trick there if u start busting the balloon  from the very start then it will so happen that every one will be dependent on the other  say if u burst 5 first then 1*5*8 and the 1 which will be depenedent on the other sub problem that is 8*1*3 so to store it in dp is pretty impossible so we start from bursting last by bursting last i mean \\nsuppose u have 3 1 5 8\\nyou bursterd 8 last the what will the subproblems (3 1 5)+(empty)+8*1*1\\nyou then bursted 3 before busting 8 which result into (3*1*8)+(empty)+(1 5)\\nyou then bursted 5 so (5*3*8)+empty+(1)\\nand then you bursted 1 so u get 1*3*5+empty +emty \\nadd all u will get 167\\nthank you for reading my logic i wish u like the way i wrote this if u have any doubt smash it on comment section i have attached the code for clarity\\n```\\n\\n\\n```\\n\\n\\nclass Solution \\n{\\n    public static int mcm(int[] nums,int i,int j,int n,int dp[][])\\n    {\\n        if(i>j)\\n        {\\n           return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int left=i-1>=0?nums[i-1]:1;\\n        int right=j+1<n?nums[j+1]:1;\\n        \\n        int max=0;        \\n       \\n        for(int k=i;k<=j;k++)\\n        {\\n            max=Math.max(left*nums[k]*right+mcm(nums,i,k-1,n,dp)+mcm(nums,k+1,j,n,dp),max);\\n        }\\n        return dp[i][j]=max;\\n    }\\n    public int maxCoins(int[] nums) \\n    {\\n        int n=nums.length;\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return mcm(nums,0,nums.length-1,n,dp);\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n**pls upvote which motivates me to write more for my family**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nHAPPY NEW YEAR TO MY LEETCODE FAMILY\\n\\nso this problem can be solved using MCM but a small trick there if u start busting the balloon  from the very start then it will so happen that every one will be dependent on the other  say if u burst 5 first then 1*5*8 and the 1 which will be depenedent on the other sub problem that is 8*1*3 so to store it in dp is pretty impossible so we start from bursting last by bursting last i mean \\nsuppose u have 3 1 5 8\\nyou bursterd 8 last the what will the subproblems (3 1 5)+(empty)+8*1*1\\nyou then bursted 3 before busting 8 which result into (3*1*8)+(empty)+(1 5)\\nyou then bursted 5 so (5*3*8)+empty+(1)\\nand then you bursted 1 so u get 1*3*5+empty +emty \\nadd all u will get 167\\nthank you for reading my logic i wish u like the way i wrote this if u have any doubt smash it on comment section i have attached the code for clarity\\n```\n```\\n\\n\\nclass Solution \\n{\\n    public static int mcm(int[] nums,int i,int j,int n,int dp[][])\\n    {\\n        if(i>j)\\n        {\\n           return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int left=i-1>=0?nums[i-1]:1;\\n        int right=j+1<n?nums[j+1]:1;\\n        \\n        int max=0;        \\n       \\n        for(int k=i;k<=j;k++)\\n        {\\n            max=Math.max(left*nums[k]*right+mcm(nums,i,k-1,n,dp)+mcm(nums,k+1,j,n,dp),max);\\n        }\\n        return dp[i][j]=max;\\n    }\\n    public int maxCoins(int[] nums) \\n    {\\n        int n=nums.length;\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return mcm(nums,0,nums.length-1,n,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659359,
                "title": "java-o-n-3-memoization-mcm-variation",
                "content": "```\\npublic int maxCoins(int[] arr) {\\n        return burstBalloons(arr, 0, arr.length - 1, new Integer[arr.length][arr.length]);\\n    }\\n    \\n    private int burstBalloons(int[] arr, int beg, int end, Integer[][] dp) {\\n        if(beg < 0 || end < 0 || beg >= arr.length || end >= arr.length) return 0;\\n        \\n        if(dp[beg][end] != null) return dp[beg][end];\\n        int max = 0;\\n        int prev = beg - 1 >= 0 ? arr[beg - 1] : 1;\\n        int next = end + 1 < arr.length ? arr[end + 1] : 1;\\n        \\n        for(int i = beg; i <= end; i++) {\\n            max = Math.max(max, burstBalloons(arr, beg, i - 1, dp) + (prev * arr[i] * next) + burstBalloons(arr, i + 1, end, dp));\\n        }\\n        \\n        return dp[beg][end] = max;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic int maxCoins(int[] arr) {\\n        return burstBalloons(arr, 0, arr.length - 1, new Integer[arr.length][arr.length]);\\n    }\\n    \\n    private int burstBalloons(int[] arr, int beg, int end, Integer[][] dp) {\\n        if(beg < 0 || end < 0 || beg >= arr.length || end >= arr.length) return 0;\\n        \\n        if(dp[beg][end] != null) return dp[beg][end];\\n        int max = 0;\\n        int prev = beg - 1 >= 0 ? arr[beg - 1] : 1;\\n        int next = end + 1 < arr.length ? arr[end + 1] : 1;\\n        \\n        for(int i = beg; i <= end; i++) {\\n            max = Math.max(max, burstBalloons(arr, beg, i - 1, dp) + (prev * arr[i] * next) + burstBalloons(arr, i + 1, end, dp));\\n        }\\n        \\n        return dp[beg][end] = max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611158,
                "title": "matrix-chain-multiplication-memoization-c",
                "content": "This question is similar to matrix chain multiplication.\\nIf you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem Matrix-chain multiplication found in section 15.2 in the book Introduction to Algorithms (2nd edition).\\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3*5] and B[5*8]. So in this example, the original problem is actually the same as given a matrix chain A[1*3]*B[3*5]*C[5*8]*D[8*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem.\\n\\nThanks to [GREEsDY](https://leetcode.com/GREEsDYhttp://) for the above explanation\\n```\\nint dp[502][502];\\n    int solve(vector<int>& nums, int i, int j){\\n        if(i>=j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MIN;\\n        for(int k = i; k<=j-1; k++){\\n            int temp = solve(nums,i,k) + solve(nums,k+1,j) + nums[k]*nums[i-1]*nums[j];\\n            ans = max(ans,temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(),1);\\n        nums.insert(nums.end(),1);\\n        memset(dp,-1,sizeof dp);\\n        return solve(nums,1,nums.size()-1); \\n    }\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nint dp[502][502];\\n    int solve(vector<int>& nums, int i, int j){\\n        if(i>=j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MIN;\\n        for(int k = i; k<=j-1; k++){\\n            int temp = solve(nums,i,k) + solve(nums,k+1,j) + nums[k]*nums[i-1]*nums[j];\\n            ans = max(ans,temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(),1);\\n        nums.insert(nums.end(),1);\\n        memset(dp,-1,sizeof dp);\\n        return solve(nums,1,nums.size()-1); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087727,
                "title": "c-sol-top-down-dp",
                "content": "class Solution {\\npublic:\\n\\t\\t\\tint dp[502][502];\\n\\t\\t\\n\\tint fun(vector<int>&v , int l , int r){\\n\\t\\t\\tif(dp[l][r]!=-1){\\n\\t\\t\\t\\treturn dp[l][r];\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0 ;\\n\\t\\t\\tfor(int i=l ; i<=r ; i++){\\n\\t\\t\\t\\tans = max( ans , v[i]*(l!=0?v[l-1]:1)*(r!=v.size()-1?v[r+1]:1) + (i>0?fun(v,l,i-1):0) + (i<v.size()-1?fun(v,i+1,r):0) );\\n\\t\\t}\\n        \\n        return dp[l][r]=ans ;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp , -1 , sizeof(dp));\\n        int ans = fun(nums , 0 , nums.size()-1);\\n        \\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\t\\tint dp[502][502];\\n\\t\\t\\n\\tint fun(vector<int>&v , int l , int r){\\n\\t\\t\\tif(dp[l][r]!=-1){\\n\\t\\t\\t\\treturn dp[l][r];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 829516,
                "title": "c-based-on-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        dp.resize(n, vector<int>(n));\\n        return helper(nums,1,n-1);\\n    }\\n    int helper(vector<int>& nums,int start,int end){\\n        if(start >= end){\\n            return 0;\\n        }\\n        if(dp[start][end] != 0){\\n            return dp[start][end];\\n        }\\n        int res = INT_MIN;\\n        for(int k = start; k < end; k++){\\n            int temp = helper(nums,start,k) + helper(nums,k+1,end) + nums[start-1]*nums[k]*nums[end];\\n            res = max(res,temp);\\n        }\\n        dp[start][end] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        dp.resize(n, vector<int>(n));\\n        return helper(nums,1,n-1);\\n    }\\n    int helper(vector<int>& nums,int start,int end){\\n        if(start >= end){\\n            return 0;\\n        }\\n        if(dp[start][end] != 0){\\n            return dp[start][end];\\n        }\\n        int res = INT_MIN;\\n        for(int k = start; k < end; k++){\\n            int temp = helper(nums,start,k) + helper(nums,k+1,end) + nums[start-1]*nums[k]*nums[end];\\n            res = max(res,temp);\\n        }\\n        dp[start][end] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352306,
                "title": "c-dp-with-without-recursion",
                "content": "```cpp\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        \\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size()));\\n        \\n        for (int len=1; len<nums.size()-1; len++) {\\n            for (int i=1; i+len-1<nums.size()-1; i++) {\\n                int s = 0;\\n                for (int k=i; k<=i+len-1; k++)\\n                    s = max(s, nums[i-1] * nums[k] * nums[i+len] + dp[i][k-1] + dp[k+1][i+len-1]);\\n                dp[i][i+len-1] = s;\\n            }\\n        }\\n        return dp[1][nums.size()-2];\\n    }\\n```\\n\\nWith recursion\\n```cpp\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        \\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), -1));\\n        \\n        function<int(int,int)> calc = [&](int start, int end){\\n            if (start > end) return 0;\\n            if (dp[start][end] != -1) return dp[start][end];\\n            int s = 0;\\n            for (int i=start; i<=end; i++) {\\n                int ss = nums[start-1] * nums[i] * nums[end+1] + calc(start, i-1) + calc(i+1, end);\\n                s = max(ss, s);\\n            }\\n            dp[start][end] = s;\\n            return s;\\n        };\\n        \\n        return calc(1, nums.size()-2); \\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        \\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size()));\\n        \\n        for (int len=1; len<nums.size()-1; len++) {\\n            for (int i=1; i+len-1<nums.size()-1; i++) {\\n                int s = 0;\\n                for (int k=i; k<=i+len-1; k++)\\n                    s = max(s, nums[i-1] * nums[k] * nums[i+len] + dp[i][k-1] + dp[k+1][i+len-1]);\\n                dp[i][i+len-1] = s;\\n            }\\n        }\\n        return dp[1][nums.size()-2];\\n    }\\n```\n```cpp\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        \\n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size(), -1));\\n        \\n        function<int(int,int)> calc = [&](int start, int end){\\n            if (start > end) return 0;\\n            if (dp[start][end] != -1) return dp[start][end];\\n            int s = 0;\\n            for (int i=start; i<=end; i++) {\\n                int ss = nums[start-1] * nums[i] * nums[end+1] + calc(start, i-1) + calc(i+1, end);\\n                s = max(ss, s);\\n            }\\n            dp[start][end] = s;\\n            return s;\\n        };\\n        \\n        return calc(1, nums.size()-2); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287256,
                "title": "java-6ms-dp-solution-with-detailed-explanation",
                "content": "This problem can be solved via divider conquer and dynamic programming. We use ```sum[i][j]``` to denote the max coins we can get for ballons from index ```i``` to index ```j```. \\n\\nHow can we calculate ```sum[i][j]```? Imagine kth (i <= k <= j) ballon is **the last one** we burst in the subarray [i, j]. Then the coin we can get for bursting kth ballon is apparently ```nums[i - 1] * nums[k] * nums[j + 1]```. And the total coins for [i, j] is ```sum[i][k - 1] + sum[k + 1][j] + nums[i - 1] * nums[k] * nums[j + 1]```. What we need to do is traverse from i to j to get the best **k**.\\n\\nNote that we add two dummy ballons to the head and tail respectively for the convenience of calculation.\\n\\n```\\npublic int maxCoins(int[] nums) {\\n\\t// add dummy head and tail\\n    int helpNum[] = new int[nums.length + 2]; \\n    for(int i = 1; i <= nums.length; i++)\\n        helpNum[i] = nums[i - 1];\\n    helpNum[0] = 1;\\n    helpNum[nums.length + 1] = 1;\\n\\t\\n    int sum[][] = new int[helpNum.length][helpNum.length];\\n    for(int gap = 0; gap < nums.length; gap++) {\\n        for(int begin = 1; begin < nums.length - gap + 1; begin++) { // we don\\'t consider the dummy head and tail\\n            int end = begin + gap;\\n            sum[begin][end] = Integer.MIN_VALUE;\\n            int left = helpNum[begin - 1];\\n            int right = helpNum[end + 1];\\n\\t\\t\\t\\n\\t\\t\\t// head and tail for current subrange need to be special processed\\n            sum[begin][end] = Math.max(sum[begin][end], sum[begin + 1][end] + helpNum[begin] * left * right);\\n            sum[begin][end] = Math.max(sum[begin][end], sum[begin][end - 1] + helpNum[end] * left * right);\\n\\t\\t\\t\\n            for(int j = begin + 1; j < end; j++)\\n                sum[begin][end] = Math.max(sum[begin][end], sum[begin][j - 1] + sum[j + 1][end] + helpNum[j] * left * right);\\n        }\\n    }\\n    return sum[1][nums.length];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```sum[i][j]```\n```i```\n```j```\n```sum[i][j]```\n```nums[i - 1] * nums[k] * nums[j + 1]```\n```sum[i][k - 1] + sum[k + 1][j] + nums[i - 1] * nums[k] * nums[j + 1]```\n```\\npublic int maxCoins(int[] nums) {\\n\\t// add dummy head and tail\\n    int helpNum[] = new int[nums.length + 2]; \\n    for(int i = 1; i <= nums.length; i++)\\n        helpNum[i] = nums[i - 1];\\n    helpNum[0] = 1;\\n    helpNum[nums.length + 1] = 1;\\n\\t\\n    int sum[][] = new int[helpNum.length][helpNum.length];\\n    for(int gap = 0; gap < nums.length; gap++) {\\n        for(int begin = 1; begin < nums.length - gap + 1; begin++) { // we don\\'t consider the dummy head and tail\\n            int end = begin + gap;\\n            sum[begin][end] = Integer.MIN_VALUE;\\n            int left = helpNum[begin - 1];\\n            int right = helpNum[end + 1];\\n\\t\\t\\t\\n\\t\\t\\t// head and tail for current subrange need to be special processed\\n            sum[begin][end] = Math.max(sum[begin][end], sum[begin + 1][end] + helpNum[begin] * left * right);\\n            sum[begin][end] = Math.max(sum[begin][end], sum[begin][end - 1] + helpNum[end] * left * right);\\n\\t\\t\\t\\n            for(int j = begin + 1; j < end; j++)\\n                sum[begin][end] = Math.max(sum[begin][end], sum[begin][j - 1] + sum[j + 1][end] + helpNum[j] * left * right);\\n        }\\n    }\\n    return sum[1][nums.length];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170148,
                "title": "python-clean-recursive-solution",
                "content": "Following the same idea from the other post to separate the search space into two parts using the last element to burst. The key with this implementation is to add \"[1]\" to the beginning and end of the input array to handle ALL the corner cases at ease.\\n```\\nclass Solution(object):\\n    def maxCoins(self, nums):\\n        if not nums:\\n            return 0\\n        nums = [1] + nums + [1]\\n        cache = {}\\n        return self._maxCoins(nums, 0, len(nums) - 1, cache)\\n\\n    def _maxCoins(self, nums, left, right, cache):\\n        if (left, right) in cache:\\n            return cache[(left, right)]\\n        maximum = 0\\n        for i in range(left + 1, right):\\n            maximum = max(maximum, self._maxCoins(nums, left, i, cache) + self._maxCoins(nums, i, right, cache) + nums[left] * nums[i] * nums[right])\\n        cache[(left, right)] = maximum\\n        return maximum\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxCoins(self, nums):\\n        if not nums:\\n            return 0\\n        nums = [1] + nums + [1]\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 167434,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n  = nums.size();\\n        /// Insert two 1s in the begining and in the end.\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        \\n        vector<vector<int>> c(n+2, vector<int>(n+2, 0));\\n        for(int l  = 1; l <=n ; ++l) {\\n            for (int i = 1; i <= n-l+1; ++i) {\\n                int j = i + l -1;\\n                for(int k = i; k <= j; ++k) {\\n                    c[i][j] = max(c[i][j], c[i][k-1]+ nums[i-1]*nums[k]*nums[j+1] + c[k+1][j]);\\n                }\\n            }\\n        }\\n        return c[1][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n  = nums.size();\\n        /// Insert two 1s in the begining and in the end.\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        \\n        vector<vector<int>> c(n+2, vector<int>(n+2, 0));\\n        for(int l  = 1; l <=n ; ++l) {\\n            for (int i = 1; i <= n-l+1; ++i) {\\n                int j = i + l -1;\\n                for(int k = i; k <= j; ++k) {\\n                    c[i][j] = max(c[i][j], c[i][k-1]+ nums[i-1]*nums[k]*nums[j+1] + c[k+1][j]);\\n                }\\n            }\\n        }\\n        return c[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158201,
                "title": "python-6-lines-easy-to-understand-dfs-w-memoization",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, nums):\\n        memo, nums = {}, [1] + [num for num in nums if num] + [1]\\n        def dfs(l, r):\\n            if r - l == 1: return 0\\n            if (l, r) not in memo: memo[(l, r)] = max(nums[l] * nums[i] * nums[r] + dfs(l, i) + dfs(i, r) for i in range(l + 1, r))\\n            return memo[(l, r)]\\n        return dfs(0, len(nums) - 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums):\\n        memo, nums = {}, [1] + [num for num in nums if num] + [1]\\n        def dfs(l, r):\\n            if r - l == 1: return 0\\n            if (l, r) not in memo: memo[(l, r)] = max(nums[l] * nums[i] * nums[r] + dfs(l, i) + dfs(i, r) for i in range(l + 1, r))\\n            return memo[(l, r)]\\n        return dfs(0, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76239,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Burst Balloons** https://leetcode.com/problems/burst-balloons/\\n\\n**Brute Force Backtracking Solution**\\n* The first naive solution is to use back-tracking. Then you can optimize back-tracking using caching. Back-tracking will have a complexity of O(N!). With cache optmization, some pruning will happen in the tree, but its complexity will still be a lot.\\n\\n```\\nclass Solution(object):\\n    def get_key(self, nums):\\n        return \"_\".join(map(str, nums))\\n    \\n    def helper(self, nums, cache):\\n        if nums == []:\\n            return 0\\n        else:\\n            k = self.get_key(nums)\\n            if k in cache:\\n                return cache[k]\\n            cache[k] = float('-inf')\\n            for i, x in enumerate(nums):\\n                left, right = nums[i-1] if i > 0 else 1, nums[i+1] if i+1<len(nums) else 1\\n                cache[k] = max(cache[k], self.helper(nums[0:i] + nums[i+1:], cache) + left*right*x)\\n            return cache[k]\\n    \\n    def maxCoins(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(nums, {})\\n```\\n\\n**Optimized Solution using Divide and Conquer**\\n* Try thinking using divide and conquer. Pick an index, burst that balloon. Issue is that post bursting, the left and right halves around the burst balloon share a common boundary.\\n* Instead, the insight is to define a sub-problem as finding the maximum coins possible within [low, high] of nums array. \\n* Now let us pick an index i as the last burst balloon within that range.\\n* The last burst balloon will be padded with nums[low-1] and nums[high+1]. So its contribution will be nums[low-1] * nums[high+1] * nums[i]\\n* nums[i] is the last balloon to be burst which yield maximum coins when considering only ballons within nums[low] to nums[high]. Now when we reach nums[i] ready to be burst, what balloons is it padded with? It will be padded with nums[low-1] and nums[high+1]. Thus you need you take their contribution. This part is tricky - give it a careful though. If you understand the sub-problem formulation, then it is easy.\\n* Now we can define a recursive formulation. Given that we pick index i as the last burst balloon to burst, the maximum coins which can be collected using balloons from low to high is:\\ndp[low,high] = max(dp[low,high], nums[i] * nums[low-1] * nums[high + 1] + dp[low, i-1] + dp[i+1, high])\\n* Simply use caching to solve this recurrence.\\n* What is the complexity? Answer is: O(N^3). Why? There O(N^2) sub-problems (evident from the matrix to cache solutions). Each problem is O(N) complexity.\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, nums, low, high, cache):\\n        if low > high:\\n            return 0\\n        elif low in cache and high in cache[low]:\\n            return cache[low][high]\\n        else:\\n            for i in range(low, high+1):\\n                left_half, right_half = self.helper(nums, low, i-1, cache), self.helper(nums, i+1, high, cache)\\n                left, right = nums[low-1] if low > 0 else 1, nums[high+1] if high+1<len(nums) else 1\\n                cache[low][high] = max(cache[low][high], left_half + right_half + left*nums[i]*right)\\n            return cache[low][high]\\n    \\n    def maxCoins(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(lambda: defaultdict(int))\\n        return self.helper(nums, 0, len(nums)-1, cache)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def get_key(self, nums):\\n        return \"_\".join(map(str, nums))\\n    \\n    def helper(self, nums, cache):\\n        if nums == []:\\n            return 0\\n        else:\\n            k = self.get_key(nums)\\n            if k in cache:\\n                return cache[k]\\n            cache[k] = float('-inf')\\n            for i, x in enumerate(nums):\\n                left, right = nums[i-1] if i > 0 else 1, nums[i+1] if i+1<len(nums) else 1\\n                cache[k] = max(cache[k], self.helper(nums[0:i] + nums[i+1:], cache) + left*right*x)\\n            return cache[k]\\n    \\n    def maxCoins(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(nums, {})\\n```\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, nums, low, high, cache):\\n        if low > high:\\n            return 0\\n        elif low in cache and high in cache[low]:\\n            return cache[low][high]\\n        else:\\n            for i in range(low, high+1):\\n                left_half, right_half = self.helper(nums, low, i-1, cache), self.helper(nums, i+1, high, cache)\\n                left, right = nums[low-1] if low > 0 else 1, nums[high+1] if high+1<len(nums) else 1\\n                cache[low][high] = max(cache[low][high], left_half + right_half + left*nums[i]*right)\\n            return cache[low][high]\\n    \\n    def maxCoins(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(lambda: defaultdict(int))\\n        return self.helper(nums, 0, len(nums)-1, cache)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76276,
                "title": "c-dp-solution",
                "content": "I got the idea from dietpepsi's post, but had a hard time to understand the usage of \"nums[left] * nums[i] * nums[right]\"  in his implementation. So I changed the definition of dp state a little bit, which I can understand better. In following code, dp[start][end] is defined as the maximum coins we can get by bursting balloons between \"start\" and \"end\" (exclusively, means \"start\" and \"end\" won't burst).\\n\\n\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n\\n        for (int len = 1; len < n - 1; len ++) {\\n            for (int start = 0; start < n - 1 - len; start ++) {\\n                int end = start + len + 1;\\n                \\n                for (int k = start + 1; k < end; k ++) {\\n                    dp[start][end] = max(dp[start][end], dp[start][k] + dp[k][end] + nums[start] * nums[k] * nums[end]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }",
                "solutionTags": [],
                "code": "I got the idea from dietpepsi's post, but had a hard time to understand the usage of \"nums[left] * nums[i] * nums[right]\"  in his implementation. So I changed the definition of dp state a little bit, which I can understand better. In following code, dp[start][end] is defined as the maximum coins we can get by bursting balloons between \"start\" and \"end\" (exclusively, means \"start\" and \"end\" won't burst).\\n\\n\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n\\n        for (int len = 1; len < n - 1; len ++) {\\n            for (int start = 0; start < n - 1 - len; start ++) {\\n                int end = start + len + 1;\\n                \\n                for (int k = start + 1; k < end; k ++) {\\n                    dp[start][end] = max(dp[start][end], dp[start][k] + dp[k][end] + nums[start] * nums[k] * nums[end]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76286,
                "title": "recursion-version-dp",
                "content": "You should never worry about the loop sequence in recursion.\\n\\n    class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> f(n + 1, vector<int>(n + 1, -1));\\n            vector<int> nums1(n + 2, 1);\\n            for (int i = 0; i < n; ++i) {\\n                nums1[i + 1] = nums[i];\\n            }\\n            return search(nums1, f, 1, n);\\n        }\\n    private:\\n        int search(const vector<int>& nums, vector<vector<int>>& f, const int i, const int j) {\\n            if (i > j) {\\n                return 0;\\n            }\\n            if (f[i][j] >= 0) {\\n                return f[i][j];\\n            }\\n            for (int k = i; k <= j; ++k) {\\n                f[i][j] = max(f[i][j], search(nums, f, i, k - 1) + search(nums, f, k + 1, j) + nums[k] * nums[i - 1] * nums[j + 1]);\\n            }\\n            return f[i][j];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> f(n + 1, vector<int>(n + 1, -1));\\n            vector<int> nums1(n + 2, 1);\\n            for (int i = 0; i < n; ++i) {\\n                nums1[i + 1] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76258,
                "title": "share-my-both-dp-and-divide-conquer-solutions",
                "content": "    // dp solution\\n    // dp[i][j] = max(dp[i][j], dp[i][x-1] + nums[i-1]*nums[x]*nums[j+1] + dp[x+1][j]; // x from i to j\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        \\n        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));\\n\\n        // k indetify the the body length for dp[i, j]\\n        // travel all the possibility for body length for 1 to n    \\n        for (int k = 1; k <= n; k++) { \\n                // [i, j] body length from 1 to n\\n                for (int i = 1; i <= n - k + 1; ++i) {\\n                int j = i + k - 1;\\n                // x between [i, j]                    \\n                for (int x = i; x <= j; ++x) {\\n                    int temp = dp[i][x-1] + nums[i-1]*nums[x]*nums[j+1] + dp[x+1][j];\\n                    if (temp > dp[i][j]) dp[i][j] = temp;\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\n    // divide and conquer\\n    int maxCoins1(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));\\n        return DP(1, n, nums, dp);\\n    }\\n    \\n    // remember search\\n    int DP(int i, int j, const vector<int> &nums, vector<vector<int>> &dp) {\\n        if (dp[i][j] > 0) return dp[i][j];\\n        for (int x = i; x <= j; ++x) {\\n            int temp = DP(i, x-1, nums, dp) + nums[i-1]*nums[x]*nums[j+1] + DP(x+1, j, nums, dp);\\n            if (temp > dp[i][j]) dp[i][j] = temp;\\n        }\\n        return dp[i][j];\\n    }",
                "solutionTags": [],
                "code": "    // dp solution\\n    // dp[i][j] = max(dp[i][j], dp[i][x-1] + nums[i-1]*nums[x]*nums[j+1] + dp[x+1][j]; // x from i to j\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        \\n        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));\\n\\n        // k indetify the the body length for dp[i, j]\\n        // travel all the possibility for body length for 1 to n    \\n        for (int k = 1; k <= n; k++) { \\n                // [i, j] body length from 1 to n\\n                for (int i = 1; i <= n - k + 1; ++i) {\\n                int j = i + k - 1;\\n                // x between [i, j]                    \\n                for (int x = i; x <= j; ++x) {\\n                    int temp = dp[i][x-1] + nums[i-1]*nums[x]*nums[j+1] + dp[x+1][j];\\n                    if (temp > dp[i][j]) dp[i][j] = temp;\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\n    // divide and conquer\\n    int maxCoins1(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.insert(nums.end(), 1);\\n        vector<vector<int> > dp(n+2, vector<int>(n+2, 0));\\n        return DP(1, n, nums, dp);\\n    }\\n    \\n    // remember search\\n    int DP(int i, int j, const vector<int> &nums, vector<vector<int>> &dp) {\\n        if (dp[i][j] > 0) return dp[i][j];\\n        for (int x = i; x <= j; ++x) {\\n            int temp = DP(i, x-1, nums, dp) + nums[i-1]*nums[x]*nums[j+1] + DP(x+1, j, nums, dp);\\n            if (temp > dp[i][j]) dp[i][j] = temp;\\n        }\\n        return dp[i][j];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76288,
                "title": "my-c-code-dp-o-n-3-20ms",
                "content": "The algorithm is well explained in [1] and I pretty much followed the same line.\\n1) First version I got is recursion +backtracing (TLE)\\n2) Second version I got is DP:\\ninstead of bursting ballons one by one, we do it in a reverse order, \"de-burst\" ballons one by one. In that order, the left and right neighbor of the \"de-burst\" ballon is known. However, the complexity is still high (~ order of C(n,n/2))\\n\\nThe real challenge is the outer boundaries (i.e. left, right neighbors vary with the burst order). The algorithm in [1] elegantly fixed that problem: fix left/right neighbors and doing DP from length=3 to nSize;\\n\\n  [1]: https://leetcode.com/discuss/72216/share-some-analysis-and-explanations\\n\\n    class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int nSize = nums.size()+2, left, right, len, mid, temp, dpMax[nSize][nSize] ={};\\n            nums.insert(nums.begin(),1); // two dummy \"1\" added to simplify DP\\n            nums.push_back(1);\\n            \\n            for(len=3; len<=nSize; ++len) // lenght including left and right boudaries, \\n                for(left=0; left<=nSize-len; ++left)  //left boudary/neighbor\\n                    for(right = left+len-1, mid=left+1, temp = nums[left]*nums[right]; mid<right;++mid) //right boundary, mid is the last one to burst in the range (left, right)\\n                        dpMax[left][right] = max(dpMax[left][right], dpMax[left][mid] + dpMax[mid][right] + nums[mid]*temp);\\n    \\n            nums.erase(nums.begin()); // recover nums\\n            nums.pop_back();\\n            return dpMax[0][nSize-1];        \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int nSize = nums.size()+2, left, right, len, mid, temp, dpMax[nSize][nSize] ={}",
                "codeTag": "Java"
            },
            {
                "id": 3025088,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(n+2,vector<int>(n+2,0));\\n        for(int i=n;i>=1;i--){\\n            for(int j=1;j<=n;j++){\\n                if(i>j) continue;\\n                int maxi=INT_MIN;\\n                for(int ind=i;ind<=j;ind++){\\n                    int cost=nums[i-1]*nums[ind]*nums[j+1]+dp[i][ind-1]+dp[ind+1][j];\\n                    maxi=max(maxi,cost);\\n        }\\n        dp[i][j]=maxi;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(n+2,vector<int>(n+2,0));\\n        for(int i=n;i>=1;i--){\\n            for(int j=1;j<=n;j++){\\n                if(i>j) continue;\\n                int maxi=INT_MIN;\\n                for(int ind=i;ind<=j;ind++){\\n                    int cost=nums[i-1]*nums[ind]*nums[j+1]+dp[i][ind-1]+dp[ind+1][j];\\n                    maxi=max(maxi,cost);\\n        }\\n        dp[i][j]=maxi;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025087,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(n+2,vector<int>(n+2,0));\\n        for(int i=n;i>=1;i--){\\n            for(int j=1;j<=n;j++){\\n                if(i>j) continue;\\n                int maxi=INT_MIN;\\n                for(int ind=i;ind<=j;ind++){\\n                    int cost=nums[i-1]*nums[ind]*nums[j+1]+dp[i][ind-1]+dp[ind+1][j];\\n                    maxi=max(maxi,cost);\\n        }\\n        dp[i][j]=maxi;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(n+2,vector<int>(n+2,0));\\n        for(int i=n;i>=1;i--){\\n            for(int j=1;j<=n;j++){\\n                if(i>j) continue;\\n                int maxi=INT_MIN;\\n                for(int ind=i;ind<=j;ind++){\\n                    int cost=nums[i-1]*nums[ind]*nums[j+1]+dp[i][ind-1]+dp[ind+1][j];\\n                    maxi=max(maxi,cost);\\n        }\\n        dp[i][j]=maxi;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482152,
                "title": "python-dynamic-programming-solution-with-explanation",
                "content": "based on scoring rule, the score of bursting ```nums[i]``` is ```nums[i - 1]``` * ```nums[i]``` * ```nums[i + 1]```, and ```i - 1``` or ```i + 1``` goes out of bounds of the array, treat it as if there is a balloon with a ```1``` painted on it.\\nSo, add ```1``` at the first and the end of ```nums```\\n```dp[i][j]``` means how much score we can get from ```nums[i+1:j]``` ->  ```(i, j)``` open interval.\\n\\n```k``` is the balloon we is to burst **last** in the open interval ```(i, j)```, we can calculate score after burst every balloons in the open interval ```(i, j)```, and find the max score.\\n```dp[i][k]``` is the max score we can from open interval ```(i, k)```, ```dp[k][j]``` is the max score we can from open interval ```(k, j)```,\\n```dp[i][k]``` means the balloons in the closed interval ```[i+1, k-1]``` have been bursted, ```dp[k][j]``` is the same.\\nso ```dp[i][j]``` is ```max(dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j] for k in closed interval [i+1, j-1])```\\n\\neg. nums=```[3,1,5,8]```\\n<img src=\"https://latex.codecogs.com/svg.image?\\\\begin{bmatrix}&space;&&space;1&space;&&space;3&space;&&space;1&space;&&space;5&space;&&space;8&space;&&space;1&space;\\\\\\\\1&space;&&space;0&space;&&space;0&space;&&space;3&space;&&space;30&space;&&space;159&space;&&space;167&space;\\\\\\\\3&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;15&space;&&space;135&space;&&space;159&space;\\\\\\\\1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;40&space;&&space;48&space;\\\\\\\\5&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;40&space;\\\\\\\\8&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;\\\\\\\\1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;\\\\end{bmatrix}\" />\\n\\n### iteration\\ndp array is filled from bottom to top, from left to right\\ntc is```O(len(nums)**3)```, sc is ```O(0.5*len(nums)**2)```\\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        nums = [1] + nums + [1]\\n        leng = len(nums)\\n        dp = [[0] * leng for _ in range(leng)]\\n        for i in range(leng-2,-1,-1):\\n            for j in range(i, leng):\\n                for k in range(i+1, j):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[j]*nums[k])\\n        return dp[0][leng-1]\\n```\\n\\n### dfs\\ntc is```O(len(nums)**3)```, sc is ```O(0.5*len(nums)**2)```\\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        nums = [1] + nums + [1]\\n        leng = len(nums)\\n        @cache\\n        def dfs(i, j):\\n            if j - i <= 1: return 0 # there is no balloon between the neighbor\\n            ans = 0\\n            for k in range(i+1, j):\\n                ans = max(ans, dfs(i,k) + dfs(k,j) + nums[i] * nums[j] * nums[k])\\n            return  ans\\n        return dfs(0, leng-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```nums[i]```\n```nums[i - 1]```\n```nums[i]```\n```nums[i + 1]```\n```i - 1```\n```i + 1```\n```1```\n```1```\n```nums```\n```dp[i][j]```\n```nums[i+1:j]```\n```(i, j)```\n```k```\n```(i, j)```\n```(i, j)```\n```dp[i][k]```\n```(i, k)```\n```dp[k][j]```\n```(k, j)```\n```dp[i][k]```\n```[i+1, k-1]```\n```dp[k][j]```\n```dp[i][j]```\n```max(dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j] for k in closed interval [i+1, j-1])```\n```[3,1,5,8]```\n```O(len(nums)**3)```\n```O(0.5*len(nums)**2)```\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        nums = [1] + nums + [1]\\n        leng = len(nums)\\n        dp = [[0] * leng for _ in range(leng)]\\n        for i in range(leng-2,-1,-1):\\n            for j in range(i, leng):\\n                for k in range(i+1, j):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[j]*nums[k])\\n        return dp[0][leng-1]\\n```\n```O(len(nums)**3)```\n```O(0.5*len(nums)**2)```\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        nums = [1] + nums + [1]\\n        leng = len(nums)\\n        @cache\\n        def dfs(i, j):\\n            if j - i <= 1: return 0 # there is no balloon between the neighbor\\n            ans = 0\\n            for k in range(i+1, j):\\n                ans = max(ans, dfs(i,k) + dfs(k,j) + nums[i] * nums[j] * nums[k])\\n            return  ans\\n        return dfs(0, leng-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225175,
                "title": "java-dynamic-programming",
                "content": "### Idea\\n1. What makes this problem difficult to solve is, when we have a lot of balloons, we are not sure what the neighbor balloon is. So, thinking in terms of what the first balloon to pop is not straight-forward.\\n2. Let\\'s consider in terms of what the last balloon to pop in a given range is. Given `[A, B, C, D, E]` balloons, let\\'s consider we pop `[B, C, D]` first.  `[A, *B, *C, *D, E]`. Among these three balloons, what happens if we decide to pop `C` last? We will get points from popping the other two, and then we will get points of the product of `A` * `C` *  `E` (the other two edges).\\n3. Saying it generally, if we decide to pop `i`th balloon last between range `a` and `b`, the max point would be\\n`[nums[0], ..., nums[a - 1], nums[a], ..., nums[i], ...nums[b], nums[b + 1], ... nums[n - 1]]`, the max point would be:\\n`maxpoint from popping balloon a to i - 1` + `nums[a - 1] * nums[i] * nums[b + 1]` + `maxpoint from popping ballon i + 1 to balloon b`.\\n4. Since we don\\'t know what `i` value is, we iterate through all the possible `i`. In the code sample, the `i` value is named as `last`\\n5. Given this, the shorter range should be computed before the longer range. That is, to know the max point we can get from range `0 to 5`, we should know what the max point we can get from `0 to 4` because the said `i` could be `5`.\\n\\n### Implementation details\\n1. It is much easier to implement the dp when we have the dummy end points. So, I constructed a new array with `1` on each end.\\n2. To make it obvious, what the left and right end points we are considering, I named the left-most balloon index `left`, and the right-most balloon index `right`.\\n3. To prevent repeated computations, I used the memoization. The repeated query is, given `left` and `right` end point what the max `dp` is. So, it is a 2-dimensional `dp`.\\n4. When the `len` is 1, do we need special handling? The code we wrote (`maxValue = Math.max(balloons[last] * balloons[left - 1] * balloons[right + 1] + dp[left][last - 1] + dp[last + 1][right], maxValue);`)is fine, because `dp[left][last - 1]` and `dp[last + 1][right]` are both initialized as `0` in Java.\\n\\n### Sample Code\\n``` java\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length + 2;\\n        int[] balloons = buildBalloonArray(nums);  // see implementation detail # 1\\n        int[][] dp = new int[n][n]; // see implementation detail # 3\\n        for (int len = 1; len <= n - 2; len++) { // see idea # 5\\n            for (int left = 1; left < n - 1; left++) { // see implementation detail # 2\\n                int right = left + len - 1; // see implementation detail # 2\\n                if (right >= n - 1) {\\n                    break;\\n                }\\n                int maxValue = 0;\\n                for (int last = left; last <= right; last++) { // see idea # 4\\n                    maxValue = Math.max(balloons[last] * balloons[left - 1] * balloons[right + 1] \\n                                        + dp[left][last - 1] + dp[last + 1][right], maxValue); // see idea # 3, implementation detail # 4\\n                }\\n                dp[left][right] = maxValue;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n    \\n    private int[] buildBalloonArray(int[] nums) {\\n        int n = nums.length;\\n        int[] balloons = new int[n + 2];\\n        for (int i = 0; i < n; i++) {\\n            balloons[i + 1] = nums[i];\\n        }\\n        balloons[0] = 1;\\n        balloons[n + 1] = 1;\\n        return balloons;\\n    }\\n}\\n```\\n\\nPlease let me know if you have any questions, and upvote it if you liked it.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` java\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length + 2;\\n        int[] balloons = buildBalloonArray(nums);  // see implementation detail # 1\\n        int[][] dp = new int[n][n]; // see implementation detail # 3\\n        for (int len = 1; len <= n - 2; len++) { // see idea # 5\\n            for (int left = 1; left < n - 1; left++) { // see implementation detail # 2\\n                int right = left + len - 1; // see implementation detail # 2\\n                if (right >= n - 1) {\\n                    break;\\n                }\\n                int maxValue = 0;\\n                for (int last = left; last <= right; last++) { // see idea # 4\\n                    maxValue = Math.max(balloons[last] * balloons[left - 1] * balloons[right + 1] \\n                                        + dp[left][last - 1] + dp[last + 1][right], maxValue); // see idea # 3, implementation detail # 4\\n                }\\n                dp[left][right] = maxValue;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n    \\n    private int[] buildBalloonArray(int[] nums) {\\n        int n = nums.length;\\n        int[] balloons = new int[n + 2];\\n        for (int i = 0; i < n; i++) {\\n            balloons[i + 1] = nums[i];\\n        }\\n        balloons[0] = 1;\\n        balloons[n + 1] = 1;\\n        return balloons;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660097,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ******Using DP******\\n\\n1. ***Time Complexity : O(N ^ 3)***\\n2. ***Space Complexity : O(N ^ 2)***\\n\\n```\\nint maxCoins(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int arr[n+2];\\n        \\n        arr[0] = 1;\\n        \\n        arr[n+1] = 1;\\n        \\n        for(int i = 1; i <= n; i++)\\n            arr[i] = nums[i-1];\\n        \\n        int dp[n+2][n+2];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int length = 1; length <= n; length++)\\n        {\\n            for(int left = 1; left <= (n - length + 1); left++)\\n            {\\n                int right = left + length - 1;\\n                \\n                for(int i = left; i <= right; i++)\\n                {\\n                    dp[left][right] = max(dp[left][right], (arr[left-1] * arr[i] * arr[right+1]) + dp[left][i-1] + dp[i+1][right]);\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n] ;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxCoins(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int arr[n+2];\\n        \\n        arr[0] = 1;\\n        \\n        arr[n+1] = 1;\\n        \\n        for(int i = 1; i <= n; i++)\\n            arr[i] = nums[i-1];\\n        \\n        int dp[n+2][n+2];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int length = 1; length <= n; length++)\\n        {\\n            for(int left = 1; left <= (n - length + 1); left++)\\n            {\\n                int right = left + length - 1;\\n                \\n                for(int i = left; i <= right; i++)\\n                {\\n                    dp[left][right] = max(dp[left][right], (arr[left-1] * arr[i] * arr[right+1]) + dp[left][i-1] + dp[i+1][right]);\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n] ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660081,
                "title": "java-discussed-both-top-down-and-bottom-up-approach",
                "content": "**312. Burst Balloons**\\n**Approach:**\\n **A. BruteForce:**\\n  1. Generate all permutations of given array and consider each permutation to be the order of bursting balloons\\n  2. For each permutation, compute the cost and keep track of maximum cost\\n  3. Return max cost\\n \\n  **Complexity**\\n  1. **Time**: O(n!)\\n       There will be n! permutations. Computing cost for each permutation would take O(n^2). so essentially total cost will\\n       be O(n!)\\n  2. **Space**: O(n)\\n       Permutations can be made using recursion and we will need an array to hold one permutation.\\n \\n **B. Top Down Recursion with DP**\\n  1. Suppose function f(start, end) gives max cost for bursting balloons in range of [start, end]\\n  2. This function can be defined recursively as\\n  3. ```\\n       f(start, end) = maximum of (\\n\\t                     f(start, k - 1) +\\n\\t\\t\\t\\t\\t\\t\\tnums[start - 1] *  nums[k] * nums[end + 1]) +\\n\\t\\t\\t\\t\\t\\t\\tf(k + 1, end)\\n\\t\\t\\t\\t\\t\\t\\t) where k lies in range [start, end]\\n\\t   ```\\n       Here,\\n       **`f(start, k - 1):`** means total maximum cost from left sub array\\n       **`nums[start - 1] * nums[k] * nums[end + 1]`**: Cost of bursting balloon k considering it is the last balloon bursted in\\n       this group from [start, end]\\n       **`f(k + 1, end)`**: means total maximum cost from right sub array\\n\\t   \\n  **Complexity**\\n  **1. Time: O(n^3)**\\n       For filling each value in memo table, one loop is needed. Hence, to fill N^2 states, we need N^3 complexity\\n  **2.Space: O(n^2)** for memo table\\n \\n ```\\n     private static int computeTopDown(int[] nums) {\\n        int n = nums.length;\\n        int[] newNums = new int[n + 2];\\n        System.arraycopy(nums, 0, newNums, 1, n);\\n        newNums[0] = 1;\\n        newNums[newNums.length - 1] = 1;\\n\\n        int[][] memo = new int[n + 2][n + 2];\\n        compute(newNums, memo, 1, n);\\n        return memo[1][n];\\n    }\\n\\n    /**\\n     * recursive top down approach\\n     *\\n     * @param nums:  input array\\n     * @param memo:  memo table\\n     * @param start: starting index of array\\n     * @param end:   ending index of array\\n     * @return\\n     */\\n    private static int compute(int[] nums, int[][] memo, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (memo[start][end] != 0) {\\n            return memo[start][end];\\n        }\\n        int maxValue = 0;\\n        for (int mid = start; mid <= end; mid++) {\\n            maxValue = Math.max(maxValue,\\n                    // nums[start - 1] means the rightmost unburst balloon from the left subarray\\n                    // nums[end + 1] means the leftmost unburst balloon from the right subarray\\n                    // the above two balloons will be needed to compute cost while bursting mid balloon.\\n                    nums[start - 1] * nums[mid] * nums[end + 1] +\\n                            compute(nums, memo, start, mid - 1) +\\n                            compute(nums, memo, mid + 1, end));\\n        }\\n        memo[start][end] = maxValue;\\n        return maxValue;\\n    }\\n\\n ```\\n \\n  **C. Bottom Up**\\n  1. The above algorithm can be implemented in bottom up manner using nested loops\\n  **Complexity**\\n  **1. Time: O(N^3)** There are 3 loops\\n  **2. Space: O(N^2)** : memo table\\n  \\n  ```\\n      /**\\n     * This is an iterating way for above approach.\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    private static int computeBottomUp(int[] nums) {\\n        int n = nums.length;\\n        int[] newNums = new int[n + 2];\\n        System.arraycopy(nums, 0, newNums, 1, n);\\n        newNums[0] = 1;\\n        newNums[newNums.length - 1] = 1;\\n        int[][] memo = new int[n + 2][n + 2];\\n\\n        for (int len = 1; len <= n; len++) {\\n            for (int start = 0; start < n - len + 1; start++) {\\n                int end = start + len + 1;\\n                for (int mid = start + 1; mid < end; mid++) {\\n                    // start and end will point to array element which are out of bounds for current subarray.\\n                    // here since, mid is iterating from start + 1 to end - 1 hence, we will populate memo with those values\\n                    // only.\\n                    memo[start + 1][end - 1] = Math.max(memo[start + 1][end - 1],\\n                            newNums[start] * newNums[mid] * newNums[end] +\\n                                    memo[start + 1][mid - 1] +\\n                                    memo[mid + 1][end - 1]);\\n                }\\n            }\\n        }\\n        return memo[1][n];\\n    }\\n  ```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n       f(start, end) = maximum of (\\n\\t                     f(start, k - 1) +\\n\\t\\t\\t\\t\\t\\t\\tnums[start - 1] *  nums[k] * nums[end + 1]) +\\n\\t\\t\\t\\t\\t\\t\\tf(k + 1, end)\\n\\t\\t\\t\\t\\t\\t\\t) where k lies in range [start, end]\\n\\t   ```\n```\\n     private static int computeTopDown(int[] nums) {\\n        int n = nums.length;\\n        int[] newNums = new int[n + 2];\\n        System.arraycopy(nums, 0, newNums, 1, n);\\n        newNums[0] = 1;\\n        newNums[newNums.length - 1] = 1;\\n\\n        int[][] memo = new int[n + 2][n + 2];\\n        compute(newNums, memo, 1, n);\\n        return memo[1][n];\\n    }\\n\\n    /**\\n     * recursive top down approach\\n     *\\n     * @param nums:  input array\\n     * @param memo:  memo table\\n     * @param start: starting index of array\\n     * @param end:   ending index of array\\n     * @return\\n     */\\n    private static int compute(int[] nums, int[][] memo, int start, int end) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        if (memo[start][end] != 0) {\\n            return memo[start][end];\\n        }\\n        int maxValue = 0;\\n        for (int mid = start; mid <= end; mid++) {\\n            maxValue = Math.max(maxValue,\\n                    // nums[start - 1] means the rightmost unburst balloon from the left subarray\\n                    // nums[end + 1] means the leftmost unburst balloon from the right subarray\\n                    // the above two balloons will be needed to compute cost while bursting mid balloon.\\n                    nums[start - 1] * nums[mid] * nums[end + 1] +\\n                            compute(nums, memo, start, mid - 1) +\\n                            compute(nums, memo, mid + 1, end));\\n        }\\n        memo[start][end] = maxValue;\\n        return maxValue;\\n    }\\n\\n ```\n```\\n      /**\\n     * This is an iterating way for above approach.\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    private static int computeBottomUp(int[] nums) {\\n        int n = nums.length;\\n        int[] newNums = new int[n + 2];\\n        System.arraycopy(nums, 0, newNums, 1, n);\\n        newNums[0] = 1;\\n        newNums[newNums.length - 1] = 1;\\n        int[][] memo = new int[n + 2][n + 2];\\n\\n        for (int len = 1; len <= n; len++) {\\n            for (int start = 0; start < n - len + 1; start++) {\\n                int end = start + len + 1;\\n                for (int mid = start + 1; mid < end; mid++) {\\n                    // start and end will point to array element which are out of bounds for current subarray.\\n                    // here since, mid is iterating from start + 1 to end - 1 hence, we will populate memo with those values\\n                    // only.\\n                    memo[start + 1][end - 1] = Math.max(memo[start + 1][end - 1],\\n                            newNums[start] * newNums[mid] * newNums[end] +\\n                                    memo[start + 1][mid - 1] +\\n                                    memo[mid + 1][end - 1]);\\n                }\\n            }\\n        }\\n        return memo[1][n];\\n    }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659520,
                "title": "java-top-down-and-bottom-up-approach-o-n-3-time-and-o-n-2-space",
                "content": "**Top Down Approach: O(N^3) Time and O(N^2) Space due to DP Array and stack space of recursion**\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        //TopDown Approach\\n        int[][] dp = new int[nums.length][nums.length];\\n        for(int i = 0; i < nums.length; i++)Arrays.fill(dp[i], -1);\\n        \\n        return maxCoinsTopDown(nums, 0, nums.length - 1, dp);\\n    }\\n    public int maxCoinsTopDown(int[] nums, int leftIdx, int rightIdx, int[][] dp){\\n        //base case\\n        if(leftIdx > rightIdx)return 0;\\n        if(dp[leftIdx][rightIdx] != -1)return dp[leftIdx][rightIdx];\\n        \\n        int leftBoundary = leftIdx != 0? nums[leftIdx - 1]: 1;\\n        int rightBoundary = rightIdx != nums.length - 1? nums[rightIdx + 1]: 1;\\n        \\n        if(leftIdx == rightIdx)return dp[leftIdx][rightIdx] = leftBoundary * nums[leftIdx] * rightBoundary;\\n        \\n        int maxCoins = 0;\\n        for(int lastBalloonIdx = leftIdx; lastBalloonIdx <= rightIdx; lastBalloonIdx++){\\n            \\n            //picking the balloon at lastBalloonIdx to be the last balloon to be burst\\n            //among the balloons in the range leftIdx to rightIdx\\n            \\n            maxCoins = Math.max(maxCoins, leftBoundary * nums[lastBalloonIdx] * rightBoundary + \\n                               maxCoinsTopDown(nums, leftIdx, lastBalloonIdx - 1, dp) + \\n                               maxCoinsTopDown(nums, lastBalloonIdx + 1, rightIdx, dp));\\n        }\\n        return dp[leftIdx][rightIdx] = maxCoins;\\n    }\\n}\\n```\\n\\n**Bottom Up Approach: O(N^3) time and O(N^2) space due to DP Array**\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        //bottomUp Approach\\n        int[][] dp = new int[nums.length][nums.length];\\n        \\n        for(int len = 1; len <= nums.length; len++){\\n            for(int i = 0; i < nums.length + 1 - len; i++){\\n                \\n                int leftBoundary = (i != 0)? nums[i - 1]: 1;\\n                int rightBoundary = (i + len < nums.length)? nums[i + len]: 1;\\n                \\n                int k = i + len - 1;\\n                for(int j = i; j <= k; j++){\\n                    //in the range of balloons from i to k, picking the balloon at jth\\n                    //idx to be the last balloon to burst\\n                    dp[i][k] = Math.max(dp[i][k],\\n                                        leftBoundary * nums[j] * rightBoundary + \\n                                        (j > 0? dp[i][j - 1]: 0) + \\n                                        (j < nums.length - 1? dp[j + 1][k]: 0));\\n                }\\n            }\\n        }\\n        return dp[0][nums.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        //TopDown Approach\\n        int[][] dp = new int[nums.length][nums.length];\\n        for(int i = 0; i < nums.length; i++)Arrays.fill(dp[i], -1);\\n        \\n        return maxCoinsTopDown(nums, 0, nums.length - 1, dp);\\n    }\\n    public int maxCoinsTopDown(int[] nums, int leftIdx, int rightIdx, int[][] dp){\\n        //base case\\n        if(leftIdx > rightIdx)return 0;\\n        if(dp[leftIdx][rightIdx] != -1)return dp[leftIdx][rightIdx];\\n        \\n        int leftBoundary = leftIdx != 0? nums[leftIdx - 1]: 1;\\n        int rightBoundary = rightIdx != nums.length - 1? nums[rightIdx + 1]: 1;\\n        \\n        if(leftIdx == rightIdx)return dp[leftIdx][rightIdx] = leftBoundary * nums[leftIdx] * rightBoundary;\\n        \\n        int maxCoins = 0;\\n        for(int lastBalloonIdx = leftIdx; lastBalloonIdx <= rightIdx; lastBalloonIdx++){\\n            \\n            //picking the balloon at lastBalloonIdx to be the last balloon to be burst\\n            //among the balloons in the range leftIdx to rightIdx\\n            \\n            maxCoins = Math.max(maxCoins, leftBoundary * nums[lastBalloonIdx] * rightBoundary + \\n                               maxCoinsTopDown(nums, leftIdx, lastBalloonIdx - 1, dp) + \\n                               maxCoinsTopDown(nums, lastBalloonIdx + 1, rightIdx, dp));\\n        }\\n        return dp[leftIdx][rightIdx] = maxCoins;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        //bottomUp Approach\\n        int[][] dp = new int[nums.length][nums.length];\\n        \\n        for(int len = 1; len <= nums.length; len++){\\n            for(int i = 0; i < nums.length + 1 - len; i++){\\n                \\n                int leftBoundary = (i != 0)? nums[i - 1]: 1;\\n                int rightBoundary = (i + len < nums.length)? nums[i + len]: 1;\\n                \\n                int k = i + len - 1;\\n                for(int j = i; j <= k; j++){\\n                    //in the range of balloons from i to k, picking the balloon at jth\\n                    //idx to be the last balloon to burst\\n                    dp[i][k] = Math.max(dp[i][k],\\n                                        leftBoundary * nums[j] * rightBoundary + \\n                                        (j > 0? dp[i][j - 1]: 0) + \\n                                        (j < nums.length - 1? dp[j + 1][k]: 0));\\n                }\\n            }\\n        }\\n        return dp[0][nums.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309807,
                "title": "some-time-we-need-to-skip-recursion-and-jump-with-iterative-intuition",
                "content": "On first time when I saw this problem, I think that we came with the intuition :\\n1. We will burst all the ballon.\\n2. And for each ballon we can have two options:\\n      1. Either I can burst it or,\\n      2. I can skip it.\\n\\n\\nBut this intuition got failed after looking at some hints. I tried to figure out that :\\n\\nLet\\u2019s suppose we are going to burst the ballon in the range [left\\u2026.right] so,\\n\\n1. This range can vary from 0...N.\\n2. For each [left, right], we will burst every ballon and get the possible maximum coins for this [left, right]\\n3. In such a way, we have explored all the ranges of bursting the ballon and we required the range from [left=1\\u2026 right=n] i.e. full length.\\n\\nSo,\\n\\n1. My, Dp[left][right] = {Will tell you that what will be the maximum coins if you burst all the ballon from left to right.}\\n2. Let\\u2019s suppose we bursting i-th ballon :\\n3. So we\\u2019ll get the coin :\\n4.  `(dp[left][i-1] + dp[i+1][right]) + (nums[burn] * nums[left - 1] * nums[right + 1])`\\n5.  **dp[left][i-1] + dp[i+1][right] :** total coin from [left\\u2026 right] after burning i-th ballon will be  coins of [left...i] and coins[i+1...right] because nums[i] is going to be burned plus coins what we will get extra after burning i-th ballon(i.e. nums[i] * nums[left - 1] * nums[right + 1])\\n\\n\\n```\\n\\nclass Solution {\\n   public:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\\n\\n        // Let\\'s extract from small length to n\\n        for (int len = 1; len <= n; len++) {\\n            for (int left = 1; left <= n - len + 1; left++) {\\n                // Get the right range\\n                int right = left + len - 1;\\n                int bestCoin = 0;\\n\\n                // Find the maximum possible coins if we burned all the ballon in the rand left to right\\n                for (int burn = left; burn <= right; burn++) {\\n                    // total coin from [left...burn-1] and [burn+1...right] because [burn] is going to be burned\\n                    int coins = dp[left][burn - 1] + dp[burn + 1][right];\\n                    coins += (nums[burn] * nums[left - 1] * nums[right + 1]);\\n                    bestCoin = max(bestCoin, coins);\\n                }\\n\\n                // Store the answer\\n                dp[left][right] = bestCoin;\\n            }\\n        }\\n\\n        // return the max coins which getting after burning from 1-n\\n        return dp[1][n];\\n    }\\n};\\n\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n   public:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\\n\\n        // Let\\'s extract from small length to n\\n        for (int len = 1; len <= n; len++) {\\n            for (int left = 1; left <= n - len + 1; left++) {\\n                // Get the right range\\n                int right = left + len - 1;\\n                int bestCoin = 0;\\n\\n                // Find the maximum possible coins if we burned all the ballon in the rand left to right\\n                for (int burn = left; burn <= right; burn++) {\\n                    // total coin from [left...burn-1] and [burn+1...right] because [burn] is going to be burned\\n                    int coins = dp[left][burn - 1] + dp[burn + 1][right];\\n                    coins += (nums[burn] * nums[left - 1] * nums[right + 1]);\\n                    bestCoin = max(bestCoin, coins);\\n                }\\n\\n                // Store the answer\\n                dp[left][right] = bestCoin;\\n            }\\n        }\\n\\n        // return the max coins which getting after burning from 1-n\\n        return dp[1][n];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286673,
                "title": "c-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[502][502];\\n    int f(vector<int> &a,int i,int j)\\n    {\\n        if(i+1==j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res=0;\\n        for(int k=i+1;k<j;k++)\\n        {\\n            res=max(res,(f(a,i,k)+f(a,k,j)+a[i]*a[k]*a[j]));\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int maxCoins(vector<int>& a) {\\n        a.insert(a.begin(), 1);\\n        a.insert(a.end(), 1);\\n        int n=a.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(a,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[502][502];\\n    int f(vector<int> &a,int i,int j)\\n    {\\n        if(i+1==j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res=0;\\n        for(int k=i+1;k<j;k++)\\n        {\\n            res=max(res,(f(a,i,k)+f(a,k,j)+a[i]*a[k]*a[j]));\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int maxCoins(vector<int>& a) {\\n        a.insert(a.begin(), 1);\\n        a.insert(a.end(), 1);\\n        int n=a.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(a,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180636,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:  \\n    int dp[504][504];\\n    int solve(vector<int>&a, int i , int j)\\n    {\\n        // base case\\n        // start from  1 to n-2\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = 0;\\n        for(int k = i+1; k <= j-1 ; k++)\\n            ans = max(ans , (solve(a,i,k) + solve(a,k,j) + a[i]*a[k]*a[j])) ;\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int maxCoins(vector<int>& a) {\\n       \\n        // insert 1 at the begining and at the end\\n        a.insert(a.begin() , 1);\\n        a.push_back(1);\\n         int n = a.size();\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(a,0,n-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:  \\n    int dp[504][504];\\n    int solve(vector<int>&a, int i , int j)\\n    {\\n        // base case\\n        // start from  1 to n-2\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = 0;\\n        for(int k = i+1; k <= j-1 ; k++)\\n            ans = max(ans , (solve(a,i,k) + solve(a,k,j) + a[i]*a[k]*a[j])) ;\\n        dp[i][j] = ans;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1149843,
                "title": "mcm-top-down-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[505][505];\\n    \\n    int solve(vector<int>& a, int i, int j){\\n        if(i>j)\\n            return 0;\\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n            int t=solve(a,i,k-1) + solve(a,k+1,j) + a[i-1]*a[k]*a[j+1];\\n            ans=max(ans,t);\\n        }\\n        return t[i][j]=ans;\\n    }\\n    \\n    \\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);  \\n        int n=nums.size();\\n        memset(t,-1,sizeof(t));\\n        return solve(nums, 1, n-2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[505][505];\\n    \\n    int solve(vector<int>& a, int i, int j){\\n        if(i>j)\\n            return 0;\\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n            int t=solve(a,i,k-1) + solve(a,k+1,j) + a[i-1]*a[k]*a[j+1];\\n            ans=max(ans,t);\\n        }\\n        return t[i][j]=ans;\\n    }\\n    \\n    \\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);  \\n        int n=nums.size();\\n        memset(t,-1,sizeof(t));\\n        return solve(nums, 1, n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149251,
                "title": "thought-process-to-come-up-with-the-solution",
                "content": "[This](https://medium.com/algorithms-digest/bursting-balloons-1820664a4ffa) blog made a lot of sense to me: \\nIt explains how one can think of the solution from scratch.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        \\n        // Get the number of balloons\\n        int n = nums.size();\\n        \\n        // Generate a new array by adding 1 on the left and right of nums[]\\n        vector<int> numsDP(n+2);\\n        numsDP[0] = numsDP[n+1] = 1;\\n        for(int i=1; i<=n; i++)\\n            numsDP[i] = nums[i-1];\\n        \\n        // Initialize entries of dp[][] with -1\\n        int dp`[n+2][n+2];\\n        for(int i=0; i<n+2; i++)\\n            for(int j=0; j<n+2; j++)\\n                dp[i][j] = -1;\\n    \\n        // Iterate over different subarray sizes (s) in a bottom-up manner\\n        for(int s=2; s<=(n+2); s++)\\n        {\\n            for(int i=0; i<n+2-s+1; i++)\\n            {\\n                // Size 2 sub-arrays corespond to the base case (0 coins collected)\\n                if(s == 2)\\n                    dp[i][i+s-1] = 0;\\n                else // For other sub-arrays use the recusive formulation\\n                {\\n                    // Consider all possible choices of the last balloon to be burst\\n                    // And select the onee which maximises the number of coins collected\\n                    for(int j=i+1; j<(i+s-1); j++)\\n                    {\\n                        dp[i][i+s-1] = max(dp[i][i+s-1], dp[i][j] + dp[j][i+s-1] + numsDP[i]*numsDP[j]*numsDP[i+s-1]);\\n                    }\\n                }\\n            }\\n        }\\n        // Final answer is dp[0][n+1]\\n        return dp[0][n+1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        \\n        // Get the number of balloons\\n        int n = nums.size();\\n        \\n        // Generate a new array by adding 1 on the left and right of nums[]\\n        vector<int> numsDP(n+2);\\n        numsDP[0] = numsDP[n+1] = 1;\\n        for(int i=1; i<=n; i++)\\n            numsDP[i] = nums[i-1];\\n        \\n        // Initialize entries of dp[][] with -1\\n        int dp`[n+2][n+2];\\n        for(int i=0; i<n+2; i++)\\n            for(int j=0; j<n+2; j++)\\n                dp[i][j] = -1;\\n    \\n        // Iterate over different subarray sizes (s) in a bottom-up manner\\n        for(int s=2; s<=(n+2); s++)\\n        {\\n            for(int i=0; i<n+2-s+1; i++)\\n            {\\n                // Size 2 sub-arrays corespond to the base case (0 coins collected)\\n                if(s == 2)\\n                    dp[i][i+s-1] = 0;\\n                else // For other sub-arrays use the recusive formulation\\n                {\\n                    // Consider all possible choices of the last balloon to be burst\\n                    // And select the onee which maximises the number of coins collected\\n                    for(int j=i+1; j<(i+s-1); j++)\\n                    {\\n                        dp[i][i+s-1] = max(dp[i][i+s-1], dp[i][j] + dp[j][i+s-1] + numsDP[i]*numsDP[j]*numsDP[i+s-1]);\\n                    }\\n                }\\n            }\\n        }\\n        // Final answer is dp[0][n+1]\\n        return dp[0][n+1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970740,
                "title": "java-short-and-crisp-dp-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        \\n        int[][] memo = new int[n][n];\\n        \\n        //memo[i][j] = maximum coins obtained to brust ballons from index i to j in nums.\\n        for(int len=1;len<=n;len++){\\n            for(int st=0,end=st+len-1;end<n;st++,end++){\\n                //Lets find maximum coins if kth balloon is bursted last\\n                for(int k=st;k<=end;k++){\\n                    //Kth balloon will be burst last only if,\\n                    //Balloons from st to k-1 & k+1 to end are bursted before kth balloon\\n                    int cost= ((k==st)?0:memo[st][k-1])+ ((k==end)?0:memo[k+1][end]);\\n                    //As Kth balloon is burst last, start-1 & end+1 will be its adjacent balloons\\n                    cost+=((st==0)?1:nums[st-1])*nums[k]*((end==n-1)?1:nums[end+1]);\\n                    //Store maximum coins \\n                    memo[st][end]=Math.max(memo[st][end],cost);\\n                }\\n            }\\n        }\\n        return memo[0][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        \\n        int[][] memo = new int[n][n];\\n        \\n        //memo[i][j] = maximum coins obtained to brust ballons from index i to j in nums.\\n        for(int len=1;len<=n;len++){\\n            for(int st=0,end=st+len-1;end<n;st++,end++){\\n                //Lets find maximum coins if kth balloon is bursted last\\n                for(int k=st;k<=end;k++){\\n                    //Kth balloon will be burst last only if,\\n                    //Balloons from st to k-1 & k+1 to end are bursted before kth balloon\\n                    int cost= ((k==st)?0:memo[st][k-1])+ ((k==end)?0:memo[k+1][end]);\\n                    //As Kth balloon is burst last, start-1 & end+1 will be its adjacent balloons\\n                    cost+=((st==0)?1:nums[st-1])*nums[k]*((end==n-1)?1:nums[end+1]);\\n                    //Store maximum coins \\n                    memo[st][end]=Math.max(memo[st][end],cost);\\n                }\\n            }\\n        }\\n        return memo[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970659,
                "title": "python-top-down-dp",
                "content": "<details>\\n\\n<summary><b>Approach:</b> (click to show)</summary>\\n\\nThe idea here is to work backwards.\\nDon\\'t pop balloons **insert** balloons.\\n\\nWhile inserting balloons we need to keep track of a few things.\\n```left``` and ```right``` are the values of the last balloon inserted\\nto the left and right of the current range.\\n\\n```i``` and ```j``` are the start and end indices of the current range.\\n\\nInitially we have the range [0, len(nums) - 1] and left = right = 1\\nbecause no balloons have been inserted yet.\\n\\nThen when we insert a balloon with a value of 3 at index 5. \\nWe now have two ranges to consider. \\nThe first range is [0, 4] where left equals 1 but **right now**\\n**equals 3** because we inserted a balloon with a \\nvalue of 3.\\n\\nThe second range is [6, len(nums) - 1] where **left equals 3**\\nand right equals 1.\\n\\nEvery time we insert a balloon we create two new ranges\\n**until** the length of the range is 1 and we only have\\none balloon to pick from to insert.\\n\\nEvery time a balloon is inserted add left * nums[k] * right\\nto the total (where nums[k] is the value of the balloon inserted\\nat index k).\\n\\nFor each sub-problem, consider all of the possible indices\\nk where the balloon could be inserted and pick the one\\nthat yields the maximum points.\\n\\n</details>\\n\\n<br>\\n\\n```python\\ndef maxCoins(self, nums: List[int]) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(left, right, i, j):\\n\\t\\tif i >= j:\\n\\t\\t\\treturn left * right * nums[i] if i == j else 0\\n\\t\\tbest = 0\\n\\t\\tfor k in range(i, j+1):\\n\\t\\t\\tbest = max(best, left * nums[k] * right + helper(left, nums[k], i, k-1) + helper(nums[k], right, k+1, j))\\n\\t\\treturn best\\n\\t\\t\\n\\treturn helper(1, 1, 0, len(nums) - 1)\\n```",
                "solutionTags": [],
                "code": "```left```\n```right```\n```i```\n```j```\n```python\\ndef maxCoins(self, nums: List[int]) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(left, right, i, j):\\n\\t\\tif i >= j:\\n\\t\\t\\treturn left * right * nums[i] if i == j else 0\\n\\t\\tbest = 0\\n\\t\\tfor k in range(i, j+1):\\n\\t\\t\\tbest = max(best, left * nums[k] * right + helper(left, nums[k], i, k-1) + helper(nums[k], right, k+1, j))\\n\\t\\treturn best\\n\\t\\t\\n\\treturn helper(1, 1, 0, len(nums) - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 786517,
                "title": "c-brute-force-memoised-bottom-up",
                "content": "Brute force:-\\n```\\nclass Solution {\\npublic:\\n    \\n    int cut(vector<int> &b, int left, int right){\\n        if(left+1==right) return 0;\\n        int ans=0;\\n        for(int i=left+1;i<right;i++){\\n            int t1=cut(b,left,i);\\n            int t2=cut(b,i,right);\\n            int tans=b[left]*b[i]*b[right];\\n            ans=max(ans,tans+t1+t2);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxCoins(vector<int>& a){\\n        int n=a.size();\\n        if(n==0) return 0;\\n        if(n==1) return a[0];\\n        vector<int> b(n+2);\\n        b[0]=b[n+1]=1;\\n        for(int i=1;i<=n;i++) b[i]=a[i-1];\\n        return cut(b,0,n+1);\\n    }\\n};\\n```\\n\\nMemoized:-\\n```\\nclass Solution {\\npublic:\\n    int dp[502][502];\\n    int cut(vector<int> &b, int left, int right){\\n        if(left+1==right) return 0;\\n        if(dp[left][right]!=-1) return dp[left][right];\\n        int ans=0;\\n        for(int i=left+1;i<right;i++){\\n            int t1=cut(b,left,i);\\n            int t2=cut(b,i,right);\\n            int tans=b[left]*b[i]*b[right];\\n            ans=max(ans,tans+t1+t2);\\n        }\\n        return dp[left][right]=ans;\\n    }\\n    \\n    int maxCoins(vector<int>& a){\\n        int n=a.size();\\n        if(n==0) return 0;\\n        if(n==1) return a[0];\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> b(n+2);\\n        b[0]=b[n+1]=1;\\n        for(int i=1;i<=n;i++) b[i]=a[i-1];\\n        return cut(b,0,n+1);\\n    }\\n};\\n```\\nBottom up:-\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& a){\\n        int n=a.size();\\n        if(n==0) return 0;\\n        if(n==1) return a[0];\\n        //memset(dp,-1,sizeof(dp));\\n        vector<int> b(n+2);\\n        b[0]=b[n+1]=1;\\n        for(int i=1;i<=n;i++) b[i]=a[i-1];\\n        int dp[b.size()][b.size()];\\n        memset(dp,0,sizeof(dp));\\n        for(int gap=2;gap<b.size();gap++){\\n            for(int le=0;le<=b.size()-gap-1;le++){\\n                int ri=le+gap;\\n                for(int i=le+1;i<ri;i++){\\n                    dp[le][ri]=max(dp[le][ri],dp[le][i]+dp[i][ri]+(b[le]*b[i]*b[ri]));\\n                }\\n            }\\n        }\\n        return dp[0][b.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int cut(vector<int> &b, int left, int right){\\n        if(left+1==right) return 0;\\n        int ans=0;\\n        for(int i=left+1;i<right;i++){\\n            int t1=cut(b,left,i);\\n            int t2=cut(b,i,right);\\n            int tans=b[left]*b[i]*b[right];\\n            ans=max(ans,tans+t1+t2);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxCoins(vector<int>& a){\\n        int n=a.size();\\n        if(n==0) return 0;\\n        if(n==1) return a[0];\\n        vector<int> b(n+2);\\n        b[0]=b[n+1]=1;\\n        for(int i=1;i<=n;i++) b[i]=a[i-1];\\n        return cut(b,0,n+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[502][502];\\n    int cut(vector<int> &b, int left, int right){\\n        if(left+1==right) return 0;\\n        if(dp[left][right]!=-1) return dp[left][right];\\n        int ans=0;\\n        for(int i=left+1;i<right;i++){\\n            int t1=cut(b,left,i);\\n            int t2=cut(b,i,right);\\n            int tans=b[left]*b[i]*b[right];\\n            ans=max(ans,tans+t1+t2);\\n        }\\n        return dp[left][right]=ans;\\n    }\\n    \\n    int maxCoins(vector<int>& a){\\n        int n=a.size();\\n        if(n==0) return 0;\\n        if(n==1) return a[0];\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> b(n+2);\\n        b[0]=b[n+1]=1;\\n        for(int i=1;i<=n;i++) b[i]=a[i-1];\\n        return cut(b,0,n+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& a){\\n        int n=a.size();\\n        if(n==0) return 0;\\n        if(n==1) return a[0];\\n        //memset(dp,-1,sizeof(dp));\\n        vector<int> b(n+2);\\n        b[0]=b[n+1]=1;\\n        for(int i=1;i<=n;i++) b[i]=a[i-1];\\n        int dp[b.size()][b.size()];\\n        memset(dp,0,sizeof(dp));\\n        for(int gap=2;gap<b.size();gap++){\\n            for(int le=0;le<=b.size()-gap-1;le++){\\n                int ri=le+gap;\\n                for(int i=le+1;i<ri;i++){\\n                    dp[le][ri]=max(dp[le][ri],dp[le][i]+dp[i][ri]+(b[le]*b[i]*b[ri]));\\n                }\\n            }\\n        }\\n        return dp[0][b.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645473,
                "title": "java-matrix-chain-multiplication-memo",
                "content": "The arr[] is created as in note section is given at index -1 and n =1\\nso clone the given arr and add padding.\\n\\nAs in mcm is given to minimize we can vary it by maximize it.\\n```\\nclass Solution {\\n    int dp[][]=new int[501][501];\\n    public int maxCoins(int[] nums) {\\n       \\n        int arr[]=new int[nums.length+2];\\n        int n=1;\\n        for(int ii[]:dp)\\n        {\\n            Arrays.fill(ii,-1);\\n        }\\n        for(int x:nums)\\n            arr[n++]=x;\\n            arr[0]=arr[n++]=1;\\n        return solve(arr,1,n-1);\\n    }\\n    public int solve(int arr[],int i,int j)\\n    {\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int max=Integer.MIN_VALUE;\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int temp=solve(arr,i,k)+solve(arr,k+1,j)+arr[i-1]*arr[k]*arr[j];\\n            max=Math.max(max,temp);\\n        }\\n        return dp[i][j]=max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][]=new int[501][501];\\n    public int maxCoins(int[] nums) {\\n       \\n        int arr[]=new int[nums.length+2];\\n        int n=1;\\n        for(int ii[]:dp)\\n        {\\n            Arrays.fill(ii,-1);\\n        }\\n        for(int x:nums)\\n            arr[n++]=x;\\n            arr[0]=arr[n++]=1;\\n        return solve(arr,1,n-1);\\n    }\\n    public int solve(int arr[],int i,int j)\\n    {\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int max=Integer.MIN_VALUE;\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int temp=solve(arr,i,k)+solve(arr,k+1,j)+arr[i-1]*arr[k]*arr[j];\\n            max=Math.max(max,temp);\\n        }\\n        return dp[i][j]=max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533575,
                "title": "java-dp-solution-with-expalination",
                "content": "For this problem, we firstly define a 2D dynamic programming table named `OPT` to represent the maximum coins we can get in the index range from `left` to `right`  denoted by `OPT[left, right]`. \\n\\nThen, we need to express this by some subproblems. The idea is to consider **which balloon is the last one to be bursted** so that we can get the maximum coins. Assume the last one bursted has index `i` with in `[left, right]`. In this way, our subproblems are the **maximum coins in both left side and right side of nums[k]**: values of `OPT[left, i-1]` and `OPT[i+1, right]`. Sum the results of these two subproblems and the coins from bursting last balloon to get `OPT[left, right]`.\\n\\nConcequently, our recurrence relation can be expressed as following\\n```\\nOPT[left, right] = max(OPT[left, right], OPT[left, i-1] + nums[left-1] * nums[i] * nums[right+1] + OPT[i+1, right])\\n```\\n\\nNote that the index range we use here is inclusive.\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] inNums) {\\n        int[] nums = new int[inNums.length + 2];\\n        nums[0] = nums[nums.length - 1] = 1;\\n        for(int i = 1; i < nums.length - 1; i++) {\\n            nums[i] = inNums[i-1];\\n        }\\n        \\n        int[][] DP = new int[nums.length][nums.length];\\n        for(int size = 0; size < inNums.length; size++) {\\n            for(int left = 1; left <= inNums.length - size; left++) {\\n                int right = left + size;\\n                for(int i = left; i <= right; i++) {\\n                    DP[left][right] = Math.max(DP[left][right], nums[left-1] * nums[i] * nums[right+1] + DP[left][i-1] + DP[i+1][right]);\\n                }\\n            }\\n        }\\n        return DP[1][inNums.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nOPT[left, right] = max(OPT[left, right], OPT[left, i-1] + nums[left-1] * nums[i] * nums[right+1] + OPT[i+1, right])\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] inNums) {\\n        int[] nums = new int[inNums.length + 2];\\n        nums[0] = nums[nums.length - 1] = 1;\\n        for(int i = 1; i < nums.length - 1; i++) {\\n            nums[i] = inNums[i-1];\\n        }\\n        \\n        int[][] DP = new int[nums.length][nums.length];\\n        for(int size = 0; size < inNums.length; size++) {\\n            for(int left = 1; left <= inNums.length - size; left++) {\\n                int right = left + size;\\n                for(int i = left; i <= right; i++) {\\n                    DP[left][right] = Math.max(DP[left][right], nums[left-1] * nums[i] * nums[right+1] + DP[left][i-1] + DP[i+1][right]);\\n                }\\n            }\\n        }\\n        return DP[1][inNums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527752,
                "title": "",
                "content": "\\u8FD9\\u9053\\u9898\\u7684\\u5173\\u952E\\uFF0C\\u5176\\u5B9E\\u548C\\u4EFB\\u4F55\\u52A8\\u6001\\u89C4\\u5212\\u95EE\\u9898\\u662F\\u4E00\\u6837\\u513F\\u4E00\\u6837\\u513F\\u7684\\u3002\\u90A3\\u5C31\\u662F\\uFF01\\u641E\\u6E05\\u695Adp\\u6570\\u7EC4\\u600E\\u4E48\\u5EFA\\u7ACB\\uFF0Cdp\\u6570\\u7EC4\\u8868\\u793A\\u5565\\uFF0Cdp[i][j]\\u5E94\\u8BE5\\u5982\\u4F55\\u8FED\\u4EE3\\u83B7\\u53D6!\\ntalk is cheap\\uFF1A\\n```\\n/**\\n * @Author: changyifan\\n * @Description: \\u7EC8\\u4E8E\\u5237\\u5230\\u4F60!\\u6233\\u6C14\\u7403!!\\n * \\u56E0\\u4E3A\\u8FD9\\u9053\\u53D8\\u6001\\u7684\\u9898...\\u6211\\u542C\\u8BF4\\u4E86\\u53D8\\u6001\\u7684LeetCode,\\u77E5\\u9053\\u4E86\\u8FD9\\u73A9\\u610F\\u513F\\u53D8\\u6001\\u96BE...\\n * <p>\\n * \\u8BDD\\u4E0D\\u591A\\u8BF4,\\u5F00\\u59CB..\\n * dp[i][j]\\u8868\\u793A\\u6233\\u7206i~j\\u4E2D\\u6240\\u6709\\u6C14\\u7403\\u540E\\u7684\\u6700\\u9AD8\\u5F97\\u5206(\\u4E0D\\u5305\\u62ECi,j)\\n * \\u90A3\\u6478,\\u5047\\u8BBEk\\u662Fnums[]\\u4E2D\\u6700\\u540E\\u4E00\\u4E2A\\u6233\\u7206\\u7684\\u6C14\\u7403.\\u5219\\u6709:\\n * dp[i][j] = max(dp[i][j], extendedNums[i] * extendedNums[k] * extendedNums[j] + dp[i][k] + dp[k][j])\\n * \\u5176\\u4E2DextendedNums[] \\u4E3A\\u6269\\u5C55\\u540E\\u7684nums[], extendedNums\\u5C06\\u6536\\u5C3E\\u7F6E1,\\u5E76\\u4E14\\u5C06nums[]\\u4E2D\\u4E3A0\\u7684\\u5168\\u90E8\\u4F18\\u5148\\u6233\\u7206(0\\u5728\\u8BE5\\u89C4\\u5219\\u4E0B\\u65E0\\u610F\\u4E49,\\u4ED4\\u7EC6\\u60F3\\u60F3\\u5C31\\u77E5\\u9053\\u4E86)\\n * \\u6240\\u4EE5\\u5462,i\\u8981\\u904D\\u5386,j\\u8981\\u904D\\u5386,k\\u8981\\u904D\\u5386,\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(n^3),\\u6700\\u7EC8\\u8FD4\\u56DEdp[0][n-1],\\u5176\\u4E2Dn\\u4E3AextendedNums\\u4E2D\\u4E0D\\u4E3A0\\u7684\\u6570\\u5B57\\u7684\\u957F\\u5EA6\\n *\\n * \\u597D\\u5427,\\u505A\\u8FD9\\u9053\\u9898\\u592A\\u5174\\u594B\\u4E86,\\u628A\\u7528\\u4F8B\\u641E\\u9519\\u4E86\\u6298\\u78E8\\u6211\\u4E00\\u4E2A\\u591A\\u5C0F\\u65F6...\\n */\\n\\n\\nclass Solution {\\n    public static int maxCoins(int[] nums) {\\n        //\\u91CD\\u65B0\\u5F04\\u4E2A\\u6570\\u7EC4\\u51FA\\u6765,\\u53BB\\u63890, \\u9996\\u5C3E\\u7F6E1\\n        int[] extendedNums = new int[nums.length + 2];\\n        int n = 1;\\n        for (int num : nums) {\\n            if (num != 0) {\\n                extendedNums[n] = num;\\n                n++;\\n            }\\n        }\\n        extendedNums[0] = extendedNums[n] = 1;\\n        n++;\\n        //\\u5F00\\u59CBdp show\\n        int[][] dp = new int[n][n];\\n        //\\u65E0\\u9700\\u521D\\u59CB\\u5316,\\u56E0\\u4E3Adp[][]\\u5DF2\\u7ECF\\u6269\\u5C55\\u8FC7\\u4E86,\\u4E0D\\u5B58\\u5728dp\\u957F\\u5EA6\\u4EC5\\u4E3A2\\u7684\\u60C5\\u51B5,\\u82E5\\u771F\\u662F\\u8FD9\\u6837,\\u8BF4\\u660E\\u7B54\\u6848\\u5C31\\u662F0\\n        //\\u76F4\\u63A5\\u5F00\\u59CB\\u70AB\\u9177\\u7684for\\u5FAA\\u73AF,\\u6CE8\\u610F\\u8FD9\\u91CC\\u662F\\u5148\\u4ECEj\\u5F00\\u59CB\\u904D\\u5386,\\u806A\\u660E\\u7684\\u4F60\\u4E00\\u5B9A\\u77E5\\u9053,\\u5982\\u679C\\u4ECEi\\u5148\\u5F00\\u59CB,\\u90A3\\u4E48\\u6211\\u4EEC\\u5728\\u8BA1\\u7B97dp[0][n-1]\\u7684\\u65F6\\u5019\\u5C06\\u4E0D\\u518D\\u62E5\\u6709\\u4EFB\\u4F55dp\\u7684\\u4F18\\u52BF,\\u5F97\\u51FA\\u7684\\u4E5F\\u5FC5\\u5C06\\u662F\\u9519\\u8BEF\\u7B54\\u6848\\n        for (int j = 2; j < n; j++) {\\n            for (int i = j - 2; i >= 0; i--) {\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], extendedNums[i] * extendedNums[k] * extendedNums[j] + dp[i][k] + dp[k][j]);\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @Author: changyifan\\n * @Description: \\u7EC8\\u4E8E\\u5237\\u5230\\u4F60!\\u6233\\u6C14\\u7403!!\\n * \\u56E0\\u4E3A\\u8FD9\\u9053\\u53D8\\u6001\\u7684\\u9898...\\u6211\\u542C\\u8BF4\\u4E86\\u53D8\\u6001\\u7684LeetCode,\\u77E5\\u9053\\u4E86\\u8FD9\\u73A9\\u610F\\u513F\\u53D8\\u6001\\u96BE...\\n * <p>\\n * \\u8BDD\\u4E0D\\u591A\\u8BF4,\\u5F00\\u59CB..\\n * dp[i][j]\\u8868\\u793A\\u6233\\u7206i~j\\u4E2D\\u6240\\u6709\\u6C14\\u7403\\u540E\\u7684\\u6700\\u9AD8\\u5F97\\u5206(\\u4E0D\\u5305\\u62ECi,j)\\n * \\u90A3\\u6478,\\u5047\\u8BBEk\\u662Fnums[]\\u4E2D\\u6700\\u540E\\u4E00\\u4E2A\\u6233\\u7206\\u7684\\u6C14\\u7403.\\u5219\\u6709:\\n * dp[i][j] = max(dp[i][j], extendedNums[i] * extendedNums[k] * extendedNums[j] + dp[i][k] + dp[k][j])\\n * \\u5176\\u4E2DextendedNums[] \\u4E3A\\u6269\\u5C55\\u540E\\u7684nums[], extendedNums\\u5C06\\u6536\\u5C3E\\u7F6E1,\\u5E76\\u4E14\\u5C06nums[]\\u4E2D\\u4E3A0\\u7684\\u5168\\u90E8\\u4F18\\u5148\\u6233\\u7206(0\\u5728\\u8BE5\\u89C4\\u5219\\u4E0B\\u65E0\\u610F\\u4E49,\\u4ED4\\u7EC6\\u60F3\\u60F3\\u5C31\\u77E5\\u9053\\u4E86)\\n * \\u6240\\u4EE5\\u5462,i\\u8981\\u904D\\u5386,j\\u8981\\u904D\\u5386,k\\u8981\\u904D\\u5386,\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3AO(n^3),\\u6700\\u7EC8\\u8FD4\\u56DEdp[0][n-1],\\u5176\\u4E2Dn\\u4E3AextendedNums\\u4E2D\\u4E0D\\u4E3A0\\u7684\\u6570\\u5B57\\u7684\\u957F\\u5EA6\\n *\\n * \\u597D\\u5427,\\u505A\\u8FD9\\u9053\\u9898\\u592A\\u5174\\u594B\\u4E86,\\u628A\\u7528\\u4F8B\\u641E\\u9519\\u4E86\\u6298\\u78E8\\u6211\\u4E00\\u4E2A\\u591A\\u5C0F\\u65F6...\\n */\\n\\n\\nclass Solution {\\n    public static int maxCoins(int[] nums) {\\n        //\\u91CD\\u65B0\\u5F04\\u4E2A\\u6570\\u7EC4\\u51FA\\u6765,\\u53BB\\u63890, \\u9996\\u5C3E\\u7F6E1\\n        int[] extendedNums = new int[nums.length + 2];\\n        int n = 1;\\n        for (int num : nums) {\\n            if (num != 0) {\\n                extendedNums[n] = num;\\n                n++;\\n            }\\n        }\\n        extendedNums[0] = extendedNums[n] = 1;\\n        n++;\\n        //\\u5F00\\u59CBdp show\\n        int[][] dp = new int[n][n];\\n        //\\u65E0\\u9700\\u521D\\u59CB\\u5316,\\u56E0\\u4E3Adp[][]\\u5DF2\\u7ECF\\u6269\\u5C55\\u8FC7\\u4E86,\\u4E0D\\u5B58\\u5728dp\\u957F\\u5EA6\\u4EC5\\u4E3A2\\u7684\\u60C5\\u51B5,\\u82E5\\u771F\\u662F\\u8FD9\\u6837,\\u8BF4\\u660E\\u7B54\\u6848\\u5C31\\u662F0\\n        //\\u76F4\\u63A5\\u5F00\\u59CB\\u70AB\\u9177\\u7684for\\u5FAA\\u73AF,\\u6CE8\\u610F\\u8FD9\\u91CC\\u662F\\u5148\\u4ECEj\\u5F00\\u59CB\\u904D\\u5386,\\u806A\\u660E\\u7684\\u4F60\\u4E00\\u5B9A\\u77E5\\u9053,\\u5982\\u679C\\u4ECEi\\u5148\\u5F00\\u59CB,\\u90A3\\u4E48\\u6211\\u4EEC\\u5728\\u8BA1\\u7B97dp[0][n-1]\\u7684\\u65F6\\u5019\\u5C06\\u4E0D\\u518D\\u62E5\\u6709\\u4EFB\\u4F55dp\\u7684\\u4F18\\u52BF,\\u5F97\\u51FA\\u7684\\u4E5F\\u5FC5\\u5C06\\u662F\\u9519\\u8BEF\\u7B54\\u6848\\n        for (int j = 2; j < n; j++) {\\n            for (int i = j - 2; i >= 0; i--) {\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], extendedNums[i] * extendedNums[k] * extendedNums[j] + dp[i][k] + dp[k][j]);\\n                }\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139814,
                "title": "awesome-2d-dp-video-explanation-must-watch",
                "content": "Pls check this link out: https://www.youtube.com/watch?v=IFNibRVgFBo \\nAwesome video tutorial on the problem by Tushar Roy!\\nBTW, I think the author who came up with the problem is inspired by Matrix Multiplication DP problem.\\n",
                "solutionTags": [],
                "code": "Pls check this link out: https://www.youtube.com/watch?v=IFNibRVgFBo \\nAwesome video tutorial on the problem by Tushar Roy!\\nBTW, I think the author who came up with the problem is inspired by Matrix Multiplication DP problem.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 76261,
                "title": "a-typical-dynamic-programming-problem-in-java-code",
                "content": "This is a typical dynamic programming problem. It is very similar to the matrix chain multiplication problem described in \"introduction to algorithms third edition\", you can refer to it for some detailed information. And here is my java code.\\n\\n    public int maxCoins(int[] nums) {\\n        int[] p = new int[nums.length + 2];\\n        System.arraycopy(nums, 0, p, 1, nums.length);\\n        p[0] = 1;\\n        p[p.length - 1] = 1;\\n        int n = p.length - 1;\\n        int[][] m = new int[n][n];\\n        for (int i = 0; i < n; i++)\\n            m[i][i] = 0;\\n        for (int l = 2; l <= n; l++)\\n            for (int i = 0; i <= n - l; i++) {\\n                int j = i + l - 1;\\n                m[i][j] = Integer.MIN_VALUE;\\n                for (int k = i; k < j; k++)\\n                    m[i][j] = Math.max(m[i][j], m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1]);\\n            }\\n        return m[0][n - 1];\\n    }",
                "solutionTags": [],
                "code": "This is a typical dynamic programming problem. It is very similar to the matrix chain multiplication problem described in \"introduction to algorithms third edition\", you can refer to it for some detailed information. And here is my java code.\\n\\n    public int maxCoins(int[] nums) {\\n        int[] p = new int[nums.length + 2];\\n        System.arraycopy(nums, 0, p, 1, nums.length);\\n        p[0] = 1;\\n        p[p.length - 1] = 1;\\n        int n = p.length - 1;\\n        int[][] m = new int[n][n];\\n        for (int i = 0; i < n; i++)\\n            m[i][i] = 0;\\n        for (int l = 2; l <= n; l++)\\n            for (int i = 0; i <= n - l; i++) {\\n                int j = i + l - 1;\\n                m[i][j] = Integer.MIN_VALUE;\\n                for (int k = i; k < j; k++)\\n                    m[i][j] = Math.max(m[i][j], m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1]);\\n            }\\n        return m[0][n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76266,
                "title": "sharing-my-c-o-n-3-solution-using-recursion-and-memoization-easy-to-read",
                "content": "    class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n == 0) return 0;\\n            else if (n == 1) return nums[0];\\n            \\n            // if \"nums\" is const, we can create a new vector instead\\n            nums.insert(nums.begin(), 1);\\n            nums.push_back(1); // now, balloons are from 1 to n\\n        \\n            vector<vector<int>> memo(n + 2, vector<int>((n + 2), -1));\\n            return calcIncome(nums, memo, 0, n + 1); \\n        }\\n        \\n        // start index from 0 to n - 1, end index from 2 to n + 1\\n        int calcIncome(vector<int>& nums, vector<vector<int>>& memo, int start, int end)\\n        {\\n            if (memo[start][end] != -1)\\n                return memo[start][end];\\n    \\n            if (end - start == 1)\\n                memo[start][end] = 0;\\n            else\\n            {\\n                int income = 0;\\n                \\n                for (int i = start + 1; i < end; i++)\\n                {  \\n                    income = max(income, calcIncome(nums, memo, start, i) + \\n                        calcIncome(nums, memo, i, end) + nums[i] * nums[start] * nums[end]);\\n                }\\n                \\n                memo[start][end] = income;\\n            }\\n            \\n            return memo[start][end];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n == 0) return 0;\\n            else if (n == 1) return nums[0];\\n            \\n            // if \"nums\" is const, we can create a new vector instead\\n            nums.insert(nums.begin(), 1);\\n            nums.push_back(1); // now, balloons are from 1 to n\\n        \\n            vector<vector<int>> memo(n + 2, vector<int>((n + 2), -1));\\n            return calcIncome(nums, memo, 0, n + 1); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 76270,
                "title": "16-ms-dp-c-solution-beating-96-others",
                "content": "    int maxCoins(vector<int>& nums) {\\n            int num[nums.size()+2];\\n            int n = 1;\\n            for(int x : nums)  num[n++] = x;\\n            num[0] = num[n++] = 1;\\n            int dp[n][n] = {};   // dp[i][j] means the maxScore we can reach by bursting all the balloons between (i,j)\\n            for(int k = 2; k < n; k++){\\n                for(int left = 0; left + k < n; left++){\\n                    int right = left + k;\\n                    for(int i = left+1; i < right; i++){\\n                        dp[left][right] = max(dp[left][right], dp[left][i] + dp[i][right] + num[left]*num[right]*num[i]);\\n                    }\\n                }\\n            }\\n            return dp[0][n-1];\\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    int maxCoins(vector<int>& nums) {\\n            int num[nums.size()+2];\\n            int n = 1;\\n            for(int x : nums)  num[n++] = x;\\n            num[0] = num[n++] = 1;\\n            int dp[n][n] = {};   // dp[i][j] means the maxScore we can reach by bursting all the balloons between (i,j)\\n            for(int k = 2; k < n; k++){\\n                for(int left = 0; left + k < n; left++){\\n                    int right = left + k;\\n                    for(int i = left+1; i < right; i++){\\n                        dp[left][right] = max(dp[left][right], dp[left][i] + dp[i][right] + num[left]*num[right]*num[i]);\\n                    }\\n                }\\n            }\\n            return dp[0][n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3676838,
                "title": "c-using-mcm-concept-both-memoization-tabulation-t-c-o-n-3-s-c-o-n-2",
                "content": "1. Memoization Approach:\\n```\\nclass Solution {\\n    \\n    /*\\n        Memoization Approach : \\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int n;\\n    \\n    int helper(int i, int j, vector<int> &nums, vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int res = INT_MIN;\\n        for(int idx=i; idx<=j; idx++){\\n            int coins = nums[i-1]*nums[idx]*nums[j+1]\\n                + helper(i, idx-1, nums, dp)\\n                + helper(idx+1, j, nums, dp);\\n            \\n            res = max(res, coins);\\n        }\\n        \\n        return dp[i][j] = res;\\n    }\\n    \\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(begin(nums), 1);\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (n+1, -1));\\n        \\n        return helper(1, n, nums, dp);\\n    }\\n};\\n```\\n\\n2. Tabulation Approach:\\n```\\nclass Solution {\\n    \\n    /*\\n        Memoization Approach : \\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int n;\\n        \\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(begin(nums), 1);\\n        \\n        vector<vector<int>> dp(n+2, vector<int> (n+2, 0));\\n        \\n        for(int i=n; i>=1; i--){\\n            for(int j=1; j<=n; j++){\\n                if(i>j) continue;\\n               \\n                int res = INT_MIN;\\n               \\n                for(int idx=i; idx<=j; idx++){\\n                    int coins = nums[i-1]*nums[idx]*nums[j+1]\\n                        + dp[i][idx-1]\\n                        + dp[idx+1][j];\\n\\n                    res = max(res, coins);\\n                }\\n\\n                dp[i][j] = res;\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Memoization Approach : \\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int n;\\n    \\n    int helper(int i, int j, vector<int> &nums, vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int res = INT_MIN;\\n        for(int idx=i; idx<=j; idx++){\\n            int coins = nums[i-1]*nums[idx]*nums[j+1]\\n                + helper(i, idx-1, nums, dp)\\n                + helper(idx+1, j, nums, dp);\\n            \\n            res = max(res, coins);\\n        }\\n        \\n        return dp[i][j] = res;\\n    }\\n    \\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(begin(nums), 1);\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (n+1, -1));\\n        \\n        return helper(1, n, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    /*\\n        Memoization Approach : \\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int n;\\n        \\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(begin(nums), 1);\\n        \\n        vector<vector<int>> dp(n+2, vector<int> (n+2, 0));\\n        \\n        for(int i=n; i>=1; i--){\\n            for(int j=1; j<=n; j++){\\n                if(i>j) continue;\\n               \\n                int res = INT_MIN;\\n               \\n                for(int idx=i; idx<=j; idx++){\\n                    int coins = nums[i-1]*nums[idx]*nums[j+1]\\n                        + dp[i][idx-1]\\n                        + dp[idx+1][j];\\n\\n                    res = max(res, coins);\\n                }\\n\\n                dp[i][j] = res;\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844729,
                "title": "follow-up-question-for-interview",
                "content": "**Question**\\nReturn the maximum coins you can collect by bursting k consecutive out of the n balloons wisely. k will be given as input\\n\\n\\n**Solution**\\nmax along kth diagonal ( k according to 1 based indexing)\\n\\n\\n*Please don\\'t go without upvoting if you liked it!*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**Question**\\nReturn the maximum coins you can collect by bursting k consecutive out of the n balloons wisely. k will be given as input\\n\\n\\n**Solution**\\nmax along kth diagonal ( k according to 1 based indexing)\\n\\n\\n*Please don\\'t go without upvoting if you liked it!*",
                "codeTag": "Unknown"
            },
            {
                "id": 2782238,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, a[305], dp[305][305];\\n    int solve(int l, int r) {\\n        if(dp[l][r] != -1) return dp[l][r];\\n        int ans = 0;\\n        for (int i = l + 1; i < r; i++) {\\n            int sum = solve(l, i) + solve(i, r);\\n            sum += (a[l] * a[i] * a[r]);\\n            ans = max(ans, sum);\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        n = nums.size();\\n        for(int i=0; i<n; i++) a[i+1] = nums[i];\\n        a[0] = 1;\\n        a[n+1] = 1;\\n        n++;\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, a[305], dp[305][305];\\n    int solve(int l, int r) {\\n        if(dp[l][r] != -1) return dp[l][r];\\n        int ans = 0;\\n        for (int i = l + 1; i < r; i++) {\\n            int sum = solve(l, i) + solve(i, r);\\n            sum += (a[l] * a[i] * a[r]);\\n            ans = max(ans, sum);\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        n = nums.size();\\n        for(int i=0; i<n; i++) a[i+1] = nums[i];\\n        a[0] = 1;\\n        a[n+1] = 1;\\n        n++;\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742415,
                "title": "easy-solution-c",
                "content": "```\\n// Burst Balloons\\n    // brute\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int> & nums){\\n                if(i > j) return 0;\\n                long mini = -1e9; // int error \\u2B50\\n                for(int ind=i;ind<=j;ind++){ // ind < j error \\u2B50\\n                    long burst = nums[i-1]*nums[ind]*nums[j+1] + pre(i,ind-1,nums)+pre(ind+1,j,nums);\\n                    mini = max(mini,burst);\\n                }\\n                return mini;\\n            }\\n            \\n            int maxCoins(vector<int>& nums) {\\n                int c = nums.size();\\n                nums.insert(nums.begin(),1);\\n                nums.push_back(1);\\n                return pre(1,c,nums); // c + 2 => giving error \\u2B50\\n            }\\n        };\\n    \\n    // memo\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int> & nums,vector<vector<int>> &dp){\\n                if(i > j) return 0;\\n                if(dp[i][j] != -1) return dp[i][j];\\n                \\n                long mini = -1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long burst = nums[i-1]*nums[ind]*nums[j+1] + pre(i,ind-1,nums,dp)+pre(ind+1,j,nums,dp);\\n                    mini = max(mini,burst);\\n                }\\n                return dp[i][j] = mini;\\n            }\\n            \\n            int maxCoins(vector<int>& nums) {\\n                int c = nums.size();\\n                nums.insert(nums.begin(),1);\\n                nums.push_back(1);\\n                \\n                vector<vector<int>> dp(c+1,vector<int> (c+1,-1));\\n                return pre(1,c,nums,dp);\\n            }\\n        };\\n    \\n    // tab\\n        class Solution {\\n        public:\\n            int maxCoins(vector<int>& nums) {\\n                int c = nums.size();\\n                nums.insert(nums.begin(),1);\\n                nums.push_back(1);\\n                \\n                vector<vector<int>> dp(c+3,vector<int> (c+3,0)); // wrong declaration\\n                \\n                for(int i=c;i>=1;i--){ // wrong intialied for loop \\n                    for(int j=1;j<=c;j++){ // wrong intiated for loop\\n                        if(i > j) continue;\\n                        long mini = -1e9;\\n                        for(int ind=i;ind<=j;ind++){\\n                            long burst = nums[i-1]*nums[ind]*nums[j+1] + dp[i][ind-1]+ dp[ind+1][j];\\n                            mini = max(mini,burst);\\n                        }\\n                        dp[i][j] = mini;\\n                    }\\n                }\\n                \\n                return dp[1][c];\\n            }\\n        };\\n```\\n<br>\\n<div> Happy coding </div>\\nPlease do upvote this post.\\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Burst Balloons\\n    // brute\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int> & nums){\\n                if(i > j) return 0;\\n                long mini = -1e9; // int error \\u2B50\\n                for(int ind=i;ind<=j;ind++){ // ind < j error \\u2B50\\n                    long burst = nums[i-1]*nums[ind]*nums[j+1] + pre(i,ind-1,nums)+pre(ind+1,j,nums);\\n                    mini = max(mini,burst);\\n                }\\n                return mini;\\n            }\\n            \\n            int maxCoins(vector<int>& nums) {\\n                int c = nums.size();\\n                nums.insert(nums.begin(),1);\\n                nums.push_back(1);\\n                return pre(1,c,nums); // c + 2 => giving error \\u2B50\\n            }\\n        };\\n    \\n    // memo\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int> & nums,vector<vector<int>> &dp){\\n                if(i > j) return 0;\\n                if(dp[i][j] != -1) return dp[i][j];\\n                \\n                long mini = -1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long burst = nums[i-1]*nums[ind]*nums[j+1] + pre(i,ind-1,nums,dp)+pre(ind+1,j,nums,dp);\\n                    mini = max(mini,burst);\\n                }\\n                return dp[i][j] = mini;\\n            }\\n            \\n            int maxCoins(vector<int>& nums) {\\n                int c = nums.size();\\n                nums.insert(nums.begin(),1);\\n                nums.push_back(1);\\n                \\n                vector<vector<int>> dp(c+1,vector<int> (c+1,-1));\\n                return pre(1,c,nums,dp);\\n            }\\n        };\\n    \\n    // tab\\n        class Solution {\\n        public:\\n            int maxCoins(vector<int>& nums) {\\n                int c = nums.size();\\n                nums.insert(nums.begin(),1);\\n                nums.push_back(1);\\n                \\n                vector<vector<int>> dp(c+3,vector<int> (c+3,0)); // wrong declaration\\n                \\n                for(int i=c;i>=1;i--){ // wrong intialied for loop \\n                    for(int j=1;j<=c;j++){ // wrong intiated for loop\\n                        if(i > j) continue;\\n                        long mini = -1e9;\\n                        for(int ind=i;ind<=j;ind++){\\n                            long burst = nums[i-1]*nums[ind]*nums[j+1] + dp[i][ind-1]+ dp[ind+1][j];\\n                            mini = max(mini,burst);\\n                        }\\n                        dp[i][j] = mini;\\n                    }\\n                }\\n                \\n                return dp[1][c];\\n            }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512188,
                "title": "best-solution-easy-approch-from-scratch",
                "content": "# Memoisation : \\n```\\ndef f(i,j,arr,dp):\\n    if i>j:\\n        return 0\\n    if dp[i][j]!=-1:\\n        return dp[i][j]\\n    maxi=float(\"-inf\")\\n    for ind in range(i,j+1):\\n        cost=arr[i-1]*arr[ind]*arr[j+1]+f(i,ind-1,arr,dp)+f(ind+1,j,arr,dp)\\n        maxi=max(maxi,cost)\\n        dp[i][j]=maxi\\n    return dp[i][j]\\ndef maxCoins(nums: List[int]) -> int:\\n        n=len(nums)\\n        nums =[1]+nums+[1]\\n        dp=[[-1 for i in range(n+1)]for j in range(n+1)]\\n        return f(1,n,nums,dp)\\n```\\n# Tabulation :\\n```\\n    def maxCoins(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        nums =[1]+nums+[1]\\n        dp=[[0 for i in range(n+2)]for j in range(n+2)]\\n        for i in range(n,0,-1):\\n            for j in range(1,n+1):\\n                if i>j:\\n                    continue\\n                maxi=float(\"-inf\")\\n                for ind in range(i,j+1):\\n                    cost=nums[i-1]*nums[ind]*nums[j+1]+dp[i][ind-1]+dp[ind+1][j]\\n                    maxi=max(maxi,cost)\\n                dp[i][j]=maxi\\n        return dp[1][n]\\n```\\n# Upvote if you Liked",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef f(i,j,arr,dp):\\n    if i>j:\\n        return 0\\n    if dp[i][j]!=-1:\\n        return dp[i][j]\\n    maxi=float(\"-inf\")\\n    for ind in range(i,j+1):\\n        cost=arr[i-1]*arr[ind]*arr[j+1]+f(i,ind-1,arr,dp)+f(ind+1,j,arr,dp)\\n        maxi=max(maxi,cost)\\n        dp[i][j]=maxi\\n    return dp[i][j]\\ndef maxCoins(nums: List[int]) -> int:\\n        n=len(nums)\\n        nums =[1]+nums+[1]\\n        dp=[[-1 for i in range(n+1)]for j in range(n+1)]\\n        return f(1,n,nums,dp)\\n```\n```\\n    def maxCoins(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        nums =[1]+nums+[1]\\n        dp=[[0 for i in range(n+2)]for j in range(n+2)]\\n        for i in range(n,0,-1):\\n            for j in range(1,n+1):\\n                if i>j:\\n                    continue\\n                maxi=float(\"-inf\")\\n                for ind in range(i,j+1):\\n                    cost=nums[i-1]*nums[ind]*nums[j+1]+dp[i][ind-1]+dp[ind+1][j]\\n                    maxi=max(maxi,cost)\\n                dp[i][j]=maxi\\n        return dp[1][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1845115,
                "title": "top-down-python",
                "content": "```\\nclass Solution:\\n    \\n    @cache\\n    def dp(self, i, j):\\n        maximum = 0\\n        for k in range(i+1,j):\\n            current = self.nums[i] * self.nums[k] * self.nums[j]\\n            left = self.dp(i, k)\\n            right = self.dp(k, j)\\n            maximum = max(maximum, current + left + right)\\n        return maximum\\n    \\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        self.nums = nums\\n        res = self.dp(0, len(nums)-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\n    @cache\\n    def dp(self, i, j):\\n        maximum = 0\\n        for k in range(i+1,j):\\n            current = self.nums[i] * self.nums[k] * self.nums[j]\\n            left = self.dp(i, k)\\n            right = self.dp(k, j)\\n            maximum = max(maximum, current + left + right)\\n        return maximum\\n    \\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        self.nums = nums\\n        res = self.dp(0, len(nums)-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780635,
                "title": "java-dp-with-comments-fast",
                "content": "```\\nclass Solution {\\n    public int maxCoins(int[] arr) {\\n            int[][]dp=new int[arr.length][arr.length];\\n        \\n        //The initial 2 loops are to implement the gap strategy.\\n        for(int g=0;g<dp.length;g++){\\n        for(int i=0,j=g;j<dp.length;i++,j++){ \\n            \\n            int max=Integer.MIN_VALUE;\\n            \\n            //This internal loop is to iterate in the window and figure out the max.\\n            for(int k=i;k<=j;k++){\\n            int left=k == i?0:dp[i][k-1];\\n            int right=k == j?0:dp[k+1][j];\\n            int val=(i==0 ? 1: arr[i-1])*arr[k]*(j==arr.length-1?1:arr[j+1]);\\n            \\n            int total=left+right+val;\\n            if(total>max){\\n                max=total;\\n            }\\n        }\\n        dp[i][j]=max;\\n        }\\n       }\\n    \\n        return dp[0][dp.length-1];    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] arr) {\\n            int[][]dp=new int[arr.length][arr.length];\\n        \\n        //The initial 2 loops are to implement the gap strategy.\\n        for(int g=0;g<dp.length;g++){\\n        for(int i=0,j=g;j<dp.length;i++,j++){ \\n            \\n            int max=Integer.MIN_VALUE;\\n            \\n            //This internal loop is to iterate in the window and figure out the max.\\n            for(int k=i;k<=j;k++){\\n            int left=k == i?0:dp[i][k-1];\\n            int right=k == j?0:dp[k+1][j];\\n            int val=(i==0 ? 1: arr[i-1])*arr[k]*(j==arr.length-1?1:arr[j+1]);\\n            \\n            int total=left+right+val;\\n            if(total>max){\\n                max=total;\\n            }\\n        }\\n        dp[i][j]=max;\\n        }\\n       }\\n    \\n        return dp[0][dp.length-1];    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550436,
                "title": "java-easy-to-understand-with-explanation-tabulation-method-dynamic-programming",
                "content": "First of all, dp[i][j] in here means, the maximum coins we get after we burst all the balloons between i and j in the original array.\\n\\nFor example with input [3,1,5,8] :\\n\\ndp[0][0] means we burst ballons between [0,0], which means we only burst the first balloon in original array. So dp[0][0] is 1 * 3 * 1 = 3.\\n\\ndp[1][1] means we burst balloons between [1][1], which means we only burst the second ballon in the original array. So dp[1][1] is 3 * 1 * 5 = 15.\\n\\nSo in the end for this problem we want to find out dp[0][ arr.length - 1 ], which is the maximum value we can get when we burst all the balloon between [0 , length -1]\\n\\nTo get that we need the transition function :\\n\\nfor (int k = left; k <= right; ++k)\\ndp[left][right] = max(dp[left][right], nums[left-1] * nums[k] * nums[right+1] + dp[left][k-1] + dp[k+1][right])**\\n\\nThis transition function basically says in order to get the maximum value we can get for bursting all the balloons between [ i , j] , we just loop through each balloon between these two indexes and make them to be the last balloon to be burst,\\n\\nwhy we pick it as the last balloon to burst ?\\n\\nFor example when calculating dp[0,3] and picking index 2 as the last balloon to burst,\\n\\n[ 3 , 1 , 5 , 8] , that means 5 is the last balloon to burst between [0,3] , to get the maximum value when picking 5 as the last balloon to burst :\\n\\nmax = maximum value of bursting all the balloon on the left side of 5 + maximum value of bursting all the balloon on the right side of 5 + bursting balloon 5 when left side and right side are gone.\\n\\nThat is dp[0, 1] + nums[0 - 1] * nums[2] * nums[3 + 1] + + dp[3,3];\\n\\nThat is dp[left, k - 1] + nums[left - 1] * nums[k] * nums[right + 1] + dp[k+1, right] ;\\n\\nto get the maximum dp[left, right] we just loop through all the possible value of k to get the maximum.\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for(int g = 0;g<n;g++)\\n        {\\n            for(int i=0,j=g;j<n;i++,j++)\\n            {\\n                int max = Integer.MIN_VALUE;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    int left = (k == i ? 0 : dp[i][k-1]);\\n                    int right = (k == j ? 0 : dp[k+1][j]);\\n                    int val = (i == 0?1:nums[i-1]) * nums[k] * (j == n-1 ? 1 : nums[j+1]);\\n                    int total = left+right+val;\\n                    max = Math.max(total,max);\\n                }\\n                dp[i][j] = max;\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to undertand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for(int g = 0;g<n;g++)\\n        {\\n            for(int i=0,j=g;j<n;i++,j++)\\n            {\\n                int max = Integer.MIN_VALUE;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    int left = (k == i ? 0 : dp[i][k-1]);\\n                    int right = (k == j ? 0 : dp[k+1][j]);\\n                    int val = (i == 0?1:nums[i-1]) * nums[k] * (j == n-1 ? 1 : nums[j+1]);\\n                    int total = left+right+val;\\n                    max = Math.max(total,max);\\n                }\\n                dp[i][j] = max;\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503086,
                "title": "simple-matrix-chain-approach-dp",
                "content": "//Simply append 1 at front and ed of array\\n\\nclass Solution {\\n    \\n    int dp[][]=new int[502][502];\\n    public int maxCoins(int[] nums) {\\n        \\n        int nums2[]=new int[nums.length+2];\\n         \\n        nums2[0]=1;\\n            int m=0;\\n            for(int i=1;i<nums2.length-1;i++){\\n                nums2[i]=nums[m++];\\n            }\\n        nums2[nums2.length-1]=1;\\n        for(int i=0;i<502;i++){\\n            for(int j=0;j<502;j++){\\n                dp[i][j]=-1;\\n            }\\n                \\n        }\\n        \\n       return  solve(nums2,1,nums2.length-1);\\n        \\n    }\\n    \\n    public int solve(int nums[],int left,int right){\\n        if (left>=right){\\n            return 0;\\n        }\\n        if (dp[left][right]!=-1){\\n            return dp[left][right];\\n        }\\n        \\n         int ans=Integer.MIN_VALUE;\\n        for (int k=left;k<right;k++){\\n            int temp=solve(nums,left,k)+solve(nums,k+1,right)+nums[left-1]*nums[k]*nums[right];\\n            ans=Math.max(ans,temp);\\n        }\\n        return dp[left][right]=ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int dp[][]=new int[502][502];\\n    public int maxCoins(int[] nums) {\\n        \\n        int nums2[]=new int[nums.length+2];\\n         \\n        nums2[0]=1;\\n            int m=0;\\n            for(int i=1;i<nums2.length-1;i++){\\n                nums2[i]=nums[m++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1442558,
                "title": "matrix-chain-multiplication-memoized-easy-to-understand-credits-to-aditya-verma-the-legend",
                "content": "```\\n  int dp[505][505];\\n    int solve(vector<int> & nums, int i, int j)\\n    {\\n        if(i >= j) {\\n            return 0; \\n        }\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int curr_sum = INT_MIN;  \\n        \\n        for(int k = i; k < j; ++k){\\n            \\n            int temp = solve(nums, i, k) + solve(nums, k+1, j); \\n            int curr_val = nums[i-1] * nums[k] * nums[j] + temp;\\n            if(curr_val > curr_sum) {\\n                curr_sum = curr_val; \\n            }\\n        }\\n        return dp[i][j] = curr_sum; \\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        nums.insert(nums.begin(),1); \\n        nums.push_back(1);  \\n        return solve(nums, 1, nums.size()-1); \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n  int dp[505][505];\\n    int solve(vector<int> & nums, int i, int j)\\n    {\\n        if(i >= j) {\\n            return 0; \\n        }\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int curr_sum = INT_MIN;  \\n        \\n        for(int k = i; k < j; ++k){\\n            \\n            int temp = solve(nums, i, k) + solve(nums, k+1, j); \\n            int curr_val = nums[i-1] * nums[k] * nums[j] + temp;\\n            if(curr_val > curr_sum) {\\n                curr_sum = curr_val; \\n            }\\n        }\\n        return dp[i][j] = curr_sum; \\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        nums.insert(nums.begin(),1); \\n        nums.push_back(1);  \\n        return solve(nums, 1, nums.size()-1); \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272091,
                "title": "lessons-learned",
                "content": "**UPDATE**:\\n* LC has recently uploaded the solution to this problem which is of top quality. This itself is enough to solve this problem now.\\n* Teaches:\\n \\xA0  * the pattern of how a subsequent problem can be turned  into subarray problem.\\n \\xA0 * time complexity of subsequence(aka subsets) is always O(2^N) and subarray is always O(N\\xB2).\\n \\xA0 * Here, O(2^N) states in the first approach are the the non-overlapped subproblems in time complexity representation. Actual value/steps would be N!. If overlapped subproblems are also considered, then time complexity would be O(N^N). \\n \\xA0 * a combo of: DP + Divide Conquer + Thinking Backwards\\n\\n**ORIGINAL**:\\n**Concept**:\\n* Naive approach: is plain recursion of O(n!)\\n* Optimal approach: DP in O(n\\xB3)\\n \\xA0 * Approach the problem as **\"solve for array from i to j\"** and cache (i,j) value.\\n \\xA0 * **Pick the last cadidate**. This is what males the concept tricky since till now all DP problems had the pattern of pick first candidate. Where this is something like Post Order Traversal concept. Why last? Read below.\\n \\xA0 * **Solve left and right sub problems** recursively. (To solve these left and right sub problems, they should be independent, which wouldn\\'t have been the case if we had picked first candidate above. Reason: due to subarray order instead of subsequence order as in [Connect sticks](https://leetcode.com/problems/minimum-cost-to-connect-sticks) )\\n \\xA0 * What are the neighbours of `i` (or any element of the state (state = subarray defined by start and end) ): start - 1 and end + 1 (see image in approach\\'s link)\\n * Incorrect approach: Greedy\\nOne would first think greedily like [Connect sticks](https://leetcode.com/problems/minimum-cost-to-connect-sticks). But Burst Balloons has subarray format (i - 1, i, i + 1) and not subsequence format (where sort and then pick greedily was possible)\\n\\n**Approach**: [Click here](https://leetcode.com/problems/burst-balloons/discuss/892552/For-those-who-are-not-able-to-understand-any-solution-WITH-DIAGRAM?page=2)\\n\\n**Similar problems**:\\n* This is a variation of classic problem of Matrix Chain Multiplication from the book CLRS.\\n* https://leetcode.com/problems/minimum-cost-to-connect-sticks\\n* https://leetcode.com/problems/minimum-cost-to-merge-stones \\n* https://leetcode.com/problems/remove-boxes\\n* https://leetcode.com/problems/strange-printer\\n* I think the same approach can be used for the problem https://leetcode.com/problems/24-game\\n\\n**Code**: \\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        return f(nums, n, 0, n - 1, new int[n][n]);\\n    }\\n    \\n    private int f(int[]nums, int n, int start, int end, int[][] cache){\\n        // base\\n        if (start > end) return 0;\\n        // cache out\\n        if (cache[start][end] > 0) return cache[start][end];\\n        \\n        // recurse\\n        int max = 0;\\n        for (int i = start; i <= end; i++){\\n            int sum = 0;\\n            sum += f(nums, n, start, i - 1, cache);\\n            sum += f(nums, n, i + 1, end, cache);\\n            \\n            int prevNum = start == 0 ? 1 : nums[start - 1];\\n            int nextNum = end == n - 1 ? 1 : nums[end + 1];\\n            sum += prevNum * nums[i] * nextNum;\\n            \\n            max = Math.max(max, sum);\\n        }\\n        \\n        // cache in\\n        cache[start][end] = max;\\n        \\n        // return \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        return f(nums, n, 0, n - 1, new int[n][n]);\\n    }\\n    \\n    private int f(int[]nums, int n, int start, int end, int[][] cache){\\n        // base\\n        if (start > end) return 0;\\n        // cache out\\n        if (cache[start][end] > 0) return cache[start][end];\\n        \\n        // recurse\\n        int max = 0;\\n        for (int i = start; i <= end; i++){\\n            int sum = 0;\\n            sum += f(nums, n, start, i - 1, cache);\\n            sum += f(nums, n, i + 1, end, cache);\\n            \\n            int prevNum = start == 0 ? 1 : nums[start - 1];\\n            int nextNum = end == n - 1 ? 1 : nums[end + 1];\\n            sum += prevNum * nums[i] * nextNum;\\n            \\n            max = Math.max(max, sum);\\n        }\\n        \\n        // cache in\\n        cache[start][end] = max;\\n        \\n        // return \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230790,
                "title": "divide-conquer-w-memoization-explanation-javascript-js-es6",
                "content": "`Intuition:`\\n- Try each balloon as the last balloon to burst and compute max.\\n```\\nEXAMPLE: input [ 3 , 1 , 5 , 8] \\nLet\\'s say, if at any time 5 is the last balloon :\\nmax = max value on the left side of 5 + max value on the right side of 5 + value 5 with only 1s on its left and right\\n```\\n\\n `Algorithm:`\\n- Pad 1 at the beginning & end of the input array \\n- There are 3 values to be summed-up when a balloon is popped. \\n- With a for-loop try each balloon in input-array as last balloon. \\n-  Rember, each balloon is also the right and left ballon for the next level of recursion\\n- Base case: there is no balloon between two padded 1\\'s\\n- For memoisation, the cache is similar to problem  https://leetcode.com/problems/longest-palindromic-substring/. The idea is to compute answer for a given range by populating the matrix diagonally. That is, cache[i][j] is the maximum coins after bursting all the balloons between i and j .\\n```\\nEXAMPLE: input [3,1,5,8] :\\ncache[0][0]  is 1 * 3 * 1 = 3.\\ncache[1][1]  is 3 * 1 * 5 = 15.\\nThus, our answer is located at [0][ inputArray.length - 1 ];\\n```\\n\\n\\n```\\nconst maxCoins = function(balloons) {\\n  const auxArray = new Array(balloons.length+2).fill(null);\\n  let idx = 1;\\n  for (let balloonVal of balloons){\\n    if(balloonVal > 0) auxArray[idx++] = balloonVal;  \\n  } \\n  auxArray[0] = auxArray[idx++] = 1;\\n  const cache = Array.from({length: idx}, ()=>new Array(idx).fill([]));\\n  return burst(cache, auxArray, 0, idx - 1);\\n}\\n\\nfunction burst(cache, auxArray, left, right) {   \\n  if (left + 1 == right) return 0;\\n  if (cache[left][right] > 0) return cache[left][right];\\n  let max = 0;\\n  for (let idx = left + 1; idx < right; idx++)\\n      max = Math.max(max, auxArray[left] * auxArray[idx] * auxArray[right] \\n      + burst(cache, auxArray, left, idx) + burst(cache, auxArray, idx, right));\\n  cache[left][right] = max;\\n  return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nEXAMPLE: input [ 3 , 1 , 5 , 8] \\nLet\\'s say, if at any time 5 is the last balloon :\\nmax = max value on the left side of 5 + max value on the right side of 5 + value 5 with only 1s on its left and right\\n```\n```\\nEXAMPLE: input [3,1,5,8] :\\ncache[0][0]  is 1 * 3 * 1 = 3.\\ncache[1][1]  is 3 * 1 * 5 = 15.\\nThus, our answer is located at [0][ inputArray.length - 1 ];\\n```\n```\\nconst maxCoins = function(balloons) {\\n  const auxArray = new Array(balloons.length+2).fill(null);\\n  let idx = 1;\\n  for (let balloonVal of balloons){\\n    if(balloonVal > 0) auxArray[idx++] = balloonVal;  \\n  } \\n  auxArray[0] = auxArray[idx++] = 1;\\n  const cache = Array.from({length: idx}, ()=>new Array(idx).fill([]));\\n  return burst(cache, auxArray, 0, idx - 1);\\n}\\n\\nfunction burst(cache, auxArray, left, right) {   \\n  if (left + 1 == right) return 0;\\n  if (cache[left][right] > 0) return cache[left][right];\\n  let max = 0;\\n  for (let idx = left + 1; idx < right; idx++)\\n      max = Math.max(max, auxArray[left] * auxArray[idx] * auxArray[right] \\n      + burst(cache, auxArray, left, idx) + burst(cache, auxArray, idx, right));\\n  cache[left][right] = max;\\n  return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116682,
                "title": "javascript-top-down-and-bottom-up-dp-solution",
                "content": "For both solutions: Time: `O(N^3)` and Space: `O(N^2)`\\n## Solution 1: Top Down\\n```javascript\\nvar maxCoins = function(nums) {\\n    nums.push(1);\\n    nums.unshift(1);\\n    \\n    const memo = [...Array(nums.length)].map(() => Array(nums.length).fill(0));\\n    \\n    function split(start, end) {\\n        if(start > end) return 0\\n        if(memo[start][end]) return memo[start][end];\\n        \\n        let max = 0;\\n        \\n        for(let i = start; i <= end; i++) {\\n            const left = split(start, i-1);\\n            const right = split(i+1, end);\\n            const currBurst = nums[start-1] * nums[i] * nums[end+1]\\n            const coin = left + currBurst + right;\\n            max = Math.max(max, coin);\\n        }\\n        memo[start][end] = max;\\n        return max;\\n    }\\n    return split(1, nums.length-2)\\n};\\n```\\n\\n## Solution 2: Bottom Up\\n```javascript\\nvar maxCoins = function(nums) {\\n    nums.push(1);\\n    nums.unshift(1);\\n    const dp = [...Array(nums.length)].map(() => Array(nums.length).fill(0));\\n    \\n    for(let windowSize = 1; windowSize < nums.length-1; windowSize++) {\\n        for(let start = 1, end = windowSize; end < nums.length-1; end++, start++) {\\n            for(let i = start; i <= end; i++) {\\n                const coins = dp[start][i-1] + (nums[start-1] * nums[i] * nums[end+1]) + dp[i+1][end];\\n                dp[start][end] = Math.max(dp[start][end], coins);\\n            }\\n        }\\n    }\\n    return dp[1][nums.length-2]\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar maxCoins = function(nums) {\\n    nums.push(1);\\n    nums.unshift(1);\\n    \\n    const memo = [...Array(nums.length)].map(() => Array(nums.length).fill(0));\\n    \\n    function split(start, end) {\\n        if(start > end) return 0\\n        if(memo[start][end]) return memo[start][end];\\n        \\n        let max = 0;\\n        \\n        for(let i = start; i <= end; i++) {\\n            const left = split(start, i-1);\\n            const right = split(i+1, end);\\n            const currBurst = nums[start-1] * nums[i] * nums[end+1]\\n            const coin = left + currBurst + right;\\n            max = Math.max(max, coin);\\n        }\\n        memo[start][end] = max;\\n        return max;\\n    }\\n    return split(1, nums.length-2)\\n};\\n```\n```javascript\\nvar maxCoins = function(nums) {\\n    nums.push(1);\\n    nums.unshift(1);\\n    const dp = [...Array(nums.length)].map(() => Array(nums.length).fill(0));\\n    \\n    for(let windowSize = 1; windowSize < nums.length-1; windowSize++) {\\n        for(let start = 1, end = windowSize; end < nums.length-1; end++, start++) {\\n            for(let i = start; i <= end; i++) {\\n                const coins = dp[start][i-1] + (nums[start-1] * nums[i] * nums[end+1]) + dp[i+1][end];\\n                dp[start][end] = Math.max(dp[start][end], coins);\\n            }\\n        }\\n    }\\n    return dp[1][nums.length-2]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1092449,
                "title": "do-this-thing-if-your-python-dp-o-n3-solution-tle",
                "content": "You can also easy find O(N3) DP solutions and explanation in top votes post. With constraint N = 500, it should work well but when I submit, my solution TLE, I also checked some other python solution on top votes post, TLE too. \\nTo overcome TLE, you can check the edge case when all elements in array are the same:\\n```\\nif len(nums) == 1:\\n\\treturn nums[0]\\n\\nif len(set(nums)) == 1:  # edge case when all elements are the same\\n\\treturn nums[0] ** 3 * (N - 2) + nums[0] ** 2 + nums[0]\\n```\\n\\nFull demo code:\\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        if N == 1:\\n            return nums[0]\\n        \\n        if len(set(nums)) == 1:  # edge case when all elements are the same\\n            return nums[0] ** 3 * (N - 2) + nums[0] ** 2 + nums[0]\\n        \\n        nums = [1] + nums + [1]\\n        dp = [[0 for _ in range (N + 2)] for _ in range (N + 2)]\\n        \\n        for window_size in range(1, N + 1):\\n            for left in range (1, N - window_size + 2):\\n                right = left + window_size - 1\\n                for i in range (left, right + 1):\\n                    dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\\n                    \\n        return dp[1][N]\\n```",
                "solutionTags": [],
                "code": "```\\nif len(nums) == 1:\\n\\treturn nums[0]\\n\\nif len(set(nums)) == 1:  # edge case when all elements are the same\\n\\treturn nums[0] ** 3 * (N - 2) + nums[0] ** 2 + nums[0]\\n```\n```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        if N == 1:\\n            return nums[0]\\n        \\n        if len(set(nums)) == 1:  # edge case when all elements are the same\\n            return nums[0] ** 3 * (N - 2) + nums[0] ** 2 + nums[0]\\n        \\n        nums = [1] + nums + [1]\\n        dp = [[0 for _ in range (N + 2)] for _ in range (N + 2)]\\n        \\n        for window_size in range(1, N + 1):\\n            for left in range (1, N - window_size + 2):\\n                right = left + window_size - 1\\n                for i in range (left, right + 1):\\n                    dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\\n                    \\n        return dp[1][N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017626,
                "title": "python-accepted-detailed-explanation-dhruv-vavliya",
                "content": "```\\n# written By : Dhruv vavliya\\n\\'\\'\\'\\n   SLIDING WINDOW WITH DP ALGORITHM\\n\\nstatement :-\\n     1. ballons with coins\\n     2. burst all ballons with wisly\\n        coins gain : A[i-1]*A[i]*A{i+1]  => max coins\\n\\nassumption :-\\n    1. consider 4 - at last ballon (1,2,3,5,6 ballons busted)\\n    2. maximum coins :-\\n            left + 1*4*6 + right\\n            (1,2,3)          (5,6)\\n\\n               *  *  *   @    *  *\\n          1|   1  2  3   4    5  6  |1\\n               =======        ====\\n                  left        right\\n\\'\\'\\'\\n\\n# accepted in python\\ndef solution(nums):\\n    nums = [1]+nums+[1]\\n    dp = [ [0]*len(nums) for _ in range(len(nums)) ]\\n\\n    for window in range(3,len(nums)+1):                           # take all sized windows 3 to N (includes 1__1)\\n        for left in range(len(nums)-window+1):                    # define window left\\n            right = left + window - 1                             # define windoe right\\n            for last in range(left+1,right):                      # considered last element iterate from left to right\\n                dp[left][right] = max( dp[left][right] , dp[left][last] + nums[left]*nums[last]*nums[right]+ dp[last][right] )\\n    return dp[0][len(nums)-1]\\n\\n\\n# time limit exceeded in python\\n# dynamic programming\\n# easy to understand\\ndef burst_ballon(nums):\\n    import numpy as np\\n    n = len(nums)\\n    nums = [1]+nums+[1]\\n    dp = np.full((len(nums),len(nums)) ,0)\\n\\n    for window in range(2,n+1):                         # take all sized windows 1 to N\\n        left_end = n-window+1\\n        for left in range(1,left_end+1):                       # define window left\\n            right = left + window - 1                              # define windoe right\\n            for last in range(left ,right+1):                      # considered last element iterate from left to right\\n                score = nums[left-1]*nums[last]*nums[right+1]\\n                dp[left][right] = max( dp[left][right] ,dp[left][last-1] + score + dp[last+1][right] )\\n\\n    return dp[1][n]\\n\\n\\n\\n# time limit exceeded on last case in python\\ndef go(nums,left,right,dp):\\n\\n    if right == left+1:\\n        dp[left][right] = 0\\n        return 0\\n    if dp[left][right] != -1:\\n        return dp[left][right]\\n\\n    ans=0\\n    for i in range(left+1,right):\\n        score = nums[left]*nums[i]*nums[right]     # always think about general case\\n        ans = max(ans ,go(nums,left,i,dp) + score + go(nums,i,right,dp) )\\n    dp[left][right] = ans\\n    return ans\\n\\ndef max_coin(nums):\\n    import numpy as np\\n    nums = [1]+nums+[1]\\n    dp = np.full((len(nums) + 1, len(nums) + 1), -1)\\n    return go(nums,0,len(nums)-1,dp)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n# written By : Dhruv vavliya\\n\\'\\'\\'\\n   SLIDING WINDOW WITH DP ALGORITHM\\n\\nstatement :-\\n     1. ballons with coins\\n     2. burst all ballons with wisly\\n        coins gain : A[i-1]*A[i]*A{i+1]  => max coins\\n\\nassumption :-\\n    1. consider 4 - at last ballon (1,2,3,5,6 ballons busted)\\n    2. maximum coins :-\\n            left + 1*4*6 + right\\n            (1,2,3)          (5,6)\\n\\n               *  *  *   @    *  *\\n          1|   1  2  3   4    5  6  |1\\n               =======        ====\\n                  left        right\\n\\'\\'\\'\\n\\n# accepted in python\\ndef solution(nums):\\n    nums = [1]+nums+[1]\\n    dp = [ [0]*len(nums) for _ in range(len(nums)) ]\\n\\n    for window in range(3,len(nums)+1):                           # take all sized windows 3 to N (includes 1__1)\\n        for left in range(len(nums)-window+1):                    # define window left\\n            right = left + window - 1                             # define windoe right\\n            for last in range(left+1,right):                      # considered last element iterate from left to right\\n                dp[left][right] = max( dp[left][right] , dp[left][last] + nums[left]*nums[last]*nums[right]+ dp[last][right] )\\n    return dp[0][len(nums)-1]\\n\\n\\n# time limit exceeded in python\\n# dynamic programming\\n# easy to understand\\ndef burst_ballon(nums):\\n    import numpy as np\\n    n = len(nums)\\n    nums = [1]+nums+[1]\\n    dp = np.full((len(nums),len(nums)) ,0)\\n\\n    for window in range(2,n+1):                         # take all sized windows 1 to N\\n        left_end = n-window+1\\n        for left in range(1,left_end+1):                       # define window left\\n            right = left + window - 1                              # define windoe right\\n            for last in range(left ,right+1):                      # considered last element iterate from left to right\\n                score = nums[left-1]*nums[last]*nums[right+1]\\n                dp[left][right] = max( dp[left][right] ,dp[left][last-1] + score + dp[last+1][right] )\\n\\n    return dp[1][n]\\n\\n\\n\\n# time limit exceeded on last case in python\\ndef go(nums,left,right,dp):\\n\\n    if right == left+1:\\n        dp[left][right] = 0\\n        return 0\\n    if dp[left][right] != -1:\\n        return dp[left][right]\\n\\n    ans=0\\n    for i in range(left+1,right):\\n        score = nums[left]*nums[i]*nums[right]     # always think about general case\\n        ans = max(ans ,go(nums,left,i,dp) + score + go(nums,i,right,dp) )\\n    dp[left][right] = ans\\n    return ans\\n\\ndef max_coin(nums):\\n    import numpy as np\\n    nums = [1]+nums+[1]\\n    dp = np.full((len(nums) + 1, len(nums) + 1), -1)\\n    return go(nums,0,len(nums)-1,dp)\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 977911,
                "title": "how-i-solved-it",
                "content": "\\nIf we choose which balloon we intend to pop _last_, then this balloon forms a barrier between the balloons to the left and right of it. This makes the problem of popping the balloons to the left _independent_ of the problem of popping the balloons to the right. This means we have broken the problem into two independent subproblems.\\n\\n```text\\n              pop this one last\\n              v\\n \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88\\n|-----------|   |-----------|\\n subproblem      subproblem\\n```\\n\\nEach subproblem can be distinguished by four parameters:\\n* The start and stop indices that define the range of balloons in the subproblem.\\n* The values of the two \"sentinel\" balloons, which guard either end of the range. Each of these may be one of the imaginary balloons from the problem description, with value 1, or a balloon which we are waiting to pop afterwards.\\n\\nHow should we choose which balloon to pop last? Maybe there\\'s a smart way to make this choice, but for now let\\'s just try all possibilities.\\n\\nWhen we do finally pop the last balloon, we don\\'t need to consider any other balloon in the range (as they have all been popped). We only need the values of the sentinel balloons to the left and right of the range.\\n\\nThe base-case is an empty range, which provides zero coins.\\n\\n```python\\nclass Solution:\\n    \\n    def maxCoins(self, nums):\\n        \\n        @functools.cache\\n        def foo(start, stop, left, right):\\n            if start == stop:\\n                return 0\\n            return max(\\n                left * nums[i] * right \\n                + foo(start, i, left, nums[i])\\n                + foo(i+1, stop, nums[i], right)\\n                for i in range(start, stop)\\n            )\\n        \\n        return foo(0, len(nums), 1, 1)\\n```\\n\\nWhat is the runtime-complexity? Memoization reduces the runtime to the number of subproblems multiplied by the time taken per subproblem. The indices `start` and `stop` each fall in the range `0-N`, and the sentinels `left` and `right` fall in the range `0-M`, where `N` is the length of `nums` and `M` is the maximum allowed value of a balloon. There are on the order of up-to `N` steps per subproblem. Therefore the runtime is `O(N^3 * M^2)`.\\n\\n*Edit:* Having looked at other answers, I realise now that the values of `left` and `right` are uniquely determined by the values of `start` and `stop`, so the run time is actually `O(N^3)`.",
                "solutionTags": [],
                "code": "```text\\n              pop this one last\\n              v\\n \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88 \\uD83C\\uDF88\\n|-----------|   |-----------|\\n subproblem      subproblem\\n```\n```python\\nclass Solution:\\n    \\n    def maxCoins(self, nums):\\n        \\n        @functools.cache\\n        def foo(start, stop, left, right):\\n            if start == stop:\\n                return 0\\n            return max(\\n                left * nums[i] * right \\n                + foo(start, i, left, nums[i])\\n                + foo(i+1, stop, nums[i], right)\\n                for i in range(start, stop)\\n            )\\n        \\n        return foo(0, len(nums), 1, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971365,
                "title": "c-dp",
                "content": "```\\nclass Solution { // BEST: DP; Time/Space:  O(N^3)\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        const int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);        \\n        //vector<vector<int> > d(n+2, vector<int>(n+2, 0));\\n        //constexpr int len = 500;\\n        const int len = 500;\\n        int d[len+2][len+2]={0};   // quick to code     \\n        for(int l = 1; l <= n; l++)\\n            //for(int i = 1; i <= n -l + 1; i++){\\n            for(int i = 1; i + l - 1 <= n; i++){\\n                int j = i + l - 1; // j-i == l - 1\\n                for(int k = i; k <= j; k++)\\n                    d[i][j] = max(d[i][j], d[i][k-1] + nums[i-1]*nums[k]*nums[j+1] + d[k+1][j]  );                \\n            }        \\n        return d[1][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // BEST: DP; Time/Space:  O(N^3)\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        const int n = nums.size();\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);        \\n        //vector<vector<int> > d(n+2, vector<int>(n+2, 0));\\n        //constexpr int len = 500;\\n        const int len = 500;\\n        int d[len+2][len+2]={0};   // quick to code     \\n        for(int l = 1; l <= n; l++)\\n            //for(int i = 1; i <= n -l + 1; i++){\\n            for(int i = 1; i + l - 1 <= n; i++){\\n                int j = i + l - 1; // j-i == l - 1\\n                for(int k = i; k <= j; k++)\\n                    d[i][j] = max(d[i][j], d[i][k-1] + nums[i-1]*nums[k]*nums[j+1] + d[k+1][j]  );                \\n            }        \\n        return d[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970834,
                "title": "c-simple-dp-solution",
                "content": "Explaination  will be added later :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        vector<int> num{1};\\n        num.insert(num.end(), nums.begin(), nums.end());\\n        num.push_back(1);\\n        int sz = num.size();\\n        vector<vector<int>> dp(sz, vector<int>(sz));\\n        for(int i=2;i<sz;++i){\\n            for(int j=i-1;j>=1;--j){\\n                for(int k=j-1;k>=0;--k){\\n                    dp[k][i] = max(dp[k][i], num[k]*num[j]*num[i]+dp[k][j]+dp[j][i]);\\n                }\\n            }\\n        }\\n        return dp[0][sz-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        vector<int> num{1};\\n        num.insert(num.end(), nums.begin(), nums.end());\\n        num.push_back(1);\\n        int sz = num.size();\\n        vector<vector<int>> dp(sz, vector<int>(sz));\\n        for(int i=2;i<sz;++i){\\n            for(int j=i-1;j>=1;--j){\\n                for(int k=j-1;k>=0;--k){\\n                    dp[k][i] = max(dp[k][i], num[k]*num[j]*num[i]+dp[k][j]+dp[j][i]);\\n                }\\n            }\\n        }\\n        return dp[0][sz-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629567,
                "title": "c-top-down-dp-with-logic-explained",
                "content": "The brute force logic will be pick an element, multiply it with it\\'s predecessor and successor, then remove it from the array, recursively do this for all elements in a given array and thus finding the maximum.\\nIn DP, what we do is we fix the boundaries lval,rval then look at the sub arrays between those indices(both exclusive) which gives the maximum value and  store them. When we pick an index i between left and right, the new boundary values become (lval,nums[i]) and (nums[i],rval) for the new sub arrays formed respectively.\\n```\\nvector<vector<int>> memo;\\nint dp(vector<int>& nums,int left, int right)\\n{\\n\\tif(left<0||right>=nums.size()||left>right)\\n\\t\\treturn 0;\\n\\tif(memo[left][right]!=-1)\\n\\t\\treturn memo[left][right];\\n\\tint q=INT_MIN;\\n\\tfor(int i=left;i<=right;++i)\\n\\t{\\n\\t\\tint lval=left-1<0?1:nums[left-1];\\n\\t\\tint rval=right+1>=nums.size()?1:nums[right+1];\\n\\t\\tq=max(q,nums[i]*lval*rval+dp(nums,left,i-1)+dp(nums,i+1,right));\\n\\t}\\n\\treturn memo[left][right]=q;\\n}\\nint maxCoins(vector<int>& nums)\\n{\\n\\tmemo.resize(nums.size(),vector<int>(nums.size(),-1));\\n\\treturn dp(nums,0,nums.size()-1);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> memo;\\nint dp(vector<int>& nums,int left, int right)\\n{\\n\\tif(left<0||right>=nums.size()||left>right)\\n\\t\\treturn 0;\\n\\tif(memo[left][right]!=-1)\\n\\t\\treturn memo[left][right];\\n\\tint q=INT_MIN;\\n\\tfor(int i=left;i<=right;++i)\\n\\t{\\n\\t\\tint lval=left-1<0?1:nums[left-1];\\n\\t\\tint rval=right+1>=nums.size()?1:nums[right+1];\\n\\t\\tq=max(q,nums[i]*lval*rval+dp(nums,left,i-1)+dp(nums,i+1,right));\\n\\t}\\n\\treturn memo[left][right]=q;\\n}\\nint maxCoins(vector<int>& nums)\\n{\\n\\tmemo.resize(nums.size(),vector<int>(nums.size(),-1));\\n\\treturn dp(nums,0,nums.size()-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481264,
                "title": "easy-top-down-and-bottom-up-solution-python-n-3",
                "content": "\\tdef bottom_up(A):\\n\\t    \\n\\t    if not A:\\n\\t        return 0\\n\\t    \\n\\t    nums = [1] + A + [1]\\n\\t    \\n\\t    n = len(nums)\\n\\t    \\n\\t    dp = [[0]*(n) for _ in range(n)]\\n\\n\\t    for L in reversed(range(n)):\\n\\t        for R in range(L,n):\\n\\t            for i in range(L+1,R):\\n\\t                dp[L][R] = max(dp[L][R], nums[L] * nums[i] * nums[R] + \\n\\t                                            dp[L][i] + dp[i][R])\\n\\t                    \\n\\t        \\n\\t    return dp[0][n-1]\\n\\t        \\n\\tdef recursion(A):\\n\\t    nums = [1] + A + [1]\\n\\t    \\n\\t    from functools import lru_cache\\n\\n\\t    @lru_cache(None)\\n\\t    def recurse(left, right):\\n\\n\\t        if right - left < 2:\\n\\t            ans = 0\\n\\n\\t        else:\\n\\t            ans = 0\\n\\t            for i in range(left + 1, right):\\n\\t                cost = nums[left] * nums[i] * nums[right]\\n\\n\\t                ans = max(ans, cost + \\n\\t                          recurse(left,i) + recurse(i,right))\\n\\n\\n\\t        return ans\\n\\t    return recurse(0,len(nums)-1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "\\tdef bottom_up(A):\\n\\t    \\n\\t    if not A:\\n\\t        return 0\\n\\t    \\n\\t    nums = [1] + A + [1]\\n\\t    \\n\\t    n = len(nums)\\n\\t    \\n\\t    dp = [[0]*(n) for _ in range(n)]\\n\\n\\t    for L in reversed(range(n)):\\n\\t        for R in range(L,n):\\n\\t            for i in range(L+1,R):\\n\\t                dp[L][R] = max(dp[L][R], nums[L] * nums[i] * nums[R] + \\n\\t                                            dp[L][i] + dp[i][R])\\n\\t                    \\n\\t        \\n\\t    return dp[0][n-1]\\n\\t        \\n\\tdef recursion(A):\\n\\t    nums = [1] + A + [1]\\n\\t    \\n\\t    from functools import lru_cache\\n\\n\\t    @lru_cache(None)\\n\\t    def recurse(left, right):\\n\\n\\t        if right - left < 2:\\n\\t            ans = 0\\n\\n\\t        else:\\n\\t            ans = 0\\n\\t            for i in range(left + 1, right):\\n\\t                cost = nums[left] * nums[i] * nums[right]\\n\\n\\t                ans = max(ans, cost + \\n\\t                          recurse(left,i) + recurse(i,right))\\n\\n\\n\\t        return ans\\n\\t    return recurse(0,len(nums)-1)",
                "codeTag": "Python3"
            },
            {
                "id": 473230,
                "title": "backtrack-solution-correct-tle",
                "content": "```\\nclass Solution {\\nint max = 0;\\n    public int maxCoins(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        } \\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int x: nums){\\n            list.add(x);\\n        }\\n        backtrack(list, 0);\\n        return max;\\n    }\\n    \\n    private void backtrack(List<Integer> temp, int curCount){\\n        if(temp.isEmpty()){\\n            max = Math.max(curCount, max);\\n        } else {\\n            int n = temp.size();\\n            for(int i = 0; i < n; i++){\\n                if(i == 0){\\n                    int tempInt = temp.remove(0);\\n                    if(n - 1 == 0){\\n                        backtrack(temp, curCount + tempInt);\\n                    } else {\\n                        backtrack(temp, curCount + tempInt * temp.get(0));\\n                    } \\n                    temp.add(0, tempInt);\\n                } else if(i == n - 1){\\n                    int tempInt = temp.remove(n - 1);\\n                    backtrack(temp, curCount + temp.get(n - 2) * tempInt);\\n                    temp.add(n - 1, tempInt);\\n                } else { \\n                    int tempInt = temp.remove(i);\\n                    backtrack(temp, curCount + tempInt * temp.get(i - 1) * temp.get(i));\\n                    temp.add(i, tempInt);\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\nThis solution never cache the intermediate results, thats why it gets TLE\\n\\nHowever it is a correct solution.",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nint max = 0;\\n    public int maxCoins(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        } \\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int x: nums){\\n            list.add(x);\\n        }\\n        backtrack(list, 0);\\n        return max;\\n    }\\n    \\n    private void backtrack(List<Integer> temp, int curCount){\\n        if(temp.isEmpty()){\\n            max = Math.max(curCount, max);\\n        } else {\\n            int n = temp.size();\\n            for(int i = 0; i < n; i++){\\n                if(i == 0){\\n                    int tempInt = temp.remove(0);\\n                    if(n - 1 == 0){\\n                        backtrack(temp, curCount + tempInt);\\n                    } else {\\n                        backtrack(temp, curCount + tempInt * temp.get(0));\\n                    } \\n                    temp.add(0, tempInt);\\n                } else if(i == n - 1){\\n                    int tempInt = temp.remove(n - 1);\\n                    backtrack(temp, curCount + temp.get(n - 2) * tempInt);\\n                    temp.add(n - 1, tempInt);\\n                } else { \\n                    int tempInt = temp.remove(i);\\n                    backtrack(temp, curCount + tempInt * temp.get(i - 1) * temp.get(i));\\n                    temp.add(i, tempInt);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468038,
                "title": "accepted-c-dp-solution-easy-to-understand",
                "content": "Ported to C# from [C++ solution](https://leetcode.com/problems/burst-balloons/discuss/464719/C%2B%2B-SIMPLE-EASY-DP-SOLUTION)\\n\\n```\\npublic class Solution {\\n    public int MaxCoins(int[] onums)\\n    {\\n        int n = onums.Length;\\n        List<int> nums = new List<int>();\\n        nums.Add(1);\\n        nums.AddRange(onums);\\n        nums.Add(1);\\n        \\n        int[][] dp = new int[n + 2][];\\n        for (int i = 0; i < n + 2; i++)\\n            dp[i] = new int[n + 2];        \\n        \\n        for (int len = 1; len <= n; ++len)\\n        {\\n            for (int left = 1; left <= n - len + 1; ++left)\\n            {\\n                int right = left + len - 1;\\n                for (int k = left; k <= right; ++k)\\n                    dp[left][right] = Math.Max(dp[left][right], nums[left - 1] * nums[k] * nums[right + 1] + dp[left][k - 1] + dp[k + 1][right]);\\n            }            \\n        }\\n        \\n        return dp[1][n];\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxCoins(int[] onums)\\n    {\\n        int n = onums.Length;\\n        List<int> nums = new List<int>();\\n        nums.Add(1);\\n        nums.AddRange(onums);\\n        nums.Add(1);\\n        \\n        int[][] dp = new int[n + 2][];\\n        for (int i = 0; i < n + 2; i++)\\n            dp[i] = new int[n + 2];        \\n        \\n        for (int len = 1; len <= n; ++len)\\n        {\\n            for (int left = 1; left <= n - len + 1; ++left)\\n            {\\n                int right = left + len - 1;\\n                for (int k = left; k <= right; ++k)\\n                    dp[left][right] = Math.Max(dp[left][right], nums[left - 1] * nums[k] * nums[right + 1] + dp[left][k - 1] + dp[k + 1][right]);\\n            }            \\n        }\\n        \\n        return dp[1][n];\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449270,
                "title": "my-understanding-of-the-solution",
                "content": "**Thanks to most-voted answer: \"Share some analysis and explanations\", I finianlly solve this problem.**\\n\\nHowever, after reading the explaination and code, it still took me like a whole day to really understand why this could work. I\\'m going to record and share the process of how I got to the point.\\n\\n## Code ##\\n\\tclass Solution:\\n\\t\\tdef maxCoins(self, nums: List[int]) -> int:\\n\\t\\t\\tif not nums:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tnums = [1]+nums+[1]\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tdp = [[0]*n for _ in range(n)]\\n        \\n\\t\\t\\tfor window in range(2, n):\\n\\t\\t\\t\\tfor left in range(0, n-window):\\n\\t\\t\\t\\t\\tright = left + window\\n\\t\\t\\t\\t\\tfor balloon in range(left+1, right):\\n\\t\\t\\t\\t\\t\\tdp[left][right] = max(dp[left][right], nums[left]*nums[balloon]*nums[right]+dp[left][balloon]+dp[balloon][right])\\n\\t\\t\\treturn dp[0][n-1]\\n\\n## Variable\\n**nums:** nums is the list of bulloons with its value (add value 1 balloon to the head and tail of the list)\\n**n:** n is the the length of value-1-added list. \\n**dp:** dp (dynamic programming) is the key to understand this solution. dp is a 2-dimention list, the meaning of whose content is the most coins one can receive between left bar and right bar. Note that the return value is **dp[0][n-1]**, which means the return value is the \"most coins you can get between the first balloon (imaginary value-1), and the last balloon (imaginary value-1)\".  I will talk about how to calculate value of a single cell of dp later.\\n**window:** window is a variable representing how much the distance between the left and right bar ( which is \\'k\\' in the original answer, but to me, \\'window\\' makes more senses). The size of window grows from 2 to n-1; when window size is 2, it means only 1 balloon is between left bar and right bar, while when window size is n-1, all balloons are included.\\n**left, right:** these 2 variables are the bar ( or the adjacent balloons of the next-to-burst balloon). They are used to calculate value of a cell of dp. No matter how far it is between left and right, when looping through all balloons between left and right, you should think that the balloon between left and right is the last one to burst. According to the definition, the distance between left and right is fixed for each window size.\\n**balloon:** is the ballon to burst between left and right bar ( which is \\'i\\' in the original answer). When the balloon is burst, you can get **nums[left] * nums[balloon] * nums[right]** coins ( from bursting that particular balloon. Will get to the **dp[left][balloon]** and **dp[balloon][right]** later).\\n\\n## Process\\n#### The basic idea of the solution is Divide and Conquer\\nLike what stated in the original answer, we can only make sure the neighbor balloons of a balloon to burst is the very first 1 and the last balloon to burst. When a balloon is burst, it disappears, and its 2 adjacent neighbors will become neighbors; so it is impossible for us to divive the problem in a normal way ( divide the problem from the first balloon to burst to the last one). However , if we divide the problem backward, meaning from the last balloon to burst to the first one, then we are dividing the whole problem into small sub-problems. \\nWhen it comes to the last balloon, what do I get by bursting that balloon alone? **1 * nums[i] * 1**, where i is the index of the last balloon. We don\\'t need to worry about what its neighbors are. However, because it gets to the last balloon, all the balloons on both sides of that last balloon (i) have been burst. Apparently, we should have got the coins from bursting the balloons on the left of ith balloon (**dp[left][i]**) and on the right of the ith balloon (**dp[i][right]**). \\nSee? We divide the problem into 2 small sub-problems: how to get value of **dp[left][i]** and **dp[i][right]**. For me, at first, the most difficult part to understand is that after we divide the problem, both the left and right part are kind of losing the contribute of the ith balloon. However, note the 2 sub-problems, **dp[left][i]** and **dp[i][right]**, one of their bar (bondary) is the ith balloon. **Value of the bars will contribute to the value of dp[left][right].** So the value of ith balloon is also included inthe sub-problems of left and right side. (NOTE: the 1-value balloons we added in the beginning and end of the list won\\'t affect the result, because 1 * n = n).\\nTherefore, the total coins we can get from bursting a balloon ***i*** between balloon ***left*** and balloon ***right*** is: \\n**dp[left][right] = nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]**\\nAnd we just need to find the largest value of dp[left][right]:\\n**dp[left][right] = max( dp[left][right] , nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])**\\nThe reason why we need to get the max of dp[left][right] is that we need to loop through all balloons (i) between left and righ (exclusive).\\n\\n1. First, we need to prepare for the \\'nums\\' list, by adding \\'1\\' in the beginning and end of the original \\'nums\\' list. By doing this, we actually add the imaginary value-1 balloons to the list, which will help use due will the bondary balloons.\\n2. Then initialize the dp with n rows, in which there are n 0s.\\n3. Then start the loop with window first. The minimum size of a window is 2 ( only 1 balloon between bars), and the maximum size of a window is n-1, which contains the whole \\'nums\\' list.\\n4. Start moving the left bar from 0 to n-window, and set the right bar as **left + window**. By doing this, we can cover all possibilities from the first (imaginary) balloon, as left bar, to the last one, as right bar, for all the window size. When left = n-window-1, the corresponding right bar will be n-1.\\n5. Then calculate each singe balloon between the left and right bar (exclusive). Note here, no matter how many balloons are there between the left and right bar, the results of each calculation will be compared, and the largest will be saved in dp[left][right]. In other words, dp[left][right] is the largest value among the balloons between left and right bars. \\n6. As we discussed above, the accumulated coins one can get from bursting a balloon between left and right bar is: **nums[left] * nums[balloon] * nums[right] + bp[left][balloon] + bp[balloon][right]**\\n7. By looking at the code above, we should know that the code actually calculates the smaller size windows first, then when calculating the larger size windows, we can use the saved most coins one can get from the smaller window (as the left and right sections of the burst balloon).\\n8. Then after looping through all the windows, we can get the result as dp[0][n-1]\\n\\nAs the original answer states, the solution can be improved by removing all the 0-value balloons at first.\\n",
                "solutionTags": [],
                "code": "**Thanks to most-voted answer: \"Share some analysis and explanations\", I finianlly solve this problem.**\\n\\nHowever, after reading the explaination and code, it still took me like a whole day to really understand why this could work. I\\'m going to record and share the process of how I got to the point.\\n\\n## Code ##\\n\\tclass Solution:\\n\\t\\tdef maxCoins(self, nums: List[int]) -> int:\\n\\t\\t\\tif not nums:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tnums = [1]+nums+[1]\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tdp = [[0]*n for _ in range(n)]\\n        \\n\\t\\t\\tfor window in range(2, n):\\n\\t\\t\\t\\tfor left in range(0, n-window):\\n\\t\\t\\t\\t\\tright = left + window\\n\\t\\t\\t\\t\\tfor balloon in range(left+1, right):\\n\\t\\t\\t\\t\\t\\tdp[left][right] = max(dp[left][right], nums[left]*nums[balloon]*nums[right]+dp[left][balloon]+dp[balloon][right])\\n\\t\\t\\treturn dp[0][n-1]\\n\\n## Variable\\n**nums:** nums is the list of bulloons with its value (add value 1 balloon to the head and tail of the list)\\n**n:** n is the the length of value-1-added list. \\n**dp:** dp (dynamic programming) is the key to understand this solution. dp is a 2-dimention list, the meaning of whose content is the most coins one can receive between left bar and right bar. Note that the return value is **dp[0][n-1]**, which means the return value is the \"most coins you can get between the first balloon (imaginary value-1), and the last balloon (imaginary value-1)\".  I will talk about how to calculate value of a single cell of dp later.\\n**window:** window is a variable representing how much the distance between the left and right bar ( which is \\'k\\' in the original answer, but to me, \\'window\\' makes more senses). The size of window grows from 2 to n-1; when window size is 2, it means only 1 balloon is between left bar and right bar, while when window size is n-1, all balloons are included.\\n**left, right:** these 2 variables are the bar ( or the adjacent balloons of the next-to-burst balloon). They are used to calculate value of a cell of dp. No matter how far it is between left and right, when looping through all balloons between left and right, you should think that the balloon between left and right is the last one to burst. According to the definition, the distance between left and right is fixed for each window size.\\n**balloon:** is the ballon to burst between left and right bar ( which is \\'i\\' in the original answer). When the balloon is burst, you can get **nums[left] * nums[balloon] * nums[right]** coins ( from bursting that particular balloon. Will get to the **dp[left][balloon]** and **dp[balloon][right]** later).\\n\\n## Process\\n#### The basic idea of the solution is Divide and Conquer\\nLike what stated in the original answer, we can only make sure the neighbor balloons of a balloon to burst is the very first 1 and the last balloon to burst. When a balloon is burst, it disappears, and its 2 adjacent neighbors will become neighbors; so it is impossible for us to divive the problem in a normal way ( divide the problem from the first balloon to burst to the last one). However , if we divide the problem backward, meaning from the last balloon to burst to the first one, then we are dividing the whole problem into small sub-problems. \\nWhen it comes to the last balloon, what do I get by bursting that balloon alone? **1 * nums[i] * 1**, where i is the index of the last balloon. We don\\'t need to worry about what its neighbors are. However, because it gets to the last balloon, all the balloons on both sides of that last balloon (i) have been burst. Apparently, we should have got the coins from bursting the balloons on the left of ith balloon (**dp[left][i]**) and on the right of the ith balloon (**dp[i][right]**). \\nSee? We divide the problem into 2 small sub-problems: how to get value of **dp[left][i]** and **dp[i][right]**. For me, at first, the most difficult part to understand is that after we divide the problem, both the left and right part are kind of losing the contribute of the ith balloon. However, note the 2 sub-problems, **dp[left][i]** and **dp[i][right]**, one of their bar (bondary) is the ith balloon. **Value of the bars will contribute to the value of dp[left][right].** So the value of ith balloon is also included inthe sub-problems of left and right side. (NOTE: the 1-value balloons we added in the beginning and end of the list won\\'t affect the result, because 1 * n = n).\\nTherefore, the total coins we can get from bursting a balloon ***i*** between balloon ***left*** and balloon ***right*** is: \\n**dp[left][right] = nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]**\\nAnd we just need to find the largest value of dp[left][right]:\\n**dp[left][right] = max( dp[left][right] , nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])**\\nThe reason why we need to get the max of dp[left][right] is that we need to loop through all balloons (i) between left and righ (exclusive).\\n\\n1. First, we need to prepare for the \\'nums\\' list, by adding \\'1\\' in the beginning and end of the original \\'nums\\' list. By doing this, we actually add the imaginary value-1 balloons to the list, which will help use due will the bondary balloons.\\n2. Then initialize the dp with n rows, in which there are n 0s.\\n3. Then start the loop with window first. The minimum size of a window is 2 ( only 1 balloon between bars), and the maximum size of a window is n-1, which contains the whole \\'nums\\' list.\\n4. Start moving the left bar from 0 to n-window, and set the right bar as **left + window**. By doing this, we can cover all possibilities from the first (imaginary) balloon, as left bar, to the last one, as right bar, for all the window size. When left = n-window-1, the corresponding right bar will be n-1.\\n5. Then calculate each singe balloon between the left and right bar (exclusive). Note here, no matter how many balloons are there between the left and right bar, the results of each calculation will be compared, and the largest will be saved in dp[left][right]. In other words, dp[left][right] is the largest value among the balloons between left and right bars. \\n6. As we discussed above, the accumulated coins one can get from bursting a balloon between left and right bar is: **nums[left] * nums[balloon] * nums[right] + bp[left][balloon] + bp[balloon][right]**\\n7. By looking at the code above, we should know that the code actually calculates the smaller size windows first, then when calculating the larger size windows, we can use the saved most coins one can get from the smaller window (as the left and right sections of the burst balloon).\\n8. Then after looping through all the windows, we can get the result as dp[0][n-1]\\n\\nAs the original answer states, the solution can be improved by removing all the 0-value balloons at first.\\n",
                "codeTag": "Java"
            },
            {
                "id": 383937,
                "title": "share-a-tutorial-video-speaking-very-clearly",
                "content": "https://www.youtube.com/watch?v=IFNibRVgFBo",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=IFNibRVgFBo",
                "codeTag": "Unknown"
            },
            {
                "id": 289283,
                "title": "java-dp-with-complete-thought-process",
                "content": "**Idea**\\nFirst thought - greedy doesn\\'t work - try bursting larger one first in [3,5], but bursting smaller on also doesn\\'t work [3,5,8].\\n\\nSo that tells we need to try all possibilities. That is, `[0,...,n-1]`, we check coins in bursting 0th first or bursting 1st balloon first etc..\\nSo let us try to define a recurse relation `For k in [0..n-1], maxCoins(k) = ..` but wait how do we know the neighbors for `k` in the optimal path...we need that to calculate the coins given by bursting `k`.\\n\\nMay be, we can reformulate our strategy which can gurantee our neighbors at `i`. If we define `maxCoins at k` as the case with last guy standing at `k`? We try to place everyone from `[0..n-1]` as last guys, so we know we are tring all possibilities. But this also gurantees, we bursted all the balloons in left part and also in the right part and lastly come to `k`.\\n\\nSo if we define `maxCoins(i,j) as bursting all balloons in [i..k-1] and in [k+1..j] and then bursting k for all k in [i..j]`, we can define recurrence relation as `maxCoins(i,k-1)+maxCoins(k+1,j)+nums[i-1]*nums[k]*nums[j+1]`.\\n\\nWhy would `nums[i-1]` and `nums[j+1]` be our neighbors and not burst before `k`? That again stems from the recurrence relation bursting `k` as the last balloon, so the subproblem `maxCoins(i,k-1)` can safely assume `k` (sub-problem neighbour) will be there for product calculation part.\\n\\n---\\n\\n\\n```\\nclass Solution {\\n    Integer[][] dp = null;\\n\\tpublic int maxCoins(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tdp = new Integer[n][n];\\n\\t\\treturn maxCoins(nums, 0, n - 1);\\n\\t}\\n\\tprivate int maxCoins(int[] n, int i, int j) {\\n\\t\\tif (i > j)\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i][j] != null)\\n\\t\\t\\treturn dp[i][j];\\n\\t\\tdp[i][j] = 0;\\n\\t\\tfor (int k = i; k <= j; k++) {\\n\\t\\t\\tint prod = n[k];\\n\\t\\t\\tif (i - 1 >= 0)\\n\\t\\t\\t\\tprod *= n[i - 1];\\n\\t\\t\\tif (j + 1 < n.length)\\n\\t\\t\\t\\tprod *= n[j + 1];\\n\\t\\t\\tdp[i][j] = Math.max(dp[i][j], maxCoins(n, i, k - 1) + prod + maxCoins(n, k + 1, j));\\n\\t\\t}\\n\\t\\treturn dp[i][j];\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] dp = null;\\n\\tpublic int maxCoins(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tdp = new Integer[n][n];\\n\\t\\treturn maxCoins(nums, 0, n - 1);\\n\\t}\\n\\tprivate int maxCoins(int[] n, int i, int j) {\\n\\t\\tif (i > j)\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i][j] != null)\\n\\t\\t\\treturn dp[i][j];\\n\\t\\tdp[i][j] = 0;\\n\\t\\tfor (int k = i; k <= j; k++) {\\n\\t\\t\\tint prod = n[k];\\n\\t\\t\\tif (i - 1 >= 0)\\n\\t\\t\\t\\tprod *= n[i - 1];\\n\\t\\t\\tif (j + 1 < n.length)\\n\\t\\t\\t\\tprod *= n[j + 1];\\n\\t\\t\\tdp[i][j] = Math.max(dp[i][j], maxCoins(n, i, k - 1) + prod + maxCoins(n, k + 1, j));\\n\\t\\t}\\n\\t\\treturn dp[i][j];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251048,
                "title": "python-5-lines",
                "content": "```\\ndef maxCoins(self, nums: List[int]) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef dfs(i,j):\\n\\t\\tif i>j: return 0\\n\\t\\treturn max(dfs(i,k-1)+dfs(k+1,j)+(nums[i-1] if i>=1 else 1)*nums[k]*(nums[j+1] if j <=len(nums)-2 else 1) for k in range(i,j+1))\\n\\treturn dfs(0,len(nums)-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxCoins(self, nums: List[int]) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef dfs(i,j):\\n\\t\\tif i>j: return 0\\n\\t\\treturn max(dfs(i,k-1)+dfs(k+1,j)+(nums[i-1] if i>=1 else 1)*nums[k]*(nums[j+1] if j <=len(nums)-2 else 1) for k in range(i,j+1))\\n\\treturn dfs(0,len(nums)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 241078,
                "title": "java-solution-in-chinese",
                "content": "\\u672C\\u9898\\u8981\\u6C42\\u6D88\\u53BB\\u6574\\u4E2A\\u6570\\u7EC4\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u90A3\\u4E48\\u4F7F\\u7528\\u5012\\u63A8\\u7684\\u65B9\\u6CD5\\uFF0C\\u6700\\u540E\\u4E00\\u4E2A\\u6D88\\u53BB\\u7684\\u4E00\\u5B9A\\u662F\\u6570\\u7EC4[0,...,n-1]\\u4E2D\\u7684\\u4E00\\u4E2A\\uFF0C\\u5047\\u8BBE\\u662F i \\uFF0C\\u90A3\\u4E48\\u4E5F\\u5C31\\u662F\\u8BF4\\u6B64\\u65F6\\u5DF2\\u7ECF\\u6D88\\u53BB\\u4E86\\u5DE6\\u8FB9\\u7684\\u5B50\\u6570\\u7EC4[0,...,i-1]\\u548C\\u53F3\\u8FB9\\u7684\\u5B50\\u6570\\u7EC4[i+1,...,n-1]\\uFF0C\\u6709[0,...,n-1]\\u7684\\u89E3 = nums[i] * nums[-1] * nums[n] + [0,...,i-1]\\u7684\\u89E3 + [i+1,...,n-1]\\u7684\\u89E3\\uFF0C\\u4E3A\\u4E86\\u4F7F[0,...,n-1]\\u7684\\u89E3\\u6700\\u5927\\uFF0C\\u5C31\\u9700\\u8981\\u6C42\\u51FA[0,...,i-1]\\u548C[i+1,...,n-1]\\u6700\\u5927\\u7684\\u89E3\\u3002\\n\\n\\u90A3\\u4E48\\u5BF9\\u4E8E\\u5B50\\u6570\\u7EC4[0,...,i-1]\\u6765\\u8BF4\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u91C7\\u7528\\u76F8\\u540C\\u7684\\u6C42\\u6CD5\\uFF0C\\u5047\\u8BBE\\u5728\\u8FD9\\u4E2A\\u6570\\u7EC4\\u4E2D\\u6700\\u540E\\u4E00\\u4E2A\\u6D88\\u53BB\\u7684\\u4F4D\\u7F6E\\u662F j \\uFF0C\\u90A3\\u4E48\\u6709[0,...,i-1]\\u7684\\u89E3 = nums[j] * num[-1] * num[i] + [0,...,j-1]\\u7684\\u89E3 + [j+1,...,i-1]\\u7684\\u89E3\\u3002\\n\\n\\u5B50\\u6570\\u7EC4\\u4E0D\\u65AD\\u88AB\\u5206\\u5272\\u6210\\u66F4\\u5C0F\\u7684\\u5B50\\u6570\\u7EC4\\uFF0C\\u6700\\u540E\\uFF0C\\u5F53\\u8FD9\\u4E2A\\u5B50\\u6570\\u7EC4\\u4E2D\\u53EA\\u6709\\u4E00\\u4E2A\\u5143\\u7D20\\u7684\\u65F6\\u5019\\uFF0C\\u5982\\u679C\\u8FD9\\u4E2A\\u5728\\u6570\\u7EC4[0,...,n-1]\\u4E2D\\u7684\\u4F4D\\u7F6E\\u662F k \\uFF0C\\u90A3\\u4E48\\u6B64\\u65F6\\u5B50\\u6570\\u7EC4[k]\\u53EA\\u6709\\u4E00\\u4E2A\\u89E3\\u4E3Anums[k] * nums[k-1] * nums[k+1]\\uFF0C\\u8FD9\\u662F\\u9012\\u5F52\\u7684\\u7ED3\\u675F\\u6761\\u4EF6\\u3002\\n\\n\\u4E8E\\u662F\\u6709\\uFF1A\\n\\n    public static int maxCoins(int[] nums) {\\n        int[] newNums = new int[nums.length+2];\\n        System.arraycopy(nums, 0, newNums, 1, nums.length);\\n        newNums[0] = newNums[nums.length+1] = 1;\\n        int[][] saved = new int[nums.length+2][nums.length+2];\\n        return max(newNums, 1, nums.length, saved);\\n    }\\n    private static int max(int[] nums, int start, int end, int[][] saved) {\\n        if (start > end) return 0;\\n        if (saved[start][end] != 0) return saved[start][end];\\n        int max = 0;\\n        for (int i = start; i <= end; i++) {\\n            int m = max(nums, start, i-1, saved) +\\n                    nums[start-1] * nums[i] * nums[end+1] +\\n                    max(nums, i+1, end, saved);\\n            max = Math.max(max, m);\\n        }\\n        saved[start][end] = max;\\n        return max;\\n    }\\n\\n\\u8FD9\\u91CC\\u8FD8\\u6709\\u4E00\\u70B9\\uFF0C\\u5728\\u8BA1\\u7B97\\u4F0A\\u59CB\\uFF0C\\u5C06\\u6570\\u7EC4[0,...,n-1]\\u6269\\u5C55\\u6210\\u4E86[-1,...,n]\\uFF0C\\u56E0\\u4E3A\\u9898\\u76EE\\u91CC\\u7ED9\\u51FA\\u4E86\\u6761\\u4EF6\\uFF0Cnums[-1] = nums[n] = 1\\uFF0C\\u90A3\\u4E48\\u5728\\u8BA1\\u7B97\\u5143\\u7D20\\u4E2A\\u6570\\u5C0F\\u4E8E 3 \\u7684\\u6570\\u7EC4\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u6309\\u7167\\u540C\\u6837\\u7684\\u89C4\\u5219\\u8FDB\\u884C\\u8BA1\\u7B97\\u3002\\u800C\\u6B64\\u65F6\\u6CE8\\u610F\\uFF0C\\u5BF9\\u4E8E\\u4E0A\\u9762\\u7684\\u8FD9\\u79CD\\u6765\\u8BF4\\uFF0C\\u6574\\u4E2A\\u6570\\u7EC4\\u53D8\\u6210\\u4E86[0,...,n+1]\\uFF0C\\u5F85\\u6C42\\u89E3\\u6570\\u7EC4\\u53D8\\u6210\\u4E86[1,...,n]\\u3002\\n\\n\\u6216\\u8005\\u4E5F\\u53EF\\u4EE5\\u5C06\\u8FD9\\u4E2A\\u89E3\\u6CD5\\u53D8\\u6210\\u4E00\\u4E2A\\u975E\\u9012\\u5F52\\u7684\\uFF1A\\n\\n    public static int maxCoins3(int[] nums) {\\n        int[] newNums = new int[nums.length+2];\\n        System.arraycopy(nums, 0, newNums, 1, nums.length);\\n        newNums[0] = newNums[nums.length+1] = 1;\\n        nums = newNums;\\n        int len = nums.length;\\n        int[][] dp = new int[len][len];\\n        for (int right = 0; right < len; right++) {\\n            for (int left = right-1; left >= 0; left--) {\\n                int sub = nums[left] * nums[right];\\n                for (int k = left+1; k < right; k++) {\\n                    dp[left][right] = Math.max(dp[left][right],\\n                            sub * nums[k] + dp[left][k] + dp[k][right]);\\n                }\\n            }\\n        }\\n        return dp[0][len-1];\\n    }\\n\\n\\u5728\\u8FD9\\u91CC\\uFF0C\\u5916\\u5C42\\u7684\\u4E24\\u4E2A right \\u548C left \\u5FAA\\u73AF\\uFF0C\\u662F\\u4E3A\\u4E86\\u6C42\\u51FA\\u5B50\\u6570\\u7EC4[left,...,right]\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u5185\\u5C42\\u7684 k \\u5FAA\\u73AF\\uFF0C\\u662F\\u6C42\\u6700\\u540E\\u6D88\\u53BB\\u7684\\u5143\\u7D20\\u4F4D\\u7F6E\\u4E3A k \\u65F6\\u7684\\u89E3\\u3002\\n\\nright \\u4ECE 0 \\u5F00\\u59CB\\u9012\\u589E\\uFF0Cleft \\u4ECE right \\u5F00\\u59CB\\u9012\\u51CF\\uFF0C\\u5BF9\\u4E8E\\u6570\\u7EC4[0,...,n-1]\\u6765\\u8BF4\\uFF0C[0,...,right]\\u662F\\u957F\\u5EA6\\u9012\\u589E\\u7684\\uFF0C\\u5BF9\\u4E8E\\u6570\\u7EC4[0,...,right]\\u6765\\u8BF4\\uFF0C[left,...,right]\\u4E5F\\u662F\\u957F\\u5EA6\\u9012\\u589E\\u7684\\uFF0C\\u5728\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0B\\uFF0C\\u624D\\u80FD\\u4F7F\\u7528\\u52A8\\u6001\\u89C4\\u5212\\u6C42\\u89E3\\u3002\\n\\n\\u6216\\u8005\\u4E0A\\u8FF0\\u7684\\u5FAA\\u73AF\\u4E5F\\u53EF\\u4EE5\\u662F\\uFF1A\\n\\n    for (int left = len-1; left >= 0; left--) {\\n        for (int right = left+1; right < len; right++) {\\n            int sub = nums[left] * nums[right];\\n            for (int k = left+1; k < right; k++) {\\n                dp[left][right] = Math.max(dp[left][right],\\n                        sub * nums[k] + dp[left][k] + dp[k][right]);\\n            }\\n        }\\n    }\\n\\n\\u5B83\\u5206\\u522B\\u4ECE[left,...,n-1]\\u548C[left,...,right]\\u9012\\u589E\\u3002\\n",
                "solutionTags": [],
                "code": "\\u672C\\u9898\\u8981\\u6C42\\u6D88\\u53BB\\u6574\\u4E2A\\u6570\\u7EC4\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u90A3\\u4E48\\u4F7F\\u7528\\u5012\\u63A8\\u7684\\u65B9\\u6CD5\\uFF0C\\u6700\\u540E\\u4E00\\u4E2A\\u6D88\\u53BB\\u7684\\u4E00\\u5B9A\\u662F\\u6570\\u7EC4[0,...,n-1]\\u4E2D\\u7684\\u4E00\\u4E2A\\uFF0C\\u5047\\u8BBE\\u662F i \\uFF0C\\u90A3\\u4E48\\u4E5F\\u5C31\\u662F\\u8BF4\\u6B64\\u65F6\\u5DF2\\u7ECF\\u6D88\\u53BB\\u4E86\\u5DE6\\u8FB9\\u7684\\u5B50\\u6570\\u7EC4[0,...,i-1]\\u548C\\u53F3\\u8FB9\\u7684\\u5B50\\u6570\\u7EC4[i+1,...,n-1]\\uFF0C\\u6709[0,...,n-1]\\u7684\\u89E3 = nums[i] * nums[-1] * nums[n] + [0,...,i-1]\\u7684\\u89E3 + [i+1,...,n-1]\\u7684\\u89E3\\uFF0C\\u4E3A\\u4E86\\u4F7F[0,...,n-1]\\u7684\\u89E3\\u6700\\u5927\\uFF0C\\u5C31\\u9700\\u8981\\u6C42\\u51FA[0,...,i-1]\\u548C[i+1,...,n-1]\\u6700\\u5927\\u7684\\u89E3\\u3002\\n\\n\\u90A3\\u4E48\\u5BF9\\u4E8E\\u5B50\\u6570\\u7EC4[0,...,i-1]\\u6765\\u8BF4\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u91C7\\u7528\\u76F8\\u540C\\u7684\\u6C42\\u6CD5\\uFF0C\\u5047\\u8BBE\\u5728\\u8FD9\\u4E2A\\u6570\\u7EC4\\u4E2D\\u6700\\u540E\\u4E00\\u4E2A\\u6D88\\u53BB\\u7684\\u4F4D\\u7F6E\\u662F j \\uFF0C\\u90A3\\u4E48\\u6709[0,...,i-1]\\u7684\\u89E3 = nums[j] * num[-1] * num[i] + [0,...,j-1]\\u7684\\u89E3 + [j+1,...,i-1]\\u7684\\u89E3\\u3002\\n\\n\\u5B50\\u6570\\u7EC4\\u4E0D\\u65AD\\u88AB\\u5206\\u5272\\u6210\\u66F4\\u5C0F\\u7684\\u5B50\\u6570\\u7EC4\\uFF0C\\u6700\\u540E\\uFF0C\\u5F53\\u8FD9\\u4E2A\\u5B50\\u6570\\u7EC4\\u4E2D\\u53EA\\u6709\\u4E00\\u4E2A\\u5143\\u7D20\\u7684\\u65F6\\u5019\\uFF0C\\u5982\\u679C\\u8FD9\\u4E2A\\u5728\\u6570\\u7EC4[0,...,n-1]\\u4E2D\\u7684\\u4F4D\\u7F6E\\u662F k \\uFF0C\\u90A3\\u4E48\\u6B64\\u65F6\\u5B50\\u6570\\u7EC4[k]\\u53EA\\u6709\\u4E00\\u4E2A\\u89E3\\u4E3Anums[k] * nums[k-1] * nums[k+1]\\uFF0C\\u8FD9\\u662F\\u9012\\u5F52\\u7684\\u7ED3\\u675F\\u6761\\u4EF6\\u3002\\n\\n\\u4E8E\\u662F\\u6709\\uFF1A\\n\\n    public static int maxCoins(int[] nums) {\\n        int[] newNums = new int[nums.length+2];\\n        System.arraycopy(nums, 0, newNums, 1, nums.length);\\n        newNums[0] = newNums[nums.length+1] = 1;\\n        int[][] saved = new int[nums.length+2][nums.length+2];\\n        return max(newNums, 1, nums.length, saved);\\n    }\\n    private static int max(int[] nums, int start, int end, int[][] saved) {\\n        if (start > end) return 0;\\n        if (saved[start][end] != 0) return saved[start][end];\\n        int max = 0;\\n        for (int i = start; i <= end; i++) {\\n            int m = max(nums, start, i-1, saved) +\\n                    nums[start-1] * nums[i] * nums[end+1] +\\n                    max(nums, i+1, end, saved);\\n            max = Math.max(max, m);\\n        }\\n        saved[start][end] = max;\\n        return max;\\n    }\\n\\n\\u8FD9\\u91CC\\u8FD8\\u6709\\u4E00\\u70B9\\uFF0C\\u5728\\u8BA1\\u7B97\\u4F0A\\u59CB\\uFF0C\\u5C06\\u6570\\u7EC4[0,...,n-1]\\u6269\\u5C55\\u6210\\u4E86[-1,...,n]\\uFF0C\\u56E0\\u4E3A\\u9898\\u76EE\\u91CC\\u7ED9\\u51FA\\u4E86\\u6761\\u4EF6\\uFF0Cnums[-1] = nums[n] = 1\\uFF0C\\u90A3\\u4E48\\u5728\\u8BA1\\u7B97\\u5143\\u7D20\\u4E2A\\u6570\\u5C0F\\u4E8E 3 \\u7684\\u6570\\u7EC4\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u6309\\u7167\\u540C\\u6837\\u7684\\u89C4\\u5219\\u8FDB\\u884C\\u8BA1\\u7B97\\u3002\\u800C\\u6B64\\u65F6\\u6CE8\\u610F\\uFF0C\\u5BF9\\u4E8E\\u4E0A\\u9762\\u7684\\u8FD9\\u79CD\\u6765\\u8BF4\\uFF0C\\u6574\\u4E2A\\u6570\\u7EC4\\u53D8\\u6210\\u4E86[0,...,n+1]\\uFF0C\\u5F85\\u6C42\\u89E3\\u6570\\u7EC4\\u53D8\\u6210\\u4E86[1,...,n]\\u3002\\n\\n\\u6216\\u8005\\u4E5F\\u53EF\\u4EE5\\u5C06\\u8FD9\\u4E2A\\u89E3\\u6CD5\\u53D8\\u6210\\u4E00\\u4E2A\\u975E\\u9012\\u5F52\\u7684\\uFF1A\\n\\n    public static int maxCoins3(int[] nums) {\\n        int[] newNums = new int[nums.length+2];\\n        System.arraycopy(nums, 0, newNums, 1, nums.length);\\n        newNums[0] = newNums[nums.length+1] = 1;\\n        nums = newNums;\\n        int len = nums.length;\\n        int[][] dp = new int[len][len];\\n        for (int right = 0; right < len; right++) {\\n            for (int left = right-1; left >= 0; left--) {\\n                int sub = nums[left] * nums[right];\\n                for (int k = left+1; k < right; k++) {\\n                    dp[left][right] = Math.max(dp[left][right],\\n                            sub * nums[k] + dp[left][k] + dp[k][right]);\\n                }\\n            }\\n        }\\n        return dp[0][len-1];\\n    }\\n\\n\\u5728\\u8FD9\\u91CC\\uFF0C\\u5916\\u5C42\\u7684\\u4E24\\u4E2A right \\u548C left \\u5FAA\\u73AF\\uFF0C\\u662F\\u4E3A\\u4E86\\u6C42\\u51FA\\u5B50\\u6570\\u7EC4[left,...,right]\\u7684\\u6700\\u5927\\u89E3\\uFF0C\\u5185\\u5C42\\u7684 k \\u5FAA\\u73AF\\uFF0C\\u662F\\u6C42\\u6700\\u540E\\u6D88\\u53BB\\u7684\\u5143\\u7D20\\u4F4D\\u7F6E\\u4E3A k \\u65F6\\u7684\\u89E3\\u3002\\n\\nright \\u4ECE 0 \\u5F00\\u59CB\\u9012\\u589E\\uFF0Cleft \\u4ECE right \\u5F00\\u59CB\\u9012\\u51CF\\uFF0C\\u5BF9\\u4E8E\\u6570\\u7EC4[0,...,n-1]\\u6765\\u8BF4\\uFF0C[0,...,right]\\u662F\\u957F\\u5EA6\\u9012\\u589E\\u7684\\uFF0C\\u5BF9\\u4E8E\\u6570\\u7EC4[0,...,right]\\u6765\\u8BF4\\uFF0C[left,...,right]\\u4E5F\\u662F\\u957F\\u5EA6\\u9012\\u589E\\u7684\\uFF0C\\u5728\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0B\\uFF0C\\u624D\\u80FD\\u4F7F\\u7528\\u52A8\\u6001\\u89C4\\u5212\\u6C42\\u89E3\\u3002\\n\\n\\u6216\\u8005\\u4E0A\\u8FF0\\u7684\\u5FAA\\u73AF\\u4E5F\\u53EF\\u4EE5\\u662F\\uFF1A\\n\\n    for (int left = len-1; left >= 0; left--) {\\n        for (int right = left+1; right < len; right++) {\\n            int sub = nums[left] * nums[right];\\n            for (int k = left+1; k < right; k++) {\\n                dp[left][right] = Math.max(dp[left][right],\\n                        sub * nums[k] + dp[left][k] + dp[k][right]);\\n            }\\n        }\\n    }\\n\\n\\u5B83\\u5206\\u522B\\u4ECE[left,...,n-1]\\u548C[left,...,right]\\u9012\\u589E\\u3002\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 220960,
                "title": "short-java-dp-solution-same-idea-with-lc-375-486-5",
                "content": "All of the questions apply DP in a similar way, altough the specific substructure is different.\\n\\nThe base case happens when the length is fixed (1 or 0), then results accumulate and are reused as the length expands.\\n\\nThere are a bunch of other similar question. Will continue update when I find one.\\n\\n\\n```\\n\\tpublic int maxCoins(int[] nums) {\\n        int n = nums.length;\\n                    \\n        int[] a = new int[n + 2];\\n        a[0] = 1; a[a.length - 1] = 1;\\n        for (int i = 0; i<n; i++) {\\n            a[i+1] = nums[i];\\n        }      \\n        \\n        int[][] dp = new int[a.length][a.length];\\n        \\n        for (int len = 0; len < n; len++) {\\n            for (int i = 1; i + len <=n; i++) {\\n                int j = i + len;\\n                for (int k = i; k <= j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k-1] + dp[k+1][j] + a[k]*a[i-1]*a[j+1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\t\\n\\t//LC 375 Guess Number Higher or Lower II    \\n\\tpublic int getMoneyAmount(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        int[][] dp = new int[n + 1][n + 1];\\n \\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i + len <= n; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i][j], k + Math.max(k == i ? 0 : dp[i][k - 1], \\n\\t\\t\\t\\t\\t\\tk == j ? 0 : dp[k + 1][j]));\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\t\\n\\t//LC 486 Predict the Winner    \\n\\tpublic boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) { \\n            dp[i][i] = nums[i]; \\n        }\\n        \\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i + len < n; i++) {\\n                int j = i + len;\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }",
                "solutionTags": [],
                "code": "All of the questions apply DP in a similar way, altough the specific substructure is different.\\n\\nThe base case happens when the length is fixed (1 or 0), then results accumulate and are reused as the length expands.\\n\\nThere are a bunch of other similar question. Will continue update when I find one.\\n\\n\\n```\\n\\tpublic int maxCoins(int[] nums) {\\n        int n = nums.length;\\n                    \\n        int[] a = new int[n + 2];\\n        a[0] = 1; a[a.length - 1] = 1;\\n        for (int i = 0; i<n; i++) {\\n            a[i+1] = nums[i];\\n        }      \\n        \\n        int[][] dp = new int[a.length][a.length];\\n        \\n        for (int len = 0; len < n; len++) {\\n            for (int i = 1; i + len <=n; i++) {\\n                int j = i + len;\\n                for (int k = i; k <= j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k-1] + dp[k+1][j] + a[k]*a[i-1]*a[j+1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\t\\n\\t//LC 375 Guess Number Higher or Lower II    \\n\\tpublic int getMoneyAmount(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        int[][] dp = new int[n + 1][n + 1];\\n \\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i + len <= n; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i][j], k + Math.max(k == i ? 0 : dp[i][k - 1], \\n\\t\\t\\t\\t\\t\\tk == j ? 0 : dp[k + 1][j]));\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\t\\n\\t//LC 486 Predict the Winner    \\n\\tpublic boolean PredictTheWinner(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) { \\n            dp[i][i] = nums[i]; \\n        }\\n        \\n        for (int len = 1; len < n; len++) {\\n            for (int i = 0; i + len < n; i++) {\\n                int j = i + len;\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        \\n        return dp[0][n-1] >= 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 167057,
                "title": "matrix-chain-multiplication-only-one-condition-changed-also-4ms-answer-faster-than-anyone",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) \\n    {\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        int n=nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        int m[n][n];\\n\\n        int i, j, k, L, q;\\n\\n        /* m[i,j] = Minimum number of scalar multiplications needed\\n        to compute the matrix A[i]A[i+1]...A[j] = A[i..j] where\\n        dimension of A[i] is p[i-1] x p[i] */\\n\\n        // cost is zero when multiplying one matrix.\\n        for (i=1; i<n; i++)\\n            m[i][i] = 0;\\n\\n        // L is chain length.\\n        for (L=2; L<n; L++)\\n        {\\n            for (i=1; i<n-L+1; i++)\\n            {\\n                j = i+L-1;\\n                m[i][j] = INT_MIN;\\n                for (k=i; k<=j-1; k++)\\n                {\\n                    // q = cost/scalar multiplications\\n                    q = m[i][k] + m[k+1][j] + nums[i-1]*nums[k]*nums[j];\\n                    if (q > m[i][j])\\n                        m[i][j] = q;\\n                }\\n            }\\n        }\\n\\n        return m[1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) \\n    {\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        int n=nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        int m[n][n];\\n\\n        int i, j, k, L, q;\\n\\n        /* m[i,j] = Minimum number of scalar multiplications needed\\n        to compute the matrix A[i]A[i+1]...A[j] = A[i..j] where\\n        dimension of A[i] is p[i-1] x p[i] */\\n\\n        // cost is zero when multiplying one matrix.\\n        for (i=1; i<n; i++)\\n            m[i][i] = 0;\\n\\n        // L is chain length.\\n        for (L=2; L<n; L++)\\n        {\\n            for (i=1; i<n-L+1; i++)\\n            {\\n                j = i+L-1;\\n                m[i][j] = INT_MIN;\\n                for (k=i; k<=j-1; k++)\\n                {\\n                    // q = cost/scalar multiplications\\n                    q = m[i][k] + m[k+1][j] + nums[i-1]*nums[k]*nums[j];\\n                    if (q > m[i][j])\\n                        m[i][j] = q;\\n                }\\n            }\\n        }\\n\\n        return m[1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76249,
                "title": "c-19ms-7-lines-dp-solution",
                "content": "```\\nint maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1), nums.insert(nums.end(), 1);   // add 1 at both first and last for convenience\\n        int len = nums.size(), dp[len][len]{};          // dp[l][r] is the max result of nums[l - r] inclusively\\n        \\n        for (int r = 1, end = len - 1; r < end; r++)\\n            for (int l = r; l > 0; l--)\\n                for (int k = l; k <= r; k++)            // treat k as the last balloons bursted\\n                    dp[l][r] = max(dp[l][r], dp[l][k - 1] + nums[l - 1] * nums[k] * nums[r + 1] + dp[k + 1][r]);\\n\\n        return dp[1][len - 2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1), nums.insert(nums.end(), 1);   // add 1 at both first and last for convenience\\n        int len = nums.size(), dp[len][len]{};          // dp[l][r] is the max result of nums[l - r] inclusively\\n        \\n        for (int r = 1, end = len - 1; r < end; r++)\\n            for (int l = r; l > 0; l--)\\n                for (int k = l; k <= r; k++)            // treat k as the last balloons bursted\\n                    dp[l][r] = max(dp[l][r], dp[l][k - 1] + nums[l - 1] * nums[k] * nums[r + 1] + dp[k + 1][r]);\\n\\n        return dp[1][len - 2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76277,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            vector<int> _nums(nums);\\n            _nums.insert(_nums.begin(), 1);\\n            _nums.push_back(1);\\n            int n=_nums.size();\\n            vector<vector<int>> matrix(n, vector<int>(n, 0));\\n            //return 0;\\n            return help(_nums, matrix, 0, n-1);\\n        }\\n        /*** (start, end)  ***/\\n        int help(vector<int>& nums, vector<vector<int>>& matrix, int low, int high){\\n            if(low+1==high)  return 0;\\n            if(matrix[low][high]>0)  return matrix[low][high];\\n            int result=0;\\n            for(int i=low+1; i<high; i++){\\n                result=max(result, nums[low]*nums[i]*nums[high],\\n                                   +help(nums, matrix, low, i)\\n                                   +help(nums, matrix, i, high));\\n            }\\n            matrix[low][high]=result;\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxCoins(vector<int>& nums) {\\n            vector<int> _nums(nums);\\n            _nums.insert(_nums.begin(), 1);\\n            _nums.push_back(1);\\n            int n=_nums.size();\\n            vector<vector<int>> matrix(n, vector<int>(n, 0));\\n            //return 0;\\n            return help(_nums, matrix, 0, n-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3952014,
                "title": "python-90-12-faster-dp-recursive-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            maxi=-maxsize\\n            for k in range(i,j+1):\\n                coins=nums[i-1]*nums[k]*nums[j+1]+solve(i,k-1)+solve(k+1,j)\\n                maxi=max(maxi,coins)\\n            return maxi\\n        \\n        n=len(nums)\\n        nums.insert(0,1)\\n        nums.append(1)\\n        return solve(1,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2) + O(n)\\nclass Solution2:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            maxi=-maxsize\\n            for k in range(i,j+1):\\n                coins=nums[i-1]*nums[k]*nums[j+1]+solve(i,k-1)+solve(k+1,j)\\n                maxi=max(maxi,coins)\\n            dp[i][j]=maxi\\n            return dp[i][j]\\n        \\n        n=len(nums)\\n        dp=[[-1 for j in range(n+1)] for j in range(n+1)]\\n        nums.insert(0,1)\\n        nums.append(1)\\n        return solve(1,n)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2)\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        nums.insert(0,1)\\n        nums.append(1)\\n        dp=[[0 for j in range(n+2)] for j in range(n+2)]\\n        for i in range(n,0,-1):\\n            for j in range(1,n+1):\\n                if i>j:\\n                    continue\\n                maxi=-maxsize\\n                for k in range(i,j+1):\\n                    coins=nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j]\\n                    maxi=max(maxi,coins)\\n                dp[i][j]=maxi\\n        return dp[1][n]\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            maxi=-maxsize\\n            for k in range(i,j+1):\\n                coins=nums[i-1]*nums[k]*nums[j+1]+solve(i,k-1)+solve(k+1,j)\\n                maxi=max(maxi,coins)\\n            return maxi\\n        \\n        n=len(nums)\\n        nums.insert(0,1)\\n        nums.append(1)\\n        return solve(1,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2) + O(n)\\nclass Solution2:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            maxi=-maxsize\\n            for k in range(i,j+1):\\n                coins=nums[i-1]*nums[k]*nums[j+1]+solve(i,k-1)+solve(k+1,j)\\n                maxi=max(maxi,coins)\\n            dp[i][j]=maxi\\n            return dp[i][j]\\n        \\n        n=len(nums)\\n        dp=[[-1 for j in range(n+1)] for j in range(n+1)]\\n        nums.insert(0,1)\\n        nums.append(1)\\n        return solve(1,n)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2)\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        nums.insert(0,1)\\n        nums.append(1)\\n        dp=[[0 for j in range(n+2)] for j in range(n+2)]\\n        for i in range(n,0,-1):\\n            for j in range(1,n+1):\\n                if i>j:\\n                    continue\\n                maxi=-maxsize\\n                for k in range(i,j+1):\\n                    coins=nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j]\\n                    maxi=max(maxi,coins)\\n                dp[i][j]=maxi\\n        return dp[1][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749731,
                "title": "java-dp-memoization",
                "content": "# Memoization\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n+2];\\n        arr[0] = 1;\\n        arr[arr.length - 1] = 1;\\n        for(int i = 1; i < arr.length - 1; i++) arr[i] = nums[i-1];\\n\\n        int[][] dp = new int[arr.length][arr.length];\\n        for(int[] ar : dp) Arrays.fill(ar, -1);\\n        return helper(arr, 1, arr.length - 2, dp);\\n    }\\n\\n    private int helper(int[] nums, int i, int j, int[][] dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int k = i; k <= j; k++) {\\n            max = Math.max((nums[i-1] * nums[k] * nums[j+1]) + helper(nums, i, k-1, dp) + helper(nums, k+1, j, dp), max);\\n        }\\n\\n        return dp[i][j] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n+2];\\n        arr[0] = 1;\\n        arr[arr.length - 1] = 1;\\n        for(int i = 1; i < arr.length - 1; i++) arr[i] = nums[i-1];\\n\\n        int[][] dp = new int[arr.length][arr.length];\\n        for(int[] ar : dp) Arrays.fill(ar, -1);\\n        return helper(arr, 1, arr.length - 2, dp);\\n    }\\n\\n    private int helper(int[] nums, int i, int j, int[][] dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int k = i; k <= j; k++) {\\n            max = Math.max((nums[i-1] * nums[k] * nums[j+1]) + helper(nums, i, k-1, dp) + helper(nums, k+1, j, dp), max);\\n        }\\n\\n        return dp[i][j] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600670,
                "title": "dp-on-mcm-pattern",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<int> &nums)\\n{\\n    if (i > j)\\n    {\\n        return 0;\\n    }\\n\\n    int mx = -1e9;\\n    for (int ind = i; ind <= j; ind++)\\n    {\\n        int cost = nums[i - 1] * nums[ind] * nums[j + 1] + solve(i, ind - 1, nums) + solve(ind + 1, j, nums);\\n        mx = max(mx, cost);\\n    }\\n    return mx;\\n}\\n\\nint DP(int i, int j, vector<int> &nums, vector<vector<int>> &dp)\\n{\\n    if (i > j)\\n        return 0;\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int mx = -1e9;\\n    for (int ind = i; ind <= j; ind++)\\n    {\\n        int cost = nums[i - 1] * nums[ind] * nums[j + 1] + DP(i, ind - 1, nums, dp) + DP(ind + 1, j, nums, dp);\\n        mx = max(mx, cost);\\n    }\\n    return dp[i][j] = mx;\\n}\\n\\nint maxCoins(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    nums.insert(nums.begin(), 1);\\n    nums.push_back(1);\\n    // return solve(1, n, nums);\\n\\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, -1));\\n    return DP(1, n, nums, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<int> &nums)\\n{\\n    if (i > j)\\n    {\\n        return 0;\\n    }\\n\\n    int mx = -1e9;\\n    for (int ind = i; ind <= j; ind++)\\n    {\\n        int cost = nums[i - 1] * nums[ind] * nums[j + 1] + solve(i, ind - 1, nums) + solve(ind + 1, j, nums);\\n        mx = max(mx, cost);\\n    }\\n    return mx;\\n}\\n\\nint DP(int i, int j, vector<int> &nums, vector<vector<int>> &dp)\\n{\\n    if (i > j)\\n        return 0;\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int mx = -1e9;\\n    for (int ind = i; ind <= j; ind++)\\n    {\\n        int cost = nums[i - 1] * nums[ind] * nums[j + 1] + DP(i, ind - 1, nums, dp) + DP(ind + 1, j, nums, dp);\\n        mx = max(mx, cost);\\n    }\\n    return dp[i][j] = mx;\\n}\\n\\nint maxCoins(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    nums.insert(nums.begin(), 1);\\n    nums.push_back(1);\\n    // return solve(1, n, nums);\\n\\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, -1));\\n    return DP(1, n, nums, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594366,
                "title": "c-tabulation-easy-to-get",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i=n-2; i>=1; i--){\\n            for(int j=i; j<n-1; j++){\\n                int maxi = 0;\\n                for(int k=i; k<=j; k++){\\n                    int cost = nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j];\\n                    maxi = max(maxi,cost);\\n                }\\n                dp[i][j] = maxi;\\n            }\\n        }\\n        return dp[1][n-2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i=n-2; i>=1; i--){\\n            for(int j=i; j<n-1; j++){\\n                int maxi = 0;\\n                for(int k=i; k<=j; k++){\\n                    int cost = nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j];\\n                    maxi = max(maxi,cost);\\n                }\\n                dp[i][j] = maxi;\\n            }\\n        }\\n        return dp[1][n-2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303973,
                "title": "clean-sol-with-intution-explanation-partition-dp-java-with-diagram-tabulation-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis prob seems like a partition prob where the order of solving sub prob changes the ans, so we apply the partition DP here and coins at any stage is\\n\\n`coins nums[i-1]*nums[i]*nums[i+1] + rec(i, ind-1) + rec(ind+1,j)`\\n\\n- but here we can\\'t solve the subprob independently\\n- consider an array [b1,b2,b3,b4,b5,b6]\\n- if we burst b4 first then it divids the prob in 2 sub prob and now b3 and b5 becomes adjacent and dependent on each other so now if we burst b5 from right subarray then it needs b3 which is part of left sub prob so 2 sub prob can\\'t be solved indendently\\n![burst_balloons_DP2.JPG](https://assets.leetcode.com/users/images/73b9e4c0-3c8c-4810-a47b-74ed961d1ece_1678970885.435919.jpeg)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsince thinking in terms of which is the first balloon to birst gives us depedent sub prob, think other way round i.e think which will be the last balloon to burst \\n\\nlet\\'s say kth balloon is last one to burst then 1*arr[k]*1\\n```\\ncoins = arr[i-1]*arr[k]*arr[j+1] + subprob(i, k-1) +subprob(k+1, i)\\n```\\nherer k-1 and k+1 will not be adjacent since k is bursting in last so it is present in earlier stages i.e subprob \\n\\ni.e let\\'s say 8 is the last ballon to burst in [3,1,5,8] then it will earn coins = 1*8*1 now which will be the 2nd last ballon to burst it could be any one out of [3,1,5] i.e at 2nd last stage left ballons could be [3,8] or [1,8] or [5,8] cos 8 will definitley be there in 2nd last stage if it is burst in last stage so if we burst 3 in 2nd last stage then\\n- `coins = a[i-1] * a[ind] * a[j+1]` i-1 and j+1 signify out of bounds of sub prob i.e left of sub prob range and right of sub prob range so left of [3,8] in [3,1,5,8] is 1 and right is defnitely 8 cos it is burst in last stage and at 2nd last stage 1 and 5 are already assumed to be burst in earlier stages for [3,8] so coins = 1*3*5 and so on till 1st stage  \\n- \\n![burst_balloons_DP.JPG](https://assets.leetcode.com/users/images/fde0af2b-dc4d-4d7c-a9e3-3b1296eba90e_1678970894.2333257.jpeg)\\n\\n- as shown in image below two sub prob at 2nd last stage are not dependent on each other but on b4 i.e balloon bursted in last stage  \\n\\n![burst_balloons_DP1.JPG](https://assets.leetcode.com/users/images/0ec5121a-792e-4908-a2e2-55700aa38fd5_1678970904.1310182.jpeg)\\n\\nplease give it a thumbs up if the sol helped you\\n  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n^3) \\n\\n- Space complexity:  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(n^2) + o(n)\\n\\n# Code\\n## using memoization\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int len = nums.length;\\n        int[] arr = new int[len+2];\\n        int[][] dp = new int[len+1][len+1];\\n        for(int[] row: dp){\\n            Arrays.fill(row, -1);\\n        }\\n        arr[0] = arr[len+1] = 1;\\n        for(int i = 1; i <= len; i++){\\n            arr[i] = nums[i-1];\\n        }\\n        return rec(arr, 1, len, dp);\\n    }\\n    int rec(int[] arr, int i, int j, int[][] dp){\\n        if(i > j ) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int max = Integer.MIN_VALUE;\\n        for(int ind = i; ind <= j ; ind++){\\n            int coins = (arr[i-1] * arr[ind] * arr[j+1]) + rec(arr, i, ind - 1, dp) + rec(arr, ind+1, j, dp);\\n            max = Math.max(max, coins);\\n        }\\n        return dp[i][j] = max;\\n    }\\n}\\n```\\n\\n## using tabulation\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int len = nums.length;\\n        int[] arr = new int[len+2];\\n        int[][] dp = new int[len+2][len+2];\\n        // for(int[] row: dp){\\n        //     Arrays.fill(row, -1);\\n        // }\\n        arr[0] = arr[len+1] = 1;\\n        for(int i = 1; i <= len; i++){\\n            arr[i] = nums[i-1];\\n        }\\n        for(int i = len; i > 0; i--){\\n            for(int j = i; j <= len; j++){\\n                int max = Integer.MIN_VALUE;\\n                for(int ind = i; ind <= j ; ind++){                    \\n                    int coins = (arr[i-1] * arr[ind] * arr[j+1]) + dp[i][ind - 1] + dp[ind + 1][j];\\n                    max = Math.max(max, coins);\\n                }\\n                dp[i][j] = max;\\n            }\\n        }\\n        return dp[1][len];\\n        //return rec(arr, 1, len, dp);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ncoins = arr[i-1]*arr[k]*arr[j+1] + subprob(i, k-1) +subprob(k+1, i)\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int len = nums.length;\\n        int[] arr = new int[len+2];\\n        int[][] dp = new int[len+1][len+1];\\n        for(int[] row: dp){\\n            Arrays.fill(row, -1);\\n        }\\n        arr[0] = arr[len+1] = 1;\\n        for(int i = 1; i <= len; i++){\\n            arr[i] = nums[i-1];\\n        }\\n        return rec(arr, 1, len, dp);\\n    }\\n    int rec(int[] arr, int i, int j, int[][] dp){\\n        if(i > j ) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int max = Integer.MIN_VALUE;\\n        for(int ind = i; ind <= j ; ind++){\\n            int coins = (arr[i-1] * arr[ind] * arr[j+1]) + rec(arr, i, ind - 1, dp) + rec(arr, ind+1, j, dp);\\n            max = Math.max(max, coins);\\n        }\\n        return dp[i][j] = max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int len = nums.length;\\n        int[] arr = new int[len+2];\\n        int[][] dp = new int[len+2][len+2];\\n        // for(int[] row: dp){\\n        //     Arrays.fill(row, -1);\\n        // }\\n        arr[0] = arr[len+1] = 1;\\n        for(int i = 1; i <= len; i++){\\n            arr[i] = nums[i-1];\\n        }\\n        for(int i = len; i > 0; i--){\\n            for(int j = i; j <= len; j++){\\n                int max = Integer.MIN_VALUE;\\n                for(int ind = i; ind <= j ; ind++){                    \\n                    int coins = (arr[i-1] * arr[ind] * arr[j+1]) + dp[i][ind - 1] + dp[ind + 1][j];\\n                    max = Math.max(max, coins);\\n                }\\n                dp[i][j] = max;\\n            }\\n        }\\n        return dp[1][len];\\n        //return rec(arr, 1, len, dp);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241181,
                "title": "c-top-down-and-bottom-up",
                "content": "# Code [Recursive - TLE]\\n```\\nint BurstBalloonsRec(vector<int>&nums,int si,int ei){\\n    int ans = INT_MIN;\\n    int first = (si-1>=0)?nums[si-1] : 1;\\n    int last = (ei+1<n)?nums[ei+1] : 1;\\n\\n    for(int i = si;i<=ei;i++){\\n        int before = (i==si)? 0 : BurstBalloonsRec(nums,si,i-1);\\n        int after = (i==ei)? 0 : BurstBalloonsRec(nums,i+1,ei);\\n\\n        int total = before + after + first*last*nums[i];\\n        ans = max(ans,total);\\n    }\\n\\n    return ans;\\n}\\n```\\n__________________\\n# Code [Top Down]\\n```\\nint BurstBalloonsTD(vector<int>&nums,int si,int ei,vector<vector<int>>&strg){\\n    if(strg[si][ei]!=-1) return strg[si][ei];\\n    int ans = INT_MIN;\\n    int first = (si-1>=0)?nums[si-1] : 1;\\n    int last = (ei+1<n)?nums[ei+1] : 1;\\n\\n    for(int i = si;i<=ei;i++){\\n        int before = (i==si)? 0 : BurstBalloonsTD(nums,si,i-1,strg);\\n        int after = (i==ei)? 0 : BurstBalloonsTD(nums,i+1,ei,strg);\\n\\n        int total = before + after + first*last*nums[i];\\n        ans = max(ans,total);\\n    }\\n\\n    return strg[si][ei] = ans;\\n}\\n```\\n__________________\\n# Code [Bottom Up]\\n```\\nint BurstBalloonsBU(vector<int>&nums){\\n    vector<vector<int>> strg(n,vector<int>(n));    \\n    for(int si = n-1 ; si>=0 ; si--){\\n        for(int ei = si ; ei<n ; ei++){\\n            int ans = INT_MIN;\\n            int first = (si-1>=0)?nums[si-1] : 1;\\n            int last = (ei+1<n)?nums[ei+1] : 1;\\n\\n            for(int i = si;i<=ei;i++){\\n                int before = (i==si)? 0 : strg[si][i-1];\\n                int after = (i==ei)? 0 : strg[i+1][ei];\\n\\n                int total = before + after + first*last*nums[i];\\n                ans = max(ans,total);\\n            }\\n\\n            strg[si][ei] = ans;\\n        }\\n    }\\n    return strg[0][n-1];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint BurstBalloonsRec(vector<int>&nums,int si,int ei){\\n    int ans = INT_MIN;\\n    int first = (si-1>=0)?nums[si-1] : 1;\\n    int last = (ei+1<n)?nums[ei+1] : 1;\\n\\n    for(int i = si;i<=ei;i++){\\n        int before = (i==si)? 0 : BurstBalloonsRec(nums,si,i-1);\\n        int after = (i==ei)? 0 : BurstBalloonsRec(nums,i+1,ei);\\n\\n        int total = before + after + first*last*nums[i];\\n        ans = max(ans,total);\\n    }\\n\\n    return ans;\\n}\\n```\n```\\nint BurstBalloonsTD(vector<int>&nums,int si,int ei,vector<vector<int>>&strg){\\n    if(strg[si][ei]!=-1) return strg[si][ei];\\n    int ans = INT_MIN;\\n    int first = (si-1>=0)?nums[si-1] : 1;\\n    int last = (ei+1<n)?nums[ei+1] : 1;\\n\\n    for(int i = si;i<=ei;i++){\\n        int before = (i==si)? 0 : BurstBalloonsTD(nums,si,i-1,strg);\\n        int after = (i==ei)? 0 : BurstBalloonsTD(nums,i+1,ei,strg);\\n\\n        int total = before + after + first*last*nums[i];\\n        ans = max(ans,total);\\n    }\\n\\n    return strg[si][ei] = ans;\\n}\\n```\n```\\nint BurstBalloonsBU(vector<int>&nums){\\n    vector<vector<int>> strg(n,vector<int>(n));    \\n    for(int si = n-1 ; si>=0 ; si--){\\n        for(int ei = si ; ei<n ; ei++){\\n            int ans = INT_MIN;\\n            int first = (si-1>=0)?nums[si-1] : 1;\\n            int last = (ei+1<n)?nums[ei+1] : 1;\\n\\n            for(int i = si;i<=ei;i++){\\n                int before = (i==si)? 0 : strg[si][i-1];\\n                int after = (i==ei)? 0 : strg[i+1][ei];\\n\\n                int total = before + after + first*last*nums[i];\\n                ans = max(ans,total);\\n            }\\n\\n            strg[si][ei] = ans;\\n        }\\n    }\\n    return strg[0][n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141146,
                "title": "memoization-tabulation-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, vector<int> &nums, vector<vector<int>> &dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = -1;\\n        for(int k=i; k<=j; k++) {\\n            ans = max(ans, nums[i - 1] * nums[k] * nums[j + 1] + dfs(i, k - 1, nums, dp) + dfs(k + 1, j, nums, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return dfs(1, n - 2, nums, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n\\n        vector<vector<int>> dp(n, vector<int>(n));\\n\\n        for(int i=n-2; i>=1; i--) {\\n            for(int j=1; j<=n-2; j++) {\\n                if(i > j) continue;\\n                int ans = -1;\\n                for(int k=i; k<=j; k++) {\\n                    ans = max(ans, nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<int> &nums, vector<vector<int>> &dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = -1;\\n        for(int k=i; k<=j; k++) {\\n            ans = max(ans, nums[i - 1] * nums[k] * nums[j + 1] + dfs(i, k - 1, nums, dp) + dfs(k + 1, j, nums, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return dfs(1, n - 2, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        nums.insert(nums.begin(), 1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n\\n        vector<vector<int>> dp(n, vector<int>(n));\\n\\n        for(int i=n-2; i>=1; i--) {\\n            for(int j=1; j<=n-2; j++) {\\n                if(i > j) continue;\\n                int ans = -1;\\n                for(int k=i; k<=j; k++) {\\n                    ans = max(ans, nums[i - 1] * nums[k] * nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693428,
                "title": "recursion-memoization-tabulation-c",
                "content": "```\\n// Recursion\\n// class Solution {\\n// public:\\n//     int f(int i, int j, vector<int> &nums){\\n//         if( i > j) return 0;\\n//         int maxi = INT_MIN;\\n//         for(int ind = i; ind <= j ; ind++){\\n//             int coins = nums[i-1] * nums[ind] * nums[j+1] + f(i,ind-1,nums) + f(ind+1,j,nums);\\n//             maxi = max(maxi,coins);\\n//         }\\n//         return maxi;\\n//     }\\n    \\n//     int maxCoins(vector<int>& nums) {\\n//         int n = nums.size();\\n//         nums.push_back(1);\\n//         nums.insert(nums.begin(),1);\\n//         return f(1,n,nums);\\n//     }\\n// };\\n\\n//MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, vector<int> &nums, vector<vector<int>> &dp){\\n//         if( i > j) return 0;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         int maxi = INT_MIN;\\n//         for(int ind = i; ind <= j ; ind++){\\n//             int coins = nums[i-1] * nums[ind] * nums[j+1] + f(i,ind-1,nums,dp) + f(ind+1,j,nums,dp);\\n//             maxi = max(maxi,coins);\\n//         }\\n//         return dp[i][j] = maxi;\\n//     }\\n    \\n//     int maxCoins(vector<int>& nums) {\\n//         int n = nums.size();\\n//         nums.push_back(1);\\n//         nums.insert(nums.begin(),1);\\n//         vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n//         return f(1,n,nums,dp);\\n//     }\\n// };\\n\\n// TABULATION\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,0));\\n        for(int i=n;i>=1;i--){\\n            for(int j = 1; j<=n; j++){\\n                int maxi = INT_MIN;\\n                if(i > j) continue;\\n                for(int ind = i; ind <= j; ind++){\\n                    int coins = nums[i-1]*nums[ind]*nums[j+1] + dp[i][ind-1] + dp[ind+1][j];\\n                    maxi = max(maxi,coins);\\n                }\\n                dp[i][j] = maxi;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursion\\n// class Solution {\\n// public:\\n//     int f(int i, int j, vector<int> &nums){\\n//         if( i > j) return 0;\\n//         int maxi = INT_MIN;\\n//         for(int ind = i; ind <= j ; ind++){\\n//             int coins = nums[i-1] * nums[ind] * nums[j+1] + f(i,ind-1,nums) + f(ind+1,j,nums);\\n//             maxi = max(maxi,coins);\\n//         }\\n//         return maxi;\\n//     }\\n    \\n//     int maxCoins(vector<int>& nums) {\\n//         int n = nums.size();\\n//         nums.push_back(1);\\n//         nums.insert(nums.begin(),1);\\n//         return f(1,n,nums);\\n//     }\\n// };\\n\\n//MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, vector<int> &nums, vector<vector<int>> &dp){\\n//         if( i > j) return 0;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         int maxi = INT_MIN;\\n//         for(int ind = i; ind <= j ; ind++){\\n//             int coins = nums[i-1] * nums[ind] * nums[j+1] + f(i,ind-1,nums,dp) + f(ind+1,j,nums,dp);\\n//             maxi = max(maxi,coins);\\n//         }\\n//         return dp[i][j] = maxi;\\n//     }\\n    \\n//     int maxCoins(vector<int>& nums) {\\n//         int n = nums.size();\\n//         nums.push_back(1);\\n//         nums.insert(nums.begin(),1);\\n//         vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n//         return f(1,n,nums,dp);\\n//     }\\n// };\\n\\n// TABULATION\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,0));\\n        for(int i=n;i>=1;i--){\\n            for(int j = 1; j<=n; j++){\\n                int maxi = INT_MIN;\\n                if(i > j) continue;\\n                for(int ind = i; ind <= j; ind++){\\n                    int coins = nums[i-1]*nums[ind]*nums[j+1] + dp[i][ind-1] + dp[ind+1][j];\\n                    maxi = max(maxi,coins);\\n                }\\n                dp[i][j] = maxi;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668392,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Reacursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare dp\\n    \\n    int dp[305][305];\\n    \\n    int helper(vector<int>& arr, int start, int end)\\n    {\\n        // base case, if there is no. element remaining in partition\\n        \\n        if(start > end)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[start][end] != -1)\\n        {\\n            return dp[start][end];\\n        }\\n        \\n        int maxi = 0;\\n        \\n        // start deleting the every element and take maximum of it\\n        \\n        for(int j = start; j <= end; j++)\\n        {\\n            // call for deleting left part [start, j - 1]\\n            \\n            int left = helper(arr, start, j - 1);\\n            \\n            // call for deleting right part [j + 1, end]\\n            \\n            int right = helper(arr, j + 1, end);\\n            \\n            // take the cost of deleting the curr element\\n            \\n            // all the elements between [start, j - 1] is deleted, so left adjacent will be at start - 1\\n            \\n            // all the elements between [j + 1, end] is deleted, so right adjacent will be at [end + 1]\\n            \\n            int prod = arr[start - 1] * arr[j] * arr[end + 1];\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, prod + left + right);\\n        }\\n        \\n        // store the res and return\\n        \\n        return dp[start][end] = maxi;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // insert 1 and back\\n        \\n        nums.push_back(1);\\n        \\n        // insert 1 at start\\n        \\n        nums.insert(nums.begin(), 1);\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(nums, 1, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare dp\\n    \\n    int dp[305][305];\\n    \\n    int helper(vector<int>& arr, int start, int end)\\n    {\\n        // base case, if there is no. element remaining in partition\\n        \\n        if(start > end)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[start][end] != -1)\\n        {\\n            return dp[start][end];\\n        }\\n        \\n        int maxi = 0;\\n        \\n        // start deleting the every element and take maximum of it\\n        \\n        for(int j = start; j <= end; j++)\\n        {\\n            // call for deleting left part [start, j - 1]\\n            \\n            int left = helper(arr, start, j - 1);\\n            \\n            // call for deleting right part [j + 1, end]\\n            \\n            int right = helper(arr, j + 1, end);\\n            \\n            // take the cost of deleting the curr element\\n            \\n            // all the elements between [start, j - 1] is deleted, so left adjacent will be at start - 1\\n            \\n            // all the elements between [j + 1, end] is deleted, so right adjacent will be at [end + 1]\\n            \\n            int prod = arr[start - 1] * arr[j] * arr[end + 1];\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, prod + left + right);\\n        }\\n        \\n        // store the res and return\\n        \\n        return dp[start][end] = maxi;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // insert 1 and back\\n        \\n        nums.push_back(1);\\n        \\n        // insert 1 at start\\n        \\n        nums.insert(nums.begin(), 1);\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(nums, 1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534256,
                "title": "c-recursion-memoization-tabulation-partition-dp",
                "content": "# Method -1 [Recursion]\\n\\n![image](https://assets.leetcode.com/users/images/158cc651-c83c-4850-b282-72558668bfed_1662367794.232929.png)\\n\\n**T->O(Expo) && S->O(n) [RECURSION STACK SPACE]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& nums){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tint maxi=INT_MIN;\\n\\t\\t\\tfor(int k=i;k<=j;k++){\\n\\t\\t\\t\\tint cost=nums[i-1]*nums[k]*nums[j+1]+f(i,k-1,nums)+f(k+1,j,nums);\\n\\t\\t\\t\\tmaxi=max(maxi,cost);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\n\\t\\tint maxCoins(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tnums.insert(nums.begin(),1);\\n\\t\\t\\tnums.insert(nums.end(),1);\\n\\t\\t\\treturn f(1,n,nums);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 2 [Memoization]\\n\\n![image](https://assets.leetcode.com/users/images/6117d4c6-0baf-4e79-8063-723612b1304d_1662374576.8607242.png)\\n\\n**T->O(n^2) && S->O(n^2) + O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& nums,vector<vector<int>>& dp){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint maxi=INT_MIN;\\n\\t\\t\\tfor(int k=i;k<=j;k++){\\n\\t\\t\\t\\tint cost=nums[i-1]*nums[k]*nums[j+1]+f(i,k-1,nums,dp)+f(k+1,j,nums,dp);\\n\\t\\t\\t\\tmaxi=max(maxi,cost);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j]=maxi;\\n\\t\\t}\\n\\n\\t\\tint maxCoins(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tnums.insert(nums.begin(),1);\\n\\t\\t\\tnums.insert(nums.end(),1);\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n\\t\\t\\treturn f(1,n,nums,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/14bd666f-6738-45d8-9772-53151b958099_1662375726.5308394.png)\\n\\n**T->O(n^2) && S->O(n^2)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxCoins(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tnums.insert(nums.begin(),1);\\n\\t\\t\\tnums.insert(nums.end(),1);\\n\\t\\t\\tvector<vector<int>> dp(n+2,vector<int>(n+2,0));\\n\\t\\t\\tfor(int i=n;i>=1;i--){\\n\\t\\t\\t\\tfor(int j=i;j<=n;j++){\\n\\t\\t\\t\\t\\tint maxi=INT_MIN;\\n\\t\\t\\t\\t\\tfor(int k=i;k<=j;k++){\\n\\t\\t\\t\\t\\t\\tint cost=nums[i-1]*nums[k]*nums[j+1]+dp[i][k-1]+dp[k+1][j];\\n\\t\\t\\t\\t\\t\\tmaxi=max(maxi,cost);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j]=maxi;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[1][n];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& nums){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tint maxi=INT_MIN;\\n\\t\\t\\tfor(int k=i;k<=j;k++){\\n\\t\\t\\t\\tint cost=nums[i-1]*nums[k]*nums[j+1]+f(i,k-1,nums)+f(k+1,j,nums);\\n\\t\\t\\t\\tmaxi=max(maxi,cost);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2453704,
                "title": "easily-understandable-recursive-memoization-and-dp-solutions",
                "content": "Lets first analyze why a normal partition dp does not suffice for this:\\nAssume my test case to be: [1,2,3,4,5,6,7,8] and I decided to burst the 5th balloon, now in a normal partition dp solution, we could solve for [1,2,3,4] and [6,7,8] separately and add their answers to the coins gained from bursting 5.\\nBut solving these individually is not possible and these two segments are not **independent** because resulting list would now be: [1,2,3,4,6,7,8] now if I try to burst 4 I should get 3 * 4 * 6 coins but if I solved the segment [1,2,3,4] independently, I would have got 3 * 4 * 1 coins! We are dependent upon values from the other segments.\\n\\n**What works then?**\\nWell let\\'s dry run the example test case from the problem with some patterns and see what\\'s happening there:\\n[3,1,5,8]\\nPick 5,  Coins = 1 * 5 * 8\\n[3,1,8]\\nPick 3, Coins = 1 * 3 * 1\\n[1,8]\\nPick 1, Coins = 1 * 1 * 8\\n[8]\\nPick 8, Coins = 1 * 8 * 1\\n[]\\n\\nAnother Possibility:\\n[3,1,5,8]\\nPick 1,  Coins = 3 * 1 * 5\\n[3,5,8]\\nPick 3, Coins = 1 * 3 * 5\\n[5,8]\\nPick 8, Coins = 5 * 8 * 1\\n[5]\\nPick 5, Coins = 1 * 5 * 1\\n[]\\n\\nNow we can observe that whichever balloon we pick to be burst last, does not have a dependency on any segment or any balloon for that matter.\\nThen, the second last element we pick to be burst only depends on the last balloon to be burst and so on.\\nLet\\'s see if we can generalize this thinking.\\n\\nLets go back to [1,2,3,4,5,6,7,8] as our array:\\nFor simplicity of explanation, we can add 1 at the start and end of this array\\n1 [1,2,3,4,5,6,7,8] 1\\nIf we pick 5 to be the last element that would be burst, we know for a fact that we get 1 * 5 * 1 coins\\nwhich is nothing but **(value at left of my segment) * value * (value at right of my segment)**\\nNow, we partition the array into two segments at 5:\\n1 [1,2,3,4] 5 [6,7,8] 1\\nFor segment 1, if we pick 3 to be last element to be burst, the cost is going to be 1 * 3 * 5 (this can be thought of as the array was only [1,2,3,4,5] and then we burst 5 last and 3 second last) which is nothing but **(value at left of my segment) * value * (value at right of my segment)**\\n\\nSo if we partition our array according to which balloon to burst last in a segment, we can see that each segment is independent of the other segments and thus we can apply partition dp.\\n\\n**Recursion + memoisation solution**\\n```\\nclass Solution {\\npublic:\\n    int recurr(int left, int right, vector<int> &a, vector<vector<int>> &dp) {\\n        \\n\\t\\t// base case: no answer is possible if range is invalid\\n        if (left > right) return 0;\\n        \\n\\t\\t// if answer is pre calculated, return it\\n        if (dp[left][right] != -1) return dp[left][right]; \\n        \\n        int ans = 0;\\n        for (int burst = left; burst<=right; burst++) {\\n\\t\\t\\t// cost + answer of left segment + answer of right segment\\t\\n            ans = max(ans, a[left-1] * a[burst] * a[right+1] + recurr(left, burst-1, a, dp) + recurr(burst+1, right, a, dp));\\n        }\\n\\t\\t// store the answer for later use\\n        dp[left][right] = ans;\\n        return ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> numsCopy;\\n\\t\\t// inserting 1\\'s at left and right for easier implementation\\n        numsCopy.push_back(1);\\n        for (int &i: nums) {\\n            numsCopy.push_back(i);\\n        }\\n        numsCopy.push_back(1);\\n        \\n        vector<vector<int>> dp(n+2, vector<int>(n+2, -1));\\n        \\n        return recurr(1, n, numsCopy, dp);\\n    }\\n};\\n```\\n\\n**DP solution**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> a;\\n        a.push_back(1);\\n        for (int i: nums) {\\n            a.push_back(i);\\n        }\\n        a.push_back(1);\\n        \\n        vector<vector<int>> dp(n+2, vector<int>(n+2, 0));\\n        \\n        // base case\\n        for (int left = 0; left<n+2; left++) {\\n            for (int right = left-1; right>=0; right--) {\\n                dp[left][right] = 0;\\n            }\\n        }\\n        \\n        for (int left = n; left>=1; left--) {\\n            for (int right = left; right<=n; right++) {\\n                int ans = 0;\\n                \\n                for (int burst = left; burst<=right; burst++) {\\n                    ans = max(ans, a[left-1] * a[burst] * a[right+1] + dp[left][burst-1] + dp[burst+1][right]);\\n                }\\n                \\n                dp[left][right] = ans;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```\\n\\nA good follow up for this problem is: https://leetcode.com/problems/pizza-with-3n-slices/",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recurr(int left, int right, vector<int> &a, vector<vector<int>> &dp) {\\n        \\n\\t\\t// base case: no answer is possible if range is invalid\\n        if (left > right) return 0;\\n        \\n\\t\\t// if answer is pre calculated, return it\\n        if (dp[left][right] != -1) return dp[left][right]; \\n        \\n        int ans = 0;\\n        for (int burst = left; burst<=right; burst++) {\\n\\t\\t\\t// cost + answer of left segment + answer of right segment\\t\\n            ans = max(ans, a[left-1] * a[burst] * a[right+1] + recurr(left, burst-1, a, dp) + recurr(burst+1, right, a, dp));\\n        }\\n\\t\\t// store the answer for later use\\n        dp[left][right] = ans;\\n        return ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> numsCopy;\\n\\t\\t// inserting 1\\'s at left and right for easier implementation\\n        numsCopy.push_back(1);\\n        for (int &i: nums) {\\n            numsCopy.push_back(i);\\n        }\\n        numsCopy.push_back(1);\\n        \\n        vector<vector<int>> dp(n+2, vector<int>(n+2, -1));\\n        \\n        return recurr(1, n, numsCopy, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> a;\\n        a.push_back(1);\\n        for (int i: nums) {\\n            a.push_back(i);\\n        }\\n        a.push_back(1);\\n        \\n        vector<vector<int>> dp(n+2, vector<int>(n+2, 0));\\n        \\n        // base case\\n        for (int left = 0; left<n+2; left++) {\\n            for (int right = left-1; right>=0; right--) {\\n                dp[left][right] = 0;\\n            }\\n        }\\n        \\n        for (int left = n; left>=1; left--) {\\n            for (int right = left; right<=n; right++) {\\n                int ans = 0;\\n                \\n                for (int burst = left; burst<=right; burst++) {\\n                    ans = max(ans, a[left-1] * a[burst] * a[right+1] + dp[left][burst-1] + dp[burst+1][right]);\\n                }\\n                \\n                dp[left][right] = ans;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396653,
                "title": "c-simple-solution-with-explanation-dp",
                "content": "```\\nFor better explanation  please watch this video : https://youtu.be/Fh9bf0RbQ1k\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(),vector<int>(nums.size(),-1));\\n        int start=0;\\n        int end=nums.size()-1;\\n        return fun(nums,dp,start,end);\\n    }\\n    int fun(vector<int>&nums,vector<vector<int>>&dp,int start,int end)\\n    {\\n        if(start>end)\\n        {\\n            return 0; //no balloon left\\n        }\\n        if(dp[start][end]!=-1)\\n        {\\n            return dp[start][end];\\n        }\\n        int ans=INT_MIN;\\n        for(int k=start;k<=end;k++)\\n        {\\n            int val1=1;//nums[start-1]\\n            int val2=1;//nums[end+1]\\n            int val3=nums[k];\\n            if(start-1>=0)\\n            {\\n                val1=nums[start-1];\\n            }\\n            if(end+1<=nums.size()-1)\\n            {\\n                val2=nums[end+1];\\n            }\\n            ans=max(ans,val1*val3*val2+fun(nums,dp,start,k-1)+fun(nums,dp,k+1,end));\\n        }\\n        dp[start][end]=ans;\\n        return dp[start][end];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nFor better explanation  please watch this video : https://youtu.be/Fh9bf0RbQ1k\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(),vector<int>(nums.size(),-1));\\n        int start=0;\\n        int end=nums.size()-1;\\n        return fun(nums,dp,start,end);\\n    }\\n    int fun(vector<int>&nums,vector<vector<int>>&dp,int start,int end)\\n    {\\n        if(start>end)\\n        {\\n            return 0; //no balloon left\\n        }\\n        if(dp[start][end]!=-1)\\n        {\\n            return dp[start][end];\\n        }\\n        int ans=INT_MIN;\\n        for(int k=start;k<=end;k++)\\n        {\\n            int val1=1;//nums[start-1]\\n            int val2=1;//nums[end+1]\\n            int val3=nums[k];\\n            if(start-1>=0)\\n            {\\n                val1=nums[start-1];\\n            }\\n            if(end+1<=nums.size()-1)\\n            {\\n                val2=nums[end+1];\\n            }\\n            ans=max(ans,val1*val3*val2+fun(nums,dp,start,k-1)+fun(nums,dp,k+1,end));\\n        }\\n        dp[start][end]=ans;\\n        return dp[start][end];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344792,
                "title": "python-simple-dp",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums=[1]+nums+[1] \\n        n=len(nums)\\n        dp=[[0] * n for _ in range(n)]\\n        for gap in range(2,n):\\n            for i in range(n-gap):\\n                j=i+gap\\n                for k in range(i+1,j):\\n                    dp[i][j]=max(dp[i][j],nums[i]*nums[k]*nums[j]+dp[i][k]+dp[k][j])\\n        return dp[0][n-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums=[1]+nums+[1] \\n        n=len(nums)\\n        dp=[[0] * n for _ in range(n)]\\n        for gap in range(2,n):\\n            for i in range(n-gap):\\n                j=i+gap\\n                for k in range(i+1,j):\\n                    dp[i][j]=max(dp[i][j],nums[i]*nums[k]*nums[j]+dp[i][k]+dp[k][j])\\n        return dp[0][n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338240,
                "title": "c-memoization-tabulation-notes-resources",
                "content": "**Memoization:**\\n`TC = O(n^3), SC = O(n^2) + stack space`\\n```\\nint solve(int i, int j, vector<int> &nums, vector<vector<int>> &dp) {\\n\\tif(i > j) return 0;\\n\\tif(dp[i][j] != -1) return dp[i][j];\\n\\tint result = INT_MIN;\\n\\tfor(int k = i; k <= j; k++) {\\n\\t\\tint temp = nums[i - 1] * nums[k] * nums[j + 1] + \\n\\t\\t\\t\\t\\tsolve(i, k - 1, nums, dp) + solve(k + 1, j, nums, dp);\\n\\t\\tresult = max(result, temp);\\n\\t}\\n\\treturn dp[i][j] = result;\\n}\\n\\nint maxCoins(vector<int>& nums) {\\n\\tnums.insert(nums.begin(), 1);\\n\\tnums.push_back(1);\\n\\tint n = nums.size();\\n\\tvector<vector<int>> dp(n - 1, vector<int>(n - 1, -1));\\n\\treturn solve(1, n - 2, nums, dp);\\n}\\n```\\n\\n**Tabulation:**\\n`TC = O(n^3), SC = O(n^2)`\\n```\\nint maxCoins(vector<int>& nums) {\\n\\tnums.insert(nums.begin(), 1);\\n\\tnums.push_back(1);\\n\\tint n = nums.size();\\n\\tvector<vector<int>> dp(n, vector<int>(n - 1, 0));\\n\\tfor(int x = 1; x < n - 1; x++) {\\n\\t\\tint i = 1, j = x;\\n\\t\\twhile(j < n - 1) {\\n\\t\\t\\tint result = INT_MIN;\\n\\t\\t\\tfor(int k = i; k <= j; k++) {\\n\\t\\t\\t\\tint temp = nums[i - 1] * nums[k] * nums[j + 1] + \\n\\t\\t\\t\\t\\t\\t\\tdp[i][k - 1] + dp[k + 1][j];\\n\\t\\t\\t\\tresult = max(result, temp);\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] = result;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n - 2];\\n}\\n```\\n\\n**Notes:**\\n![image](https://assets.leetcode.com/users/images/7d62252c-a550-4e59-9c9b-798261a1f90b_1658866211.0847857.jpeg)\\n![image](https://assets.leetcode.com/users/images/9db31aa4-f607-4b27-bb5f-66df4bd0865a_1658866217.2730846.jpeg)\\n\\n**Resources:**\\nhttps://www.youtube.com/watch?v=zfgZtcDQAxw\\nhttps://www.youtube.com/watch?v=YzvF8CqPafI\\nhttps://www.youtube.com/watch?v=Yz4LlDSlkns",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(int i, int j, vector<int> &nums, vector<vector<int>> &dp) {\\n\\tif(i > j) return 0;\\n\\tif(dp[i][j] != -1) return dp[i][j];\\n\\tint result = INT_MIN;\\n\\tfor(int k = i; k <= j; k++) {\\n\\t\\tint temp = nums[i - 1] * nums[k] * nums[j + 1] + \\n\\t\\t\\t\\t\\tsolve(i, k - 1, nums, dp) + solve(k + 1, j, nums, dp);\\n\\t\\tresult = max(result, temp);\\n\\t}\\n\\treturn dp[i][j] = result;\\n}\\n\\nint maxCoins(vector<int>& nums) {\\n\\tnums.insert(nums.begin(), 1);\\n\\tnums.push_back(1);\\n\\tint n = nums.size();\\n\\tvector<vector<int>> dp(n - 1, vector<int>(n - 1, -1));\\n\\treturn solve(1, n - 2, nums, dp);\\n}\\n```\n```\\nint maxCoins(vector<int>& nums) {\\n\\tnums.insert(nums.begin(), 1);\\n\\tnums.push_back(1);\\n\\tint n = nums.size();\\n\\tvector<vector<int>> dp(n, vector<int>(n - 1, 0));\\n\\tfor(int x = 1; x < n - 1; x++) {\\n\\t\\tint i = 1, j = x;\\n\\t\\twhile(j < n - 1) {\\n\\t\\t\\tint result = INT_MIN;\\n\\t\\t\\tfor(int k = i; k <= j; k++) {\\n\\t\\t\\t\\tint temp = nums[i - 1] * nums[k] * nums[j + 1] + \\n\\t\\t\\t\\t\\t\\t\\tdp[i][k - 1] + dp[k + 1][j];\\n\\t\\t\\t\\tresult = max(result, temp);\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] = result;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n - 2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2304333,
                "title": "java-solution-memoization-tabulation",
                "content": "These are the two DP solutions.\\nThese solutions are similar to Matrix Chain Multiplication Problem.\\n\\nMemoization\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i = 0 ; i <= n ; i++)\\n            for(int j = 0 ; j <= n ; j++)\\n                dp[i][j] = -1;\\n        int[] arr = new int[n+2];\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            arr[i] = nums[i-1];\\n        }\\n        arr[0] = 1;\\n        arr[n+1] = 1;\\n        \\n        return coins(arr , 1 , n , dp);\\n    }\\n    \\n    int coins(int[] arr , int i , int j , int[][] dp){\\n        if(i > j)   return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        for(int k = i ; k <= j ; k++)\\n        {\\n            dp[i][j] = (int)Math.max(dp[i][j] , arr[i-1]*arr[j+1]*arr[k] + coins(arr , i , k-1 , dp) + coins(arr , k+1 , j , dp));\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}\\n```\\n\\nTabulation\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n+2][n+2];\\n        int[] arr = new int[n+2];\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            arr[i] = nums[i-1];\\n        }\\n        arr[0] = 1;\\n        arr[n+1] = 1;\\n        \\n        for(int i = n ; i >= 1 ; i--){\\n            for(int j = i ; j <= n ; j++)\\n            {\\n                for(int k = i ; k <= j ; k++)\\n                {\\n                    dp[i][j] = (int)Math.max(dp[i][j] , arr[i-1]*arr[j+1]*arr[k] + dp[i][k-1] + dp[k+1][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n}\\n```\\n\\nIf you like the solution, please UPVOTE :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i = 0 ; i <= n ; i++)\\n            for(int j = 0 ; j <= n ; j++)\\n                dp[i][j] = -1;\\n        int[] arr = new int[n+2];\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            arr[i] = nums[i-1];\\n        }\\n        arr[0] = 1;\\n        arr[n+1] = 1;\\n        \\n        return coins(arr , 1 , n , dp);\\n    }\\n    \\n    int coins(int[] arr , int i , int j , int[][] dp){\\n        if(i > j)   return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        for(int k = i ; k <= j ; k++)\\n        {\\n            dp[i][j] = (int)Math.max(dp[i][j] , arr[i-1]*arr[j+1]*arr[k] + coins(arr , i , k-1 , dp) + coins(arr , k+1 , j , dp));\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[][] dp = new int[n+2][n+2];\\n        int[] arr = new int[n+2];\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            arr[i] = nums[i-1];\\n        }\\n        arr[0] = 1;\\n        arr[n+1] = 1;\\n        \\n        for(int i = n ; i >= 1 ; i--){\\n            for(int j = i ; j <= n ; j++)\\n            {\\n                for(int k = i ; k <= j ; k++)\\n                {\\n                    dp[i][j] = (int)Math.max(dp[i][j] , arr[i-1]*arr[j+1]*arr[k] + dp[i][k-1] + dp[k+1][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278728,
                "title": "burst-balloons-easy-java-solution",
                "content": "class Solution {\\n      public int f(int i ,int j,int a[],int dp[][]){\\n            if(i>j) return 0;  \\n            int maxi = Integer.MIN_VALUE;\\n        \\n        if(dp[i][j] > 0){\\n            return dp[i][j] ;\\n        }\\n        for(int ind =i;ind <= j;ind++){\\n            int cost = a[i-1] * a[ind] * a[j+1] + f(i,ind-1,a,dp) + f(ind+1,j,a,dp);\\n            maxi= Math.max(cost,maxi);\\n            \\n        }\\n        return dp[i][j] =  maxi;\\n    }\\n    public int maxCoins(int[] nums) {\\n        int n = nums.length;\\n        int[] nCuts = new int[n + 2];         // creating a new array of size n+2\\n        nCuts[0] = 1;                         // inserting 1 at the front  \\n        nCuts[n + 1] = 1;                     //inserting 1 at the back\\n        System.arraycopy(nums, 0, nCuts, 1, n);\\n        \\n        int dp[][] = new int[n+1][n+1];\\n        return f(1,n,nCuts,dp);\\n    }\\n\\t\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n      public int f(int i ,int j,int a[],int dp[][]){\\n            if(i>j) return 0;  \\n            int maxi = Integer.MIN_VALUE;\\n        \\n        if(dp[i][j] > 0){\\n            return dp[i][j] ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2180247,
                "title": "using-dynamic-programming-o-n-3-recursion-memoization",
                "content": "```\\n int f(int i,int j,vector<int>&nums,vector<vector<int>>&dp){\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int res=INT_MIN;\\n        for(int k=i;k<=j;k++){\\n            int ans=nums[i-1]*nums[k]*nums[j+1]+f(i,k-1,nums,dp)+f(k+1,j,nums,dp);\\n            res=max(res,ans);\\n        }\\n        \\n        return dp[i][j]=res;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));        \\n        return f(1,n,nums,dp);\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int f(int i,int j,vector<int>&nums,vector<vector<int>>&dp){\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int res=INT_MIN;\\n        for(int k=i;k<=j;k++){\\n            int ans=nums[i-1]*nums[k]*nums[j+1]+f(i,k-1,nums,dp)+f(k+1,j,nums,dp);\\n            res=max(res,ans);\\n        }\\n        \\n        return dp[i][j]=res;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        int n=nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));        \\n        return f(1,n,nums,dp);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178657,
                "title": "java-recursion-memoization-tabulation",
                "content": "**Recursive Solution**\\n```\\n\\n    class Solution {\\n        public int maxCoins (int[] nums) {\\n            int n = nums.length;\\n            int[] arr = new int[n + 2];\\n            arr[0] = 1;\\n            arr[arr.length - 1] = 1;\\n            for (int i = 1; i < arr.length - 1; i++) {\\n                arr[i] = nums[i - 1];\\n            }\\n            return maxCoinsHelper(arr, 1, arr.length - 2);\\n        }\\n        public int maxCoinsHelper (int[] nums, int i, int j) {\\n            if (i > j)\\n                return 0;\\n            int maxCoins = Integer.MIN_VALUE;\\n            for (int k = i; k <= j; k++) {\\n                int cost = (nums[i - 1] * nums[k] * nums[j + 1]) + maxCoinsHelper(nums, i, k - 1) + maxCoinsHelper(nums, k + 1, j);\\n                maxCoins = Math.max(maxCoins, cost);\\n            }\\n            return maxCoins;\\n        }\\n    }\\n```\\n\\nTime Complexity : Exponential \\nSpace Complexity : Auxilary Stack Space\\n\\n**Memoization (Top-down DP)**\\n\\n```\\n\\n    class Solution {\\n        public int maxCoins (int[] nums) {\\n            int n = nums.length;\\n            int[][] dp = new int[n + 2][n + 2];\\n            for (int[] row : dp)\\n                Arrays.fill(row, -1);\\n            int[] arr = new int[n + 2];\\n            arr[0] = 1;\\n            arr[arr.length - 1] = 1;\\n            for (int i = 1; i < arr.length - 1; i++) {\\n                arr[i] = nums[i - 1];\\n            }\\n            return maxCoinsHelper(arr, 1, arr.length - 2, dp);\\n        }\\n        public int maxCoinsHelper (int[] nums, int i, int j, int[][] dp) {\\n            if (i > j)\\n                return 0;\\n            if (dp[i][j] != -1)\\n                return dp[i][j];\\n            int maxCoins = Integer.MIN_VALUE;\\n            for (int k = i; k <= j; k++) {\\n                int cost = (nums[i - 1] * nums[k] * nums[j + 1]) + maxCoinsHelper(nums, i, k - 1, dp) + maxCoinsHelper(nums, k + 1, j, dp);\\n                maxCoins = Math.max(maxCoins, cost);\\n            }\\n            return dp[i][j] = maxCoins;\\n        }\\n    }\\n```\\n\\nTime Complexity : O(n^3)\\nSpace Complexity : O(n^2) + auxilary stack space\\n\\n**Tabulation (Bottom-up DP)**\\n\\n```\\n\\n    class Solution {\\n        public int maxCoins (int[] nums) {\\n            int n = nums.length;\\n            int[][] dp = new int[n + 2][n + 2];\\n            int[] arr = new int[n + 2];\\n            arr[0] = 1;\\n            arr[arr.length - 1] = 1;\\n            for (int i = 1; i < arr.length - 1; i++) {\\n                arr[i] = nums[i - 1];\\n            }\\n            for (int i = n; i >= 1; i--) {\\n                for (int j = 1; j <= n; j++) {\\n                    if (i > j) continue;\\n                    int maxCoins = Integer.MIN_VALUE;\\n                    for (int k = i; k <= j; k++) {\\n                        int cost = (arr[i - 1] * arr[k] * arr[j + 1]) + dp[i][k - 1] + dp[k + 1][j];\\n                        maxCoins = Math.max(maxCoins, cost);\\n                    }\\n                    dp[i][j] = maxCoins;\\n                }\\n            }\\n            return dp[1][n];\\n        }\\n    }\\n```\\n\\nTime Complexity : O(n^3)\\nSpace Complexity : O(n^2)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n    class Solution {\\n        public int maxCoins (int[] nums) {\\n            int n = nums.length;\\n            int[] arr = new int[n + 2];\\n            arr[0] = 1;\\n            arr[arr.length - 1] = 1;\\n            for (int i = 1; i < arr.length - 1; i++) {\\n                arr[i] = nums[i - 1];\\n            }\\n            return maxCoinsHelper(arr, 1, arr.length - 2);\\n        }\\n        public int maxCoinsHelper (int[] nums, int i, int j) {\\n            if (i > j)\\n                return 0;\\n            int maxCoins = Integer.MIN_VALUE;\\n            for (int k = i; k <= j; k++) {\\n                int cost = (nums[i - 1] * nums[k] * nums[j + 1]) + maxCoinsHelper(nums, i, k - 1) + maxCoinsHelper(nums, k + 1, j);\\n                maxCoins = Math.max(maxCoins, cost);\\n            }\\n            return maxCoins;\\n        }\\n    }\\n```\n```\\n\\n    class Solution {\\n        public int maxCoins (int[] nums) {\\n            int n = nums.length;\\n            int[][] dp = new int[n + 2][n + 2];\\n            for (int[] row : dp)\\n                Arrays.fill(row, -1);\\n            int[] arr = new int[n + 2];\\n            arr[0] = 1;\\n            arr[arr.length - 1] = 1;\\n            for (int i = 1; i < arr.length - 1; i++) {\\n                arr[i] = nums[i - 1];\\n            }\\n            return maxCoinsHelper(arr, 1, arr.length - 2, dp);\\n        }\\n        public int maxCoinsHelper (int[] nums, int i, int j, int[][] dp) {\\n            if (i > j)\\n                return 0;\\n            if (dp[i][j] != -1)\\n                return dp[i][j];\\n            int maxCoins = Integer.MIN_VALUE;\\n            for (int k = i; k <= j; k++) {\\n                int cost = (nums[i - 1] * nums[k] * nums[j + 1]) + maxCoinsHelper(nums, i, k - 1, dp) + maxCoinsHelper(nums, k + 1, j, dp);\\n                maxCoins = Math.max(maxCoins, cost);\\n            }\\n            return dp[i][j] = maxCoins;\\n        }\\n    }\\n```\n```\\n\\n    class Solution {\\n        public int maxCoins (int[] nums) {\\n            int n = nums.length;\\n            int[][] dp = new int[n + 2][n + 2];\\n            int[] arr = new int[n + 2];\\n            arr[0] = 1;\\n            arr[arr.length - 1] = 1;\\n            for (int i = 1; i < arr.length - 1; i++) {\\n                arr[i] = nums[i - 1];\\n            }\\n            for (int i = n; i >= 1; i--) {\\n                for (int j = 1; j <= n; j++) {\\n                    if (i > j) continue;\\n                    int maxCoins = Integer.MIN_VALUE;\\n                    for (int k = i; k <= j; k++) {\\n                        int cost = (arr[i - 1] * arr[k] * arr[j + 1]) + dp[i][k - 1] + dp[k + 1][j];\\n                        maxCoins = Math.max(maxCoins, cost);\\n                    }\\n                    dp[i][j] = maxCoins;\\n                }\\n            }\\n            return dp[1][n];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173582,
                "title": "c-mcm-tle-recursive-to-ac-dp-memoization",
                "content": "```\\n// (TLE) Recustive Soln - Time: O(Exponential)\\nclass Solution {\\npublic:\\n    int f(vector<int> &arr, int i, int j) {\\n        if (j - i + 1 <= 2) return 0;\\n        int money = INT_MIN;\\n        for (int k = i + 1; k < j; k++) {\\n            int curMoney = (arr[i] * arr[k] * arr[j]) + f(arr, i, k) + f(arr, k, j);\\n            money = max(money, curMoney);            \\n        }\\n        return money;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        return f(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\n\\n```\\n// (AC) Memoization Soln - Time O(Cubic)\\nclass Solution {\\npublic:\\n    int dp[305][305]; // Declare DP\\n    \\n    int f(vector<int> &arr, int i, int j) {\\n        if (j - i + 1 <= 2) return 0;\\n        if (dp[i][j] != -1) return dp[i][j]; // Check DP state\\n        int money = INT_MIN;\\n        for (int k = i + 1; k < j; k++) {\\n            int curMoney = (arr[i] * arr[k] * arr[j]) + f(arr, i, k) + f(arr, k, j);\\n            money = max(money, curMoney);            \\n        }\\n        return dp[i][j] = money; // Save result in DP\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp)); // Initialize DP\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        return f(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// (TLE) Recustive Soln - Time: O(Exponential)\\nclass Solution {\\npublic:\\n    int f(vector<int> &arr, int i, int j) {\\n        if (j - i + 1 <= 2) return 0;\\n        int money = INT_MIN;\\n        for (int k = i + 1; k < j; k++) {\\n            int curMoney = (arr[i] * arr[k] * arr[j]) + f(arr, i, k) + f(arr, k, j);\\n            money = max(money, curMoney);            \\n        }\\n        return money;\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        return f(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\n```\\n// (AC) Memoization Soln - Time O(Cubic)\\nclass Solution {\\npublic:\\n    int dp[305][305]; // Declare DP\\n    \\n    int f(vector<int> &arr, int i, int j) {\\n        if (j - i + 1 <= 2) return 0;\\n        if (dp[i][j] != -1) return dp[i][j]; // Check DP state\\n        int money = INT_MIN;\\n        for (int k = i + 1; k < j; k++) {\\n            int curMoney = (arr[i] * arr[k] * arr[j]) + f(arr, i, k) + f(arr, k, j);\\n            money = max(money, curMoney);            \\n        }\\n        return dp[i][j] = money; // Save result in DP\\n    }\\n    \\n    int maxCoins(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp)); // Initialize DP\\n        nums.push_back(1);\\n        nums.insert(nums.begin(), 1);\\n        return f(nums, 0, nums.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161863,
                "title": "c-easy-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tint helper(vector<int> &nums, int i, int j, vector<vector<int>> &dp) {\\n\\t\\tif (i > j) return 0;\\n\\t\\tif (dp[i][j] != -1) return dp[i][j];\\n\\t\\tint maxi = INT_MIN;\\n\\t\\tfor (int ind = i; ind <= j; ++ind) {\\n\\t\\t\\tint cost = nums[i - 1] * nums[ind] * nums[j + 1] + helper(nums, i, ind - 1, dp) + helper(nums, ind + 1, j, dp);\\n\\t\\t\\tmaxi = max(maxi, cost);\\n\\t\\t}\\n\\t\\treturn dp[i][j] = maxi;\\n\\t}\\npublic:\\n\\tint maxCoins(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tnums.push_back(1);\\n\\t\\tnums.insert(nums.begin(), 1);\\n\\t\\tvector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n\\t\\treturn helper(nums, 1, n, dp);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint helper(vector<int> &nums, int i, int j, vector<vector<int>> &dp) {\\n\\t\\tif (i > j) return 0;\\n\\t\\tif (dp[i][j] != -1) return dp[i][j];\\n\\t\\tint maxi = INT_MIN;\\n\\t\\tfor (int ind = i; ind <= j; ++ind) {\\n\\t\\t\\tint cost = nums[i - 1] * nums[ind] * nums[j + 1] + helper(nums, i, ind - 1, dp) + helper(nums, ind + 1, j, dp);\\n\\t\\t\\tmaxi = max(maxi, cost);\\n\\t\\t}\\n\\t\\treturn dp[i][j] = maxi;\\n\\t}\\npublic:\\n\\tint maxCoins(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tnums.push_back(1);\\n\\t\\tnums.insert(nums.begin(), 1);\\n\\t\\tvector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n\\t\\treturn helper(nums, 1, n, dp);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106035,
                "title": "for-those-who-are-still-stuck-at-this-problem",
                "content": "Have a look at this video\\nhttps://www.youtube.com/watch?v=VFskby7lUbw\\nI could not figure out the solution even after looking at the solution.\\nThe video explained pretty well on the process of the dynamic programming. Its basically a different approach which is looking for the element if its is popped last in the given subarray. Doing so we get a consistent sub problem that can be memoised.\\nHis code is in python so I just converted it to C++ if anyone wants to have a look at that!\\nThanks :)\\n```\\nclass Solution {\\nprivate:\\n    int helper(int l, int r, vector<int>& nums, vector<vector<int>>& dp){\\n        // cout<<l<<\" \"<<r<<endl;\\n        if(l>r) return 0;\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        int coins = 0;\\n        for(int i=l;i<=r;i++){\\n            // cout<<\"i :\"<<i<<endl;\\n            coins = nums[l-1]*nums[i]*nums[r+1];\\n\\t\\t\\t// the left and the right subarray sum is also needed to calculate \\n\\t\\t\\t// the final number of coins if the given element is popped the last\\n            coins+= helper(l,i-1,nums,dp) + helper(i+1,r,nums,dp);\\n            dp[l][r] = max(dp[l][r], coins);\\n            // cout<<dp[l][r];\\n        }\\n        return dp[l][r];\\n    }\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n\\t\\t// Add 1 to both the end of the given array \\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        vector<vector<int>> dp(nums.size(),vector<int> (nums.size(),-1));\\n\\n        return helper(1,nums.size()-2,nums, dp);\\n    }\\n};\\n\\n// Time complexity : O(n^3)\\n// Space Complexit : O(n^2)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int l, int r, vector<int>& nums, vector<vector<int>>& dp){\\n        // cout<<l<<\" \"<<r<<endl;\\n        if(l>r) return 0;\\n        if(dp[l][r]!=-1) return dp[l][r];\\n        int coins = 0;\\n        for(int i=l;i<=r;i++){\\n            // cout<<\"i :\"<<i<<endl;\\n            coins = nums[l-1]*nums[i]*nums[r+1];\\n\\t\\t\\t// the left and the right subarray sum is also needed to calculate \\n\\t\\t\\t// the final number of coins if the given element is popped the last\\n            coins+= helper(l,i-1,nums,dp) + helper(i+1,r,nums,dp);\\n            dp[l][r] = max(dp[l][r], coins);\\n            // cout<<dp[l][r];\\n        }\\n        return dp[l][r];\\n    }\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n\\t\\t// Add 1 to both the end of the given array \\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        vector<vector<int>> dp(nums.size(),vector<int> (nums.size(),-1));\\n\\n        return helper(1,nums.size()-2,nums, dp);\\n    }\\n};\\n\\n// Time complexity : O(n^3)\\n// Space Complexit : O(n^2)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1946760,
                "title": "same-concept-as-matrix-chain-multiplication-memoization-tabulation",
                "content": "The question is an exact type of Matix Chain Multiplication with a little change. First of all we have to keep track of maximum instead of minimum and to keep a check of out of bound indexes, we add 1 at the start of the array and the end of the array.\\n\\nMemoization Solution :\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<int> &nums, vector<vector<int>> &dp){\\n        if(i == j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = -1e9;\\n        \\n        for(int k=i;k<j;k++){\\n            int steps = nums[i-1] * nums[k] * nums[j] + f(i,k,nums,dp) + f(k+1,j,nums,dp);\\n            ans = max(ans,steps);\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        // Add 1 at start and end to take care of out of bond situations\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n\\t\\t\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return f(1,n-1,nums,dp);\\n\\t\\t}\\n\\t};\\n```\\n\\nTabulation Solution :\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        // Add 1 at start and end to take care of out of bond situations\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][i] = 0;\\n        }\\n        \\n        for(int i=n-1;i>=1;i--){\\n            for(int j=i+1;j<n;j++){\\n                int ans = -1e9;\\n                for(int k=i;k<j;k++){\\n                    int steps = nums[i-1]*nums[k]*nums[j] + dp[i][k] + dp[k+1][j];\\n                    ans = max(ans,steps);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<int> &nums, vector<vector<int>> &dp){\\n        if(i == j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = -1e9;\\n        \\n        for(int k=i;k<j;k++){\\n            int steps = nums[i-1] * nums[k] * nums[j] + f(i,k,nums,dp) + f(k+1,j,nums,dp);\\n            ans = max(ans,steps);\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        // Add 1 at start and end to take care of out of bond situations\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n\\t\\t\\n        int n = nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return f(1,n-1,nums,dp);\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        // Add 1 at start and end to take care of out of bond situations\\n        nums.insert(nums.begin(),1);\\n        nums.push_back(1);\\n        int n = nums.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][i] = 0;\\n        }\\n        \\n        for(int i=n-1;i>=1;i--){\\n            for(int j=i+1;j<n;j++){\\n                int ans = -1e9;\\n                for(int k=i;k<j;k++){\\n                    int steps = nums[i-1]*nums[k]*nums[j] + dp[i][k] + dp[k+1][j];\\n                    ans = max(ans,steps);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878009,
                "title": "backtrack-timeoout-fail",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n\\n    public int maxCoins(int[] nums) {\\n        backtrack(nums, new HashSet<>(), 0);\\n        return max;\\n    }\\n\\n    private void backtrack(int[] nums, Set<Integer> used, int product) {\\n        if (used.size() == nums.length) {\\n            max = Math.max(max, product);\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (!used.contains(i)) {\\n                    used.add(i);\\n                    backtrack(nums, used, product + neighborProduct(used, i, nums));\\n                    used.remove(i);\\n                }\\n            }\\n        }\\n    }\\n\\n    private int neighborProduct(Set<Integer> used, int i, int[] nums) {\\n        return getPrev(nums, i - 1, used) * nums[i] * getNext(nums, i + 1, used);\\n    }\\n\\n    private int getNext(int[] nums, int i, Set<Integer> used) {\\n        if (i == nums.length) {\\n            return 1;\\n        }\\n        if (used.contains(i)) {\\n            return getNext(nums, i + 1, used);\\n        }\\n        return nums[i];\\n    }\\n\\n    private int getPrev(int[] nums, int i, Set<Integer> used) {\\n        if (i < 0) {\\n            return 1;\\n        }\\n        if (used.contains(i)) {\\n            return getPrev(nums, i - 1, used);\\n        }\\n        return nums[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n\\n    public int maxCoins(int[] nums) {\\n        backtrack(nums, new HashSet<>(), 0);\\n        return max;\\n    }\\n\\n    private void backtrack(int[] nums, Set<Integer> used, int product) {\\n        if (used.size() == nums.length) {\\n            max = Math.max(max, product);\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (!used.contains(i)) {\\n                    used.add(i);\\n                    backtrack(nums, used, product + neighborProduct(used, i, nums));\\n                    used.remove(i);\\n                }\\n            }\\n        }\\n    }\\n\\n    private int neighborProduct(Set<Integer> used, int i, int[] nums) {\\n        return getPrev(nums, i - 1, used) * nums[i] * getNext(nums, i + 1, used);\\n    }\\n\\n    private int getNext(int[] nums, int i, Set<Integer> used) {\\n        if (i == nums.length) {\\n            return 1;\\n        }\\n        if (used.contains(i)) {\\n            return getNext(nums, i + 1, used);\\n        }\\n        return nums[i];\\n    }\\n\\n    private int getPrev(int[] nums, int i, Set<Integer> used) {\\n        if (i < 0) {\\n            return 1;\\n        }\\n        if (used.contains(i)) {\\n            return getPrev(nums, i - 1, used);\\n        }\\n        return nums[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841743,
                "title": "easy-to-understand-explanation-java",
                "content": "1st Approach - TLE \\n\\nAll the balloons needs to be bursted. You can try all the different sequences in which you can burst balloons and take the maximum sum obtained among all sequences. There can be n! ( n factorial ) sequences and calculating the score for each sequence would take another O(n) operation. So the overall complexity of the solution will be O(n * n!) which is huge and clearly will not pass.\\n\\nEg - nums = [ 2,3,4]\\nWays to burst = 3! = 6\\nAll the ways are :  \\n1.  1 -> 2 ->3  ===> score = (1x2x3 + 1x3x4 + 1x4x1)     =  22\\n2.  1 -> 3 ->2  ===> score = (1x2x3 + 3x4x1 + 1x3x1)     =  21\\n3.  2 -> 1 ->3  ===> score = (2x3x4 + 1x2x4 + 1x4x1)     =  36\\n4.  2 -> 3 -> 1 ===> score = (2x3x4 +  2x4x1 + 1x2x1)    =  34\\n5.  3 -> 1 -> 2 ===> score = (3x4x1 + 1x2x3 + 1x3x1)     =  21\\n6.  3 -> 2 -> 1 ===> score = (3x4x1 + 2x3x1 + 1x2x1)     =  20 \\n\\nSo the answer will be 36 which was obtained by bursting 2nd ballon, then 1st balloon and finally the third balloon\\n\\n\\n2nd Approach - TLE\\n\\nNote that after bursting some number of balloons , you will be left with some balloons in the array which you need to burst. No matter what sequnce you follwed to burst the previous balloons, once you reach the current set of remaining balloons, you will always have a single answer which is basically the maximum you can get if you burst the current balloons in the best possible way. That means,  the order in which all the previous balloons were bursted does not matter to dertermine the answer for the present set of balloons. \\nThe answer for the current set of balloons solely depends on the remaining balloons. We can already start thinking of a dp solution now. Our state can be set of all the balloons which have been bursted ( order doesnt matter).We can loop over the reamining balloons and try bursting them one by one. Once we burst a ballloon , we can add it to the set of bursted balloons and pass it as the next dp call. We can take the maximum of all orders to know the answer. When bursting a balloon, the points we get can be easily calculated by finding the elements left to it which is not yet bursted and the element right to it which is not bursted. The pseudo code will look something like this\\n```\\nint find(Set<Integers> alreadyBursted){\\n    if(bursted.size() == nums.length) return 0; // all balloons have been bursted\\n\\telse if (dp[alreadyBursted]!=-1 )return dp[alreadyBursted]; // we have already calculated the best answer if a set of balloons were already bursted\\n\\telse{\\n\\t            int ans = 0;\\n\\t            for(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t    if(!alreadyBursted.contains(i)){ // if ith is not bursted yet\\n\\t\\t\\t\\t\\t\\t\\t// take the maximum among all ans i.e here we see bursting what next can give us maximum points\\n\\t\\t\\t\\t\\t\\t\\talreadyBursted.add(i); // Add i to bursted \\n\\t\\t\\t\\t\\t\\t\\tint prev = -1, next = -1;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t// loop to see which element on left of this is not bursted yet.\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=i-1;j>=0;j--){\\n\\t\\t\\t\\t\\t\\t\\t  if(!alreadyBursted.contains(j)){ \\n\\t\\t\\t\\t\\t\\t\\t    prev = j;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t// loop to find the element to right which is not bursted yet\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=i+1;j<nums.length;j++){\\n\\t\\t\\t\\t\\t\\t\\t if(!alreadyBursted.contains(j)){ \\n\\t\\t\\t\\t\\t\\t\\t    next = j;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = Math.max(ans, nums[i]*nums[prev]*nums[next] + find(alreadyBursted));\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn dp[alreadyBursted] = ans;\\n\\t}\\n}\\n\\n// find method will be called with empty set to get the answer.\\n```\\nThe problem with the above appraoch is many fold. The state of a dp have to be stored as a set. You need to loop everytime to find previous and next element which has not been deleted. To pass arguments for the next call, you need to make sure different function calls have their own version of sets for which you need to clone the sets before modifying them specially for languages such as Java where all calls can reference and modify the same underlying set if not properly cloned. All these will take a lot of time and memory and will probably be a TLE.\\n\\n3rd Approach - AC \\nLets try to change the approach a little bit. Note that all the balloons needs to be bursted. That means there will be some balloon say x which will  burst at last. Since x will burst at last, all the balloons left to it, will burst before it and also all balloons  to the right of x, will burst before it i.e if balloon x is at index i, then all the balloons from 0 to (i-1) would have been bursted and all the balloons from ( i+1 to nums.length-1) would have been bursted before it. Now if we know the answer of bursting balloons 0 to (i-1) and we also know the answer for bursting all balloons from (i+1) to (nums.length-1) say ans1 and ans2. Our final ans will be finalAns = points obtained by bursting i\\'th balloon at last + ans1 + ans2. How do we calculate the points obtained from bursting some balloon at last? It would simply be the product of  the last element * what is not yet bursted at left of it * what is not yet bursted at the right of it. \\n\\nHow to know which element at left or right is not bursted yet - Lets try to generalise our solution. Lets say we are trying to find the answer for some range [l,r] i.e what is the best we get if we burst from l to r in the most optimal way. Again we can say that there will be some jth balloon in this range which will burst at the end. When bursting the j\\'th element, the element which would have not been bursted till now will be (r+1)th element. Why ? Because if [l,r] is called it means some method call decided to first burst all elements from [l,r] and then only they will burst others. if (r+1) is out of bounds then we can assume there is a balloon with value 1.\\nWith the same logic, we can safely say that the left element which was not burst will be nums[l-1]. So the asnwer for some range [l,r] can be easily calculated by deciding which element in the range to be bursted at last and adding with the points which will be obrtained by choosing the last elemts as nums[x] * nums[l-1] * nums[r+1] assuming x is what we decided to burst at last in the [l,r] array. The maximum among all x will be the answer, The code will look something like this\\n \\n```\\nclass Solution {\\n    int[][] dp = new int[305][305];\\n    private void init(){\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[i].length;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    private int find(int st,int en,int[] nums){\\n        if(st > en || st<0 || en>= nums.length)return 0;\\n        else if(dp[st][en]!=-1)return dp[st][en];\\n        else {\\n               int ans = 0;\\n               int prevEl = st-1 < 0 ? 1 : nums[st-1];\\n               int nextEl = en+1 >= nums.length ? 1 : nums[en+1];\\n\\t\\t\\t   //iterate to find the element which will be burst at end \\n               for(int i=st;i<=en;i++){\\n\\t\\t\\t      // ith element in the range [st,en] will be deleted at end\\n\\t\\t\\t\\t   int an1 = find(st,i-1,nums);\\n\\t\\t\\t\\t   int ans2 = find(i+1,en,nums);\\n                   ans = Math.max(ans, nums[i]*prevEl*nextEl +ans1 + ans2) ;\\n               }\\n            return dp[st][en] = ans;\\n            \\n        }\\n    }\\n    \\n    public int maxCoins(int[] nums) {\\n        init();\\n        return find(0,nums.length-1,nums);\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint find(Set<Integers> alreadyBursted){\\n    if(bursted.size() == nums.length) return 0; // all balloons have been bursted\\n\\telse if (dp[alreadyBursted]!=-1 )return dp[alreadyBursted]; // we have already calculated the best answer if a set of balloons were already bursted\\n\\telse{\\n\\t            int ans = 0;\\n\\t            for(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t    if(!alreadyBursted.contains(i)){ // if ith is not bursted yet\\n\\t\\t\\t\\t\\t\\t\\t// take the maximum among all ans i.e here we see bursting what next can give us maximum points\\n\\t\\t\\t\\t\\t\\t\\talreadyBursted.add(i); // Add i to bursted \\n\\t\\t\\t\\t\\t\\t\\tint prev = -1, next = -1;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t// loop to see which element on left of this is not bursted yet.\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=i-1;j>=0;j--){\\n\\t\\t\\t\\t\\t\\t\\t  if(!alreadyBursted.contains(j)){ \\n\\t\\t\\t\\t\\t\\t\\t    prev = j;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t// loop to find the element to right which is not bursted yet\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=i+1;j<nums.length;j++){\\n\\t\\t\\t\\t\\t\\t\\t if(!alreadyBursted.contains(j)){ \\n\\t\\t\\t\\t\\t\\t\\t    next = j;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = Math.max(ans, nums[i]*nums[prev]*nums[next] + find(alreadyBursted));\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn dp[alreadyBursted] = ans;\\n\\t}\\n}\\n\\n// find method will be called with empty set to get the answer.\\n```\n```\\nclass Solution {\\n    int[][] dp = new int[305][305];\\n    private void init(){\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[i].length;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    private int find(int st,int en,int[] nums){\\n        if(st > en || st<0 || en>= nums.length)return 0;\\n        else if(dp[st][en]!=-1)return dp[st][en];\\n        else {\\n               int ans = 0;\\n               int prevEl = st-1 < 0 ? 1 : nums[st-1];\\n               int nextEl = en+1 >= nums.length ? 1 : nums[en+1];\\n\\t\\t\\t   //iterate to find the element which will be burst at end \\n               for(int i=st;i<=en;i++){\\n\\t\\t\\t      // ith element in the range [st,en] will be deleted at end\\n\\t\\t\\t\\t   int an1 = find(st,i-1,nums);\\n\\t\\t\\t\\t   int ans2 = find(i+1,en,nums);\\n                   ans = Math.max(ans, nums[i]*prevEl*nextEl +ans1 + ans2) ;\\n               }\\n            return dp[st][en] = ans;\\n            \\n        }\\n    }\\n    \\n    public int maxCoins(int[] nums) {\\n        init();\\n        return find(0,nums.length-1,nums);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790166,
                "title": "python-8-lines-bottom-up-dp",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        hs = [[0] * n for _ in range(n)]\\n        for s in range(n - 1, -1, -1):\\n            for e in range(s + 1, n):\\n                for k in range(s + 1, e):\\n                    hs[s][e] = max(hs[s][e], hs[s][k] + hs[k][e] + nums[s] * nums[k] * nums[e])\\n        return hs[0][n - 1]\\n```\\nBasically the same problem of Matrix multiplication chain.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        hs = [[0] * n for _ in range(n)]\\n        for s in range(n - 1, -1, -1):\\n            for e in range(s + 1, n):\\n                for k in range(s + 1, e):\\n                    hs[s][e] = max(hs[s][e], hs[s][k] + hs[k][e] + nums[s] * nums[k] * nums[e])\\n        return hs[0][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762345,
                "title": "python-dp-same-as-matrix-multiplication",
                "content": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        \\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        \\n        dptable = [[0]*n for _ in range(n)]\\n        \\n        for i in range(n-1):\\n            dptable[i][i+1] = 0\\n        \\n        for row in range(n, -1, -1):\\n            for col in range(row+2, n):\\n                \\n                for k in range(row+1, col):\\n                    \\n                    dptable[row][col] = max(dptable[row][col], dptable[row][k] + dptable[k][col] + nums[row]*nums[k]* nums[col])\\n\\n        return dptable[0][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        \\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        \\n        dptable = [[0]*n for _ in range(n)]\\n        \\n        for i in range(n-1):\\n            dptable[i][i+1] = 0\\n        \\n        for row in range(n, -1, -1):\\n            for col in range(row+2, n):\\n                \\n                for k in range(row+1, col):\\n                    \\n                    dptable[row][col] = max(dptable[row][col], dptable[row][k] + dptable[k][col] + nums[row]*nums[k]* nums[col])\\n\\n        return dptable[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672506,
                "title": "tabulation-dp-c",
                "content": "Implementation\\n\\n**Tabulation\\nUsing DP\\nGap & Cut strategy\\nTime Complexity = O(N^3), Space Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        \\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){\\n                \\n                // to hold the maximum possible value in the gap from itr to jtr\\n                int maxValue = INT_MIN;\\n                \\n                // running loop in the gap of itr to jtr\\n                for(int ktr = itr; ktr <= jtr; ktr++){\\n                    int left = (itr == ktr) ? 0 : dp[itr][ktr-1];\\n                    int right = (jtr == ktr) ? 0 : dp[ktr+1][jtr];\\n                    int val = ((itr == 0) ? 1 : nums[itr-1]) * (nums[ktr]) * ((jtr == n-1) ? 1 : nums[jtr+1]);\\n                    \\n                    int total = left + right + val;\\n                    maxValue = max(maxValue, total);\\n                }\\n                \\n\\t\\t\\t\\t// storing the maxValue in dp, to resuse further\\n                dp[itr][jtr] = maxValue;\\n            }\\n        }\\n                               \\n        // returning the last index of the first row, it will gonna contain the highest possible value\\n        return dp[0][n-1];                       \\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        \\n        for(int gap = 0; gap < n; gap++){\\n            for(int itr = 0, jtr = gap; jtr < n; itr++, jtr++){\\n                \\n                // to hold the maximum possible value in the gap from itr to jtr\\n                int maxValue = INT_MIN;\\n                \\n                // running loop in the gap of itr to jtr\\n                for(int ktr = itr; ktr <= jtr; ktr++){\\n                    int left = (itr == ktr) ? 0 : dp[itr][ktr-1];\\n                    int right = (jtr == ktr) ? 0 : dp[ktr+1][jtr];\\n                    int val = ((itr == 0) ? 1 : nums[itr-1]) * (nums[ktr]) * ((jtr == n-1) ? 1 : nums[jtr+1]);\\n                    \\n                    int total = left + right + val;\\n                    maxValue = max(maxValue, total);\\n                }\\n                \\n\\t\\t\\t\\t// storing the maxValue in dp, to resuse further\\n                dp[itr][jtr] = maxValue;\\n            }\\n        }\\n                               \\n        // returning the last index of the first row, it will gonna contain the highest possible value\\n        return dp[0][n-1];                       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660155,
                "title": "c-brute-force-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int n=0;\\n    unordered_map<int,bool> busted;\\n    void fun(vector<int>& nums, int coins){\\n        res=max(res,coins);\\n        for(int i=0;i<n;i++){\\n            if(busted[i]==1){\\n                continue;\\n            }\\n            busted[i]=1;\\n            int currcoinbusted=nums[i];\\n            int j=i-1;\\n            while(j>=0){\\n                if(busted[j]==0){\\n                    currcoinbusted*=nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n            j=i+1;\\n            while(j<n){\\n                if(busted[j]==0){\\n                    currcoinbusted*=nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n            fun(nums,coins+currcoinbusted);\\n            busted[i]=0;\\n        }\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        n=nums.size();\\n        fun(nums,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int n=0;\\n    unordered_map<int,bool> busted;\\n    void fun(vector<int>& nums, int coins){\\n        res=max(res,coins);\\n        for(int i=0;i<n;i++){\\n            if(busted[i]==1){\\n                continue;\\n            }\\n            busted[i]=1;\\n            int currcoinbusted=nums[i];\\n            int j=i-1;\\n            while(j>=0){\\n                if(busted[j]==0){\\n                    currcoinbusted*=nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n            j=i+1;\\n            while(j<n){\\n                if(busted[j]==0){\\n                    currcoinbusted*=nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n            fun(nums,coins+currcoinbusted);\\n            busted[i]=0;\\n        }\\n    }\\n    int maxCoins(vector<int>& nums) {\\n        n=nums.size();\\n        fun(nums,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564557,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1564566,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1565999,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1565181,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1569780,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1572965,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1567372,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1573074,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1567953,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1571563,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1564557,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1564566,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1565999,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1565181,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1569780,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1572965,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1567372,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1573074,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1567953,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1571563,
                "content": [
                    {
                        "username": "GREEsDY",
                        "content": "If you think of bursting a balloon as multiplying two adjacent matrices, then this problem is exactly the classical DP problem **Matrix-chain multiplication** found in section 15.2 in the book Introduction to Algorithms (2nd edition). \\n\\nFor example, given [3,5,8] and bursting 5, the number of coins you get is the number of scalar multiplications you need to do to multiply two matrices A[3\\\\*5] and B[5\\\\*8]. So in this example, the original problem is actually the same as given a matrix chain A[1\\\\*3]\\\\*B[3\\\\*5]\\\\*C[5\\\\*8]*D[8\\\\*1], fully parenthesize it so that the total number of scalar multiplications is maximized, although the orignal matrix-chain multiplication problem in the book asks to minimize it. Then you can see it clearly as a classical DP problem."
                    },
                    {
                        "username": "Sayan_19",
                        "content": "Simply wow....it\\'s just an application of MCM. One less pattern to remember!!!"
                    },
                    {
                        "username": "jackbb147",
                        "content": "this blew my mind too. Wow."
                    },
                    {
                        "username": "s510702",
                        "content": "This idea really blows my mind, very elegant and clear. Thank you!"
                    },
                    {
                        "username": "wyp70627768",
                        "content": "I think they don\\'t really want to hire you if anyone ask you this question during interview"
                    },
                    {
                        "username": "avijit1996iiti",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "banty",
                        "content": "I am not saying that this problem is unsolvable, all I am saying that under a interview setup with only 45 minutes or so, and if you haven\\'t seen this problem before, you cannot solve this. Unless offcourse you are Errichto, Tourist or God.\\n"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "[@qingoba](/qingoba) They are top competitive coders. You find them in top positions of rank lists on Codeforces.com"
                    },
                    {
                        "username": "_Pinocchio",
                        "content": "[@qingoba](/qingoba) no, they are top persons of competitive programming"
                    },
                    {
                        "username": "qingoba",
                        "content": "Hello, I am a English learner and dont know \"Errichto, Tourist\". Are these two slangs?"
                    },
                    {
                        "username": "rajeshtalreja2010",
                        "content": "Recursion way was very easy.. but it is giving TLE. Optimised may be little complex "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Naive)\n\n  \n**Approach 2:** Dynamic Programming (Top-Down)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-Up)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Maksadbek",
                        "content": "https://medium.com/@resiloc/how-to-solve-the-burst-balloons-problem-like-a-piece-of-cake-6121f365b1f"
                    },
                    {
                        "username": "Kururuken",
                        "content": "I guess hardly anyone can do it themselves so people just go directly to the solution...(I tried to solve it myself but after an hour\\'s work in vain I just gave up...)"
                    },
                    {
                        "username": "oshongayito",
                        "content": "Every time if I select the minimum among the elements except the 1st and the last elements, we are bringing the maximum values closer and hence making the product larger. May be I am doing something very wrong. Can anyone help me out here?"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "I was also trying with the similar strategy.  But picking the min ele between 1st and last element nor picking smallest in whole array doesn\\'t always gives the max possible value.\\nMay be something to do with value around it too.\\n\\n[1, 3 , 5, 8]\\n\\n[1, 3, 5, 8] -> [1,5,8] -> [1,8] -> [8]   // Picking smallest between 1st and last\\n(3*5*1)+(5*8*1)+(1*8)+8  = 71\\n\\n[1, 3, 5, 8] -> [3,5,8] -> [3,8] -> 8 // some other order\\n(1*3*1)+(5*3*8)+(3*8)+8 = 155\\n\\n[1,3,5,8] -> [1,3,8] -> [1,8] -> [8] // some other order.\\n(5*3*8)+(3*8*1)+(1*8)+8 = 160\\n"
                    },
                    {
                        "username": "c_jain",
                        "content": "While solving solution for a subproblem, say A[0,...,n], **Think it like this and ask yourself a question**:\\n\\n**\"which balloon should I burst at last to maximize the result\".** \\n\\nNow suppose you picked balloon at index i to be burst at last then you will successfully reach to two new independent states, i.e, State1 = A[0,...,i-1] and, state2 =  A[i+1,...,n]. Now simply fetch result of these states from DP and store this **local result** as dp[0][i-1] + A[subProblem\\'s starts - 1] * A[i] * A[subProblems\\'s end + 1] + dp[i+1][n], and finally find maximum of these **local results** for this range or sub problem.\\n \\n // \"subProblem\\'s starts - 1\" will be \\'-1\\' in this case\\n // \"subProblems\\'s end + 1\" will be \\'n\\' in this case\\n \\n **Why above mentioned 2 states are independent?**\\n Because whenever we decide last balloon for a range then we need adjacent balloons of that range. And you will see that the adjacent balloons becomes fixed whenever we decide last balloon to be burst in a range or sub problem adn divide it in two parts left sub problem and right sub problem. Therefore, adjacent balloons of, say, left range no longer depends on any balloons in the right range."
                    },
                    {
                        "username": "fbyp07",
                        "content": "let alone the time complexity first.\\n\\ncan we just burst the balloon with the smallest number each time until all are bursted.\\n\\nThanks!"
                    },
                    {
                        "username": "pingtianli",
                        "content": "[@chungquantin](/chungquantin) maybe 3,5,8 is not the same as 5,3,8"
                    },
                    {
                        "username": "chungquantin",
                        "content": "There will be a case that being greedy like this won\\'t work. For example, [3, 1, 5, 8]\\n- You pop 1 first because it is a minimum balloon\\n- [3, 5, 8] you pop 3 but it is not correct because it should pop 5 instead of 3"
                    },
                    {
                        "username": "huangdachuan",
                        "content": "It might be easier to look at this problem in a \"building balloon\" way, instead of \"bursting balloon\" way. I got this after being inspired by \"last balloon to burst\" solution.\\n\\nSuppose all balloons < i are already built, and all balloons > j are built. Then we need to find the first balloon to build between i and j (inclusive). So dp[i, j] = nums[i - 1] * nums[k] * nums[j + 1] + dp[i, k - 1] + dp[k + 1, j]."
                    }
                ]
            },
            {
                "id": 1567246,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1934571,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1690409,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1571564,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1982556,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1937469,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1759595,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1730263,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1694860,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            },
            {
                "id": 1677624,
                "content": [
                    {
                        "username": "darksidechris",
                        "content": "I read the post of @dietpepsi . It's a great post but I think the explanation is a little bit complex. We could just take dp[left][right] as the coins we got after burst all balloons between left and right (exclusive).\\nThus, dp[left][right] = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "highly unintuitive"
                    },
                    {
                        "username": "r0kkka",
                        "content": "if someone actually managed to solve this without looking at soln/discussions, I\\'d love to know how you built your intuition for this one."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "When I firstly encountered this question in Jan 2022, I failed to solve it after hours of thinking, and then abandoned it.\n\n8 months later, when I was hunting down \"Attempted\" but not solved yet questions, I came back to this question again, and I finally got the idea.\n\nFor me the intuition is just the nature of DP problems, meaning that I need to find out the recursive definition between the answers of sub-problems.\n\nBut still it is very challenging to come up with \"what that subproblem should be\"..."
                    },
                    {
                        "username": "neo9729",
                        "content": "1. Started by drawing a tree  placing 3,1, 5, 8 at top\\n2. In first iteration popped 3 then observed result array is 1, 5, 8. Did these for similar indices and each level.\\n3. Also, look at constraints max arr length is too short and n[i] also has a small max value, this is a good intuition that we can use more space. So I did not hesitated to create new lists at each iteration"
                    },
                    {
                        "username": "polarisgt",
                        "content": "Example:\\n\\nGiven [3, 1, 5, 8]\\n\\nReturn 167\\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x3x8      + 1x8x1   = 167\\n\\nBut I can easily get better by doing \\n\\n    nums = [3,1,5,8] --> [3,5,8] -->   [5,8]   -->  [8]  --> []\\n   coins =  3x1x5      +  3x5x8    +  1x5x8      + 1x8x1   = 183\\n\\nSo who is wrong?"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "In your \"better\" solution the coins = 3x1x5 + 1x3x5(not 3x5x8 as you mentioned) + 1x5x8 + 8 = 78"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": " Can we space optimize tabulated version ?\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "POTD for jan1, 2022 \\nwhat a perfect problem to start a new year :))"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Anyone please help me, i\\'m not able to memoize it unlike the other problem, when i\\'m trying to memoize it , it is giving me the wrong answer, why this happening? your efforts will be appreciated. \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i,int j, vector<int> &nums){\\n        if(i > j) return 0;\\n        // if(dp[i][j] != -1) return dp[i][j];\\n\\n        int maxi = -1e9;\\n        for(int k = i;k<=j;k++){\\n            int pans = nums[k];\\n            nums.erase(nums.begin()+k);\\n            int step = nums[k-1]*pans*nums[k] + solve(i,j-1,nums); \\n            nums.insert(nums.begin()+k,pans);\\n            maxi = max(step,maxi);\\n        }\\n        // return dp[i][j] = maxi;\\n        return maxi;\\n    }\\n\\n    int maxCoins(vector<int>& nums) {\\n        n = nums.size();\\n        nums.push_back(1);\\n        nums.insert(nums.begin(),1);\\n        // vector<vector<int>> dp(n+2, vector<int>(n+2,-1));\\n        return solve(1,n,nums);\\n    }\\n};\\n```\\nIt is working fine without memoization.."
                    },
                    {
                        "username": "_persistent",
                        "content": "https://leetcode.com/problems/burst-balloons/solutions/2844729/follow-up-question-for-interview/"
                    },
                    {
                        "username": "dipupaul",
                        "content": "73/73 test cases passed still TLE coming, is it some kind of bug"
                    }
                ]
            }
        ]
    }
]