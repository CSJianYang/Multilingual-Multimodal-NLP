[
    {
        "title": "Sort Array By Parity II",
        "question_content": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\nExample 2:\n\nInput: nums = [2,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 2 * 104\n\tnums.length is even.\n\tHalf of the integers in nums are even.\n\t0 <= nums[i] <= 1000\n\n&nbsp;\nFollow Up: Could you solve it in-place?",
        "solutions": [
            {
                "id": 181160,
                "title": "java-two-pointer-one-pass-inplace",
                "content": "```\\n\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int i = 0, j = 1, n = A.length;\\n        while (i < n && j < n) {\\n            while (i < n && A[i] % 2 == 0) {\\n                i += 2;\\n            }\\n            while (j < n && A[j] % 2 == 1) {\\n                j += 2;\\n            }\\n            if (i < n && j < n) {\\n                swap(A, i, j);\\n            }\\n        }\\n        return A;\\n    }\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int i = 0, j = 1, n = A.length;\\n        while (i < n && j < n) {\\n            while (i < n && A[i] % 2 == 0) {\\n                i += 2;\\n            }\\n            while (j < n && A[j] % 2 == 1) {\\n                j += 2;\\n            }\\n            if (i < n && j < n) {\\n                swap(A, i, j);\\n            }\\n        }\\n        return A;\\n    }\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205903,
                "title": "python-one-pass-o-1-memory-simple-code-beats-90",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, a):\\n        i = 0 # pointer for even misplaced\\n        j = 1 # pointer for odd misplaced\\n        sz = len(a)\\n        \\n        # invariant: for every misplaced odd there is misplaced even\\n        # since there is just enough space for odds and evens\\n\\n        while i < sz and j < sz:\\n            if a[i] % 2 == 0:\\n                i += 2\\n            elif a[j] % 2 == 1:\\n                j += 2\\n            else:\\n                # a[i] % 2 == 1 AND a[j] % 2 == 0\\n                a[i],a[j] = a[j],a[i]\\n                i += 2\\n                j += 2\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, a):\\n        i = 0 # pointer for even misplaced\\n        j = 1 # pointer for odd misplaced\\n        sz = len(a)\\n        \\n        # invariant: for every misplaced odd there is misplaced even\\n        # since there is just enough space for odds and evens\\n\\n        while i < sz and j < sz:\\n            if a[i] % 2 == 0:\\n                i += 2\\n            elif a[j] % 2 == 1:\\n                j += 2\\n            else:\\n                # a[i] % 2 == 1 AND a[j] % 2 == 0\\n                a[i],a[j] = a[j],a[i]\\n                i += 2\\n                j += 2\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181158,
                "title": "c-5-lines-two-pointers-2-liner-bonus",
                "content": "Use two pointers to search for missplaced odd and even elements, and swap them.\\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n    for (int i = 0, j = 1; i < A.size(); i += 2, j += 2) {\\n        while (i < A.size() && A[i] % 2 == 0) i += 2;\\n        while (j < A.size() && A[j] % 2 == 1) j += 2;\\n        if (i < A.size()) swap(A[i], A[j]);\\n    }\\n    return A;\\n}\\n```\\nNow, some fun for for my minimalistic functional friends. It\\'s techically a two-liner, though I split ```swap``` into 3 lines for readability :) It actually may even look a bit cleaner, as you do not have to do \"plus 2\".\\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n  for (int i = 0, j = 0; i < A.size() && j < A.size(); ) swap(\\n      *find_if(begin(A) + i, end(A), [&] (int v) { return (i++ % 2 == 0 && v % 2 != 0) || i == A.size(); }),\\n      *find_if(begin(A) + j, end(A), [&] (int v) { return (j++ % 2 != 0 && v % 2 == 0) || j == A.size(); }));\\n  return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n    for (int i = 0, j = 1; i < A.size(); i += 2, j += 2) {\\n        while (i < A.size() && A[i] % 2 == 0) i += 2;\\n        while (j < A.size() && A[j] % 2 == 1) j += 2;\\n        if (i < A.size()) swap(A[i], A[j]);\\n    }\\n    return A;\\n}\\n```\n```swap```\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n  for (int i = 0, j = 0; i < A.size() && j < A.size(); ) swap(\\n      *find_if(begin(A) + i, end(A), [&] (int v) { return (i++ % 2 == 0 && v % 2 != 0) || i == A.size(); }),\\n      *find_if(begin(A) + j, end(A), [&] (int v) { return (j++ % 2 != 0 && v % 2 == 0) || j == A.size(); }));\\n  return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252502,
                "title": "c-o-n-time-o-1-space-solution-with-intuition-for-building-the-solution",
                "content": "## Basic Idea of Question\\nWe are given an array in which half of the numbers are odd, and the other half are even. So the length of the array is always even, and the first index is even (0), while the last index is odd (n-1). We have to arrange the numbers in the array such that at every even index, there is an even number, while at every odd index, there is an odd number.\\n\\nThe most naive solution to this question is to just traverse the array, and upon finding an out-of-place element, find its replacement in the array by traversing the subarray after it. This algorithm will cost us **O(n<sup>2</sup>)** in time and **O(1)** in space, but it isn\\'t enough. It just seems too naive of a solution.\\n<br>\\n\\n## Approach 1: Separate even and odd numbers\\nThe next approach that might come to mind is to just iterate over the array and separate the numbers into two groups, even and odd.\\nThen we build the array again from the start by choosing an even number for each even index and an odd number for each odd index.\\nThis is a good solution, and it does fit in with the least runtime possible for such an algorithm, which is **O(n)** since we have to at least check every element, so that they are all at their place, but it also requires extra space of O(n) for storing the even and odd numbers.\\n\\nThe code for the approach is as follows:\\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> evens, odds;\\n\\tevens.reserve(n/2);\\n\\todds.reserve(n/2);\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(nums[i] % 2 == 0) {\\n\\t\\t\\tevens.push_back(nums[i]);\\n\\t\\telse {\\n\\t\\t\\todds.push_back(nums[i]);\\n\\t}\\n\\t//filling even spaces\\n\\tfor(int i = 0; i<n; i+=2) {\\n\\t\\tnums[i] = evens[i/2];\\n\\t}\\n\\t//filling odd spaces\\n\\tfor(int i = 1; i<n; i+=2) {\\n\\t\\tnums[i] = odds[i/2];\\n\\t}\\n\\treturn nums;\\n}\\n```\\nIf you are confused by the lines ```evens.reserve(n/2)``` and ```odds.reserve(n/2)```, they are just ensuring beforehand that our vectors have adequate capacities, so that all push back operations are completed in O(1).\\n\\n**Time: O(n)** as we just iterate the array two times.\\n**Space: O(n)**, the extra space required for the two arrays.\\n<br>\\n\\n## Approach 2: Swap outliers\\nWe can think of this question in another way as well. Since the number of even and odd numbers in the array is equal, if there is one outlier (even number at odd index or vice versa), there must be another outlier somewhere, since if there isn\\'t, then this place has no rightful element which can fill it.\\nIf we find and swap such pairs, we wouldn\\'t have to care about finding the odd or even numbers and separating them. In fact, we can even do it in one iteration only, using two pointers.\\n\\nComing back to the question statement, as n is even,, so index 0 is even and the index (n-1) is odd. So starting at index 0 for the even pointer, and n-1 for the odd pointer would be just fine.\\nWe follow the below algorithm until one of the pointers reaches the other end of the array (here i represents the even pointer, and j represents the odd pointer):\\n\\n1. Keep incrementing i by 2 until either it reaches the other end, or an outlier (odd number at even index).\\n2. Keep decrementing j by 2 until either it reaches the other end, or an outlier (even number at odd index).\\n3. Swap nums[i] and nums[j]\\n\\nYou might be thinking, what happens if i stops at an outlier and j reaches the other end, or vice versa?\\nWell, the fact that n is even, and there being equal number of even and odd numbers prevents that situation from happening (as explained above). If there will be a pair, it will be a valid pair, otherwise both of them will reach the ends.\\n\\nThe code for this approach is as follows:\\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0, j = n-1;\\n\\twhile(i<n) {\\n\\t\\twhile(i<n && nums[i]%2==0) i+=2;\\n\\t\\tif(i==n) break;\\n\\t\\twhile(j>=0 && nums[j]%2==1) j-=2;\\n\\t\\t//swap the outliers\\n\\t\\tswap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\\n\\n**Time: O(n)** as we traverse the array once.\\n**Space: O(1)** as we only use two pointers, and no other space.\\n\\n<br>\\n\\n**Don\\'t forget to upvote** if you liked this post and learned something from it, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> evens, odds;\\n\\tevens.reserve(n/2);\\n\\todds.reserve(n/2);\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(nums[i] % 2 == 0) {\\n\\t\\t\\tevens.push_back(nums[i]);\\n\\t\\telse {\\n\\t\\t\\todds.push_back(nums[i]);\\n\\t}\\n\\t//filling even spaces\\n\\tfor(int i = 0; i<n; i+=2) {\\n\\t\\tnums[i] = evens[i/2];\\n\\t}\\n\\t//filling odd spaces\\n\\tfor(int i = 1; i<n; i+=2) {\\n\\t\\tnums[i] = odds[i/2];\\n\\t}\\n\\treturn nums;\\n}\\n```\n```evens.reserve(n/2)```\n```odds.reserve(n/2)```\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0, j = n-1;\\n\\twhile(i<n) {\\n\\t\\twhile(i<n && nums[i]%2==0) i+=2;\\n\\t\\tif(i==n) break;\\n\\t\\twhile(j>=0 && nums[j]%2==1) j-=2;\\n\\t\\t//swap the outliers\\n\\t\\tswap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490877,
                "title": "python-o-1-space-solution-explained",
                "content": "`O(n)` space complexity soluiton is straightforward. It is more interseting to investigate `O(1)` solution. The idea is to use two pointers approach, where we start with index `0` for even numbers and with index `1` for odd numbers. We traverse our numbers, where we can have the following options:\\n\\n1. if `nums[i] % 2 == 0`, then number is already on place, so we look at the next place for `i`.\\n2. if `nums[j] % 2 == 1`, then number is already on place, so we look ate the next place for `j`.\\n3. In the opposite case we need to sweich elements.\\n\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j, n = 0, 1, len(nums)\\n        while j < n and i < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j, n = 0, 1, len(nums)\\n        while j < n and i < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490847,
                "title": "c-two-pointers-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint i = 0, j = 1;\\n\\t\\t\\twhile(i < n && j < n){\\n\\t\\t\\t\\tif(nums[i] % 2 == 0){\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[j] % 2 == 1){\\n\\t\\t\\t\\t\\tj += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint i = 0, j = 1;\\n\\t\\t\\twhile(i < n && j < n){\\n\\t\\t\\t\\tif(nums[i] % 2 == 0){\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 181500,
                "title": "java-two-pointers-inplace-o-n-time-simple-straightforward",
                "content": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int e = 0;\\n        int o = 1;\\n        \\n        while(e < A.length && o < A.length) {\\n            if(A[e]%2 != 0) {\\n                swap(A, e, o);\\n                o += 2;\\n            } else {\\n                e += 2;\\n            }\\n        }\\n\\n        return A;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int e = 0;\\n        int o = 1;\\n        \\n        while(e < A.length && o < A.length) {\\n            if(A[e]%2 != 0) {\\n                swap(A, e, o);\\n                o += 2;\\n            } else {\\n                e += 2;\\n            }\\n        }\\n\\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193854,
                "title": "linear-pass-using-2-pointers-in-c",
                "content": "We need to maintain a following invariant: `A[i]` is an even number at even position and `A[j]` is an odd number at odd position. As soon as this invariant is violated, it\\'s possible to swap numbers to restore it.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        for (int i = 0, j = 1; j < A.size() && i < A.size();) {\\n            if (A[i] % 2 == 0) {\\n                i += 2;\\n            } else if (A[j] % 2 == 1) {\\n                j += 2;\\n            } else {\\n                swap(A[i], A[j]);\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        for (int i = 0, j = 1; j < A.size() && i < A.size();) {\\n            if (A[i] % 2 == 0) {\\n                i += 2;\\n            } else if (A[j] % 2 == 1) {\\n                j += 2;\\n            } else {\\n                swap(A[i], A[j]);\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319267,
                "title": "python-o-n-t-o-1-s-easy-to-understand-with-explanation",
                "content": "The idea: \\nGetting odd numbers on odd indices, after which, even numbers would also stand right positions;\\n**i** as even index starts from 0 (2, 4, 6...), **j** as odd index starts from 1 (3, 5, 7...)\\n\\nA half of A is odd, so the length of A - **L**  so 2|L, also means **L - 1** is odd;\\n\\nJudging every number on odd indices if it is odd, if it is, it stands at a right position, then j = j + 2 (jumping to next odd index), and \\'i\\' keep the same. \\nOtherwise, exchanging the values between index j and i,  then index \\'i\\'  has a right value and can point to next even position i = i + 2, but we don\\'t know the original value on i is odd, so j keep unchanged.\\n\\nAfter processing all odd indices, we get the result we want.\\n```\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        i, j, L = 0, 1, len(A)              # i - even index, j - odd index, L - length of A\\n        while j < L:                          # (L - 1) is odd, j can reach the last element, so this condition is enough\\n            if A[j] % 2 == 0:              # judge if the value on odd indices is odd\\n                A[j], A[i] = A[i], A[j]     # if it is even, exchange the values between index j and i\\n                i += 2                         # even indices get a right value, then i pointer jump to next even index\\n            else:\\n                j += 2                         # if it is odd, odd indices get a right value, then j pointer jump to next odd index\\n        return A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        i, j, L = 0, 1, len(A)              # i - even index, j - odd index, L - length of A\\n        while j < L:                          # (L - 1) is odd, j can reach the last element, so this condition is enough\\n            if A[j] % 2 == 0:              # judge if the value on odd indices is odd\\n                A[j], A[i] = A[i], A[j]     # if it is even, exchange the values between index j and i\\n                i += 2                         # even indices get a right value, then i pointer jump to next even index\\n            else:\\n                j += 2                         # if it is odd, odd indices get a right value, then j pointer jump to next odd index\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234994,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181261,
                "title": "python-easy-2-liner",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]\\n        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]\\n        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283369,
                "title": "java-2ms-99-76-faster",
                "content": "1. Get first even entry at the wrong index\\n2. Get first odd entry at the wrong index\\n3. swap\\n4. repeat\\n```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int even = 0, odd = 1;\\n        while(true){\\n            while(even < A.length && A[even] % 2 == 0) /*(1)*/\\n                even += 2;\\n            while(odd < A.length && A[odd] % 2 != 0) /*(2)*/\\n                odd += 2;\\n            if(odd >= A.length || even >= A.length) return A;\\n\\t\\t\\t\\n\\t\\t\\t/*(3)*/\\n            int temp = A[even];\\n            A[even] = A[odd];\\n            A[odd] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int even = 0, odd = 1;\\n        while(true){\\n            while(even < A.length && A[even] % 2 == 0) /*(1)*/\\n                even += 2;\\n            while(odd < A.length && A[odd] % 2 != 0) /*(2)*/\\n                odd += 2;\\n            if(odd >= A.length || even >= A.length) return A;\\n\\t\\t\\t\\n\\t\\t\\t/*(3)*/\\n            int temp = A[even];\\n            A[even] = A[odd];\\n            A[odd] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491154,
                "title": "python-two-pointers-o-1-space-clean-concise",
                "content": "**Idea**\\n- Let `iEven` point to the first number which has an even index but the value is odd.\\n- Let `iOdd` point to the first number which has an odd index but the value is even.\\n- We need to swap `nums[iEven]` and `nums[iOdd]` together since they are mismatch.\\n```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        iEven = 0\\n        iOdd = 1\\n        while True:\\n            while iEven < n and nums[iEven] % 2 == 0:\\n                iEven += 2\\n            while iOdd < n and nums[iOdd] % 2 == 1:\\n                iOdd += 2\\n            if iEven >= n or iOdd >= n:\\n                break\\n\\n            nums[iEven], nums[iOdd] = nums[iOdd], nums[iEven]\\n            iEven += 2\\n            iOdd += 2\\n        return nums\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 2*10^4` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        iEven = 0\\n        iOdd = 1\\n        while True:\\n            while iEven < n and nums[iEven] % 2 == 0:\\n                iEven += 2\\n            while iOdd < n and nums[iOdd] % 2 == 1:\\n                iOdd += 2\\n            if iEven >= n or iOdd >= n:\\n                break\\n\\n            nums[iEven], nums[iOdd] = nums[iOdd], nums[iEven]\\n            iEven += 2\\n            iOdd += 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213068,
                "title": "3-lines-javascript-solution",
                "content": "```\\n  let evenArray = A.filter(x => x % 2 === 0);\\n  let oddArray = A.filter(x => x % 2 === 1);\\n  return A.map((x, index) => index % 2 === 0 ? evenArray.pop() : oddArray.pop());\\n```",
                "solutionTags": [],
                "code": "```\\n  let evenArray = A.filter(x => x % 2 === 0);\\n  let oddArray = A.filter(x => x % 2 === 1);\\n  return A.map((x, index) => index % 2 === 0 ? evenArray.pop() : oddArray.pop());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490850,
                "title": "simple-to-understand-for-beginners-91-faster",
                "content": "## IDEA:\\n* Separate all even and odd numbers Once.\\n* Then now replace original arr with alternate even and odd numbers.\\n* Here flag denotes you are at even index.\\n\\n**For Biginners:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        odd,even = [],[]\\n        for n in nums:\\n            if n%2: odd.append(n)\\n            else: even.append(n)\\n        \\n        o,e = 0,0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i]=even[e]\\n                e+=1\\n            else:\\n                nums[i]=odd[o]\\n                o+=1\\n        \\n        return nums\\n\\n**Most Efficient:**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0                            #even_index\\n        o = 1                            #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return num\\n\\n### Thanks and Upvote If you got any help !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n* Separate all even and odd numbers Once.\\n* Then now replace original arr with alternate even and odd numbers.\\n* Here flag denotes you are at even index.\\n\\n**For Biginners:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        odd,even = [],[]\\n        for n in nums:\\n            if n%2: odd.append(n)\\n            else: even.append(n)\\n        \\n        o,e = 0,0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i]=even[e]\\n                e+=1\\n            else:\\n                nums[i]=odd[o]\\n                o+=1\\n        \\n        return nums\\n\\n**Most Efficient:**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0                            #even_index\\n        o = 1                            #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return num\\n\\n### Thanks and Upvote If you got any help !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1235041,
                "title": "swift-sort-array-by-parity-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func sortArrayByParityII(_ nums: [Int]) -> [Int] {\\n        var map = [Int](repeating: 0, count: nums.count)\\n        var i = 0, j = 1\\n        nums.forEach({\\n            if $0 % 2 == 0 {\\n                map[i] = $0\\n                i += 2\\n            } else {\\n                map[j] = $0\\n                j += 2\\n            }\\n        })\\n        return map\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.sortArrayByParityII([4,2,5,7]), [4,5,2,7])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.sortArrayByParityII([2,3]), [2,3])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func sortArrayByParityII(_ nums: [Int]) -> [Int] {\\n        var map = [Int](repeating: 0, count: nums.count)\\n        var i = 0, j = 1\\n        nums.forEach({\\n            if $0 % 2 == 0 {\\n                map[i] = $0\\n                i += 2\\n            } else {\\n                map[j] = $0\\n                j += 2\\n            }\\n        })\\n        return map\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.sortArrayByParityII([4,2,5,7]), [4,5,2,7])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.sortArrayByParityII([2,3]), [2,3])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181075,
                "title": "java-simple-code-swap-odd-and-even-indices-elements",
                "content": "Use i and j to denote even and odd indices, respectively.\\nLoop through input array,\\n1. locate next wrongly placed item with odd index j;\\n2. if current even-index item, A[i], is wrongly placed, swap it with A[j]; otherwise, forward to the next even index;\\n\\nTime: O(n), space: O(1).\\n\\n```\\n    public int[] sortArrayByParityII(int[] A) {\\n        for (int i = 0, j = 1; i < A.length; i += 2) {\\n            while (j < A.length && A[j] % 2 == 1) { j += 2; } //find next odd-index item A[j] with even value.\\n            if (A[i] % 2 == 1) { // if odd-index item A[i] is odd, swap it with A[j].\\n                int t = A[i];\\n                A[i] = A[j];\\n                A[j] = t;\\n                j += 2;\\n            }\\n        }\\n        return A;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortArrayByParityII(int[] A) {\\n        for (int i = 0, j = 1; i < A.length; i += 2) {\\n            while (j < A.length && A[j] % 2 == 1) { j += 2; } //find next odd-index item A[j] with even value.\\n            if (A[i] % 2 == 1) { // if odd-index item A[i] is odd, swap it with A[j].\\n                int t = A[i];\\n                A[i] = A[j];\\n                A[j] = t;\\n                j += 2;\\n            }\\n        }\\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420962,
                "title": "c-easy-to-understand-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n    \\n        vector<int> ans(nums.size());\\n        int e=0,o=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[e]=nums[i];\\n                    e+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    ans[o]=nums[i];\\n                    o+=2;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n    \\n        vector<int> ans(nums.size());\\n        int e=0,o=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[e]=nums[i];\\n                    e+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2431242,
                "title": "100-t-c-short-solution-easy-to-undesrtand",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int[] ans = new int[nums.length];\\n        int even = -2, odd = -1;\\n\\n        for (int  i: nums){\\n            if (i % 2 == 0) ans[even+=2] = i;\\n            else ans[odd+=2] = i;\\n        }\\n\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224767,
                "title": "python-two-pointers-one-pass",
                "content": "one pointer is used to remember the odd position, the other is to remember the even position\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd = 1\\n        even = 0\\n        result = [0]*len(A)\\n        for num in A:\\n            if num%2==0:\\n                result[even] = num\\n                even += 2\\n            else:\\n                result[odd] = num\\n                odd += 2\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd = 1\\n        even = 0\\n        result = [0]*len(A)\\n        for num in A:\\n            if num%2==0:\\n                result[even] = num\\n                even += 2\\n            else:\\n                result[odd] = num\\n                odd += 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182347,
                "title": "python-beginner-solution",
                "content": "Tried to make a simple solution. \\n1. Loop through initial list, check for odd/even, and append to an odd_list or even list\\n2. Combine the lists with slicing to alternate odd/even lists\\n\\n```class Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd_list = []\\n        even_list = []\\n        \\n        for i in A:\\n            if i % 2 == 1:\\n                odd_list.append(i)\\n            else:\\n                even_list.append(i)\\n\\n        result = [None]*(len(odd_list)+len(even_list))\\n        result[::2] = even_list\\n        result[1::2] = odd_list\\n        return result",
                "solutionTags": [],
                "code": "Tried to make a simple solution. \\n1. Loop through initial list, check for odd/even, and append to an odd_list or even list\\n2. Combine the lists with slicing to alternate odd/even lists\\n\\n```class Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd_list = []\\n        even_list = []\\n        \\n        for i in A:\\n            if i % 2 == 1:\\n                odd_list.append(i)\\n            else:\\n                even_list.append(i)\\n\\n        result = [None]*(len(odd_list)+len(even_list))\\n        result[::2] = even_list\\n        result[1::2] = odd_list\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 3253084,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even = []\\n        odd = []\\n        lst=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                even.append(nums[i])\\n            else:\\n                odd.append(nums[i])\\n        for i in range(len(even)):\\n            lst.append(even[i])\\n            lst.append(odd[i])\\n        return lst\\n```\\n![image.png](https://assets.leetcode.com/users/images/d1d1fa02-4b7b-4404-b577-ebef47fd1b2f_1677865820.3052886.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even = []\\n        odd = []\\n        lst=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                even.append(nums[i])\\n            else:\\n                odd.append(nums[i])\\n        for i in range(len(even)):\\n            lst.append(even[i])\\n            lst.append(odd[i])\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665223,
                "title": "c-three-o-n-solutions",
                "content": "**Solution #1:** Two-pass solution using two-pointer technique [O(n) Time & O(1) Space]\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tfor (int i = 0, c = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 != 0) c++;\\n\\t\\telse if (c > 0) swap(nums[i], nums[i - c]);\\n\\t}\\n\\tfor (int i = 1; i < nums.size() / 2; i += 2) swap(nums[i], nums[nums.size() - i - 1]);\\n\\treturn nums;\\n}\\n```\\n\\n**Solution #2:** One-pass solution using two-pointer technique [O(n) Time & O(1) Space]\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tint i = 0, j = nums.size() - 1;\\n\\twhile (i < nums.size() && j >= 0) {\\n\\t\\tif (nums[i] % 2 == 0) i += 2;\\n\\t\\telse if (nums[j] % 2 != 0) j -= 2;\\n\\t\\telse swap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\\n\\n**Solution #3:** One-pass solution [O(n) Time & O(n) Space] \\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tvector<int> result(nums.size());\\n\\tfor (int i = 0, j = 0, k = 1; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 == 0) {\\n\\t\\t\\tresult[j] = nums[i];\\n\\t\\t\\tj += 2;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k] = nums[i];\\n\\t\\t\\tk += 2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n**Note:** Not an in-place solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tfor (int i = 0, c = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 != 0) c++;\\n\\t\\telse if (c > 0) swap(nums[i], nums[i - c]);\\n\\t}\\n\\tfor (int i = 1; i < nums.size() / 2; i += 2) swap(nums[i], nums[nums.size() - i - 1]);\\n\\treturn nums;\\n}\\n```\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tint i = 0, j = nums.size() - 1;\\n\\twhile (i < nums.size() && j >= 0) {\\n\\t\\tif (nums[i] % 2 == 0) i += 2;\\n\\t\\telse if (nums[j] % 2 != 0) j -= 2;\\n\\t\\telse swap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tvector<int> result(nums.size());\\n\\tfor (int i = 0, j = 0, k = 1; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 == 0) {\\n\\t\\t\\tresult[j] = nums[i];\\n\\t\\t\\tj += 2;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k] = nums[i];\\n\\t\\t\\tk += 2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404663,
                "title": "python3-2-pointer",
                "content": "Even & odd indices \\n1) maintain two indices \"even\" and \"odd\" which start at 0 and 1 spectively;\\n2) loop through elements in array;\\n3) if element is of odd parity, copy it to position of \"odd\" index and increase odd by two; if element is of even parity, copy it to positon of \"even\" index and increase even by two.\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        ans = [None] * len(A)\\n        index = [0, 1] #even & odd indices\\n        for x in A:\\n            ans[index[x%2]] = x\\n            index[x%2] += 2\\n        return ans \\n```\\n\\nAn alternative implementation which updates A in place is as below. \\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        ii, i = 0, 1\\n        while ii < len(nums) and i < len(nums): \\n            if not nums[ii] & 1: ii += 2\\n            elif nums[i] & 1: i += 2\\n            else: \\n                nums[ii], nums[i] = nums[i], nums[ii]\\n                ii += 2\\n                i += 2\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        ans = [None] * len(A)\\n        index = [0, 1] #even & odd indices\\n        for x in A:\\n            ans[index[x%2]] = x\\n            index[x%2] += 2\\n        return ans \\n```\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        ii, i = 0, 1\\n        while ii < len(nums) and i < len(nums): \\n            if not nums[ii] & 1: ii += 2\\n            elif nums[i] & 1: i += 2\\n            else: \\n                nums[ii], nums[i] = nums[i], nums[ii]\\n                ii += 2\\n                i += 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184608,
                "title": "javascript-beats-100",
                "content": "```\\n    var ans = new Array(A.length);\\n    var odd = 1, even = 0;\\n    \\n    for (var i = 0; i < A.length ; i++){\\n        if (A[i] % 2 === 0){\\n            ans[even] = A[i];\\n            even += 2;\\n        }else{\\n            ans[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n\\n    return ans;",
                "solutionTags": [],
                "code": "```\\n    var ans = new Array(A.length);\\n    var odd = 1, even = 0;\\n    \\n    for (var i = 0; i < A.length ; i++){\\n        if (A[i] % 2 === 0){\\n            ans[even] = A[i];\\n            even += 2;\\n        }else{\\n            ans[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n\\n    return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3440920,
                "title": "smartest-solution-with-java-beats-99-90-1-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }else{\\n                ret[odd] = a;\\n                odd+=2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }else{\\n                ret[odd] = a;\\n                odd+=2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499431,
                "title": "one-pass-two-pointer-solution",
                "content": "Consider two pointers, one **oddIx**, pointing to odd position and the other **evenIx**, pointing to even position.\\nBegining with **oddIx at 1** and **evenIx at 0**, we will increment these **until one exceeds the length** of the array.\\nIf we have odd number at even position or even number at odd position, we will like to change this, so we will **swap** only **when both**, oddIx and evenIx, **holds number of opposite category(even/odd)**.\\nElse, we would simply skip the position for oddIx and evenIx if they hold number belonging to their category.\\n\\n\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddIx = 1, evenIx = 0;\\n        while(oddIx < nums.length && evenIx < nums.length){\\n            if (nums[oddIx] % 2 < nums[evenIx] % 2){\\n                int temp = nums[oddIx];\\n                nums[oddIx] = nums[evenIx];\\n                nums[evenIx] = temp;\\n            }\\n            if (nums[oddIx] % 2 == 1)\\n                oddIx = oddIx + 2;\\n            if (nums[evenIx] % 2 == 0)\\n                evenIx = evenIx + 2;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddIx = 1, evenIx = 0;\\n        while(oddIx < nums.length && evenIx < nums.length){\\n            if (nums[oddIx] % 2 < nums[evenIx] % 2){\\n                int temp = nums[oddIx];\\n                nums[oddIx] = nums[evenIx];\\n                nums[evenIx] = temp;\\n            }\\n            if (nums[oddIx] % 2 == 1)\\n                oddIx = oddIx + 2;\\n            if (nums[evenIx] % 2 == 0)\\n                evenIx = evenIx + 2;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476301,
                "title": "c-simpler-than-top-voted-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = n-1;\\n        //i stands for even\\n        //j stands for odd\\n        while(i < n && j >= 0) {\\n            if   (nums[i]%2 == 0)    i += 2;\\n            else if(nums[j] %2 == 1) j -= 2;\\n            else                     swap(nums[i], nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = n-1;\\n        //i stands for even\\n        //j stands for odd\\n        while(i < n && j >= 0) {\\n            if   (nums[i]%2 == 0)    i += 2;\\n            else if(nums[j] %2 == 1) j -= 2;\\n            else                     swap(nums[i], nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156067,
                "title": "java-faster-than-99",
                "content": "\\tclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddindex = 1;\\n       int evenindex = 0;\\n       int res[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]%2==0) {\\n                res[evenindex]=nums[i];\\n                evenindex+=2;\\n            }\\n            else\\n            {\\n                res[oddindex]=nums[i];\\n                oddindex+=2;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddindex = 1;\\n       int evenindex = 0;\\n       int res[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]%2==0) {\\n                res[evenindex]=nums[i];\\n                evenindex+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 397526,
                "title": "javascript-one-loop-solution",
                "content": "```\\nconst sortArrayByParityII = arr => {\\n    let res = []\\n    let evenIndex = 0\\n    let oddIndex = 1\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 0) {\\n            res[evenIndex] = arr[i]\\n            evenIndex = evenIndex + 2\\n        } else {\\n            res[oddIndex] = arr[i]\\n            oddIndex = oddIndex + 2\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortArrayByParityII = arr => {\\n    let res = []\\n    let evenIndex = 0\\n    let oddIndex = 1\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 0) {\\n            res[evenIndex] = arr[i]\\n            evenIndex = evenIndex + 2\\n        } else {\\n            res[oddIndex] = arr[i]\\n            oddIndex = oddIndex + 2\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169529,
                "title": "python3-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even, odd = 0, 1\\n        \\n        while even < len(nums) and odd < len(nums):\\n            while even < len(nums) and nums[even] % 2 == 0:\\n                even += 2\\n            while odd < len(nums) and nums[odd] % 2 != 0:\\n                odd += 2\\n                \\n            if even < len(nums) and odd < len(nums):\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n                \\n            even += 2\\n            odd += 2\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even, odd = 0, 1\\n        \\n        while even < len(nums) and odd < len(nums):\\n            while even < len(nums) and nums[even] % 2 == 0:\\n                even += 2\\n            while odd < len(nums) and nums[odd] % 2 != 0:\\n                odd += 2\\n                \\n            if even < len(nums) and odd < len(nums):\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n                \\n            even += 2\\n            odd += 2\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049238,
                "title": "simple-c-two-pointers-solution",
                "content": "Simple two pointers solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n      int n = A.size();\\n        for(int i = 0, j = 1; j < A.size() && i < A.size();){\\n            if(A[i]%2==0 )\\n                i+=2;\\n            else if(A[j]%2==1)\\n                j+=2;\\n            else(swap(A[i],A[j]));\\n            \\n        }\\n        return A;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n      int n = A.size();\\n        for(int i = 0, j = 1; j < A.size() && i < A.size();){\\n            if(A[i]%2==0 )\\n                i+=2;\\n            else if(A[j]%2==1)\\n                j+=2;\\n            else(swap(A[i],A[j]));\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3519592,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n){\\n            if(nums[i]%2==0)\\n                i=i+2;\\n            else if(nums[j]%2==1)\\n                j=j+2;\\n            else\\n                swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        j=1\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2:\\n                while nums[j]%2:\\n                    j+=2\\n                nums[i],nums[j]=nums[j],nums[i]\\n\\n        return nums\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }\\n        for (int k = 0; k < 2; k++) {\\n            int cur = k;\\n            for (int i = k; i < nums.length; i += 2) {\\n                while (freq[cur] == 0) cur += 2;\\n                freq[cur]--;\\n                nums[i] = cur;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n){\\n            if(nums[i]%2==0)\\n                i=i+2;\\n            else if(nums[j]%2==1)\\n                j=j+2;\\n            else\\n                swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        j=1\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2:\\n                while nums[j]%2:\\n                    j+=2\\n                nums[i],nums[j]=nums[j],nums[i]\\n\\n        return nums\\n```\n```Java []\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }\\n        for (int k = 0; k < 2; k++) {\\n            int cur = k;\\n            for (int i = k; i < nums.length; i += 2) {\\n                while (freq[cur] == 0) cur += 2;\\n                freq[cur]--;\\n                nums[i] = cur;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722158,
                "title": "c-easy-even-odd-vector",
                "content": "### Simple Solution using Even & Odd Vector \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]%2==0)\\n                even.push_back(a[i]);\\n            else\\n                odd.push_back(a[i]);\\n        }\\n        int n=even.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(even[i]);\\n            ans.push_back(odd[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]%2==0)\\n                even.push_back(a[i]);\\n            else\\n                odd.push_back(a[i]);\\n        }\\n        int n=even.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(even[i]);\\n            ans.push_back(odd[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628372,
                "title": "2-solutions-using-extra-space-and-without-extra-space-c",
                "content": "# **Using Extra Space : O(N)** #\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> odd, even;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((nums[i]&1) == 1)\\n                odd.push_back(nums[i]);\\n            else\\n                even.push_back(nums[i]);\\n        }\\n        int e = 0, o = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((i & 1) == 0){\\n                nums[i] = even[e];\\n                e++;\\n            }\\n            else\\n            {\\n                nums[i] = odd[o];\\n                o++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# **Without Using Extra Space : O(1)** #\\n```\\nclass Solution{\\npublic:\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        int i = 0, j = 1, n = nums.size();\\n        while (i < n && j < n)\\n        {\\n            if (nums[i] % 2 == 0)\\n                i += 2;\\n            else if (nums[j] % 2 != 0)\\n                j += 2;\\n            else\\n            {\\n                swap(nums[i], nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> odd, even;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((nums[i]&1) == 1)\\n                odd.push_back(nums[i]);\\n            else\\n                even.push_back(nums[i]);\\n        }\\n        int e = 0, o = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((i & 1) == 0){\\n                nums[i] = even[e];\\n                e++;\\n            }\\n            else\\n            {\\n                nums[i] = odd[o];\\n                o++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        int i = 0, j = 1, n = nums.size();\\n        while (i < n && j < n)\\n        {\\n            if (nums[i] % 2 == 0)\\n                i += 2;\\n            else if (nums[j] % 2 != 0)\\n                j += 2;\\n            else\\n            {\\n                swap(nums[i], nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1774458,
                "title": "c-easy-to-understand-step-by-step-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> result(nums.size());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[even]=nums[i];\\n                    even+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    result[odd]=nums[i];\\n                    odd+=2;\\n                }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> result(nums.size());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[even]=nums[i];\\n                    even+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    result[odd]=nums[i];\\n                    odd+=2;\\n                }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498698,
                "title": "very-easy-two-pointer-solution-in-java-for-beginners",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 ;\\n        int odd =  1 ;\\n        \\n        while(even < nums.length && odd < nums.length){\\n            \\n            if(nums[even]%2 != 0){\\n                swap(nums , even , odd);\\n                odd += 2 ;\\n            } else{\\n                even += 2 ;\\n            }\\n        }\\n        \\n        return nums ;\\n    }\\n    \\n    public void swap(int[] arr , int e1 , int e2){\\n        int temp = arr[e1];\\n        arr[e1] = arr[e2];\\n        arr[e2] = temp ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 ;\\n        int odd =  1 ;\\n        \\n        while(even < nums.length && odd < nums.length){\\n            \\n            if(nums[even]%2 != 0){\\n                swap(nums , even , odd);\\n                odd += 2 ;\\n            } else{\\n                even += 2 ;\\n            }\\n        }\\n        \\n        return nums ;\\n    }\\n    \\n    public void swap(int[] arr , int e1 , int e2){\\n        int temp = arr[e1];\\n        arr[e1] = arr[e2];\\n        arr[e2] = temp ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330742,
                "title": "two-pointer-solution-python-3-beats-90",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0 #even_index\\n        o = 1 #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0 #even_index\\n        o = 1 #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210032,
                "title": "c-in-place-solution-for-90-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n         \\n        for(int i =0 , j =1 ; j < nums.size() && i <nums.size();)\\n        {\\n            if(nums[i] %2 ==0)\\n            i+=2;\\n            else if(nums[j] % 2 ==1)\\n            j+=2;\\n            else\\n            swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n         \\n        for(int i =0 , j =1 ; j < nums.size() && i <nums.size();)\\n        {\\n            if(nums[i] %2 ==0)\\n            i+=2;\\n            else if(nums[j] % 2 ==1)\\n            j+=2;\\n            else\\n            swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197747,
                "title": "c-12ms-98-two-pointers-in-place",
                "content": "Runtime: 12 ms, faster than 98.13% of C++ online submissions for Sort Array By Parity II.\\nMemory Usage: 21.5 MB, less than 29.09% of C++ online submissions for Sort Array By Parity II.\\n```\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i = 0, ni = A.size(), j = 1, nj = A.size() + 1;\\n    \\n    while(true){\\n      while(i != ni && A[i]%2 == 0) i+=2;\\n      while(j != nj && A[j]%2 == 1) j+=2;\\n      if(i == ni) break;\\n      swap(A[i],A[j]);\\n    }\\n    return A;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i = 0, ni = A.size(), j = 1, nj = A.size() + 1;\\n    \\n    while(true){\\n      while(i != ni && A[i]%2 == 0) i+=2;\\n      while(j != nj && A[j]%2 == 1) j+=2;\\n      if(i == ni) break;\\n      swap(A[i],A[j]);\\n    }\\n    return A;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919338,
                "title": "python3-easy-to-understand-solution",
                "content": "class Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        op=[0]*len(A)\\n        e=0\\n        o=1\\n        for i in A:\\n            if i%2==0:\\n                op[e]=i\\n                e+=2\\n            else:\\n                op[o]=i\\n                o+=2\\n        return op\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        op=[0]*len(A)\\n        e=0\\n        o=1\\n        for i in A:\\n            if i%2==0:\\n                op[e]=i\\n                e+=2\\n            else:\\n                op[o]=i\\n                o+=2\\n        return op\\n",
                "codeTag": "Java"
            },
            {
                "id": 764104,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *odd, *even, i = 0;\\n    \\n    odd = res + 1;\\n    even = res;\\n    \\n    while(i < ASize)\\n    {\\n        if(A[i] % 2)\\n        {\\n            *odd = A[i];\\n            odd +=2;\\n            i++;\\n            \\n        }\\n        else\\n        {\\n            *even = A[i];\\n            even += 2;\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *odd, *even, i = 0;\\n    \\n    odd = res + 1;\\n    even = res;\\n    \\n    while(i < ASize)\\n    {\\n        if(A[i] % 2)\\n        {\\n            *odd = A[i];\\n            odd +=2;\\n            i++;\\n            \\n        }\\n        else\\n        {\\n            *even = A[i];\\n            even += 2;\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558016,
                "title": "java-faster-than-99-63",
                "content": "```\\nclass Solution {\\n    \\n    void swap(int[] A, int i, int j){\\n         int tmp = A[i];\\n         A[i] = A[j];\\n         A[j] = tmp;\\n    }\\n    \\n    public int[] sortArrayByParityII(int[] A) {\\n        int odd_p = 1;\\n        int n = A.length;\\n        \\n        for(int i=0;i<n;i+=2){\\n            if(A[i]%2 == 1){\\n                while(A[odd_p]%2 == 1)\\n                    odd_p += 2;\\n                swap(A, i, odd_p);\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void swap(int[] A, int i, int j){\\n         int tmp = A[i];\\n         A[i] = A[j];\\n         A[j] = tmp;\\n    }\\n    \\n    public int[] sortArrayByParityII(int[] A) {\\n        int odd_p = 1;\\n        int n = A.length;\\n        \\n        for(int i=0;i<n;i+=2){\\n            if(A[i]%2 == 1){\\n                while(A[odd_p]%2 == 1)\\n                    odd_p += 2;\\n                swap(A, i, odd_p);\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349213,
                "title": "solution-in-python-3-beats-100-two-pointer-space-o-1",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n    \\tj = 1\\n    \\tfor i in range(0,len(A),2):\\n    \\t\\tif A[i] % 2 == 0: continue\\n    \\t\\twhile A[j] % 2 != 0: j += 2\\n    \\t\\tA[i], A[j] = A[j], A[i]\\n    \\treturn A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n    \\tj = 1\\n    \\tfor i in range(0,len(A),2):\\n    \\t\\tif A[i] % 2 == 0: continue\\n    \\t\\twhile A[j] % 2 != 0: j += 2\\n    \\t\\tA[i], A[j] = A[j], A[i]\\n    \\treturn A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 266823,
                "title": "java-two-pointers-one-pass-beats-99",
                "content": "```\\n`public int[] sortArrayByParityII(int[] A) {\\n        int[] res = new int[A.length];\\n        int i = 0, k = 1;\\n        for (int j = 0; j < A.length; j++) {\\n            if (A[j] % 2 == 0) {\\n                res[i] = A[j];\\n                i+=2;\\n            } \\n            else {\\n                res[k] = A[j];\\n                k+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n`public int[] sortArrayByParityII(int[] A) {\\n        int[] res = new int[A.length];\\n        int i = 0, k = 1;\\n        for (int j = 0; j < A.length; j++) {\\n            if (A[j] % 2 == 0) {\\n                res[i] = A[j];\\n                i+=2;\\n            } \\n            else {\\n                res[k] = A[j];\\n                k+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208169,
                "title": "c-this-problem-is-so-easy-that-i-code-it-fluently-with-no-change",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        \\n        for(int i=0,j=1;j<A.size();){\\n            if(A[i]%2 == 1 && A[j]%2 == 0){\\n                swap(A[i],A[j]);\\n                i=i+2;\\n                j=j+2;\\n            }else if(A[i]%2 == 0 && A[j]%2 == 0){\\n                i=i+2;\\n            }else if(A[i]%2 == 1 && A[j]%2 == 1){\\n                j=j+2;\\n            }else{\\n                i=i+2;\\n                j=j+2;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        \\n        for(int i=0,j=1;j<A.size();){\\n            if(A[i]%2 == 1 && A[j]%2 == 0){\\n                swap(A[i],A[j]);\\n                i=i+2;\\n                j=j+2;\\n            }else if(A[i]%2 == 0 && A[j]%2 == 0){\\n                i=i+2;\\n            }else if(A[i]%2 == 1 && A[j]%2 == 1){\\n                j=j+2;\\n            }else{\\n                i=i+2;\\n                j=j+2;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182755,
                "title": "javascript",
                "content": "```\nvar sortArrayByParityII = function(A) {\n    let oddIndex = 1;\n    let evenIndex = 0;\n    \n    let result = new Array(A.length);\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] % 2 == 0) {\n            result[evenIndex] = A[i];\n            evenIndex += 2;\n        } else {\n            result[oddIndex] = A[i];\n            oddIndex += 2;\n        }\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar sortArrayByParityII = function(A) {\n    let oddIndex = 1;\n    let evenIndex = 0;\n    \n    let result = new Array(A.length);\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] % 2 == 0) {\n            result[evenIndex] = A[i];\n            evenIndex += 2;\n        } else {\n            result[oddIndex] = A[i];\n            oddIndex += 2;\n        }\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733555,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0 , odd=1;\\n\\t\\t\\t\\tint n = nums.size() ;\\n\\t\\t\\t\\twhile(even < n && odd < n){\\n\\t\\t\\t\\t\\tif(nums[even]%2==0){\\n\\t\\t\\t\\t\\t\\teven += 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[odd]%2 == 1){\\n\\t\\t\\t\\t\\t\\todd+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tswap(nums[even],nums[odd]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0 , odd=1;\\n\\t\\t\\t\\tint n = nums.size() ;\\n\\t\\t\\t\\twhile(even < n && odd < n){\\n\\t\\t\\t\\t\\tif(nums[even]%2==0){\\n\\t\\t\\t\\t\\t\\teven += 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[odd]%2 == 1){\\n\\t\\t\\t\\t\\t\\todd+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tswap(nums[even],nums[odd]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440934,
                "title": "smartest-solution-with-java-beats-99-50-2-way",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n\\n        while(true){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even += 2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd += 2;\\n            }\\n            if(odd >= nums.length || even >= nums.length) break;\\n\\n            int temp = nums[odd];\\n            nums[odd] = nums[even];\\n            nums[even] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n\\n        while(true){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even += 2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd += 2;\\n            }\\n            if(odd >= nums.length || even >= nums.length) break;\\n\\n            int temp = nums[odd];\\n            nums[odd] = nums[even];\\n            nums[even] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304439,
                "title": "most-easy-way-efficient-approach-beats-95",
                "content": "# Intuition\\nAs soon as i saw the problem it was clear that we have to swap any unwanted element with respect to its index. i.e even element in odd index and odd element in even index.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers approach. Here we will take two pointers i and j, i is to find any odd element in even index, so i will start from 0 (i=0), j is to find even any element in odd index. When these both condition are true just swap i and j.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=1;\\n        while(i<n && j<n)\\n        {\\n            while(i<n && nums[i]%2==0)\\n                i+=2;\\n            while(j<n && nums[j]%2!=0)\\n                j+=2;\\n            if(i<n)\\n                swap(nums[i],nums[j]);\\n            i+=2;j+=2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=1;\\n        while(i<n && j<n)\\n        {\\n            while(i<n && nums[i]%2==0)\\n                i+=2;\\n            while(j<n && nums[j]%2!=0)\\n                j+=2;\\n            if(i<n)\\n                swap(nums[i],nums[j]);\\n            i+=2;j+=2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121590,
                "title": "beats-99-optimization-two-solution-o-2n-o-n",
                "content": "# Intuition One\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. since half of array contains even and odd numbers, and we have to place even at even elements indexes and odd elements at odd indexes so to avoid complexity we declare another vector for even and odd for easy way.\\n# Approach Number One\\n<!-- Describe your approach to solving the problem. -->\\n1. declare even and odd vector. if nums[i] is even array, pushback it in even and if it is odd then in odd array\\n2. now, in loop, check whether i is even or odd, accordingly set even elements at even indexes and odd elements at odd indexes respectively.\\n3. I have taken k and m so that i can excess even and odd array elements\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2N)-> O(N)\\n\\n# Code One\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> even;\\n        vector<int> odd;\\n\\n        //seperating even and odd elements\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1)\\n            odd.push_back(nums[i]);\\n            else \\n            even.push_back(nums[i]);\\n        }\\n        int k=0, m=0;\\n        inserting even element at even index and odd at odd index.\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(i&1)//odd\\n                nums[i]= odd[m++];\\n            else//even\\n                nums[i]= even[k++];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# Intuition Two\\nWe can solve this without declaring extra arrays, that is, even and odd. We will check directly nums[i] is even or odd and directly place it at its respective index in ans vector.\\n\\n# Approach Number Two(OPTIMIZED)\\n1. iterate throughout the array, check nums[i] is even or odd. \\n2. if nums[i] is even set it to even index and if it is odd set it to odd index.\\n\\n# Time Complexity -> O(N)\\n# Space Complexity ->O(1)\\nCode block\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int k=1, m=0;\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1) //odd\\n            {\\n                ans[k]= nums[i];\\n                k=k+2;\\n            }\\n            else//even\\n            {\\n                ans[m]=nums[i];\\n                m=m+2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// hope you like it. Upvote it please. If you find any problem, do let me know in the comment section.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> even;\\n        vector<int> odd;\\n\\n        //seperating even and odd elements\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1)\\n            odd.push_back(nums[i]);\\n            else \\n            even.push_back(nums[i]);\\n        }\\n        int k=0, m=0;\\n        inserting even element at even index and odd at odd index.\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(i&1)//odd\\n                nums[i]= odd[m++];\\n            else//even\\n                nums[i]= even[k++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821154,
                "title": "cpp-two-pointer-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int odd = 1; // pointer at odd index\\n        int even = 0; //pointer at even index \\n        \\n        while(even<nums.size()){\\n            if(nums[even] % 2 == 0){ // if even place has even value \\n                even += 2; // increment even pointer\\n            }\\n            else{ // else even place has odd value\\n                swap(nums[even], nums[odd]); // swap values such that odd pointer will surely have odd value\\n                odd += 2; // increment odd pointer\\n            }\\n        }\\n        return nums; // return your in-place solution \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int odd = 1; // pointer at odd index\\n        int even = 0; //pointer at even index \\n        \\n        while(even<nums.size()){\\n            if(nums[even] % 2 == 0){ // if even place has even value \\n                even += 2; // increment even pointer\\n            }\\n            else{ // else even place has odd value\\n                swap(nums[even], nums[odd]); // swap values such that odd pointer will surely have odd value\\n                odd += 2; // increment odd pointer\\n            }\\n        }\\n        return nums; // return your in-place solution \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755990,
                "title": "js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\nlet res = [];\\nnums = nums.sort()\\n\\n\\nlet odd = [];\\nlet even = [];\\nfor (let i = 0; i < nums.length; i++) {\\n  if(nums[i] % 2 === 0) odd.push(nums[i]);\\n  else {\\n    even.push(nums[i])\\n  }  \\n}\\nfor (let i = 0; i < nums.length; i++) {\\n  if(i % 2 === 0)\\n    res.push(odd.pop())\\n  else  res.push(even.pop())\\n}\\nreturn res\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\nlet res = [];\\nnums = nums.sort()\\n\\n\\nlet odd = [];\\nlet even = [];\\nfor (let i = 0; i < nums.length; i++) {\\n  if(nums[i] % 2 === 0) odd.push(nums[i]);\\n  else {\\n    even.push(nums[i])\\n  }  \\n}\\nfor (let i = 0; i < nums.length; i++) {\\n  if(i % 2 === 0)\\n    res.push(odd.pop())\\n  else  res.push(even.pop())\\n}\\nreturn res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703647,
                "title": "85ms-java-solution-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        \\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        \\n        for (int n : A) {\\n            if (n % 2 == 0)\\n                even.add(n);\\n            else \\n                odd.add(n);\\n        }\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % 2 == 0) {\\n                result[i] = even.remove(0);\\n            } else {\\n                result[i] = odd.remove(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        \\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        \\n        for (int n : A) {\\n            if (n % 2 == 0)\\n                even.add(n);\\n            else \\n                odd.add(n);\\n        }\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % 2 == 0) {\\n                result[i] = even.remove(0);\\n            } else {\\n                result[i] = odd.remove(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702239,
                "title": "java-easiest-solution-2-approaches-faster-than-80-online-submission-easy-understanding",
                "content": "```\\n//Approch :- 1 Runtime 9Ms Faster Than 33.3%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0,odd = 1;\\n        int[] arr = new int[nums.length];\\n        for(int i: nums){\\n            if(i%2 == 0){\\n                arr[even] = i;\\n                even+=2;\\n            }\\n            else{\\n                arr[odd] = i;\\n                odd+=2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n//Approch :- 2 Runtime 4Ms Faster Than 77.63%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even=0,odd=1;\\n        int[] arr = new int[nums.length];\\n        while(even<nums.length && odd<nums.length){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even+=2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd+=2;\\n            }\\n            if(even<nums.length && odd<nums.length){\\n                int temp = nums[even];\\n                nums[even] = nums[odd];\\n                nums[odd] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Approch :- 1 Runtime 9Ms Faster Than 33.3%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0,odd = 1;\\n        int[] arr = new int[nums.length];\\n        for(int i: nums){\\n            if(i%2 == 0){\\n                arr[even] = i;\\n                even+=2;\\n            }\\n            else{\\n                arr[odd] = i;\\n                odd+=2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n//Approch :- 2 Runtime 4Ms Faster Than 77.63%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even=0,odd=1;\\n        int[] arr = new int[nums.length];\\n        while(even<nums.length && odd<nums.length){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even+=2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd+=2;\\n            }\\n            if(even<nums.length && odd<nums.length){\\n                int temp = nums[even];\\n                nums[even] = nums[odd];\\n                nums[odd] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106494,
                "title": "c-easy-two-pointer-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n     vector<int>ans;\\n        vector<int>even;\\n        vector<int>odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even.push_back(nums[i]);\\n            }\\n            if(nums[i]%2==1){\\n                odd.push_back(nums[i]);\\n            }\\n        }\\n            int j=0;\\n            int k=0;\\n            for(int i=0;i<nums.size();i++){\\n                if(i%2==0){\\n                    ans.push_back(even[j]);\\n                    j++;\\n                }\\n                else{\\n                    ans.push_back(odd[k]);\\n                    k++;\\n                }\\n            }\\n return ans;\\n        \\n    }\\n};\\n \\n           \\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n     vector<int>ans;\\n        vector<int>even;\\n        vector<int>odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2074974,
                "title": "c-solution-simply-explained-constant-space-fast-algorithm",
                "content": "```\\nclass Solution {\\n  public:\\n    void reArrange(int arr[], int n) {\\n        //I have tried writing a simple while-loop method to swap wrongly placed odd and wrongly placed even elements.\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        while(x<n && y<n){\\n            \\n            //wrongly placed odd\\n            if(x%2==0 and arr[x]%2==1){\\n                x++;\\n            }\\n            //rightly placed even\\n            else if(x%2==0 and arr[x]%2==0){\\n                x++;\\n            }\\n            //rightly placed odd\\n            else if(x%2==1 and arr[x]%2==1){\\n                x++;\\n            }\\n            \\n            //wrongly placed even\\n            if(y%2==1 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed even\\n            else if(y%2==0 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed odd\\n            else if(y%2==1 and arr[y]%2==1){\\n                y++;\\n            }\\n            \\n            //swap wrongly placed even and wrongly placed odd\\n            if(x%2==1 and arr[x]%2==0 and y%2==0 and arr[y]%2==1){\\n                swap(arr[x],arr[y]);\\n                x++;\\n                y++;\\n            }\\n        }\\n    }\\n};\\n```\\nDo upvote and comment. Thanks.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    void reArrange(int arr[], int n) {\\n        //I have tried writing a simple while-loop method to swap wrongly placed odd and wrongly placed even elements.\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        while(x<n && y<n){\\n            \\n            //wrongly placed odd\\n            if(x%2==0 and arr[x]%2==1){\\n                x++;\\n            }\\n            //rightly placed even\\n            else if(x%2==0 and arr[x]%2==0){\\n                x++;\\n            }\\n            //rightly placed odd\\n            else if(x%2==1 and arr[x]%2==1){\\n                x++;\\n            }\\n            \\n            //wrongly placed even\\n            if(y%2==1 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed even\\n            else if(y%2==0 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed odd\\n            else if(y%2==1 and arr[y]%2==1){\\n                y++;\\n            }\\n            \\n            //swap wrongly placed even and wrongly placed odd\\n            if(x%2==1 and arr[x]%2==0 and y%2==0 and arr[y]%2==1){\\n                swap(arr[x],arr[y]);\\n                x++;\\n                y++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057475,
                "title": "python-two-pointers-o-n-time-explanation",
                "content": "<b>Success</b>\\nDetails \\nRuntime: 228 ms, faster than <b>73.41% </b>of Python3 online submissions for Sort Array By Parity II.\\nMemory Usage: 16.1 MB, less than <b>91.62%</b> of Python3 online submissions for Sort Array By Parity II.\\n\\n\\n1. Itterating i pointer over the array starting from zero and skipping one element so i will be always even.\\n2. Check if the current element is odd or even\\n3. If even we dont have to do anything\\n4. if odd chek j pointer which was initillized at 1.\\n5. Itterating j pointer over the array starting from one and skipping one element so i will be always odd.\\n6. if jth element is even we have to swap jth element with ith.\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j=1\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2!=0:\\n                while nums[j]%2!=0:\\n                    j=j+2\\n                nums[i],nums[j]=nums[j],nums[i]\\n        return nums\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j=1\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2!=0:\\n                while nums[j]%2!=0:\\n                    j=j+2\\n                nums[i],nums[j]=nums[j],nums[i]\\n        return nums\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552138,
                "title": "c-solution-two-pointer-using-bitwise-operator",
                "content": "**If the Solution helps you,please do consider upvoting it.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n      for(int i=0,j=1;i<nums.size() and j<nums.size();)\\n      {\\n          if(!(nums[i]&1))\\n              i+=2;\\n          else if(nums[j]&1)\\n              j+=2;\\n          else\\n              swap(nums[i],nums[j]);\\n      }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n      for(int i=0,j=1;i<nums.size() and j<nums.size();)\\n      {\\n          if(!(nums[i]&1))\\n              i+=2;\\n          else if(nums[j]&1)\\n              j+=2;\\n          else\\n              swap(nums[i],nums[j]);\\n      }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493808,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n\\tvector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n\\t\\tint n = nums.size();\\n\\t\\tint i = 0, j = 1;\\n\\t\\twhile(i < n && j < n)\\n        {\\n\\t\\t\\tif(nums[i] % 2 == 0)\\n            {\\n\\t\\t\\t\\ti += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[j] % 2 == 1)\\n            {\\n\\t\\t\\t\\tj += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n\\tvector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n\\t\\tint n = nums.size();\\n\\t\\tint i = 0, j = 1;\\n\\t\\twhile(i < n && j < n)\\n        {\\n\\t\\t\\tif(nums[i] % 2 == 0)\\n            {\\n\\t\\t\\t\\ti += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[j] % 2 == 1)\\n            {\\n\\t\\t\\t\\tj += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491669,
                "title": "inplace-solution-using-two-pointers-java",
                "content": "It is given that the array will have same count of even and odd numbers which means that the length of the array will always be even. \\nIf we maintain two pointers `left` and `right` at opposite ends of the array, i.e.,\\n\\n```java\\nleft = 0\\nright = n - 1\\n```\\n\\nThen we can safely say that `left` will be at even index and `right` will be at odd index. We will use this property and always make sure that the element at `left` will always be even and element at `right` will always be odd. We will move both pointers two steps ahead and behind respectively. It will result in the following three cases -\\n\\n1. If both the elements are violating the constraint, we will swap them and move both pointers\\n2. If only a single element is violating the constraint, we will move that pointer only.\\n3. If both the elements are not violating the constraint, we will just move both the pointers.\\n\\n```java\\npublic class Problem28_SortArrayByParityII {\\n\\n    public int[] sortArrayByParityII(int[] nums) {\\n        // Special case\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Length of the array\\n        int n = nums.length;\\n        // Left and right pointers\\n        int left = 0;\\n        int right = n - 1;\\n        // Loop until the condition is met\\n        while (left < n && right >= 0) {\\n            // If both the numbers at wrong positions, we will swap them\\n            if (nums[left] % 2 == 1 && nums[right] % 2 == 0) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left += 2;\\n                right -= 2;\\n            }\\n            // If the left number is at wrong position but right\\n            // number is at correct position, we will move right\\n            // pointer two steps before\\n            else if (nums[left] % 2 == 1 && nums[right] % 2 == 1) {\\n                right -= 2;\\n            }\\n            // If the right number is at wrong position but left\\n            // number is at correct position, we will move left\\n            // pointer two steps after\\n            else if (nums[left] % 2 == 0 && nums[right] % 2 == 0) {\\n                left += 2;\\n            }\\n            // If both the numbers are at correct position, we just move\\n            // both the pointers\\n            else {\\n                left += 2;\\n                right -= 2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```java\\nleft = 0\\nright = n - 1\\n```\n```java\\npublic class Problem28_SortArrayByParityII {\\n\\n    public int[] sortArrayByParityII(int[] nums) {\\n        // Special case\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Length of the array\\n        int n = nums.length;\\n        // Left and right pointers\\n        int left = 0;\\n        int right = n - 1;\\n        // Loop until the condition is met\\n        while (left < n && right >= 0) {\\n            // If both the numbers at wrong positions, we will swap them\\n            if (nums[left] % 2 == 1 && nums[right] % 2 == 0) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left += 2;\\n                right -= 2;\\n            }\\n            // If the left number is at wrong position but right\\n            // number is at correct position, we will move right\\n            // pointer two steps before\\n            else if (nums[left] % 2 == 1 && nums[right] % 2 == 1) {\\n                right -= 2;\\n            }\\n            // If the right number is at wrong position but left\\n            // number is at correct position, we will move left\\n            // pointer two steps after\\n            else if (nums[left] % 2 == 0 && nums[right] % 2 == 0) {\\n                left += 2;\\n            }\\n            // If both the numbers are at correct position, we just move\\n            // both the pointers\\n            else {\\n                left += 2;\\n                right -= 2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491222,
                "title": "c-two-pointers-inplace-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();){\\n\\t\\t\\t// If we get an odd number or  an even number which is already processed then leave that number  \\n            if(nums[i]&1 || (i<j && !(i&1))){ \\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[j]); // Placing even numbers at their right place. By doing this, the odd numbers will come in their place automatically\\n                j+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();){\\n\\t\\t\\t// If we get an odd number or  an even number which is already processed then leave that number  \\n            if(nums[i]&1 || (i<j && !(i&1))){ \\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[j]); // Placing even numbers at their right place. By doing this, the odd numbers will come in their place automatically\\n                j+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335190,
                "title": "c-solution-two-pointer-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenPointer = 0, oddPointer = 1;\\n        while(evenPointer < nums.size() && oddPointer <nums.size()){\\n            if(nums[evenPointer] %2 == 1 && nums[oddPointer]%2==0){\\n                swap(nums[evenPointer],nums[oddPointer]);\\n                evenPointer+=2;\\n                oddPointer+=2;\\n                continue;\\n            }\\n            if(nums[evenPointer]%2==0){\\n                evenPointer+=2;\\n            }\\n            if(nums[oddPointer]%2==1){\\n                oddPointer+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenPointer = 0, oddPointer = 1;\\n        while(evenPointer < nums.size() && oddPointer <nums.size()){\\n            if(nums[evenPointer] %2 == 1 && nums[oddPointer]%2==0){\\n                swap(nums[evenPointer],nums[oddPointer]);\\n                evenPointer+=2;\\n                oddPointer+=2;\\n                continue;\\n            }\\n            if(nums[evenPointer]%2==0){\\n                evenPointer+=2;\\n            }\\n            if(nums[oddPointer]%2==1){\\n                oddPointer+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003699,
                "title": "python-3-two-pointers-o-n",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\tans = [None] * len(A)\\n\\t\\tk = 0\\n\\t\\tt = 1\\n\\t\\tfor i in A:\\n\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\tans[k] = i\\n\\t\\t\\t\\tk += 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[t] = i\\n\\t\\t\\t\\tt += 2\\n\\t\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\tans = [None] * len(A)\\n\\t\\tk = 0\\n\\t\\tt = 1\\n\\t\\tfor i in A:\\n\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\tans[k] = i\\n\\t\\t\\t\\tk += 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[t] = i\\n\\t\\t\\t\\tt += 2\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767628,
                "title": "c-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i,even=0,odd=1;\\n        vector<int> B(A.size());\\n        for(i=0;i<A.size();i++)\\n        {\\n            if((A[i]%2)==0)\\n            {\\n               B[even]=A[i];\\n                even+=2;\\n            } \\n            else\\n            {\\n               B[odd]=A[i];\\n                odd+=2; \\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i,even=0,odd=1;\\n        vector<int> B(A.size());\\n        for(i=0;i<A.size();i++)\\n        {\\n            if((A[i]%2)==0)\\n            {\\n               B[even]=A[i];\\n                even+=2;\\n            } \\n            else\\n            {\\n               B[odd]=A[i];\\n                odd+=2; \\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755362,
                "title": "javascript-simple-using-filter",
                "content": "```\\nvar sortArrayByParityII = function(A) {\\n    let evenNums = A.filter((i) => i % 2 === 0);\\n    let oddNums = A.filter((i) => i % 2 !== 0);\\n    \\n    let res = [];\\n    for (let i = 0; i < A.length / 2; i++) {\\n        res.push(evenNums[i], oddNums[i]);\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nStats:\\nRuntime: 100 ms, faster than 88.97% of JavaScript online submissions for Sort Array By Parity II.\\nMemory Usage: 44.3 MB, less than 12.50% of JavaScript online submissions for Sort Array By Parity II.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(A) {\\n    let evenNums = A.filter((i) => i % 2 === 0);\\n    let oddNums = A.filter((i) => i % 2 !== 0);\\n    \\n    let res = [];\\n    for (let i = 0; i < A.length / 2; i++) {\\n        res.push(evenNums[i], oddNums[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308659,
                "title": "efficient-python-solution-with-generator",
                "content": "We only need to check every other element for violating the problem statement invariant. If that happens, we can use generator to find matching pair to swap and to also pick up where we left off on next mismatch.\\n\\n```\\ndef sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        def gen_odd():\\n            for j in range(1, len(A), 2):\\n                if not A[j] % 2: yield j\\n\\n        odd = gen_odd()\\n        for i in range(0,len(A),2):\\n            if A[i] % 2:\\n                j = next(odd)\\n                A[i], A[j] = A[j], A[i]\\n\\n        return A\\n```",
                "solutionTags": [],
                "code": "```\\ndef sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        def gen_odd():\\n            for j in range(1, len(A), 2):\\n                if not A[j] % 2: yield j\\n\\n        odd = gen_odd()\\n        for i in range(0,len(A),2):\\n            if A[i] % 2:\\n                j = next(odd)\\n                A[i], A[j] = A[j], A[i]\\n\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 223835,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(i < A.length && j < A.length)\\n        {\\n            while(i < A.length && A[i] % 2 == 0) i += 2;\\n            while(j < A.length && A[j] % 2 == 1) j += 2;\\n            \\n            if(i < A.length && j < A.length)\\n                swap(A, i, j);\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int evenIndex = 0;\\n        int oddIndex = A.length - 1;\\n        \\n        while(evenIndex < A.length && oddIndex > 0)\\n        {\\n            if(A[evenIndex] % 2 > A[oddIndex] % 2)\\n                swap(A, evenIndex, oddIndex);\\n            \\n            if(A[evenIndex] % 2 == 0) evenIndex += 2;\\n            if(A[oddIndex] % 2 == 1)  oddIndex -= 2;\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(i < A.length && j < A.length)\\n        {\\n            while(i < A.length && A[i] % 2 == 0) i += 2;\\n            while(j < A.length && A[j] % 2 == 1) j += 2;\\n            \\n            if(i < A.length && j < A.length)\\n                swap(A, i, j);\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int evenIndex = 0;\\n        int oddIndex = A.length - 1;\\n        \\n        while(evenIndex < A.length && oddIndex > 0)\\n        {\\n            if(A[evenIndex] % 2 > A[oddIndex] % 2)\\n                swap(A, evenIndex, oddIndex);\\n            \\n            if(A[evenIndex] % 2 == 0) evenIndex += 2;\\n            if(A[oddIndex] % 2 == 1)  oddIndex -= 2;\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204664,
                "title": "c-solution",
                "content": "```\\nint *sortArrayByParityII(int const *A, int ASize, int *returnSize) {\\n    int odd = 1, even = 0;\\n    int *ret = (int *) malloc(sizeof(int) * (*returnSize = ASize));\\n    for (int i = 0; i < *returnSize; ++i) {\\n        if (A[i] % 2 == 0) {\\n            ret[even] = A[i];\\n            even += 2;\\n        } else {\\n            ret[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint *sortArrayByParityII(int const *A, int ASize, int *returnSize) {\\n    int odd = 1, even = 0;\\n    int *ret = (int *) malloc(sizeof(int) * (*returnSize = ASize));\\n    for (int i = 0; i < *returnSize; ++i) {\\n        if (A[i] % 2 == 0) {\\n            ret[even] = A[i];\\n            even += 2;\\n        } else {\\n            ret[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733546,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n        int even=0;\\n        int odd=1;\\n\\n        cout<<\"Hello\";\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] % 2==0){\\n                ans[even]=nums[i];\\n                if(even+2 <= nums.size()-1){\\n                    even+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n            else{\\n                ans[odd]=nums[i];\\n                if(odd+2 <= nums.size()-1){\\n                    odd+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n        int even=0;\\n        int odd=1;\\n\\n        cout<<\"Hello\";\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] % 2==0){\\n                ans[even]=nums[i];\\n                if(even+2 <= nums.size()-1){\\n                    even+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n            else{\\n                ans[odd]=nums[i];\\n                if(odd+2 <= nums.size()-1){\\n                    odd+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2952911,
                "title": "python3-simple-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        answer=[]\\n\\n        # We split nums into even entries and odd entries\\n        even = [n for n in nums if n%2 == 0]\\n        odd =  [n for n in nums if n%2 == 1]\\n\\n        # We fill answer with even and odd entries \\n        for a, b in zip(even, odd):\\n            answer.append(a)\\n            answer.append(b)\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        answer=[]\\n\\n        # We split nums into even entries and odd entries\\n        even = [n for n in nums if n%2 == 0]\\n        odd =  [n for n in nums if n%2 == 1]\\n\\n        # We fill answer with even and odd entries \\n        for a, b in zip(even, odd):\\n            answer.append(a)\\n            answer.append(b)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933111,
                "title": "easy-with-two-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n       \\n       /* int temp=0;\\n        int k=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        \\n        if(i%2==0&&nums[i]%2==0||i%2!=0&&nums[i]%2!=0)\\n        {\\n            continue;\\n        }\\n        temp=i;\\n        for(int j=i+1;j<nums.length;j++)\\n        {\\n            if((i%2!=0 && nums[i]%2==0)||(i%2==0 && nums[i]%2!=0))\\n            {\\n               k= nums[temp];\\n               nums[temp]=nums[j];\\n               nums[j]=k;\\n                \\n\\n            }\\n        }\\n        }\\n\\n        return nums;\\n    }*/\\n    \\n        int i = 0, j = 1;\\n        int l = nums.length;\\n        int[] B = new int[l];\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k]%2 == 0){\\n                B[i] = nums[k];\\n                i+=2;\\n            }else{\\n                B[j] = nums[k];\\n                j+=2;\\n            } \\n        }\\n        return B;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n       \\n       /* int temp=0;\\n        int k=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        \\n        if(i%2==0&&nums[i]%2==0||i%2!=0&&nums[i]%2!=0)\\n        {\\n            continue;\\n        }\\n        temp=i;\\n        for(int j=i+1;j<nums.length;j++)\\n        {\\n            if((i%2!=0 && nums[i]%2==0)||(i%2==0 && nums[i]%2!=0))\\n            {\\n               k= nums[temp];\\n               nums[temp]=nums[j];\\n               nums[j]=k;\\n                \\n\\n            }\\n        }\\n        }\\n\\n        return nums;\\n    }*/\\n    \\n        int i = 0, j = 1;\\n        int l = nums.length;\\n        int[] B = new int[l];\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k]%2 == 0){\\n                B[i] = nums[k];\\n                i+=2;\\n            }else{\\n                B[j] = nums[k];\\n                j+=2;\\n            } \\n        }\\n        return B;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896465,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[]ans= new int[nums.length];\\n\\t\\tint even=0;\\n        int odd=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                ans[even]=nums[i];\\n                even=even+2;\\n            }else{\\n                ans[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[]ans= new int[nums.length];\\n\\t\\tint even=0;\\n        int odd=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                ans[even]=nums[i];\\n                even=even+2;\\n            }else{\\n                ans[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655409,
                "title": "java-two-solutions-extra-space-and-in-place",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Using extra-space (stack):\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        Stack<Integer> evens = new Stack<>();\\n        Stack<Integer> odds = new Stack<>();\\n\\n        for (int n : nums) {\\n            if (n % 2 == 0) evens.add(n);\\n            else odds.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = evens.pop();\\n            else nums[i] = odds.pop();\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. In-place: \\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i = 0, j = 1;\\n        int n = nums.length;\\n\\n        while (i < n && j < n) {\\n            while (i < n && nums[i] % 2 == 0) i += 2;\\n            while (j < n && nums[j] % 2 == 1) j += 2;\\n\\n            if (i < n && j < n) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(N), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        Stack<Integer> evens = new Stack<>();\\n        Stack<Integer> odds = new Stack<>();\\n\\n        for (int n : nums) {\\n            if (n % 2 == 0) evens.add(n);\\n            else odds.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = evens.pop();\\n            else nums[i] = odds.pop();\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i = 0, j = 1;\\n        int n = nums.length;\\n\\n        while (i < n && j < n) {\\n            while (i < n && nums[i] % 2 == 0) i += 2;\\n            while (j < n && nums[j] % 2 == 1) j += 2;\\n\\n            if (i < n && j < n) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(N), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586768,
                "title": "both-approach-optimized-brute-force-two-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n\\t***METHOD-1***\\n** 2 ptr --> Brute Force using additional space**\\n\\n       int odd = 1  ; \\n        int even = 0 ; \\n        vector<int>ans(nums.size());\\n        for(int i=0 ; i<nums.size();i++) {\\n            if(nums[i]&1) {\\n                ans[odd] = nums[i];\\n                odd+=2;\\n            }\\n           else if(!(nums[i]&1)) {\\n                ans[even] = nums[i];\\n                even+=2;\\n            }     \\n        }\\n        return ans;    \\n        \\n     \\t***METHOD-2***\\n   ** 2 ptr -->  optimized Approach  Without using additional space**\\n\\n    \\n        int odd = 1  ; \\n        int even = 0 ; \\n        int n = nums.size();\\n        while(odd<n and even<n){\\n            // odd element at odd pos \\n            if(nums[odd]&1) { odd+=2;}\\n        // even element at even pos \\n             else if(!(nums[even]&1)) {even+=2;    }\\n            // odd element at even position and even element at odd position \\n            else if(!(nums[odd]&1) || nums[even]&1){\\n                swap(nums[odd],nums[even]);\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n\\t***METHOD-1***\\n** 2 ptr --> Brute Force using additional space**\\n\\n       int odd = 1  ; \\n        int even = 0 ; \\n        vector<int>ans(nums.size());\\n        for(int i=0 ; i<nums.size();i++) {\\n            if(nums[i]&1) {\\n                ans[odd] = nums[i];\\n                odd+=2;\\n            }\\n           else if(!(nums[i]&1)) {\\n                ans[even] = nums[i];\\n                even+=2;\\n            }     \\n        }\\n        return ans;    \\n        \\n     \\t***METHOD-2***\\n   ** 2 ptr -->  optimized Approach  Without using additional space**\\n\\n    \\n        int odd = 1  ; \\n        int even = 0 ; \\n        int n = nums.size();\\n        while(odd<n and even<n){\\n            // odd element at odd pos \\n            if(nums[odd]&1) { odd+=2;}\\n        // even element at even pos \\n             else if(!(nums[even]&1)) {even+=2;    }\\n            // odd element at even position and even element at odd position \\n            else if(!(nums[odd]&1) || nums[even]&1){\\n                swap(nums[odd],nums[even]);\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417872,
                "title": "python-simple-solution",
                "content": "```\\nresult = [0]*len(nums)\\n        even = 0\\n        odd = 1\\n        for i in nums:\\n            if i % 2 == 0:\\n                result[even] = i\\n                even += 2\\n            else:\\n                result[odd] = i\\n                odd += 2\\n        return (result)\\n```",
                "solutionTags": [],
                "code": "```\\nresult = [0]*len(nums)\\n        even = 0\\n        odd = 1\\n        for i in nums:\\n            if i % 2 == 0:\\n                result[even] = i\\n                even += 2\\n            else:\\n                result[odd] = i\\n                odd += 2\\n        return (result)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403590,
                "title": "java-o-1-space-o-n-time-90-faster-easy-explained",
                "content": "A brief about logical approach:\\n* We have two poiters,\\n\\t* `i` at index 0 (for even indices)\\n\\t* `j` at index 1 (for odd indices)\\n* Now we check whether `i` has an `even` number,\\n\\t* if `nums[i]` is even : `i+=2` (move to next even index)\\n\\t* if `nums[i]` is odd: we check whether `j` has an `odd` number,\\n\\t\\t* if `nums[j]` is odd : `j+=2` (move to next odd index)\\n\\t\\t* if `nums[j]` is even: swap `nums[i]` and `nums[j]`\\n\\nThats it!\\n\\nIf you found it helpful upvote. And if you have any doubts or suggestions, comment them down. \\u270C\\n\\n\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i=0,j=1;\\n\\t\\t\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]%2==0) i+=2;\\n            else{\\n                if(nums[j]%2!=0) j+=2;\\n                else{\\n                    int temp = nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i=0,j=1;\\n\\t\\t\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]%2==0) i+=2;\\n            else{\\n                if(nums[j]%2!=0) j+=2;\\n                else{\\n                    int temp = nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387565,
                "title": "c-solution-easy-and-simple",
                "content": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        vector<int>v(n); // ans vector will be of same size as nums\\n\\t\\t\\n        int i=0; // even index\\n        int j=1; // odd index\\n\\t\\t\\n        for(int k=0; k<n; k++){\\n            if(nums[k]%2==0){\\n                v[i]=nums[k];\\n                i+=2;\\n            }\\n            else if(nums[k]%2!=0){\\n                v[j]=nums[k];\\n                j+=2;\\n            }\\n        }\\n        return v;\\n    }\\n\\t// dry run to understand best!\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        vector<int>v(n); // ans vector will be of same size as nums\\n\\t\\t\\n        int i=0; // even index\\n        int j=1; // odd index\\n\\t\\t\\n        for(int k=0; k<n; k++){\\n            if(nums[k]%2==0){\\n                v[i]=nums[k];\\n                i+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2349723,
                "title": "100-faster-code-for-the-problem",
                "content": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int result[]=new int[nums.length];\\n        int j=0,k=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[j]=nums[i];\\n                j+=2;\\n            }\\n            else{\\n                \\n            result[k]=nums[i];\\n            k+=2;\\n            }\\n        }\\n        return(result);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int result[]=new int[nums.length];\\n        int j=0,k=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[j]=nums[i];\\n                j+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2280745,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tprint(nums)\\n\\n\\t\\t\\ts=0\\n\\t\\t\\te=1\\n\\n\\t\\t\\twhile s<len(nums) and e<len(nums):\\n\\t\\t\\t\\twhile nums[s]%2==0:\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\tif s>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\t\\t\\t\\twhile nums[e]%2!=0:\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\t\\t\\tif e>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\n\\t\\t\\t\\tif s<len(nums) and e<len(nums):\\n\\t\\t\\t\\t\\tnums[e],nums[s]=nums[s],nums[e]\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\treturn nums",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tprint(nums)\\n\\n\\t\\t\\ts=0\\n\\t\\t\\te=1\\n\\n\\t\\t\\twhile s<len(nums) and e<len(nums):\\n\\t\\t\\t\\twhile nums[s]%2==0:\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\tif s>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\t\\t\\t\\twhile nums[e]%2!=0:\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\t\\t\\tif e>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\n\\t\\t\\t\\tif s<len(nums) and e<len(nums):\\n\\t\\t\\t\\t\\tnums[e],nums[s]=nums[s],nums[e]\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\treturn nums",
                "codeTag": "Java"
            },
            {
                "id": 2209673,
                "title": "basic-swapping",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        for(int i = 0, j = 1; i < nums.size();){\\n            if(nums[i]%2==0)   i+=2; //for even index we are checking whether the number is even or not \\n            else if(nums[j]%2!=0)   j+=2; //here we are checking for odd index\\n            else swap(nums[i],nums[j]);// swap if both condition doesn\\'t match\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nDon\\'t forget to like:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        for(int i = 0, j = 1; i < nums.size();){\\n            if(nums[i]%2==0)   i+=2; //for even index we are checking whether the number is even or not \\n            else if(nums[j]%2!=0)   j+=2; //here we are checking for odd index\\n            else swap(nums[i],nums[j]);// swap if both condition doesn\\'t match\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123940,
                "title": "simple-c-solution-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int a=0,b=1;\\n        while (b<nums.size()&&a<nums.size()) {\\n            if (nums[a]%2==0) a+=2;\\n            else {\\n                if (nums[b]%2==0) {\\n                    swap(nums[a],nums[b]);\\n                    a+=2;\\n                    b+=2;\\n                }\\n                else b+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int a=0,b=1;\\n        while (b<nums.size()&&a<nums.size()) {\\n            if (nums[a]%2==0) a+=2;\\n            else {\\n                if (nums[b]%2==0) {\\n                    swap(nums[a],nums[b]);\\n                    a+=2;\\n                    b+=2;\\n                }\\n                else b+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110301,
                "title": "c-easy-solution-2-pointers",
                "content": "The basic intuition is, whenever we find element at odd index as even and element at even index as odd simultaneously, we just swap them them to their original positions , else we move even and odd pointers forward.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenIndex = 0 , oddIndex = 1 ; \\n        while (evenIndex < nums.size() && oddIndex < nums.size()) {\\n            if (nums[evenIndex] % 2 == 0)  evenIndex += 2 ;\\n            else if (nums[oddIndex] % 2 != 0) oddIndex += 2 ;\\n            else  swap(nums[evenIndex] , nums[oddIndex]) ; \\n        }\\n        return nums ; \\n    }\\n};\\n```\\nPlease do **upvote** if you found this helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenIndex = 0 , oddIndex = 1 ; \\n        while (evenIndex < nums.size() && oddIndex < nums.size()) {\\n            if (nums[evenIndex] % 2 == 0)  evenIndex += 2 ;\\n            else if (nums[oddIndex] % 2 != 0) oddIndex += 2 ;\\n            else  swap(nums[evenIndex] , nums[oddIndex]) ; \\n        }\\n        return nums ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058266,
                "title": "js-easiest",
                "content": "```\\nvar sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052518,
                "title": "java-o-n-complexity-with-faster-than-99-94-submission",
                "content": "```\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 , odd = 1;\\n        while( even < nums.length && odd < nums.length) {\\n            if(nums[even] % 2 != 0) {\\n                swap(nums, even, odd);\\n                odd += 2;\\n            } else even += 2;\\n        }\\n        return nums;\\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 , odd = 1;\\n        while( even < nums.length && odd < nums.length) {\\n            if(nums[even] % 2 != 0) {\\n                swap(nums, even, odd);\\n                odd += 2;\\n            } else even += 2;\\n        }\\n        return nums;\\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945828,
                "title": "sort-array-by-parity-i-ii-c-explanation",
                "content": "**C++ solutions**\\n\\n**1. [Sort Array By Parity I](https://leetcode.com/problems/sort-array-by-parity)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        \\n        while (l < r) {\\n            // skip even numbers from left\\n            // until an odd number is found\\n            while (l < r && nums[l] & 1 == 0) l++;\\n            // skip odd numbers from right\\n            // until an even number is found\\n            while (l < r && nums[r] & 1) r--;\\n            \\n            // now swap the numbers\\n            swap(nums[l], nums[r]);\\n            // loop until all numbers have been exhausted\\n            l++, r--;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**2. [Sort Array By Parity II](https://leetcode.com/problems/sort-array-by-parity-ii/)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1, n = nums.size();\\n        \\n        while (i < n && j < n) {\\n            // skip even numbers which are at even positions\\n            while (i < n && nums[i]%2 == 0) i += 2;\\n            // skip odd numbers which are at odd positions\\n            while (j < n && nums[j]%2 != 0) j += 2;\\n            \\n            // swap numbers which weren\\'t skipped\\n            // these numbers are obviously:\\n            // even at odd position & odd at even position\\n            if (i < n && j < n) swap(nums[i], nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\nFor both:\\nTime comlexity: **O(n)**\\nSpace complexity: **O(1)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        \\n        while (l < r) {\\n            // skip even numbers from left\\n            // until an odd number is found\\n            while (l < r && nums[l] & 1 == 0) l++;\\n            // skip odd numbers from right\\n            // until an even number is found\\n            while (l < r && nums[r] & 1) r--;\\n            \\n            // now swap the numbers\\n            swap(nums[l], nums[r]);\\n            // loop until all numbers have been exhausted\\n            l++, r--;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1, n = nums.size();\\n        \\n        while (i < n && j < n) {\\n            // skip even numbers which are at even positions\\n            while (i < n && nums[i]%2 == 0) i += 2;\\n            // skip odd numbers which are at odd positions\\n            while (j < n && nums[j]%2 != 0) j += 2;\\n            \\n            // swap numbers which weren\\'t skipped\\n            // these numbers are obviously:\\n            // even at odd position & odd at even position\\n            if (i < n && j < n) swap(nums[i], nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929768,
                "title": "c-solution-beats-97-92-o-n-complexity",
                "content": "**922. Sort Array By Parity II**\\n\\nHere, we have considered two variables **o** and **e** for odd and even respectively, and going to increment \\nit by 2 so that the element at index i if even then we will increment **e** by 2 and if odd then increment **o** \\nby 2.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n      vector<int>v(nums.size());\\n        int o=1,e=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                v[e]=nums[i];\\n                e+=2;\\n            }\\n            else\\n            {\\n                v[o]=nums[i];\\n                o+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb0273e4-5cfb-4fdc-9cbb-7767d42ca7a9_1649523099.3406916.png)\\n\\n**Please do upvote**\\uD83E\\uDD17\\n**Keep Codin\\' **\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n      vector<int>v(nums.size());\\n        int o=1,e=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                v[e]=nums[i];\\n                e+=2;\\n            }\\n            else\\n            {\\n                v[o]=nums[i];\\n                o+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892677,
                "title": "python-tc-o-n-sc-o-1-easy-solution-explained",
                "content": "**Please upvote if it is useful. Thanks!**\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j = 1 # j is used to check all the odd indexes\\n        \\n        # check all the even indexes with i\\n        for i in range(0, len(nums), 2):\\n            # nums[i] is odd while it should be even\\n            if nums[i] & 1:\\n                # look for the next even number in an odd index\\n                # it\\'s guaranteed to exist because we already found\\n                # ad odd number with even index\\n                while (j < len(nums)) and (nums[j] & 1):\\n                    j += 2\\n                # now swap them\\n                # by putting even numbers in positions with even indexes\\n                # we are also putting odd numbers in odd indexes as a\\n                # consequence of the swap, all in one pass\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j = 1 # j is used to check all the odd indexes\\n        \\n        # check all the even indexes with i\\n        for i in range(0, len(nums), 2):\\n            # nums[i] is odd while it should be even\\n            if nums[i] & 1:\\n                # look for the next even number in an odd index\\n                # it\\'s guaranteed to exist because we already found\\n                # ad odd number with even index\\n                while (j < len(nums)) and (nums[j] & 1):\\n                    j += 2\\n                # now swap them\\n                # by putting even numbers in positions with even indexes\\n                # we are also putting odd numbers in odd indexes as a\\n                # consequence of the swap, all in one pass\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883643,
                "title": "java-in-place-solution",
                "content": "```\\n    \\n    // given array with half even and half odd nums\\n    // place even nums in even indices and odd nums in odd indices\\n    \\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        // in a loop check if index is even or odd - this tells us whether we need to put even or odd number in that place\\n        // if correct num is in that place move to next index\\n        // if not, have a pointer move to the next correct val and swap those two and move to next index\\n        // O(1) space O(n) time\\n        \\n        int evenIndex = 0;\\n        int oddIndex = 1;\\n        \\n        while(true) {\\n            while(evenIndex < nums.length) {\\n                if(nums[evenIndex] % 2 == 0) {\\n                    evenIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            while(oddIndex < nums.length) {\\n                if(nums[oddIndex] % 2 != 0) {\\n                    oddIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            if(evenIndex < nums.length) { // or oddIndex doesn\\'t matter\\n                int temp = nums[evenIndex];\\n                nums[evenIndex] = nums[oddIndex];\\n                nums[oddIndex] = temp;\\n                evenIndex += 2;\\n                oddIndex += 2;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return nums;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    \\n    // given array with half even and half odd nums\\n    // place even nums in even indices and odd nums in odd indices\\n    \\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        // in a loop check if index is even or odd - this tells us whether we need to put even or odd number in that place\\n        // if correct num is in that place move to next index\\n        // if not, have a pointer move to the next correct val and swap those two and move to next index\\n        // O(1) space O(n) time\\n        \\n        int evenIndex = 0;\\n        int oddIndex = 1;\\n        \\n        while(true) {\\n            while(evenIndex < nums.length) {\\n                if(nums[evenIndex] % 2 == 0) {\\n                    evenIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            while(oddIndex < nums.length) {\\n                if(nums[oddIndex] % 2 != 0) {\\n                    oddIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            if(evenIndex < nums.length) { // or oddIndex doesn\\'t matter\\n                int temp = nums[evenIndex];\\n                nums[evenIndex] = nums[oddIndex];\\n                nums[oddIndex] = temp;\\n                evenIndex += 2;\\n                oddIndex += 2;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return nums;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1755746,
                "title": "c-in-place-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        while(i < nums.size() and j < nums.size()) {\\n            while(i < nums.size() and nums[i]%2 == 0) i += 2;\\n            while(j < nums.size() and nums[j]%2 == 1) j += 2;\\n            if(i < nums.size() and j < nums.size()) swap(nums[i],nums[j]);\\n            i += 2; j += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        while(i < nums.size() and j < nums.size()) {\\n            while(i < nums.size() and nums[i]%2 == 0) i += 2;\\n            while(j < nums.size() and nums[j]%2 == 1) j += 2;\\n            if(i < nums.size() and j < nums.size()) swap(nums[i],nums[j]);\\n            i += 2; j += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716736,
                "title": "simple-java-solution-using-two-index-variables-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n\\t\\n        int even_index = 0;\\n        int odd_index = 0;\\n        \\n        int[] returned_array = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(i%2 == 0){\\n                while(nums[even_index]%2 != 0){\\n                    even_index++;\\n                }\\n                \\n                returned_array[i] = nums[even_index];\\n                even_index++;\\n                \\n            } else {\\n                while(nums[odd_index]%2 == 0){\\n                    odd_index++;\\n                }\\n                \\n                returned_array[i] = nums[odd_index];\\n                odd_index++;\\n            }\\n        }\\n        \\n        return returned_array;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n\\t\\n        int even_index = 0;\\n        int odd_index = 0;\\n        \\n        int[] returned_array = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(i%2 == 0){\\n                while(nums[even_index]%2 != 0){\\n                    even_index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1694517,
                "title": "python-easy-solution-using-two-pointers-beats-90-solutions",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        l,r=0,len(nums)-1\\n        \\n        while l<len(nums) and r>0:\\n            \\n            if nums[l]%2==0: l+=2\\n                \\n            elif nums[r]%2!=0: r-=2\\n            \\n            else:\\n                nums[l],nums[r]=nums[r],nums[l]\\n                l+=2\\n                r-=2\\n               \\n        return nums\\n     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        l,r=0,len(nums)-1\\n        \\n        while l<len(nums) and r>0:\\n            \\n            if nums[l]%2==0: l+=2\\n                \\n            elif nums[r]%2!=0: r-=2\\n            \\n            else:\\n                nums[l],nums[r]=nums[r],nums[l]\\n                l+=2\\n                r-=2\\n               \\n        return nums\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621556,
                "title": "java-solution",
                "content": "```\\npublic int[] sortArrayByParityII(int[] nums) {\\n        \\n        int length = nums.length;\\n        int[] result = new int[length];\\n        int e = 0; //for even\\n        int o = 1; //for odd\\n        \\n        for(int num: nums) {\\n            \\n            if(num%2 == 0) {\\n                result[e] = num;\\n                e+=2;\\n\\n            }\\n            else {\\n                result[o] = num;\\n                o+=2;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] nums) {\\n        \\n        int length = nums.length;\\n        int[] result = new int[length];\\n        int e = 0; //for even\\n        int o = 1; //for odd\\n        \\n        for(int num: nums) {\\n            \\n            if(num%2 == 0) {\\n                result[e] = num;\\n                e+=2;\\n\\n            }\\n            else {\\n                result[o] = num;\\n                o+=2;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558853,
                "title": "python-simple-sloution",
                "content": "\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in nums:\\n            if i%2==0:\\n                a.append(i)\\n            if i%2!=0:\\n                b.append(i)\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in nums:\\n            if i%2==0:\\n                a.append(i)\\n            if i%2!=0:\\n                b.append(i)\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c",
                "codeTag": "Python3"
            },
            {
                "id": 1538449,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        int a = 0 , b = 1;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[a] = nums[i];\\n                a += 2;\\n            }\\n            else\\n            {\\n                result[b] = nums[i];\\n                b += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        int a = 0 , b = 1;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[a] = nums[i];\\n                a += 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1492732,
                "title": "rust-two-pointers",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc0922)\\n\\n<b>Problem List</b>\\n#TwoPointers - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/2_pointers)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/sort-array-by-parity-ii/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        let len_n = nums.len();\\n        let mut nums = nums;\\n        let mut idx_even: usize = 0;\\n        let mut idx_odd: usize = 1;\\n        while idx_even < len_n && idx_odd < len_n {\\n            if nums[idx_even] % 2 == 0 {\\n                idx_even += 2;\\n            }\\n            if nums[idx_odd] % 2 == 1 {\\n                idx_odd += 2;\\n            }\\n            if idx_even < len_n && idx_odd < len_n {\\n                nums.swap(idx_even, idx_odd);\\n            }\\n        }\\n        nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/sort-array-by-parity-ii/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        let len_n = nums.len();\\n        let mut nums = nums;\\n        let mut idx_even: usize = 0;\\n        let mut idx_odd: usize = 1;\\n        while idx_even < len_n && idx_odd < len_n {\\n            if nums[idx_even] % 2 == 0 {\\n                idx_even += 2;\\n            }\\n            if nums[idx_odd] % 2 == 1 {\\n                idx_odd += 2;\\n            }\\n            if idx_even < len_n && idx_odd < len_n {\\n                nums.swap(idx_even, idx_odd);\\n            }\\n        }\\n        nums\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492207,
                "title": "c-2-pointer-in-place-solution-explained-100-time-99-space",
                "content": "This problem is not too hard even when you consider operating in place (and it would be rather trivial otherwise: just creating a new array of the same size and populating it with of 2 pointers to write there in alternate order).\\n\\nIn order to solve it, we will use 3 variables:\\n* `i` and `j` will be our pointers, respectively set to `0` and `1` initially, with the goal to find odd (the former) or even value (the latter);\\n* `lmt` is going to be the limit of our search, set to be the length of our input.\\n\\nWe will then ran an infinite loop and inside it:\\n* move `i` to find the first odd value in even positions (if any such is left);\\n* move `j` to find the first even value in odd positions (if any such is left);\\n* check if we reached the end of the input and:\\n\\t* if not, we swap the values pointed by `i` and `j`;\\n\\t* otherwise, it means we are done parsing and just `break` out of the loop.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& ns) {\\n        // support variables\\n        int i = 0, j = 1, lmt = ns.size();\\n        // parsing ns\\n        while (true) {\\n            // moving i in even positions with odd values\\n            while (i < lmt && !(ns[i] & 1)) i += 2;\\n            // moving j in odd positions with even values\\n            while (j < lmt && (ns[j] & 1)) j += 2;\\n            // swapping if needed\\n            if (i < lmt && j < lmt) swap(ns[i], ns[j]);\\n            else break;\\n        }\\n        return ns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& ns) {\\n        // support variables\\n        int i = 0, j = 1, lmt = ns.size();\\n        // parsing ns\\n        while (true) {\\n            // moving i in even positions with odd values\\n            while (i < lmt && !(ns[i] & 1)) i += 2;\\n            // moving j in odd positions with even values\\n            while (j < lmt && (ns[j] & 1)) j += 2;\\n            // swapping if needed\\n            if (i < lmt && j < lmt) swap(ns[i], ns[j]);\\n            else break;\\n        }\\n        return ns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491779,
                "title": "c-easy-solution-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0  , j = 1;\\n        while(i<nums.size() and j <nums.size()-1 || i<nums.size()-1 and j<nums.size())\\n        {\\n            if(nums[i]%2 == 0 and nums[j]%2==1)\\n            {\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==1 and nums[j]%2==0 )\\n            {\\n                swap(nums[i],nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==0 and nums[j]%2==0)\\n            {\\n                i += 2;\\n            }else \\n            {\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0  , j = 1;\\n        while(i<nums.size() and j <nums.size()-1 || i<nums.size()-1 and j<nums.size())\\n        {\\n            if(nums[i]%2 == 0 and nums[j]%2==1)\\n            {\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==1 and nums[j]%2==0 )\\n            {\\n                swap(nums[i],nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==0 and nums[j]%2==0)\\n            {\\n                i += 2;\\n            }else \\n            {\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491589,
                "title": "2-solution-inc-in-place-c-solution-easy-to-understand",
                "content": "```\\n// Solution I - In place\\nvector<int> ans;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            if(i%2==0) {\\n                if(nums[i]%2==0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2==0) {\\n                        swap(nums[i],nums[j]);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            else {\\n                if(nums[i]%2!=0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2!=0) {\\n                        swap(nums[i], nums[j]);\\n                        break;\\n                    }\\n                    else continue;\\n                }\\n            }\\n        }\\n        return nums;\\n\\t\\t// Solution 2\\n\\t\\tclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> odd, even;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int i=0,j=0;\\n        while(i<odd.size() && j<even.size()) {\\n            if(j<even.size()) {\\n                ans.push_back(even[j]);\\n                j++;\\n            }\\n            if(i<odd.size()) {\\n                ans.push_back(odd[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Solution I - In place\\nvector<int> ans;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            if(i%2==0) {\\n                if(nums[i]%2==0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2==0) {\\n                        swap(nums[i],nums[j]);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            else {\\n                if(nums[i]%2!=0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2!=0) {\\n                        swap(nums[i], nums[j]);\\n                        break;\\n                    }\\n                    else continue;\\n                }\\n            }\\n        }\\n        return nums;\\n\\t\\t// Solution 2\\n\\t\\tclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> odd, even;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int i=0,j=0;\\n        while(i<odd.size() && j<even.size()) {\\n            if(j<even.size()) {\\n                ans.push_back(even[j]);\\n                j++;\\n            }\\n            if(i<odd.size()) {\\n                ans.push_back(odd[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491123,
                "title": "c-easy-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1)\\n            {\\n                v2.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                v1.push_back(nums[i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.size() / 2; i++)\\n        {\\n            v.push_back(v1[i]);\\n            v.push_back(v2[i]);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1)\\n            {\\n                v2.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1491089,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .filter(|&num| num % 2 == 0)\\n            .zip(nums.iter().filter(|&num| num % 2 != 0))\\n            .flat_map(|(&even, &odd)| vec![even, odd].into_iter())\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .filter(|&num| num % 2 == 0)\\n            .zip(nums.iter().filter(|&num| num % 2 != 0))\\n            .flat_map(|(&even, &odd)| vec![even, odd].into_iter())\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491039,
                "title": "sort-array-by-parity-ii-inplace-o-n-time-c",
                "content": "explanation:\\nfor every no. there are two possibilities: either its correct on its position or not correct.\\nalso as there are equal no. of odd and even nos, so for every incorrect odd, there will be one incorrect even and vice-versa.\\n\\nSo we will just keep two pointers : one for odd positions and one for even positions.\\nIgnore those which are already at correct position.\\nSwap those which are at incorrect.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(i<nums.size() && j<nums.size())\\n        {\\n            while(i<nums.size() && nums[i]%2==0)\\n                i+=2;\\n            while(j<nums.size() && nums[j]%2==1)\\n                j+=2;\\n            \\n            if(i<nums.size() && j<nums.size())\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(i<nums.size() && j<nums.size())\\n        {\\n            while(i<nums.size() && nums[i]%2==0)\\n                i+=2;\\n            while(j<nums.size() && nums[j]%2==1)\\n                j+=2;\\n            \\n            if(i<nums.size() && j<nums.size())\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490976,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(i%2==0){\\n                if(nums[i]%2==0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2==0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else{\\n                if(nums[i]%2!=0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2!=0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(i%2==0){\\n                if(nums[i]%2==0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2==0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else{\\n                if(nums[i]%2!=0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2!=0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490897,
                "title": "java-one-pass-inplace",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] n) {\\n        int e = 0,o = 1;\\n        while(e<n.length && o<n.length){\\n            while(e<n.length && n[e]%2 == 0) e += 2;\\n            while(o<n.length && n[o]%2 == 1) o += 2;\\n            \\n            if(o<n.length && e<n.length){\\n                int t = n[o];\\n                n[o] = n[e];\\n                n[e] = t;\\n                o += 2;\\n                e += 2;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] n) {\\n        int e = 0,o = 1;\\n        while(e<n.length && o<n.length){\\n            while(e<n.length && n[e]%2 == 0) e += 2;\\n            while(o<n.length && n[o]%2 == 1) o += 2;\\n            \\n            if(o<n.length && e<n.length){\\n                int t = n[o];\\n                n[o] = n[e];\\n                n[e] = t;\\n                o += 2;\\n                e += 2;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445385,
                "title": "simple-java-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int out[]=new int[nums.length];\\n        int evenIndex=0,oddIndex=1;\\n        for(int i:nums){\\n            if(i%2==1){\\n                out[oddIndex]=i;\\n                oddIndex+=2;\\n            }else{\\n                out[evenIndex]=i;\\n                evenIndex+=2;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int out[]=new int[nums.length];\\n        int evenIndex=0,oddIndex=1;\\n        for(int i:nums){\\n            if(i%2==1){\\n                out[oddIndex]=i;\\n                oddIndex+=2;\\n            }else{\\n                out[evenIndex]=i;\\n                evenIndex+=2;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345921,
                "title": "c-simple-solution",
                "content": "```\\nvector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>v1,v2;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]%2==0)\\n                v1.push_back(a[i]);\\n            else\\n                v2.push_back(a[i]);\\n        }\\n        vector<int>res(a.size());\\n        int k=0,j=0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(i%2==0)\\n                res[i]=v1[k++];\\n            else\\n                res[i]=v2[j++];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>v1,v2;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]%2==0)\\n                v1.push_back(a[i]);\\n            else\\n                v2.push_back(a[i]);\\n        }\\n        vector<int>res(a.size());\\n        int k=0,j=0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(i%2==0)\\n                res[i]=v1[k++];\\n            else\\n                res[i]=v2[j++];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291804,
                "title": "in-place-python-easy-100-faster-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        j = 1\\n        n = len(nums)\\n        while i < n and j < n:\\n            if nums[i]%2 == 0:\\n                i += 2\\n            elif nums[j]%2 != 0:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        j = 1\\n        n = len(nums)\\n        while i < n and j < n:\\n            if nums[i]%2 == 0:\\n                i += 2\\n            elif nums[j]%2 != 0:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206155,
                "title": "javascript-inplace-and-using-space-90-faster",
                "content": "**Please upvote if you find this solution useful**\\n\\n**In place**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n  let even = 0;\\n    let odd = nums.length - 1;\\n    while(even < nums.length && odd >= 0){\\n        \\n        if(nums[even] % 2==0 && nums[odd] % 2 !== 0){\\n            even = even + 2;\\n            odd = odd - 2\\n        }else if(nums[even] % 2 !== 0 && nums[odd] % 2 == 0){\\n            [ nums[even] , nums[odd] ] = [ nums[odd] , nums[even] ]\\n        }else if(nums[even] % 2 ==0 ){\\n            even = even+2;\\n        }else{\\n            odd = odd - 2;\\n        }\\n    }\\n    return nums\\n};\\n```\\n\\n\\n**Using space**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    var arr = new Array(nums.length);\\n    var even  =0;\\n    var odd = 1;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            arr[even] = nums[i];\\n            even +=2;\\n        }else{\\n            arr[odd] = nums[i]\\n            odd +=2\\n        }\\n    }\\n    return arr\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n  let even = 0;\\n    let odd = nums.length - 1;\\n    while(even < nums.length && odd >= 0){\\n        \\n        if(nums[even] % 2==0 && nums[odd] % 2 !== 0){\\n            even = even + 2;\\n            odd = odd - 2\\n        }else if(nums[even] % 2 !== 0 && nums[odd] % 2 == 0){\\n            [ nums[even] , nums[odd] ] = [ nums[odd] , nums[even] ]\\n        }else if(nums[even] % 2 ==0 ){\\n            even = even+2;\\n        }else{\\n            odd = odd - 2;\\n        }\\n    }\\n    return nums\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    var arr = new Array(nums.length);\\n    var even  =0;\\n    var odd = 1;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            arr[even] = nums[i];\\n            even +=2;\\n        }else{\\n            arr[odd] = nums[i]\\n            odd +=2\\n        }\\n    }\\n    return arr\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126788,
                "title": "javascript-clean-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    const [odds, evens] = [nums.filter(n => n%2===1), nums.filter(n => n%2 === 0)]\\n    const retArr = []\\n    for(let i = 0; i<nums.length; i++){\\n       i%2 ? retArr.push(odds.pop()) : retArr.push(evens.pop())\\n    }\\n    return retArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    const [odds, evens] = [nums.filter(n => n%2===1), nums.filter(n => n%2 === 0)]\\n    const retArr = []\\n    for(let i = 0; i<nums.length; i++){\\n       i%2 ? retArr.push(odds.pop()) : retArr.push(evens.pop())\\n    }\\n    return retArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095123,
                "title": "python-using-slicing",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        ans = [0] * N\\n        ans[::2] = (x for x in nums if x % 2 == 0)\\n        ans[1::2] = (x for x in nums if x % 2 == 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        ans = [0] * N\\n        ans[::2] = (x for x in nums if x % 2 == 0)\\n        ans[1::2] = (x for x in nums if x % 2 == 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050619,
                "title": "python-sorted-runtime-73-memory-78",
                "content": "Do upvote it if you liked it\\n\\n\\n\\n\\t\\tA = sorted(A)\\n        \\n\\t\\todd = []\\n        even = []\\n\\t\\t\\n        for num in A:\\n            if num % 2 == 0:\\n                even.append(num)\\n            else:\\n                odd.append(num)\\n                \\n        A[0 : : 2], A[1 : : 2]  = even, odd\\n        \\n        return A",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Do upvote it if you liked it\\n\\n\\n\\n\\t\\tA = sorted(A)\\n        \\n\\t\\todd = []\\n        even = []\\n\\t\\t\\n        for num in A:\\n            if num % 2 == 0:\\n                even.append(num)\\n            else:\\n                odd.append(num)\\n                \\n        A[0 : : 2], A[1 : : 2]  = even, odd\\n        \\n        return A",
                "codeTag": "Unknown"
            },
            {
                "id": 971488,
                "title": "javascript-solution",
                "content": "\\tvar sortArrayByParityII = function(A) {\\n    \\n    let odd = [];\\n    let even = []\\n    \\n    for(let i = 0 ; i < A.length; i++){\\n        \\n        if(A[i] % 2 !== 0){\\n            odd.push(A[i])\\n        }else{\\n            even.push(A[i])\\n        }\\n        \\n    }\\n    \\n    let arr = [];\\n    \\n    for(let i = 0 ; i < odd.length ; i++){\\n    \\n        arr.push(even[i]);\\n        arr.push(odd[i])\\n      \\n    }\\n\\n    \\n    return arr\\n    \\n    \\n\\t};",
                "solutionTags": [],
                "code": "\\tvar sortArrayByParityII = function(A) {\\n    \\n    let odd = [];\\n    let even = []\\n    \\n    for(let i = 0 ; i < A.length; i++){\\n        \\n        if(A[i] % 2 !== 0){\\n            odd.push(A[i])\\n        }else{\\n            even.push(A[i])\\n        }\\n        \\n    }\\n    \\n    let arr = [];\\n    \\n    for(let i = 0 ; i < odd.length ; i++){\\n    \\n        arr.push(even[i]);\\n        arr.push(odd[i])\\n      \\n    }\\n\\n    \\n    return arr\\n    \\n    \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 797027,
                "title": "c-easy-and-fast",
                "content": "**Please upvote my solution if you like it**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        int ec=0,oc=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]%2==0)\\n            {\\n                ans[ec]=A[i];\\n                ec+=2;\\n            }\\n            else\\n            {\\n                ans[oc]=A[i];\\n                oc+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        int ec=0,oc=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]%2==0)\\n            {\\n                ans[ec]=A[i];\\n                ec+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 764082,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize){\\n    *returnSize = ASize;\\n    int odd = 1;\\n    int even = 0;\\n    int* arr = malloc(sizeof(int)*ASize);\\n    for (int i=0; i < ASize; i++)\\n    {\\n        if (A[i] % 2 == 0)\\n        {\\n            arr[even] = A[i];\\n            even +=2;\\n        }\\n        else\\n        {\\n            arr[odd] = A[i];\\n            odd +=2;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize){\\n    *returnSize = ASize;\\n    int odd = 1;\\n    int even = 0;\\n    int* arr = malloc(sizeof(int)*ASize);\\n    for (int i=0; i < ASize; i++)\\n    {\\n        if (A[i] % 2 == 0)\\n        {\\n            arr[even] = A[i];\\n            even +=2;\\n        }\\n        else\\n        {\\n            arr[odd] = A[i];\\n            odd +=2;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755487,
                "title": "c-single-pass-inplace-o-n-97-runtime-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i=0;\\n    int j=1;\\n    while(i<A.size() && j<A.size()){\\n        if(A[i]%2!=0 && A[j]%2==0){\\n            swap(A[i],A[j]);\\n            i=i+2;\\n            j=j+2;\\n            continue;\\n        }\\n        if(A[i]%2==0){\\n            i=i+2;\\n        }\\n        if(A[j]%2==1){\\n            j=j+2;\\n        }\\n    }\\n        return A;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i=0;\\n    int j=1;\\n    while(i<A.size() && j<A.size()){\\n        if(A[i]%2!=0 && A[j]%2==0){\\n            swap(A[i],A[j]);\\n            i=i+2;\\n            j=j+2;\\n            continue;\\n        }\\n        if(A[i]%2==0){\\n            i=i+2;\\n        }\\n        if(A[j]%2==1){\\n            j=j+2;\\n        }\\n    }\\n        return A;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 727212,
                "title": "python-3-explanation",
                "content": "* Initialise an empty array `parityArray` of the same length as `A`.\\n* Keep track of two pointers, one `even` and one `odd`, that will be incremented when a new `num` is inserted into `parityArray`.\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        parityArray = [None] * len(A)\\n        even, odd = 0, 1\\n        \\n        for num in A:\\n            if num % 2 == 0:\\n                parityArray[even] = num\\n                even += 2\\n            else:\\n                parityArray[odd] = num\\n                odd += 2\\n            \\n        return parityArray\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        parityArray = [None] * len(A)\\n        even, odd = 0, 1\\n        \\n        for num in A:\\n            if num % 2 == 0:\\n                parityArray[even] = num\\n                even += 2\\n            else:\\n                parityArray[odd] = num\\n                odd += 2\\n            \\n        return parityArray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592182,
                "title": "python-3-faster-than-97-98",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        e = 0\\n        o = 1\\n        op = []\\n        for a in A:\\n            if a%2==0:\\n                op.insert(e,a)\\n                e+= 2\\n            else:\\n                op.insert(o,a)\\n                o+= 2\\n        return op\\n```\\nDo upvote it if you liked it :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        e = 0\\n        o = 1\\n        op = []\\n        for a in A:\\n            if a%2==0:\\n                op.insert(e,a)\\n                e+= 2\\n            else:\\n                op.insert(o,a)\\n                o+= 2\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576924,
                "title": "o-n-time-with-two-pointers-javascript",
                "content": "```\\nvar sortArrayByParityII = (A) => {\\n    let oddP = 1;\\n    \\n    const swap = (i, j) => {\\n        let buf = A[i];\\n        A[i] = A[j];\\n        A[j] = buf;\\n    }\\n    \\n    for (let i = 0 ; i < A.length; i += 2) {\\n        if (A[i] & 1) {\\n            while (A[oddP] & 1) {\\n                oddP += 2;\\n            }\\n            swap(i, oddP);\\n        }\\n    }\\n    \\n    return A;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortArrayByParityII = (A) => {\\n    let oddP = 1;\\n    \\n    const swap = (i, j) => {\\n        let buf = A[i];\\n        A[i] = A[j];\\n        A[j] = buf;\\n    }\\n    \\n    for (let i = 0 ; i < A.length; i += 2) {\\n        if (A[i] & 1) {\\n            while (A[oddP] & 1) {\\n                oddP += 2;\\n            }\\n            swap(i, oddP);\\n        }\\n    }\\n    \\n    return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520221,
                "title": "very-simple-in-place-c-solution-68ms-100",
                "content": "See also my copying solution here: https://leetcode.com/problems/sort-array-by-parity-ii/discuss/520235/C%2B%2B-Copy-out-to-odd-or-even-addresses-68ms100\\n# Algorithm\\n\\nThis is a very simple modify in-place approach.\\nThe overall flow is to step 2 index counters through the input array. One indexes odd locations and the other indexes even locations, so their paths interleave and never touch the same location.\\n* Advance even indexes by 2 until an odd value is hit\\n* Advance odd indexes by 2 until an even value is hit\\n* Swap the elements at these indexes to restore the desired state of even values at even indexes and odd values at odd indexes.\\n\\n# Code\\n```\\n        static vector<int> sortArrayByParityII(vector<int> A)\\n        {\\n            const unsigned len = A.size();\\n            unsigned odd = 1u;\\n            unsigned even = 0u;\\n            while(even < len)\\n            {\\n                // Skip even numbers at even indexes:\\n                while(even < len  && (A[even] & 1u) == 0u){\\n                    even += 2u;\\n                }\\n                // Skip odd numbers at odd indexes:\\n                while((odd < len) && (A[odd]  & 1u)){\\n                    odd += 2u;\\n                }\\n                // Either we hit the end of the input or an odd number at an even address\\n                // and an even number at an odd address. If the latter, swap them:\\n                if(even < len){\\n                    swap(A[even], A[odd]);\\n                }\\n                // We always increment so that as little code as possible is inside\\n                // the branch above even though logically the increment belongs inside\\n                // it:\\n                even += 2u;\\n                odd += 2u;\\n            }\\n            return A;\\n        }\\n```\\n\\n# Results\\n\\n> Runtime: 68 ms, faster than 100.00% of C++ online submissions for Sort Array By Parity II.\\n> Memory Usage: 12 MB, less than 25.00% of C++ online submissions for Sort Array By Parity II.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        static vector<int> sortArrayByParityII(vector<int> A)\\n        {\\n            const unsigned len = A.size();\\n            unsigned odd = 1u;\\n            unsigned even = 0u;\\n            while(even < len)\\n            {\\n                // Skip even numbers at even indexes:\\n                while(even < len  && (A[even] & 1u) == 0u){\\n                    even += 2u;\\n                }\\n                // Skip odd numbers at odd indexes:\\n                while((odd < len) && (A[odd]  & 1u)){\\n                    odd += 2u;\\n                }\\n                // Either we hit the end of the input or an odd number at an even address\\n                // and an even number at an odd address. If the latter, swap them:\\n                if(even < len){\\n                    swap(A[even], A[odd]);\\n                }\\n                // We always increment so that as little code as possible is inside\\n                // the branch above even though logically the increment belongs inside\\n                // it:\\n                even += 2u;\\n                odd += 2u;\\n            }\\n            return A;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515483,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i=0,j=0;\\n        while (i< A.size() && j < A.size()){\\n            while (i< A.size() ){\\n                if (i%2==0 && A[i]%2==1) break;\\n                else i++;\\n            } \\n            while (j< A.size()){\\n                if (j%2==1 && A[j]%2==0) break;\\n                else j++;\\n            }\\n            if (i<A.size() && j<A.size()){\\n                int temp = A[i];\\n                A[i] = A[j];\\n                A[j] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i=0,j=0;\\n        while (i< A.size() && j < A.size()){\\n            while (i< A.size() ){\\n                if (i%2==0 && A[i]%2==1) break;\\n                else i++;\\n            } \\n            while (j< A.size()){\\n                if (j%2==1 && A[j]%2==0) break;\\n                else j++;\\n            }\\n            if (i<A.size() && j<A.size()){\\n                int temp = A[i];\\n                A[i] = A[j];\\n                A[j] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475103,
                "title": "python-o-n-sol-based-on-two-pointers-run-time-95-with-explanation",
                "content": "Python O( n ) sol. based on two-pointers\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        \\n        size = len(A)\\n        \\n        sorted_array = [0]*size\\n        \\n        # two pointers for even numbers, as well as odd numbers, respectively.\\n        even_index, odd_index = 0, 1\\n        \\n        for x in A:\\n            \\n            if x & 1:\\n                # odd numbers\\n                sorted_array[odd_index] = x\\n                odd_index += 2\\n            else:\\n                # even numbers\\n                sorted_array[even_index] = x\\n                even_index += 2\\n                \\n        return sorted_array\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        \\n        size = len(A)\\n        \\n        sorted_array = [0]*size\\n        \\n        # two pointers for even numbers, as well as odd numbers, respectively.\\n        even_index, odd_index = 0, 1\\n        \\n        for x in A:\\n            \\n            if x & 1:\\n                # odd numbers\\n                sorted_array[odd_index] = x\\n                odd_index += 2\\n            else:\\n                # even numbers\\n                sorted_array[even_index] = x\\n                even_index += 2\\n                \\n        return sorted_array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459869,
                "title": "simplest-c-code",
                "content": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n\\tint oddIndex = 1, evenIndex = 0;\\n\\tvector<int> res(A.size());\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t{\\n\\t\\tif (A[i] % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tres[evenIndex] = A[i];\\n\\t\\t\\tevenIndex += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres[oddIndex] = A[i];\\n\\t\\t\\toddIndex += 2;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n\\tint oddIndex = 1, evenIndex = 0;\\n\\tvector<int> res(A.size());\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t{\\n\\t\\tif (A[i] % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tres[evenIndex] = A[i];\\n\\t\\t\\tevenIndex += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres[oddIndex] = A[i];\\n\\t\\t\\toddIndex += 2;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410428,
                "title": "python-3-o-n-time-and-o-n-space-using-stack",
                "content": "```\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        d = {0:[],1:[]}\\n        for i in A:\\n            d[i%2].append(i)\\n        r= []\\n        for _ in range(0,len(A)//2):\\n            r.append(d[0].pop())\\n            r.append(d[1].pop())\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        d = {0:[],1:[]}\\n        for i in A:\\n            d[i%2].append(i)\\n        r= []\\n        for _ in range(0,len(A)//2):\\n            r.append(d[0].pop())\\n            r.append(d[1].pop())\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383747,
                "title": "rust-8ms-o-n-time-o-1-space",
                "content": "```\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(a: Vec<i32>) -> Vec<i32> {\\n        let mut even_ptr = 0;\\n        let mut odd_ptr = 1;\\n        let size = a.len();\\n        let mut res = a.clone();\\n        \\n        while even_ptr < size && odd_ptr < size {\\n            if a[even_ptr] % 2 == 0 {\\n                even_ptr += 2;\\n            } else if a[odd_ptr] % 2 != 0 {\\n                odd_ptr += 2;\\n            } else {\\n                res[even_ptr] = a[odd_ptr];\\n                res[odd_ptr] = a[even_ptr];\\n                \\n                even_ptr += 2;\\n                odd_ptr += 2;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(a: Vec<i32>) -> Vec<i32> {\\n        let mut even_ptr = 0;\\n        let mut odd_ptr = 1;\\n        let size = a.len();\\n        let mut res = a.clone();\\n        \\n        while even_ptr < size && odd_ptr < size {\\n            if a[even_ptr] % 2 == 0 {\\n                even_ptr += 2;\\n            } else if a[odd_ptr] % 2 != 0 {\\n                odd_ptr += 2;\\n            } else {\\n                res[even_ptr] = a[odd_ptr];\\n                res[odd_ptr] = a[even_ptr];\\n                \\n                even_ptr += 2;\\n                odd_ptr += 2;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265141,
                "title": "java-beats-99-2ms-quick-sort",
                "content": "```\\npublic int[] sortArrayByParityII(int[] array) {\\n    int len = 0;\\n    if(array == null || ((len = array.length) & 1) == 1){\\n        return null;\\n    }\\n    int even = 0;\\n    int odd = len - 1;\\n    while(true){\\n        while(even < len && (array[even] & 1) == 0){\\n            even += 2;\\n        }\\n        if(even == len){\\n            break;\\n        }\\n        while(odd > -1 && (array[odd] & 1) == 1){\\n            odd -= 2;\\n        }\\n        if(odd == -1){\\n            break;\\n        }\\n        swap(array, even, odd);\\n    }\\n    return array;\\n}\\n private void swap(int[] array, int i, int j){\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] array) {\\n    int len = 0;\\n    if(array == null || ((len = array.length) & 1) == 1){\\n        return null;\\n    }\\n    int even = 0;\\n    int odd = len - 1;\\n    while(true){\\n        while(even < len && (array[even] & 1) == 0){\\n            even += 2;\\n        }\\n        if(even == len){\\n            break;\\n        }\\n        while(odd > -1 && (array[odd] & 1) == 1){\\n            odd -= 2;\\n        }\\n        if(odd == -1){\\n            break;\\n        }\\n        swap(array, even, odd);\\n    }\\n    return array;\\n}\\n private void swap(int[] array, int i, int j){\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255898,
                "title": "go-golang-o-n-in-place-beat-100",
                "content": "```\\nfunc sortArrayByParityII(A []int) []int {\\n\\tfor i, j := 0, 1; i< len(A); i+=2{\\n\\t\\tif A[i]&1 == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor ;A[j]&1 != 0; j += 2 {}\\n\\t\\tA[i], A[j] = A[j], A[i]\\n\\t}\\n\\treturn A\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortArrayByParityII(A []int) []int {\\n\\tfor i, j := 0, 1; i< len(A); i+=2{\\n\\t\\tif A[i]&1 == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor ;A[j]&1 != 0; j += 2 {}\\n\\t\\tA[i], A[j] = A[j], A[i]\\n\\t}\\n\\treturn A\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255048,
                "title": "python-two-pointer-922",
                "content": "### 922. Sort Array By Parity II\\n\\n#### Two Pointer\\nTime: O(N) | Space: O(1)\\n\\nOdd\\u6307\\u9488\\u7269\\u7406\\u610F\\u4E49\\uFF1A\\u505C\\u7559\\u5728A[odd] % 2 \\u662F\\u5076\\u6570\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7B49\\u5F85\\u4EA4\\u6362\\nEven\\u6307\\u9488\\u7269\\u7406\\u610F\\u4E49\\uFF1A\\u505C\\u7559\\u5728A[odd] % 2 \\u662F\\u57FA\\u6570\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7B49\\u5F85\\u4EA4\\u6362\\n\\n\\u5F53\\u5185\\u7F6E\\u4E24\\u4E2AWhile Loop\\u8D70\\u5B8C\\uFF0C\\u4E14\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6709\\u505C\\u7559\\uFF0C\\u8BF4\\u660E\\u4ED6\\u4EEC\\u5BF9\\u5E94\\u7684Value\\u53EF\\u4EE5\\u88AB\\u5151\\u6362\\uFF0CSwap\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        odd, even = 1 , 0\\n        size = len(A)\\n        \\n        while odd < size and even < size:\\n            while odd < size and A[odd] % 2 == 1: \\n                odd += 2\\n            while even < size and A[even] % 2 == 0: \\n                even += 2\\n            if odd < size and even < size:\\n                A[odd], A[even] = A[even], A[odd]\\n                odd += 2 ; even += 2  # Optional Line\\n        return A\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        odd, even = 1 , 0\\n        size = len(A)\\n        \\n        while odd < size and even < size:\\n            while odd < size and A[odd] % 2 == 1: \\n                odd += 2\\n            while even < size and A[even] % 2 == 0: \\n                even += 2\\n            if odd < size and even < size:\\n                A[odd], A[even] = A[even], A[odd]\\n                odd += 2 ; even += 2  # Optional Line\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247428,
                "title": "java-simple-solution-beats-100-4ms",
                "content": "I am using 2 pointers corresponding to the even and odd indices. \\n```\\npublic int[] sortArrayByParityII(int[] A) {\\n\\tif(A.length<2)\\n\\t\\treturn A;\\n\\tint oddPointer = 1, evenPointer = 0;\\n\\tint result[] = new int[A.length];\\n\\tfor(int i=0;i<A.length;i++)\\n\\t{\\n\\t\\tif(A[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tresult[evenPointer] = A[i];\\n\\t\\t\\tevenPointer+=2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tresult[oddPointer] = A[i];\\n\\t\\t\\toddPointer+=2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n\\tif(A.length<2)\\n\\t\\treturn A;\\n\\tint oddPointer = 1, evenPointer = 0;\\n\\tint result[] = new int[A.length];\\n\\tfor(int i=0;i<A.length;i++)\\n\\t{\\n\\t\\tif(A[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tresult[evenPointer] = A[i];\\n\\t\\t\\tevenPointer+=2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tresult[oddPointer] = A[i];\\n\\t\\t\\toddPointer+=2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230388,
                "title": "python-one-pass-in-place-two-pointers-o-n-time-o-1-memory",
                "content": "```python\\ndef sortArrayByParityII(self, A): \\n    odd, even, n = 1, 0, len(A)\\n    while odd < n and even < n:\\n        if A[odd] % 2 == 0 and A[even] % 2:\\n            A[odd], A[even] = A[even], A[odd]\\n        if A[odd] % 2 == 1: odd += 2\\n        if A[even] % 2 == 0: even += 2\\n    return A\\n```\\n\\nInspired by awice\\'s solution to Sort Array By Parity.",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\ndef sortArrayByParityII(self, A): \\n    odd, even, n = 1, 0, len(A)\\n    while odd < n and even < n:\\n        if A[odd] % 2 == 0 and A[even] % 2:\\n            A[odd], A[even] = A[even], A[odd]\\n        if A[odd] % 2 == 1: odd += 2\\n        if A[even] % 2 == 0: even += 2\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 209017,
                "title": "java-easy-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int[] result = new int[A.length];\\n        List<Integer> evens = new ArrayList<Integer>();\\n        List<Integer> odds = new ArrayList<Integer>();\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] % 2 == 0) {\\n                evens.add(A[i]);\\n            } else {\\n                odds.add(A[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < A.length; i += 2) {\\n            result[i] = evens.get(i / 2);\\n        }\\n        \\n        for(int i = 1; i < A.length; i += 2) {\\n            result[i] = odds.get(i / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int[] result = new int[A.length];\\n        List<Integer> evens = new ArrayList<Integer>();\\n        List<Integer> odds = new ArrayList<Integer>();\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] % 2 == 0) {\\n                evens.add(A[i]);\\n            } else {\\n                odds.add(A[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < A.length; i += 2) {\\n            result[i] = evens.get(i / 2);\\n        }\\n        \\n        for(int i = 1; i < A.length; i += 2) {\\n            result[i] = odds.get(i / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203920,
                "title": "java-5ms-99-09",
                "content": "```\\n int [] res = new int[A.length];\\n        int even = 0,odd = 1;\\n        for (int i = 0;i < A.length;i++) {\\n            if (A[i]%2==0){\\n                res[even]=A[i];\\n                even += 2;\\n            } else {\\n                res[odd]=A[i];\\n                odd += 2;\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n int [] res = new int[A.length];\\n        int even = 0,odd = 1;\\n        for (int i = 0;i < A.length;i++) {\\n            if (A[i]%2==0){\\n                res[even]=A[i];\\n                even += 2;\\n            } else {\\n                res[odd]=A[i];\\n                odd += 2;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 203083,
                "title": "ruby-beats-100",
                "content": "```\\n# @param {Integer[]} a\\n# @return {Integer[]}\\ndef sort_array_by_parity_ii(arr)\\n  e,o = 0,1\\n  newarr = []\\n  arr.each do |i| \\n    if i % 2 == 0\\n      newarr[e] = i\\n      e+=2\\n    else \\n      newarr[o] = i \\n      o += 2\\n    end\\n  end\\n  newarr  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {Integer[]}\\ndef sort_array_by_parity_ii(arr)\\n  e,o = 0,1\\n  newarr = []\\n  arr.each do |i| \\n    if i % 2 == 0\\n      newarr[e] = i\\n      e+=2\\n    else \\n      newarr[o] = i \\n      o += 2\\n    end\\n  end\\n  newarr  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 182806,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun sortArrayByParityII(A: IntArray): IntArray {\\n        val even = A.filter { it % 2 == 0 }\\n        val odd = A.filter { it % 2 == 1 }\\n        return even.zip(odd).flatMap { listOf(it.first, it.second) }.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun sortArrayByParityII(A: IntArray): IntArray {\\n        val even = A.filter { it % 2 == 0 }\\n        val odd = A.filter { it % 2 == 1 }\\n        return even.zip(odd).flatMap { listOf(it.first, it.second) }.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027701,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n     \\n       int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n        if(i%2==0 && nums[i]%2!=0)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==0)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                }\\n            }\\n        }\\n            \\n        if(i%2==1 && nums[i]%2!=1)\\n        {\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==1)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n     \\n       int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n        if(i%2==0 && nums[i]%2!=0)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==0)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3658073,
                "title": "java-0ms-runtime-99-faster-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }else{\\n                result[o] = i;\\n                o += 2;       \\n            } \\n        }\\n\\n        return result;\\n\\n    }\\n    // boolean odd(int n, int i){\\n    //     return n % 2 != 0 || i % 2 != 0;\\n    // }\\n    // boolean even(int n, int i){\\n    //     return n % 2 == 0 || i % 2 == 0;\\n    // }\\n    // int odd(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 != 0 && arr[i] % 2 != 0)\\n    //          return i;\\n\\n    //     return -1;\\n    // }\\n    // int even(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 == 0 && arr[i] % 2 == 0)\\n    //          return i;\\n             \\n    //     return -1;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }else{\\n                result[o] = i;\\n                o += 2;       \\n            } \\n        }\\n\\n        return result;\\n\\n    }\\n    // boolean odd(int n, int i){\\n    //     return n % 2 != 0 || i % 2 != 0;\\n    // }\\n    // boolean even(int n, int i){\\n    //     return n % 2 == 0 || i % 2 == 0;\\n    // }\\n    // int odd(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 != 0 && arr[i] % 2 != 0)\\n    //          return i;\\n\\n    //     return -1;\\n    // }\\n    // int even(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 == 0 && arr[i] % 2 == 0)\\n    //          return i;\\n             \\n    //     return -1;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531705,
                "title": "c-o-1-easy-approach",
                "content": "Here is my c++ code for thsi problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i=0, j=1;\\n        while(i<nums.size() && j<nums.size()){\\n            if(!(nums[i]&1)){i+=2;}\\n            else if(nums[j]&1){j+=2;}\\n            else{\\n                swap(nums[i], nums[j]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i=0, j=1;\\n        while(i<nums.size() && j<nums.size()){\\n            if(!(nums[i]&1)){i+=2;}\\n            else if(nums[j]&1){j+=2;}\\n            else{\\n                swap(nums[i], nums[j]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354227,
                "title": "simple-c-code-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0) \\n            {\\n                v.push_back(even[k]);\\n                k++;\\n            }\\n            else\\n            {\\n                v.push_back(odd[l]);\\n                l++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0) \\n            {\\n                v.push_back(even[k]);\\n                k++;\\n            }\\n            else\\n            {\\n                v.push_back(odd[l]);\\n                l++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334621,
                "title": "c-2-pointer-approch-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n       int i=0,j=nums.size()-1;\\n       while(i<nums.size()) \\n       {\\n           while(i<nums.size()&&nums[i]%2==0)\\n           {\\n            i+=2;\\n           }\\n           if(i==nums.size())\\n           break;\\n           while(j>=0&&nums[j]%2==1)\\n           {\\n            j-=2;\\n           }\\n           swap(nums[i],nums[j]);\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n       int i=0,j=nums.size()-1;\\n       while(i<nums.size()) \\n       {\\n           while(i<nums.size()&&nums[i]%2==0)\\n           {\\n            i+=2;\\n           }\\n           if(i==nums.size())\\n           break;\\n           while(j>=0&&nums[j]%2==1)\\n           {\\n            j-=2;\\n           }\\n           swap(nums[i],nums[j]);\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324326,
                "title": "sort-array-by-parity-ii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int i, j=0, k=1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[j] = nums[i];\\n                j += 2;\\n            }\\n            else\\n            {\\n                ans[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int i, j=0, k=1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[j] = nums[i];\\n                j += 2;\\n            }\\n            else\\n            {\\n                ans[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166647,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n            \\n        }\\n        \\n       int j=nums.size()-2;\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                swap(nums[i],nums[j]);\\n                j-=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n            \\n        }\\n        \\n       int j=nums.size()-2;\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                swap(nums[i],nums[j]);\\n                j-=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158910,
                "title": "parity-done-easily",
                "content": "i hope you like the solution,if any doubt feel free to comment :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>odd;\\n        vector<int>even;\\n        int e=0,o=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            even.push_back(nums[i]);\\n            else\\n            odd.push_back(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            {\\n                nums[i]=even[e];\\n                e++;\\n            }\\n            else if(i%2!=0)\\n            {\\n                nums[i]=odd[o];\\n                o++;\\n            }\\n\\n        }\\n        \\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>odd;\\n        vector<int>even;\\n        int e=0,o=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            even.push_back(nums[i]);\\n            else\\n            odd.push_back(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            {\\n                nums[i]=even[e];\\n                e++;\\n            }\\n            else if(i%2!=0)\\n            {\\n                nums[i]=odd[o];\\n                o++;\\n            }\\n\\n        }\\n        \\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944868,
                "title": "beats-99-92-11ms-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size(),i,ev=0,od=1;\\n        vector<int> result(n,1);\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                result[ev]=nums[i];\\n                ev=ev+2;\\n            }\\n            else{\\n                result[od]=nums[i];\\n                od=od+2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size(),i,ev=0,od=1;\\n        vector<int> result(n,1);\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                result[ev]=nums[i];\\n                ev=ev+2;\\n            }\\n            else{\\n                result[od]=nums[i];\\n                od=od+2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657326,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                a.append(nums[i])\\n            else:\\n                b.append(nums[i])\\n        j=0\\n        for i in range(0,len(nums),2):\\n            nums[i]=a[j]\\n            nums[i+1]=b[j]\\n            j+=1\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                a.append(nums[i])\\n            else:\\n                b.append(nums[i])\\n        j=0\\n        for i in range(0,len(nums),2):\\n            nums[i]=a[j]\\n            nums[i+1]=b[j]\\n            j+=1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636042,
                "title": "two-pointers-one-for-left-and-one-for-right-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int l = 0;\\n        int r = n-1;\\n        int sa, sb;\\n        sa = sb = -1;\\n        while(l<n && r>=0)\\n        {\\n            while(l<n && r>=0 && (l%2 ==0 && a[l]%2 == 0) || l%2)\\n            {\\n                l++;  \\n            }\\n            \\n            if(l<n && r>=0 && (l%2 ==0 && a[l]%2 != 0))\\n            {\\n                sa = l;\\n            }\\n            \\n            \\n            while(l<n && r>=0 && (r%2 && a[r]%2) || r%2==0)\\n            {\\n                r--;\\n            }\\n            if(l<n && r>=0 && (r%2 && a[r]%2 == 0))\\n            {\\n                sb = r;\\n            }\\n            \\n            if(sa >=0 && sa < n && sb>=0 && sb< n)\\n            {\\n                swap(a[sa] , a[sb]);\\n                sa = sb = -1;\\n                l++;\\n                r--;\\n            }    \\n            \\n        }\\n        \\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int l = 0;\\n        int r = n-1;\\n        int sa, sb;\\n        sa = sb = -1;\\n        while(l<n && r>=0)\\n        {\\n            while(l<n && r>=0 && (l%2 ==0 && a[l]%2 == 0) || l%2)\\n            {\\n                l++;  \\n            }\\n            \\n            if(l<n && r>=0 && (l%2 ==0 && a[l]%2 != 0))\\n            {\\n                sa = l;\\n            }\\n            \\n            \\n            while(l<n && r>=0 && (r%2 && a[r]%2) || r%2==0)\\n            {\\n                r--;\\n            }\\n            if(l<n && r>=0 && (r%2 && a[r]%2 == 0))\\n            {\\n                sb = r;\\n            }\\n            \\n            if(sa >=0 && sa < n && sb>=0 && sb< n)\\n            {\\n                swap(a[sa] , a[sb]);\\n                sa = sb = -1;\\n                l++;\\n                r--;\\n            }    \\n            \\n        }\\n        \\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618009,
                "title": "two-pointers-217-ms",
                "content": "![image](https://assets.leetcode.com/users/images/193c8f75-84fc-4083-932f-a0e85e9ddf5d_1664021649.5232708.png)\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        even = 0\\n        odd = 1\\n        while (odd < n or even <n):\\n            while odd < n and nums[odd] % 2:\\n                odd += 2\\n            while even < n and not nums[even] % 2:\\n                even += 2\\n            if even < n and odd < n:\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        even = 0\\n        odd = 1\\n        while (odd < n or even <n):\\n            while odd < n and nums[odd] % 2:\\n                odd += 2\\n            while even < n and not nums[even] % 2:\\n                even += 2\\n            if even < n and odd < n:\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609225,
                "title": "c-two-clean-in-place-approaches-with-explanation",
                "content": "**1st Approach: Two Pointers**\\nThe idea behind the first approach is to to use two pointers starting from 0 and 1 respectively.\\n1. If the value in the even pointer is even then no need to swap, just increment it by 2.\\n2. Same applies for the odd value and pointer.\\n3. If those conditions aren\\'t true, then swap the values to set them in the correct position.\\n\\n**Complexity Analysis**\\nTime Complexity: `O(n)` where `n` is the size of the array.\\nSpace Complexity: `O(1)`.\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n    int i = 0, j = 1, n = nums.size();\\n    while(i < n && j < n) {\\n        if(nums[i] % 2 == 0)\\n            i += 2;\\n        else if(nums[j] % 2 != 0)\\n            j += 2;\\n        else {\\n            swap(nums[i], nums[j]);\\n            i += 2;\\n            j += 2;\\n        }\\n    }\\n    return nums;\\n}\\n```\\n\\n**2nd Approach: Partitioning and Sorting**\\nThis key of this approach is to split the array into two sorted parts. The preprocessed array should look like the following <kbd>a = {e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n/2</sub>, o<sub>1</sub>, o<sub>2</sub>, ..., o<sub>n/2</sub>}</kbd>.\\n1. Partition the array with even numbers.\\n2. Sort the array in-place based on the partitioning iterator.\\n3. Now, the array is split into even then odd numbers respectively.\\n4. Only swap the values to their corresponding position.\\n\\n**Complexity Analysis**\\nTime Complexity: `O(n)` where `n` is the size of the array.\\nSpace Complexity: `O(1)`.\\n\\n```\\nvoid sortByParity(vector<int>& nums) {\\n    auto itr = partition(nums.begin(), nums.end(), [](const int val) {\\n        return val % 2 == 0;\\n    });\\n    sort(itr, nums.end());\\n}\\n\\nvector<int> sortArrayByParityII_2(vector<int>& nums) {\\n    sortByParity(nums);\\n    int i = 1, j = nums.size() / 2;\\n    while(i < j && j < nums.size()) {\\n        swap(nums[i], nums[j]);\\n        i += 2;\\n        ++j;\\n    }\\n    return nums;\\n}\\n```\\n\\n**Please upvote if you found this helpful.**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n    int i = 0, j = 1, n = nums.size();\\n    while(i < n && j < n) {\\n        if(nums[i] % 2 == 0)\\n            i += 2;\\n        else if(nums[j] % 2 != 0)\\n            j += 2;\\n        else {\\n            swap(nums[i], nums[j]);\\n            i += 2;\\n            j += 2;\\n        }\\n    }\\n    return nums;\\n}\\n```\n```\\nvoid sortByParity(vector<int>& nums) {\\n    auto itr = partition(nums.begin(), nums.end(), [](const int val) {\\n        return val % 2 == 0;\\n    });\\n    sort(itr, nums.end());\\n}\\n\\nvector<int> sortArrayByParityII_2(vector<int>& nums) {\\n    sortByParity(nums);\\n    int i = 1, j = nums.size() / 2;\\n    while(i < j && j < nums.size()) {\\n        swap(nums[i], nums[j]);\\n        i += 2;\\n        ++j;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594685,
                "title": "python-solution-runtime-263-ms-memory-usage-16-7-mb",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        arr = [0] * len(nums)\\n        even, odd = 0,  1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                arr[even] = num\\n                even += 2\\n            else:\\n                arr[odd] = num\\n                odd += 2\\n        \\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        arr = [0] * len(nums)\\n        even, odd = 0,  1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                arr[even] = num\\n                even += 2\\n            else:\\n                arr[odd] = num\\n                odd += 2\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586921,
                "title": "easy-python-solution",
                "content": "**Please upvote \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        odd = [x for x in nums if x%2!=0]\\n        even = [x for x in nums if x%2==0]\\n        \\n        nums = []\\n        for x,y in zip(odd,even):\\n            nums.append(y)\\n            nums.append(x)\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        odd = [x for x in nums if x%2!=0]\\n        even = [x for x in nums if x%2==0]\\n        \\n        nums = []\\n        for x,y in zip(odd,even):\\n            nums.append(y)\\n            nums.append(x)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578925,
                "title": "js-simple-solution-o-n",
                "content": "```\\nvar sortArrayByParityII = function(nums) {\\n    const output = new Array(nums.length);\\n    let cursorOdd = 1;\\n    let cursorEven = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i]%2) {\\n            output[cursorOdd] = nums[i];\\n            cursorOdd+=2;\\n        } else {\\n            output[cursorEven] = nums[i];\\n            cursorEven+=2;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(nums) {\\n    const output = new Array(nums.length);\\n    let cursorOdd = 1;\\n    let cursorEven = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i]%2) {\\n            output[cursorOdd] = nums[i];\\n            cursorOdd+=2;\\n        } else {\\n            output[cursorEven] = nums[i];\\n            cursorEven+=2;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512918,
                "title": "c-cool-ans",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int j = 1;\\n        int n = nums.size();\\n        for(int i = 0; i < n ; i+=2){// even\\n            if(nums[i] % 2 != 0){\\n                while(nums[i] % 2 != 0){\\n                    swap(nums[i] , nums[j]);\\n                    j+=2;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int j = 1;\\n        int n = nums.size();\\n        for(int i = 0; i < n ; i+=2){// even\\n            if(nums[i] % 2 != 0){\\n                while(nums[i] % 2 != 0){\\n                    swap(nums[i] , nums[j]);\\n                    j+=2;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1860513,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 2038925,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 2035838,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 1937791,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 1700145,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rank Transform of an Array",
        "question_content": "<p>Given an array of integers&nbsp;<code>arr</code>, replace each element with its rank.</p>\n\n<p>The rank represents how large the element is. The rank has the following rules:</p>\n\n<ul>\n\t<li>Rank is an integer starting from 1.</li>\n\t<li>The larger the element, the larger the rank. If two elements are equal, their rank must be the same.</li>\n\t<li>Rank should be as small as possible.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [40,10,20,30]\n<strong>Output:</strong> [4,1,2,3]\n<strong>Explanation</strong>: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [100,100,100]\n<strong>Output:</strong> [1,1,1]\n<strong>Explanation</strong>: Same elements share the same rank.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [37,12,28,9,100,56,80,5,12]\n<strong>Output:</strong> [5,3,4,2,8,6,7,1,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 489753,
                "title": "java-c-python-hashmap",
                "content": "# **Explanation**\\nCopy `arr` into `A` and sort it.\\nIterate sorted array `A` and record the rank for each element in hashmap `rank`.\\nIterate `arr` again, and assign `rank[arr[i]]` to `A[i]`.\\nreturn the final result `A`.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**Java**\\nSuggested by @hiepit and @saftageorge \\n```java\\n   public int[] arrayRankTransform(int[] arr) {\\n        int[] A = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(A);\\n        HashMap<Integer, Integer> rank = new HashMap<>();\\n        for (int x : A)\\n          rank.putIfAbsent(x, rank.size() + 1);\\n        for (int i = 0; i < arr.length; ++i)\\n          A[i] = rank.get(arr[i]);\\n        return A;\\n    }\\n```\\n**C++**\\n```cpp\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A(arr);\\n        sort(A.begin(), A.end());\\n        unordered_map<int, int> rank;\\n        for (int& a : A)\\n            rank.emplace(a, rank.size() + 1);\\n        for (int i = 0; i < A.size(); ++i)\\n            A[i] = rank[arr[i]];\\n        return A;\\n    }\\n```\\n**Python:**\\n```python\\n    def arrayRankTransform(self, A):\\n        rank = {}\\n        for a in sorted(A):\\n            rank.setdefault(a, len(rank) + 1)\\n        return map(rank.get, A)\\n```\\n\\n**1-line Python**\\n```py\\n    def arrayRankTransform(self, A):\\n        return map({a: i + 1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```",
                "solutionTags": [],
                "code": "```java\\n   public int[] arrayRankTransform(int[] arr) {\\n        int[] A = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(A);\\n        HashMap<Integer, Integer> rank = new HashMap<>();\\n        for (int x : A)\\n          rank.putIfAbsent(x, rank.size() + 1);\\n        for (int i = 0; i < arr.length; ++i)\\n          A[i] = rank.get(arr[i]);\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A(arr);\\n        sort(A.begin(), A.end());\\n        unordered_map<int, int> rank;\\n        for (int& a : A)\\n            rank.emplace(a, rank.size() + 1);\\n        for (int i = 0; i < A.size(); ++i)\\n            A[i] = rank[arr[i]];\\n        return A;\\n    }\\n```\n```python\\n    def arrayRankTransform(self, A):\\n        rank = {}\\n        for a in sorted(A):\\n            rank.setdefault(a, len(rank) + 1)\\n        return map(rank.get, A)\\n```\n```py\\n    def arrayRankTransform(self, A):\\n        return map({a: i + 1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490843,
                "title": "simple-java-solution",
                "content": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : arr) {\\n            set.add(i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for (int num : set) {\\n            map.put(num, rank++);\\n        }\\n        int[] ranks = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            ranks[i] = map.get(arr[i]);\\n        }\\n        return ranks;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i : arr) {\\n            set.add(i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for (int num : set) {\\n            map.put(num, rank++);\\n        }\\n        int[] ranks = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            ranks[i] = map.get(arr[i]);\\n        }\\n        return ranks;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489824,
                "title": "python-set-sorted-dict-and-scipy",
                "content": "Remove duplicates with `set`, then sort, then build a dict mapping values to ranks, then use that dict on the given list.\\n\\nTime: `O(n log n)`\\nSpace: `O(n)`\\n\\n```\\ndef arrayRankTransform(self, A):\\n    return map({a: i+1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```\\nor\\n```\\ndef arrayRankTransform(self, A):\\n    return map(dict(zip(sorted(set(A)), itertools.count(1))).get, A)\\n```\\nSciPy solution (don\\'t know the complexities, the [&rarr;doc](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rankdata.html) doesn\\'t say):\\n```\\nfrom scipy.stats import rankdata\\n\\nclass Solution(object):\\n    def arrayRankTransform(self, A):\\n        return rankdata(A, \\'dense\\')\\n```",
                "solutionTags": [],
                "code": "```\\ndef arrayRankTransform(self, A):\\n    return map({a: i+1 for i, a in enumerate(sorted(set(A)))}.get, A)\\n```\n```\\ndef arrayRankTransform(self, A):\\n    return map(dict(zip(sorted(set(A)), itertools.count(1))).get, A)\\n```\n```\\nfrom scipy.stats import rankdata\\n\\nclass Solution(object):\\n    def arrayRankTransform(self, A):\\n        return rankdata(A, \\'dense\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826051,
                "title": "c-set-map",
                "content": "**C++:**\\n```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n\\tset<int> st(arr.begin(),arr.end());\\n\\tunordered_map<int,int> m;\\n\\tint rank=1;\\n\\tfor(auto &i: st)  m[i]=rank++;\\n\\tfor(auto &i: arr) i = m[i];\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n\\tset<int> st(arr.begin(),arr.end());\\n\\tunordered_map<int,int> m;\\n\\tint rank=1;\\n\\tfor(auto &i: st)  m[i]=rank++;\\n\\tfor(auto &i: arr) i = m[i];\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489702,
                "title": "java-treemap-sorting",
                "content": "```\\n  public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        int rank = 1;\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> currentList = entry.getValue();\\n            for(int i: currentList)  arr[i] = rank;\\n            rank++;\\n        }\\n        return arr;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n  public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        int rank = 1;\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> currentList = entry.getValue();\\n            for(int i: currentList)  arr[i] = rank;\\n            rank++;\\n        }\\n        return arr;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 771861,
                "title": "python3-solution",
                "content": "\\t\\tarr_copy=arr.copy()\\n        arr_copy.sort()\\n        d={}\\n        a=[]\\n        rank=1\\n        \\n        for i in arr_copy:\\n            if i not in d:\\n                d[i]=rank\\n                rank+=1\\n            \\n        for i in arr:\\n            a.append(d[i])\\n        \\n        return a",
                "solutionTags": [],
                "code": "\\t\\tarr_copy=arr.copy()\\n        arr_copy.sort()\\n        d={}\\n        a=[]\\n        rank=1\\n        \\n        for i in arr_copy:\\n            if i not in d:\\n                d[i]=rank\\n                rank+=1\\n            \\n        for i in arr:\\n            a.append(d[i])\\n        \\n        return a",
                "codeTag": "Unknown"
            },
            {
                "id": 742765,
                "title": "javascript-es6-two-simple-2-line-solutions",
                "content": "```\\nvar arrayRankTransform = function (arr) {\\n  var sorted = Array.from(new Set(arr)).sort((a, b) => a - b);\\n  return arr.map((x) => sorted.indexOf(x) + 1);\\n};\\n```\\nThe solution below is faster:\\n```\\nvar arrayRankTransform = function (arr) {\\n var map = new Map();\\n [...new Set(arr)].sort((a, b) => a - b).map((x, i) => map.set(x, i + 1));\\n return arr.map((x) => map.get(x));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function (arr) {\\n  var sorted = Array.from(new Set(arr)).sort((a, b) => a - b);\\n  return arr.map((x) => sorted.indexOf(x) + 1);\\n};\\n```\n```\\nvar arrayRankTransform = function (arr) {\\n var map = new Map();\\n [...new Set(arr)].sort((a, b) => a - b).map((x, i) => map.set(x, i + 1));\\n return arr.map((x) => map.get(x));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493035,
                "title": "python-sol-based-on-sorting-and-dict-95-with-explanation",
                "content": "Python sol. based on sorting and dict\\n\\n---\\n\\nExample explanation\\n\\n---\\nExample_#1\\n\\ninput = [40,10,20,30]\\n\\nunique elements with ascending order = [ **10**, **20**, **30**, **40**]\\n\\nnumber-rank-dict = { 10 : **1**, 20 : **2**, 30 : **3**, 40 : **4** }\\n\\noutput = [ **4**, **1**, **2**, **3** ] by looking up number-rank-dict \\n\\n---\\nExample_#2\\n\\ninput = [100,100,100]\\n\\nunique elements with ascending order = [ **100** ]\\n\\nnumber-rank-dict = { 100 : **1** }\\n\\noutput = [ **1**, **1**, **1** ] by looking up number-rank-dict \\n\\n---\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # keep unique elements of array in ascending order\\n        elements_ascending = sorted(set(arr))\\n        \\n        # dictionary\\n        # key   : number\\n        # value : rank\\n        num_rank_dict = dict()\\n        \\n\\n        for index, num in enumerate(elements_ascending):\\n            \\n            # rank = index + 1\\n            num_rank_dict[num] = (index+1)\\n                \\n        \\n        # give each number with its corresponding rank\\n        result = [ num_rank_dict[num] for num in arr ]\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # keep unique elements of array in ascending order\\n        elements_ascending = sorted(set(arr))\\n        \\n        # dictionary\\n        # key   : number\\n        # value : rank\\n        num_rank_dict = dict()\\n        \\n\\n        for index, num in enumerate(elements_ascending):\\n            \\n            # rank = index + 1\\n            num_rank_dict[num] = (index+1)\\n                \\n        \\n        # give each number with its corresponding rank\\n        result = [ num_rank_dict[num] for num in arr ]\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552384,
                "title": "java-hashmap-array-sorting-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int[] array=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(array);\\n        int k=1;\\n        for(int i=0;i<array.length;i++){\\n            if(!map.containsKey(array[i]))\\n                map.put(array[i],k++);\\n        }\\n        int[] result=new int[array.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(arr[i]);\\n        return result;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int[] array=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(array);\\n        int k=1;\\n        for(int i=0;i<array.length;i++){\\n            if(!map.containsKey(array[i]))\\n                map.put(array[i],k++);\\n        }\\n        int[] result=new int[array.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(arr[i]);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390913,
                "title": "c-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> copy = arr;\\n        sort(copy.begin(), copy.end());\\n        int rank = 1;\\n        \\n        unordered_map<int, int> ranks;\\n        for (auto num : copy) \\n            if (ranks.find(num) == ranks.end()) ranks[num] = rank++;\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n            arr[i] = ranks[arr[i]];\\n        \\n        return arr;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> copy = arr;\\n        sort(copy.begin(), copy.end());\\n        int rank = 1;\\n        \\n        unordered_map<int, int> ranks;\\n        for (auto num : copy) \\n            if (ranks.find(num) == ranks.end()) ranks[num] = rank++;\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n            arr[i] = ranks[arr[i]];\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099391,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        Arrays.sort(temp);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0;i<temp.length;i++)\\n            map.putIfAbsent(temp[i],map.size()+1);\\n        \\n        for (int i=0;i<temp.length;i++)\\n            temp[i] = map.get(arr[i]);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        Arrays.sort(temp);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0;i<temp.length;i++)\\n            map.putIfAbsent(temp[i],map.size()+1);\\n        \\n        for (int i=0;i<temp.length;i++)\\n            temp[i] = map.get(arr[i]);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489733,
                "title": "clean-python-3-two-lines",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {ele: i + 1 for i, ele in enumerate(sorted(set(arr)))}\\n        return list(map(rank.get, arr))\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {ele: i + 1 for i, ele in enumerate(sorted(set(arr)))}\\n        return list(map(rank.get, arr))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489707,
                "title": "easy-solution-java-detailed-explanation",
                "content": "**Approach :** \\nCreate another array which has `\"value\":\"index\"` mapping. Sort it by value.\\n\\nNow iterate through this and keep assigning the rank. If the new value is same as previous one then rank doesn\\'t change, else increase rank by 1.\\n\\n**Example :**\\n\\nGiven array : [20, 30, 20, 50]\\nTransformed : [[20, 0], [20, 2], [30, 1], [50,3]]\\nrank for ->\\n\\n* \\tfirst 20 : 1, update index 0 for res\\n* \\tsecond 20 : 1, since it is same as prev, update index 2 for res\\n* \\tfirst 30 : 2, since it is different from 20, update index 1 for res\\n* \\tfirst 50 : 3, since it is different from 30, update index 3 for res\\n\\t\\n```\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] res = new int[arr.length];\\n        List<int[]> temp = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            temp.add(new int[]{arr[i], i}); // store : [value, index]\\n        }\\n        Collections.sort(temp, (a, b) -> a[0] - b[0]);\\n        int rank = 1;\\n        for (int i = 0; i < temp.size(); i++) {\\n            int idx = temp.get(i)[1];\\n            if (i == 0 || temp.get(i)[0] == temp.get(i - 1)[0]) {\\n                res[idx] = rank;\\n            } else {\\n                res[idx] = ++rank;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] res = new int[arr.length];\\n        List<int[]> temp = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            temp.add(new int[]{arr[i], i}); // store : [value, index]\\n        }\\n        Collections.sort(temp, (a, b) -> a[0] - b[0]);\\n        int rank = 1;\\n        for (int i = 0; i < temp.size(); i++) {\\n            int idx = temp.get(i)[1];\\n            if (i == 0 || temp.get(i)[0] == temp.get(i - 1)[0]) {\\n                res[idx] = rank;\\n            } else {\\n                res[idx] = ++rank;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677596,
                "title": "3-simple-c-solution",
                "content": "# **Using Set and Map :-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        set <int> s;\\n        for(int i=0;i<arr.size();i++)\\n            s.insert(arr[i]);          // making set that contains unique element in sorted order\\n        int rank = 1;\\n        for(auto &i : s)\\n            mp[i] = rank,++rank;       // assinging rank to unique elements \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\\n\\n# **Using Map & Sorting :-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        vector <int> temp = arr;\\n        int rank = 1; \\n        // sorting the array\\n        sort(temp.begin(),temp.end()); \\n        // deleting repeated element\\n        vector<int>::iterator it;\\n        it = unique(temp.begin(), temp.end());\\n        temp.resize(distance(temp.begin(), it));\\n        //assinging rank\\n        for(int i=0;i<temp.size();i++)\\n            mp[temp[i]] = rank,++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\\n\\n# **Using Map :-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        for(auto &it: arr)\\n            mp[it] = 0;\\n        int rank = 0;\\n        for(auto &it: mp)\\n            mp[it.first] = ++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        set <int> s;\\n        for(int i=0;i<arr.size();i++)\\n            s.insert(arr[i]);          // making set that contains unique element in sorted order\\n        int rank = 1;\\n        for(auto &i : s)\\n            mp[i] = rank,++rank;       // assinging rank to unique elements \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        vector <int> temp = arr;\\n        int rank = 1; \\n        // sorting the array\\n        sort(temp.begin(),temp.end()); \\n        // deleting repeated element\\n        vector<int>::iterator it;\\n        it = unique(temp.begin(), temp.end());\\n        temp.resize(distance(temp.begin(), it));\\n        //assinging rank\\n        for(int i=0;i<temp.size();i++)\\n            mp[temp[i]] = rank,++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map <int, int> mp;\\n        for(auto &it: arr)\\n            mp[it] = 0;\\n        int rank = 0;\\n        for(auto &it: mp)\\n            mp[it.first] = ++rank;\\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493972,
                "title": "javascript-hash-easy-solution-with-explanation",
                "content": "**APPROACH**:\\nSince we need to replace each element with its rank, we need to find the smallest element and assigned it to the smallest rank. The easiest way to accomplish this is by sorting the input array in ascending order and then associating it with a rank. The rank initial value = 1, then we need to check if the element does not exist in our dictionary then add it to the dictionary and increase the rank by 1. \\n\\n\\nPSEUDO CODE:\\n    1. Make a copy of the array and sort it\\n    2. Assign ranks using a dictionary of key-value pairs,  ```arrayVal: index```\\n    3. transform the original array into ranks and return the result\\n\\nTime Complexity:  O(N log N)\\nSpace Complexity: O(N)\\n\\nAny feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nvar arrayRankTransform = function(ar) {\\n    if(ar.length == 0) return ar;\\n    \\n\\t/*  clone array & sort it   */\\n    let sortedAr = ar.slice().sort((a,b) => a - b);\\n    let res = [];\\n    let dic = {};\\n    \\n\\t/*  assign ranks        */\\n    let rank = 1;\\n    for(let i = 0; i < sortedAr.length; i++) {\\n        if(!dic[sortedAr[i]]) {\\n            dic[sortedAr[i]] = rank;\\n            rank++;\\n        }\\n    }\\n    \\n\\t/*  rank transform of an array  */\\n    for(let j = 0; j < ar.length; j++) {\\n        let rankVal = dic[ar[j]];\\n        res.push(rankVal)\\n    }\\n    return res; \\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```arrayVal: index```\n```\\nvar arrayRankTransform = function(ar) {\\n    if(ar.length == 0) return ar;\\n    \\n\\t/*  clone array & sort it   */\\n    let sortedAr = ar.slice().sort((a,b) => a - b);\\n    let res = [];\\n    let dic = {};\\n    \\n\\t/*  assign ranks        */\\n    let rank = 1;\\n    for(let i = 0; i < sortedAr.length; i++) {\\n        if(!dic[sortedAr[i]]) {\\n            dic[sortedAr[i]] = rank;\\n            rank++;\\n        }\\n    }\\n    \\n\\t/*  rank transform of an array  */\\n    for(let j = 0; j < ar.length; j++) {\\n        let rankVal = dic[ar[j]];\\n        res.push(rankVal)\\n    }\\n    return res; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493602,
                "title": "java-solution-treemap-or-treeset",
                "content": "Use TreeMap\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for(int x: arr) map.put(x, 1);\\n        \\n        int rank = 1;\\n        for(int key: map.keySet()) map.put(key, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nUse TreeSet\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Set<Integer> set = new TreeSet<>();\\n        for(int x: arr) set.add(x);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for(int x: set) map.put(x, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for(int x: arr) map.put(x, 1);\\n        \\n        int rank = 1;\\n        for(int key: map.keySet()) map.put(key, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Set<Integer> set = new TreeSet<>();\\n        for(int x: arr) set.add(x);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank = 1;\\n        for(int x: set) map.put(x, rank++);\\n        \\n        int[] res = new int[arr.length];\\n        for(int i = 0; i< res.length; i++){\\n            res[i] = map.get(arr[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655612,
                "title": "java-super-easy-solution-with-comments-using-hashmap-and-sorting-works-faster",
                "content": "```\\n//Please upvote my answer if you like it \\nimport java.util.*;\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n=arr.length;\\n        int dummy[]=new int[n];\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i=0;i<n;i++) dummy[i]=arr[i];   //filling arr elements in dummy array so that we can\\'t lost our original array\\n        \\n        Arrays.sort(dummy);       //sorting the dummy array\\n       \\n        for(int i:dummy){\\n            if(!map.containsKey(i)){ //if map don\\'t contain that element then map it with it\\'s rank\\n                map.put(i,rank);\\n                rank++;\\n            } \\n            else map.put(i,map.get(i));    //if it contains that element then the rank should be that of the same element\\n        }\\n        \\n        for(int i=0;i<n;i++){    //putting the ranks from the map into array\\n            arr[i]=map.get(arr[i]);\\n        }\\n        \\n        return arr;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n=arr.length;\\n        int dummy[]=new int[n];\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i=0;i<n;i++) dummy[i]=arr[i];   //filling arr elements in dummy array so that we can\\'t lost our original array\\n        \\n        Arrays.sort(dummy);       //sorting the dummy array\\n       \\n        for(int i:dummy){\\n            if(!map.containsKey(i)){ //if map don\\'t contain that element then map it with it\\'s rank\\n                map.put(i,rank);\\n                rank++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3545754,
                "title": "hashmap-solution-easy-java",
                "content": "# Approach\\nThe given code implements a method `arrayRankTransform` that takes an integer array `arr` as input and returns a new array where each element is replaced with its rank in the sorted array. The rank represents the position of the element when the array is sorted in ascending order.\\n\\nHere\\'s the approach taken by the code:\\n\\n1. Create a copy of the input array `arr` called `rankedArray` using the `clone()` method.\\n2. Create a `LinkedHashMap` called `map` to store the elements of the array as keys and their ranks as values.\\n3. Sort the array `arr` using `Arrays.sort(arr)` to get the elements in ascending order.\\n4. Initialize a variable `rank` to 1 to keep track of the current rank.\\n5. If the length of the array is 0, return the empty array.\\n6. Initialize a variable `prev` to store the previous element in the array. Set it as the first element of the sorted array `arr[0]`.\\n7. Iterate through each element `num` in the sorted array `arr`.\\n   - If the current element `num` is different from the previous element `prev`, increment the `rank` by 1.\\n   - Put the element `num` in the map `map` if it doesn\\'t already exist, along with its corresponding `rank`.\\n   - Update the `prev` variable to the current element `num`.\\n8. Iterate through each element in the `rankedArray`.\\n   - Replace the element with its corresponding rank from the map using `map.get(rankedArray[i])`.\\n9. Return the `rankedArray`.\\n\\nOverall, the code creates a sorted map of element-rank pairs by iterating through the sorted array and assigning ranks based on the element\\'s uniqueness. Finally, it replaces the elements in the original array with their corresponding ranks from the map.\\n\\n# Complexity\\n- Time complexity:\\n    - The overall time complexity of the code is O(n log n), dominated by the sorting operation.\\n- Space complexity:\\n    - The overall space complexity of the code is O(n), where n is the length of the array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] rankedArray = arr.clone();\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        Arrays.sort(arr);\\n        int rank = 1;\\n        if(arr.length==0) return arr;\\n        int prev = arr[0];\\n        \\n        for (int num : arr) {\\n            if (prev != num) {\\n                rank++;\\n            }\\n            map.putIfAbsent(num, rank);\\n            prev = num;\\n        }\\n        \\n        for (int i = 0; i < rankedArray.length; i++) {\\n            rankedArray[i] = map.get(rankedArray[i]);\\n        }\\n        \\n        return rankedArray;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] rankedArray = arr.clone();\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        Arrays.sort(arr);\\n        int rank = 1;\\n        if(arr.length==0) return arr;\\n        int prev = arr[0];\\n        \\n        for (int num : arr) {\\n            if (prev != num) {\\n                rank++;\\n            }\\n            map.putIfAbsent(num, rank);\\n            prev = num;\\n        }\\n        \\n        for (int i = 0; i < rankedArray.length; i++) {\\n            rankedArray[i] = map.get(rankedArray[i]);\\n        }\\n        \\n        return rankedArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439696,
                "title": "o-nlogn-beginner-friendly-approach-c",
                "content": "- Approach\\n          Firstly, I declare one map which stores elements and in second loop I declare one cnt variable which starts from 1. after first loop elements stored in map is in sorted order so now I start second loop which is iterate inside map and cnt starts from 0 and second part of map is assigned to cnt variable and after each iteration increase cnt variable.\\n          Now I iterate one simple for loop in which I push back all those second part of map of arr vector(m[arr[i]]).\\n          Then I simply return that vector\\n\\n# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        int cnt=1;\\n        for(auto i : arr)\\n        {\\n            m[i]++;\\n        }\\n        for(auto i : m)\\n        {\\n            m[i.first] = cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ans.push_back(m[arr[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/59bd3797-91ef-445c-874d-752003be760c_1682046832.1349757.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        int cnt=1;\\n        for(auto i : arr)\\n        {\\n            m[i]++;\\n        }\\n        for(auto i : m)\\n        {\\n            m[i.first] = cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ans.push_back(m[arr[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469684,
                "title": "easy-java-solution-hashmap-beginner-friendly-best-method",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = arr[i];\\n        }\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int j = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],j++);\\n            }\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = map.get(arr[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = arr[i];\\n        }\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int j = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],j++);\\n            }\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            nums[i] = map.get(arr[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491041,
                "title": "java-o-n-memory-o-n-log-n-time",
                "content": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        if (arr.length == 0) {\\n            return arr;\\n        }\\n        if (arr.length == 1) {\\n            arr[0] = 1;\\n            return arr;\\n        }\\n        int[] copyArr = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(copyArr);\\n        Map<Integer, Integer> elementToRank = new HashMap<>();\\n        for (int i = 0, rank = 1, prevElem = -1; i < copyArr.length; i++) {\\n            int curElem = copyArr[i];\\n            if (i != 0 && curElem != prevElem) {\\n                rank++;\\n            }\\n            elementToRank.putIfAbsent(copyArr[i], rank);\\n            prevElem = curElem;\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = elementToRank.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n        if (arr.length == 0) {\\n            return arr;\\n        }\\n        if (arr.length == 1) {\\n            arr[0] = 1;\\n            return arr;\\n        }\\n        int[] copyArr = Arrays.copyOf(arr, arr.length);\\n        Arrays.sort(copyArr);\\n        Map<Integer, Integer> elementToRank = new HashMap<>();\\n        for (int i = 0, rank = 1, prevElem = -1; i < copyArr.length; i++) {\\n            int curElem = copyArr[i];\\n            if (i != 0 && curElem != prevElem) {\\n                rank++;\\n            }\\n            elementToRank.putIfAbsent(copyArr[i], rank);\\n            prevElem = curElem;\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = elementToRank.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2250295,
                "title": "c-solution-hashmap-easy-to-understand",
                "content": "```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>dup=arr;\\n        int count=1;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            if(mp[arr[i]]==0){\\n                mp[arr[i]]=count;\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            dup[i]=mp[dup[i]];\\n        }\\n        return dup;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>dup=arr;\\n        int count=1;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            if(mp[arr[i]]==0){\\n                mp[arr[i]]=count;\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            dup[i]=mp[dup[i]];\\n        }\\n        return dup;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879202,
                "title": "java-easy-hashmap",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr){\\n        int[] val=arr.clone();\\n        Arrays.sort(val);\\n        Map<Integer,Integer>mpp=new HashMap<Integer,Integer>();\\n        for(int a: val) mpp.putIfAbsent(a,mpp.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=mpp.get(arr[i]);\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr){\\n        int[] val=arr.clone();\\n        Arrays.sort(val);\\n        Map<Integer,Integer>mpp=new HashMap<Integer,Integer>();\\n        for(int a: val) mpp.putIfAbsent(a,mpp.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=mpp.get(arr[i]);\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310705,
                "title": "c-using-sorting-vector-of-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if (arr.size() == 0) {\\n            return {};\\n        }\\n        if (arr.size() == 1) {\\n            return {1};\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for (int i = 0; i < arr.size(); i++) {\\n            v.push_back({arr[i], i});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        int rank = 1;\\n        int prev = v[0].first;\\n        v[0].first = rank;\\n        \\n        for (int i = 1; i < v.size(); i++) {\\n            if (v[i].first == prev) {\\n                prev = v[i].first;\\n                v[i].first = rank;\\n            }\\n            else {\\n                prev = v[i].first;\\n                v[i].first = ++rank;\\n            }\\n        }\\n        \\n        vector<int> res(arr.size(), 0);\\n        for (int i = 0; i < v.size(); i++) {\\n            res[v[i].second] = v[i].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if (arr.size() == 0) {\\n            return {};\\n        }\\n        if (arr.size() == 1) {\\n            return {1};\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for (int i = 0; i < arr.size(); i++) {\\n            v.push_back({arr[i], i});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        int rank = 1;\\n        int prev = v[0].first;\\n        v[0].first = rank;\\n        \\n        for (int i = 1; i < v.size(); i++) {\\n            if (v[i].first == prev) {\\n                prev = v[i].first;\\n                v[i].first = rank;\\n            }\\n            else {\\n                prev = v[i].first;\\n                v[i].first = ++rank;\\n            }\\n        }\\n        \\n        vector<int> res(arr.size(), 0);\\n        for (int i = 0; i < v.size(); i++) {\\n            res[v[i].second] = v[i].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285683,
                "title": "c-set-unorderd-map-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int>s(arr.begin(),arr.end()); //set to remove duplicate values\\n        unordered_map<int,int>m; // map to place rank and value\\n        vector<int>out;//output vector\\n        \\n        for(auto val:s)\\n        {\\n            //since we are giving sorted values thus... map size+1 would be the rank of next input\\n            m[val]=m.size()+1;\\n        }\\n        for(auto val:arr)\\n        {\\n            //now we took the value for the given number from map and put it into output vector\\n            out.push_back(m[val]);\\n        }\\n        return out;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int>s(arr.begin(),arr.end()); //set to remove duplicate values\\n        unordered_map<int,int>m; // map to place rank and value\\n        vector<int>out;//output vector\\n        \\n        for(auto val:s)\\n        {\\n            //since we are giving sorted values thus... map size+1 would be the rank of next input\\n            m[val]=m.size()+1;\\n        }\\n        for(auto val:arr)\\n        {\\n            //now we took the value for the given number from map and put it into output vector\\n            out.push_back(m[val]);\\n        }\\n        return out;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277703,
                "title": "python-solution-faster-then-95-71-solution",
                "content": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        l,f = dict(),list(sorted(set(arr)))\\n        for i in range(len(f)):\\n            l[f[i]]=i+1 \\n        return [l[i] for i in arr] \\n```",
                "solutionTags": [],
                "code": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        l,f = dict(),list(sorted(set(arr)))\\n        for i in range(len(f)):\\n            l[f[i]]=i+1 \\n        return [l[i] for i in arr] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1072516,
                "title": "c-solution-using-unordered-map-faster-than-85-80-of-other-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> v;\\n        unordered_map<int,int> mp;\\n        v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        mp[v[0]]=1;\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]!=v[i-1]){\\n                rank++;\\n            }\\n            mp[v[i]]=rank;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> v;\\n        unordered_map<int,int> mp;\\n        v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        mp[v[0]]=1;\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]!=v[i-1]){\\n                rank++;\\n            }\\n            mp[v[i]]=rank;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523376,
                "title": "javascript-2-line-solution",
                "content": "Runtime: 228 ms, faster than 98.85% of JavaScript online submissions\\nMemory Usage: 66.7 MB, less than 100.00% of JavaScript online submissions\\n\\n```\\nconst arrayRankTransform = arr => {\\n  const ranks = [...new Set(arr)]\\n    .sort((a, b) => a - b)\\n    .reduce((acc, curr, idx) => acc.set(curr, idx + 1), new Map());\\n  return arr.map(n => ranks.get(n));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst arrayRankTransform = arr => {\\n  const ranks = [...new Set(arr)]\\n    .sort((a, b) => a - b)\\n    .reduce((acc, curr, idx) => acc.set(curr, idx + 1), new Map());\\n  return arr.map(n => ranks.get(n));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3240108,
                "title": "python3-beats-84-44",
                "content": "# Please upvote if you find the solution helpful.\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        d = {}\\n        f_lst=[]\\n        arr1 = sorted(list(set(arr)))\\n        for i in range(len(arr1)):\\n            d[arr1[i]] = i+1\\n        for i in arr:\\n            f_lst.append(d[i])\\n        return f_lst\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        d = {}\\n        f_lst=[]\\n        arr1 = sorted(list(set(arr)))\\n        for i in range(len(arr1)):\\n            d[arr1[i]] = i+1\\n        for i in arr:\\n            f_lst.append(d[i])\\n        return f_lst\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940937,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& vec) {\\n        vector<int> arr=vec;\\n        if(vec.size()==1)return{1};\\n        if(vec.size()==0)return vec;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        int r=1;\\n        mp[arr[0]]=1;\\n        \\n\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]!=arr[i-1]){\\n                mp[arr[i]]=++r;\\n                \\n            }\\n            else{\\n                mp[arr[i]]=r;\\n                \\n            }\\n            \\n        }\\n        for(int i=0;i<vec.size();i++){\\n            vec[i]=mp[vec[i]];\\n        }\\n    return vec;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& vec) {\\n        vector<int> arr=vec;\\n        if(vec.size()==1)return{1};\\n        if(vec.size()==0)return vec;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int> mp;\\n        int r=1;\\n        mp[arr[0]]=1;\\n        \\n\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]!=arr[i-1]){\\n                mp[arr[i]]=++r;\\n                \\n            }\\n            else{\\n                mp[arr[i]]=r;\\n                \\n            }\\n            \\n        }\\n        for(int i=0;i<vec.size();i++){\\n            vec[i]=mp[vec[i]];\\n        }\\n    return vec;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823902,
                "title": "easy-python-solution-beats-95-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        #print(rank)\\n        return [rank[i] for i in arr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        #print(rank)\\n        return [rank[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614234,
                "title": "easy-code-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        //can be decoded as key and value where key is the array elem and value is it\\'s rank\\n        vector<int>temp;\\n        temp=arr;\\n        sort(temp.begin(),temp.end());\\n        map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            if(mp.find(temp[i])==mp.end())\\n            {\\n            mp[temp[i]]=rank;//storing the rank of the number\\n                rank++;\\n             }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ans.push_back(mp[arr[i]]);//value of the key \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        //can be decoded as key and value where key is the array elem and value is it\\'s rank\\n        vector<int>temp;\\n        temp=arr;\\n        sort(temp.begin(),temp.end());\\n        map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            if(mp.find(temp[i])==mp.end())\\n            {\\n            mp[temp[i]]=rank;//storing the rank of the number\\n                rank++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2450341,
                "title": "fast-short-easy-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        int[] copySort = arr.clone();\\n        Arrays.sort(copySort);\\n\\n        int index = 1;\\n        for(int i : copySort)\\n            if (map.putIfAbsent(i, index) == null)\\n                index++;\\n\\n        for(int i=0; i<arr.length; i++)\\n            arr[i]=map.get(arr[i]);\\n\\n        return arr;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421511,
                "title": "python-elegant-short-two-lines-hashmap-sorting",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*log(n))\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}\\n\\t\\t\\treturn [ranks[num] for num in arr]\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "class Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*log(n))\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\t\\t\\tranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}",
                "codeTag": "Java"
            },
            {
                "id": 1931825,
                "title": "python-solutions-one-liner-set-sorted-enumerate-simple-and-clean",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {}\\n        for rank, num in enumerate(sorted(set(arr))):\\n            ranks[num] = rank+1\\n        return [ranks[num] for num in arr]\\n```\\n\\n**Solution - Dictionary Comprehension**:\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {num:rank+1 for rank, num in enumerate(sorted(set(arr)))}\\n        return [ranks[num] for num in arr]\\n```\\n\\n**Solution - One-Liner**:\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        return map({n:r+1 for r,n in enumerate(sorted(set(arr)))}.get, arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {}\\n        for rank, num in enumerate(sorted(set(arr))):\\n            ranks[num] = rank+1\\n        return [ranks[num] for num in arr]\\n```\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        ranks = {num:rank+1 for rank, num in enumerate(sorted(set(arr)))}\\n        return [ranks[num] for num in arr]\\n```\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr):\\n        return map({n:r+1 for r,n in enumerate(sorted(set(arr)))}.get, arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561105,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        vector<int>nums=arr;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(nums[i])==0)\\n              mp[nums[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        vector<int>nums=arr;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        int rank=1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(nums[i])==0)\\n              mp[nums[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481836,
                "title": "python-two-lines-solutions-beats-99-75",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:       \\n        ref = {k: v+1 for v, k in enumerate(sorted(set(arr)))}\\n        return [ref[i] for i in arr]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:       \\n        ref = {k: v+1 for v, k in enumerate(sorted(set(arr)))}\\n        return [ref[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191799,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        uniques = sorted(set(arr))\\n        dct = {number: rank for rank, number in enumerate(uniques, start=1)}\\n        \\n        return [dct[num] for num in arr]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        uniques = sorted(set(arr))\\n        dct = {number: rank for rank, number in enumerate(uniques, start=1)}\\n        \\n        return [dct[num] for num in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054163,
                "title": "java-easy-6-lines-beats-85-time-and-80-space",
                "content": "```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] gd=arr.clone();\\n        Arrays.sort(gd);\\n        Map<Integer,Integer> sr=new HashMap<>();\\n        for(int i=0;i<gd.length;i++){\\n            sr.putIfAbsent(gd[i],sr.size()+1);\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=sr.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] gd=arr.clone();\\n        Arrays.sort(gd);\\n        Map<Integer,Integer> sr=new HashMap<>();\\n        for(int i=0;i<gd.length;i++){\\n            sr.putIfAbsent(gd[i],sr.size()+1);\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=sr.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039492,
                "title": "min-heap-python-t-o-nlogn-s-o-n",
                "content": "My min heap solution in python. Basically we add every element and it\\'s index to heap, then one by one we extract it and add ranks at remembered index. If two adjacent elements are the same, rank will not increase.\\n\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        heap = [(x, i) for i, x in enumerate(arr)]\\n        heapify(heap)\\n        rank = 0\\n        last = inf\\n        \\n        while heap:\\n            val, idx = heappop(heap)\\n            if val != last:\\n                last = val\\n                rank += 1\\n            arr[idx] = rank\\n        return arr\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "My min heap solution in python. Basically we add every element and it\\'s index to heap, then one by one we extract it and add ranks at remembered index. If two adjacent elements are the same, rank will not increase.\\n\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        heap = [(x, i) for i, x in enumerate(arr)]\\n        heapify(heap)\\n        rank = 0\\n        last = inf\\n        \\n        while heap:\\n            val, idx = heappop(heap)\\n            if val != last:\\n                last = val\\n                rank += 1\\n            arr[idx] = rank\\n        return arr\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1002019,
                "title": "sortedset-c",
                "content": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\n            int[] aRank = new int[arr.Length];\\n\\n            Dictionary<int, int> map = new SortedSet<int>(arr)\\n               .Select((num, i) => (num, i))\\n               .ToDictionary(k => k.num, v => v.i + 1); \\n\\n            for (int i = 0; i < arr.Length; i++) {\\n                aRank[i] =map[arr[i]];                \\n            }      \\n            return aRank;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\n            int[] aRank = new int[arr.Length];\\n\\n            Dictionary<int, int> map = new SortedSet<int>(arr)\\n               .Select((num, i) => (num, i))\\n               .ToDictionary(k => k.num, v => v.i + 1); \\n\\n            for (int i = 0; i < arr.Length; i++) {\\n                aRank[i] =map[arr[i]];                \\n            }      \\n            return aRank;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582248,
                "title": "javascript-easy-solution-98-100",
                "content": "var arrayRankTransform = function(arr) {\\n\\n\\tvar unre = Array.from(new Set(arr)).sort((a,b) => a - b);\\n\\tvar obj = new Map();\\n\\n\\tfor (var i = 0; i < unre.length ; i++) {\\n\\t\\tobj.set(unre[i],i+1);\\n\\t}\\n\\t\\n\\tarr = arr.map(item => item=obj.get(item));\\n    \\n    return arr;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var arrayRankTransform = function(arr) {\\n\\n\\tvar unre = Array.from(new Set(arr)).sort((a,b) => a - b);\\n\\tvar obj = new Map();\\n\\n\\tfor (var i = 0; i < unre.length ; i++) {\\n\\t\\tobj.set(unre[i],i+1);\\n\\t}\\n\\t\\n\\tarr = arr.map(item => item=obj.get(item));\\n    \\n    return arr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 523582,
                "title": "c-beats-80-and-100-memory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector <int> aux = arr;\\n        sort(aux.begin(),aux.end());\\n        int i = 1;\\n        unordered_map <int,int> m;\\n        for(auto w : aux)\\n        {\\n            if(m.find(w) == m.end()) m[w] = i++;\\n        }\\n        i = 0;\\n        for(auto w : arr) aux[i++] = m[w];\\n        return aux;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector <int> aux = arr;\\n        sort(aux.begin(),aux.end());\\n        int i = 1;\\n        unordered_map <int,int> m;\\n        for(auto w : aux)\\n        {\\n            if(m.find(w) == m.end()) m[w] = i++;\\n        }\\n        i = 0;\\n        for(auto w : arr) aux[i++] = m[w];\\n        return aux;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522049,
                "title": "c-hashing-memory-efficient-100",
                "content": "```\\nMemory Usage: 31.2 MB, less than 100.00% of C++ online submissions for Rank Transform of an Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      set<int> arrSet(arr.begin(), arr.end());\\n      \\n      unordered_map<int, int> pos;\\n      int position = 1;\\n        \\n      for (auto num : arrSet){\\n          pos[num] = position;\\n          position++;\\n      }\\n      \\n      for (auto& num : arr){\\n          num = pos[num];\\n      }\\n        \\n      return arr;\\n    }\\n};\\n\\n//CODE BELOW FAILS FOR ONLY 1 TEST CASE\\n/*vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> arrSet(arr.begin(), arr.end());\\n        \\n        for(auto& num : arr){\\n            num = getIndex(arrSet, num);\\n        }\\n        \\n        return arr;\\n    }\\n    \\n    int getIndex(set<int> arrSet, int num){\\n        set<int>::iterator setIt = arrSet.begin();\\n\\n        for(int i = 0; i < arrSet.size(); i++){\\n            if(num == *setIt){\\n                return i + 1;\\n            }\\n            setIt++;\\n        }\\n        return 0;\\n    }\\n    */\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nMemory Usage: 31.2 MB, less than 100.00% of C++ online submissions for Rank Transform of an Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      set<int> arrSet(arr.begin(), arr.end());\\n      \\n      unordered_map<int, int> pos;\\n      int position = 1;\\n        \\n      for (auto num : arrSet){\\n          pos[num] = position;\\n          position++;\\n      }\\n      \\n      for (auto& num : arr){\\n          num = pos[num];\\n      }\\n        \\n      return arr;\\n    }\\n};\\n\\n//CODE BELOW FAILS FOR ONLY 1 TEST CASE\\n/*vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> arrSet(arr.begin(), arr.end());\\n        \\n        for(auto& num : arr){\\n            num = getIndex(arrSet, num);\\n        }\\n        \\n        return arr;\\n    }\\n    \\n    int getIndex(set<int> arrSet, int num){\\n        set<int>::iterator setIt = arrSet.begin();\\n\\n        for(int i = 0; i < arrSet.size(); i++){\\n            if(num == *setIt){\\n                return i + 1;\\n            }\\n            setIt++;\\n        }\\n        return 0;\\n    }\\n    */\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 493244,
                "title": "c-solution",
                "content": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\tvar dict = arr\\n\\t\\t.Distinct()\\n\\t\\t.OrderBy(x => x)\\n\\t\\t.Select((x, i) => (x, i))\\n\\t\\t.ToDictionary(x => x.x, x => x.i + 1);\\n\\n\\tfor (var i = 0; i < arr.Length; i++)\\n\\t\\tarr[i] = dict[arr[i]];\\n\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ArrayRankTransform(int[] arr) {\\n\\tvar dict = arr\\n\\t\\t.Distinct()\\n\\t\\t.OrderBy(x => x)\\n\\t\\t.Select((x, i) => (x, i))\\n\\t\\t.ToDictionary(x => x.x, x => x.i + 1);\\n\\n\\tfor (var i = 0; i < arr.Length; i++)\\n\\t\\tarr[i] = dict[arr[i]];\\n\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491455,
                "title": "priorityqueue",
                "content": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t// (value, index)\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(\\n\\t\\t\\t\\tnew Comparator<int[]>() {\\n\\n\\t\\t\\t\\t\\t@Override\\n\\t\\t\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tpq.add(new int[] { arr[i], i });\\n\\t\\t}\\n\\t\\tint rank = 1;\\n\\t\\tint[] res = new int[arr.length];\\n\\t\\tInteger prev = null;\\n\\t\\twhile (!pq.isEmpty()) {\\n\\t\\t\\tint[] element = pq.remove();\\n\\t\\t\\tif (prev == null || prev == element[0]) {\\n\\t\\t\\t\\tres[element[1]] = rank;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[element[1]] = ++rank;\\n\\t\\t\\t}\\n\\t\\t\\tprev = element[0];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t// (value, index)\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(\\n\\t\\t\\t\\tnew Comparator<int[]>() {\\n\\n\\t\\t\\t\\t\\t@Override\\n\\t\\t\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tpq.add(new int[] { arr[i], i });\\n\\t\\t}\\n\\t\\tint rank = 1;\\n\\t\\tint[] res = new int[arr.length];\\n\\t\\tInteger prev = null;\\n\\t\\twhile (!pq.isEmpty()) {\\n\\t\\t\\tint[] element = pq.remove();\\n\\t\\t\\tif (prev == null || prev == element[0]) {\\n\\t\\t\\t\\tres[element[1]] = rank;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[element[1]] = ++rank;\\n\\t\\t\\t}\\n\\t\\t\\tprev = element[0];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489706,
                "title": "java-sort-and-keep-track",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n = arr.length;\\n        int[] brr = new int[n];\\n        for(int i = 0; i < n; i++) brr[i] = arr[i];\\n        Arrays.sort(brr);\\n        int[] rank = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int val = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(brr[i])) {\\n                val++;\\n                map.put(brr[i], val);\\n            }\\n        }\\n        for(int i = 0; i < n; i++) rank[i] = map.get(arr[i]);\\n        return rank;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int n = arr.length;\\n        int[] brr = new int[n];\\n        for(int i = 0; i < n; i++) brr[i] = arr[i];\\n        Arrays.sort(brr);\\n        int[] rank = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int val = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(brr[i])) {\\n                val++;\\n                map.put(brr[i], val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3950970,
                "title": "c-easy-intution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain a set and then unordered map where we will keep the rank.\\n        set<int> array;\\n        for(auto &num : arr) array.insert(num);\\n        unordered_map<int, int> mp;\\n        int i = 1;\\n        for(auto itr = array.begin(); itr != array.end() ; itr++){ \\n            mp[*itr] = i++;\\n        }\\n        for(auto &num : arr) num = mp[num];\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain a set and then unordered map where we will keep the rank.\\n        set<int> array;\\n        for(auto &num : arr) array.insert(num);\\n        unordered_map<int, int> mp;\\n        int i = 1;\\n        for(auto itr = array.begin(); itr != array.end() ; itr++){ \\n            mp[*itr] = i++;\\n        }\\n        for(auto &num : arr) num = mp[num];\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520913,
                "title": "for-beginners-simple-java-solution",
                "content": "Solution using HashMap and sorting. \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int len = arr.length; \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n        \\n        int[] nums = new int[len]; \\n        \\n        // copy into new array nums \\n        for(int i=0; i<len; i++) {\\n            nums[i] = arr[i]; \\n        }\\n\\n        // sorting the new copy array \\n        Arrays.sort(nums); \\n\\n        // now putting this data into hashmap \\n        int rank=1; \\n        for(int i=0; i<len; i++) {\\n            if(! map.containsKey(nums[i])) { // if map does not contain key, then add it and increae the rank. \\n                map.put(nums[i], rank++); \\n            }\\n        } \\n\\n        for(int i=0; i<len; i++) {\\n            arr[i]=map.get(arr[i]); \\n        }\\n\\n        return arr; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int len = arr.length; \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n        \\n        int[] nums = new int[len]; \\n        \\n        // copy into new array nums \\n        for(int i=0; i<len; i++) {\\n            nums[i] = arr[i]; \\n        }\\n\\n        // sorting the new copy array \\n        Arrays.sort(nums); \\n\\n        // now putting this data into hashmap \\n        int rank=1; \\n        for(int i=0; i<len; i++) {\\n            if(! map.containsKey(nums[i])) { // if map does not contain key, then add it and increae the rank. \\n                map.put(nums[i], rank++); \\n            }\\n        } \\n\\n        for(int i=0; i<len; i++) {\\n            arr[i]=map.get(arr[i]); \\n        }\\n\\n        return arr; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399552,
                "title": "rank-transform-of-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int i, j, l, r, mid;\\n        vector<int> rank;\\n       \\n        unordered_set<int> set(arr.begin(), arr.end());\\n        vector<int> sorted_arr(set.begin(), set.end());\\n        sort(sorted_arr.begin(), sorted_arr.end());\\n\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            l=0, r=sorted_arr.size()-1;\\n            while(l<=r)\\n            {\\n                mid = (l+r)/2;\\n                if(sorted_arr[mid]==arr[i])\\n                {\\n                    rank.push_back(mid+1);\\n                    break;\\n                }\\n                else if(sorted_arr[mid]<arr[i])\\n                {\\n                    l = mid+1;\\n                }\\n                else\\n                {\\n                    r = mid-1;\\n                }\\n            }\\n        }\\n        return rank;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int i, j, l, r, mid;\\n        vector<int> rank;\\n       \\n        unordered_set<int> set(arr.begin(), arr.end());\\n        vector<int> sorted_arr(set.begin(), set.end());\\n        sort(sorted_arr.begin(), sorted_arr.end());\\n\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            l=0, r=sorted_arr.size()-1;\\n            while(l<=r)\\n            {\\n                mid = (l+r)/2;\\n                if(sorted_arr[mid]==arr[i])\\n                {\\n                    rank.push_back(mid+1);\\n                    break;\\n                }\\n                else if(sorted_arr[mid]<arr[i])\\n                {\\n                    l = mid+1;\\n                }\\n                else\\n                {\\n                    r = mid-1;\\n                }\\n            }\\n        }\\n        return rank;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309869,
                "title": "easiest-solution-you-ever-find-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        list1=[]\\n        x=sorted(set(arr))\\n        dict1={}\\n        for i in range(len(x)):\\n            dict1[x[i]]=i+1\\n        for j in arr:\\n            y=dict1[j]\\n            list1.append(y)\\n        return list1\\n    #please do upvote it will help alot to gain my love in coding\\n\\n```\\n# consider upvoting if found helpful![57jfh9.jpg](https://assets.leetcode.com/users/images/18e346ce-ffbb-46f1-995f-cfc301972ca0_1679115728.6807754.jpeg)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        list1=[]\\n        x=sorted(set(arr))\\n        dict1={}\\n        for i in range(len(x)):\\n            dict1[x[i]]=i+1\\n        for j in arr:\\n            y=dict1[j]\\n            list1.append(y)\\n        return list1\\n    #please do upvote it will help alot to gain my love in coding\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453766,
                "title": "98-tc-and-68-sc-easy-python-solution",
                "content": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\tc = 1\\n\\td = dict()\\n\\tfor i in sorted(list(set(arr))):\\n\\t\\td[i] = c\\n\\t\\tc += 1\\n\\tfor i in range(len(arr)):\\n\\t\\tarr[i] = d[arr[i]]\\n\\treturn arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n\\tc = 1\\n\\td = dict()\\n\\tfor i in sorted(list(set(arr))):\\n\\t\\td[i] = c\\n\\t\\tc += 1\\n\\tfor i in range(len(arr)):\\n\\t\\tarr[i] = d[arr[i]]\\n\\treturn arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2053787,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar arrayRankTransform = function(arr) {\\n    let keys = 0;\\n\\n    const ranks = [...arr].sort((a, b) => a - b).reduce((res, x) => {\\n        if (!res[x]) {\\n            res[x] = 1 + keys++;\\n        }\\n        \\n        return res;\\n    }, {});\\n    \\n    return arr.map(x => ranks[x]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n    let keys = 0;\\n\\n    const ranks = [...arr].sort((a, b) => a - b).reduce((res, x) => {\\n        if (!res[x]) {\\n            res[x] = 1 + keys++;\\n        }\\n        \\n        return res;\\n    }, {});\\n    \\n    return arr.map(x => ranks[x]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040619,
                "title": "26-ms-95-faster-simple-java-solution",
                "content": "java code is:\\n\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int copy[]=arr.clone();\\n        Arrays.sort(copy);\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int num : copy) if(!map.containsKey(num))map.put(num,map.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=map.get(arr[i]);\\n        return arr;\\n    }\\n## }\\n### ```\\n### Time : O(nlogn)\\n### Space : O(n) linear extra space\\n### Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int copy[]=arr.clone();\\n        Arrays.sort(copy);\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int num : copy) if(!map.containsKey(num))map.put(num,map.size()+1);\\n        for(int i=0;i<arr.length;i++) arr[i]=map.get(arr[i]);\\n        return arr;\\n    }\\n## }\\n### ```",
                "codeTag": "Java"
            },
            {
                "id": 1559482,
                "title": "python-simple-solution-using-hashmap-faster-than-83-32",
                "content": "\\n        a=sorted(list(set(arr)))\\n        rank=1\\n        b={}\\n        for i in a:\\n            b[i]=rank\\n            rank+=1\\n        c=[]    \\n        for i in arr:\\n            c.append(b[i])\\n        return c\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n        a=sorted(list(set(arr)))\\n        rank=1\\n        b={}\\n        for i in a:\\n            b[i]=rank\\n            rank+=1\\n        c=[]    \\n        for i in arr:\\n            c.append(b[i])\\n        return c\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1428174,
                "title": "c-easy-intuitive",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> s(arr.begin(),arr.end());\\n        int rank=1;\\n        unordered_map<int,int> mp;\\n        for(int x:s)\\n        {\\n            mp[x]=rank++;\\n        }   \\n        for(int &x:arr)\\n        {\\n            x=mp[x];    \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        set<int> s(arr.begin(),arr.end());\\n        int rank=1;\\n        unordered_map<int,int> mp;\\n        for(int x:s)\\n        {\\n            mp[x]=rank++;\\n        }   \\n        for(int &x:arr)\\n        {\\n            x=mp[x];    \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424926,
                "title": "c-easy-and-concise-map-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      map<int,int>mp;\\n      //Initializing rank of all unique elements to 0 in map\\n      for(int i=0;i<arr.size();i++) mp[arr[i]]=0;\\n      int rank=0;\\n      //Alotting rank to each unique array element\\n      for(auto i:mp) mp[i.first]=++rank;\\n      //Forming the output \\n      vector<int>result;\\n      for(int i:arr) result.push_back(mp[i]);\\n      return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n      map<int,int>mp;\\n      //Initializing rank of all unique elements to 0 in map\\n      for(int i=0;i<arr.size();i++) mp[arr[i]]=0;\\n      int rank=0;\\n      //Alotting rank to each unique array element\\n      for(auto i:mp) mp[i.first]=++rank;\\n      //Forming the output \\n      vector<int>result;\\n      for(int i:arr) result.push_back(mp[i]);\\n      return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1409701,
                "title": "c-how-i-write-improved-solutions-from-complex-ones",
                "content": "```\\n//Approach-1 (Little messed solution : Naive approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        int i = 0;\\n\\t\\t//I store indices of all elements\\n        for(const int &x : arr) mp[x].push_back(i++);\\n        \\n        sort(begin(arr), end(arr));\\n        vector<int> result(arr.size());\\n        \\n        int rank = 1;\\n\\t\\t//Just put rank starting from 1\\n        for(int i = 0; i<arr.size();) {\\n\\t\\t\\t//Fill same rank for same elements\\n            for(const int& idx : mp[arr[i]]) {\\n                result[idx] = rank;\\n                i++;\\n            }\\n            rank++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Simplified and better to understand approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A = arr;\\n        sort(begin(A), end(A));\\n        \\n        unordered_map<int, int> mp;\\n        for(const int &x : A) {\\n            if(!mp.count(x))\\n                mp[x] = mp.size()+1;\\n        }\\n        \\n        for(int &x : arr)\\n            x = mp[x];\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Little messed solution : Naive approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, vector<int>> mp;\\n        int i = 0;\\n\\t\\t//I store indices of all elements\\n        for(const int &x : arr) mp[x].push_back(i++);\\n        \\n        sort(begin(arr), end(arr));\\n        vector<int> result(arr.size());\\n        \\n        int rank = 1;\\n\\t\\t//Just put rank starting from 1\\n        for(int i = 0; i<arr.size();) {\\n\\t\\t\\t//Fill same rank for same elements\\n            for(const int& idx : mp[arr[i]]) {\\n                result[idx] = rank;\\n                i++;\\n            }\\n            rank++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Simplified and better to understand approach)\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> A = arr;\\n        sort(begin(A), end(A));\\n        \\n        unordered_map<int, int> mp;\\n        for(const int &x : A) {\\n            if(!mp.count(x))\\n                mp[x] = mp.size()+1;\\n        }\\n        \\n        for(int &x : arr)\\n            x = mp[x];\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391934,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        if(arr.length == 0 || arr == null) {\\n            return new int[]{};\\n        }\\n        \\n        int[] temp = arr.clone();\\n        \\n        Arrays.sort(temp);\\n        \\n        Map<Integer,Integer> map = new HashMap();\\n        \\n        for(int i = 0; i<temp.length; i++) {\\n            map.putIfAbsent(temp[i], map.size()+1);\\n        }\\n        \\n        \\n        for(int i = 0; i<arr.length; i++) {\\n            temp[i] = map.get(arr[i]);\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        if(arr.length == 0 || arr == null) {\\n            return new int[]{};\\n        }\\n        \\n        int[] temp = arr.clone();\\n        \\n        Arrays.sort(temp);\\n        \\n        Map<Integer,Integer> map = new HashMap();\\n        \\n        for(int i = 0; i<temp.length; i++) {\\n            map.putIfAbsent(temp[i], map.size()+1);\\n        }\\n        \\n        \\n        for(int i = 0; i<arr.length; i++) {\\n            temp[i] = map.get(arr[i]);\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355474,
                "title": "python3-simple-and-easy-understanding",
                "content": "\\n\\n        sorted_arr = sorted(set(arr))\\n        n = len(sorted_arr)\\n        indx = [i+1 for i in range(n)]\\n        mapping = dict(zip(sorted_arr,indx))\\n        ans = []\\n        for i in arr:\\n            ans.append(mapping[i])\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\n        sorted_arr = sorted(set(arr))\\n        n = len(sorted_arr)\\n        indx = [i+1 for i in range(n)]\\n        mapping = dict(zip(sorted_arr,indx))\\n        ans = []\\n        for i in arr:\\n            ans.append(mapping[i])\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 1286962,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] copy=new int[arr.length];\\n        copy=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(copy);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            if(!map.containsKey(copy[i]))\\n            {\\n                map.put(copy[i],rank++);\\n            }\\n        }\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            arr[i]=map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        int[] copy=new int[arr.length];\\n        copy=Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(copy);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int rank=1;\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            if(!map.containsKey(copy[i]))\\n            {\\n                map.put(copy[i],rank++);\\n            }\\n        }\\n        for(int i=0;i<copy.length;i++)\\n        {\\n            arr[i]=map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120131,
                "title": "js-easy-to-understand-for-beginners-as-well-beats-93-comments",
                "content": "```\\nvar arrayRankTransform = function (arr) {\\n  // map to store the rank of elements\\n  let m = new Map();\\n  // creating a sorted list with unique values\\n  let sorted = [...new Set([...arr].sort((a, b) => a - b))];\\n  for (let i = 0; i < sorted.length; i++) {\\n  // assigning ranks starting from 1. We removed duplicates because if we don\\'t then same numbers will have different ranks\\n    m.set(sorted[i], i + 1);\\n  }\\n  // retrieving the assigned ranks from the map and replacing in the original input array\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = m.get(arr[i]);\\n  }\\n  return arr;\\n};\\n```\\nRuntime: 192 ms, faster than 93.87% of JavaScript online submissions for Rank Transform of an Array.\\nMemory Usage: 56.5 MB, less than 86.79% of JavaScript online submissions for Rank Transform of an Array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function (arr) {\\n  // map to store the rank of elements\\n  let m = new Map();\\n  // creating a sorted list with unique values\\n  let sorted = [...new Set([...arr].sort((a, b) => a - b))];\\n  for (let i = 0; i < sorted.length; i++) {\\n  // assigning ranks starting from 1. We removed duplicates because if we don\\'t then same numbers will have different ranks\\n    m.set(sorted[i], i + 1);\\n  }\\n  // retrieving the assigned ranks from the map and replacing in the original input array\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = m.get(arr[i]);\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045634,
                "title": "my-python-solution",
                "content": "I\\'m sure its not the best solution, but its the best I could come up with. \\n\\nThe thought process is to sort the array then keep track of the previous number and running rank while iterating through the sorted array. If we get a number that isn\\'t the same as the previous number (new number) we assign it to the running rank in a dictionary--if we get a number that is the same as the previous (a duplicate), we do nothing at all.\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        rank = 1\\n        d = {}\\n        temp = \\'\\'\\n        for num in sorted(arr):\\n            if num == temp:\\n                continue\\n            else:\\n                d[num] = rank\\n                temp = num\\n                rank += 1\\n        return [d[i] for i in arr]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        rank = 1\\n        d = {}\\n        temp = \\'\\'\\n        for num in sorted(arr):\\n            if num == temp:\\n                continue\\n            else:\\n                d[num] = rank\\n                temp = num\\n                rank += 1\\n        return [d[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994639,
                "title": "python-use-dictionary-straightforward",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        cnt = {}\\n        rank = 1\\n        for k in sorted(list(set(arr))):\\n            cnt[k] = rank\\n            rank += 1\\n        return [cnt[x] for x in arr]",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        cnt = {}",
                "codeTag": "Java"
            },
            {
                "id": 935547,
                "title": "python-one-liner-using-hashmap-and-set",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {elem: rank + 1 for rank, elem in enumerate(sorted(set(arr)))}\\n        return [ranks[key] for key in arr]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {elem: rank + 1 for rank, elem in enumerate(sorted(set(arr)))}\\n        return [ranks[key] for key in arr]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 900636,
                "title": "easy-java-with-treeset-and-hashmap",
                "content": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        if(arr == null) {\\n            return null;\\n        }\\n        \\n        Set<Integer> set = new TreeSet<>();\\n        for(int i: arr) {\\n            set.add(i);\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();        \\n        int rank = 1; \\n        \\n        for(int i: set) {\\n            map.put(i, rank++);\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        if(arr == null) {\\n            return null;\\n        }\\n        \\n        Set<Integer> set = new TreeSet<>();\\n        for(int i: arr) {\\n            set.add(i);\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();        \\n        int rank = 1; \\n        \\n        for(int i: set) {\\n            map.put(i, rank++);\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 827558,
                "title": "c-solution-using-sorting-and-binary-search",
                "content": "```c\\nint cmp(const void* a, const void* b) {\\n  int* x = (int*)a;\\n  int* y = (int*)b;\\n\\n  return *x - *y;\\n}\\n\\nint search(int* a, int size, int v) {\\n  int l = 0, h = size;\\n  while (l < h) {\\n    int mid = l + (h - l) / 2;\\n    if (a[mid] == v) {\\n      return mid;\\n    } else if (a[mid] > v) {\\n      h = mid;\\n    } else {\\n      l = mid;\\n    }\\n  }\\n\\n  return -1;\\n}\\n\\nint* arrayRankTransform(int* arr, int arrSize, int* returnSize) {\\n  *returnSize = arrSize;\\n  int* result = malloc(sizeof(int) * arrSize);\\n  if (arrSize == 0)\\n    return result;\\n\\n  int values[arrSize], ranks[arrSize];\\n  memcpy(values, arr, sizeof(values));\\n  qsort(values, arrSize, sizeof(int), cmp);\\n\\n  ranks[0] = 1;\\n  for (int i = 1; i < arrSize; i++) {\\n    if (values[i] == values[i - 1]) {\\n      ranks[i] = ranks[i - 1];\\n    } else {\\n      ranks[i] = ranks[i - 1] + 1;\\n    }\\n  }\\n\\n  for (int i = 0; i < arrSize; i++) {\\n    int j = search(values, arrSize, arr[i]);\\n    result[i] = ranks[j];\\n  }\\n\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```c\\nint cmp(const void* a, const void* b) {\\n  int* x = (int*)a;\\n  int* y = (int*)b;\\n\\n  return *x - *y;\\n}\\n\\nint search(int* a, int size, int v) {\\n  int l = 0, h = size;\\n  while (l < h) {\\n    int mid = l + (h - l) / 2;\\n    if (a[mid] == v) {\\n      return mid;\\n    } else if (a[mid] > v) {\\n      h = mid;\\n    } else {\\n      l = mid;\\n    }\\n  }\\n\\n  return -1;\\n}\\n\\nint* arrayRankTransform(int* arr, int arrSize, int* returnSize) {\\n  *returnSize = arrSize;\\n  int* result = malloc(sizeof(int) * arrSize);\\n  if (arrSize == 0)\\n    return result;\\n\\n  int values[arrSize], ranks[arrSize];\\n  memcpy(values, arr, sizeof(values));\\n  qsort(values, arrSize, sizeof(int), cmp);\\n\\n  ranks[0] = 1;\\n  for (int i = 1; i < arrSize; i++) {\\n    if (values[i] == values[i - 1]) {\\n      ranks[i] = ranks[i - 1];\\n    } else {\\n      ranks[i] = ranks[i - 1] + 1;\\n    }\\n  }\\n\\n  for (int i = 0; i < arrSize; i++) {\\n    int j = search(values, arrSize, arr[i]);\\n    result[i] = ranks[j];\\n  }\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802651,
                "title": "short-and-fast",
                "content": "```\\nvector<int> arrayRankTransform(vector<int>& a) \\n{\\n\\tvector<pair<int, int>> t(size(a));\\n\\tfor(auto i{0}; i<size(a); t[i] = {a[i], i}, ++i);\\n\\n\\tsort(begin(t), end(t));\\n\\n\\tvector<int> out(size(a), 1);\\n\\tfor(auto i{1}, c{1}; i<size(t); ++i)\\n\\t\\tout[t[i].second] = (c += t[i].first != t[i-1].first);\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& a) \\n{\\n\\tvector<pair<int, int>> t(size(a));\\n\\tfor(auto i{0}; i<size(a); t[i] = {a[i], i}, ++i);\\n\\n\\tsort(begin(t), end(t));\\n\\n\\tvector<int> out(size(a), 1);\\n\\tfor(auto i{1}, c{1}; i<size(t); ++i)\\n\\t\\tout[t[i].second] = (c += t[i].first != t[i-1].first);\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 757762,
                "title": "java-easy-to-understand-comments-video-explanation",
                "content": "Video Explanation: https://www.youtube.com/watch?v=F7O9fNeV_FM\\n\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        // Create copy array O(N) time and space\\n        int[] copyArr = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) copyArr[i] = arr[i];\\n        \\n        // Sort the copy array. O(nlogn) time complexity\\n        Arrays.sort(copyArr);\\n        \\n        // HashMap, key: number, value: rank\\n        // O(N) time to loop through. O(N) space to store all the numbers\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : copyArr) {\\n            if (!map.containsKey(num)) map.put(num, map.size() + 1);\\n        }\\n        \\n        // Use map to build rankings. O(N) time to loop through.\\n        for (int i = 0; i < arr.length; i++) arr[i] = map.get(arr[i]);\\n        \\n        return arr;\\n    }\\n}\\n\\n// Original Array: 40, 10, 20, 30\\n// Sorted Arr: 10, 20, 30, 40\\n// Map: {10, 1}, {20, 2}, {30, 3}, {40, 4}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        // Create copy array O(N) time and space\\n        int[] copyArr = new int[arr.length];\\n        for (int i = 0; i < arr.length; i++) copyArr[i] = arr[i];\\n        \\n        // Sort the copy array. O(nlogn) time complexity\\n        Arrays.sort(copyArr);\\n        \\n        // HashMap, key: number, value: rank\\n        // O(N) time to loop through. O(N) space to store all the numbers\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : copyArr) {\\n            if (!map.containsKey(num)) map.put(num, map.size() + 1);\\n        }\\n        \\n        // Use map to build rankings. O(N) time to loop through.\\n        for (int i = 0; i < arr.length; i++) arr[i] = map.get(arr[i]);\\n        \\n        return arr;\\n    }\\n}\\n\\n// Original Array: 40, 10, 20, 30\\n// Sorted Arr: 10, 20, 30, 40\\n// Map: {10, 1}, {20, 2}, {30, 3}, {40, 4}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757679,
                "title": "easy-to-understand-solution",
                "content": "I created a sorted copy of the arr and an hashMap, loop through the copy to track the ranks, check for it in the hashMap and assign it a rank if not present in the hashMap. \\nWent through the arr a second time to modify the elements with their ranks.\\n```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not arr:\\n            return []\\n\\t\\t\\t\\n        rank = 1\\n        hashMap = {}\\n        result = sorted(arr)\\n        for num in result:\\n            if num not in hashMap:\\n                hashMap[num] = rank\\n                rank += 1\\n            \\n        for idx, val in enumerate(arr):\\n            arr[idx] = hashMap[val]\\n\\t\\t\\t\\n        return arr\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not arr:\\n            return []\\n\\t\\t\\t\\n        rank = 1\\n        hashMap = {}\\n        result = sorted(arr)\\n        for num in result:\\n            if num not in hashMap:\\n                hashMap[num] = rank\\n                rank += 1\\n            \\n        for idx, val in enumerate(arr):\\n            arr[idx] = hashMap[val]\\n\\t\\t\\t\\n        return arr\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 701604,
                "title": "python-faster-than-90",
                "content": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        ranks = {v:k for k,v in enumerate(list(sorted(set(arr)))) }\\n        \\n        for i in range(len(arr)):\\n            arr[i] = ranks[arr[i]] + 1 \\n            \\n        return arr",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        ranks = {v:k for k,v in enumerate(list(sorted(set(arr)))) }",
                "codeTag": "Java"
            },
            {
                "id": 692146,
                "title": "another-2-line-javascript-solution",
                "content": "```javascript\\nconst arrayRankTransform = function (arr) {\\n  const ranks = Object.fromEntries([...new Set(arr)].sort((a, b) => a - b).map((n, i) => [n, i + 1]))\\n  return arr.map(n => ranks[n])\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst arrayRankTransform = function (arr) {\\n  const ranks = Object.fromEntries([...new Set(arr)].sort((a, b) => a - b).map((n, i) => [n, i + 1]))\\n  return arr.map(n => ranks[n])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665734,
                "title": "java-hashmap-soln-faster-than-95",
                "content": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        int[] rankMatrix = new int[arr.length];\\n        System.arraycopy(arr, 0, rankMatrix, 0, arr.length);\\n        Arrays.sort(rankMatrix);\\n            \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i : rankMatrix){\\n            if(!map.containsKey(i)){\\n                map.put(i, rank++);\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] = map.get(arr[i]);            \\n        }\\n        return arr; \\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n        int[] rankMatrix = new int[arr.length];\\n        System.arraycopy(arr, 0, rankMatrix, 0, arr.length);\\n        Arrays.sort(rankMatrix);\\n            \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int rank=1;\\n        \\n        for(int i : rankMatrix){\\n            if(!map.containsKey(i)){\\n                map.put(i, rank++);\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] = map.get(arr[i]);            \\n        }\\n        return arr; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 664243,
                "title": "javascript-o-n-log-n-solution-88-49-faster",
                "content": "Runtime: 232 ms, faster than 88.49% of JavaScript online submissions for Rank Transform of an Array.\\nMemory Usage: 62.9 MB, less than 100.00% of JavaScript online submissions for Rank Transform of an Array.\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let rankMap = {};\\n    //sort the array\\n    let temp = [...new Set(arr)].sort((a,b)=>a-b);\\n    for(let i=0;i<temp.length;i++)\\n        rankMap[temp[i]]=i+1;\\n    return arr.reduce((acc,cur)=>{\\n        acc.push(rankMap[cur]);\\n        return acc\\n    },[]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let rankMap = {};\\n    //sort the array\\n    let temp = [...new Set(arr)].sort((a,b)=>a-b);\\n    for(let i=0;i<temp.length;i++)\\n        rankMap[temp[i]]=i+1;\\n    return arr.reduce((acc,cur)=>{\\n        acc.push(rankMap[cur]);\\n        return acc\\n    },[]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621912,
                "title": "java-simple-solution-using-tree-set-and-hashmap",
                "content": "```\\n        int[] rankMatrix = new int[arr.length];\\n        Set<Integer> set = new TreeSet<>();\\n        for (int num : arr) {\\n            set.add(num);\\n        }\\n        int rank = 1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : set) {\\n            map.put(i, rank++);\\n        }\\n        int incr = 0;\\n        for (int i : arr) {\\n            rankMatrix[incr++] = map.get(i);\\n        }\\n        return rankMatrix;",
                "solutionTags": [],
                "code": "```\\n        int[] rankMatrix = new int[arr.length];\\n        Set<Integer> set = new TreeSet<>();\\n        for (int num : arr) {\\n            set.add(num);\\n        }\\n        int rank = 1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : set) {\\n            map.put(i, rank++);\\n        }\\n        int incr = 0;\\n        for (int i : arr) {\\n            rankMatrix[incr++] = map.get(i);\\n        }\\n        return rankMatrix;",
                "codeTag": "Unknown"
            },
            {
                "id": 540140,
                "title": "python-clean-code-hashmap",
                "content": "```\\n    def arrayRankTransform(self, arr):\\n\\n        tmp = sorted(set(arr))\\n        hashmap = {}\\n        rank = 1\\n        \\n        for each in tmp:\\n            hashmap[each] = rank\\n            rank += 1\\n\\n            \\n        return [ hashmap[each] for each in arr]\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def arrayRankTransform(self, arr):\\n\\n        tmp = sorted(set(arr))\\n        hashmap = {}\\n        rank = 1\\n        \\n        for each in tmp:\\n            hashmap[each] = rank\\n            rank += 1\\n\\n            \\n        return [ hashmap[each] for each in arr]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 523487,
                "title": "c-344-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int[] ArrayRankTransform(int[] arr)\\n        {\\n            if (arr == null)\\n            {\\n                return null;\\n            }\\n\\n            // eliminate duplicates\\n            var set = new HashSet<int>(arr);\\n\\n            // sort for rank\\n            var array = set.ToArray();\\n            Array.Sort(array);\\n            \\n            // rank dictionary\\n            var rank = new Dictionary<int, int>();\\n            for (int i = 0; i < array.Length; i++)\\n            {\\n                rank[array[i]] = i + 1;\\n            }\\n\\n            // look up the ranks\\n            var res = new int[arr.Length];\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                res[i] = rank[arr[i]];\\n            }\\n            return res;\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int[] ArrayRankTransform(int[] arr)\\n        {\\n            if (arr == null)\\n            {\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 503326,
                "title": "c-2-line-solution-binarysearch",
                "content": "```\\n    public int[] ArrayRankTransform(int[] arr)\\n    {\\n      var wk = arr.OrderBy(x => x).ToHashSet().ToList();\\n      return arr.Select(i => wk.BinarySearch(i) + 1).ToArray();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] ArrayRankTransform(int[] arr)\\n    {\\n      var wk = arr.OrderBy(x => x).ToHashSet().ToList();\\n      return arr.Select(i => wk.BinarySearch(i) + 1).ToArray();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501716,
                "title": "swift-hashmap-solution",
                "content": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var sArr = arr.sorted()\\n        var map:[Int:Int] = [:]\\n        for item in sArr{\\n            if map[item] == nil{ map[item] = map.count + 1 }\\n        }\\n        var res:[Int] = []\\n        for item in arr{\\n            res.append(map[item]!)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var sArr = arr.sorted()\\n        var map:[Int:Int] = [:]\\n        for item in sArr{\\n            if map[item] == nil{ map[item] = map.count + 1 }\\n        }\\n        var res:[Int] = []\\n        for item in arr{\\n            res.append(map[item]!)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499887,
                "title": "python-hashmap-93",
                "content": "Thank you guys for the help. cheers\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hash_map = {}\\n        copy_arr = sorted(set(arr))\\n        rank = 1\\n        \\n        for i in copy_arr:\\n            hash_map[i] = rank\\n            rank += 1\\n            \\n        re = []\\n        for i in arr:\\n            re.append(hash_map[i])\\n            \\n        return re\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hash_map = {}\\n        copy_arr = sorted(set(arr))\\n        rank = 1\\n        \\n        for i in copy_arr:\\n            hash_map[i] = rank\\n            rank += 1\\n            \\n        re = []\\n        for i in arr:\\n            re.append(hash_map[i])\\n            \\n        return re\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492324,
                "title": "javascript-solution",
                "content": "``` js\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let uniqArr = Array.from(new Set(arr));\\n    const hashTable = {};\\n    uniqArr.sort((x, y) => x > y ? 1 : x == y ? 0 : -1);\\n    uniqArr.forEach((x, idx) => {\\n        hashTable[x] = idx + 1;\\n    });\\n    \\n    return arr.map(x => hashTable[x]);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "``` js\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    let uniqArr = Array.from(new Set(arr));\\n    const hashTable = {};\\n    uniqArr.sort((x, y) => x > y ? 1 : x == y ? 0 : -1);\\n    uniqArr.forEach((x, idx) => {\\n        hashTable[x] = idx + 1;\\n    });\\n    \\n    return arr.map(x => hashTable[x]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490705,
                "title": "java-commented-100-faster-sort-map",
                "content": "Sort the array for getting ranks.\\nMap the values to ranks.\\nRetrive the values for getting ranks in correct order.\\n\\n```java\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int len = arr.length;\\n        if(len == 0)    return new int[0];\\n        \\n        int[] sortedArr = arr.clone();\\n        \\n        Arrays.sort(sortedArr);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int[] rankList = new int[len];\\n        int rank = 1;\\n        map.put(sortedArr[0], rank);\\n    \\n\\t\\t//Map the values to ranks.\\n        for(int i = 1 ; i < len; i++)\\n            if(sortedArr[i] != sortedArr[i-1])\\n            {\\n                rank++;\\n                map.put(sortedArr[i], rank);\\n            }\\n\\n\\t\\t//Retrive the values for getting ranks in correct order.\\n        for(int i = 0 ; i < len; i++)\\n            rankList[i] = map.get(arr[i]);\\n\\n        return rankList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int len = arr.length;\\n        if(len == 0)    return new int[0];\\n        \\n        int[] sortedArr = arr.clone();\\n        \\n        Arrays.sort(sortedArr);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int[] rankList = new int[len];\\n        int rank = 1;\\n        map.put(sortedArr[0], rank);\\n    \\n\\t\\t//Map the values to ranks.\\n        for(int i = 1 ; i < len; i++)\\n            if(sortedArr[i] != sortedArr[i-1])\\n            {\\n                rank++;\\n                map.put(sortedArr[i], rank);\\n            }\\n\\n\\t\\t//Retrive the values for getting ranks in correct order.\\n        for(int i = 0 ; i < len; i++)\\n            rankList[i] = map.get(arr[i]);\\n\\n        return rankList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490395,
                "title": "c-map-for-sorted-unique-values-short-and-simple",
                "content": "Intuition: \\n - we need unique values sorted in ascending order\\n - for each value we need just one rank\\n\\nSo we keep positions for each value in a vector and we sort the values using a map. \\nThen go through values and step the rank when going to the next value.\\n\\n```\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,vector<int>> m; // value -> positions\\n        vector<int> res(arr.size());\\n        for(int i=0;i<arr.size();i++) m[arr[i]].push_back(i);\\n        int rank=1;\\n        for(auto& it:m) {\\n            for(int pos:it.second) {\\n                res[pos] = rank;\\n            }\\n            rank++;\\n        }\\n        return res;\\n    }\\n```\\nComplexity: memory O(N), speed O(NLogN) caused by inserting into the map",
                "solutionTags": [],
                "code": "```\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,vector<int>> m; // value -> positions\\n        vector<int> res(arr.size());\\n        for(int i=0;i<arr.size();i++) m[arr[i]].push_back(i);\\n        int rank=1;\\n        for(auto& it:m) {\\n            for(int pos:it.second) {\\n                res[pos] = rank;\\n            }\\n            rank++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490025,
                "title": "javascript-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    const sorted = arr.slice().sort((a, b) => a - b);\\n    const rank = {};\\n    for (let i = 0, r = 0; i < sorted.length; i += 1) {\\n        if (sorted[i] !== sorted[i - 1]) {\\n            r += 1;\\n            rank[sorted[i]] = r;\\n        }\\n    }\\n    \\n    return arr.map(v => rank[v]);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arr) {\\n    const sorted = arr.slice().sort((a, b) => a - b);\\n    const rank = {};\\n    for (let i = 0, r = 0; i < sorted.length; i += 1) {\\n        if (sorted[i] !== sorted[i - 1]) {\\n            r += 1;\\n            rank[sorted[i]] = r;\\n        }\\n    }\\n    \\n    return arr.map(v => rank[v]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489709,
                "title": "cpp-map-one-of-the-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        sort(arr.begin(), arr.end());                  //sort original array\\n        int rank=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                m[arr[i]] = rank++;\\n            else if(arr[i]==arr[i-1])\\n                continue;\\n            else\\n                m[arr[i]] = rank++;                                  //store element and its rank in map\\n        }\\n        //cout<<n<<endl;\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n            res.push_back(m[v[i]]);                            //find rank of saved elements in v\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        sort(arr.begin(), arr.end());                  //sort original array\\n        int rank=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                m[arr[i]] = rank++;\\n            else if(arr[i]==arr[i-1])\\n                continue;\\n            else\\n                m[arr[i]] = rank++;                                  //store element and its rank in map\\n        }\\n        //cout<<n<<endl;\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n            res.push_back(m[v[i]]);                            //find rank of saved elements in v\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 489705,
                "title": "kotlin-simple-6-lines",
                "content": "```\\nfun arrayRankTransform(arr: IntArray): IntArray {\\n    var sorted = arr.copyOf().sortedArray()\\n    var map = mutableMapOf<Int, Int>()\\n    var rank = 1\\n    for(i in sorted.indices) if(i > 0 && sorted[i] > sorted[i-1]) map.put(sorted[i], ++rank) else map.put(sorted[i], rank)\\n    for(i in arr.indices) arr[i] = map.get(arr[i])!!\\n    return arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun arrayRankTransform(arr: IntArray): IntArray {\\n    var sorted = arr.copyOf().sortedArray()\\n    var map = mutableMapOf<Int, Int>()\\n    var rank = 1\\n    for(i in sorted.indices) if(i > 0 && sorted[i] > sorted[i-1]) map.put(sorted[i], ++rank) else map.put(sorted[i], rank)\\n    for(i in arr.indices) arr[i] = map.get(arr[i])!!\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842447,
                "title": "solution",
                "content": "# Intuition\\nstore the value with their index in vector\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     \\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int n=arr.size();\\n       if(arr.empty()){\\n            return {};\\n        }\\n        vector<pair<int,int>>temp;\\n        for(int i=0;i<n;i++){\\n            temp.push_back({arr[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        int rank=1;\\n        \\n        for(int i=0;i<n-1;i++){\\n             if(temp[i].first==temp[i+1].first){\\n                 arr[temp[i].second]=rank;\\n             }\\n             else{\\n                 arr[temp[i].second]=rank;\\n                  rank++;\\n             }\\n        }\\n        if(!temp.empty()){\\n            arr[temp.back().second]=rank;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n     \\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        int n=arr.size();\\n       if(arr.empty()){\\n            return {};\\n        }\\n        vector<pair<int,int>>temp;\\n        for(int i=0;i<n;i++){\\n            temp.push_back({arr[i],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        int rank=1;\\n        \\n        for(int i=0;i<n-1;i++){\\n             if(temp[i].first==temp[i+1].first){\\n                 arr[temp[i].second]=rank;\\n             }\\n             else{\\n                 arr[temp[i].second]=rank;\\n                  rank++;\\n             }\\n        }\\n        if(!temp.empty()){\\n            arr[temp.back().second]=rank;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805417,
                "title": "c-beats-100-solution",
                "content": "# Intuition\\nmake a pair of vector copy all arr index with value and sort using custom operator \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nOverall, the dominant time complexity is O(N log N) due to the sorting step\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     struct compare {\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2) {\\n            return p1.first < p2.first;\\n        }\\n    };\\n\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.empty()){\\n            return {};\\n        }\\n      vector<pair<int,int>>arr1;\\n      for(int i =0;i<arr.size();i++){\\n          arr1.push_back(make_pair(arr[i],i));\\n      }\\n       sort(arr1.begin(), arr1.end(), compare());\\n      int rank =1 ;\\n      for(int i = 0 ;i<arr1.size()-1;i++){\\n          if(arr1[i].first!=arr1[i+1].first){\\n              arr[arr1[i].second]=rank;\\n              rank++;\\n          }else{\\n               arr[arr1[i].second]=rank;\\n          }\\n      }\\n       if (!arr1.empty()) {\\n            arr[arr1.back().second] = rank;\\n       }\\n      return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n     struct compare {\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2) {\\n            return p1.first < p2.first;\\n        }\\n    };\\n\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.empty()){\\n            return {};\\n        }\\n      vector<pair<int,int>>arr1;\\n      for(int i =0;i<arr.size();i++){\\n          arr1.push_back(make_pair(arr[i],i));\\n      }\\n       sort(arr1.begin(), arr1.end(), compare());\\n      int rank =1 ;\\n      for(int i = 0 ;i<arr1.size()-1;i++){\\n          if(arr1[i].first!=arr1[i+1].first){\\n              arr[arr1[i].second]=rank;\\n              rank++;\\n          }else{\\n               arr[arr1[i].second]=rank;\\n          }\\n      }\\n       if (!arr1.empty()) {\\n            arr[arr1.back().second] = rank;\\n       }\\n      return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748468,
                "title": "python-easy-solution-sorting-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn) \\nBecause of sorting\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        dic={}\\n        lis=list(set(arr))\\n        lis.sort()\\n        for i in range(len(lis)):\\n            dic[lis[i]]=i\\n        for i in range(len(arr)):\\n            arr[i]=(dic[arr[i]]+1)\\n        return arr        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        dic={}\\n        lis=list(set(arr))\\n        lis.sort()\\n        for i in range(len(lis)):\\n            dic[lis[i]]=i\\n        for i in range(len(arr)):\\n            arr[i]=(dic[arr[i]]+1)\\n        return arr        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649581,
                "title": "best-menthod",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int n = size(arr);\\n\\n        vector<int> ans = arr;\\n        sort(begin(ans), end(ans));\\n\\n        int rank=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mp.find(ans[i]) == mp.end()){\\n                mp[ans[i]] = rank;\\n                rank++;\\n            }\\n        }\\n\\n        ans.clear();\\n        for(auto i:arr)\\n        {\\n            ans.push_back(mp[i]);\\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/1ea84f20-4d96-4955-8fdb-c394300ce2ca_1687027269.8888555.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int n = size(arr);\\n\\n        vector<int> ans = arr;\\n        sort(begin(ans), end(ans));\\n\\n        int rank=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(mp.find(ans[i]) == mp.end()){\\n                mp[ans[i]] = rank;\\n                rank++;\\n            }\\n        }\\n\\n        ans.clear();\\n        for(auto i:arr)\\n        {\\n            ans.push_back(mp[i]);\\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402210,
                "title": "java-hashmap-60-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer, Integer> hmap = new HashMap<>();\\n        int ans[] = new int[arr.length];\\n        ans = arr.clone();\\n        Arrays.sort(arr);\\n        int res[] = Arrays.stream(arr)\\n                                    .distinct()\\n                                    .toArray();\\n        for(int i=1;i<=res.length;i++)\\n            hmap.put(res[i-1], i);\\n        \\n        for(int i=0;i<ans.length;i++)\\n            ans[i] = hmap.get(ans[i]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer, Integer> hmap = new HashMap<>();\\n        int ans[] = new int[arr.length];\\n        ans = arr.clone();\\n        Arrays.sort(arr);\\n        int res[] = Arrays.stream(arr)\\n                                    .distinct()\\n                                    .toArray();\\n        for(int i=1;i<=res.length;i++)\\n            hmap.put(res[i-1], i);\\n        \\n        for(int i=0;i<ans.length;i++)\\n            ans[i] = hmap.get(ans[i]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329126,
                "title": "javascript-beats-100",
                "content": "# Intuition\\nBeats 100%\\n\\n# Approach\\noptimised apporach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arrr) {\\n    let map=new Map()\\n    let arr=[...arrr]\\n    arr.sort((a,b)=>a-b)\\n    let count=0\\n   for(let i=0;i<arr.length;i++){\\n      if(!map.has(arr[i])){\\n          count++\\n          map.set(arr[i],count)\\n      }\\n   }\\n    for(let i=0;i<arrr.length;i++){\\n        let newVar=map.get(arrr[i])\\n        arrr[i]=newVar\\n    }\\n    return arrr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar arrayRankTransform = function(arrr) {\\n    let map=new Map()\\n    let arr=[...arrr]\\n    arr.sort((a,b)=>a-b)\\n    let count=0\\n   for(let i=0;i<arr.length;i++){\\n      if(!map.has(arr[i])){\\n          count++\\n          map.set(arr[i],count)\\n      }\\n   }\\n    for(let i=0;i<arrr.length;i++){\\n        let newVar=map.get(arrr[i])\\n        arrr[i]=newVar\\n    }\\n    return arrr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233977,
                "title": "easy-python-code-for-beginners",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        copy = sorted(arr)\\n        ranks = {}\\n        rank = 1\\n        # storing the rank of every elements in hashtable ranks\\n        for n in copy:\\n            if n not in ranks:\\n                ranks[n] = rank\\n                rank += 1\\n                \\n        for i in range(len(arr)):\\n            arr[i] = ranks[arr[i]]\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        copy = sorted(arr)\\n        ranks = {}\\n        rank = 1\\n        # storing the rank of every elements in hashtable ranks\\n        for n in copy:\\n            if n not in ranks:\\n                ranks[n] = rank\\n                rank += 1\\n                \\n        for i in range(len(arr)):\\n            arr[i] = ranks[arr[i]]\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070230,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> minheap;\\n        for(int i=0;i<arr.size();i++){\\n            minheap.push(arr[i]);\\n        }\\n        unordered_map<int,int> ourmap;\\n        int rank=1;\\n        while(minheap.size()!=0){\\n            \\n            int data=minheap.top();\\n            minheap.pop();\\n            if(ourmap.find(data)==ourmap.end()){\\n                ourmap[data]=rank;\\n                rank++;\\n            }\\n        }\\n        int n=arr.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<arr.size();i++){\\n            ans[i]=ourmap[arr[i]];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> minheap;\\n        for(int i=0;i<arr.size();i++){\\n            minheap.push(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2940015,
                "title": "java-88-faster-hashmap-with-explanation",
                "content": "# Intuition\\nStore the unique numbers as key in a HashMap and add thier rank as values.[Key(40):Value(4)].\\n\\n# Approach\\n1. Create a HashMap\\n2. Make a copy of the original Array A = arr. Because we will sort the temp array A so that we can put it in a map easily by incrementing rank.\\n3. Put the number from array \"A\" in the HashMap if number is not present already and increment the value(rank) by 1. \\n4. Explanation: \\nWe are putting the numbers as key and rank as values because we can easily get the value from a map by using map.get().\\nThere is no such direct method available to get key of a map.\\n\\n5. Print map just to check how map stores key:value\\n6. Store the rank in our temp array \"A\" by fetching the rank from HashMap with the help of map.get(key) -> returns value(rank).\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) -> Arrays.sort takes (nlogn) time\\n\\n- Space complexity:\\nO(n) -> map takes O(n) spaces\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int A[] = Arrays.copyOf(arr, arr.length);\\n\\n        Arrays.sort(A);\\n\\n        for(Integer n : A){\\n            map.putIfAbsent(n,map.size()+1);\\n        }\\n\\n        System.out.println(map);\\n\\n        for(int i=0;i<arr.length;i++){\\n            A[i] = map.get(arr[i]);\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int A[] = Arrays.copyOf(arr, arr.length);\\n\\n        Arrays.sort(A);\\n\\n        for(Integer n : A){\\n            map.putIfAbsent(n,map.size()+1);\\n        }\\n\\n        System.out.println(map);\\n\\n        for(int i=0;i<arr.length;i++){\\n            A[i] = map.get(arr[i]);\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837994,
                "title": "1331-rank-transform-of-an-array-using-python-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        return [rank[i] for i in arr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {}\\n        cnt = 1\\n        for i in sorted(list(set(arr))):\\n            rank[i] = cnt\\n            cnt += 1\\n        return [rank[i] for i in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687632,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed Set for new unique and sorted array and binary search to find the position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n80%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n60% \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> arr2;\\n        set<int> st;\\n        for(auto i:arr){\\n            st.insert(i);\\n        }\\n        for(auto i:st){\\n            arr2.push_back(i);\\n        }\\n        vector<int> sol;\\n        for(auto i:arr){\\n            int s = 0,e=arr2.size()-1;\\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                if(arr2[mid]==i){\\n                    sol.push_back(mid+1);\\n                    break;\\n                }else if(arr2[mid]<i){\\n                    s = mid+1;\\n                }else{\\n                    e = mid-1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> arr2;\\n        set<int> st;\\n        for(auto i:arr){\\n            st.insert(i);\\n        }\\n        for(auto i:st){\\n            arr2.push_back(i);\\n        }\\n        vector<int> sol;\\n        for(auto i:arr){\\n            int s = 0,e=arr2.size()-1;\\n            while(s<=e){\\n                int mid = s + (e-s)/2;\\n                if(arr2[mid]==i){\\n                    sol.push_back(mid+1);\\n                    break;\\n                }else if(arr2[mid]<i){\\n                    s = mid+1;\\n                }else{\\n                    e = mid-1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605058,
                "title": "java-solution-using-priority-queue-and-hashmap",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t\\t//USING PRIORITY QUEUE AND HASHMAP\\n\\t\\t\\tint n= arr.length;\\n\\t\\t\\tPriorityQueue<Integer> pq= new PriorityQueue<>();\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t   pq.add(arr[i]);\\n\\t\\t\\tHashMap<Integer,Integer> map= new HashMap<>();\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(!pq.isEmpty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val= pq.remove();\\n\\t\\t\\t\\tif(!map.containsKey(val))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmap.put(val,count);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tarr[i]=map.get(arr[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn arr;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\t\\t\\t//USING PRIORITY QUEUE AND HASHMAP\\n\\t\\t\\tint n= arr.length;\\n\\t\\t\\tPriorityQueue<Integer> pq= new PriorityQueue<>();\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t   pq.add(arr[i]);\\n\\t\\t\\tHashMap<Integer,Integer> map= new HashMap<>();\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(!pq.isEmpty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val= pq.remove();\\n\\t\\t\\t\\tif(!map.containsKey(val))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmap.put(val,count);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2597031,
                "title": "c-easy-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        //map\\n        int rank=1;               //to assign the rank to the elements\\n        map<int,vector<int>>mp;   //why map->to ensure the sorted nature of the elements\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int>v;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            v=it->second;   //this vector<int> will have basically all the index of the it->first\\n            int idx;\\n            for(int i=0;i<v.size();i++)\\n            {\\n                idx=v[i];\\n                arr[idx]=rank;\\n            }\\n            rank++;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        //map\\n        int rank=1;               //to assign the rank to the elements\\n        map<int,vector<int>>mp;   //why map->to ensure the sorted nature of the elements\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int>v;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            v=it->second;   //this vector<int> will have basically all the index of the it->first\\n            int idx;\\n            for(int i=0;i<v.size();i++)\\n            {\\n                idx=v[i];\\n                arr[idx]=rank;\\n            }\\n            rank++;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543530,
                "title": "c-easy-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        auto vec = arr;\\n        sort(vec.begin(), vec.end());\\n        unordered_map<int, int>mp;\\n        int rank = 1;\\n        for(int num : vec)\\n        {\\n            if(mp[num])\\n                continue;\\n            mp[num] = rank;      \\n            rank++;\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            arr[i] = mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        auto vec = arr;\\n        sort(vec.begin(), vec.end());\\n        unordered_map<int, int>mp;\\n        int rank = 1;\\n        for(int num : vec)\\n        {\\n            if(mp[num])\\n                continue;\\n            mp[num] = rank;      \\n            rank++;\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            arr[i] = mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439469,
                "title": "my-solution-java-using-hashmap",
                "content": "\\n\\t HashMap<Integer, Integer> res = new HashMap<Integer, Integer>();\\n        int[] blu = arr.clone();\\n        Arrays.sort(blu);\\n        \\n        if(arr.length == 0)\\n            return arr;\\n        \\n        int ble = 1;\\n        for(int i = 0; i < arr.length-1; i++){\\n            if(blu[i] == blu[i+1]){\\n                res.put(blu[i], ble);\\n                continue;\\n            }\\n            res.put(blu[i], ble);\\n            ble++;\\n        }\\n        res.put(blu[arr.length-1], ble);\\n\\n        int[] glu = new int[arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            glu[i] = res.get(arr[i]);\\n        }\\n        \\n        return glu;\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\t HashMap<Integer, Integer> res = new HashMap<Integer, Integer>();\\n        int[] blu = arr.clone();\\n        Arrays.sort(blu);\\n        \\n        if(arr.length == 0)\\n            return arr;\\n        \\n        int ble = 1;\\n        for(int i = 0; i < arr.length-1; i++){\\n            if(blu[i] == blu[i+1]){\\n                res.put(blu[i], ble);\\n                continue;\\n            }\\n            res.put(blu[i], ble);\\n            ble++;\\n        }\\n        res.put(blu[arr.length-1], ble);\\n\\n        int[] glu = new int[arr.length];\\n        for(int i = 0; i < arr.length; i++){\\n            glu[i] = res.get(arr[i]);\\n        }\\n        \\n        return glu;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2423829,
                "title": "c-simple-and-clean-implementation",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nvector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if(arr.size()==0)\\n            return arr;\\n        vector<int> copy = arr;\\n        sort(copy.begin(),copy.end());\\n        unordered_map<int,int> mp;\\n        int rank=0;\\n        for(int i=0;i<copy.size()-1;i++)\\n        {\\n            if(copy[i]!=copy[i+1])\\n            {\\n                rank++;\\n            }\\n            mp[copy[i]]=rank;\\n        }\\n        mp[copy[copy.size()-1]]=rank+1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr) \\n    {\\n        if(arr.size()==0)\\n            return arr;\\n        vector<int> copy = arr;\\n        sort(copy.begin(),copy.end());\\n        unordered_map<int,int> mp;\\n        int rank=0;\\n        for(int i=0;i<copy.size()-1;i++)\\n        {\\n            if(copy[i]!=copy[i+1])\\n            {\\n                rank++;\\n            }\\n            mp[copy[i]]=rank;\\n        }\\n        mp[copy[copy.size()-1]]=rank+1;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=mp[arr[i]];\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379360,
                "title": "python-3-lines-solution-o-n-log-n",
                "content": "```\\nfrom itertools import count\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank_dict = dict(zip(sorted(set(arr)), count(1)))  # mapping from element to rank\\n        return [rank_dict[e] for e in arr]",
                "solutionTags": [],
                "code": "```\\nfrom itertools import count\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank_dict = dict(zip(sorted(set(arr)), count(1)))  # mapping from element to rank\\n        return [rank_dict[e] for e in arr]",
                "codeTag": "Java"
            },
            {
                "id": 2374542,
                "title": "python-simplest-solution-o-nlog-n",
                "content": "```class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        new = sorted(arr)\\n        rank = {}\\n        score = 1\\n        for i in range(len(arr)):\\n            if not (new[i] in rank):\\n                rank[new[i]] = score\\n                score += 1\\n        new = []\\n        for i in range(len(arr)):\\n            new += [rank[arr[i]]]\\n        return new",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        new = sorted(arr)\\n        rank = {}",
                "codeTag": "Java"
            },
            {
                "id": 2314328,
                "title": "java-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        Map<Integer, List<Integer>> elememtsToIndicesMap = new TreeMap();\\n        \\n        for (int idx=0; idx < arr.length; idx++) {\\n            List<Integer> indices = elememtsToIndicesMap.getOrDefault(arr[idx], new ArrayList());\\n            indices.add(idx);\\n            elememtsToIndicesMap.put(arr[idx], indices);\\n        }\\n                \\n        int rank = 1;\\n        \\n        for (int key: elememtsToIndicesMap.keySet()) {\\n            for (int index: elememtsToIndicesMap.get(key)) {\\n                arr[index] = rank;\\n            }\\n            rank++;\\n        }\\n        \\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        Map<Integer, List<Integer>> elememtsToIndicesMap = new TreeMap();\\n        \\n        for (int idx=0; idx < arr.length; idx++) {\\n            List<Integer> indices = elememtsToIndicesMap.getOrDefault(arr[idx], new ArrayList());\\n            indices.add(idx);\\n            elememtsToIndicesMap.put(arr[idx], indices);\\n        }\\n                \\n        int rank = 1;\\n        \\n        for (int key: elememtsToIndicesMap.keySet()) {\\n            for (int index: elememtsToIndicesMap.get(key)) {\\n                arr[index] = rank;\\n            }\\n            rank++;\\n        }\\n        \\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287552,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        arrx = [i for i in set(arr)]\\n        arrx.sort()\\n        \\n        hp={}\\n        for i in range(len(arrx)):\\n            if arrx[i] in hp:\\n                continue\\n            else:\\n                hp[arrx[i]] = i+1 \\n                \\n        print(hp)        \\n        for j in range(len(arr)):\\n            arr[j] = hp[arr[j]]\\n            \\n        return arr\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        arrx = [i for i in set(arr)]\\n        arrx.sort()\\n        \\n        hp={}\\n        for i in range(len(arrx)):\\n            if arrx[i] in hp:\\n                continue\\n            else:\\n                hp[arrx[i]] = i+1 \\n                \\n        print(hp)        \\n        for j in range(len(arr)):\\n            arr[j] = hp[arr[j]]\\n            \\n        return arr\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102551,
                "title": "code-smells-python-solution-it-s-very-easy-to-use",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = dict(zip(sorted(set(arr)), [i + 1 for i in range(len(set(arr)))]))\\n        return [ranks[num] for num in arr]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = dict(zip(sorted(set(arr)), [i + 1 for i in range(len(set(arr)))]))\\n        return [ranks[num] for num in arr]",
                "codeTag": "Java"
            },
            {
                "id": 2066034,
                "title": "non-hashmap-solution-java",
                "content": "```\\npublic static int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        int[] rank = new int[arr.length];\\n        if(arr.length==0) return arr;\\n        Arrays.sort(temp);\\n        rank[0] = 1;\\n        for (int i = 1; i < rank.length; i++) {\\n            if(temp[i]==temp[i-1]){\\n                rank[i] = rank[i-1];\\n            }\\n            else{\\n                rank[i] = rank[i-1] + 1;\\n            }\\n        }\\n        for (int i = 0; i < rank.length; i++) {\\n            arr[i] = Arrays.binarySearch(temp, arr[i]);\\n            arr[i] = rank[arr[i]];\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] arrayRankTransform(int[] arr) {\\n        int[] temp = arr.clone();\\n        int[] rank = new int[arr.length];\\n        if(arr.length==0) return arr;\\n        Arrays.sort(temp);\\n        rank[0] = 1;\\n        for (int i = 1; i < rank.length; i++) {\\n            if(temp[i]==temp[i-1]){\\n                rank[i] = rank[i-1];\\n            }\\n            else{\\n                rank[i] = rank[i-1] + 1;\\n            }\\n        }\\n        for (int i = 0; i < rank.length; i++) {\\n            arr[i] = Arrays.binarySearch(temp, arr[i]);\\n            arr[i] = rank[arr[i]];\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989339,
                "title": "python-simple-maths",
                "content": "\\n    def arrayRankTransform(self, arr):\\n        new_arr, dict1, res = sorted(list(set(arr))), defaultdict(int), []\\n        \\n        for i, j in enumerate(new_arr):\\n            dict1[j] = i+1\\n            \\n        for i in arr:\\n            res += [dict1[i]]\\n            \\n        return res\\n",
                "solutionTags": [],
                "code": "\\n    def arrayRankTransform(self, arr):\\n        new_arr, dict1, res = sorted(list(set(arr))), defaultdict(int), []\\n        \\n        for i, j in enumerate(new_arr):\\n            dict1[j] = i+1\\n            \\n        for i in arr:\\n            res += [dict1[i]]\\n            \\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1985251,
                "title": "python-optimised-using-dict-and-set-simple-explaination",
                "content": "Logic is quite simple . Take a unique set, sort it and use position in sorted DS to define the result. \\n\\nHowever if we keep sorted result in a list it will be a problem and raise time complexity to O(n\\\\*\\\\*2). Which with the help of dict is brought back to (nLogn). \\n\\nPlease find the solution with complexity explaination as below.\\n\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # Overall complexity is O(nlogn) which is due to sorting requirement\\n        \\n        # O(n)\\n        unique_list = list(set(arr))\\n        \\n        # O(nlogn)\\n        unique_list.sort()\\n        \\n        dicts = dict()\\n        \\n        # O(n)\\n        for i in range(len(unique_list)):\\n            dicts[unique_list[i]] = i+1\\n        \\n        result = [] \\n        \\n        #This is O(n)\\n        # Earlier in place of dict a list.index was being used making t = O(n**2)\\n        for ele in arr:\\n            result.append(dicts[ele])\\n            \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        \\n        # Overall complexity is O(nlogn) which is due to sorting requirement\\n        \\n        # O(n)\\n        unique_list = list(set(arr))\\n        \\n        # O(nlogn)\\n        unique_list.sort()\\n        \\n        dicts = dict()\\n        \\n        # O(n)\\n        for i in range(len(unique_list)):\\n            dicts[unique_list[i]] = i+1\\n        \\n        result = [] \\n        \\n        #This is O(n)\\n        # Earlier in place of dict a list.index was being used making t = O(n**2)\\n        for ele in arr:\\n            result.append(dicts[ele])\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910048,
                "title": "c-priority-queue-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pq.push({-1*arr[i],i});\\n        }\\n        \\n        \\n        vector<int> ans(arr.size(),0);\\n        int i=1;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            \\n            ans[temp.second]=i;\\n            if(!pq.empty()){\\n                int ele=pq.top().first;\\n            if(temp.first!=ele)\\n            {\\n                i++;\\n            }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        \\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pq.push({-1*arr[i],i});\\n        }\\n        \\n        \\n        vector<int> ans(arr.size(),0);\\n        int i=1;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            \\n            ans[temp.second]=i;\\n            if(!pq.empty()){\\n                int ele=pq.top().first;\\n            if(temp.first!=ele)\\n            {\\n                i++;\\n            }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905432,
                "title": "python-easy-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ind = [x+1 for x in range(len(arr))]\\n        ranks = dict(zip(sorted(set(arr)), ind))\\n        res = []\\n        for i in arr:\\n            res.append(ranks[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ind = [x+1 for x in range(len(arr))]\\n        ranks = dict(zip(sorted(set(arr)), ind))\\n        res = []\\n        for i in arr:\\n            res.append(ranks[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1855002,
                "title": "c-easy-to-grab-using-map-93-faster-solution",
                "content": "\\t\\t unordered_map<int,int>mp;\\n        vector<int>v(arr);\\n        sort(v.begin(),v.end());\\n        int count=1;//initial rank\\n        for(int i=0;i<v.size();i++)\\n        {\\n           auto it=mp.find(v[i]);//maintaining same rank for duplicates\\n            if(it!=mp.end())\\n                continue;\\n            else\\n            {\\n                mp[v[i]]=count;\\n                count++;//increment in rank for another element\\n            }\\n        }\\n        v.clear();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            auto it=mp.find(arr[i]);\\n            v.push_back(it->second);\\n        }\\n        return v;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\t\\t unordered_map<int,int>mp;\\n        vector<int>v(arr);\\n        sort(v.begin(),v.end());\\n        int count=1;//initial rank\\n        for(int i=0;i<v.size();i++)\\n        {\\n           auto it=mp.find(v[i]);//maintaining same rank for duplicates\\n            if(it!=mp.end())\\n                continue;\\n            else\\n            {\\n                mp[v[i]]=count;\\n                count++;//increment in rank for another element\\n            }\\n        }\\n        v.clear();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            auto it=mp.find(arr[i]);\\n            v.push_back(it->second);\\n        }\\n        return v;",
                "codeTag": "Unknown"
            },
            {
                "id": 1771278,
                "title": "5-lines-c-easy-clean-explained",
                "content": "**C++ Solutions :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& a,int n=1) {\\n        set<int>s(begin(a),end(a));\\n        unordered_map<int,int>m;\\n        for(auto &i:s)m[i]=n++;\\n        for(auto &i:a)i=m[i];\\n        return a;\\n    }\\n};\\n```\\n**If you like / help this solutions , please upvote for my motivations ^</>^**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& a,int n=1) {\\n        set<int>s(begin(a),end(a));\\n        unordered_map<int,int>m;\\n        for(auto &i:s)m[i]=n++;\\n        for(auto &i:a)i=m[i];\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713877,
                "title": "javascript-easy-understanding",
                "content": "```\\nvar arrayRankTransform = function(arr) {\\n  let num=new Set(arr);\\n  let num1=[...num].sort((a,b)=>(a-b));\\n   let pos=[];\\n    for(i=0;i<arr.length;i++){\\n        pos.push(num1.indexOf(arr[i])+1)\\n    }\\n    return pos\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n  let num=new Set(arr);\\n  let num1=[...num].sort((a,b)=>(a-b));\\n   let pos=[];\\n    for(i=0;i<arr.length;i++){\\n        pos.push(num1.indexOf(arr[i])+1)\\n    }\\n    return pos\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1702731,
                "title": "c-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\treturn {};\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tv.push_back(arr[i]);\\n\\t\\t\\t}\\n\\t\\t\\tsort(v.begin(), v.end());\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tm[v[0]] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tif(v[i] == v[i-1]){\\n\\t\\t\\t\\t\\tm[v[i]] = m[v[i - 1]];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tm[v[i]] = m[v[i - 1]] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> res;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tres.push_back(m[arr[i]]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\treturn {}",
                "codeTag": "Java"
            },
            {
                "id": 1702321,
                "title": "c-using-maps",
                "content": "Given an array of integers our task is to assign rank to each integer based on size.\\n\\nSmaller than number, smaller the rank  \\nlarger the number, larger the rank\\nIf two numbers are same their rank should also be same.\\nRank starts from 1.\\nEg: [4, 7, 3, 8]\\no/p: [2, 3, 1, 4]\\n\\nIdea is to use map so that elements will be in the sorted order and it is easier to assign ranks that way.\\n\\n```\\nvector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        map<int,int>mp;\\n        for(auto x:arr) //push every elements of the array into the map\\n            mp[x]++;\\n        \\n        int rank=1;\\n        for(auto x:mp)\\n        {\\n            mp[x.first]=rank; //assign rank 1,2 and so on\\n            rank++;\\n        }\\n        \\n        for(int i=0;i<arr.size();i++) //Now copy back the ranks to the array\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n```\\nT.C-> O(N*LOGN) , Since in maps the sorting factor is involved in the background\\nS.C-> O(N)",
                "solutionTags": [],
                "code": "```\\nvector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        map<int,int>mp;\\n        for(auto x:arr) //push every elements of the array into the map\\n            mp[x]++;\\n        \\n        int rank=1;\\n        for(auto x:mp)\\n        {\\n            mp[x.first]=rank; //assign rank 1,2 and so on\\n            rank++;\\n        }\\n        \\n        for(int i=0;i<arr.size();i++) //Now copy back the ranks to the array\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699580,
                "title": "java-easy-solution-sort-map-rank-array",
                "content": "\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\n        int[] tmp = Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(tmp);\\n        HashMap<Integer,Integer> mp = new HashMap<Integer,Integer>();\\n        int i = 1;\\n        for(Integer x:tmp){\\n            if(!mp.containsKey(x)) mp.put(x,i++);\\n        }\\n        \\n        i=0;\\n        for(Integer x:arr){\\n            arr[i++] = mp.get(x);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "\\n\\tpublic int[] arrayRankTransform(int[] arr) {\\n\\n        int[] tmp = Arrays.copyOf(arr,arr.length);\\n        Arrays.sort(tmp);\\n        HashMap<Integer,Integer> mp = new HashMap<Integer,Integer>();\\n        int i = 1;\\n        for(Integer x:tmp){\\n            if(!mp.containsKey(x)) mp.put(x,i++);\\n        }\\n        \\n        i=0;\\n        for(Integer x:arr){\\n            arr[i++] = mp.get(x);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1681592,
                "title": "java-treemap-simple",
                "content": "**T/S:** O(n lg n)/O(n)\\n```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\tvar ranks = new int[arr.length];\\n\\tfindRanks(getIntLocations(arr), ranks);\\n\\treturn ranks;\\n}\\n\\nprivate TreeMap<Integer, List<Integer>> getIntLocations(int[] arr) {\\n\\tvar locationsByNum = new TreeMap<Integer, List<Integer>>();\\n\\tfor (var i = 0; i < arr.length; i++)\\n\\t\\tlocationsByNum.computeIfAbsent(arr[i], (k) -> new ArrayList<>()).add(i);\\n\\treturn locationsByNum;\\n}\\n\\nprivate void findRanks(Map<Integer, List<Integer>> locationsByNum, int[] ranks) {\\n\\tvar i = 1;\\n\\tfor (var key : locationsByNum.keySet()) {\\n\\t\\tfor (var j : locationsByNum.get(key))\\n\\t\\t\\tranks[j] = i;\\n\\t\\ti++;\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] arrayRankTransform(int[] arr) {\\n\\tvar ranks = new int[arr.length];\\n\\tfindRanks(getIntLocations(arr), ranks);\\n\\treturn ranks;\\n}\\n\\nprivate TreeMap<Integer, List<Integer>> getIntLocations(int[] arr) {\\n\\tvar locationsByNum = new TreeMap<Integer, List<Integer>>();\\n\\tfor (var i = 0; i < arr.length; i++)\\n\\t\\tlocationsByNum.computeIfAbsent(arr[i], (k) -> new ArrayList<>()).add(i);\\n\\treturn locationsByNum;\\n}\\n\\nprivate void findRanks(Map<Integer, List<Integer>> locationsByNum, int[] ranks) {\\n\\tvar i = 1;\\n\\tfor (var key : locationsByNum.keySet()) {\\n\\t\\tfor (var j : locationsByNum.get(key))\\n\\t\\t\\tranks[j] = i;\\n\\t\\ti++;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679595,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int>mp;//so that arr element will be in sorted order\\n        for(auto k:arr)\\n            mp[k]++;\\n        int rank=0;\\n        for(auto k:mp){\\n            mp[k.first]=++rank;//map is in sorted order so 10->1,20->2 mapped like this\\n        }\\n        for(int i=0;i<arr.size();i++)\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int,int>mp;//so that arr element will be in sorted order\\n        for(auto k:arr)\\n            mp[k]++;\\n        int rank=0;\\n        for(auto k:mp){\\n            mp[k.first]=++rank;//map is in sorted order so 10->1,20->2 mapped like this\\n        }\\n        for(int i=0;i<arr.size();i++)\\n            arr[i]=mp[arr[i]];\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643601,
                "title": "c-solution-using-map-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int, int>m;\\n\\n        for(auto ele: arr)\\n            m[ele]++;\\n        \\n        int rank = 0;\\n        for(auto it: m)\\n            m[it.first] = ++rank;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = m[arr[i]];\\n            \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        map<int, int>m;\\n\\n        for(auto ele: arr)\\n            m[ele]++;\\n        \\n        int rank = 0;\\n        for(auto it: m)\\n            m[it.first] = ++rank;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n            arr[i] = m[arr[i]];\\n            \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641155,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {num: i + 1 for i, num in enumerate(sorted(set(arr)))}\\n\\n        return [rank[num] for num in arr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        rank = {num: i + 1 for i, num in enumerate(sorted(set(arr)))}\\n\\n        return [rank[num] for num in arr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624577,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int temp[]=arr.clone();\\n        Arrays.sort(arr);\\n        int rank=1;\\n        for(int i:arr) if(!map.containsKey(i)) map.put(i,rank++);\\n        int result[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(temp[i]);\\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int temp[]=arr.clone();\\n        Arrays.sort(arr);\\n        int rank=1;\\n        for(int i:arr) if(!map.containsKey(i)) map.put(i,rank++);\\n        int result[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++)\\n            result[i]=map.get(temp[i]);\\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611031,
                "title": "java-solution-sorting-hashmap",
                "content": "Kindly upvote, if it helps you!\\n```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = Arrays.copyOf(arr, arr.length);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(temp);\\n        for(int i = 0; i< temp.length; i++){\\n            if(!map.containsKey(temp[i])){\\n                map.put(temp[i], map.size()+1);\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\n public int[] arrayRankTransform(int[] arr) {\\n        int[] temp = Arrays.copyOf(arr, arr.length);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(temp);\\n        for(int i = 0; i< temp.length; i++){\\n            if(!map.containsKey(temp[i])){\\n                map.put(temp[i], map.size()+1);\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1580348,
                "title": "c-93-time-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            if(m.find(v[i])==m.end())\\n                m[v[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=m[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>v=arr;\\n        sort(v.begin(),v.end());\\n        int rank=1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            if(m.find(v[i])==m.end())\\n                m[v[i]]=rank++;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            arr[i]=m[arr[i]];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522526,
                "title": "2-efficient-python-solutions",
                "content": "```\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        arr_sorted = sorted(list(set(arr)))\\n        hashmap = {}\\n        \\n        for i in range(0,len(arr_sorted)):\\n            hashmap[arr_sorted[i]] = i+1\\n            \\n        nums = []\\n        \\n        for j in range(0,len(arr)):\\n            nums.append(hashmap[arr[j]])\\n        \\n        return nums\\n\\n\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hashmap = {}\\n        nums = []\\n        \\n        for i in sorted(arr):\\n            if i not in hashmap:\\n                hashmap[i] = len(hashmap) + 1\\n                \\n        for j in arr:\\n            nums.append(hashmap[j])\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        arr_sorted = sorted(list(set(arr)))\\n        hashmap = {}\\n        \\n        for i in range(0,len(arr_sorted)):\\n            hashmap[arr_sorted[i]] = i+1\\n            \\n        nums = []\\n        \\n        for j in range(0,len(arr)):\\n            nums.append(hashmap[arr[j]])\\n        \\n        return nums\\n\\n\\n# Time complexity - O(nlogn)\\n# Space complexity - O(n)\\n\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        hashmap = {}\\n        nums = []\\n        \\n        for i in sorted(arr):\\n            if i not in hashmap:\\n                hashmap[i] = len(hashmap) + 1\\n                \\n        for j in arr:\\n            nums.append(hashmap[j])\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448998,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i: arr)\\n            set.add(i);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int rank = 1;\\n        for(int i: set){\\n            hm.put(i, rank);\\n            rank++;\\n        }\\n        \\n        int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n          res[i] = hm.get(arr[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```\\n**OR**\\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n         int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n            res[i] = arr[i];\\n        }\\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int rank = 1;\\n        for(int i: arr){\\n            if(!hm.containsKey(i)){\\n            hm.put(i, rank);\\n            rank++;\\n            }\\n        }\\n        \\n        for(int i=0; i<res.length; i++){\\n          res[i] = hm.get(res[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i: arr)\\n            set.add(i);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int rank = 1;\\n        for(int i: set){\\n            hm.put(i, rank);\\n            rank++;\\n        }\\n        \\n        int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n          res[i] = hm.get(arr[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n         int[] res = new int[arr.length];\\n        \\n        for(int i=0; i<arr.length; i++){\\n            res[i] = arr[i];\\n        }\\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int rank = 1;\\n        for(int i: arr){\\n            if(!hm.containsKey(i)){\\n            hm.put(i, rank);\\n            rank++;\\n            }\\n        }\\n        \\n        for(int i=0; i<res.length; i++){\\n          res[i] = hm.get(res[i]);  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437346,
                "title": "c-amazon-code-assessment-leetcode-premium-hashset-list-list-sort-api",
                "content": "Aug. 31, 2021\\n**Introduction**\\nI decided to subscribe Leetcode premium, so that I can quickly warmup some algorithms to prepare for online assessment. \\n\\n**Ranking**\\nIt is interesting to apply ranking in a given array, the idea is to put all elements in the array into a hashset, so that only unique values are stored, and then convert to a C# SortedSet, and then convert to a List, and then save a hashmap to find the index by looking up element value. \\n\\n```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null)\\n        {\\n            return arr;\\n        }\\n        \\n        var set = new HashSet<int>(arr);\\n        var sorted = new SortedSet<int>(set);\\n        \\n        var list = sorted.ToList();\\n        var map = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i);\\n        }\\n        \\n        var result = new int[arr.Length];\\n        \\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            result[i] = map[arr[i]] + 1;\\n        }\\n        \\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null)\\n        {\\n            return arr;\\n        }\\n        \\n        var set = new HashSet<int>(arr);\\n        var sorted = new SortedSet<int>(set);\\n        \\n        var list = sorted.ToList();\\n        var map = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i);\\n        }\\n        \\n        var result = new int[arr.Length];\\n        \\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            result[i] = map[arr[i]] + 1;\\n        }\\n        \\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420178,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {}\\n        answer = arr \\n        curr_rank = 1\\n        \\n        for n in sorted(arr):\\n            if n not in ranks:\\n                ranks[n] = curr_rank\\n                curr_rank += 1\\n                \\n        for i in range(len(arr)):\\n            answer[i] = ranks[arr[i]]\\n            \\n        return answer\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ranks = {}\\n        answer = arr \\n        curr_rank = 1\\n        \\n        for n in sorted(arr):\\n            if n not in ranks:\\n                ranks[n] = curr_rank\\n                curr_rank += 1\\n                \\n        for i in range(len(arr)):\\n            answer[i] = ranks[arr[i]]\\n            \\n        return answer\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1410118,
                "title": "simple-python-solution",
                "content": "```\\n        arrSorted = sorted(set(arr))\\n        ranks = [r for r in xrange(1,len(arrSorted)+1)]\\n        rankArrDict = {arr : rank for arr, rank in zip(arrSorted, ranks)}\\n        return [rankArrDict[val] for val in arr]\\n```",
                "solutionTags": [],
                "code": "```\\n        arrSorted = sorted(set(arr))\\n        ranks = [r for r in xrange(1,len(arrSorted)+1)]\\n        rankArrDict = {arr : rank for arr, rank in zip(arrSorted, ranks)}\\n        return [rankArrDict[val] for val in arr]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407904,
                "title": "23-ms-faster-than-89-60-of-java-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int[] newArr = new  int[arr.length];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            newArr[i]=arr[i];\\n        }\\n       Arrays.sort(newArr);\\n        \\n       HashMap<Integer,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0,k=0;i<newArr.length;i++){\\n             if( hmap.containsKey(newArr[i])){\\n                hmap.put(newArr[i],hmap.get(newArr[i]));\\n            }\\n           else {\\n               hmap.put(newArr[i],k);\\n               k++;\\n           }  \\n         }\\n         for(int i=0;i<arr.length;i++){\\n           arr[i]=hmap.get(arr[i])+1;\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        \\n        int[] newArr = new  int[arr.length];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            newArr[i]=arr[i];\\n        }\\n       Arrays.sort(newArr);\\n        \\n       HashMap<Integer,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0,k=0;i<newArr.length;i++){\\n             if( hmap.containsKey(newArr[i])){\\n                hmap.put(newArr[i],hmap.get(newArr[i]));\\n            }\\n           else {\\n               hmap.put(newArr[i],k);\\n               k++;\\n           }  \\n         }\\n         for(int i=0;i<arr.length;i++){\\n           arr[i]=hmap.get(arr[i])+1;\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391509,
                "title": "python-simple-solution-rank-transform-of-an-array",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        if len(set(arr)) == 1:\\n            return [1]*len(arr)\\n        \\n        temp = copy.deepcopy(arr)\\n        temp.sort()\\n        \\n        d = {}\\n        rank = 0\\n        for i in range(len(temp)):\\n            if temp[i] not in d:\\n                rank = rank + 1\\n                d[temp[i]] = rank\\n                \\n        final = [0]*len(temp)\\n        \\n        for i in range(len(arr)):\\n            final[i] = d[arr[i]]\\n            \\n        return final",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        if len(set(arr)) == 1:\\n            return [1]*len(arr)\\n        \\n        temp = copy.deepcopy(arr)\\n        temp.sort()\\n        \\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1385504,
                "title": "javascript-o-nlogn",
                "content": "```\\nvar arrayRankTransform = function(arr) {\\n    const copy = arr.slice();\\n    copy.sort((a, b) => a-b);\\n    const map = {};\\n    let rank = 1;\\n    for (let i = 1; i < copy.length; i++) {\\n        map[copy[i-1]] = rank;\\n        rank = copy[i] > copy[i-1] ? rank + 1 : rank;\\n    }\\n    map[copy[copy.length-1]] = rank\\n    for (let i = 0; i < copy.length; i++) {\\n        arr[i] = map[arr[i]];\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n    const copy = arr.slice();\\n    copy.sort((a, b) => a-b);\\n    const map = {};\\n    let rank = 1;\\n    for (let i = 1; i < copy.length; i++) {\\n        map[copy[i-1]] = rank;\\n        rank = copy[i] > copy[i-1] ? rank + 1 : rank;\\n    }\\n    map[copy[copy.length-1]] = rank\\n    for (let i = 0; i < copy.length; i++) {\\n        arr[i] = map[arr[i]];\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275142,
                "title": "very-simple-python-faster-than-100-of-python-online-submissions",
                "content": "def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        a=list(sorted(set(arr)))\\n        p={}\\n        for i,j in enumerate(a):\\n            p[j]=i+1                        \\n        return [p[x] for x in arr]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "def arrayRankTransform(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        a=list(sorted(set(arr)))\\n        p={}\\n        for i,j in enumerate(a):\\n            p[j]=i+1                        \\n        return [p[x] for x in arr]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1240692,
                "title": "java-faster-than-99-hashmap-sorting",
                "content": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        if(arr.length==0) return new int[0];\\n        int temp[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++) \\n            temp[i]=arr[i];\\n        Arrays.sort(temp); //10,20,30,40 \\n        int rank[]=new int[arr.length];\\n        Map<Integer,Integer> ranks=new HashMap<>();\\n        int r=1;\\n        for(int i=0;i<temp.length;i++){\\n            if(i-1>=0 && temp[i]!=temp[i-1])\\n                ranks.put(temp[i],r=r+1);\\n            else if(i-1>=0 && temp[i]==temp[i-1])\\n                ranks.put(temp[i],r);  \\n            else\\n                ranks.put(temp[i],r); // 10 -> 1\\n        }\\n        for(int i=0;i<arr.length;i++)\\n            rank[i]=ranks.get(arr[i]);\\n        return rank;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayRankTransform(int[] arr) {\\n        if(arr.length==0) return new int[0];\\n        int temp[]=new int[arr.length];\\n        for(int i=0;i<arr.length;i++) \\n            temp[i]=arr[i];\\n        Arrays.sort(temp); //10,20,30,40 \\n        int rank[]=new int[arr.length];\\n        Map<Integer,Integer> ranks=new HashMap<>();\\n        int r=1;\\n        for(int i=0;i<temp.length;i++){\\n            if(i-1>=0 && temp[i]!=temp[i-1])\\n                ranks.put(temp[i],r=r+1);\\n            else if(i-1>=0 && temp[i]==temp[i-1])\\n                ranks.put(temp[i],r);  \\n            else\\n                ranks.put(temp[i],r); // 10 -> 1\\n        }\\n        for(int i=0;i<arr.length;i++)\\n            rank[i]=ranks.get(arr[i]);\\n        return rank;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222330,
                "title": "python3-nlogn-in-two-lines",
                "content": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = sorted(set(arr))\\n        return [bisect_left(ranks, x) + 1 for x in arr]\\n```",
                "solutionTags": [],
                "code": "```\\ndef arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        ranks = sorted(set(arr))\\n        return [bisect_left(ranks, x) + 1 for x in arr]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1216480,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        set<int>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        vector<int>vec;\\n        for(auto t : st)\\n        {\\n            vec.push_back(t);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int ind=lower_bound(vec.begin(),vec.end(),arr[i])-vec.begin();\\n            arr[i]=ind+1;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr)\\n    {\\n        set<int>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        vector<int>vec;\\n        for(auto t : st)\\n        {\\n            vec.push_back(t);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int ind=lower_bound(vec.begin(),vec.end(),arr[i])-vec.begin();\\n            arr[i]=ind+1;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212836,
                "title": "golang-solution-with-quick-walk-through",
                "content": "[1331. Rank Transform of an Array](https://leetcode.com/problems/rank-transform-of-an-array/)\\n\\nThe idea of this solution is to:\\n\\n* Copy `arr`.\\n* Then sort the copy\\n* Then loop through the copy and add all the values and indexes of the copy to a map called `m`.\\n* Then loop through `0` to `len(arr) - 1`, and make `arr[i] = m[arr[i]]`.\\n* Then return `arr`.\\n\\n``` go\\nfunc arrayRankTransform(arr []int) []int {\\n\\tg := make([]int, len(arr))\\n\\tm := make(map[int]int)\\n\\tcounter := 1\\n\\n\\tcopy(g, arr)\\n\\tsort.Ints(g)\\n\\n\\tfor i := range g {\\n\\t\\tif i >= 1 && g[i] == g[i-1] {\\n\\t\\t\\tcounter -= 1\\n\\t\\t}\\n\\t\\tm[g[i]] = counter\\n\\t\\tcounter++\\n\\t}\\n\\n\\tfor i := range arr {\\n\\t\\tarr[i] = m[arr[i]]\\n\\t}\\n\\n\\treturn arr\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc arrayRankTransform(arr []int) []int {\\n\\tg := make([]int, len(arr))\\n\\tm := make(map[int]int)\\n\\tcounter := 1\\n\\n\\tcopy(g, arr)\\n\\tsort.Ints(g)\\n\\n\\tfor i := range g {\\n\\t\\tif i >= 1 && g[i] == g[i-1] {\\n\\t\\t\\tcounter -= 1\\n\\t\\t}\\n\\t\\tm[g[i]] = counter\\n\\t\\tcounter++\\n\\t}\\n\\n\\tfor i := range arr {\\n\\t\\tarr[i] = m[arr[i]]\\n\\t}\\n\\n\\treturn arr\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187867,
                "title": "80ms-c-solution-using-maps-beats-82-19-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> original=arr;\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int,int> m;\\n        \\n        int rank=1;\\n        m[arr[0]]=rank;\\n        if(arr.size()>1){\\n          for(int i=1;i<arr.size();i++){\\n            if(arr[i]==arr[i-1]){\\n                m[arr[i]]=m[arr[i-1]];\\n            }else{\\n                rank+=1;\\n                m[arr[i]]=rank;\\n            }\\n        }  \\n        }\\n        \\n        vector<int> res;\\n        for(auto x:original){\\n            res.push_back(m[x]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if(arr.size()==0){\\n            return arr;\\n        }\\n        vector<int> original=arr;\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int,int> m;\\n        \\n        int rank=1;\\n        m[arr[0]]=rank;\\n        if(arr.size()>1){\\n          for(int i=1;i<arr.size();i++){\\n            if(arr[i]==arr[i-1]){\\n                m[arr[i]]=m[arr[i-1]];\\n            }else{\\n                rank+=1;\\n                m[arr[i]]=rank;\\n            }\\n        }  \\n        }\\n        \\n        vector<int> res;\\n        for(auto x:original){\\n            res.push_back(m[x]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140757,
                "title": "c-128ms-35-hashset-and-hashmap",
                "content": "Runtime: 128 ms, faster than 35.43% of C++ online submissions for Rank Transform of an Array.\\nMemory Usage: 46.2 MB, less than 17.86% of C++ online submissions for Rank Transform of an Array.\\n```\\nclass Solution {\\npublic:\\n  vector<int> arrayRankTransform(vector<int>& arr) {\\n    set<int>st(arr.begin(),arr.end());\\n    unordered_map<int,int> mp;\\n    int i = 0;\\n    \\n    for(auto &t : st) mp[t] = ++i;\\n    \\n    vector<int> answer(arr.size());\\n    for(i = 0 ; i != arr.size(); i++)\\n      answer[i] = mp[arr[i]];\\n    \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> arrayRankTransform(vector<int>& arr) {\\n    set<int>st(arr.begin(),arr.end());\\n    unordered_map<int,int> mp;\\n    int i = 0;\\n    \\n    for(auto &t : st) mp[t] = ++i;\\n    \\n    vector<int> answer(arr.size());\\n    for(i = 0 ; i != arr.size(); i++)\\n      answer[i] = mp[arr[i]];\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102554,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\t\\tunordered_map <int,int> m;\\n\\t\\t\\t\\tvector<int> temp = arr;\\n\\t\\t\\t\\tint rank = 1;\\n\\t\\t\\t\\tsort(temp.begin(),temp.end());\\n\\t\\t\\t\\tfor(int i = 0; i < temp.size();i++){\\n\\t\\t\\t\\t\\tif(m.find(temp[i]) == m.end()) {\\n\\t\\t\\t\\t\\t\\tm[temp[i]] = rank;\\n\\t\\t\\t\\t\\t\\trank++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto &val:arr){\\n\\t\\t\\t\\t\\tval = m[val];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn arr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayRankTransform(vector<int>& arr) {\\n\\t\\t\\t\\tunordered_map <int,int> m;\\n\\t\\t\\t\\tvector<int> temp = arr;\\n\\t\\t\\t\\tint rank = 1;\\n\\t\\t\\t\\tsort(temp.begin(),temp.end());\\n\\t\\t\\t\\tfor(int i = 0; i < temp.size();i++){\\n\\t\\t\\t\\t\\tif(m.find(temp[i]) == m.end()) {\\n\\t\\t\\t\\t\\t\\tm[temp[i]] = rank;\\n\\t\\t\\t\\t\\t\\trank++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1081958,
                "title": "python-4-lines-solution-98",
                "content": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        s = sorted(set(arr)) # to map 1,2, ..., N to array elements, we get sorted version of arr\\n        s = dict(zip(s, range(1,len(s)+1))) # now we have the rankings \\n        for i, val in enumerate(arr): # we can replace now.\\n            arr[i] = s[val]\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        s = sorted(set(arr)) # to map 1,2, ..., N to array elements, we get sorted version of arr\\n        s = dict(zip(s, range(1,len(s)+1))) # now we have the rankings \\n        for i, val in enumerate(arr): # we can replace now.\\n            arr[i] = s[val]\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1072073,
                "title": "c-sorting-distinct-values-2-18-2021",
                "content": "Feb. 18, 2021\\nThe idea is simple. First put all numbers in the array to a hashset, so all distinct values are saved. Next convert the hashset to a list, sort them in ascending order. Save all values and the order in a C# hashmap. Last, it is easy to figure out each number\\'s ranking based on C# hashmap. \\n\\n```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null || arr.Length == 0)\\n            return new int[0];\\n        \\n        var set = new HashSet<int>(arr);\\n        \\n        var list = set.ToList(); \\n        list.Sort(); \\n        var map = new Dictionary<int, int>(); \\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i + 1); \\n        }\\n        \\n        var length = arr.Length; \\n        var smallest = new int[length];\\n        for(int i = 0; i < length; i++)\\n        {\\n            smallest[i] = map[arr[i]];\\n        }\\n        \\n        return smallest; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ArrayRankTransform(int[] arr) {\\n        if(arr == null || arr.Length == 0)\\n            return new int[0];\\n        \\n        var set = new HashSet<int>(arr);\\n        \\n        var list = set.ToList(); \\n        list.Sort(); \\n        var map = new Dictionary<int, int>(); \\n        \\n        for(int i = 0; i < list.Count; i++)\\n        {\\n            map.Add(list[i], i + 1); \\n        }\\n        \\n        var length = arr.Length; \\n        var smallest = new int[length];\\n        for(int i = 0; i < length; i++)\\n        {\\n            smallest[i] = map[arr[i]];\\n        }\\n        \\n        return smallest; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971879,
                "title": "javascript-solution-with-explanation-using-sort-indexof-and-set",
                "content": "```\\nvar arrayRankTransform = function(arr) {\\n\\t//make a set of arr to remove duplicate\\n    var set = new Set(arr)\\n\\t//convert the set to new array\\n    let array = Array.from(set);\\n    //sort the array in ascending order\\n\\tvar sorted = [...array].sort((a,b) => a-b)\\n    var rank = []\\n    for(var i = 0; i < arr.length; i++){\\n\\t\\t//assign the rank or current arr element according to index position of the sorted arr\\n        rank[i] = sorted.indexOf(arr[i]) + 1\\n    }\\n    return rank\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayRankTransform = function(arr) {\\n\\t//make a set of arr to remove duplicate\\n    var set = new Set(arr)\\n\\t//convert the set to new array\\n    let array = Array.from(set);\\n    //sort the array in ascending order\\n\\tvar sorted = [...array].sort((a,b) => a-b)\\n    var rank = []\\n    for(var i = 0; i < arr.length; i++){\\n\\t\\t//assign the rank or current arr element according to index position of the sorted arr\\n        rank[i] = sorted.indexOf(arr[i]) + 1\\n    }\\n    return rank\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 962112,
                "title": "python-91-28-time-88-space",
                "content": "```\\nclass Solution(object):\\n    def arrayRankTransform(self, arr):\\n        rank = {}\\n        start = 1\\n        \\n        for each in sorted(arr):\\n            if each in rank:\\n                continue\\n            else:\\n                rank[each] = start\\n                start += 1\\n            \\n        return [rank[each] for each in arr]\\n        \\n        \\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def arrayRankTransform(self, arr):\\n        rank = {}",
                "codeTag": "Java"
            },
            {
                "id": 924345,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var dictionary = [Int : Int]()\\n        for case let element in arr {\\n            if let value = dictionary[element] {\\n                dictionary[element] = value + 1 \\n            } else {\\n                dictionary[element] = 1 \\n            }\\n        }\\n        var rankArray = dictionary.keys.sorted()\\n        var rankDict = [Int : Int]()\\n        var index = 0 \\n        while index < rankArray.count {\\n            rankDict[rankArray[index]] = index + 1\\n            index += 1\\n        }\\n        var result = [Int]()\\n        for case let element in arr {\\n            result.append(rankDict[element] ?? 1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func arrayRankTransform(_ arr: [Int]) -> [Int] {\\n        var dictionary = [Int : Int]()\\n        for case let element in arr {\\n            if let value = dictionary[element] {\\n                dictionary[element] = value + 1 \\n            } else {\\n                dictionary[element] = 1 \\n            }\\n        }\\n        var rankArray = dictionary.keys.sorted()\\n        var rankDict = [Int : Int]()\\n        var index = 0 \\n        while index < rankArray.count {\\n            rankDict[rankArray[index]] = index + 1\\n            index += 1\\n        }\\n        var result = [Int]()\\n        for case let element in arr {\\n            result.append(rankDict[element] ?? 1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891107,
                "title": "simple-fast-python-solution-using-set-and-dictionary",
                "content": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        srt = {}\\n        for i, val in enumerate(sorted(list(set(arr)))):\\n            srt[val] = i + 1\\n        return [srt[x] for x in arr]\\n```",
                "solutionTags": [],
                "code": "```\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        srt = {}\\n        for i, val in enumerate(sorted(list(set(arr)))):\\n            srt[val] = i + 1\\n        return [srt[x] for x in arr]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 885943,
                "title": "python-binary-search-solution-using-bisect",
                "content": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        temp = sorted(set(arr))\\n        op = []\\n        for n in arr:\\n            idx = bisect_left(temp, n)\\n            op.append(idx + 1)\\n        return op\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        temp = sorted(set(arr))\\n        op = []\\n        for n in arr:\\n            idx = bisect_left(temp, n)\\n            op.append(idx + 1)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872458,
                "title": "c-sort-unorderedmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if (arr.size() == 0) {\\n            return arr;\\n        }\\n        vector<int> arrUnsorted = arr;\\n        sort(arr.begin(), arr.end());\\n        int rank = 1;\\n        unordered_map<int, int> numRankMap;\\n        numRankMap[arr[0]] = rank;\\n        for (int i = 1; i < arr.size(); i++) {\\n            if (arr[i] != arr[i - 1]) {\\n                rank++;\\n            }\\n            numRankMap[arr[i]] = rank;\\n        }\\n        for (int i = 0; i < arrUnsorted.size(); i++) {\\n            arrUnsorted[i] = numRankMap[arrUnsorted[i]];\\n        }\\n        return arrUnsorted;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        if (arr.size() == 0) {\\n            return arr;\\n        }\\n        vector<int> arrUnsorted = arr;\\n        sort(arr.begin(), arr.end());\\n        int rank = 1;\\n        unordered_map<int, int> numRankMap;\\n        numRankMap[arr[0]] = rank;\\n        for (int i = 1; i < arr.size(); i++) {\\n            if (arr[i] != arr[i - 1]) {\\n                rank++;\\n            }\\n            numRankMap[arr[i]] = rank;\\n        }\\n        for (int i = 0; i < arrUnsorted.size(); i++) {\\n            arrUnsorted[i] = numRankMap[arrUnsorted[i]];\\n        }\\n        return arrUnsorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872266,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> v;\\n        set<int> s;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        vector<int> z=arr;\\n        map<int,int> m;\\n        int k=1;\\n        for(auto it=s.begin();it!=s.end();++it){\\n            m.insert({(*it),k++});\\n        }\\n        \\n        for(int i=0;i<z.size();i++){\\n        cout<<m[z[i]];\\n            v.push_back(m[z[i]]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int> v;\\n        set<int> s;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        vector<int> z=arr;\\n        map<int,int> m;\\n        int k=1;\\n        for(auto it=s.begin();it!=s.end();++it){\\n            m.insert({(*it),k++});\\n        }\\n        \\n        for(int i=0;i<z.size();i++){\\n        cout<<m[z[i]];\\n            v.push_back(m[z[i]]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1793538,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1792498,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963663,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574054,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573906,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2068086,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1977020,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963672,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1934717,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1930197,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793538,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1792498,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963663,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574054,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573906,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2068086,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1977020,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1963672,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1934717,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1930197,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "The second hint is technically incorrect. It should be \"The rank of each element is the number of UNIQUE elements smaller than it in the sorted array plus one.\" Good problem though."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Input = [40,10,10,20,30]\\nOutput=[4,1,1,2,3]\\n\\nIn my opinion, if two elements have rank 1, the next greatest element should have rank 3.\\n"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "no it will have rank 2"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "question seems inappropiately easy but i cant solve"
                    },
                    {
                        "username": "rakeshchandrasheker",
                        "content": "var arrayRankTransform = function(arr) {\\nlet unique = Array.from(new Set(arr)).sort((a,b)=>a-b);\\nlet hashMap = unique.reduce( (acc, cur, index) => {\\n  acc[cur] = index + 1;\\n  return acc;\\n}, {})\\n   return arr.map(item => item = hashMap[item])\\n};"
                    },
                    {
                        "username": "henrychen222",
                        "content": "![image](https://assets.leetcode.com/users/henrychen222/image_1591724998.png)\\n"
                    },
                    {
                        "username": "crytondre",
                        "content": "I don\\'t think this should be marked as an Easy Question"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": " could it be done in better than nlogn time"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "nice question just randomly assiging new array  lol."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Man I want to know how the best solution is of time O(n*logn) even my solution is O(n*logn) but people having better solutions in submissions.\n\nMy soln :-\n```\nclass Solution {\npublic:\n    vector<int> arrayRankTransform(vector<int>& arr) {\n        set<int>s;\n        unordered_map<int,int>m;\n        vector<int>rank;\n        int n = arr.size();\n\n        for(int i=0;i<n;i++) {\n            s.insert(arr[i]);\n        } \n\n        int j = 1;\n        for(auto i:s) {\n            m[i] = j;\n            j++;\n        }\n\n        for(int i=0;i<n;i++) {\n            rank.push_back(m[arr[i]]);\n        }\n\n        return rank;\n    }\n};\n```"
                    },
                    {
                        "username": "Paridhi77",
                        "content": "can someone pls help me with this...I am not able to get what is wrong with my solution!\\nclass Solution {\\npublic:\\n    vector<int> arrayRankTransform(vector<int>& arr) {\\n        vector<int>ans(arr.size());\\n        int cnt;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=0;\\n            for(int j=1;j<arr.size();j++){\\n                if(arr[i]>arr[j]){\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode XORed Permutation",
        "question_content": "<p>There is an integer array <code>perm</code> that is a permutation of the first <code>n</code> positive integers, where <code>n</code> is always <strong>odd</strong>.</p>\n\n<p>It was encoded into another integer array <code>encoded</code> of length <code>n - 1</code>, such that <code>encoded[i] = perm[i] XOR perm[i + 1]</code>. For example, if <code>perm = [1,3,2]</code>, then <code>encoded = [2,1]</code>.</p>\n\n<p>Given the <code>encoded</code> array, return <em>the original array</em> <code>perm</code>. It is guaranteed that the answer exists and is unique.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> encoded = [3,1]\n<strong>Output:</strong> [1,2,3]\n<strong>Explanation:</strong> If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> encoded = [6,5,4,6]\n<strong>Output:</strong> [2,4,1,5,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;&nbsp;10<sup>5</sup></code></li>\n\t<li><code>n</code>&nbsp;is odd.</li>\n\t<li><code>encoded.length == n - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1031107,
                "title": "java-c-python-straight-forward-solution",
                "content": "# **Intuition**\\nIf the first element is determined,\\nthe whole array can be decoded.\\n[1720. Decode XORed Array](https://leetcode.com/problems/decode-xored-array/discuss/1009844/)\\n\\nBut if we enumerate the first element,\\nthe overall complexity will be `O(n^2)`,\\nwhich will be TLE.\\n<br>\\n\\n# **Explanation**\\nWe make good use of the condition \"n is odd\" as follow\\n`a1,(a2,a3),(a4,a5).....`,\\nmaking the decoded into pairs.\\n`a2^a3 = A[1]`\\n`a4^a5 = A[3]`\\n`a6^a7 = A[5]`\\n...\\nso we can have the result of `a2^a3^a4...^an`.\\nAnd a1,a2,a3... is a permuatation of 1,2,3,4..n\\n\\nso we can have\\na1 = 1^2^3...^n^a2^a2^a3...^an\\n\\nThen we can deduct the whole decoded array.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int[] decode(int[] A) {\\n        int n = A.length + 1, a = 0, res[] = new int[n];\\n        for (int i = 0; i <= n; ++i) {\\n            a ^= i;\\n            if (i < n && i % 2 == 1) {\\n                a ^= A[i];\\n            }\\n        }\\n        res[0] = a;\\n        for (int i = 0; i < n - 1; ++i) {\\n            res[i + 1] = res[i] ^ A[i];\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> decode(vector<int>& A) {\\n        int n = A.size() + 1, a = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            a ^= i;\\n            if (i < n && i % 2 == 1) {\\n                a ^= A[i];\\n            }\\n        }\\n        vector<int> res = {a};\\n        for (int a: A) {\\n            res.push_back(res.back() ^ a);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def decode(self, A):\\n        first = reduce(ixor, A[::-2] + list(range(len(A) + 2)))\\n        return list(accumulate([first] + A, ixor))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] decode(int[] A) {\\n        int n = A.length + 1, a = 0, res[] = new int[n];\\n        for (int i = 0; i <= n; ++i) {\\n            a ^= i;\\n            if (i < n && i % 2 == 1) {\\n                a ^= A[i];\\n            }\\n        }\\n        res[0] = a;\\n        for (int i = 0; i < n - 1; ++i) {\\n            res[i + 1] = res[i] ^ A[i];\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> decode(vector<int>& A) {\\n        int n = A.size() + 1, a = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            a ^= i;\\n            if (i < n && i % 2 == 1) {\\n                a ^= A[i];\\n            }\\n        }\\n        vector<int> res = {a};\\n        for (int a: A) {\\n            res.push_back(res.back() ^ a);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def decode(self, A):\\n        first = reduce(ixor, A[::-2] + list(range(len(A) + 2)))\\n        return list(accumulate([first] + A, ixor))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1031840,
                "title": "explanations-xor-and-1st-element-java-kotlin-python",
                "content": "I was stuck in this seemingly easy question in [contest 44](https://leetcode.com/contest/biweekly-contest-44).  How could the answer be unique?\\n\\n**XOR properties and tips**\\n\\nLet\\'s note `xor` as xor instead of ^\\n**1) For `a xor b = c` , you can write \\n`b = c xor a` \\nor `a = c xor b`** . \\nYou can use 2) and 3) to demonstrate 1) .\\n2) XOR is commutative, `a xor b = b xor a`\\n3) XOR to the same number is always zero `a xor a = 0`\\n\\n\\n# **Intuition**\\nIf the first element is determined, the whole array can be decoded.\\n> `encoded[i] = perm[i] XOR perm[i + 1]` implies\\n\\n `perm[i+1] = perm[i] XOR encoded[i]` thanks to 1)\\n So you can loop to find the next perm element\\nSee [1720. Decode XORed Array](https://leetcode.com/problems/decode-xored-array/discuss/1009844)\\n\\nBut you still need `perm[0]` , the first element in output array.\\n\\n\\n\\n# **Find the first element**\\nThat\\'s where I was stuck in the contest 44.  How could the answer be unique?\\nIt took a while to understand after reading other solutions.\\n\\nI missed an important part in the problem descrition\\n> integer array `perm` that is a permutation of the **first `n` positive integers**,  where `n` is always odd.\\n\\nYes, perm is an array with values ranging from [1,2,3 .. n]. The order in the array is permuted.\\n\\nLet\\'s XOR all elements in array  `perm`. And perms is an array with **first `n` positive integers**\\n`perm[0] XOR perm[1] XOR ... perm[n] = 1 XOR 2 XOR 3 .. XOR n`  Order doesn\\'t matter, XOR is commutative.\\nLet\\'s call `totalXor`\\n`totalXor = 1 XOR 2 XOR 3 .. XOR n` .\\n\\nXOR all except the first `perm[0]`\\n`perm[0] = totalXor XOR perm[1] XOR perm[2] XOR  perm[3] XOR  perm[4] XOR ... perm[n]`\\n\\nLet\\'s subsitute (replace) by encoded\\n> encoded[i] = perm[i] XOR perm[i + 1]\\n\\nencoded[1] = perm[1] XOR perm[2]\\nencoded[3] = perm[3] XOR perm[4]\\n...\\nencoded[n-2] = perm[n-2] XOR perm[n-1], remember `n` is the size of perm and is always **odd**\\n\\n**`perm[0] = totalXor XOR encoded[1] XOR encoded[3] ... encoded[n-2] `**\\nOnly the odd indexes of `encoded` are taken.\\n\\n\\n\\n\\n## Solutions big O\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n## Java\\n```\\n    public int[] decode(int[] encoded) {\\n        int first = 0;\\n        int n = encoded.length+1;\\n        for(int i=1;i<=n;i++){\\n            first ^= i; \\n        }\\n        for(int i=1;i<n-1;i+=2) first ^= encoded[i];\\n        \\n        int[] perm = new int[n];\\n        perm[0] = first;\\n        for(int i=0;i<n-1;i++){\\n            perm[i+1] = perm[i] ^ encoded[i];\\n        }\\n        return perm;\\n    }\\n```\\n\\n## Kotlin\\n```\\n   fun decode(encoded: IntArray): IntArray {\\n        var first = 0\\n        val n = encoded.size + 1\\n        for(i in 1 .. n){\\n            first = first xor i\\n        }\\n        \\n        for(i in 1 until n step 2){\\n            first = first xor encoded[i]\\n        }\\n        \\n        val perm = IntArray(n)\\n        perm[0] = first\\n        for (i in 0 until n-1) {\\n            perm[i + 1] = perm[i] xor encoded[i]\\n        }\\n\\n        return perm\\n    }\\n```\\n\\n## Python\\n```\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        first = 0\\n        n = len(encoded) + 1\\n        for i in range(1,n+1):\\n            first = first ^ i\\n\\n        for i in range(1,n,2):\\n            first = first ^ encoded[i]\\n            \\n        \\n        perm = [0] * n\\n        perm[0] = first\\n        for i in range(n-1):\\n            perm[i+1] = perm[i] ^ encoded[i]\\n        return perm\\n```\\nNot a python pro, the code could be much shorter.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Kotlin"
                ],
                "code": "```\\n    public int[] decode(int[] encoded) {\\n        int first = 0;\\n        int n = encoded.length+1;\\n        for(int i=1;i<=n;i++){\\n            first ^= i; \\n        }\\n        for(int i=1;i<n-1;i+=2) first ^= encoded[i];\\n        \\n        int[] perm = new int[n];\\n        perm[0] = first;\\n        for(int i=0;i<n-1;i++){\\n            perm[i+1] = perm[i] ^ encoded[i];\\n        }\\n        return perm;\\n    }\\n```\n```\\n   fun decode(encoded: IntArray): IntArray {\\n        var first = 0\\n        val n = encoded.size + 1\\n        for(i in 1 .. n){\\n            first = first xor i\\n        }\\n        \\n        for(i in 1 until n step 2){\\n            first = first xor encoded[i]\\n        }\\n        \\n        val perm = IntArray(n)\\n        perm[0] = first\\n        for (i in 0 until n-1) {\\n            perm[i + 1] = perm[i] xor encoded[i]\\n        }\\n\\n        return perm\\n    }\\n```\n```\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        first = 0\\n        n = len(encoded) + 1\\n        for i in range(1,n+1):\\n            first = first ^ i\\n\\n        for i in range(1,n,2):\\n            first = first ^ encoded[i]\\n            \\n        \\n        perm = [0] * n\\n        perm[0] = first\\n        for i in range(n-1):\\n            perm[i+1] = perm[i] ^ encoded[i]\\n        return perm\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1031080,
                "title": "simple-solution-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/8ad353be-4297-4262-bd7e-e6a38ffbc3f6_1611474408.793708.png)\\n\\n\\nSimilar problem:\\n[1720.\\xA0Decode XORed Array](https://leetcode.com/problems/decode-xored-array/)\\nThe following is the code:\\n```cpp\\nclass Solution {\\npublic:\\n    int xorallel(int n) // XOR of all elements from 1 to N \\n    { \\n        switch (n & 3) \\n        { \\n            case 0: \\n                return n; \\n            case 1: \\n                return 1; \\n            case 2: \\n                return n + 1; \\n            case 3: \\n                return 0; \\n        } \\n        return 0;\\n    }\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> arr; \\n        int n = encoded.size() + 1;\\n        int xor_all = xorallel(n); \\n        int xor_adjacent = 0; \\n\\n        for (int i = 0; i < n - 1; i += 2) { \\n            xor_adjacent = xor_adjacent ^ encoded[i]; \\n        } \\n        int last_element = xor_all ^ xor_adjacent; \\n        arr.push_back(last_element); \\n\\n        for (int i = n - 2; i >= 0; i--) { \\n            last_element = encoded[i] ^ last_element; \\n            arr.push_back(last_element); \\n        } \\n\\n        return vector<int>(arr.rbegin(), arr.rend()); \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int xorallel(int n) // XOR of all elements from 1 to N \\n    { \\n        switch (n & 3) \\n        { \\n            case 0: \\n                return n; \\n            case 1: \\n                return 1; \\n            case 2: \\n                return n + 1; \\n            case 3: \\n                return 0; \\n        } \\n        return 0;\\n    }\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> arr; \\n        int n = encoded.size() + 1;\\n        int xor_all = xorallel(n); \\n        int xor_adjacent = 0; \\n\\n        for (int i = 0; i < n - 1; i += 2) { \\n            xor_adjacent = xor_adjacent ^ encoded[i]; \\n        } \\n        int last_element = xor_all ^ xor_adjacent; \\n        arr.push_back(last_element); \\n\\n        for (int i = n - 2; i >= 0; i--) { \\n            last_element = encoded[i] ^ last_element; \\n            arr.push_back(last_element); \\n        } \\n\\n        return vector<int>(arr.rbegin(), arr.rend()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502892,
                "title": "c-just-simple-observation-nothing-more",
                "content": "The question wanted you to play with XOR.  We will be using the fact that `x^x = 0` and `x^y = y^x`.\\nLets consider the 2nd example where `encoded = [6, 5, 4, 6]`. Now, our array will have 5 elements, let\\'s take them as `[a, b, c, d, e]`\\nNow,\\n```\\n[a^b,    b^c,   c^d,   d^e]\\t\\t\\n[ 6       5      4      6 ]\\n\\t\\t\\t\\t\\n```\\nNow, let us consider the XOR of all the permutation. Lets say it X. So, \\n```\\nX = a^b^c^d^e\\n```\\nJust add some brackets, and this X(better than mine \\uD83D\\uDE11) will become\\n```\\nX = a ^    (b^c)     ^   (d^e)\\nX = a ^ (encoded[1]) ^ (encoded[3])\\n\\n=> a = X ^ (encoded[1] ^ encoded[3])\\n```\\nWe can observe that `a`, which is the first number, is actually XOR of permutation `xored` to the odd positioned elements of encoded vector.\\n\\nThus, we can find the first number, and then from the first number, we can find the rest of them.\\nSince we have `a^b` and `a`, thus, `a^(a^b) = b`, then from `b` and `b^c`, we find c and so on. \\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size(), x = 0;\\n\\t\\t// XOR of the permutation\\n        for(int i = 1; i<=n+1; i++) x ^= i;\\n        \\n\\t\\t// Xoring X with all the odd positioned elements to find first number\\n        for(int i = 1; i<n; i+=2) x ^= encoded[i];\\n        \\n        vector <int> res;\\n        res.push_back(x);\\n        for(int i = 0; i<n; i++){\\n            x ^= encoded[i];\\n            res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n[a^b,    b^c,   c^d,   d^e]\\t\\t\\n[ 6       5      4      6 ]\\n\\t\\t\\t\\t\\n```\n```\\nX = a^b^c^d^e\\n```\n```\\nX = a ^    (b^c)     ^   (d^e)\\nX = a ^ (encoded[1]) ^ (encoded[3])\\n\\n=> a = X ^ (encoded[1] ^ encoded[3])\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size(), x = 0;\\n\\t\\t// XOR of the permutation\\n        for(int i = 1; i<=n+1; i++) x ^= i;\\n        \\n\\t\\t// Xoring X with all the odd positioned elements to find first number\\n        for(int i = 1; i<n; i+=2) x ^= encoded[i];\\n        \\n        vector <int> res;\\n        res.push_back(x);\\n        for(int i = 0; i<n; i++){\\n            x ^= encoded[i];\\n            res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069727,
                "title": "c-solution-with-clear-explanation",
                "content": "###  XOR Basic Rules\\nAt first, we need understand the following XOR rules\\n\\n1) `x^x = 0 ` \\n2) `0^x = x` \\n3) with the rule 1 and 2 , we can have: `x^x^y = y` . the element ocurrs twice would be removed.\\n4) if `x^y = z` , then `x = y^z` and `y = x^z`\\n\\n### XOR from 1 to n\\nSecondly, \\n\\nsuppose the `f(n)` is XOR from `1` to `n` , `f(n)  = 1^2^3^4^5 .... ^n` .\\nif the n is odd number, then we can observse the following things:\\n\\n- `f(1) = 1`\\n- `f(3) = 1^2^3 = 0`\\n- `f(5) = 1^2^3^4^5 = 1`\\n- `f(7) = 1^2^3^4^5^6^7 = 0`\\n- `f(9) = 1^2^3^4^5^6^7^8^9 = 1`\\n- ... ...\\n\\nso, `f(n) = [ (n-1)/2 + 1 ] % 2` - (n is odd number)\\n\\n### Solution\\n\\nWe know, \\n`encode = { (p1^p2),   (p2^p3),     (p3^p4),    ... }` - `p` is the permutation array \\n\\nso, if xor the odd index of `encoded[]` array,\\n- `encoded[1] = p2 ^ p3;`\\n- `encoded[3] = p4 ^ p5;`\\n- `encoded[5] = p6 ^ p7;`\\n- ......\\n \\n we can get:  `f(m) = p2 ^ p3 ^ p4 ...pn `, without the `p1`\\n\\nwith the XOR rule 3, we know\\n\\n`p1 = f(n) ^ f(m)`\\n\\nwith the XOR rule 4, we know `encoded[0] = p1^p2` then\\n`p2 = p1 ^ enclode[0]`\\n\\nSo,\\n\\n`p[i+1] = p[i] ^ enclode[i]`\\n\\n\\nThe source code as below:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        \\n        // f(n)  = 1^2^3^4^5 .... ^n ( n is odd number)\\n        int nxor = (encoded.size() / 2 + 1) % 2 ;\\n        \\n        // f(m) = p2^p3^p4....pn (without p1) \\n        int mxor = encoded[1];\\n        for (int i=3; i< encoded.size(); i+=2) {\\n            mxor ^= encoded[i];\\n        }\\n        \\n        // p[0] = f(n) ^ f(m) \\n        x = nxor ^ mxor;\\n        \\n        vector<int> result;\\n        result.push_back(x);\\n        \\n        // we know, encoded[i] = p[i] ^ p[i+1]\\n        // so, p[i+1] = p[i] ^ encoded[i]\\n        for (int i=0; i< encoded.size(); i++) {\\n            x = x ^ encoded[i];\\n            result.push_back(x);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        \\n        // f(n)  = 1^2^3^4^5 .... ^n ( n is odd number)\\n        int nxor = (encoded.size() / 2 + 1) % 2 ;\\n        \\n        // f(m) = p2^p3^p4....pn (without p1) \\n        int mxor = encoded[1];\\n        for (int i=3; i< encoded.size(); i+=2) {\\n            mxor ^= encoded[i];\\n        }\\n        \\n        // p[0] = f(n) ^ f(m) \\n        x = nxor ^ mxor;\\n        \\n        vector<int> result;\\n        result.push_back(x);\\n        \\n        // we know, encoded[i] = p[i] ^ p[i+1]\\n        // so, p[i+1] = p[i] ^ encoded[i]\\n        for (int i=0; i< encoded.size(); i++) {\\n            x = x ^ encoded[i];\\n            result.push_back(x);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280106,
                "title": "c-easy-solution-with-analysis",
                "content": "**Analysis:**\\n\\nLook at the given:\\n\\n```\\np0 ^ p1 = e0\\n\\np1 ^ p2 = e1\\n\\np2 ^ p3 = e2\\n\\np3 ^ p4 = e3\\n```\\n\\nMake the following observations:\\n\\n`p1 ^ p2 ... ^ pn = e1 ^ e3 ^ e5 ...`\\n\\nLet `x = p0 ^ p1 ^ p2 ... ^ pn`\\n\\nLet `e = e1 ^ e3 ^ e5 ...`\\n\\nObserve that `p0 ^ e = x`\\n\\nTherefore `p0 = e ^ x`\\n\\nOnce we have `p0`, use the relation to figure out the rest\\n\\n`perm[i] = perm[i-1] XOR encoded[i-1]`\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    std::vector<int> decode(std::vector<int>& encoded) {\\n        const int n = encoded.size() + 1;\\n\\n        int x = 0;\\n        for ( int i = 1; i <= n; ++i )\\n            x ^= i;\\n\\n        int e = 0;\\n        for ( int i = 1; i < encoded.size(); i += 2 )\\n            e ^= encoded[i];\\n\\n        int po = x ^ e;\\n\\n        std::vector<int> perm(n, 0);\\n\\n        perm[0] = po;\\n\\n        for ( int i = 1; i < n; ++i ) {\\n            perm[i] = perm[i-1] ^ encoded[i-1];\\n        }\\n\\n        return perm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\np0 ^ p1 = e0\\n\\np1 ^ p2 = e1\\n\\np2 ^ p3 = e2\\n\\np3 ^ p4 = e3\\n```\n```\\nclass Solution {\\npublic:\\n    std::vector<int> decode(std::vector<int>& encoded) {\\n        const int n = encoded.size() + 1;\\n\\n        int x = 0;\\n        for ( int i = 1; i <= n; ++i )\\n            x ^= i;\\n\\n        int e = 0;\\n        for ( int i = 1; i < encoded.size(); i += 2 )\\n            e ^= encoded[i];\\n\\n        int po = x ^ e;\\n\\n        std::vector<int> perm(n, 0);\\n\\n        perm[0] = po;\\n\\n        for ( int i = 1; i < n; ++i ) {\\n            perm[i] = perm[i-1] ^ encoded[i-1];\\n        }\\n\\n        return perm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031058,
                "title": "python3-simple-10-line-with-comments",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:        \\n        xor_all_elements, xor_except_last_element = 0, 0\\n        \\n        for val in range(1, len(encoded)+2): \\n            xor_all_elements ^= val\\n            \\n        for i, val in enumerate(encoded):\\n            if i%2: continue\\n            xor_except_last_element ^= val\\n        \\n        # xor_all_elements ^ xor_except_last_element = the last element of the original array\\n        ans = [xor_all_elements ^ xor_except_last_element]\\n        for val in encoded[::-1]:\\n            ans.append(ans[-1] ^ val)\\n        return ans[::-1]\\n            \\n        \\n  ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:        \\n        xor_all_elements, xor_except_last_element = 0, 0\\n        \\n        for val in range(1, len(encoded)+2): \\n            xor_all_elements ^= val\\n            \\n        for i, val in enumerate(encoded):\\n            if i%2: continue\\n            xor_except_last_element ^= val\\n        \\n        # xor_all_elements ^ xor_except_last_element = the last element of the original array\\n        ans = [xor_all_elements ^ xor_except_last_element]\\n        for val in encoded[::-1]:\\n            ans.append(ans[-1] ^ val)\\n        return ans[::-1]\\n            \\n        \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2075629,
                "title": "c-xor-observation",
                "content": "* **Key Observations->**\\n* `X ^ X = 0`. (XOR of two same numbers  == 0) and  `X ^ 0 = X`(XOR of  any number with 0 is number itself!).\\n* If we find the first element of the orignal array , call it `a` , then we can easily find out the whole array.How??\\n* Consider original array of odd size -> `[a,b,c,d,e]`, then its encoded form would be -> `[a^b , b^c , c^d , d^e]`.\\n* Now let\\'s say we know `a` , then second element `b` can be found out by-> `a` XOR `FirstElementOfEncoded`, or we can say `a ^ a ^ b`. (`a^a == 0` therefore result will be `b`).\\n* Similarly , now we know `b`, then `c` can be found out by-> `b` XOR `SecondElementOfEncoded`(`b^b^c == c`). Hence, all other elements an be found out. Ok This is Done, Now How to find the first element `a`??\\n* Take XOR (`totalXOR`) of all numbers from `1 to n` and then try to eliminate all the numbers except `a`(By elimination , I mean try to make other numbers zero by taking xor with themselves!) with the help of encoded array. You will Observe that this is only possible,  when we take XOR of `totalXOR` with odd indices of encoded array. In our Case , `a^b^c^d^e ^ (b^c) ^(d^e) == a`. Take a few more examples to convince yourself.\\n\\nSIMILAR PROBLEM- > [decode XORED array](https://leetcode.com/problems/decode-xored-array/)\\n```\\nclass Solution {\\npublic:\\n    vector<int>original ;\\n    \\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1 ;\\n        \\n        int totalXOR = 0 ;\\n        for(int i = 1 ; i <= n  ;++i ) totalXOR ^= i ;\\n        for(int i = 1 ; i < encoded.size(); i += 2) totalXOR ^= encoded[i] ; ///take XOR with odd indices\\n        int a = totalXOR ; //first element of the original array \\n        \\n        original.push_back(a) ;\\n        for(auto &x : encoded) original.push_back(original.back() ^ x) ;\\n        return original ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>original ;\\n    \\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1 ;\\n        \\n        int totalXOR = 0 ;\\n        for(int i = 1 ; i <= n  ;++i ) totalXOR ^= i ;\\n        for(int i = 1 ; i < encoded.size(); i += 2) totalXOR ^= encoded[i] ; ///take XOR with odd indices\\n        int a = totalXOR ; //first element of the original array \\n        \\n        original.push_back(a) ;\\n        for(auto &x : encoded) original.push_back(original.back() ^ x) ;\\n        return original ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701971,
                "title": "c-explaination-and-intuition",
                "content": "[https://leetcode.com/problems/decode-xored-array/](http://)\\nFirst prerequisite is this easy problem above.\\n\\nAfter doing this you already know that if we get to know even **one element** of the permutation array then we can **decode** the entire encoded array. But how to get that one lement.\\n\\nlet there be 4 elements in encoded. [6,5,4,6]\\nand encoded have 5 element a , b , c , d , e respectively\\nwe know:\\na^b = 6\\nb^c = 5\\nc^d = 4\\nd^e = 6\\n\\nif we xor all of them , it doesnt actually beneits us you can try.\\n1. But if we xor them by skipping an index it actually benefits us.\\n(a^b) ^(c^d)  . This way on xoring we get xor of all elements except the last.\\n\\n2. We can easily get  xor of  all elements from 1 to n+1 (n=size of encoded) . \\n\\nIf we xor the results from point1 and point2 we will get the last element of encoded array.\\nas same same elements will xor themselves to zero.\\n\\n\\nFrom here you can easily solve ahead . Hope it helps\\nPlease upvote.\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\nvector<int> decode(vector<int>& encoded) {\\n\\n    int n = encoded.size();\\n\\n    int temp = 0;\\n    for (int i = 0; i < n ; i += 2) {\\n        temp = temp ^ encoded[i];\\n    }\\n    for (int i = 1; i <= n + 1; i++) {\\n        temp = temp ^ i;\\n    }\\n\\n    vector<int> ans;\\n    ans.push_back(temp);\\n\\n    int j = n - 1;\\n    while (j >= 0) {\\n        ans.push_back(ans[ans.size() - 1] ^ encoded[j--]);\\n    }\\n\\n    reverse(ans.begin(), ans.end());\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> decode(vector<int>& encoded) {\\n\\n    int n = encoded.size();\\n\\n    int temp = 0;\\n    for (int i = 0; i < n ; i += 2) {\\n        temp = temp ^ encoded[i];\\n    }\\n    for (int i = 1; i <= n + 1; i++) {\\n        temp = temp ^ i;\\n    }\\n\\n    vector<int> ans;\\n    ans.push_back(temp);\\n\\n    int j = n - 1;\\n    while (j >= 0) {\\n        ans.push_back(ans[ans.size() - 1] ^ encoded[j--]);\\n    }\\n\\n    reverse(ans.begin(), ans.end());\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265186,
                "title": "easy-and-very-detailed-solution-with-comments-beats-100-in-java",
                "content": "**Please Upvote if you liked the post**\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        /* The main logic here is to find Permutation 0th element because after\\n        that i can easily find all elements using the relationship given that is\\n        encoded[i] = perm[i] XOR perm[i + 1] for ex\\n        \\n        let us say we found perm[0] by any means , let us assume then\\n        encoded[0] = perm[0] ^ per[1];\\n        taking xor both sides by per[0]\\n        encoded[0] ^ per[0] = perm[1];\\n        that is  perm[1] = perm[0] ^ encoded[0];\\n        so general formula becomes\\n        \\n        perm[i] = perm[i - 1] ^ encoded[i - 1];\\n        \\n        Now the question arises how to find permutation[0]. so we will do it\\n        like this\\n        \\n        first find out xor of all numbers from 1 to n , let it be x\\n        x = 1 ^ 2 ^ 3 ..... n (it contains all elements of permuation array)\\n        \\n        now if we see\\n        encoded[1] = perm[1] ^ perm[2];\\n        encoded[3] = perm[3] ^ perm[4];\\n        encoded[5] = perm[5] ^ perm[6];\\n        so xor of all odd index encoded array gives us the complete permuation array\\n        elements xor except that of perm[0], and x has xor of all elements of permut\\n        array including perm[0] . so if we xor x with all odd indices ecoded elements\\n        i will get the permuation[0] element.\\n        */\\n        \\n        int length = encoded.length;\\n        \\n        int x = 0;  //will contain xor of all elements of permuatation except of\\n                    //permutation[0]\\n        for(int i = 1 ;i<= length + 1;i++){\\n            x ^= i;\\n        }\\n        \\n        int x2 = 0; //will contain xor of all elements of permutation\\n        \\n        for(int i = 1;i<length;i += 2){\\n            x2 ^= encoded[i];\\n        }\\n        \\n        int [] permut = new int[length + 1];\\n        permut[0] = x ^ x2;\\n        \\n        for(int i = 0;i< length;i++){\\n            permut[i + 1] = permut[i] ^ encoded[i];\\n        }\\n        \\n        return permut;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        /* The main logic here is to find Permutation 0th element because after\\n        that i can easily find all elements using the relationship given that is\\n        encoded[i] = perm[i] XOR perm[i + 1] for ex\\n        \\n        let us say we found perm[0] by any means , let us assume then\\n        encoded[0] = perm[0] ^ per[1];\\n        taking xor both sides by per[0]\\n        encoded[0] ^ per[0] = perm[1];\\n        that is  perm[1] = perm[0] ^ encoded[0];\\n        so general formula becomes\\n        \\n        perm[i] = perm[i - 1] ^ encoded[i - 1];\\n        \\n        Now the question arises how to find permutation[0]. so we will do it\\n        like this\\n        \\n        first find out xor of all numbers from 1 to n , let it be x\\n        x = 1 ^ 2 ^ 3 ..... n (it contains all elements of permuation array)\\n        \\n        now if we see\\n        encoded[1] = perm[1] ^ perm[2];\\n        encoded[3] = perm[3] ^ perm[4];\\n        encoded[5] = perm[5] ^ perm[6];\\n        so xor of all odd index encoded array gives us the complete permuation array\\n        elements xor except that of perm[0], and x has xor of all elements of permut\\n        array including perm[0] . so if we xor x with all odd indices ecoded elements\\n        i will get the permuation[0] element.\\n        */\\n        \\n        int length = encoded.length;\\n        \\n        int x = 0;  //will contain xor of all elements of permuatation except of\\n                    //permutation[0]\\n        for(int i = 1 ;i<= length + 1;i++){\\n            x ^= i;\\n        }\\n        \\n        int x2 = 0; //will contain xor of all elements of permutation\\n        \\n        for(int i = 1;i<length;i += 2){\\n            x2 ^= encoded[i];\\n        }\\n        \\n        int [] permut = new int[length + 1];\\n        permut[0] = x ^ x2;\\n        \\n        for(int i = 0;i< length;i++){\\n            permut[i + 1] = permut[i] ^ encoded[i];\\n        }\\n        \\n        return permut;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031645,
                "title": "c-simple-solution",
                "content": "eg. 2, 4, 1, 5, 3\\nand we are given (2 ^ 4) (4 ^ 1) (1 ^ 5) (5 ^ 3)\\n\\nWe can find out xor with each element in the array by xoring elements in encoded array.\\n\\n(2 ^ 4) - encoded[0]\\n(2 ^ 1) - encoded[0] ^ encoded[1]\\n(2 ^ 5) - encoded[0] ^ encoded[1] ^ encoded[2]\\n(2 ^ 3) - encoded[0] ^ encoded[1] ^ encoded[2] ^ encoded[3]\\n\\nNow, If we XOR (2 ^ 4) (2 ^ 1) (2 ^ 5) (2 ^ 3) together we get (1 ^ 3 ^ 4 ^ 5), now we XOR elements from (1 - 5) [as this is the given range of elements] \\n\\n(1 ^ 3 ^ 4 ^ 5) ^ (1 ^ 3 ^ 4 ^ 5 ^ 2) = 2 (First Number)\\n\\nWe can easily generate the array using first number 2.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        int firstNum = 0, cumulativeXor = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            cumulativeXor = cumulativeXor ^ encoded[i];\\n            firstNum = firstNum ^ cumulativeXor;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) firstNum = firstNum ^ i;\\n\\n        vector<int> result;\\n        result.push_back(firstNum);\\n        int prev = firstNum;\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            int tmp = prev ^ encoded[i];\\n            result.push_back(tmp);\\n            prev = tmp;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        int firstNum = 0, cumulativeXor = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            cumulativeXor = cumulativeXor ^ encoded[i];\\n            firstNum = firstNum ^ cumulativeXor;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) firstNum = firstNum ^ i;\\n\\n        vector<int> result;\\n        result.push_back(firstNum);\\n        int prev = firstNum;\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            int tmp = prev ^ encoded[i];\\n            result.push_back(tmp);\\n            prev = tmp;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031069,
                "title": "clean-python-3-o-n",
                "content": "Get start element by xor all pairs we can obtained in `encoded` list, and xor from `1` to `len(encoded) + 1`.\\n\\nFor example, original `[2, 4, 1, 5, 3]`:\\nAfter iterating `encoded` list, we have `2 ^ 4`, `2 ^ 1`, `2 ^ 5`, `2 ^ 3` in hand.\\nAnd we can get `1 ^ 2 ^ 3 ^ 4 ^ 5` by problem definition.\\nSo `(2 ^ 4) ^ (2 ^ 1) ^ (2 ^ 5) ^ (2 ^ 3) ^ (1 ^ 2 ^ 3 ^ 4 ^ 5) = 2`, which is the start element.\\n\\nTime: `O(N)`\\nSpace: `O(N)` for output\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        start = 0\\n        for i in range(1, len(encoded) + 2):\\n            start ^= i\\n        curr = 0\\n        for encode in encoded:\\n            curr ^= encode\\n            start ^= curr\\n        result = [start]\\n        for encode in encoded:\\n            result.append(encode ^ result[-1])\\n        return result\\n```\\n\\nTwo passes version:\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        start, curr = 1, 0\\n        for i, encode in enumerate(encoded, 2):\\n            curr ^= encode\\n            start ^= curr ^ i\\n        result = [start]\\n        for encode in encoded:\\n            result.append(encode ^ result[-1])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        start = 0\\n        for i in range(1, len(encoded) + 2):\\n            start ^= i\\n        curr = 0\\n        for encode in encoded:\\n            curr ^= encode\\n            start ^= curr\\n        result = [start]\\n        for encode in encoded:\\n            result.append(encode ^ result[-1])\\n        return result\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        start, curr = 1, 0\\n        for i, encode in enumerate(encoded, 2):\\n            curr ^= encode\\n            start ^= curr ^ i\\n        result = [start]\\n        for encode in encoded:\\n            result.append(encode ^ result[-1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088096,
                "title": "explanation-and-python-solution",
                "content": "We use a few of nice properties of XOR:\\n\\n1. It is _associative_. That is, `(a XOR b) XOR c` is the same as `a XOR (b XOR c)`.\\n2. It is _commutative_. That is, `a XOR b = b XOR a`.\\n2. It _is its own inverse_. That is, if `a XOR b = c` then `a XOR c = b`.\\n\\nProperties 2 and 3 mean that if we know `a XOR b = c` and we know two of the values, we can find the third value by XORing the two values that we have. So if we can just figure out the _first_ value in the decoded array, then the rest will fall like dominoes:\\n\\n```text\\ndecoded:  x[0], x[1], x[2], ..., x[n-2], x[n-1]\\n\\t\\t\\t \\\\  /  \\\\  /             \\\\     /\\nencoded:     y[0], y[1],    ...,     y[n-2]\\n\\nx[1] = x[0] XOR y[0]\\nx[2] = x[1] XOR y[1]\\nx[3] = x[2] XOR y[2]\\n...\\n```\\n\\nHow do we find `x[0]`? We know the XOR of the entire decoded array, as it comprises the first `n` positive numbers: \\n```text\\na = 1 XOR 2 XOR ... XOR n\\n```\\nWe can use property 1 to figure out the XOR of all but the first number of the decoded array:\\n```text\\nb =  x[1] XOR x[2]  XOR  x[3] XOR x[4]  XOR ... XOR  x[n-2] XOR x[n-1]\\n  = (x[1] XOR x[2]) XOR (x[3] XOR x[4]) XOR ... XOR (x[n-2] XOR x[n-1])\\n  =       y[1]      XOR       y[3]      XOR ... XOR       y[n-2]\\n```\\nIt works out nicely because we\\'re told that `n` is odd.\\n\\nNow we have `a`, `b`, and `x[0] XOR b = a`, so we can deduce `x[0] = a XOR b`.\\n\\n# Python Solution\\n\\n```python\\nfrom functools  import reduce\\nfrom operator   import xor\\n\\nclass Solution:\\n    \\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        a = reduce(xor, range(1, n+1))\\n        b = reduce(xor, encoded[1::2])\\n        result = [a ^ b]\\n        for y in encoded:\\n            result.append(result[-1] ^ y)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```text\\ndecoded:  x[0], x[1], x[2], ..., x[n-2], x[n-1]\\n\\t\\t\\t \\\\  /  \\\\  /             \\\\     /\\nencoded:     y[0], y[1],    ...,     y[n-2]\\n\\nx[1] = x[0] XOR y[0]\\nx[2] = x[1] XOR y[1]\\nx[3] = x[2] XOR y[2]\\n...\\n```\n```text\\na = 1 XOR 2 XOR ... XOR n\\n```\n```text\\nb =  x[1] XOR x[2]  XOR  x[3] XOR x[4]  XOR ... XOR  x[n-2] XOR x[n-1]\\n  = (x[1] XOR x[2]) XOR (x[3] XOR x[4]) XOR ... XOR (x[n-2] XOR x[n-1])\\n  =       y[1]      XOR       y[3]      XOR ... XOR       y[n-2]\\n```\n```python\\nfrom functools  import reduce\\nfrom operator   import xor\\n\\nclass Solution:\\n    \\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        a = reduce(xor, range(1, n+1))\\n        b = reduce(xor, encoded[1::2])\\n        result = [a ^ b]\\n        for y in encoded:\\n            result.append(result[-1] ^ y)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031202,
                "title": "immediately-understand-it-through-an-example",
                "content": "For the following example, if we have n as 7, and suppose the perm is\\n```\\n[1, 2, 3, 4, 5, 6, 7]\\n```\\nwe will have encoded as\\n\\n[1 xor 2, **2 xor 3**, 3 xor 4, **4 xor 5**, 5 xor 6,    **6 xor 7**]\\n\\nIf we pick up the bolded ones, we will have\\n```\\n2 xor 3 xor 4 xor 5 xor 6 xor 7\\n```\\nSo if we do this operation, we will get 1\\n```\\n(2 xor 3 xor 4 xor 5 xor 6 xor 7) xor (1 xor 2 xor 3 xor 4 xor 5 xor 6 xor 7) = 1\\n```\\nActually, we can replace the 1 as the first element of the result. This is the critical part. If we know the first element of the result, we are done.\\n\\nAlso, from the example, we can see if we set n as an even number, we can not find the first element easily.\\n\\nExplanation and code can be found [here](https://jimmy-shen.medium.com/xor-608ddf279f5f)",
                "solutionTags": [],
                "code": "```\\n[1, 2, 3, 4, 5, 6, 7]\\n```\n```\\n2 xor 3 xor 4 xor 5 xor 6 xor 7\\n```\n```\\n(2 xor 3 xor 4 xor 5 xor 6 xor 7) xor (1 xor 2 xor 3 xor 4 xor 5 xor 6 xor 7) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031203,
                "title": "c-6-liners-o-n-solution-with-explanation-and-example",
                "content": "Idea:\\n1. Each consecutive pairs of integer will have an xor of 1 starts from 2\\n->eg. 2^3=1, 4^5=1, 5^6=1\\n2. The xor 1 is 1, 1~3 is 0, 1~5 is 1, 1~7 is 0 and so on (because of  previous observation)\\n3. We can find result[0] with this observation\\n\\nExample:\\nfor 5 items: a[0],a[1],a[2],a[3],a[4]\\n1. the encoded array is [a[0]^a[1],a[1]^a[2],a[2]^a[3],a[3]^a[4]]\\n2. the xor of all odd pairs (index 1 and 3) of encoded array will be a[1]^a[2]^a[3]^a[4] (xor of all items except a[0])\\n3. we know that all 5 items have an xor of 1\\n->xor step 2 and step 3, we can get a[0]\\n\\nresult[0] should be 1-(n/2)%2 because:\\nif n/2%2 is 1, then there are 2,6,10,......items in encoded array (3,7,11,...... items in decoded array), the xor for them is 0\\nif n/2%2 is 0, then there are 4,8,12,......items in encoded array (5,9,13,...... items in decoded array), the xor for them is 1\\n```\\nvector<int> decode(vector<int>& encoded) \\n{\\n\\tint n=encoded.size();\\n\\tvector<int> result(n+1);\\n\\tresult[0]=1-(n/2)%2;\\n\\tfor(int i=1;i<n;i+=2) result[0]^=encoded[i]; // get the first number\\n\\tfor(int i=1;i<=n;i++) result[i]=result[i-1]^encoded[i-1]; // get the following numbers\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decode(vector<int>& encoded) \\n{\\n\\tint n=encoded.size();\\n\\tvector<int> result(n+1);\\n\\tresult[0]=1-(n/2)%2;\\n\\tfor(int i=1;i<n;i+=2) result[0]^=encoded[i]; // get the first number\\n\\tfor(int i=1;i<=n;i++) result[i]=result[i-1]^encoded[i-1]; // get the following numbers\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782337,
                "title": "python-3-4-lines-w-example-t-m-94-12",
                "content": "It helps to recall that the xor operator is commutative and associative, and that (a^b)^b = a\\n\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:  # acc1: xor of [1... n]\\n                                                        # acc2: xor of [1...,k-1, k+1,... n], where k is \\n        n, acc2 = len(encoded), 0                       # the last element of the answer\\n\\n                                                        #   Ex: encoded = [6,5,4,6]\\n\\n        acc1 = reduce(lambda x, y: x^y,range(1, n+2))   # acc1 = xor([1,2,3,4,5]) = 1^2^3^4^5 = 1\\n       \\n        for i in range(0,n,2): acc2 ^= encoded[i]       # acc2 = xor([6,4]) = 6^4 = 2\\n  \\n        return list(accumulate(encoded[::-1],           # acc1 ^ acc2 = 1^2 = 3;  return [2, 4, 1, 5, 3]\\n                    xor, initial = acc1^acc2))[::-1]\\n```\\n[https://leetcode.com/submissions/detail/837544369/](http://)\\n\\n I could be wrong, but I think it\\'s *O*(*n*) / *O*(*n*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:  # acc1: xor of [1... n]\\n                                                        # acc2: xor of [1...,k-1, k+1,... n], where k is \\n        n, acc2 = len(encoded), 0                       # the last element of the answer\\n\\n                                                        #   Ex: encoded = [6,5,4,6]\\n\\n        acc1 = reduce(lambda x, y: x^y,range(1, n+2))   # acc1 = xor([1,2,3,4,5]) = 1^2^3^4^5 = 1\\n       \\n        for i in range(0,n,2): acc2 ^= encoded[i]       # acc2 = xor([6,4]) = 6^4 = 2\\n  \\n        return list(accumulate(encoded[::-1],           # acc1 ^ acc2 = 1^2 = 3;  return [2, 4, 1, 5, 3]\\n                    xor, initial = acc1^acc2))[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031147,
                "title": "python-3-bit-manipulation-1-line-o-n",
                "content": "- It is obvious ```a ^ a = 0```. So we should use it.\\n- Original permutation is ```a,b,c,d...y```. Encoded list is ```a^b, b^c, c^d, d^e \\u2026 x^y```. So if we know ```a``` (first original element) we can XOR ```a``` and ```a^b``` (first encoded element) and get ```b``` and etc. we can get all rest elements.\\n- We can XOR all odd encoded elements and get ```b^c ^ d^e ^\\u2026^ x^y```. So we get XOR sum of all elements except first ```a```.\\n- We can just XOR all numbers in the permutation ```a^b^c^d^\\u2026^y``` (ascending order, not permuting order). If we XOR it with previous sum we get ```a``` and can start iterating to get other elements.\\n\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded); s = 0\\n        for i in range(1, n, 2):\\n            s ^= encoded[i]\\n            \\n        for i in range(1, n+2):\\n            s ^= i\\n            \\n        ret = [s] + [0]*n\\n        for i in range(n):\\n            ret[i+1] = ret[i] ^ encoded[i]\\n            \\n        return ret\\n```\\n# The same algorithm with functional approach\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        return accumulate(encoded, xor, initial=reduce(xor, encoded[1::2]) ^ reduce(xor, range(len(encoded)+2)))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```a ^ a = 0```\n```a,b,c,d...y```\n```a^b, b^c, c^d, d^e \\u2026 x^y```\n```a```\n```a```\n```a^b```\n```b```\n```b^c ^ d^e ^\\u2026^ x^y```\n```a```\n```a^b^c^d^\\u2026^y```\n```a```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded); s = 0\\n        for i in range(1, n, 2):\\n            s ^= encoded[i]\\n            \\n        for i in range(1, n+2):\\n            s ^= i\\n            \\n        ret = [s] + [0]*n\\n        for i in range(n):\\n            ret[i+1] = ret[i] ^ encoded[i]\\n            \\n        return ret\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        return accumulate(encoded, xor, initial=reduce(xor, encoded[1::2]) ^ reduce(xor, range(len(encoded)+2)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031087,
                "title": "12-liner-easy-to-understand-beats-100-java-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& e) {\\n        int n=e.size()+1;\\n        \\n        int f=0;\\n        for(int i=0;i<e.size();i++)\\n        {\\n            f=f^e[i];\\n        }\\n        vector<int> dp(n,0);\\n        \\n        dp[0]=f;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]^e[i-1];\\n            \\n        }\\n        int x=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            x=x^dp[i];\\n        }\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s=s^i;\\n        }\\n        int last=s^x;\\n        \\n        vector<int> ans(n,0);\\n        \\n        ans[n-1]=last;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            ans[i]=ans[i+1]^e[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& e) {\\n        int n=e.size()+1;\\n        \\n        int f=0;\\n        for(int i=0;i<e.size();i++)\\n        {\\n            f=f^e[i];\\n        }\\n        vector<int> dp(n,0);\\n        \\n        dp[0]=f;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]^e[i-1];\\n            \\n        }\\n        int x=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            x=x^dp[i];\\n        }\\n        int s=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s=s^i;\\n        }\\n        int last=s^x;\\n        \\n        vector<int> ans(n,0);\\n        \\n        ans[n-1]=last;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            ans[i]=ans[i+1]^e[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031070,
                "title": "java-find-middle",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length+1, all = 0;\\n        for(int i = 1; i <= n; ++i){//a^b^c^d^e^f^g^h^i\\n            all ^= i;\\n        }\\n        int x = 0;\\n        for(int v : encoded){//a^b  b^c  c^d  d^e e^f f^g g^h h^i = a^i\\n            x ^= v;\\n        }\\n        int mid = all^x; //a^b^c^d^e^f^g^h^i ^ a^i = b^c^d^e^f^g^h\\n        for(int i = 1, j = encoded.length-2; i < j;i += 2, j -= 2){\\n        //(b^c^d^e^f^g^h) ^ (b^c ^ g^h ^ d^e ^ e^f) = e\\n            mid ^= encoded[i]^encoded[j];\\n        }\\n        int[] ans = new int[n];\\n        ans[n/2] = mid;\\n        //a    b    c    d   e   f   g   h   i\\n        //a^b  b^c  c^d  d^e e^f f^g g^h h^i\\n        for(int i = n/2+1; i < n; ++i){\\n            ans[i] = encoded[i-1]^ans[i-1];\\n        }\\n        for(int i = n/2-1; i >= 0; --i){\\n            ans[i] = encoded[i]^ans[i+1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length+1, all = 0;\\n        for(int i = 1; i <= n; ++i){//a^b^c^d^e^f^g^h^i\\n            all ^= i;\\n        }\\n        int x = 0;\\n        for(int v : encoded){//a^b  b^c  c^d  d^e e^f f^g g^h h^i = a^i\\n            x ^= v;\\n        }\\n        int mid = all^x; //a^b^c^d^e^f^g^h^i ^ a^i = b^c^d^e^f^g^h\\n        for(int i = 1, j = encoded.length-2; i < j;i += 2, j -= 2){\\n        //(b^c^d^e^f^g^h) ^ (b^c ^ g^h ^ d^e ^ e^f) = e\\n            mid ^= encoded[i]^encoded[j];\\n        }\\n        int[] ans = new int[n];\\n        ans[n/2] = mid;\\n        //a    b    c    d   e   f   g   h   i\\n        //a^b  b^c  c^d  d^e e^f f^g g^h h^i\\n        for(int i = n/2+1; i < n; ++i){\\n            ans[i] = encoded[i-1]^ans[i-1];\\n        }\\n        for(int i = n/2-1; i >= 0; --i){\\n            ans[i] = encoded[i]^ans[i+1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211949,
                "title": "c-all-about-observations-and-reading-details",
                "content": "# Intuition\\nIt\\'s all about observations\\n\\n1/  p1 ^ p2 = e1\\n    p2 ^ p3 = e2\\n    e1 ^ e2 = p1^p3\\n    that way we can get all p1 ^ pi for i in [2, n]\\n    p1^p2 = e1\\n    p1^p3 = e1^e2\\n    p1^p4 = e1^e2^e3\\n    ....\\n    p1^pn = XOR of all elements (equation 1)\\n\\n2/  we also know that the elements of perm are from 1 to n\\n    so we know p1^p2...^pn = 1^2^3...^n (equation 2)\\n\\n3/  n is **odd**, so in (equation 1), the number of lines is even, so if we do ^ of all the lines, p1^p1 will be done even times and reduced to 0, and now \\n    p2^p3^...^pn is know (equation 1)\\n\\n4/ p1 = (1)^(2)\\n5/ get all pi from encodes\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        int t1 = 0;\\n        int n = v.size();\\n        for (int i=0 ; i<=n ; i++)\\n            t1 = t1^(i+1);\\n\\n        int t2 = 0;\\n        int prev = 0;\\n        for (auto a:v)\\n        {\\n            prev = prev^a;\\n            t2 = t2^prev;\\n        }\\n\\n        int p = t1^t2;\\n        vector<int> ans;\\n        ans.push_back(p);\\n        for (int i=0 ; i<n ; i++)\\n        {\\n            p = v[i]^p;\\n            ans.push_back(p);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        int t1 = 0;\\n        int n = v.size();\\n        for (int i=0 ; i<=n ; i++)\\n            t1 = t1^(i+1);\\n\\n        int t2 = 0;\\n        int prev = 0;\\n        for (auto a:v)\\n        {\\n            prev = prev^a;\\n            t2 = t2^prev;\\n        }\\n\\n        int p = t1^t2;\\n        vector<int> ans;\\n        ans.push_back(p);\\n        for (int i=0 ; i<n ; i++)\\n        {\\n            p = v[i]^p;\\n            ans.push_back(p);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169242,
                "title": "80-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        int x = 0;\\n        for(auto &i: v)\\n            x = (x^i);\\n        // cout<<x<<\" \";\\n        vector<int> tmp = v;\\n        for(int i = 1; i < v.size(); i++){\\n            tmp[i] = (tmp[i-1]^v[i]);\\n        }\\n        for(int i = 1; i<= v.size()+1; i++){\\n            if(i <= v.size()){\\n                x = (x^tmp[i-1]);\\n            }\\n            // cout<<x<<\" \";\\n            x ^= i;\\n        }\\n        // cout<<x;\\n        vector<int> ans = {x};\\n        for(int i = v.size()-1; i>= 0; i--){\\n            ans.push_back(ans.back()^v[i]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        int x = 0;\\n        for(auto &i: v)\\n            x = (x^i);\\n        // cout<<x<<\" \";\\n        vector<int> tmp = v;\\n        for(int i = 1; i < v.size(); i++){\\n            tmp[i] = (tmp[i-1]^v[i]);\\n        }\\n        for(int i = 1; i<= v.size()+1; i++){\\n            if(i <= v.size()){\\n                x = (x^tmp[i-1]);\\n            }\\n            // cout<<x<<\" \";\\n            x ^= i;\\n        }\\n        // cout<<x;\\n        vector<int> ans = {x};\\n        for(int i = v.size()-1; i>= 0; i--){\\n            ans.push_back(ans.back()^v[i]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1515053,
                "title": "easy-solution-with-figures-and-explanation",
                "content": "This solution does require a lit bit of familiarity with bit wise operations, otherwise it might be hard to think of the solution, but the encoded array does give you a hint on how you should be thinking.\\n\\nWe\\'re given that the original array will always contain ```1 ... n``` (in some arbitrary order), with ```n``` being odd.\\n\\nSo, let\\'s take an example of ```1, 2, 3, 4, 5```\\n\\nIf we take xor of all elements from ```1 ... 5 ```, we have the following\\n\\n![image](https://assets.leetcode.com/users/images/3d8000a0-afc3-414f-8a6f-736306e9ff93_1633899260.3070457.png)\\n\\nWe\\'re given an encoded array formed with xor of two elements at a time for the above array\\n\\n![image](https://assets.leetcode.com/users/images/e8df04cb-8e37-4f5c-a143-35152b1cce6c_1633899031.1095047.png)\\n\\nXor has the property that an element xored with itself will be 0, so using that, we can easily get the first element of the original array.\\nFor this we need to xor (fig 1) with only odd elements of (fig 2), because this way we can cancel out all but first element.\\n\\n![image](https://assets.leetcode.com/users/images/59ad56f0-a608-4c59-a836-29af0b89a9cf_1633899454.6284459.png)\\n\\nWith the first element, we can now get all elements using that same property of xor, for example to get the 2nd element, we just need to xor first element of the given encoded array with the first element we found and continue that sequence\\n\\n![image](https://assets.leetcode.com/users/images/36607ecf-b1c4-4927-923b-d021c55c591d_1633899541.354136.png)\\n\\n```\\nvector<int> decode(vector<int>& encoded) {\\n\\tsize_t n = encoded.size() + 1;\\n\\tint xor_one_to_n = 0;\\n\\tfor(int i = 1; i <= n; i++) {\\n\\t\\txor_one_to_n ^= i;\\n\\t}\\n\\n\\tint xor_odd = 0;\\n\\tfor(size_t i = 1; i < encoded.size(); i += 2) {\\n\\t\\txor_odd ^= encoded[i];\\n\\t}\\n\\n\\tint first_element = xor_odd ^ xor_one_to_n;\\n\\tvector<int> original(n);\\n\\toriginal[0] = first_element;\\n\\tfor(size_t i = 1; i < n; i++) {\\n\\t\\toriginal[i] = encoded[i - 1] ^ original[i - 1]; \\n\\t}\\n\\treturn original;\\n}\\n```",
                "solutionTags": [],
                "code": "```1 ... n```\n```n```\n```1, 2, 3, 4, 5```\n```1 ... 5 ```\n```\\nvector<int> decode(vector<int>& encoded) {\\n\\tsize_t n = encoded.size() + 1;\\n\\tint xor_one_to_n = 0;\\n\\tfor(int i = 1; i <= n; i++) {\\n\\t\\txor_one_to_n ^= i;\\n\\t}\\n\\n\\tint xor_odd = 0;\\n\\tfor(size_t i = 1; i < encoded.size(); i += 2) {\\n\\t\\txor_odd ^= encoded[i];\\n\\t}\\n\\n\\tint first_element = xor_odd ^ xor_one_to_n;\\n\\tvector<int> original(n);\\n\\toriginal[0] = first_element;\\n\\tfor(size_t i = 1; i < n; i++) {\\n\\t\\toriginal[i] = encoded[i - 1] ^ original[i - 1]; \\n\\t}\\n\\treturn original;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035374,
                "title": "javascript-python-simple-5-line-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThe trick to this problem is realizing that a **bitwise XOR ( ^ )** operation is both associative and its own inverse function.\\n```javascript\\nif:  a ^ b ^ c = d                    // XOR is associative: the order of operations\\n \\u21D2:  c ^ b ^ a = d                    // for consecutive XOR\\'s does not matter\\n\\t\\t\\t  \\nif:  x ^ y = z                        // XOR is its own inverse function:\\n \\u21D2:  z ^ y = x                        // You can undo the equation from the answer\\n \\u21D2:  x ^ y ^ y = x                    // Two same operations cancel each other out\\n```\\nThis, plus the fact that the numbers in the encoded array **E** are formed by XOR\\'ing consecutive elements of **perm**, plus the fact that we know the numbers that make up the whole **perm** array, plus the fact that the length of the **perm** array must be odd, mean that we can easily deduce the first element of **perm**:\\n```javascript\\nif:  perm = [ a, b, c, d, e ]             // This is true regardless of the order of\\n \\u21D2:  a^b^c^d^e = 1^2^3^4^5                // #s in perm, b/c XOR is associative\\n   \\nif:  E[1] = b^c                           // By the encoding definition\\nif:  E[3] = d^e\\n   \\n \\u21D2:  (1^2^3^4^5) ^ E[1] ^ E[3]            // Therefore, if we XOR all #s from\\n   = (a^b^c^d^e) ^ (b^c) ^ (d^e)          // 1 to N along w/ odd elements of E\\n   = a ^ (b^b) ^ (c^c) ^ (d^d) ^ (e^e)    // then rearrange terms via association\\n   = a ^ 0 ^ 0 ^ 0 ^ 0                    // then most of the terms will cancel out\\n   = a\\t\\t                              // leaving us with just a, or perm[0]\\n```\\n(*Note: Had we used **E[0]** and **E[3]** in the example above, we could have isolated **perm[2]**, or **E[0]** and **E[2]** would yield **perm[4]**; any odd element of **perm** can be deduced this way, as long as the length of **perm** is odd.*)\\n\\nConveniently, the XOR of all values between **1** and **N** can be determined mathematically for all odd values of **N**. Because an even number and the odd number that follows only vary in the **0**th bit, when they are XOR\\'d the rest of the bits will always cancel out, leaving only a **1**. With this, we can see that for all odd values of **N**, this will simplify to alternating **0**s and **1**s:\\n```javascript\\nif:  even ^ (even+1) = 1\\n \\u21D2:  1 ^ 2 ^ 3 ^ 4 ^ 5                  \\u21D2:  1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 \\n   = 1 ^ (2^3) ^ (4^5)                     = 1 ^ (2^3) ^ (4^5) ^ (6^7)\\n   = 1 ^ 1 ^ 1                             = 1 ^ 1 ^ 1 ^ 1\\n   = 1                                     = 0\\n```\\nThus we can simplify the equation for the XOR of all numbers from **1** to **N** for all odd values of **N** to **(N + 1 >> 1) % 2**.\\n\\nAlso, since XOR is its own inverse function, we can work the encoding equation backwards:\\n```javascript\\nif:  E[i] = perm[i] ^ perm[i+1]           // By the encoding definition\\n \\u21D2:  perm[i+1] = E[i] ^ perm[i]           // Inverted to solve for perm[i+1]\\n```\\nWith **perm[0]** and this equation, we can quickly build out the rest of **perm** before returning it.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **256ms / 69.0MB**.\\n```javascript\\nvar decode = function(E) {\\n    let len = E.length, first = (len + 2 >> 1) % 2\\n    for (let i = 1; i < len; i += 2) first ^= E[i]\\n    let perm = [first]\\n    for (let i = 0; i < len; i++) ans[i+1] = ans[i] ^ E[i]\\n    return perm\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **972ms / 34.3MB**.\\n```python\\nclass Solution(object):\\n    def decode(self, E):\\n        L = len(E)\\n        first = (L + 2 >> 1) % 2\\n        for i in range(1,L,2):\\n            first ^= E[i]\\n        perm = [first]\\n        for el in E:\\n            ans.append(perm[-1] ^ el)\\n        return perm\\n```",
                "solutionTags": [],
                "code": "```javascript\\nif:  a ^ b ^ c = d                    // XOR is associative: the order of operations\\n \\u21D2:  c ^ b ^ a = d                    // for consecutive XOR\\'s does not matter\\n\\t\\t\\t  \\nif:  x ^ y = z                        // XOR is its own inverse function:\\n \\u21D2:  z ^ y = x                        // You can undo the equation from the answer\\n \\u21D2:  x ^ y ^ y = x                    // Two same operations cancel each other out\\n```\n```javascript\\nif:  perm = [ a, b, c, d, e ]             // This is true regardless of the order of\\n \\u21D2:  a^b^c^d^e = 1^2^3^4^5                // #s in perm, b/c XOR is associative\\n   \\nif:  E[1] = b^c                           // By the encoding definition\\nif:  E[3] = d^e\\n   \\n \\u21D2:  (1^2^3^4^5) ^ E[1] ^ E[3]            // Therefore, if we XOR all #s from\\n   = (a^b^c^d^e) ^ (b^c) ^ (d^e)          // 1 to N along w/ odd elements of E\\n   = a ^ (b^b) ^ (c^c) ^ (d^d) ^ (e^e)    // then rearrange terms via association\\n   = a ^ 0 ^ 0 ^ 0 ^ 0                    // then most of the terms will cancel out\\n   = a\\t\\t                              // leaving us with just a, or perm[0]\\n```\n```javascript\\nif:  even ^ (even+1) = 1\\n \\u21D2:  1 ^ 2 ^ 3 ^ 4 ^ 5                  \\u21D2:  1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 \\n   = 1 ^ (2^3) ^ (4^5)                     = 1 ^ (2^3) ^ (4^5) ^ (6^7)\\n   = 1 ^ 1 ^ 1                             = 1 ^ 1 ^ 1 ^ 1\\n   = 1                                     = 0\\n```\n```javascript\\nif:  E[i] = perm[i] ^ perm[i+1]           // By the encoding definition\\n \\u21D2:  perm[i+1] = E[i] ^ perm[i]           // Inverted to solve for perm[i+1]\\n```\n```javascript\\nvar decode = function(E) {\\n    let len = E.length, first = (len + 2 >> 1) % 2\\n    for (let i = 1; i < len; i += 2) first ^= E[i]\\n    let perm = [first]\\n    for (let i = 0; i < len; i++) ans[i+1] = ans[i] ^ E[i]\\n    return perm\\n};\\n```\n```python\\nclass Solution(object):\\n    def decode(self, E):\\n        L = len(E)\\n        first = (L + 2 >> 1) % 2\\n        for i in range(1,L,2):\\n            first ^= E[i]\\n        perm = [first]\\n        for el in E:\\n            ans.append(perm[-1] ^ el)\\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034413,
                "title": "figure-out-either-1st-or-last-element-reuse-decoded-xored-array-code",
                "content": "This runs faster than 100% of the submissions. \\n\\nIf you have done https://leetcode.com/problems/decode-xored-array/ , you would immediately get the intuition that one needs to figure out the first element of the answer & then can reuse the logic of decode xored array problem.\\nIllustration :\\nencoded = [w,x,y,z] => n=4\\nSay answer[] = [a,b,c,d,e]\\nAccording to question, the elements of answer[] are permutation of 1 to n+1, so 1 to 5.\\nYou know that a^b=w; b^c=x; c^d=y; d^e=z\\nAlso a^b^c^d^e = Xor of first n+1 positive numbers\\nNow your aim is to get the first element i.e. a. As even operations in XOR cancel out, you need to XOR (a^b^c^d^e) with (b^c^d^e) which can be easily evaluated.\\nOne can even figure out the last element (instead of first element) & proceed in similar manner.\\n\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int allXor=0;\\n        int n = encoded.length+1;\\n        //since the perm is a permutation of first n positive integers, so xor of all elements of perm array would be xor of all first n positive numbers (ordering is irrelevant in xor)\\n        for(int i=1;i<=n;i++){\\n            allXor^=i;\\n        }\\n        \\n        int xorAllOddButFirstElement=0;//basically gets XOR of all off elements starting from index 1 i.e index 1,3,5,7 and so on.\\n        for(int i=1;i<encoded.length;i=i+2){\\n            xorAllOddButFirstElement^=encoded[i];\\n        }\\n        int firstElement = allXor^xorAllOddButFirstElement;\\n        //since you know the firstElement now, it can be reduced to this problem :\\n        //https://leetcode.com/problems/decode-xored-array/ \\n        int[] answer = new int[n];\\n        answer[0]=firstElement;\\n        for(int i=0;i<(encoded.length);i++){ \\n            answer[i+1] = encoded[i] ^ answer[i];\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\nPlease upvote if you liked it :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int allXor=0;\\n        int n = encoded.length+1;\\n        //since the perm is a permutation of first n positive integers, so xor of all elements of perm array would be xor of all first n positive numbers (ordering is irrelevant in xor)\\n        for(int i=1;i<=n;i++){\\n            allXor^=i;\\n        }\\n        \\n        int xorAllOddButFirstElement=0;//basically gets XOR of all off elements starting from index 1 i.e index 1,3,5,7 and so on.\\n        for(int i=1;i<encoded.length;i=i+2){\\n            xorAllOddButFirstElement^=encoded[i];\\n        }\\n        int firstElement = allXor^xorAllOddButFirstElement;\\n        //since you know the firstElement now, it can be reduced to this problem :\\n        //https://leetcode.com/problems/decode-xored-array/ \\n        int[] answer = new int[n];\\n        answer[0]=firstElement;\\n        for(int i=0;i<(encoded.length);i++){ \\n            answer[i+1] = encoded[i] ^ answer[i];\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033552,
                "title": "java-solution-with-explanation",
                "content": "This problem becomes much easier if you use a pencil and a sheet of paper while putting your math skills to use.\\nFirst, XOR operation is commutative: if a XOR b = c then c XOR b = a\\n\\nThe encoded array is generated by:\\n\\nencoded[i] = perm[i] XOR perm[i+1] which by commutative property becomes:\\n\\nperm[i+1] = perm[i] XOR encoded[i]\\n\\nUsing this fact we can easily generate all elements of permutation array by XORing its previous element with the element of the encoded array at previous index.\\n\\nThe challenge is to find the first element of the permutation array. And here, we do some simple algebra. \\n\\ntotalPerm = perm[0] XOR perm[1] XOR perm[2] ... perm[n]\\n\\nAgain by commutative property:\\n\\nperm[0] = totalPerm XOR perm[1] XOR perm[2] ... perm[n]\\n\\nSince permutation array contains all numbers from 1 to n, we can easily calculate totalPerm by starting from 0 and XORing it with all numbers from 1 to n, i.e. from 1 to encoded.length + 1.\\n\\nOnce we\\'ve calculated totalPerm value, we again recall that:\\n\\nencoded[i] = perm[i] XOR perm[i+1] (encoded[1] = perm[1] XOR perm[2], encoded[2] = perm[2] XOR perm[3] and so on)\\n\\nSo:\\n\\nperm[0] = totalPerm XOR perm[1] XOR perm[2] XOR perm[3] XOR perm[4] ... perm[n] =\\n              = totalPerm XOR encoded[1] XOR encoded[3] ... XOR encoded[i] where i is odd.\\n\\t\\t\\t  \\nHope this helps! Like I said, things become clearer if you use a sheet of paper and do some algebra.\\nJava code is below.\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int[] res = new int[encoded.length+1];\\n        int perm = 0;\\n        for(int i = 1; i <= encoded.length+1; i ++)\\n            perm ^= i;\\n        for(int i = 1; i < encoded.length; i += 2)\\n            perm ^= encoded[i];\\n        res[0] = perm;\\n        for(int i = 1; i < res.length; i ++) {\\n            res[i] = res[i-1] ^ encoded[i-1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int[] res = new int[encoded.length+1];\\n        int perm = 0;\\n        for(int i = 1; i <= encoded.length+1; i ++)\\n            perm ^= i;\\n        for(int i = 1; i < encoded.length; i += 2)\\n            perm ^= encoded[i];\\n        res[0] = perm;\\n        for(int i = 1; i < res.length; i ++) {\\n            res[i] = res[i-1] ^ encoded[i-1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031117,
                "title": "c-easy-solution-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> decode(vector<int>& xorr) {\\n        int n1=xorr.size();//xorr is the given array in the question as exor array having size n-1.\\n        int n=n1+1;//length of original array \\n       \\n        vector<int> arr; //for store the elements of array\\n        int ans=1;\\n  for(int i=2;i<=n;i++){\\n      ans=ans^i;//calculate exor of all the elements from 1 to n.\\n  }\\n       \\n    // XOR of N natural numbers \\n    int xor_all = ans  ;\\n    int xor_adjacent = 0; \\n  \\n    // Loop to find the XOR of \\n    // adjacent elements of the XOR Array \\n    for (int i = 0; i < n - 1; i += 2) { \\n        xor_adjacent = xor_adjacent ^ xorr[i]; //find xor of two adjacent element in xor array.\\n    } \\n    int last_element = xor_all ^ xor_adjacent; //from this way we can calculate the last element of the original array that we want\\n    arr.push_back(last_element); \\n  \\n    // Loop to find the other \\n    // elements of the permuatation \\n    for (int i = n - 2; i >= 0; i--) { \\n        // Finding the next and next elements \\n        last_element = xorr[i] ^ last_element; \\n        arr.push_back(last_element); \\n    } \\n   reverse(arr.begin(), arr.end()); \\n    return arr; \\n \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> decode(vector<int>& xorr) {\\n        int n1=xorr.size();//xorr is the given array in the question as exor array having size n-1.\\n        int n=n1+1;//length of original array \\n       \\n        vector<int> arr; //for store the elements of array\\n        int ans=1;\\n  for(int i=2;i<=n;i++){\\n      ans=ans^i;//calculate exor of all the elements from 1 to n.\\n  }\\n       \\n    // XOR of N natural numbers \\n    int xor_all = ans  ;\\n    int xor_adjacent = 0; \\n  \\n    // Loop to find the XOR of \\n    // adjacent elements of the XOR Array \\n    for (int i = 0; i < n - 1; i += 2) { \\n        xor_adjacent = xor_adjacent ^ xorr[i]; //find xor of two adjacent element in xor array.\\n    } \\n    int last_element = xor_all ^ xor_adjacent; //from this way we can calculate the last element of the original array that we want\\n    arr.push_back(last_element); \\n  \\n    // Loop to find the other \\n    // elements of the permuatation \\n    for (int i = n - 2; i >= 0; i--) { \\n        // Finding the next and next elements \\n        last_element = xorr[i] ^ last_element; \\n        arr.push_back(last_element); \\n    } \\n   reverse(arr.begin(), arr.end()); \\n    return arr; \\n \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286359,
                "title": "c",
                "content": "*You first XOR all numbers from 1 to n. Then, you XOR some values in encoded array.*\\n\\nAs an example : n = 5. Numbers = {1,2,3,4,5}\\nand the encoded array is of length 4 : [w, x, y, z]\\nWe don\\'t know the final permutation, so just let it be : \\n[a,b,c,d,e], it is a permutation of {1,2,3,4,5}.\\n\\n\\nso : x = b XOR c, z = d XOR e.\\nlet T = 1 XOR 2 XOR ... XOR n.\\n\\nWith our example, if you do : **T** XOR ***x*** XOR *z*, then you have :\\n\\n**(a XOR b XOR c XOR d XOR e)** XOR ***(b XOR c)*** XOR *(d XOR e)*\\ncancel out (b XOR c) and (d XOR e), only number **a** is left, and that\\'s the first number of the sequence.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        vector<int> res = vector<int>(n, 0);\\n        res[0] = 1;\\n        for (int v = 2; v <= n; v++) {\\n            res[0] ^= v;\\n        }\\n        for (int i = 1; i < n - 1; i += 2) {\\n            res[0] ^= encoded[i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res[i] = (res[i - 1] ^ encoded[i - 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        vector<int> res = vector<int>(n, 0);\\n        res[0] = 1;\\n        for (int v = 2; v <= n; v++) {\\n            res[0] ^= v;\\n        }\\n        for (int i = 1; i < n - 1; i += 2) {\\n            res[0] ^= encoded[i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res[i] = (res[i - 1] ^ encoded[i - 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058116,
                "title": "simple-easy-explanation-clean-code-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\n   int computeXORtillN(int n) {\\n  if (n % 4 == 0) return n;\\n  if (n % 4 == 1) return 1;\\n  if (n % 4 == 2) return n + 1;\\n  return 0;\\n}\\n    \\npublic:\\n    vector<int> decode(vector<int>& en) {\\n        int n = en.size();\\n        int a = computeXORtillN(n+1);\\n        for(int i =1; i<n; i+=2)\\n        {\\n            a = a^en[i];\\n        }\\n        vector<int> dec;\\n        dec.push_back(a);\\n        for(int i=0; i<n; i++)\\n        {\\n            a = a^en[i]; \\n            dec.push_back(a);\\n        }\\n        return dec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n   int computeXORtillN(int n) {\\n  if (n % 4 == 0) return n;\\n  if (n % 4 == 1) return 1;\\n  if (n % 4 == 2) return n + 1;\\n  return 0;\\n}\\n    \\npublic:\\n    vector<int> decode(vector<int>& en) {\\n        int n = en.size();\\n        int a = computeXORtillN(n+1);\\n        for(int i =1; i<n; i+=2)\\n        {\\n            a = a^en[i];\\n        }\\n        vector<int> dec;\\n        dec.push_back(a);\\n        for(int i=0; i<n; i++)\\n        {\\n            a = a^en[i]; \\n            dec.push_back(a);\\n        }\\n        return dec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003067,
                "title": "javascript-easy-to-understand-and-high-performance-solution",
                "content": "For example, original list is[a1, a2, a3, a4, a5], which means encoded list is [a1^a2, a2^a3, a3^a4, a4^a5].\\nWe can get a1^a2, a1^a3, a1^a4, a1^a5 after iterating encoded list.\\nAnd we can compute a1^a2^a3^a4^a5 beforehand.\\nThen by xor all of them we can get the first element a1:\\n(a1^a2) ^ (a1^a3) ^ (a1^a4) ^ (a1^a5) ^ (a1^a2^a3^a4^a5) = a1\\n```javascript\\nfunction decode(encoded) {\\n  let list = Array.from(encoded);\\n  // Now we get [a1^a2, a1^a3 ... a1^an]\\n  // Noticed: you don\\'t need a list to store all xor pairs, becauce you just need \\n  // (a1^a2) ^ (a1^a3) ^ (a1^a4) ... (a1^an), so you can use a  single variable to store it,\\n  // current implemention just for better detail explain\\n  for (let i = 1; i < list.length; i++) {\\n    list[i] = list[i] ^ list[i - 1];\\n  }\\n\\n  // There is an integer array perm that is a permutation of the first n positive integers\\n  // so a1 ^ a2 ^ ... an = 1 ^ 2 ^ 3 ... ^ n\\n  let allXOR = 0;\\n  for (let i = 1; i <= encoded.length + 1; i++) {\\n    allXOR = allXOR ^ i;\\n  }\\n\\n  // (a1^a2) ^ (a1^a3) ^ (a1^a4) ... (a1^an) ^ (a1^a2^a3^a4...an) \\n  let firstElement = list.reduce((a, b) => a ^ b) ^ allXOR;\\n  \\n  // now reduce to leetcode 1720 problem\\n  let ans = [firstElement];\\n  for (let encode of encoded) {\\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/at\\n\\t// https://v8.dev/features/at-method\\n    ans.push(encode ^ ans.at(-1));\\n  }\\n\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nfunction decode(encoded) {\\n  let list = Array.from(encoded);\\n  // Now we get [a1^a2, a1^a3 ... a1^an]\\n  // Noticed: you don\\'t need a list to store all xor pairs, becauce you just need \\n  // (a1^a2) ^ (a1^a3) ^ (a1^a4) ... (a1^an), so you can use a  single variable to store it,\\n  // current implemention just for better detail explain\\n  for (let i = 1; i < list.length; i++) {\\n    list[i] = list[i] ^ list[i - 1];\\n  }\\n\\n  // There is an integer array perm that is a permutation of the first n positive integers\\n  // so a1 ^ a2 ^ ... an = 1 ^ 2 ^ 3 ... ^ n\\n  let allXOR = 0;\\n  for (let i = 1; i <= encoded.length + 1; i++) {\\n    allXOR = allXOR ^ i;\\n  }\\n\\n  // (a1^a2) ^ (a1^a3) ^ (a1^a4) ... (a1^an) ^ (a1^a2^a3^a4...an) \\n  let firstElement = list.reduce((a, b) => a ^ b) ^ allXOR;\\n  \\n  // now reduce to leetcode 1720 problem\\n  let ans = [firstElement];\\n  for (let encode of encoded) {\\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/at\\n\\t// https://v8.dev/features/at-method\\n    ans.push(encode ^ ans.at(-1));\\n  }\\n\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505993,
                "title": "python3-solution",
                "content": "Calculate p = 1^2^3.....^n\\na1^am = encoded[1] * encoded[2]....encoded[m]\\nThen Calculate t = (a1^a2) ^ (a1^a3) ......^ (an-1^an) based on encoded list. \\na1 = p ^ t\\na2, a3..... can be easily calculated from encoded list.\\n\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        total = 0\\n        a1an = 0\\n        n = len(encoded) + 1\\n        for i in range(len(encoded)):\\n            a1an ^= encoded[i]\\n            total ^= a1an\\n        \\n        nForAll = 0\\n        for i in range(1, n+1):\\n            nForAll ^= i\\n               \\n        a = [nForAll ^ total]\\n        \\n        for i in range(len(encoded)):\\n            a.append(encoded[i]^a[-1])\\n            \\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        total = 0\\n        a1an = 0\\n        n = len(encoded) + 1\\n        for i in range(len(encoded)):\\n            a1an ^= encoded[i]\\n            total ^= a1an\\n        \\n        nForAll = 0\\n        for i in range(1, n+1):\\n            nForAll ^= i\\n               \\n        a = [nForAll ^ total]\\n        \\n        for i in range(len(encoded)):\\n            a.append(encoded[i]^a[-1])\\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398053,
                "title": "o-n-approach",
                "content": "\\n\\t\\twe know p[0] ^ p[1] ^ .... ^ p[n - 1] = 1 ^ 2 ^ 3 ... ^ n = nxor(let);\\n        \\n        observe any one of the following : \\n        1. e[1] ^ e[3] ^ e[5] ^ .... ^ e[odd] = P[1] ^ P[2] ^ ... ^ P[n - 1]; => we can find P[0] using this => also find full solution.\\n            ( e[1] ^ e[3] ^ .... ^ e[odd] = nxor ^ P[0]);\\n\\t\\t\\t\\n        2. e[0] ^ e[2] ^ e[4] ^ .... ^ e[even] = P[0] ^ P[1] ^ ... ^ P[n - 2]; => we can find P[n - 1] using this => also find full solution.\\n            ( e[0] ^ e[2] ^ .... ^ e[even] = nxor ^ P[n - 1]; )\\n```\\n    vector<int> decode(vector<int>& e) \\n    {\\n        int n = e.size() + 1;\\n        int nxor = 0; for(int i = 1; i <= n; i++) nxor ^= i;\\n        \\n        int exor = 0; for(int i = 0; i < e.size(); i += 2) exor ^= e[i];\\n        \\n        int last = nxor ^ exor;\\n        \\n        vector<int> ans(n);\\n        ans[n - 1] = last;\\n        for(int i = n - 2; i >= 0; i--)\\n            ans[i] = ans[i + 1] ^ e[i];\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> decode(vector<int>& e) \\n    {\\n        int n = e.size() + 1;\\n        int nxor = 0; for(int i = 1; i <= n; i++) nxor ^= i;\\n        \\n        int exor = 0; for(int i = 0; i < e.size(); i += 2) exor ^= e[i];\\n        \\n        int last = nxor ^ exor;\\n        \\n        vector<int> ans(n);\\n        ans[n - 1] = last;\\n        for(int i = n - 2; i >= 0; i--)\\n            ans[i] = ans[i + 1] ^ e[i];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1241224,
                "title": "simple-solution-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> ans(encoded.size() + 1);\\n        int xor_all = 0;\\n        for(int i = 1;i <= encoded.size() + 1;i++)\\n            xor_all ^= i;\\n        int xor_adj = 0;\\n        for(int i = 0;i < encoded.size();i += 2)\\n            xor_adj ^= encoded[i];\\n        int last = xor_all ^ xor_adj;\\n        int xor_all2 = 0;\\n        for(int i = 0;i < encoded.size();i++)\\n            xor_all2 ^= encoded[i];\\n        int first = xor_all2 ^ last;\\n        ans[0] = first;\\n        for(int i = 0;i < encoded.size() - 1;i++){\\n            ans[i + 1] = encoded[i] ^ ans[i];\\n        }\\n        ans[encoded.size()] = last;\\n        return ans;\\n    }\\n};\\n```\\n1. **Calculate XOR of perm array i.e 1^2^3...n-1^n -> a**\\n2. **Calculate XOR of every even indexed(starting from 0) element of encoded array -> b**\\n3. **Last element = a^b**\\n4. **Calculate XOR of all elements of encoded array -> c**\\n5. **First element = c^last_element**.\\n6. **perm[i + 1] = encoded[i] ^ perm[i] (for i from 0 to encoded.length - 1)**.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> ans(encoded.size() + 1);\\n        int xor_all = 0;\\n        for(int i = 1;i <= encoded.size() + 1;i++)\\n            xor_all ^= i;\\n        int xor_adj = 0;\\n        for(int i = 0;i < encoded.size();i += 2)\\n            xor_adj ^= encoded[i];\\n        int last = xor_all ^ xor_adj;\\n        int xor_all2 = 0;\\n        for(int i = 0;i < encoded.size();i++)\\n            xor_all2 ^= encoded[i];\\n        int first = xor_all2 ^ last;\\n        ans[0] = first;\\n        for(int i = 0;i < encoded.size() - 1;i++){\\n            ans[i + 1] = encoded[i] ^ ans[i];\\n        }\\n        ans[encoded.size()] = last;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239539,
                "title": "python-simple-solution-with-explanation",
                "content": "Once you have the first value you can find the next one by XOR with the current encoded value and so forth. The challenge here is getting the first value. Initially I tried all values with early breakout but the solution timed out T: O(N^2), Space: O(N).\\n\\nI then read the discussion here and found that you can determine the first value using the properties of XOR. This took me a minute to figure out but my summary is as below.\\n\\nThe decoded list is equal to: a1^a2, a2^a3...a<sup>n-1</sup>^a<sup>n</sup> and we know the values of a1 to a<sup>n</sup>. Therefore we can simply XOR every second value (a2^a3, a4^a5...) from the first collection and all values from the second to get a1.\\n\\n``` Python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        def getFirstDecodedElement(encoded):\\n            n = 0\\n            for i in range(1,len(encoded),2):\\n                n ^= encoded[i]\\n            for i in range(1,len(encoded)+2):\\n                n ^= i\\n            return n\\n            \\n        n = getFirstDecodedElement(encoded)\\n        out = [n]\\n        for i in range(len(encoded)):\\n            n ^= encoded[i]\\n            out.append(n)\\n        return out\\n```",
                "solutionTags": [],
                "code": "``` Python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        def getFirstDecodedElement(encoded):\\n            n = 0\\n            for i in range(1,len(encoded),2):\\n                n ^= encoded[i]\\n            for i in range(1,len(encoded)+2):\\n                n ^= i\\n            return n\\n            \\n        n = getFirstDecodedElement(encoded)\\n        out = [n]\\n        for i in range(len(encoded)):\\n            n ^= encoded[i]\\n            out.append(n)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222173,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> ans;\\n        int m = encoded.size()+1;\\n        int d = 0;\\n        if(m%4==0){\\n            d = m;\\n        }\\n        if(m%4==1){\\n            d =1;\\n        }\\n        if(m%4==2){\\n            d = m+1;\\n        }\\n        if(m%4==3){\\n            d = 0;\\n        }\\n        for(int i=1;i<m-1;i=i+2){\\n            d^=encoded[i];\\n        }\\n        ans.push_back(d);\\n        for(int i=0; i<m-1;i++){\\n            ans.push_back(encoded[i]^ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\ta^b=c <=>a^c=b<=>b^c=a",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> ans;\\n        int m = encoded.size()+1;\\n        int d = 0;\\n        if(m%4==0){\\n            d = m;\\n        }\\n        if(m%4==1){\\n            d =1;\\n        }\\n        if(m%4==2){\\n            d = m+1;\\n        }\\n        if(m%4==3){\\n            d = 0;\\n        }\\n        for(int i=1;i<m-1;i=i+2){\\n            d^=encoded[i];\\n        }\\n        ans.push_back(d);\\n        for(int i=0; i<m-1;i++){\\n            ans.push_back(encoded[i]^ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040315,
                "title": "c-easy-to-understand",
                "content": "```\\n\\tvector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size();\\n        \\n\\t\\t// initialiy we have \\n\\t\\t/*\\n\\t\\tenc[0] = a[0]^a[1]\\n\\t\\tenc[1] = a[1]^a[2]\\n\\t\\tenc[2] = a[2]^a[3]\\n\\t\\t...\\n\\t\\t..\\n\\t\\t*/\\n        for(int i=1; i<n; i++) {\\n            encoded[i] ^= encoded[i-1];\\n        }\\n\\t\\t// now becomes \\n\\t\\t/*\\n\\t\\tenc[0] = a[0]^a[1]\\n\\t\\tenc[1] = a[0]^a[2]\\n\\t\\tenc[2] = a[0]^a[3]\\n\\t\\t...\\n\\t\\t..\\n\\t\\t*/\\n        \\n        int excludeAt0 = 0;\\n        for(int i=0; i<n; i++) {\\n            excludeAt0 ^= encoded[i]; \\n        }\\n        \\n\\t\\t// excludeAt0 = a[1] ^ a[2] ^ ......a[n-1]\\n\\t\\t\\n        int all = 0;\\n        for(int i=1; i<=n+1; i++) {\\n            all ^= i;\\n        }\\n        // all = 1 ^ 2 ^ 3.....^ n \\n\\t\\t\\n        int at0 = all ^ excludeAt0;\\n        vector<int> ans;\\n        ans.push_back(at0);\\n        \\n\\t\\t// at0 = a[0]\\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n            ans.push_back(encoded[i] ^ at0);\\n\\t\\t\\t// a[i+1] = encoded[i] ^ at0\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tvector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size();\\n        \\n\\t\\t// initialiy we have \\n\\t\\t/*\\n\\t\\tenc[0] = a[0]^a[1]\\n\\t\\tenc[1] = a[1]^a[2]\\n\\t\\tenc[2] = a[2]^a[3]\\n\\t\\t...\\n\\t\\t..\\n\\t\\t*/\\n        for(int i=1; i<n; i++) {\\n            encoded[i] ^= encoded[i-1];\\n        }\\n\\t\\t// now becomes \\n\\t\\t/*\\n\\t\\tenc[0] = a[0]^a[1]\\n\\t\\tenc[1] = a[0]^a[2]\\n\\t\\tenc[2] = a[0]^a[3]\\n\\t\\t...\\n\\t\\t..\\n\\t\\t*/\\n        \\n        int excludeAt0 = 0;\\n        for(int i=0; i<n; i++) {\\n            excludeAt0 ^= encoded[i]; \\n        }\\n        \\n\\t\\t// excludeAt0 = a[1] ^ a[2] ^ ......a[n-1]\\n\\t\\t\\n        int all = 0;\\n        for(int i=1; i<=n+1; i++) {\\n            all ^= i;\\n        }\\n        // all = 1 ^ 2 ^ 3.....^ n \\n\\t\\t\\n        int at0 = all ^ excludeAt0;\\n        vector<int> ans;\\n        ans.push_back(at0);\\n        \\n\\t\\t// at0 = a[0]\\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n            ans.push_back(encoded[i] ^ at0);\\n\\t\\t\\t// a[i+1] = encoded[i] ^ at0\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038733,
                "title": "c-find-the-first-number-fast-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int nxor=1;//total xor of n numbers\\n        int oxor = encoded[1];//odd exor -> we find the xor of all odd indices of encoded array in order to to get the xor of all elements of decoded array except the first element.\\n        //we then take xor of nxor and oxor in ordered to obtain the very first element\\n       for(int i=2;i<=encoded.size()+1;i++){\\n           nxor^=i;\\n           if(i<encoded.size()&&i&1){\\n              oxor^=encoded[i]; \\n           }\\n       }\\n        int first = nxor^oxor;\\n        //We then use this obtained first element in order to obtain all other elements by taking it\\'s xor with each elemet of the encdoded array in series one by one\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            ans.push_back(first^encoded[i]);\\n            first^=encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int nxor=1;//total xor of n numbers\\n        int oxor = encoded[1];//odd exor -> we find the xor of all odd indices of encoded array in order to to get the xor of all elements of decoded array except the first element.\\n        //we then take xor of nxor and oxor in ordered to obtain the very first element\\n       for(int i=2;i<=encoded.size()+1;i++){\\n           nxor^=i;\\n           if(i<encoded.size()&&i&1){\\n              oxor^=encoded[i]; \\n           }\\n       }\\n        int first = nxor^oxor;\\n        //We then use this obtained first element in order to obtain all other elements by taking it\\'s xor with each elemet of the encdoded array in series one by one\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            ans.push_back(first^encoded[i]);\\n            first^=encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035444,
                "title": "c-short-solution-w-explanation",
                "content": "Run-time is `O(N)`, space is `O(1)`. Idea is to try to figure out the one of the elements, then use the encoded array to decode back all the values. \\n\\nIf we look at the encoded array, we can see that if we `xor` all elements between `i` and `last`, we get `decoded[i]^decoded[last]`. If we `xor` all these numbers together, we get: `0^(decoded[i]^decoded[last])` for `0 <= i < n-1`. Since `n` is always odd, `0 <=  i < n-1` has even count. Since `xor` with same number cancels out itself, we can see that all `decoded[last]` gets cancelled out since there is an even number of them. Thus we end up with `decoded[0]^decoded[1] ... ^decoded[n-1]`. Since we know all elements of the decoded array, we can then `xor` this value with the total array `xor` to get `decoded[n]`. Once we get this number, we can proceed to decoded the array using `encoded` by just `xor`. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x1{0}, n{(int)encoded.size()+1};\\n        for(int i{1}; i <= n; ++i) x1^=i;\\n        for(int i{n-2}, x2{0}; i >= 0; --i) {\\n            x2 ^= encoded[i];\\n            x1 ^= x2;\\n        }\\n        std::vector<int> res(n, 0);\\n        res[n-1] = x1;\\n        for(int i{n-2}; i >= 0; --i) res[i] = encoded[i]^res[i+1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x1{0}, n{(int)encoded.size()+1};\\n        for(int i{1}; i <= n; ++i) x1^=i;\\n        for(int i{n-2}, x2{0}; i >= 0; --i) {\\n            x2 ^= encoded[i];\\n            x1 ^= x2;\\n        }\\n        std::vector<int> res(n, 0);\\n        res[n-1] = x1;\\n        for(int i{n-2}; i >= 0; --i) res[i] = encoded[i]^res[i+1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033203,
                "title": "c-simple-solution-100-ac",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int xorall = 0;\\n        for(int i = 1 ; i <= encoded.size() + 1 ; i++)\\n\\t\\t\\txorall ^= i;\\n        \\n        int xoren = 0;\\n        for(int i = 1 ; i < encoded.size() ; i+= 2) \\n\\t\\t\\txoren ^= encoded[i];\\n        \\n        int f = xorall ^ xoren;\\n        \\n        vector<int> res(1 , f);\\n        \\n        for(int i = 0 ; i < encoded.size() ; i++){\\n            res.push_back(f ^ encoded[i]);\\n            f = res[i + 1];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int xorall = 0;\\n        for(int i = 1 ; i <= encoded.size() + 1 ; i++)\\n\\t\\t\\txorall ^= i;\\n        \\n        int xoren = 0;\\n        for(int i = 1 ; i < encoded.size() ; i+= 2) \\n\\t\\t\\txoren ^= encoded[i];\\n        \\n        int f = xorall ^ xoren;\\n        \\n        vector<int> res(1 , f);\\n        \\n        for(int i = 0 ; i < encoded.size() ; i++){\\n            res.push_back(f ^ encoded[i]);\\n            f = res[i + 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1032697,
                "title": "alternate-mathematical-solution-with-detailed-proof-o-nlogn",
                "content": "say orignal array is a1, a2, a3, ...  an\\n(a1,a2,...,an is a permutation of the set of numbers {1,2,3...,N})\\n\\nI will try to find out the ith bit of all the numbers.\\n\\nnow the ith bit of a1 can either be 0 or 1.\\ni make a guess that the ith bit of a1 is 0. \\n\\nSince I already know the ith bit of a1^a2 so the ith bit of a2 is fixed which means that the ith bit of a3 is fixed(a2^a3 is known) which means the ith bit of a4 is fixed and so on.\\n\\nby fixing the ith bit of a1 to 0, the ith bits of all the numbers are known.\\n\\nNow there are two possibilites \\n1) my prediction was wrong and infact the ith bit of a1 is not 0 but 1.\\n2) my prediction was correct and I can similarly find remaining bits of all numbers.\\n\\nlet Si0 = count of numbers which have their ith bit as 1 when we fix the ith bit of a1 = 0.\\nlet Si1 = count of numbers which have their ith bit as 1 when we fix the ith bit of a1 = 1.\\nlet Ci = count of numbers which have their ith bit as 1 in the set {1,2,3,...,N} \\n\\nClaim: our prediction is correct if Si0 equal to Ci else our prediction is wrong and the ith bit of a1 is 1(in which case Si1 equal to Ci) and not 0.\\n\\nNow you may ask what if Si0 = Si1 = Ci?\\nClaim: this is not possible.\\n\\nwhy is this not possible?\\nbecause N(the number of elements is odd). \\nokay, so?\\n\\nso fix ith bit of a1 = 0, then you get x = Si0 numbers with ith bit as 1 and y = (N - Si0) numbers with ith bit as 0.\\n\\nif you flip the ith bit of a1 from 0 to 1, the ith bits of all numbers will flip(why?) and you will get x = (N - Si0) numbers with ith bit as 0 and Si0 numbers with ith bit as 1.\\n\\nN - Si0 can never be equal to Si0 because if it is then 2 * Si0 = N meaning that N is even which is not correct as per question.\\n\\nHence proved that Si0 = Si1 is not a possibility.\\n\\n```\\nclass Solution {\\npublic:\\n    \\nint actualNumOf1s(int bit, int N){\\n      int cnt = 0;\\n      for(int i = 1; i <= N; i++){\\n          if((i & (1 << bit)) != 0)\\n              cnt++;\\n      }\\n      return cnt;\\n}\\n\\nvoid setIthBit(int bit, std::vector<int>& nums, std::vector<int>& encoded){\\n      bool predict = 0; \\n      int numOf1s = 0;\\n      for(int i = 1; i <= encoded.size(); i++){\\n          bool encodedBit = ((encoded[i - 1] & (1 << bit)) == 0) ? 0 : 1;\\n          bool thisBit = (predict ^ encodedBit);\\n          if(thisBit)\\n            numOf1s++;\\n          predict = thisBit;\\n      }\\n      predict = 0;\\n      if(numOf1s != actualNumOf1s(bit, nums.size()))\\n        predict = 1;\\n\\n      nums[0] += (predict * (1 << bit));\\n      for(int i = 1; i <= encoded.size(); i++){\\n          bool encodedBit = ((encoded[i - 1] & (1 << bit)) == 0) ? 0 : 1;\\n          bool thisBit = (predict ^ encodedBit);\\n          predict = thisBit;\\n          nums[i] += (predict * (1 << bit));\\n      }\\n}\\n    vector<int> decode(vector<int>& encoded) {\\n        cout << actualNumOf1s(0, 3);\\n        vector<int> answer(encoded.size() + 1);\\n        for(int bit = 0; bit <= 30; bit++){\\n            setIthBit(bit, answer, encoded);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\n**A small self-promotion**\\nif you liked the thought process behind the proof you will enjoy my channel related to algorithms: https://www.youtube.com/user/MrHulasingh25\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nint actualNumOf1s(int bit, int N){\\n      int cnt = 0;\\n      for(int i = 1; i <= N; i++){\\n          if((i & (1 << bit)) != 0)\\n              cnt++;\\n      }\\n      return cnt;\\n}\\n\\nvoid setIthBit(int bit, std::vector<int>& nums, std::vector<int>& encoded){\\n      bool predict = 0; \\n      int numOf1s = 0;\\n      for(int i = 1; i <= encoded.size(); i++){\\n          bool encodedBit = ((encoded[i - 1] & (1 << bit)) == 0) ? 0 : 1;\\n          bool thisBit = (predict ^ encodedBit);\\n          if(thisBit)\\n            numOf1s++;\\n          predict = thisBit;\\n      }\\n      predict = 0;\\n      if(numOf1s != actualNumOf1s(bit, nums.size()))\\n        predict = 1;\\n\\n      nums[0] += (predict * (1 << bit));\\n      for(int i = 1; i <= encoded.size(); i++){\\n          bool encodedBit = ((encoded[i - 1] & (1 << bit)) == 0) ? 0 : 1;\\n          bool thisBit = (predict ^ encodedBit);\\n          predict = thisBit;\\n          nums[i] += (predict * (1 << bit));\\n      }\\n}\\n    vector<int> decode(vector<int>& encoded) {\\n        cout << actualNumOf1s(0, 3);\\n        vector<int> answer(encoded.size() + 1);\\n        for(int bit = 0; bit <= 30; bit++){\\n            setIthBit(bit, answer, encoded);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1031938,
                "title": "python-easy-to-understand-with-comments",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        valuesToOperate=[]\\n        xor_all_values=0\\n        xor_all_encoded=0\\n\\n       #xor all the values of sample permutated array(perm)\\n\\t   #xor_all_elements=perm[0]^perm[1]^perm[2]...perm[n],where n is len(encoded)---->Equation 1\\n        for i in range(1,len(encoded)+2):\\n            valuesToOperate.append(i)\\n            xor_all_values=xor_all_values^i   \\n        \\n\\t\\t#xor_all_encoded_values=encoded[0]^encoded[1]^encoded[2]...encoded[n]------>Equation 2\\n\\t\\t\\n        for key,val in enumerate(encoded):\\n            if key%2==0:continue\\n            xor_all_encoded=xor_all_encoded^encoded[key]\\n    \\n        #po that is first element of required array(perm[0])\\n\\t\\t#From equation 1 is perm[0]=xor_all_elements^perm[1]^perm[2]...perm[n],where n is len(encoded)---->Equation 3\\n\\t\\tpo=xor_all_encoded^xor_all_values\\n        finalValues=[]\\n        finalValues.append(po)\\n       \\n\\t   #From problem defination:\\n\\t   #encoded[0]=perm[0]^perm[1]\\n\\t   #encoded[1]=perm[1]^perm[2]\\n\\t   #encoded[2]=perm[2]^perm[3]\\n\\t   #encoded[3]=perm[3]^perm[4]\\n\\t   #Replace the above in equation 3 gives\\n\\t   #perm[0]=xor_all_elements^encoded[1]^encoded[3]...(So consider only odd indexes of encoded)\\n\\t   #Calculate other perm using perm[0] as shown below\\n\\t   #perm1=perm[0]^encoded[0]\\n\\t   #perm2=perm[1]^encoded[1]\\n\\t   for en in encoded:\\n            po=po^en\\n            finalValues.append(po)\\n\\n       return finalValues\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        valuesToOperate=[]\\n        xor_all_values=0\\n        xor_all_encoded=0\\n\\n       #xor all the values of sample permutated array(perm)\\n\\t   #xor_all_elements=perm[0]^perm[1]^perm[2]...perm[n],where n is len(encoded)---->Equation 1\\n        for i in range(1,len(encoded)+2):\\n            valuesToOperate.append(i)\\n            xor_all_values=xor_all_values^i   \\n        \\n\\t\\t#xor_all_encoded_values=encoded[0]^encoded[1]^encoded[2]...encoded[n]------>Equation 2\\n\\t\\t\\n        for key,val in enumerate(encoded):\\n            if key%2==0:continue\\n            xor_all_encoded=xor_all_encoded^encoded[key]\\n    \\n        #po that is first element of required array(perm[0])\\n\\t\\t#From equation 1 is perm[0]=xor_all_elements^perm[1]^perm[2]...perm[n],where n is len(encoded)---->Equation 3\\n\\t\\tpo=xor_all_encoded^xor_all_values\\n        finalValues=[]\\n        finalValues.append(po)\\n       \\n\\t   #From problem defination:\\n\\t   #encoded[0]=perm[0]^perm[1]\\n\\t   #encoded[1]=perm[1]^perm[2]\\n\\t   #encoded[2]=perm[2]^perm[3]\\n\\t   #encoded[3]=perm[3]^perm[4]\\n\\t   #Replace the above in equation 3 gives\\n\\t   #perm[0]=xor_all_elements^encoded[1]^encoded[3]...(So consider only odd indexes of encoded)\\n\\t   #Calculate other perm using perm[0] as shown below\\n\\t   #perm1=perm[0]^encoded[0]\\n\\t   #perm2=perm[1]^encoded[1]\\n\\t   for en in encoded:\\n            po=po^en\\n            finalValues.append(po)\\n\\n       return finalValues\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031868,
                "title": "c-with-explanations-in-comments",
                "content": "I\\'m fairily dissapointed with the explanations for the solutions in here. So I hope this helps someone out there.\\n\\n```\\npublic class Solution {\\n    public int[] Decode(int[] encoded) {\\n\\t\\t/*\\n\\t\\tIntuition:\\n\\t\\tWe know how many numbers we need to find. That\\'s len(encoded) + 1.\\n\\t\\tLet\\'s take the xor of all numbers from 1 to n\\n\\t\\t\\n\\t\\tLet\\'s say n == 5\\n\\t\\ta, b, c, d, e\\n\\t\\ta ^ b ^ c ^ d ^ e = y\\n\\t\\t\\n\\t\\tThis is the encoded array:\\n\\t\\t(a ^ b), (b ^ c), (c ^ d), (d ^ e) \\n\\t\\t\\n\\t\\tIf we xor all of them we end up with a ^ e. Not very helpful, as adjacent elements will cancel each other out.\\n\\t\\tBut If you notice, the problem says n will always be odd. \\n\\t\\tWhat happens if we drop the odd elements from the encoded array?\\n\\t\\t\\n\\t\\t(a ^ b), (c ^ d)\\n\\t\\tif we xor them, \\n\\t\\t\\n\\t\\ta ^ b ^ c ^ d = x\\n\\t\\t\\n\\t\\tso x ^ y == e\\n\\t\\t\\n\\t\\tThe moment we have the last element, we can unroll the encoded array easily.\\n\\t\\t\\n\\t\\t*/\\n\\t\\t\\n        var n = encoded.Length + 1;\\n\\t\\t// Fancy way of getting 1 ^ 2 ^ .. ^ n\\n        var xor = Enumerable\\n            .Range(1, n)\\n            .Aggregate((acc, x) => acc ^ x);\\n\\n\\t\\t// Fancy way of getting encoded[0] ^ encoded[2] ^ .. \\n        var skipOdd = Enumerable\\n            .Range(0, n - 1)\\n            .Where(x => x % 2 == 0)\\n            .Select(x => encoded[x])\\n            .Aggregate((acc, x) => acc ^ x);\\n        \\n        var lastNumber = xor ^ skipOdd;\\n        var result = new int[n];\\n        \\n        result[n - 1] = lastNumber;\\n        for (var i = n - 2; i >= 0; i--) {\\n            result[i] = result[i + 1] ^ encoded[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] Decode(int[] encoded) {\\n\\t\\t/*\\n\\t\\tIntuition:\\n\\t\\tWe know how many numbers we need to find. That\\'s len(encoded) + 1.\\n\\t\\tLet\\'s take the xor of all numbers from 1 to n\\n\\t\\t\\n\\t\\tLet\\'s say n == 5\\n\\t\\ta, b, c, d, e\\n\\t\\ta ^ b ^ c ^ d ^ e = y\\n\\t\\t\\n\\t\\tThis is the encoded array:\\n\\t\\t(a ^ b), (b ^ c), (c ^ d), (d ^ e) \\n\\t\\t\\n\\t\\tIf we xor all of them we end up with a ^ e. Not very helpful, as adjacent elements will cancel each other out.\\n\\t\\tBut If you notice, the problem says n will always be odd. \\n\\t\\tWhat happens if we drop the odd elements from the encoded array?\\n\\t\\t\\n\\t\\t(a ^ b), (c ^ d)\\n\\t\\tif we xor them, \\n\\t\\t\\n\\t\\ta ^ b ^ c ^ d = x\\n\\t\\t\\n\\t\\tso x ^ y == e\\n\\t\\t\\n\\t\\tThe moment we have the last element, we can unroll the encoded array easily.\\n\\t\\t\\n\\t\\t*/\\n\\t\\t\\n        var n = encoded.Length + 1;\\n\\t\\t// Fancy way of getting 1 ^ 2 ^ .. ^ n\\n        var xor = Enumerable\\n            .Range(1, n)\\n            .Aggregate((acc, x) => acc ^ x);\\n\\n\\t\\t// Fancy way of getting encoded[0] ^ encoded[2] ^ .. \\n        var skipOdd = Enumerable\\n            .Range(0, n - 1)\\n            .Where(x => x % 2 == 0)\\n            .Select(x => encoded[x])\\n            .Aggregate((acc, x) => acc ^ x);\\n        \\n        var lastNumber = xor ^ skipOdd;\\n        var result = new int[n];\\n        \\n        result[n - 1] = lastNumber;\\n        for (var i = n - 2; i >= 0; i--) {\\n            result[i] = result[i + 1] ^ encoded[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031848,
                "title": "find-the-last-number-with-explanation-c",
                "content": "**Example**\\n\\nLet the unencoded sequence be [a, b, c, d, e] \\n\\nThe encoded sequence is then [a^b, b^c, c^d, d^e]\\n\\nSince we know that the original sequence is a permutation of 1 .. N, we can get (without loss of generality) a ^ b ^ c ^ d ^ e\\n\\nTo get e I need (a ^ b ^ c ^ d ^ e) ^ (a ^ b ^ c ^ d), which I can get by xoring 1st and 3rd elements of the encoded sequence. \\n\\nOnce we found the last element we can now re-construct the sequence back to front by xoring with the encoded values. (Just to illustrate => e ^ (d ^ e) = d ...)\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int all = 0, n = encoded.size() + 1, last = 0;\\n        for (int i = 1; i <= n; i++) all ^= i;\\n        for (int i = 0; i < encoded.size(); i+=2) last ^= encoded[i];\\n        \\n        last ^= all; // we found the last\\n        vector<int> ans(n);\\n        ans[n-1] = last;\\n        encoded.push_back(0);\\n        for (int i = n-2; i >= 0; i--) {\\n            ans[i] = ans[i+1] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int all = 0, n = encoded.size() + 1, last = 0;\\n        for (int i = 1; i <= n; i++) all ^= i;\\n        for (int i = 0; i < encoded.size(); i+=2) last ^= encoded[i];\\n        \\n        last ^= all; // we found the last\\n        vector<int> ans(n);\\n        ans[n-1] = last;\\n        encoded.push_back(0);\\n        for (int i = n-2; i >= 0; i--) {\\n            ans[i] = ans[i+1] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031462,
                "title": "java-with-explanation-with-example-simple-o-n-100-fast",
                "content": "```\\n/*\\nExplanation:\\nFirst See solution of Decoded Xor Array (Problem no : 1720)\\nif we found first element of ans then whole array will be found (from 1720)\\n\\nconsider case:\\nEncoded array : E[] :     [6,5,4,6] \\nsuppose decoded array:    [x0,x1,x2,x3,x4] \\nfrom given:               x0^x1=6 and x1^x2=5 and x2^x3=4 and x3^x4=6  ...equation(1)\\n\\nnow consider only odd terms in Encoded array i.e. E[1] and E[3]\\nwe can observe that E[1]=5=x1^x2 and E[3]=6=x3^x4   ...see equation 1 if not understood\\n\\nNow we already know that decoded array consist of numbers from 1 to n (here n=5)\\nLets take XOR of all number from 1 to n i.e. all = 1^2^3^4^5          ...equation(2)\\nThus we can calculate all by xoring 1 to n number\\nas XOR is Associative hence all=x0^x1^x2^x3^x4=1^2^3^4^5\\n[Note that x0,x1,x2,x3,x4 are not in order i.e x0 not necessary to be 1]\\n\\nNow XORing all value (from equation 1) with odd indexed encoded arrayto get first number\\ni.e.\\nall^E[1]^E[3]\\n(x0^x1^x2^x3^x4) ^(x1^x2) ^(x3^x4) \\nNow we will remain with x0 which is starting index\\n\\n\\nNow Finally we get first number now we can calculate whole array (See solution of problem 1720)\\n\\nIN SHORT EXPLANATION:\\n1) calculate XOR from 1 to n\\n2) calculate XOR from odd indexed from Encoded Array\\n3) Xor value from step 1 and step 2 to get first element\\n4) Now same solution as question 1720 i.e. ans[i]=ans[i-1]^encoded[i-1];\\n*/\\n```\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n=encoded.length+1;\\n        int ans[]=new int[n];\\n        int all=0;\\n        int encod=0;\\n        for(int i=1;i<=n;i++)\\n            all=all^(i);\\n        for(int i=1;i<n;i+=2)\\n            encod=encod^encoded[i];\\n        int first=all^encod;\\n        ans[0]=first;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=ans[i-1]^encoded[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nExplanation:\\nFirst See solution of Decoded Xor Array (Problem no : 1720)\\nif we found first element of ans then whole array will be found (from 1720)\\n\\nconsider case:\\nEncoded array : E[] :     [6,5,4,6] \\nsuppose decoded array:    [x0,x1,x2,x3,x4] \\nfrom given:               x0^x1=6 and x1^x2=5 and x2^x3=4 and x3^x4=6  ...equation(1)\\n\\nnow consider only odd terms in Encoded array i.e. E[1] and E[3]\\nwe can observe that E[1]=5=x1^x2 and E[3]=6=x3^x4   ...see equation 1 if not understood\\n\\nNow we already know that decoded array consist of numbers from 1 to n (here n=5)\\nLets take XOR of all number from 1 to n i.e. all = 1^2^3^4^5          ...equation(2)\\nThus we can calculate all by xoring 1 to n number\\nas XOR is Associative hence all=x0^x1^x2^x3^x4=1^2^3^4^5\\n[Note that x0,x1,x2,x3,x4 are not in order i.e x0 not necessary to be 1]\\n\\nNow XORing all value (from equation 1) with odd indexed encoded arrayto get first number\\ni.e.\\nall^E[1]^E[3]\\n(x0^x1^x2^x3^x4) ^(x1^x2) ^(x3^x4) \\nNow we will remain with x0 which is starting index\\n\\n\\nNow Finally we get first number now we can calculate whole array (See solution of problem 1720)\\n\\nIN SHORT EXPLANATION:\\n1) calculate XOR from 1 to n\\n2) calculate XOR from odd indexed from Encoded Array\\n3) Xor value from step 1 and step 2 to get first element\\n4) Now same solution as question 1720 i.e. ans[i]=ans[i-1]^encoded[i-1];\\n*/\\n```\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n=encoded.length+1;\\n        int ans[]=new int[n];\\n        int all=0;\\n        int encod=0;\\n        for(int i=1;i<=n;i++)\\n            all=all^(i);\\n        for(int i=1;i<n;i+=2)\\n            encod=encod^encoded[i];\\n        int first=all^encod;\\n        ans[0]=first;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=ans[i-1]^encoded[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031260,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        \\n       int n = v.size() ;\\n       int xxor = 0;\\n       for(int i = 1 ; i <= n + 1 ; i ++)\\n           xxor ^= i ;\\n        \\n       int x_r = 0 ;\\n       for(int i = 0 ; i < n ; i ++) \\n       {\\n           if(i % 2 != 0 ) \\n              x_r ^= v[i] ;\\n       }\\n        vector<int> ans (n + 1);\\n        ans[0] = xxor ^ x_r;\\n\\n       int back = ans[0];\\n       for(int i = 0  ; i < n  ; i ++)\\n       {\\n           ans[i + 1] = back ^ v[i] ;\\n           back = ans[i+1];\\n       }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        \\n       int n = v.size() ;\\n       int xxor = 0;\\n       for(int i = 1 ; i <= n + 1 ; i ++)\\n           xxor ^= i ;\\n        \\n       int x_r = 0 ;\\n       for(int i = 0 ; i < n ; i ++) \\n       {\\n           if(i % 2 != 0 ) \\n              x_r ^= v[i] ;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1031253,
                "title": "python-3-with-explanation",
                "content": "The key to don\\'t get TLE is find the first premutation number in linear time.\\nThe solution is deducted from this true:\\n```a1=1^2^3^4^5^...^n   ^     a2^a3^a4^....^an```\\nWe can find ```a2^a3^a4^....^an``` from the input array ```encoded```\\n```\\nencoded[1]=a2^a3\\nencoded[3]=a4^a5\\nencoded[5]=a6^a7\\n...\\n```\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        ############ How to find the first number???\\n        # When we XORing whole array encoded:  x=0   for x in encoded: y^=x\\n        # in y we will have all permutation numbers two times except first and last one\\n        # When we XORing only items on ODD index in array encoded\\n        # in y we will have all permutation numbers one time except first one\\n        # When we XORing all numbers 1,2,3,...n and everything we already have in y (all permutation numbers one time except first one)\\n        # then in y we will have all permutation numbers two times except first one\\n        # which means y=first permutation number\\n        \\n        n=len(encoded)+1\\n        y=0\\n        for x in range(n+1):\\n            y^=x\\n        for i in range(1,len(encoded)+1,2):\\n            x=encoded[i]\\n            y^=x\\n        # print(y) \\n        # Now we know the first number, it is y\\n        # We can decode the input array encode\\n        encoded=[y]+encoded\\n        for i in range(n-1):\\n            y^=encoded[i+1]\\n            encoded[i+1]=y\\n        return encoded\\n```",
                "solutionTags": [],
                "code": "```a1=1^2^3^4^5^...^n   ^     a2^a3^a4^....^an```\n```a2^a3^a4^....^an```\n```encoded```\n```\\nencoded[1]=a2^a3\\nencoded[3]=a4^a5\\nencoded[5]=a6^a7\\n...\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        ############ How to find the first number???\\n        # When we XORing whole array encoded:  x=0   for x in encoded: y^=x\\n        # in y we will have all permutation numbers two times except first and last one\\n        # When we XORing only items on ODD index in array encoded\\n        # in y we will have all permutation numbers one time except first one\\n        # When we XORing all numbers 1,2,3,...n and everything we already have in y (all permutation numbers one time except first one)\\n        # then in y we will have all permutation numbers two times except first one\\n        # which means y=first permutation number\\n        \\n        n=len(encoded)+1\\n        y=0\\n        for x in range(n+1):\\n            y^=x\\n        for i in range(1,len(encoded)+1,2):\\n            x=encoded[i]\\n            y^=x\\n        # print(y) \\n        # Now we know the first number, it is y\\n        # We can decode the input array encode\\n        encoded=[y]+encoded\\n        for i in range(n-1):\\n            y^=encoded[i+1]\\n            encoded[i+1]=y\\n        return encoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031227,
                "title": "python-detailed-exeplanation-by-finding-the-first-one",
                "content": "1. First we should notice that the array *perm* is a permutation of the first *n* positive integers and *n* is odd. \\nFor example, n==5. The orginal array *perm* could be any permutation of [1,2,3,4,5], like [2,1,3,5,4] or [3,4,2,5,1] or [4,1,2,5,3].\\n\\n\\tThe length of the *encoded* array would be 1 smaller than *n*. So we could get *n* by adding 1 to the *len(encoded)*.\\n\\tIt\\'s not hard to find the XOR of all these first *n* elements.\\n\\n```\\n        n = len(encoded)+1\\n        XOR = 0\\n        for i in range(1,n+1):  \\n            XOR = XOR^i\\n```\\n\\n2.  Then we can find the first element of *perm*.\\n\\tencoded[i] == perm[i]^perm[i+1]\\n\\tWe do the XOR for the ones in the odd position in the encoded array. \\n\\t\\n\\tTake *n*==5 for example:\\n\\tencoded[1] == perm[1]^perm[2]\\n\\tencoded[3] == perm[3]^perm[5]\\n\\tHence, perm[1]^perm[2]^perm[3]^perm[5] == encoded[1]^encoded[3]\\n\\n\\tRemeber we find the XOR of all the elements in step1?\\n\\tSince perm[m]^perm[m] == 0, the first one could be calculated by \\n\\tperm[0] == perm[0]^perm[1]^perm[2]^perm[3]^perm[5]^perm[1]^perm[2]^perm[3]^perm[5] \\n\\t== encoded[1]^encoded[3]^XOR\\n\\t\\n```\\n        s = 0\\n        for i in range(1,n,2):\\n            s = s^encoded[i]\\n        res = [0]*n\\n        res[0] = XOR^s\\n```\\n\\n3. Since we find the first element in *perm*, it\\'s easy to find the rest ones by perm[i] == perm[i-1]^encoded[i-1]\\n```\\n        for j in range(1,n):\\n            res[j] = res[j-1]^encoded[j-1]\\n        return res\\n```\\n\\nMy complete code:\\n\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded)+1\\n        XOR = 0\\n        for i in range(1,n+1):\\n            XOR = XOR^i\\n        \\n        s = 0\\n        for i in range(1,n,2):\\n            s = s^encoded[i]\\n        res = [0]*n\\n        res[0] = XOR^s\\n        \\n        for j in range(1,n):\\n            res[j] = res[j-1]^encoded[j-1]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        n = len(encoded)+1\\n        XOR = 0\\n        for i in range(1,n+1):  \\n            XOR = XOR^i\\n```\n```\\n        s = 0\\n        for i in range(1,n,2):\\n            s = s^encoded[i]\\n        res = [0]*n\\n        res[0] = XOR^s\\n```\n```\\n        for j in range(1,n):\\n            res[j] = res[j-1]^encoded[j-1]\\n        return res\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded)+1\\n        XOR = 0\\n        for i in range(1,n+1):\\n            XOR = XOR^i\\n        \\n        s = 0\\n        for i in range(1,n,2):\\n            s = s^encoded[i]\\n        res = [0]*n\\n        res[0] = XOR^s\\n        \\n        for j in range(1,n):\\n            res[j] = res[j-1]^encoded[j-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031131,
                "title": "java-solution",
                "content": "\\nhttps://achievementguru.com/leetcode-1734-decode-xored-permutation-java-solution/\\n```\\nclass Solution {\\n    \\n    static int xor_all_elem(int n) \\n{ \\n  \\n    switch (n & 3) { \\n  \\n    case 0: \\n        return n; \\n    case 1: \\n        return 1; \\n    case 2: \\n        return n + 1;  \\n    } \\n    return 0; \\n} \\n    \\n    \\n    static int[] calArray(int xarr[], int n) \\n{ \\n    \\n    List<Integer> l = new ArrayList<Integer>(); \\n  \\n    \\n    int xor_full = xor_all_elem(n); \\n    int xor_neigh = 0; \\n  \\n    \\n    for (int i = 0; i < n - 1; i += 2) { \\n        xor_neigh = xor_neigh ^ xarr[i]; \\n    } \\n    int last_elem = xor_full ^ xor_neigh; \\n    l.add(last_elem); \\n  \\n    \\n    for (int i = n - 2; i >= 0; i--) \\n    { \\n    \\n        last_elem = xarr[i] ^ last_elem; \\n        l.add(last_elem); \\n    } \\n    \\n    Collections.reverse(l);\\n    int[] array = l.stream().mapToInt(i->i).toArray();\\n  \\n    return array; \\n} \\n    public int[] decode(int[] encoded) {\\n        int decode[] =  calArray(encoded,encoded.length+1);\\n        \\n        return decode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int xor_all_elem(int n) \\n{ \\n  \\n    switch (n & 3) { \\n  \\n    case 0: \\n        return n; \\n    case 1: \\n        return 1; \\n    case 2: \\n        return n + 1;  \\n    } \\n    return 0; \\n} \\n    \\n    \\n    static int[] calArray(int xarr[], int n) \\n{ \\n    \\n    List<Integer> l = new ArrayList<Integer>(); \\n  \\n    \\n    int xor_full = xor_all_elem(n); \\n    int xor_neigh = 0; \\n  \\n    \\n    for (int i = 0; i < n - 1; i += 2) { \\n        xor_neigh = xor_neigh ^ xarr[i]; \\n    } \\n    int last_elem = xor_full ^ xor_neigh; \\n    l.add(last_elem); \\n  \\n    \\n    for (int i = n - 2; i >= 0; i--) \\n    { \\n    \\n        last_elem = xarr[i] ^ last_elem; \\n        l.add(last_elem); \\n    } \\n    \\n    Collections.reverse(l);\\n    int[] array = l.stream().mapToInt(i->i).toArray();\\n  \\n    return array; \\n} \\n    public int[] decode(int[] encoded) {\\n        int decode[] =  calArray(encoded,encoded.length+1);\\n        \\n        return decode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031121,
                "title": "golang-with-accepted-solution",
                "content": "```\\nfunc decode(encoded []int) []int {\\n    ans := make([]int,len(encoded)+1)\\n    n := len(encoded) + 1\\n    t1 := 0\\n    for i:=1;i<=n;i++ {\\n        t1 = t1 ^ i\\n    }\\n    t2 := 0\\n    sum := 0\\n    for _,e := range encoded {\\n        sum = sum ^ e\\n        t2 = t2 ^ sum\\n    }\\n\\t// the first num\\n\\tans[0] = t1 ^ t2\\n\\tfor j:=0;j<len(encoded);j++ {\\n\\t\\tnext := encoded[j]^ans[j]\\n\\t\\tans[j+1] = next\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc decode(encoded []int) []int {\\n    ans := make([]int,len(encoded)+1)\\n    n := len(encoded) + 1\\n    t1 := 0\\n    for i:=1;i<=n;i++ {\\n        t1 = t1 ^ i\\n    }\\n    t2 := 0\\n    sum := 0\\n    for _,e := range encoded {\\n        sum = sum ^ e\\n        t2 = t2 ^ sum\\n    }\\n\\t// the first num\\n\\tans[0] = t1 ^ t2\\n\\tfor j:=0;j<len(encoded);j++ {\\n\\t\\tnext := encoded[j]^ans[j]\\n\\t\\tans[j+1] = next\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031119,
                "title": "python-o-n-time-and-space-straightforward-xor-approach-detailed-explanation",
                "content": "#### Intuition\\nThis problem is all about XOR, so tried each possible way of doing XOR..\\nAssuming answer is `p`, based on the problem we have below\\nencoded[0] = p[0] ^ p[1]\\nencoded[1] = p[1] ^ p[2]\\n...\\nIf we XOR them all, we have p[0] ^ p[-1]\\nIf we XOR everything except encoded[0], namely, XOR all encoded[1:], we have p[1] ^ p[-1]\\n\\nSee some pattern now? Let\\'s continue, assuming the accumulated XOR is `xors`, we have\\n\\nxors[0] = p[0] ^ p[n-1]\\nxors[1] = p[1] ^ p[n-1]\\n...\\nxors[n-1] = p[n-2] ^ p[n-1]\\n\\nWe know the relation between p[i] and p[n-1], but what\\'s next? Let\\'s go back to the question, and notice that the total number of elements is always odd. This means, if we furhter XOR all elements in `xors`, we have\\n(p[0] ^ p[n-1]) ^ (p[1] ^ p[n-1]) ^ ... ^ (p[n-2] ^ p[n-1])\\nSince there are **even number** of p[n-1], they will disappear, result will be p[0] ^ p[1] ^ ... p[n-2]\\n\\nNow go back to the question again, `p` contains `the first n positive integers`, so we can calculate the XOR of all first n positive integers, which is p[0] ^ p[1] ^ ... p[n-2] ^ p[n-1].\\n\\nNow we can get the p[n-1], by XOR above two results.\\nOnce we have p[n-1], we can go back to `xors`, and use p[n-1] ^ xors[0] to get p[0], and so on.\\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        xors = []\\n        e = reduce(lambda a, b: a ^ b, encoded)\\n        x = 0\\n        for i in range(len(encoded)):\\n            xors.append(e ^ x)\\n            x ^= encoded[i]\\n        \\n        total_n = reduce(lambda a, b: a ^ b, range(1, n + 1))\\n        total_x = reduce(lambda a, b: a ^ b, xors) # p[0] ^ p[1] ^... p[-2]\\n    \\n        last = total_n ^ total_x\\n        return [xors[i] ^ last for i in range(len(xors))] + [last]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        xors = []\\n        e = reduce(lambda a, b: a ^ b, encoded)\\n        x = 0\\n        for i in range(len(encoded)):\\n            xors.append(e ^ x)\\n            x ^= encoded[i]\\n        \\n        total_n = reduce(lambda a, b: a ^ b, range(1, n + 1))\\n        total_x = reduce(lambda a, b: a ^ b, xors) # p[0] ^ p[1] ^... p[-2]\\n    \\n        last = total_n ^ total_x\\n        return [xors[i] ^ last for i in range(len(xors))] + [last]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031090,
                "title": "tle-c-a-diff-approach-only-playing-with-the-first-element-of-the-decoded-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x = encoded[0];\\n       \\n       \\n        vector<int> v;\\n\\n        vector<pair<int,int>> res;\\n        for(int i =1; i<=4*x; i++){\\n            res.push_back({i,x^i});\\n            res.push_back({x-i,x^(x-i)});\\n            \\n        }\\n     \\n        for(int i =0; i<res.size(); i++){\\n            \\n        int mx =INT_MIN;\\n        int mn = INT_MAX;\\n        v.push_back(res[i].first);\\n        v.push_back(res[i].second);\\n        for(int i =1;i<encoded.size(); i++){\\n            v.push_back(encoded[i]^v[i]);\\n        }\\n        map<int,int> mp;\\n        for(int i =0; i<v.size(); i++){\\n            if(v[i]>mx){\\n                mx =v[i];\\n            }\\n            \\n            if(v[i]<mn){\\n                mn = v[i];\\n            }\\n            \\n            mp[v[i]]++;\\n        }\\n            \\n        if(mp.size()==v.size() && mn ==1 && mx ==v.size()){\\n            return v;\\n        }\\n            \\n        v = {};\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x = encoded[0];\\n       \\n       \\n        vector<int> v;\\n\\n        vector<pair<int,int>> res;\\n        for(int i =1; i<=4*x; i++){\\n            res.push_back({i,x^i});\\n            res.push_back({x-i,x^(x-i)});\\n            \\n        }\\n     \\n        for(int i =0; i<res.size(); i++){\\n            \\n        int mx =INT_MIN;\\n        int mn = INT_MAX;\\n        v.push_back(res[i].first);\\n        v.push_back(res[i].second);\\n        for(int i =1;i<encoded.size(); i++){\\n            v.push_back(encoded[i]^v[i]);\\n        }\\n        map<int,int> mp;\\n        for(int i =0; i<v.size(); i++){\\n            if(v[i]>mx){\\n                mx =v[i];\\n            }\\n            \\n            if(v[i]<mn){\\n                mn = v[i];\\n            }\\n            \\n            mp[v[i]]++;\\n        }\\n            \\n        if(mp.size()==v.size() && mn ==1 && mx ==v.size()){\\n            return v;\\n        }\\n            \\n        v = {};\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031060,
                "title": "simple-python-code",
                "content": "Since the length of the origin array is odd, we can get the total xor except the first one `xor_except_the_first = nums[1] ^ nums[2] ^ nums[3] ^ nums[4]...`\\nencoded[1] = nums[1] ^ nums[2] \\nencoded[3] = nums[3] ^ nums[4]\\nso `xor_except_the_first = encoded[1] ^ encoded[3] ^ ...`\\nwith `xor_except_the_first`, we can get the first number and then we know the rest\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1 \\n        total = 0\\n        for i in range(1, n + 1):\\n            total ^= i\\n        \\n        xor_except_the_first = 0\\n        for i in range(1, len(encoded), 2):\\n            xor_except_the_first ^= encoded[i]\\n\\n        res = [0] * n\\n        res[0] = total ^ xor_except_the_first\\n        for i in range(len(encoded)):\\n            res[i + 1] = res[i] ^ encoded[i]\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1 \\n        total = 0\\n        for i in range(1, n + 1):\\n            total ^= i\\n        \\n        xor_except_the_first = 0\\n        for i in range(1, len(encoded), 2):\\n            xor_except_the_first ^= encoded[i]\\n\\n        res = [0] * n\\n        res[0] = total ^ xor_except_the_first\\n        for i in range(len(encoded)):\\n            res[i + 1] = res[i] ^ encoded[i]\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082181,
                "title": "c-version-of-a-posted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nC# Version of the one provided at https://leetcode.com/problems/decode-xored-permutation/solutions/1031107/java-c-python-straight-forward-solution/\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] Decode(int[] encoded) {\\n        int n = encoded.Length;\\n        int p1 = 0;\\n        int totXor = 0;\\n        int secondXor = 0;\\n        int[] result = new int[n+1];\\n\\n        for(int i=0; i<n; ++i){\\n            totXor = totXor ^ (i+1);\\n            if(i%2 == 1){\\n                secondXor = secondXor ^ encoded[i];\\n            }\\n        }\\n\\n        result[0] = totXor ^ (n+1) ^ secondXor;\\n        for(int i=0; i<n; ++i){\\n            result[i+1] = encoded[i] ^ result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] Decode(int[] encoded) {\\n        int n = encoded.Length;\\n        int p1 = 0;\\n        int totXor = 0;\\n        int secondXor = 0;\\n        int[] result = new int[n+1];\\n\\n        for(int i=0; i<n; ++i){\\n            totXor = totXor ^ (i+1);\\n            if(i%2 == 1){\\n                secondXor = secondXor ^ encoded[i];\\n            }\\n        }\\n\\n        result[0] = totXor ^ (n+1) ^ secondXor;\\n        for(int i=0; i<n; ++i){\\n            result[i+1] = encoded[i] ^ result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077221,
                "title": "python-solution",
                "content": "# Intuition\\nUsing xor, we can calculate the numbers we are missing.\\n\\n# Approach\\nLet\\'s say that `[a, b, c, d, e]` are a permutation of `[1..n+1]`.\\nAlso, let\\'s call `perm = [a, b, c, d, e].`\\n\\nThe encoded value is `[a^b, b^c, c^d, d^e]`\\n\\nWe need to calculate a number x, so that:\\n`x = a ^    b ^ c   ^   d ^ e`\\n\\nWith the previous information we know:\\n`x = a ^ encoded[1] ^ encoded[3]`, therefore:\\n`a = x ^ encoded[1] ^ encoded[3]`\\n\\nNow, we know `a^b (encoded[0])` and `a`. We also know that `a^a = 0` and `0 ^ b = b`, so: `a^(a^b) = b.`\\n\\nWe can use this formula to find every number.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        x, n = 0, len(encoded)        \\n        # a, b, c, d, e are a permutation of [1..n+1]\\n        # let\\'s call perm = [a, b, c, d, e]\\n        # encoded = [a^b, b^c, c^d, d^e]\\n        # x = a ^    b ^ c   ^   d ^ e\\n        # x = a ^ encoded[1] ^ encoded[3]\\n        # a = x ^ encoded[1] ^ encoded[3]\\n\\n        # x = 1 ^ 2 ^ 3 ^ ... ^ n + 1\\n        for i in range(1, n + 2):\\n            x ^= i\\n        # find the first number (a) using xor of odd positioned numbers:\\n        for i in range(1, n, 2):\\n            x ^= encoded[i]\\n        perm = [x] # x is now a.\\n        # We know a^b (encoded[0]) and a. \\n        # We also know that a^a = 0 and 0 ^ b = b, so: a^(a^b) = b.\\n        # We use this formula to find every number\\n        for i in range(len(encoded)):\\n            x ^= encoded[i]\\n            perm.append(x)\\n        return perm\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        x, n = 0, len(encoded)        \\n        # a, b, c, d, e are a permutation of [1..n+1]\\n        # let\\'s call perm = [a, b, c, d, e]\\n        # encoded = [a^b, b^c, c^d, d^e]\\n        # x = a ^    b ^ c   ^   d ^ e\\n        # x = a ^ encoded[1] ^ encoded[3]\\n        # a = x ^ encoded[1] ^ encoded[3]\\n\\n        # x = 1 ^ 2 ^ 3 ^ ... ^ n + 1\\n        for i in range(1, n + 2):\\n            x ^= i\\n        # find the first number (a) using xor of odd positioned numbers:\\n        for i in range(1, n, 2):\\n            x ^= encoded[i]\\n        perm = [x] # x is now a.\\n        # We know a^b (encoded[0]) and a. \\n        # We also know that a^a = 0 and 0 ^ b = b, so: a^(a^b) = b.\\n        # We use this formula to find every number\\n        for i in range(len(encoded)):\\n            x ^= encoded[i]\\n            perm.append(x)\\n        return perm\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035754,
                "title": "decode-xored-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n       int n = encoded.length + 1;\\n        int a = 0, b = 0;\\n        for (int i = 0; i < n - 1; i += 2) {\\n            a ^= encoded[i];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            b ^= i;\\n        }\\n        int[] perm = new int[n];\\n        perm[n - 1] = a ^ b;\\n        for (int i = n - 2; i >= 0; --i) {\\n            perm[i] = encoded[i] ^ perm[i + 1];\\n        }\\n        return perm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n       int n = encoded.length + 1;\\n        int a = 0, b = 0;\\n        for (int i = 0; i < n - 1; i += 2) {\\n            a ^= encoded[i];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            b ^= i;\\n        }\\n        int[] perm = new int[n];\\n        perm[n - 1] = a ^ b;\\n        for (int i = n - 2; i >= 0; --i) {\\n            perm[i] = encoded[i] ^ perm[i + 1];\\n        }\\n        return perm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929832,
                "title": "swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        var numberOfElements = encoded.count + 1\\n        var xorAll = 0\\n\\n        for iterator in 1...numberOfElements {\\n            xorAll = (xorAll ^ iterator)\\n        }\\n\\n        var prev = encoded[0]\\n        var sequence = encoded[0]\\n        for iterator in 1..<(numberOfElements - 1) {\\n            sequence = sequence ^ encoded[iterator]\\n            prev = prev ^ sequence\\n        }\\n        var ans = [Int]()\\n        let firstElement = xorAll ^ prev\\n        ans.append(firstElement)\\n        var element = firstElement\\n        for iterator in 0..<(numberOfElements - 1) {\\n            var value = encoded[iterator] ^ element\\n            ans.append(value)\\n            element = value\\n        }\\n\\n        return ans\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        var numberOfElements = encoded.count + 1\\n        var xorAll = 0\\n\\n        for iterator in 1...numberOfElements {\\n            xorAll = (xorAll ^ iterator)\\n        }\\n\\n        var prev = encoded[0]\\n        var sequence = encoded[0]\\n        for iterator in 1..<(numberOfElements - 1) {\\n            sequence = sequence ^ encoded[iterator]\\n            prev = prev ^ sequence\\n        }\\n        var ans = [Int]()\\n        let firstElement = xorAll ^ prev\\n        ans.append(firstElement)\\n        var element = firstElement\\n        for iterator in 0..<(numberOfElements - 1) {\\n            var value = encoded[iterator] ^ element\\n            ans.append(value)\\n            element = value\\n        }\\n\\n        return ans\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892410,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 366ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 89.9MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec decode(encoded :: [integer]) :: [integer]\\n  def decode(encoded) do\\n    n = Enum.count(encoded) + 1\\n    {i, a} =\\n      Enum.reduce(encoded, {0, 0}, fn encode, {i, a} ->\\n        a = Bitwise.bxor(a, i)\\n        if i < n and rem(i, 2) == 1 do\\n          {i + 1, Bitwise.bxor(a, encode)}\\n        else\\n          {i + 1, a}\\n        end\\n      end)\\n    a = Enum.reduce(i..n, a, fn i, a -> Bitwise.bxor(a, i) end)\\n    Enum.reduce_while(encoded, {0, [a], a}, fn enc, {i, res, tail} ->\\n      if i >= n - 2 do\\n        {:halt, {i, [tail | res], tail}}\\n      else\\n        tail = Bitwise.bxor(tail, enc)\\n        {:cont, {i, [tail | res], tail}}\\n        end\\n    end) |> elem(1) |> Enum.reverse\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec decode(encoded :: [integer]) :: [integer]\\n  def decode(encoded) do\\n    n = Enum.count(encoded) + 1\\n    {i, a} =\\n      Enum.reduce(encoded, {0, 0}, fn encode, {i, a} ->\\n        a = Bitwise.bxor(a, i)\\n        if i < n and rem(i, 2) == 1 do\\n          {i + 1, Bitwise.bxor(a, encode)}\\n        else\\n          {i + 1, a}\\n        end\\n      end)\\n    a = Enum.reduce(i..n, a, fn i, a -> Bitwise.bxor(a, i) end)\\n    Enum.reduce_while(encoded, {0, [a], a}, fn enc, {i, res, tail} ->\\n      if i >= n - 2 do\\n        {:halt, {i, [tail | res], tail}}\\n      else\\n        tail = Bitwise.bxor(tail, enc)\\n        {:cont, {i, [tail | res], tail}}\\n        end\\n    end) |> elem(1) |> Enum.reverse\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3877434,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] arr) {\\n        int n = arr.length;\\n        int ans[] = new int[n+1];\\n\\n        int x = 1;\\n\\n        for(int i=2; i<=n+1; i++){\\n            x = x^i;\\n        }\\n\\n        for(int i=1; i<n; i=i+2){\\n            x = arr[i]^x;\\n        }\\n\\n        ans[0] = x;\\n\\n        for(int i=1; i<=n; i++){\\n            ans[i] = ans[i-1]^arr[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] arr) {\\n        int n = arr.length;\\n        int ans[] = new int[n+1];\\n\\n        int x = 1;\\n\\n        for(int i=2; i<=n+1; i++){\\n            x = x^i;\\n        }\\n\\n        for(int i=1; i<n; i=i+2){\\n            x = arr[i]^x;\\n        }\\n\\n        ans[0] = x;\\n\\n        for(int i=1; i<=n; i++){\\n            ans[i] = ans[i-1]^arr[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770295,
                "title": "simple-java-solution-100-beats-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length+1;\\n        int[] arr = new int[n];\\n        int  x=0;\\n        for(int i=1;i<n+1;i++){\\n            x = x^i;\\n        }\\n        for(int i=1;i<n-1;i+=2){\\n            x=encoded[i]^x;\\n        }\\n        arr[0] = x;\\n        for(int i=0;i<n-1;i++){\\n            arr[i+1]=encoded[i]^arr[i];\\n        }\\n\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length+1;\\n        int[] arr = new int[n];\\n        int  x=0;\\n        for(int i=1;i<n+1;i++){\\n            x = x^i;\\n        }\\n        for(int i=1;i<n-1;i+=2){\\n            x=encoded[i]^x;\\n        }\\n        arr[0] = x;\\n        for(int i=0;i<n-1;i++){\\n            arr[i+1]=encoded[i]^arr[i];\\n        }\\n\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701961,
                "title": "simple-xor-solution-using-xor-of-first-n-natural-number",
                "content": "# Intuition\\nIntution seems to a bit simple. We just need to find any one number of the perm and the whole arram can be easily decode. For that we will xor the first N natural no and xor of alternative elements in encoded and finally it gives the last element of the perm array\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach goes as you just in one loop calculate xor of first N natural no. In another loop just Xor the alternative index of the encoded and finally last loop to get the element\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) For the ans array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size();\\n        vector<int> ans(n+1);\\n        int nxor = 0, axor = 0;\\n        for(int i = 1;i<=n+1;i++){\\n            nxor = nxor ^ i;\\n        }\\n        for(int i = 0; i<n;i+=2){\\n            axor = axor ^ encoded[i];\\n        }\\n        int last = axor ^ nxor;\\n        ans[n] = last;\\n        for(int i = n-1;i>=0;i--){\\n            ans[i] = ans[i+1] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size();\\n        vector<int> ans(n+1);\\n        int nxor = 0, axor = 0;\\n        for(int i = 1;i<=n+1;i++){\\n            nxor = nxor ^ i;\\n        }\\n        for(int i = 0; i<n;i+=2){\\n            axor = axor ^ encoded[i];\\n        }\\n        int last = axor ^ nxor;\\n        ans[n] = last;\\n        for(int i = n-1;i>=0;i--){\\n            ans[i] = ans[i+1] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660658,
                "title": "java-simplest-explanation-starters-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are given the array whose each element is the xor of 2 elements from the array that we have to return, thus we need to know one of the element inorder to find the 2nd element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are given the encoded array, so consider original array that we have to return is perm = [a, b, c, d, e] and we are given encoded = [a^b, b^c, c^d, d^e], so somehow if we can know about any element from `perm` and we can `xor` that with the element from encoded we can get whole array.\\nNow what we\\'ll do is we\\'ll xor the element from 1 to n (reason i\\'ll tell later). Now it means `a ^ b ^ c ^ d ^ e = x(let)`, now we have encoded array so take 2 element(pair) from it, let say we take `a ^ b` and `c ^ d`, now if you xor `x` with `a ^ b`, the `a ^ b` in x cancels out, similarly if we xor `c ^ d` with x, the `c ^ d` from x cancels out, what do we end up with?? `e` (that is the last element of the array that we need to return). \\nNow we can iterate from last to the start and using the `e` we can get the whole array which is similar to the question https://leetcode.com/problems/decode-xored-array/\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length;\\n        int[] decoded = new int[n + 1];\\n        int xorAll = 0;\\n        for(int i = 1; i <= n + 1; i++){\\n            xorAll ^= i;\\n        }\\n\\n        for(int i = 0; i < n; i += 2){\\n            xorAll ^= encoded[i];\\n        }\\n        int last_element = xorAll;\\n        decoded[n] = last_element;\\n        for(int i = n - 1; i >= 0; i--){\\n            last_element ^= encoded[i];\\n            decoded[i] = last_element;\\n        }\\n        return decoded;\\n    }\\n}\\n```\\n\\n# Please upvote if you find it useful!!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length;\\n        int[] decoded = new int[n + 1];\\n        int xorAll = 0;\\n        for(int i = 1; i <= n + 1; i++){\\n            xorAll ^= i;\\n        }\\n\\n        for(int i = 0; i < n; i += 2){\\n            xorAll ^= encoded[i];\\n        }\\n        int last_element = xorAll;\\n        decoded[n] = last_element;\\n        for(int i = n - 1; i >= 0; i--){\\n            last_element ^= encoded[i];\\n            decoded[i] = last_element;\\n        }\\n        return decoded;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647834,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake [a,b,c,d,e] as expect , which includes number (1 - 4)\\nouput become [a^b,b^c,c^d,d^e];\\ne = (a^b^c^d^e) ^ (a^b)^(c^d)\\nsince num^num = 0\\nwhen we have e\\nform the encoded array , we can have d^e\\nwe could use e^d^e to get d ...\\nand d^c^d to get c\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> res;\\n        int allXOR=0;\\n        int xorer = 0;\\n        // xor on all numbers\\n        for(int i =1; i<= encoded.size() + 1; i++) {\\n            allXOR ^= i;\\n        }\\n        for(int i=0; i<encoded.size(); i+=2) {\\n            xorer ^= encoded[i];\\n        }\\n        int last = allXOR ^xorer;\\n        res.push_back(last);\\n        // cout<<last<<\\'\\\\n\\';\\n        for(int i =encoded.size()-1; i>=0; i--) {\\n            int pre = last ^ encoded[i];\\n            last = pre;\\n            res.push_back(pre);\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int> res;\\n        int allXOR=0;\\n        int xorer = 0;\\n        // xor on all numbers\\n        for(int i =1; i<= encoded.size() + 1; i++) {\\n            allXOR ^= i;\\n        }\\n        for(int i=0; i<encoded.size(); i+=2) {\\n            xorer ^= encoded[i];\\n        }\\n        int last = allXOR ^xorer;\\n        res.push_back(last);\\n        // cout<<last<<\\'\\\\n\\';\\n        for(int i =encoded.size()-1; i>=0; i--) {\\n            int pre = last ^ encoded[i];\\n            last = pre;\\n            res.push_back(pre);\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3620898,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        //length of perm array\\n        int length = encoded.length+1;\\n        int perm[] = new int[length];\\n        int x = 0;\\n        //for the xor of all values in perm\\n        for (int i = 1; i < length+1; i++)\\n        x ^= i;\\n        //xor with all values except 1st\\n        for(int i = 1; i < length-1 ; i+=2)\\n        x ^= encoded[i];\\n        //putting 1st value in perm[0]\\n        perm[0] = x;\\n        //finding rest values using 1st value\\n        for(int i = 0; i < length - 1; i++){\\n            perm[i+1] = perm[i]^encoded[i];\\n        }\\n\\n        return perm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        //length of perm array\\n        int length = encoded.length+1;\\n        int perm[] = new int[length];\\n        int x = 0;\\n        //for the xor of all values in perm\\n        for (int i = 1; i < length+1; i++)\\n        x ^= i;\\n        //xor with all values except 1st\\n        for(int i = 1; i < length-1 ; i+=2)\\n        x ^= encoded[i];\\n        //putting 1st value in perm[0]\\n        perm[0] = x;\\n        //finding rest values using 1st value\\n        for(int i = 0; i < length - 1; i++){\\n            perm[i+1] = perm[i]^encoded[i];\\n        }\\n\\n        return perm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532024,
                "title": "simple-c-soln",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int XOR=0;\\n        int n=encoded.size()+1;\\n        for(int i=1;i<=n;i++){\\n     XOR=XOR^i;\\n        }\\n        int first=0;\\n        for(int i=1;i<encoded.size();i+=2){\\n         first=first^encoded[i];\\n        }\\n        first=first^XOR;\\n        vector<int> res;\\n        res.push_back(first);\\n        for(int i=0;i<n-1;i++){\\n            first=first^encoded[i];\\n            res.push_back(first);\\n        }\\n        return res;\\n\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int XOR=0;\\n        int n=encoded.size()+1;\\n        for(int i=1;i<=n;i++){\\n     XOR=XOR^i;\\n        }\\n        int first=0;\\n        for(int i=1;i<encoded.size();i+=2){\\n         first=first^encoded[i];\\n        }\\n        first=first^XOR;\\n        vector<int> res;\\n        res.push_back(first);\\n        for(int i=0;i<n-1;i++){\\n            first=first^encoded[i];\\n            res.push_back(first);\\n        }\\n        return res;\\n\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498211,
                "title": "python-xor-logic-observations",
                "content": "Encoding formula: `encoded[i] = perm[i] ^ perm[i + 1]`\\n\\n**How to find `perm[i]`?**\\n\\n`encoded[i] = perm[i] ^ perm[i + 1]`\\nIn order to find it let\\'s put some numbers as an example:\\n`encoded[0] = perm[0] ^ perm[1]`\\nas `a^b = c` = `a^c = b` = `c^b = a` we can `^` both parts by `perm[0]`\\n`encoded[0] ` ^ `perm[0] = perm[0] ^ perm[1]` ^ `perm[0]`\\n`encoded[0] ^ perm[0] = perm[1]`\\n\\nSo `perm[1] = encoded[0] ^ perm[0]` which is `perm[i] = encoded[i - 1] ^ perm[i - 1]`\\n\\nIn order to find `perm[1]` we need `perm[0]`.\\n\\n**How to find `perm[0]`?**\\n\\nWe know that the perm has **odd** number of elements, which means that encoded will have **even**.\\n\\n`perm = 1 2 3 4 5`\\n`encoded = 1^2 2^3 3^4 4^5`\\n\\nBy closely observing what\\'s going on we can see the following:\\n\\n```\\nperm =    1  ^  2  ^  3  ^  4  ^  5\\nencoded: 1^2 ^ 2^3 ^ 3^4 ^ 4^5\\n```\\nHow to find the `1` in `perm`?\\n\\n1. `^` all numbers from 1 to `len(encoded)`. 1 to `perm`\\'s n.\\n2. Now we need to remove `2, 3, 4 ,5` by using only `encoded`\\'s values. \\nThis is exacly what we have in `encoded`\\'s : 1^2 >> **2^3** << 3^4 ^ >> **4^5** << as `encoded[1]` and `encoded[3]`\\nSo `1^2^3^4^5` ^ `2^3^4^5` = `1`.\\n\\nSource code:\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        P = len(encoded) + 1\\n        E = len(encoded)\\n        perm = [0] * P\\n        for num in range(1, P + 1): # ^ 1..n\\n            perm[0] ^= num\\n        for i in range(1, E + 1, 2): # ^ by encoded\\'s odd values\\n            perm[0] ^= encoded[i]\\n        for i in range(1, E + 1): # calc perm array based on perm[0] and encoded values\\n            perm[i] = perm[i - 1] ^ encoded[i - 1]\\n        return perm\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nperm =    1  ^  2  ^  3  ^  4  ^  5\\nencoded: 1^2 ^ 2^3 ^ 3^4 ^ 4^5\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        P = len(encoded) + 1\\n        E = len(encoded)\\n        perm = [0] * P\\n        for num in range(1, P + 1): # ^ 1..n\\n            perm[0] ^= num\\n        for i in range(1, E + 1, 2): # ^ by encoded\\'s odd values\\n            perm[0] ^= encoded[i]\\n        for i in range(1, E + 1): # calc perm array based on perm[0] and encoded values\\n            perm[i] = perm[i - 1] ^ encoded[i - 1]\\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450396,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n    let n = encoded.len() + 1;\\n\\n    let mut tot = 0;\\n    for i in 1..=n {\\n      tot ^= i as i32;\\n    }\\n\\n    let mut odd = 0;\\n    for i in (0..n-1).step_by(2) {\\n      odd ^= encoded[i];\\n    }\\n\\n    let last = tot ^ odd;\\n    let mut result = vec![0;n];\\n    result[n-1] = last;\\n    for i in (0..n-1).rev() {\\n      result[i] = result[i+1] ^ encoded[i];\\n    }\\n    \\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n    let n = encoded.len() + 1;\\n\\n    let mut tot = 0;\\n    for i in 1..=n {\\n      tot ^= i as i32;\\n    }\\n\\n    let mut odd = 0;\\n    for i in (0..n-1).step_by(2) {\\n      odd ^= encoded[i];\\n    }\\n\\n    let last = tot ^ odd;\\n    let mut result = vec![0;n];\\n    result[n-1] = last;\\n    for i in (0..n-1).rev() {\\n      result[i] = result[i+1] ^ encoded[i];\\n    }\\n    \\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398739,
                "title": "python3-mathematical-approach",
                "content": "# Intuition\\nWe know the numbers ``1``, ``2``,... ``n`` were use to form ``perm``. \\nAlso we know that ``n`` is odd. \\n\\n``encoded[i]`` = ``perm[i]`` xor ``perm[i+1]``\\n\\nThus:\\n\\n``xor_even`` = ``encoded[0]`` xor ``encoded[2]`` xor ... xor ``encoded[n-3]`` = ``perm[0]`` xor ``perm[1]`` xor ... xor ``perm[n-2]``\\n\\nWe can get ``perm[n-1]`` = ``xor_even`` xor (``1`` xor ``2`` xor ... xor ``n``)\\n\\nHaving ``perm[n-1]`` and ``encoded`` we can restore original permutation.\\n\\n# Approach\\n1. Get ``n`` as length of ``encoded`` plus 1\\n2. Initialize ``result`` of length ``n``\\n3. Calculate ``xor_all`` as ``1`` xor ``2`` xor ... xor ``n``\\n4. Calculate ``xor_even`` as ``perm[0]`` xor ``perm[1]`` xor ... xor ``perm[n-2]``\\n5. Calculate ``perm[n-1]`` as ``xor_even`` xor ``xor_all``\\n6. Restore the permutation backwards and return the result\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ - apart from storage for the output\\n\\n# Code\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        result = [0] * n\\n        xor_all = reduce(lambda r, s: r ^ s, range(1, n+1))\\n        xor_even = reduce(lambda r, s: r ^ s, encoded[::2])\\n        result[-1] = xor_even ^ xor_all\\n        for i in range(n-2, -1, -1):\\n            result[i] = result[i+1] ^ encoded[i]\\n        return result\\n```\\n\\nIf you have any questions please ask, and UPVOTE if you like the approach!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        result = [0] * n\\n        xor_all = reduce(lambda r, s: r ^ s, range(1, n+1))\\n        xor_even = reduce(lambda r, s: r ^ s, encoded[::2])\\n        result[-1] = xor_even ^ xor_all\\n        for i in range(n-2, -1, -1):\\n            result[i] = result[i+1] ^ encoded[i]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396414,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n    // 2,4,4,1,1,5,5,3\\n    // xorr from ulta (3^5)^(1,4)\\n    // xorr with 1 2 3 4 5 \\n    // cancel out 1 4 3 5 \\n    // rem=2;\\nint xorr=0;\\n    for(int i=v.size()-1;i>=0;i-=2){\\n        xorr=xorr^v[i];\\n    }\\n    // (4^1) ^ (5^3)\\n    // 4^5 ^ 1^3 ^ 1^ 2^ 3^4^5= 2;\\n    // 2 is the first element of array\\n    int temp=0;\\n    for(int i=1;i<=v.size()+1;i++){\\n        temp=temp^i;\\n    }\\n    vector<int>ans;\\n    ans.push_back(xorr^temp);\\n    for(int i=0;i<v.size();i++){\\n        ans.push_back(ans[i]^v[i]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n    // 2,4,4,1,1,5,5,3\\n    // xorr from ulta (3^5)^(1,4)\\n    // xorr with 1 2 3 4 5 \\n    // cancel out 1 4 3 5 \\n    // rem=2;\\nint xorr=0;\\n    for(int i=v.size()-1;i>=0;i-=2){\\n        xorr=xorr^v[i];\\n    }\\n    // (4^1) ^ (5^3)\\n    // 4^5 ^ 1^3 ^ 1^ 2^ 3^4^5= 2;\\n    // 2 is the first element of array\\n    int temp=0;\\n    for(int i=1;i<=v.size()+1;i++){\\n        temp=temp^i;\\n    }\\n    vector<int>ans;\\n    ans.push_back(xorr^temp);\\n    for(int i=0;i<v.size();i++){\\n        ans.push_back(ans[i]^v[i]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365463,
                "title": "easy-c-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x=0;\\n        int n=encoded.size();\\n        for(int i=1;i<=n+1;i++){\\n            x^=i;\\n        }\\n        \\n        for(int i=1;i<n;i+=2){\\n            x^=encoded[i];\\n\\n        }\\n        vector<int>ans;\\n        ans.push_back(x);\\n        for(int i=0;i<n;i++){\\n            x^=encoded[i];\\n            ans.push_back(x);\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x=0;\\n        int n=encoded.size();\\n        for(int i=1;i<=n+1;i++){\\n            x^=i;\\n        }\\n        \\n        for(int i=1;i<n;i+=2){\\n            x^=encoded[i];\\n\\n        }\\n        vector<int>ans;\\n        ans.push_back(x);\\n        for(int i=0;i<n;i++){\\n            x^=encoded[i];\\n            ans.push_back(x);\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355343,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1 ;\\n        int sum = 0 ;\\n        for(int i = 1; i <= n; i++)\\n            sum ^= i ;\\n        \\n        int noHead = 0 ;\\n        for(int i = 1; i < encoded.size(); i+=2){\\n            noHead ^= encoded[i] ;\\n        }\\n        int head = sum ^ noHead ;\\n        vector<int>ret ;\\n        ret.push_back(head) ;\\n        for(int i = 0; i < encoded.size(); i++){\\n            ret.push_back(encoded[i] ^ ret.back()) ;\\n        }\\n        return ret ;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1 ;\\n        int sum = 0 ;\\n        for(int i = 1; i <= n; i++)\\n            sum ^= i ;\\n        \\n        int noHead = 0 ;\\n        for(int i = 1; i < encoded.size(); i+=2){\\n            noHead ^= encoded[i] ;\\n        }\\n        int head = sum ^ noHead ;\\n        vector<int>ret ;\\n        ret.push_back(head) ;\\n        for(int i = 0; i < encoded.size(); i++){\\n            ret.push_back(encoded[i] ^ ret.back()) ;\\n        }\\n        return ret ;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267867,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n\\n        var res = Array(repeating: 0, count: encoded.count + 1)\\n        res[0] = (1...res.count).reduce(0, ^)\\n\\n        for i in stride(from: 1, to: encoded.count, by: 2) {\\n            res[0] ^= encoded[i]\\n        }\\n\\n        for i in 1..<res.count {\\n            res[i] = res[i - 1] ^ encoded[i - 1]\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n\\n        var res = Array(repeating: 0, count: encoded.count + 1)\\n        res[0] = (1...res.count).reduce(0, ^)\\n\\n        for i in stride(from: 1, to: encoded.count, by: 2) {\\n            res[0] ^= encoded[i]\\n        }\\n\\n        for i in 1..<res.count {\\n            res[i] = res[i - 1] ^ encoded[i - 1]\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208584,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n        let n = encoded.len() + 1;\\n        let mut perm = vec![0; n];\\n        let mut total = 0;\\n        for i in 1..=n {\\n            total ^= i as i32;\\n        }\\n        let mut odd = 0;\\n        for i in (1..n - 1).step_by(2) {\\n            odd ^= encoded[i];\\n        }\\n        perm[0] = total ^ odd;\\n        for i in 0..n - 1 {\\n            perm[i + 1] = perm[i] ^ encoded[i];\\n        }\\n        perm\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n        let n = encoded.len() + 1;\\n        let mut perm = vec![0; n];\\n        let mut total = 0;\\n        for i in 1..=n {\\n            total ^= i as i32;\\n        }\\n        let mut odd = 0;\\n        for i in (1..n - 1).step_by(2) {\\n            odd ^= encoded[i];\\n        }\\n        perm[0] = total ^ odd;\\n        for i in 0..n - 1 {\\n            perm[i + 1] = perm[i] ^ encoded[i];\\n        }\\n        perm\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201220,
                "title": "rust-faster-than-100-0ms-functional-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n        let len = encoded.len();\\n        let mut res = Vec::with_capacity(len + 1);\\n        let xall = (1..=(len + 1)).reduce(|acc, e| acc ^ e).unwrap() as i32;\\n        let xen = encoded\\n            .iter()\\n            .skip(1)\\n            .step_by(2)\\n            .fold(0, |acc, el| acc ^ (*el));\\n        let first = xall ^ xen;\\n        res.push(first);\\n        encoded\\n            .into_iter()\\n            .for_each(|x| res.push(x ^ res.last().unwrap()));\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n        let len = encoded.len();\\n        let mut res = Vec::with_capacity(len + 1);\\n        let xall = (1..=(len + 1)).reduce(|acc, e| acc ^ e).unwrap() as i32;\\n        let xen = encoded\\n            .iter()\\n            .skip(1)\\n            .step_by(2)\\n            .fold(0, |acc, el| acc ^ (*el));\\n        let first = xall ^ xen;\\n        res.push(first);\\n        encoded\\n            .into_iter()\\n            .for_each(|x| res.push(x ^ res.last().unwrap()));\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165242,
                "title": "find-first-element-by-xor-of-all-except-first",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded)\\n        xor = 0\\n        for i in range(1, n + 2):\\n            xor ^= i\\n        currxor = 0\\n        for i in range(1, n, 2):\\n            currxor ^= encoded[i]\\n        res = [xor ^ currxor]\\n        for el in encoded:\\n            res.append(res[-1] ^ el)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded)\\n        xor = 0\\n        for i in range(1, n + 2):\\n            xor ^= i\\n        currxor = 0\\n        for i in range(1, n, 2):\\n            currxor ^= encoded[i]\\n        res = [xor ^ currxor]\\n        for el in encoded:\\n            res.append(res[-1] ^ el)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135345,
                "title": "ok",
                "content": "```\\nvector<int> decode(vector<int>& e)\\n{\\n\\te.push_back(0);\\n\\tint s(size(e)%4==1); \\n\\tfor(int i(size(e)-2); i>=0; --i) s^=e[i]^=e[i+1];  \\n\\tfor(auto & i : e) i^=s;\\n\\treturn e; \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> decode(vector<int>& e)\\n{\\n\\te.push_back(0);\\n\\tint s(size(e)%4==1); \\n\\tfor(int i(size(e)-2); i>=0; --i) s^=e[i]^=e[i+1];  \\n\\tfor(auto & i : e) i^=s;\\n\\treturn e; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135085,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size()+1;\\n        \\n        vector<int> ans(n) ;\\n        int first = 0;\\n\\n        for(int i = 1 ; i<= n ; i++)\\n        first ^= i;\\n\\n        for(int i = 0 ; i<n-1 ; i+=2)\\n           first ^= encoded[i+1];  \\n\\n        ans[0] = first;\\n\\n        for(int i = 1 ; i<n ; i++)\\n        ans[i] = ans[i-1]^encoded[i-1];\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def decode(self, A: List[int]) -> List[int]:\\n        first = reduce(ixor, A[::-2] + list(range(len(A) + 2)))\\n        return list(accumulate([first] + A, ixor))\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        \\n        int n = encoded.length + 1;\\n        int[] result = new int[n];\\n        int xor_of_all = 0;\\n\\n        if(n%4 == 0){\\n            xor_of_all = n; \\n        }\\n\\n        else if(n%4 == 1) {\\n            xor_of_all = 1; \\n        }\\n\\n        else if(n%4 == 2) {\\n            xor_of_all = n+1; \\n        }\\n\\n        else  {\\n            xor_of_all = 0; \\n        }\\n\\n        for(int i=0; i<encoded.length; i=i+2) {\\n            xor_of_all ^= encoded[i];\\n        }\\n\\n        result[n-1] = xor_of_all;\\n        for(int i=n-2; i>=0; i--) {\\n            result[i] = result[i+1] ^ encoded[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size()+1;\\n        \\n        vector<int> ans(n) ;\\n        int first = 0;\\n\\n        for(int i = 1 ; i<= n ; i++)\\n        first ^= i;\\n\\n        for(int i = 0 ; i<n-1 ; i+=2)\\n           first ^= encoded[i+1];  \\n\\n        ans[0] = first;\\n\\n        for(int i = 1 ; i<n ; i++)\\n        ans[i] = ans[i-1]^encoded[i-1];\\n\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def decode(self, A: List[int]) -> List[int]:\\n        first = reduce(ixor, A[::-2] + list(range(len(A) + 2)))\\n        return list(accumulate([first] + A, ixor))\\n```\n```Java []\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        \\n        int n = encoded.length + 1;\\n        int[] result = new int[n];\\n        int xor_of_all = 0;\\n\\n        if(n%4 == 0){\\n            xor_of_all = n; \\n        }\\n\\n        else if(n%4 == 1) {\\n            xor_of_all = 1; \\n        }\\n\\n        else if(n%4 == 2) {\\n            xor_of_all = n+1; \\n        }\\n\\n        else  {\\n            xor_of_all = 0; \\n        }\\n\\n        for(int i=0; i<encoded.length; i=i+2) {\\n            xor_of_all ^= encoded[i];\\n        }\\n\\n        result[n-1] = xor_of_all;\\n        for(int i=n-2; i>=0; i--) {\\n            result[i] = result[i+1] ^ encoded[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952842,
                "title": "c-solution",
                "content": "```\\nint* decode(int* encoded, int encodedSize, int* returnSize){\\n    int i, x = 0, n = encodedSize, j = 1;\\n\\n    for (i = 1; i <= n + 1; i++) \\n        x ^= i;\\n    \\n    for (i = 1; i < n ; i += 2)\\n        x ^= encoded[i];\\n\\n    int *result = calloc(n + 1, sizeof(int));\\n    result[0] = x;\\n\\n    for (i = 0; i < n; i++)\\n        result[i + 1] = result[i] ^ encoded[i];\\n\\n    *returnSize = n + 1;\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decode(int* encoded, int encodedSize, int* returnSize){\\n    int i, x = 0, n = encodedSize, j = 1;\\n\\n    for (i = 1; i <= n + 1; i++) \\n        x ^= i;\\n    \\n    for (i = 1; i < n ; i += 2)\\n        x ^= encoded[i];\\n\\n    int *result = calloc(n + 1, sizeof(int));\\n    result[0] = x;\\n\\n    for (i = 0; i < n; i++)\\n        result[i + 1] = result[i] ^ encoded[i];\\n\\n    *returnSize = n + 1;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2942322,
                "title": "c-simple-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int a=0,runningxor=0;\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            runningxor^=encoded[i];\\n            a^=runningxor;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            a^=i;\\n        }\\n        vector<int>arr(n);\\n        arr[0]=a;\\n        for(int i=1;i<n;i++)\\n        {\\n            arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int a=0,runningxor=0;\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            runningxor^=encoded[i];\\n            a^=runningxor;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            a^=i;\\n        }\\n        vector<int>arr(n);\\n        arr[0]=a;\\n        for(int i=1;i<n;i++)\\n        {\\n            arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937138,
                "title": "python-xor-clean-code-o-n",
                "content": "# Code\\n```\\nfrom functools import reduce\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        r = 0\\n        n = len(encoded)\\n        for i in range(1,n,2):\\n            r = r ^ encoded[i]\\n        total = reduce(lambda x, y: x^y, list(range(1,n+2)))\\n        perm0 = total ^ r\\n        res = [perm0]\\n        for i in range(n):\\n            res.append(res[-1]^encoded[i])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        r = 0\\n        n = len(encoded)\\n        for i in range(1,n,2):\\n            r = r ^ encoded[i]\\n        total = reduce(lambda x, y: x^y, list(range(1,n+2)))\\n        perm0 = total ^ r\\n        res = [perm0]\\n        for i in range(n):\\n            res.append(res[-1]^encoded[i])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918363,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int xorr=0;\\n        vector<int>ans(n,0);\\n        //xor of all elements from 1 to n\\n        for(int i=1;i<=n;i++){\\n            xorr=xorr^i;\\n        }\\n        //change encoded as[a1^a2,a1^a3,a1^a4,......](even size)\\n        for(int i=1;i<n-1;i++){\\n            encoded[i]=encoded[i]^encoded[i-1];\\n        }\\n        //find first element by xor of xorr and all elements of encode\\n        for(int i=0;i<n-1;i++){\\n            xorr=xorr^encoded[i];\\n        }\\n        ans[0]=xorr;\\n        //now take xor of each element of encode with first element xorr\\n        for(int i=0;i<n-1;i++){\\n            encoded[i]=xorr^encoded[i];\\n            ans[i+1]=encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int xorr=0;\\n        vector<int>ans(n,0);\\n        //xor of all elements from 1 to n\\n        for(int i=1;i<=n;i++){\\n            xorr=xorr^i;\\n        }\\n        //change encoded as[a1^a2,a1^a3,a1^a4,......](even size)\\n        for(int i=1;i<n-1;i++){\\n            encoded[i]=encoded[i]^encoded[i-1];\\n        }\\n        //find first element by xor of xorr and all elements of encode\\n        for(int i=0;i<n-1;i++){\\n            xorr=xorr^encoded[i];\\n        }\\n        ans[0]=xorr;\\n        //now take xor of each element of encode with first element xorr\\n        for(int i=0;i<n-1;i++){\\n            encoded[i]=xorr^encoded[i];\\n            ans[i+1]=encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774523,
                "title": "simple-solution-to-get-perm-0",
                "content": "``` java\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length + 1;\\n        int[] res = new int[n];\\n        int t = 0;\\n        for(int i = 1; i <= n; i++) {\\n            t ^= i;\\n        }\\n        int i = 1;\\n        while(i < n-1) {\\n            res[0] ^= encoded[i];\\n            i += 2;\\n        }\\n        res[0] ^= t;\\n        for(i = 1; i < n; i++) {\\n            res[i] = encoded[i-1] ^ res[i-1];\\n        }\\n        return res;\\n    }\\n}\\n\\n// perm[0] ^ perm[1] = en[0]\\n// perm[1] ^ perm[2] = en[1]\\n// perm[2] ^ perm[3] = en[2]\\n// perm[3] ^ perm[4] = en[3]\\n// t = perm[0] ^ perm[1] ^ perm[2] ^ perm[3] ^ perm[4]\\n// t = 1 ^ 2 ^ ... ^ n\\n// 0 -> en[1] ^ en[3] ^ en[5] ^ ... ^ t\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length + 1;\\n        int[] res = new int[n];\\n        int t = 0;\\n        for(int i = 1; i <= n; i++) {\\n            t ^= i;\\n        }\\n        int i = 1;\\n        while(i < n-1) {\\n            res[0] ^= encoded[i];\\n            i += 2;\\n        }\\n        res[0] ^= t;\\n        for(i = 1; i < n; i++) {\\n            res[i] = encoded[i-1] ^ res[i-1];\\n        }\\n        return res;\\n    }\\n}\\n\\n// perm[0] ^ perm[1] = en[0]\\n// perm[1] ^ perm[2] = en[1]\\n// perm[2] ^ perm[3] = en[2]\\n// perm[3] ^ perm[4] = en[3]\\n// t = perm[0] ^ perm[1] ^ perm[2] ^ perm[3] ^ perm[4]\\n// t = 1 ^ 2 ^ ... ^ n\\n// 0 -> en[1] ^ en[3] ^ en[5] ^ ... ^ t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703883,
                "title": "c-easy-and-fast-solution",
                "content": "\\t\\tint x=0;  vector<int>vec;\\n        \\n        for(int i=1;i<encoded.size()+2;i++) x=x^i;\\n        \\n        for(int i=1;i<encoded.size();i=i+2) x=x^encoded[i];\\n        \\n        vec.push_back(x);\\n        \\n        for(int i=0;i<encoded.size();i++) vec.push_back(vec.back()^encoded[i]);\\n        \\n        return vec;",
                "solutionTags": [],
                "code": "\\t\\tint x=0;  vector<int>vec;\\n        \\n        for(int i=1;i<encoded.size()+2;i++) x=x^i;\\n        \\n        for(int i=1;i<encoded.size();i=i+2) x=x^encoded[i];\\n        \\n        vec.push_back(x);\\n        \\n        for(int i=0;i<encoded.size();i++) vec.push_back(vec.back()^encoded[i]);\\n        \\n        return vec;",
                "codeTag": "Unknown"
            },
            {
                "id": 2699647,
                "title": "c-solution-explained-with-example-easy-to-understand-detailed-solution",
                "content": "Lets assume our original permutation is \\na b c d e f g\\n\\nlets say the encoded array is \\n1 2 3 4 5 6\\n\\ntherfore,\\n1=a^b\\n2=b^c\\n3=c^d\\n4=d^e\\n5=e^f\\n6=f^g\\n\\nif we xor 1 3 5 we get,\\n1^3^5=a^b^c^d^e^f   (eqn 1)\\n\\nwe know that the permutation is of first n numbers. in this example n=7\\nso if we xor 1...7 we get  a^b^c...^g.\\n\\nlet x=1^2^3.....^7\\n\\nxoring eqn 1 with x on both sides,\\nx^1^3^5=g (because on RHS we will have every element twice except g)\\n\\nnow lets try calculate f. \\n6=f^g\\nXORing g on both sides,\\n6^g=f. \\nboth g and 6 are known\\nsimilary we can get all elements\\n\\ngeneral equation\\nans[i]=ans[i+1]^encoded[i]. (run i from n-2 to 0)\\n\\nNOTE n is nothing but size of encoded array +1.\\n\\nCODE-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int x=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            x^=i;\\n        }\\n        int last=0;\\n        for(int i=0;i<encoded.size();i+=2)\\n        {\\n            last^=encoded[i];\\n        }\\n        last=last^x;\\n        \\n        vector<int> ans(n,0);\\n        ans[n-1]=last;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            ans[i]=encoded[i]^ans[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int x=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            x^=i;\\n        }\\n        int last=0;\\n        for(int i=0;i<encoded.size();i+=2)\\n        {\\n            last^=encoded[i];\\n        }\\n        last=last^x;\\n        \\n        vector<int> ans(n,0);\\n        ans[n-1]=last;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            ans[i]=encoded[i]^ans[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684674,
                "title": "python-solution-faster-than-100-full-explanation",
                "content": "\\n```\\n\"\"\"\\n\\t\\t1. It is important to get familiar with bitwise XOR. Take a look:\\n\\t\\t\\t\\t\\tBASE-10: 1 ^ 2 = 3 \\n\\t\\t\\t\\t\\tBASE-2: 01 ^ 10 = 11\\n\\n\\t\\t\\t\\t\\tBASE-10: 3 ^ 4 = 7\\n\\t\\t\\t\\t\\tBASE-2: 011 ^ 100 = 111\\n\\n\\t\\t\\t\\t\\tBASE-10: 5 ^ 6 = 3\\n\\t\\t\\t\\t\\tBASE-2: 101 ^ 110 = 011\\n\\n\\t\\t2. Take a look at this XOR property:\\n\\t\\t\\tBASE-10: (1 ^ 2 ^ 3) ^ (2 ^ 3) = 1\\n\\t\\t\\tBASE-2: (1 ^ 10 ^ 11) ^ (10 ^ 11) = (00) ^ (01) = 01\\n\\n\\t\\t\\tPut more simply:\\n\\t\\t\\tBASE-10: 8 ^ 8 = 0\\n\\t\\t\\tBASE-2: 1000 ^ 1000 = 0000\\n\\n\\t\\t3. Strategy:\\n\\t\\t\\tExample: \\n\\t\\t\\t\\tPerm    = [1, 2, 3, 4, 5]\\n\\t\\t\\t\\tEncoded = [1^2, 2^3, 3^4, 4^5] \\n\\t\\t\\t\\t\\t\\t= [3, 1, 7, 1]\\n\\n\\t\\t\\t\\tIf we can do something like this...\\n\\t\\t\\t\\t\\tBASE-10: (2^3^4^5) ^ (1^2^3^4^5) = 1\\n\\t\\t\\t\\t\\tBASE-2: (10^11^100^101) ^ (1^10^11^100^101) = 1\\n\\t\\t\\t\\t...then we could find the first element (which is 1 in this case).\\n\\n\\t\\t\\t\\tWe CAN do this! \\n\"\"\"\\n\\'\\'\\'\\n\\t\\t\\t\\tWe know that the perm list is a permutation of the integers \\n\\t\\t\\t\\tfrom 1...n so this part (1^2^3^4^5) is taken care of:\\n\\t\\t\\t\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tThe first part is a bit more tricky, we can take the ODD entries of the encoded list:\\n\\t\\t\\t\\t[3, 1, 7, 1] = [1^2, 2^3, 3^4, 4^5]  --> (2 ^ 3 ^ 4 ^ 5) = \\n\\t\\t\\t\\tThe intuition lies in realizing that we can XOR every number in the perm list except\\n\\t\\t\\t\\tthe first element by start at the second element in encoded and skipping one\\n\\t\\t\\t\\twhile iterating.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tNow, when we have the first element. From here, we can apply this XOR property:\\n\\t\\t\\t\\t1 ^ 2 = 3 --> 1 ^ 3 = 2 --> 3 ^ 2 = 1\\n\\t\\t\\t\\t1 ^ x = 3 --> x = 1 ^ 3 --> x = 2\\n\\t\\t\\t\\tThus, to get the second element in the perm, we do:\\n\\t\\t\\t\\tsecondPermElem = firstPermElem ^ firstEncodedElem \\n\\t\\t\\t\\t\\t\\t\\t   = firstPermElem ^ firstPermElem ^ secondPermElem\\n\\t\\t\\t\\t\\t\\t\\t   = secondPermElem\\n\\t\\t\\t\\tWe can continue this process to the end now.\\n\\'\\'\\'\\n\\t\\t\\t\\t\\n\\t\\ta = 0\\n        lengthOfPerm = len(encoded) + 1\\n        \\n\\t\\t# (2^3^4^5)\\n        for i in range(1, len(encoded), 2):\\n            a ^= encoded[i]\\n        # (1^2^3^4^5)\\n        for i in range(1, lengthOfPerm + 1):\\n            a ^= i\\n        # at this point, a = 1\\n        final = [a]\\n        for i in encoded:\\n            final.append(a ^ i)\\n            a ^= i\\n        return final\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\"\"\"\\n\\t\\t1. It is important to get familiar with bitwise XOR. Take a look:\\n\\t\\t\\t\\t\\tBASE-10: 1 ^ 2 = 3 \\n\\t\\t\\t\\t\\tBASE-2: 01 ^ 10 = 11\\n\\n\\t\\t\\t\\t\\tBASE-10: 3 ^ 4 = 7\\n\\t\\t\\t\\t\\tBASE-2: 011 ^ 100 = 111\\n\\n\\t\\t\\t\\t\\tBASE-10: 5 ^ 6 = 3\\n\\t\\t\\t\\t\\tBASE-2: 101 ^ 110 = 011\\n\\n\\t\\t2. Take a look at this XOR property:\\n\\t\\t\\tBASE-10: (1 ^ 2 ^ 3) ^ (2 ^ 3) = 1\\n\\t\\t\\tBASE-2: (1 ^ 10 ^ 11) ^ (10 ^ 11) = (00) ^ (01) = 01\\n\\n\\t\\t\\tPut more simply:\\n\\t\\t\\tBASE-10: 8 ^ 8 = 0\\n\\t\\t\\tBASE-2: 1000 ^ 1000 = 0000\\n\\n\\t\\t3. Strategy:\\n\\t\\t\\tExample: \\n\\t\\t\\t\\tPerm    = [1, 2, 3, 4, 5]\\n\\t\\t\\t\\tEncoded = [1^2, 2^3, 3^4, 4^5] \\n\\t\\t\\t\\t\\t\\t= [3, 1, 7, 1]\\n\\n\\t\\t\\t\\tIf we can do something like this...\\n\\t\\t\\t\\t\\tBASE-10: (2^3^4^5) ^ (1^2^3^4^5) = 1\\n\\t\\t\\t\\t\\tBASE-2: (10^11^100^101) ^ (1^10^11^100^101) = 1\\n\\t\\t\\t\\t...then we could find the first element (which is 1 in this case).\\n\\n\\t\\t\\t\\tWe CAN do this! \\n\"\"\"\\n\\'\\'\\'\\n\\t\\t\\t\\tWe know that the perm list is a permutation of the integers \\n\\t\\t\\t\\tfrom 1...n so this part (1^2^3^4^5) is taken care of:\\n\\t\\t\\t\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tThe first part is a bit more tricky, we can take the ODD entries of the encoded list:\\n\\t\\t\\t\\t[3, 1, 7, 1] = [1^2, 2^3, 3^4, 4^5]  --> (2 ^ 3 ^ 4 ^ 5) = \\n\\t\\t\\t\\tThe intuition lies in realizing that we can XOR every number in the perm list except\\n\\t\\t\\t\\tthe first element by start at the second element in encoded and skipping one\\n\\t\\t\\t\\twhile iterating.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tNow, when we have the first element. From here, we can apply this XOR property:\\n\\t\\t\\t\\t1 ^ 2 = 3 --> 1 ^ 3 = 2 --> 3 ^ 2 = 1\\n\\t\\t\\t\\t1 ^ x = 3 --> x = 1 ^ 3 --> x = 2\\n\\t\\t\\t\\tThus, to get the second element in the perm, we do:\\n\\t\\t\\t\\tsecondPermElem = firstPermElem ^ firstEncodedElem \\n\\t\\t\\t\\t\\t\\t\\t   = firstPermElem ^ firstPermElem ^ secondPermElem\\n\\t\\t\\t\\t\\t\\t\\t   = secondPermElem\\n\\t\\t\\t\\tWe can continue this process to the end now.\\n\\'\\'\\'\\n\\t\\t\\t\\t\\n\\t\\ta = 0\\n        lengthOfPerm = len(encoded) + 1\\n        \\n\\t\\t# (2^3^4^5)\\n        for i in range(1, len(encoded), 2):\\n            a ^= encoded[i]\\n        # (1^2^3^4^5)\\n        for i in range(1, lengthOfPerm + 1):\\n            a ^= i\\n        # at this point, a = 1\\n        final = [a]\\n        for i in encoded:\\n            final.append(a ^ i)\\n            a ^= i\\n        return final\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2673976,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        l=[]\\n        x=0\\n        n=len(encoded)+1\\n        for i in range (1,n+1):      # xor of 1 to n+1\\n            x^=i\\n            #print(x)\\n        for i in range (len(encoded)):   #xor of normal array whoes index is odd\\n            if i%2==1:\\n                x^=encoded[i]\\n                print(x)                 #finding first element of an output\\n        l.append(x)\\n        #print(l)\\n        for i in range (len(encoded)):        #finding first element then calculating xor with encoded elements \\n            x=l[i]^encoded[i]\\n            l.append(x)\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        l=[]\\n        x=0\\n        n=len(encoded)+1\\n        for i in range (1,n+1):      # xor of 1 to n+1\\n            x^=i\\n            #print(x)\\n        for i in range (len(encoded)):   #xor of normal array whoes index is odd\\n            if i%2==1:\\n                x^=encoded[i]\\n                print(x)                 #finding first element of an output\\n        l.append(x)\\n        #print(l)\\n        for i in range (len(encoded)):        #finding first element then calculating xor with encoded elements \\n            x=l[i]^encoded[i]\\n            l.append(x)\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644298,
                "title": "c-easy-step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int> decode(vector<int>& A) {\\n        int n = A.size() + 1, a = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            a ^= i;\\n            if (i < n && i % 2 == 1) {\\n                a ^= A[i];\\n            }\\n        }\\n        vector<int> res = {a};\\n        for (int a: A) {\\n            res.push_back(res.back() ^ a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> decode(vector<int>& A) {\\n        int n = A.size() + 1, a = 0;\\n        for (int i = 0; i <= n; ++i) {\\n            a ^= i;\\n            if (i < n && i % 2 == 1) {\\n                a ^= A[i];\\n            }\\n        }\\n        vector<int> res = {a};\\n        for (int a: A) {\\n            res.push_back(res.back() ^ a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633243,
                "title": "decode-xored-permutation-c-easy-to-understand",
                "content": "```\\n//Please Upvote\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){ // XOR of all elemnts\\n            ans ^= i;\\n        }\\n        vector<int> v;\\n        int i = encoded.size()-1;\\n        while(i >= 0){\\n            ans ^= encoded[i];\\n            i -= 2;\\n        }\\n        v.push_back(ans);\\n        for(int i=0; i!=n-1; i++){\\n            v.push_back(v[i]^encoded[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Please Upvote\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){ // XOR of all elemnts\\n            ans ^= i;\\n        }\\n        vector<int> v;\\n        int i = encoded.size()-1;\\n        while(i >= 0){\\n            ans ^= encoded[i];\\n            i -= 2;\\n        }\\n        v.push_back(ans);\\n        for(int i=0; i!=n-1; i++){\\n            v.push_back(v[i]^encoded[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630072,
                "title": "best-easy-beginner-approach-o-n",
                "content": "class Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        lst=[]\\n        bst=[]\\n        x=0        \\n        lst.append(x)\\n        n=len(encoded)+1\\n        for i in range(1,n+1):\\n            a=lst[-1]^i\\n            lst.append(a)\\n        b=lst[-1]\\n        c=encoded[1::2]\\n        for i in c:\\n            b^=i\\n        bst.append(b)\\n        for i in encoded:\\n            e=bst[-1]^i\\n            bst.append(e)\\n        return(bst)",
                "solutionTags": [],
                "code": "class Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        lst=[]\\n        bst=[]\\n        x=0        \\n        lst.append(x)\\n        n=len(encoded)+1\\n        for i in range(1,n+1):\\n            a=lst[-1]^i\\n            lst.append(a)\\n        b=lst[-1]\\n        c=encoded[1::2]\\n        for i in c:\\n            b^=i\\n        bst.append(b)\\n        for i in encoded:\\n            e=bst[-1]^i\\n            bst.append(e)\\n        return(bst)",
                "codeTag": "Java"
            },
            {
                "id": 2628041,
                "title": "c-logical-solution-using-xor-opperations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int>ans;\\n        int a=0;\\n        int n=encoded.size()+1;\\n        for(int i=1;i<=n;i++)       //taking XOR of the elements\\n        {\\n            a=a^i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(i%2==1)              //taking xor of odd index\\n            {\\n                a=a^encoded[i];\\n            }\\n        }\\n        ans.push_back(a);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans.push_back(ans[i]^encoded[i]);       //xor of the array fromed\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        vector<int>ans;\\n        int a=0;\\n        int n=encoded.size()+1;\\n        for(int i=1;i<=n;i++)       //taking XOR of the elements\\n        {\\n            a=a^i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(i%2==1)              //taking xor of odd index\\n            {\\n                a=a^encoded[i];\\n            }\\n        }\\n        ans.push_back(a);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans.push_back(ans[i]^encoded[i]);       //xor of the array fromed\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627536,
                "title": "easy-and-beginner-friendly",
                "content": "ans=[]\\n        n=len(encoded)+1\\n        if n%4==1:\\n            x=1\\n        else:\\n            x=0\\n        for i in range(1,n,2):\\n            x^=encoded[i]\\n        ans.append(x)\\n        for i in range(1,n):\\n            ans.append(ans[i-1]^encoded[i-1])\\n        return ans",
                "solutionTags": [],
                "code": "ans=[]\\n        n=len(encoded)+1\\n        if n%4==1:\\n            x=1\\n        else:\\n            x=0\\n        for i in range(1,n,2):\\n            x^=encoded[i]\\n        ans.append(x)\\n        for i in range(1,n):\\n            ans.append(ans[i-1]^encoded[i-1])\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 2626895,
                "title": "easy-understanding-python-solution",
                "content": "def decode(self, encoded: List[int]) -> List[int]:\\n        n=len(encoded)+1\\n        temp=1\\n        for i in range(2,n+1):\\n            temp^=i\\n        for j in range(1,len(encoded),2):\\n            temp^=encoded[j]\\n        ans=[temp]\\n        for i in encoded:\\n            ans.append(i^ans[-1])\\n        return ans",
                "solutionTags": [],
                "code": "def decode(self, encoded: List[int]) -> List[int]:\\n        n=len(encoded)+1\\n        temp=1\\n        for i in range(2,n+1):\\n            temp^=i\\n        for j in range(1,len(encoded),2):\\n            temp^=encoded[j]\\n        ans=[temp]\\n        for i in encoded:\\n            ans.append(i^ans[-1])\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2608784,
                "title": "ruby-t-o-n-s-o-1-100-100",
                "content": "```\\n# @param {Integer[]} encoded\\n# @return {Integer[]}\\ndef decode(encoded)\\n  n = encoded.size + 1\\n  agg_encoded = encoded.reduce(&:^)\\n  agg_original = 1.upto(n).reduce(&:^)\\n\\n  agg_mids = agg_original ^ agg_encoded\\n  i = n - 3\\n\\n  while i > 1\\n    agg_mids ^= encoded[i]\\n    i -= 2\\n  end\\n\\n  result = Array.new(n)\\n\\n  result[1] = agg_mids\\n  result[0] = encoded[0] ^ agg_mids\\n\\n  1.upto(n - 2) do |i|\\n    result[i + 1] = encoded[i] ^ result[i]\\n  end\\n\\n  result\\nend\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} encoded\\n# @return {Integer[]}\\ndef decode(encoded)\\n  n = encoded.size + 1\\n  agg_encoded = encoded.reduce(&:^)\\n  agg_original = 1.upto(n).reduce(&:^)\\n\\n  agg_mids = agg_original ^ agg_encoded\\n  i = n - 3\\n\\n  while i > 1\\n    agg_mids ^= encoded[i]\\n    i -= 2\\n  end\\n\\n  result = Array.new(n)\\n\\n  result[1] = agg_mids\\n  result[0] = encoded[0] ^ agg_mids\\n\\n  1.upto(n - 2) do |i|\\n    result[i + 1] = encoded[i] ^ result[i]\\n  end\\n\\n  result\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2583707,
                "title": "java-o-n-use-properties-of-xor",
                "content": "We can use properties of XOR here. If we XOR alternate elements of the input array and XOR it with total from `1 to n`, we will get the first and the last elements. And then the rest of the process makes use of the following equation\\n\\n`a^(a^b) == b`\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length;\\n        int res[] = new int[n+1];\\n        int totalXor = getTotalXor(n+1);\\n        int alternateOne = getAlternateXor(encoded, 0);\\n        int alternateTwo = getAlternateXor(encoded, 1);\\n        res[n] = totalXor ^ alternateOne;\\n        res[0] = totalXor ^ alternateTwo;\\n        for(int i = 1; i<n; i++) {\\n            res[i] = encoded[i-1] ^ res[i-1];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int getAlternateXor(int encoded[], int start) {\\n        int res = 0;\\n        for(int i = start; i<encoded.length; i+=2)\\n            res ^= encoded[i];\\n        \\n        return res;\\n    }\\n    \\n    int getTotalXor(int n) {\\n        int res = 0;\\n        for(int i = 1; i<=n; i++)\\n            res ^= i;\\n        \\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length;\\n        int res[] = new int[n+1];\\n        int totalXor = getTotalXor(n+1);\\n        int alternateOne = getAlternateXor(encoded, 0);\\n        int alternateTwo = getAlternateXor(encoded, 1);\\n        res[n] = totalXor ^ alternateOne;\\n        res[0] = totalXor ^ alternateTwo;\\n        for(int i = 1; i<n; i++) {\\n            res[i] = encoded[i-1] ^ res[i-1];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int getAlternateXor(int encoded[], int start) {\\n        int res = 0;\\n        for(int i = start; i<encoded.length; i+=2)\\n            res ^= encoded[i];\\n        \\n        return res;\\n    }\\n    \\n    int getTotalXor(int n) {\\n        int res = 0;\\n        for(int i = 1; i<=n; i++)\\n            res ^= i;\\n        \\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493537,
                "title": "deatiled-c-solution",
                "content": "by thLet the permutation array is p[];\\nen[0]=p[0] xor p[1];\\nen[1]=p[1] xor p[2];\\nen[2]=p[2] xor p[3]; \\n\\nso on,\\n\\nLet the number in from 1-n;\\nWe have to first find the p[0] and afetr this we can find all the number easily. For this first we have to calculate the xor of all the number form 1 to n.\\nAnd by using some math from the given encoded array and from the xor of number from 1 to n we can find the p[0].After this we can find the value of permutation easily.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size();\\n        int x1=0,x2=0;\\n        for(int i=1;i<n;i=i+2)\\n        {\\n            x1=x1 xor encoded[i];\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            x2=x2 xor i;\\n        }\\n        int a=x1 xor x2;\\n        vector<int>v(n+1);\\n        v[0]=a;\\n        int c=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[c]=encoded[i] xor v[c-1];\\n            c++;\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size();\\n        int x1=0,x2=0;\\n        for(int i=1;i<n;i=i+2)\\n        {\\n            x1=x1 xor encoded[i];\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            x2=x2 xor i;\\n        }\\n        int a=x1 xor x2;\\n        vector<int>v(n+1);\\n        v[0]=a;\\n        int c=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[c]=encoded[i] xor v[c-1];\\n            c++;\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469941,
                "title": "clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int total_xor = 0 , n = encoded.size();\\n        \\n        for(int i = 1; i <= n + 1; i++)\\n            total_xor ^= i;\\n        \\n        int i = 0;\\n        int temp_xor = 0;\\n        \\n        while(i < encoded.size()){\\n            temp_xor ^= encoded[i];\\n            i += 2;\\n        }\\n        \\n        int last_ele = total_xor ^ temp_xor;\\n        vector<int> ans(n + 1);\\n        ans[n] = last_ele;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            int temp_ele = encoded[i]^last_ele;\\n            ans[i] = temp_ele;\\n            last_ele = temp_ele;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int total_xor = 0 , n = encoded.size();\\n        \\n        for(int i = 1; i <= n + 1; i++)\\n            total_xor ^= i;\\n        \\n        int i = 0;\\n        int temp_xor = 0;\\n        \\n        while(i < encoded.size()){\\n            temp_xor ^= encoded[i];\\n            i += 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2437483,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        res = [reduce(xor, list(range(len(encoded) + 2)) + encoded[1::2])]\\n        for e in encoded:\\n            res.append(res[-1] ^ e)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        res = [reduce(xor, list(range(len(encoded) + 2)) + encoded[1::2])]\\n        for e in encoded:\\n            res.append(res[-1] ^ e)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276876,
                "title": "python-3-find-the-first-element",
                "content": "\\tclass Solution:\\n\\t\\tdef decode(self, encoded: List[int]) -> List[int]:\\n\\t\\t\\tn=len(encoded)+1\\n\\t\\t\\ta=0\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\tif i%2 and i<n-1:\\n\\t\\t\\t\\t\\ta^=encoded[i]\\n\\t\\t\\t\\ta^=i\\n\\t\\t\\tres=[a]\\n\\t\\t\\tfor x in encoded:\\n\\t\\t\\t\\ta^=x\\n\\t\\t\\t\\tres.append(a)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef decode(self, encoded: List[int]) -> List[int]:\\n\\t\\t\\tn=len(encoded)+1\\n\\t\\t\\ta=0\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\tif i%2 and i<n-1:\\n\\t\\t\\t\\t\\ta^=encoded[i]\\n\\t\\t\\t\\ta^=i\\n\\t\\t\\tres=[a]\\n\\t\\t\\tfor x in encoded:\\n\\t\\t\\t\\ta^=x\\n\\t\\t\\t\\tres.append(a)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2213677,
                "title": "simple-c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n        vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int xorSum=0;\\n        vector<int> v;\\n        for(int i=1; i<=n; i++)\\n            xorSum^=i;\\n        for(int i=1; i<encoded.size(); i+=2)\\n            xorSum^=encoded[i];\\n        v.push_back(xorSum);\\n        for(auto i:encoded){\\n            int n1=v.size();\\n            v.push_back(v[n1-1]^i); //Xor with last element of V to current encoded[i]\\n        }\\n        return v;\\n        \\n        }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int xorSum=0;\\n        vector<int> v;\\n        for(int i=1; i<=n; i++)\\n            xorSum^=i;\\n        for(int i=1; i<encoded.size(); i+=2)\\n            xorSum^=encoded[i];\\n        v.push_back(xorSum);\\n        for(auto i:encoded){\\n            int n1=v.size();\\n            v.push_back(v[n1-1]^i); //Xor with last element of V to current encoded[i]\\n        }\\n        return v;\\n        \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211233,
                "title": "python-simple-maths",
                "content": "\\n    def decode(self, encoded):\\n        n, x = len(encoded), 0\\n        \\n        for i in range(1, n, 2):\\n            x = x^encoded[i]\\n            \\n        for i in range(1, n+2):\\n            x = x^i\\n            \\n        result = [x] + [0]*n\\n        \\n        for i in range(n):\\n            result[i+1] = result[i]^encoded[i]\\n            \\n        return result",
                "solutionTags": [],
                "code": "\\n    def decode(self, encoded):\\n        n, x = len(encoded), 0\\n        \\n        for i in range(1, n, 2):\\n            x = x^encoded[i]\\n            \\n        for i in range(1, n+2):\\n            x = x^i\\n            \\n        result = [x] + [0]*n\\n        \\n        for i in range(n):\\n            result[i+1] = result[i]^encoded[i]\\n            \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2159007,
                "title": "c-solution-xor",
                "content": "```\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1, x=0;\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++)\\n            x^=i;\\n        for(int i=1; i<encoded.size(); i+=2)\\n            x^=encoded[i];\\n        ans.push_back(x);\\n        for(int i=0; i<encoded.size(); i++)\\n            ans.push_back(ans.back()^encoded[i]);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1, x=0;\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++)\\n            x^=i;\\n        for(int i=1; i<encoded.size(); i+=2)\\n            x^=encoded[i];\\n        ans.push_back(x);\\n        for(int i=0; i<encoded.size(); i++)\\n            ans.push_back(ans.back()^encoded[i]);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138050,
                "title": "bitmasking-c-observation",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   vector<int> decode(vector<int>& encoded) \\n    {\\n\\t  //here a1,a2,a3...are the values of permutation which we have to find\\n\\t   //lets take example of n==5\\n\\t\\t//so we  are given a1^a2 , a2^a3 , a3^a4 , a4^a5 values in encoded vector\\n\\t\\t//we can take the xor of elements from 1 to n that will be equal to a1^a2^a3^a4^a5\\n\\t\\t//we can take out the value of a1^a2^a3^a4 from the given encoded vector\\n\\t\\t//(a1^a2^a3^a4)^(a5)=xor of elements from 1 to n\\n\\t\\t// so we will get the value of a5\\n\\t\\t//after that its just brute force\\n\\t\\t\\n        int n=encoded.size();\\n        int xr=0;\\n        for(int i=0;i<n;i+=2)\\n        {\\n            xr=xr^encoded[i];\\n        }\\n\\t\\tint xr1=0;\\n        for(int i=1;i<=n+1;i++)\\n        {\\n         xr1=xr1^i;\\n        }\\n        int last=xr1^xr;\\n        vector<int>v;\\n        for(int i=0;i<n+1;i++)\\n        {\\n         v.push_back(0);\\n        }\\n        n=n+1;\\n        v[n-1]=last;\\n        int ind=n-2;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            v[ind]=v[ind+1]^encoded[i];\\n            ind--;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n   vector<int> decode(vector<int>& encoded) \\n    {\\n\\t  //here a1,a2,a3...are the values of permutation which we have to find\\n\\t   //lets take example of n==5\\n\\t\\t//so we  are given a1^a2 , a2^a3 , a3^a4 , a4^a5 values in encoded vector\\n\\t\\t//we can take the xor of elements from 1 to n that will be equal to a1^a2^a3^a4^a5\\n\\t\\t//we can take out the value of a1^a2^a3^a4 from the given encoded vector\\n\\t\\t//(a1^a2^a3^a4)^(a5)=xor of elements from 1 to n\\n\\t\\t// so we will get the value of a5\\n\\t\\t//after that its just brute force\\n\\t\\t\\n        int n=encoded.size();\\n        int xr=0;\\n        for(int i=0;i<n;i+=2)\\n        {\\n            xr=xr^encoded[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2108661,
                "title": "javascript-bit-manipulation-469ms",
                "content": "key point is how to get first\\n```\\nconst decode = function (a) {\\n    let x = 0, n = a.length + 1;\\n    for (let i = 1; i <= n; i++) x ^= i;\\n    let first = x;\\n    for (let i = 1; i < n - 1; i += 2) first ^= a[i];\\n    let res = [first];\\n    for (const x of a) res.push(res[res.length - 1] ^ x);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst decode = function (a) {\\n    let x = 0, n = a.length + 1;\\n    for (let i = 1; i <= n; i++) x ^= i;\\n    let first = x;\\n    for (let i = 1; i < n - 1; i += 2) first ^= a[i];\\n    let res = [first];\\n    for (const x of a) res.push(res[res.length - 1] ^ x);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032110,
                "title": "c-simple-solution-tc-o-n-and-sc-o-1",
                "content": "```\\n vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        \\n        int Xor = 0;\\n        for(int i = 1 ; i <= n ; i++) Xor ^= i;\\n        \\n        for(int i = 0 ; i < encoded.size() ; i += 2) {\\n            Xor ^= encoded[i];\\n        }\\n        \\n        vector<int> arr(n);\\n        arr[n-1] = Xor;\\n        for(int i = n-2 ; i >= 0 ; i--) {\\n            arr[i] = encoded[i] ^ arr[i+1];\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        \\n        int Xor = 0;\\n        for(int i = 1 ; i <= n ; i++) Xor ^= i;\\n        \\n        for(int i = 0 ; i < encoded.size() ; i += 2) {\\n            Xor ^= encoded[i];\\n        }\\n        \\n        vector<int> arr(n);\\n        arr[n-1] = Xor;\\n        for(int i = n-2 ; i >= 0 ; i--) {\\n            arr[i] = encoded[i] ^ arr[i+1];\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2015927,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x=1;\\n        int n = encoded.size()+1;\\n        vector<int> myvec(n);\\n        for(int i=1;i<n;i++){\\n            x = x^(i+1);\\n        }\\n        int first=x;\\n        for(int i=1;i<encoded.size();i+=2){\\n            first = first^encoded[i];\\n        }\\n        myvec[0] = first;\\n        for(int i=1;i<n;i++){\\n            myvec[i] = myvec[i-1]^encoded[i-1];\\n        }\\n        return myvec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int x=1;\\n        int n = encoded.size()+1;\\n        vector<int> myvec(n);\\n        for(int i=1;i<n;i++){\\n            x = x^(i+1);\\n        }\\n        int first=x;\\n        for(int i=1;i<encoded.size();i+=2){\\n            first = first^encoded[i];\\n        }\\n        myvec[0] = first;\\n        for(int i=1;i<n;i++){\\n            myvec[i] = myvec[i-1]^encoded[i-1];\\n        }\\n        return myvec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963778,
                "title": "java-explained-with-formula",
                "content": "\\'\\'\\'\\npublic int[] decode(int[] encoded) {\\n    // lets say we have [a,b,c,d,e] as actual array\\n    // step 1: so encoded array would become --> [a^b, b^c, c^d, d^e]\\n    // step 2 : do XOR for even ones from step 1 above we will get --> b^c^d^e (if we take even ones)\\n    // step 3 : we know we have 1 to n do XOR for all of them  (a to e --> a^b^c^d^e)\\n    // finally we can calculate : \\'a = step2 ^ step 3\\' --> (b^c^d^e)^(a^b^c^d^e) == a (since b^b = 0, similarly c,d,e also cancel out leaving \\'a\\' behind)\\n    int ans = 0;\\n    for (int i = 0; i < encoded.length; i++) {\\n      ans ^= i + 1; // doing XOR for all of them \\n      if (i % 2 == 1) {\\n        ans ^= encoded[i]; // doing xor for even ones\\n      }\\n    }\\n    ans ^= encoded.length + 1;\\n\\n    int[] result = new int[encoded.length + 1];\\n    result[0] = ans;\\n    for (int i = 0; i < encoded.length; i++) {\\n      result[i + 1] = result[i] ^ encoded[i]; // if a^b = c --> a^c = b (property of XOR)\\n    }\\n    return result;\\n        \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "\\'\\'\\'\\npublic int[] decode(int[] encoded) {\\n    // lets say we have [a,b,c,d,e] as actual array\\n    // step 1: so encoded array would become --> [a^b, b^c, c^d, d^e]\\n    // step 2 : do XOR for even ones from step 1 above we will get --> b^c^d^e (if we take even ones)\\n    // step 3 : we know we have 1 to n do XOR for all of them  (a to e --> a^b^c^d^e)\\n    // finally we can calculate : \\'a = step2 ^ step 3\\' --> (b^c^d^e)^(a^b^c^d^e) == a (since b^b = 0, similarly c,d,e also cancel out leaving \\'a\\' behind)\\n    int ans = 0;\\n    for (int i = 0; i < encoded.length; i++) {\\n      ans ^= i + 1; // doing XOR for all of them \\n      if (i % 2 == 1) {\\n        ans ^= encoded[i]; // doing xor for even ones\\n      }\\n    }\\n    ans ^= encoded.length + 1;\\n\\n    int[] result = new int[encoded.length + 1];\\n    result[0] = ans;\\n    for (int i = 0; i < encoded.length; i++) {\\n      result[i + 1] = result[i] ^ encoded[i]; // if a^b = c --> a^c = b (property of XOR)\\n    }\\n    return result;\\n        \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1946327,
                "title": "decode-xored-permutation",
                "content": "```\\nclass Solution \\n{\\n public:\\n    vector<int> decode(vector<int>&nums) \\n    {\\n       int n=nums.size();\\n       int total=0,cur=0;\\n       //Picking First Element We know range is 1 to n+1 take xor of all x0^x1^x2^x3^x4 \\n       for(int i=1;i<=n+1;i++)\\n           total=total^i;\\n       //Here we are taking the e1=x1^x2 and e3=x3^x4 e1^e3=x1^x2^x3^x4  \\n       for(int i=1;i<n;i=i+2)\\n           cur=cur^nums[i]; \\n       //Now we will take Xor of total^cur it will remove all the element other than the very first element \\n       int f=total^cur;\\n       vector<int>ans(n+1);\\n       ans[0]=f;\\n       for(int i=1;i<=n;i++)\\n          ans[i]=ans[i-1]^nums[i-1];\\n       return ans;\\n    }\\n};\\n```\\n\\n```\\n/*\\n      //Picking First Element We know range is 1 to n+1 take xor of all x0^x1^x2^x3^x4  \\n       for(int i=1;i<=n+1;i++)\\n           total=total^i;\\n       //Here We are picking the element e0=x0^x1 and e2=x2^x3 the xor of these will result e0^e2=x0^x1^x2^x3 \\n       for(int i=0;i<n;i=i+2)\\n           cur=cur^nums[i]; \\n       //Now we will take Xor of total^cur it will remove all the element other than the very Last Element\\n       int f=total^cur;\\n       vector<int>ans(n+1);\\n       ans[n]=f;\\n       for(int i=n-1;i>=0;i--)\\n           ans[i]=ans[i+1]^nums[i];\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\n public:\\n    vector<int> decode(vector<int>&nums) \\n    {\\n       int n=nums.size();\\n       int total=0,cur=0;\\n       //Picking First Element We know range is 1 to n+1 take xor of all x0^x1^x2^x3^x4 \\n       for(int i=1;i<=n+1;i++)\\n           total=total^i;\\n       //Here we are taking the e1=x1^x2 and e3=x3^x4 e1^e3=x1^x2^x3^x4  \\n       for(int i=1;i<n;i=i+2)\\n           cur=cur^nums[i]; \\n       //Now we will take Xor of total^cur it will remove all the element other than the very first element \\n       int f=total^cur;\\n       vector<int>ans(n+1);\\n       ans[0]=f;\\n       for(int i=1;i<=n;i++)\\n          ans[i]=ans[i-1]^nums[i-1];\\n       return ans;\\n    }\\n};\\n```\n```\\n/*\\n      //Picking First Element We know range is 1 to n+1 take xor of all x0^x1^x2^x3^x4  \\n       for(int i=1;i<=n+1;i++)\\n           total=total^i;\\n       //Here We are picking the element e0=x0^x1 and e2=x2^x3 the xor of these will result e0^e2=x0^x1^x2^x3 \\n       for(int i=0;i<n;i=i+2)\\n           cur=cur^nums[i]; \\n       //Now we will take Xor of total^cur it will remove all the element other than the very Last Element\\n       int f=total^cur;\\n       vector<int>ans(n+1);\\n       ans[n]=f;\\n       for(int i=n-1;i>=0;i--)\\n           ans[i]=ans[i+1]^nums[i];\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938084,
                "title": "python-o-n-o-1-with-detailed-explanation",
                "content": "According to the explanation, the encoded array is made according to the following expression:\\n```\\nencoded[i] = perm[i] ^ perm[i+1] \\n```\\n\\nIf we expand this formula to an encoded array of length = 4, encoded is constructed as follows:\\n```\\nencoded[0] = perm[0] ^ perm[1]  \\nencoded[1] = perm[1] ^ perm[2]\\nencoded[2] = perm[2] ^ perm[3]  \\nencoded[3] = perm[3] ^ perm[4]  \\n```\\n\\nThe problem does mention that `perm` is a permutation natural numbers in the range of `[1,n]` where `n = encoded.length + 1`. This means that we know the elements of `perm` if we know the length of `encoded`.\\n\\nFor encoded arrays of length = 4, `perm` elements are `[1,2,3,4,5]`, however we don\\'t know their order, hence the permutation.\\n\\nSince `encoded` are xors of `perms` elements, we can extract the first element of perm by:\\n1. Computing the total xor sum of `perm` - `x`. This is easily done as we know the elements of `perm` once we know the size of `encoded`. \\n2. Isolate the first element by xoring with particular encoded entries, in this case since `perm` elements repeat, we can isolate `perm[0]` by xoring to total xor sum `x` with odd elements of `encoded`. \\n\\nFor an encoded array of length == 4, we have:\\n```\\nx = perm[0] ^ perm[2] ^  perm[3] ^  perm[4] ^ perm[5]\\nencoded[1] = perm[1] ^ perm[2]\\nencoded[3] = perm[3] ^ perm[4] \\nx ^ encoded[1] ^ encoded[3] = (perm[0] ^ perm[2] ^  perm[3] ^  perm[4] ^ perm[5]) ^ (perm[1] ^ perm[2]) ^ (perm[3] ^ perm[4] ) = perm[0]\\n```\\n\\nAll `perm[i]` for `i > 0` are cancelled as `a ^ a = 0`, and the xor operator has the comutative property.\\n\\nOnce we have `perm[0]`, it is easy to find the other elements by deriving the following formula:\\n```\\nencoded[i] = perm[i] ^ perm[i+1] \\nperm[i] ^ encoded[i] = perm[i] ^ perm[i] ^ perm[i+1] \\nperm[i+1] = perm[i] ^ encoded[i]\\n```\\n\\nThe solution is then simply:\\n\\n```python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        x = 0\\n        for el in range(1, n + 1):\\n            x ^= el\\n        for i in range(1, n, 2):\\n            x ^= encoded[i]\\n        decoded = [x]\\n        for i in range(len(encoded)):\\n            decoded.append(decoded[-1] ^ encoded[i])\\n        return decoded\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nencoded[i] = perm[i] ^ perm[i+1] \\n```\n```\\nencoded[0] = perm[0] ^ perm[1]  \\nencoded[1] = perm[1] ^ perm[2]\\nencoded[2] = perm[2] ^ perm[3]  \\nencoded[3] = perm[3] ^ perm[4]  \\n```\n```\\nx = perm[0] ^ perm[2] ^  perm[3] ^  perm[4] ^ perm[5]\\nencoded[1] = perm[1] ^ perm[2]\\nencoded[3] = perm[3] ^ perm[4] \\nx ^ encoded[1] ^ encoded[3] = (perm[0] ^ perm[2] ^  perm[3] ^  perm[4] ^ perm[5]) ^ (perm[1] ^ perm[2]) ^ (perm[3] ^ perm[4] ) = perm[0]\\n```\n```\\nencoded[i] = perm[i] ^ perm[i+1] \\nperm[i] ^ encoded[i] = perm[i] ^ perm[i] ^ perm[i+1] \\nperm[i+1] = perm[i] ^ encoded[i]\\n```\n```python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1\\n        x = 0\\n        for el in range(1, n + 1):\\n            x ^= el\\n        for i in range(1, n, 2):\\n            x ^= encoded[i]\\n        decoded = [x]\\n        for i in range(len(encoded)):\\n            decoded.append(decoded[-1] ^ encoded[i])\\n        return decoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913152,
                "title": "observation-logical-easy-o-n",
                "content": "Here only first element of answer array is needed. That you can find via the code mentioned below.\\nRest stuff is very easy!\\nSuppose our answer array is consisting of 5 numbers  then assume XOR of 1 to 5 =A\\nNow this 1 to 5 are in some order which is not known to us, so suppose they are x1.x2.x3.x4.x5 ans we have to find x1 out of this.\\nSo, x1^x2=e1\\nx2^x3=e2\\nx3^x4=e3\\nx4^x5=e4\\nHere e is given array\\nso x2^x3^x4^x5=e2^e4\\nx1^e2^e4=A;\\nSo x1=A^e2^e4;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& E) {\\n        vector<int> P;\\n        int A=0,B=0;\\n        for(int i=1;i<=E.size()+1;i++){\\n            A^=i;\\n        }\\n        for(int i=1;i<E.size();i+=2){\\n            B^=E[i];\\n        }\\n        P.push_back(A^B);\\n        for(int i=0;i<E.size();i++){\\n            P.push_back(P[i]^E[i]);\\n        }\\n        return P;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& E) {\\n        vector<int> P;\\n        int A=0,B=0;\\n        for(int i=1;i<=E.size()+1;i++){\\n            A^=i;\\n        }\\n        for(int i=1;i<E.size();i+=2){\\n            B^=E[i];\\n        }\\n        P.push_back(A^B);\\n        for(int i=0;i<E.size();i++){\\n            P.push_back(P[i]^E[i]);\\n        }\\n        return P;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863385,
                "title": "python3-o-n",
                "content": "* the problem is we need to find the 1st element, after that it\\'s easy.\\n* first element = total XOR between [1,n] ^ every element in odd index in \\'encoded\\'\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        total=0\\n        for el in range(1,len(encoded)+2):\\n            total^=el\\n        for i in range(1,len(encoded),2):\\n            total^=encoded[i]\\n        res=[total]\\n        for el in encoded:\\n            res.append(res[-1]^el)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        total=0\\n        for el in range(1,len(encoded)+2):\\n            total^=el\\n        for i in range(1,len(encoded),2):\\n            total^=encoded[i]\\n        res=[total]\\n        for el in encoded:\\n            res.append(res[-1]^el)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851129,
                "title": "c-simple-but-little-bit-tricky",
                "content": "Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n    \\n        int totalXor =0, X=0 ;\\n        int n= encoded.size();\\n        \\n        for(int i=1; i<=n+1; i++) totalXor^=i;\\n        for(int i=1 ; i<n; i+=2) X^=encoded[i];\\n        \\n        vector<int> ans(n+1);\\n        ans[0] = X^totalXor;\\n        \\n        for(int i=1; i<=n ; i++ ){\\n            ans[i] = ans[i-1] ^ encoded[i-1];\\n        }\\n     \\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n    \\n        int totalXor =0, X=0 ;\\n        int n= encoded.size();\\n        \\n        for(int i=1; i<=n+1; i++) totalXor^=i;\\n        for(int i=1 ; i<n; i+=2) X^=encoded[i];\\n        \\n        vector<int> ans(n+1);\\n        ans[0] = X^totalXor;\\n        \\n        for(int i=1; i<=n ; i++ ){\\n            ans[i] = ans[i-1] ^ encoded[i-1];\\n        }\\n     \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838535,
                "title": "c-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        //problem is to find the first element\\n        int f=0;\\n        int n=v.size()+1;\\n        for(int i=0;i<=n;i++){\\n            f^=i;//since it has all the numbers from 1 to n\\n            if(i<n&&i%2==1){\\n                f^=v[i];//except 1st we include all the other elements\\n            }\\n        }\\n        vector<int> res = {f};\\n        for (int a: v) {\\n            res.push_back(res.back() ^ a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& v) {\\n        //problem is to find the first element\\n        int f=0;\\n        int n=v.size()+1;\\n        for(int i=0;i<=n;i++){\\n            f^=i;//since it has all the numbers from 1 to n\\n            if(i<n&&i%2==1){\\n                f^=v[i];//except 1st we include all the other elements\\n            }\\n        }\\n        vector<int> res = {f};\\n        for (int a: v) {\\n            res.push_back(res.back() ^ a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731872,
                "title": "python-detailed-explanation-solution-in-o-n",
                "content": "Let the length of encoded array be 4. Which means that N is 5.\\n1. Find the XOR of al elements in  array from 1 till N i.e (1^2^3^4^5)\\n2. Each element in encoded array [a^b,b^c,c^d,d^e]\\n3. Try to find an expression such that elements of encoded array equals tottal XOR:\\nexp=A^(a^b)^(a^b^b^c)^(a^b^b^c^c^d)^(a^b^b^c^c^d^d^e)\\nThe above expression equals to (a^b^c^d^e)\\n4. The first element \\'A\\' lies in 1-N ( find it from array such that exp^A=total XOR)\\n5. Find all other elements from it.\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        perm1=[i for i in range(1,len(encoded)+2)]\\n        totalxor=0\\n        for i in range(len(perm1)):\\n            totalxor^=perm1[i]\\n\\n        present=0\\n        next1=0\\n\\n        i=0\\n        rx=0\\n        while(i<len(encoded)-1):\\n            if(i==0):\\n                present=encoded[i]\\n                next1=present^encoded[i+1]\\n                rx=present^next1\\n            else:\\n                next1=next1^encoded[i+1]\\n                #print(\\'next1\\',next1)\\n                rx^=next1\\n\\n            i+=1\\n\\n        for i in range(1,len(encoded)+2):\\n            if(rx^i==totalxor):\\n                y=i\\n                break\\n\\n\\n        perm=[y]\\n        for i in range(1,len(perm1)):\\n            if(i==1):\\n                perm.append(y^encoded[i-1])\\n            else:\\n                y=perm[-1]\\n                perm.append(y^encoded[i-1])\\n        \\n        return perm\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        perm1=[i for i in range(1,len(encoded)+2)]\\n        totalxor=0\\n        for i in range(len(perm1)):\\n            totalxor^=perm1[i]\\n\\n        present=0\\n        next1=0\\n\\n        i=0\\n        rx=0\\n        while(i<len(encoded)-1):\\n            if(i==0):\\n                present=encoded[i]\\n                next1=present^encoded[i+1]\\n                rx=present^next1\\n            else:\\n                next1=next1^encoded[i+1]\\n                #print(\\'next1\\',next1)\\n                rx^=next1\\n\\n            i+=1\\n\\n        for i in range(1,len(encoded)+2):\\n            if(rx^i==totalxor):\\n                y=i\\n                break\\n\\n\\n        perm=[y]\\n        for i in range(1,len(perm1)):\\n            if(i==1):\\n                perm.append(y^encoded[i-1])\\n            else:\\n                y=perm[-1]\\n                perm.append(y^encoded[i-1])\\n        \\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727051,
                "title": "c-intuitive",
                "content": "Approach : Explanation [here](https://leetcode.com/problems/decode-xored-permutation/discuss/1031107/JavaC%2B%2BPython-Straight-Forward-Solution#:~:text=We%20make%20good%20use%20of%20the%20condition%20%22n%20is%20odd%22%20as%20follow)\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        \\n        vector<int> perm;\\n        int n = encoded.size() + 1;\\n        \\n        // Idea is to get the first element. After that it becomes a piece of cake\\n        int first = 0;\\n        for(int i = 0; i <= n; i++) {\\n            first = first ^ i;           // 1^2^3^......^n\\n            if(i < n and i % 2 == 1) {\\n                // enc[1] = a2^a3, enc[3] = a3^a4, enc[5]....\\n                first = first ^ encoded[i];\\n            }\\n        }\\n        \\n        perm.push_back(first);\\n        \\n        // Find all other numbers\\n        for(int i = 0; i < encoded.size(); i++) {\\n            perm.push_back(encoded[i] ^ perm[i]);\\n        } \\n        \\n        return perm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        \\n        vector<int> perm;\\n        int n = encoded.size() + 1;\\n        \\n        // Idea is to get the first element. After that it becomes a piece of cake\\n        int first = 0;\\n        for(int i = 0; i <= n; i++) {\\n            first = first ^ i;           // 1^2^3^......^n\\n            if(i < n and i % 2 == 1) {\\n                // enc[1] = a2^a3, enc[3] = a3^a4, enc[5]....\\n                first = first ^ encoded[i];\\n            }\\n        }\\n        \\n        perm.push_back(first);\\n        \\n        // Find all other numbers\\n        for(int i = 0; i < encoded.size(); i++) {\\n            perm.push_back(encoded[i] ^ perm[i]);\\n        } \\n        \\n        return perm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702686,
                "title": "python-o-n-finding-last-number",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        xors_except_last = reduce(xor, encoded[::2])\\n        last_item = reduce(xor, range(1, len(encoded)+2), xors_except_last)\\n        \\n        ans = [last_item]\\n        for n in encoded[::-1]:\\n            ans.append(ans[-1] ^ n)\\n\\n        return list(reversed(ans))\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        xors_except_last = reduce(xor, encoded[::2])\\n        last_item = reduce(xor, range(1, len(encoded)+2), xors_except_last)\\n        \\n        ans = [last_item]\\n        for n in encoded[::-1]:\\n            ans.append(ans[-1] ^ n)\\n\\n        return list(reversed(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695112,
                "title": "c-two-rounds-easy-to-understand",
                "content": "Let\\'s assume n =5 and answer is [a,b,c,d,e].  \\none fact is a^b^c^d^e = 1^2^3^4^5, this is because the input is a permutation of the first n positive integers,\\nThere are two major steps:\\n1. find out the first element a\\n\\ta = (a^b^c^d^e) ^(b^c)^(d^e) = (1^2^3^4^5) ^ encoded[1] ^ encoded[3]\\n\\t\\n2. find out other elements\\n\\t\\tb = a ^ (a^b), --> a^b is encoded[0]\\n\\t\\tc = c ^ (b^c), --> b^c is encoded[1]\\n\\t\\t.....\\n\\nNotes: the XOR properity we used here is : (a^b)^b = a^(b^b) = a^0 = a\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        int allXor = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            allXor = allXor ^ i;\\n        }\\n        int oddEncodedXor = 0;\\n        for (int i = 1; i < n; i += 2) {\\n            oddEncodedXor = oddEncodedXor ^ encoded[i];\\n        }\\n        int firstElement = allXor ^ oddEncodedXor;\\n        vector<int> res = {firstElement};\\n        for (int el : encoded) {\\n            res.push_back(res.back() ^ el);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size() + 1;\\n        int allXor = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            allXor = allXor ^ i;\\n        }\\n        int oddEncodedXor = 0;\\n        for (int i = 1; i < n; i += 2) {\\n            oddEncodedXor = oddEncodedXor ^ encoded[i];\\n        }\\n        int firstElement = allXor ^ oddEncodedXor;\\n        vector<int> res = {firstElement};\\n        for (int el : encoded) {\\n            res.push_back(res.back() ^ el);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665518,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int x=0;\\n        for(int i=1;i<=n;i++)  x=x^i;\\n        for(int i=0;i<n-2;i=i+2)  x=x^encoded[i]; \\n       \\n       \\n        vector<int>  ans(n);\\n        ans.back()=x;\\n        for(int i=n-2;i>=0;i--){\\n            ans[i]=ans[i+1]^encoded[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size()+1;\\n        int x=0;\\n        for(int i=1;i<=n;i++)  x=x^i;\\n        for(int i=0;i<n-2;i=i+2)  x=x^encoded[i]; \\n       \\n       \\n        vector<int>  ans(n);\\n        ans.back()=x;\\n        for(int i=n-2;i>=0;i--){\\n            ans[i]=ans[i+1]^encoded[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631659,
                "title": "java-solution-easy-to-understand",
                "content": "1. a1^ a1 = 0\\n2. encoded = [a1^a2, a2^a3, a3^a4.....]\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int[] decoded = new int[encoded.length + 1];\\n        for (int i = 1; i < encoded.length; i = i + 2) {\\n             decoded[0] =  decoded[0] ^ encoded[i];\\n             decoded[0] =  decoded[0] ^ i;\\n             decoded[0] =  decoded[0] ^ i + 1;\\n        }\\n         decoded[0] =  decoded[0] ^ decoded.length;\\n        for (int i = 1; i < decoded.length; i++) {\\n            decoded[i] = decoded[i-1] ^ encoded[i-1];\\n        }\\n        return decoded;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int[] decoded = new int[encoded.length + 1];\\n        for (int i = 1; i < encoded.length; i = i + 2) {\\n             decoded[0] =  decoded[0] ^ encoded[i];\\n             decoded[0] =  decoded[0] ^ i;\\n             decoded[0] =  decoded[0] ^ i + 1;\\n        }\\n         decoded[0] =  decoded[0] ^ decoded.length;\\n        for (int i = 1; i < decoded.length; i++) {\\n            decoded[i] = decoded[i-1] ^ encoded[i-1];\\n        }\\n        return decoded;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621334,
                "title": "go",
                "content": "```\\nfunc decode(encoded []int) []int {\\n    n := len(encoded) + 1\\n    sum := 0\\n    for i := 1; i <= n; i++ {\\n        sum ^= i\\n    }\\n    \\n    start := sum\\n    for i := 1; i < len(encoded); i+= 2 {\\n        start ^= encoded[i]\\n    }\\n    \\n    res := []int{start}\\n    for _, v := range encoded {\\n        res = append(res, res[len(res) - 1] ^ v)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decode(encoded []int) []int {\\n    n := len(encoded) + 1\\n    sum := 0\\n    for i := 1; i <= n; i++ {\\n        sum ^= i\\n    }\\n    \\n    start := sum\\n    for i := 1; i < len(encoded); i+= 2 {\\n        start ^= encoded[i]\\n    }\\n    \\n    res := []int{start}\\n    for _, v := range encoded {\\n        res = append(res, res[len(res) - 1] ^ v)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541696,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc decode(encoded []int) []int {\\n\\toriginal := make([]int, 0, len(encoded)+1)\\n\\tmagic := 0\\n\\tfor i := 1; i <= cap(original); i++ {\\n\\t\\tmagic ^= i\\n\\t}\\n\\tfor i := 1; i < len(encoded); i += 2 {\\n\\t\\tmagic ^= encoded[i]\\n\\t}\\n\\toriginal = append(original, magic)\\n\\tfor _, v := range encoded {\\n\\t\\tmagic ^= v\\n\\t\\toriginal = append(original, magic)\\n\\t}\\n\\treturn original\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc decode(encoded []int) []int {\\n\\toriginal := make([]int, 0, len(encoded)+1)\\n\\tmagic := 0\\n\\tfor i := 1; i <= cap(original); i++ {\\n\\t\\tmagic ^= i\\n\\t}\\n\\tfor i := 1; i < len(encoded); i += 2 {\\n\\t\\tmagic ^= encoded[i]\\n\\t}\\n\\toriginal = append(original, magic)\\n\\tfor _, v := range encoded {\\n\\t\\tmagic ^= v\\n\\t\\toriginal = append(original, magic)\\n\\t}\\n\\treturn original\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464734,
                "title": "python-fast-solution",
                "content": "```\\ndef decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded)\\n        arr = [encoded[1]] * (n + 1)\\n\\n        for odd_val in encoded[3::2]:\\n            arr[0] ^= odd_val\\n            \\n        if (n + 1) % 4 == 1:\\n            arr[0] ^= 1\\n            \\n        for i in range(n):     \\n            arr[i + 1] = arr[i] ^ encoded[i]\\n            \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded)\\n        arr = [encoded[1]] * (n + 1)\\n\\n        for odd_val in encoded[3::2]:\\n            arr[0] ^= odd_val\\n            \\n        if (n + 1) % 4 == 1:\\n            arr[0] ^= 1\\n            \\n        for i in range(n):     \\n            arr[i + 1] = arr[i] ^ encoded[i]\\n            \\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1454517,
                "title": "python-backtracking-tle-honest-efforts",
                "content": "```\\nn = len(encoded)\\ndef backTracking(res, curr_path, encoded, n):\\n    if not encoded:\\n        res.append(curr_path)\\n        return\\n\\n    if not curr_path:\\n        for i in range(1, n + 1):\\n            if i not in curr_path:\\n                backTracking(res, curr_path + [i], encoded, n)\\n    else:\\n        temp = curr_path[-1] ^ encoded[0]\\n        if temp not in curr_path:\\n            if 1 <= temp <= n + 1:\\n                backTracking(res, curr_path + [temp], encoded[1:], n)\\n\\n    return res\\nL = backTracking([], [], encoded, n)\\nreturn L[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nn = len(encoded)\\ndef backTracking(res, curr_path, encoded, n):\\n    if not encoded:\\n        res.append(curr_path)\\n        return\\n\\n    if not curr_path:\\n        for i in range(1, n + 1):\\n            if i not in curr_path:\\n                backTracking(res, curr_path + [i], encoded, n)\\n    else:\\n        temp = curr_path[-1] ^ encoded[0]\\n        if temp not in curr_path:\\n            if 1 <= temp <= n + 1:\\n                backTracking(res, curr_path + [temp], encoded[1:], n)\\n\\n    return res\\nL = backTracking([], [], encoded, n)\\nreturn L[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1438592,
                "title": "detailed-theoretical-explanation-of-the-problem",
                "content": "\\n        Let us denote \\'perm\\' and \\'encode\\' arrays by shorthands p & e repsectively.\\n        And let n denote the size of p. Hence the size of e will be n-1.\\n\\t\\t\\n\\t\\tNote: I am assuming you have a basic understanding of the xor operations.\\n\\t\\tIf not, then please go through the xor operation properties and solve\\n\\t\\tsome basic xor questions and then come back to this problem.\\n        \\n        ----------------------------------------------------------------------------\\n        We want to know the value of p[i] for all 0<=i<=n.\\n        Consider the xor of p[i] with all the elements of perm. You might ask that how does\\n        considering the xor of p[i] with all elements of p help us. Just believe in the\\n        intuition that it will be of immense importance to us and let us proceed furhter.\\n        \\n        More formally,\\n        p[i]^p[0]=x(1)\\n        p[i]^p[1]=x(2)\\n        .\\n        .\\n        p[i]^p[i]=x(i+1)\\n        .\\n        .\\n        p[i]^p[n-1]=x(n)\\n        \\n        ------------------------------------------------------------------------------\\n        Now let us try to deduce the value of xor of all x(i)\\'s.\\n        x(1)^x(2)^....^x(n)= (p[i]^p[i]^.....^p[i]) ^ (p[0]^p[1]^p[2]^....^p[n-1])  \\n        \\n        In the rhs of above, we have n times the xor of p[i] on left.\\n        Since n is odd, it reduces to p[i].\\n        \\n        Also in the rhs of above, we have xor of p[0] till p[n-1].\\n        Since p is a permutation of 1 to n, it reduces to xor of 1 till n.\\n        \\n        Therefore,\\n        x(1)^x(2)^....^x(n)= p[i] ^ (1^2^....n)          ->{A}\\n        -------------------------------------------------------------------------------\\n        \\n        We see above that we have simplified the value of xor of all x(i)\\'s.\\n        In doing so, we have utilized the information that n is odd & that p is a permutation.\\n        But till now we haven\\'t exhausted the encoded array. \\n        Can I simplifiy the value of xor of all x(i)\\'s in a different way such that e is used\\n        in it\\'s simplifiied expression?. The answer is yes. Proceed below to see why.\\n        \\n        Let us look at xor of any two p elements p[i] & p[j]. (i<=j)\\n        p[i]^p[j] = p[i]^ (p[i+1]^p[i+1]) ^ (p[i+2]^p[i+2]) ^......^ (p[j-1]^p[j-1]) ^p[j]\\n                  = (p[i]^p[i+1]) ^ (p[i+1]^p[i+2]) ^ ....... ^ (p[j-1]^p[j])\\n                  = e[i] ^ e[i+1] ^ ...... e[j-1]\\n                  = prefixor[j-1]^prefixor[i-1]\\n                  \\n        Prefixor[k] is the xor of preifx subarray of k,\\n        that is, prefixor[k]= e[0]^e[1]^....e[k]. Use this\\n        defintion and you will understand the last step \\n        in the simplification of p[i]^p[j] above.\\n        \\n        Note that if i or j=0, we get prefixor[-1] which tries to access\\n        inalid index. Theoretically prefixor[-1] should be 0.\\n        We will see below how to deal with this invalid index.\\n        \\n        ----------------------------------------------------------------------------------\\n        Now consider all the x(i)\\'s again\\n        x(1)=p[0]^p[i] = prefixor[-1]^prefixor[i-1]\\n        x(2)=p[1]^p[i] = prefixor[0]^prefixor[i-1]\\n        x(3)=p[2]^p[i] = prefixor[1]^prefixor[i-1]\\n        .\\n        .\\n        .\\n        x(n)=p[n-1]^p[i] = prefixor[n-2]^prefixor[i-1]\\n        \\n        Therefore,\\n        x(1)^x(2)^x(3)^....x(n) = (prefixor[-1]^prefixor[0]^prefixor[1]^....^prefixor[n-2])\\n                                 ^(prefixor[i-1]^prefixor[i-1]^.............^prefixor[i-1])\\n                                \\n        In the rhs of above, we have xor of prefixor[i-1] coming n times. Since n is odd,\\n        it reduces to prefixor[i-1].\\n        \\n        Also in the rhs, we have xor of all elements of prefixor(prefixor[-1]=0)\\n        So the expression simplifies to-\\n        \\n        x(1)^x(2)^....^x(n)= prefixor[i-1] ^ (prefixor[0]^prefixor[1]^.....^prefixor[n-2])     -{B}\\n        -------------------------------------------------------------------------------------------\\n        \\n        From {A} and {B},\\n        p[i] ^ (1^2^3^....^n) = prefixor[i-1] ^ (prefixor[0]^prefixor[1]^.....^prefixor[n-2])\\n        \\n        Thus,\\n        p[i] = xor1 ^ xor3 ^ xor2\\n        where,\\n        xor1 = (1^2^3^...^n) = xor of all elements from 1 to n\\n        xor3 = 0 (if i==0) OR prefixor[i-1] (if i>0)\\n        xor2 = (prefixor[0]^prefixor[1]^.....^prefixor[n-2]) = xor of all prefixor elements\\n        --------------------------------------------------------------------------------------------\\n\\n```\\n        int n=encoded.size()+1;\\n        int xor1=0;\\n        for(int i=1; i<=n; i++)\\n            xor1=(xor1^i);\\n        \\n        vector<int> prefixor(n-1, 0);\\n        prefixor[0]=encoded[0];\\n        for(int i=1; i<n-1; i++)\\n            prefixor[i]=(encoded[i]^prefixor[i-1]);\\n        \\n        int xor2=0;\\n        for(int i=0; i<n-1; i++)\\n            xor2=(xor2^prefixor[i]);\\n        \\n        vector<int> perm(n, 0);\\n        for(int i=0; i<n; i++)\\n        {\\n            int xor3=(i==0)?0:prefixor[i-1];\\n            perm[i]=(xor1^xor2^xor3);\\n        }\\n        return perm;\\n```",
                "solutionTags": [],
                "code": "```\\n        int n=encoded.size()+1;\\n        int xor1=0;\\n        for(int i=1; i<=n; i++)\\n            xor1=(xor1^i);\\n        \\n        vector<int> prefixor(n-1, 0);\\n        prefixor[0]=encoded[0];\\n        for(int i=1; i<n-1; i++)\\n            prefixor[i]=(encoded[i]^prefixor[i-1]);\\n        \\n        int xor2=0;\\n        for(int i=0; i<n-1; i++)\\n            xor2=(xor2^prefixor[i]);\\n        \\n        vector<int> perm(n, 0);\\n        for(int i=0; i<n; i++)\\n        {\\n            int xor3=(i==0)?0:prefixor[i-1];\\n            perm[i]=(xor1^xor2^xor3);\\n        }\\n        return perm;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406296,
                "title": "c-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& e)\\n    {\\n        int n = e.size() + 1;\\n        vector<int> p(e.size() + 1);\\n        for (int i = 1; i <= n; i++) p[0] ^= i;\\n        for (int i = 1; i < e.size(); i += 2) p[0] ^= e[i];\\n        for (int i = 0; i < e.size(); i++) p[i + 1] = p[i] ^ e[i];\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& e)\\n    {\\n        int n = e.size() + 1;\\n        vector<int> p(e.size() + 1);\\n        for (int i = 1; i <= n; i++) p[0] ^= i;\\n        for (int i = 1; i < e.size(); i += 2) p[0] ^= e[i];\\n        for (int i = 0; i < e.size(); i++) p[i + 1] = p[i] ^ e[i];\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398024,
                "title": "java-100-2ms",
                "content": "By taking the xor of alternate numbers in encode array starting form 1 im getting the xor of all number except the number at first position of original array. Then I\\'m taking xor with xor of all number till n and getting the value of element at first position of array. Then simply xoring with encoded array im getting the whole array.\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int len=encoded.length;\\n        int arr[]=new int[len+1];\\n        int xorn=0;\\n        if((len+1)%4==1) xorn=1;\\n        else if((len+1)%4==2) xorn=len+1;\\n        else if((len+1)%4==3) xorn=0;\\n        else xorn=(len+1);\\n        \\n        int xorend=0;\\n        for(int i=1;i<len;i+=2){\\n            xorend^=encoded[i];\\n        }\\n        arr[0]=xorend^xorn;\\n        for(int i=1;i<len+1;i++){\\n            arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n        \\n        return arr;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int len=encoded.length;\\n        int arr[]=new int[len+1];\\n        int xorn=0;\\n        if((len+1)%4==1) xorn=1;\\n        else if((len+1)%4==2) xorn=len+1;\\n        else if((len+1)%4==3) xorn=0;\\n        else xorn=(len+1);\\n        \\n        int xorend=0;\\n        for(int i=1;i<len;i+=2){\\n            xorend^=encoded[i];\\n        }\\n        arr[0]=xorend^xorn;\\n        for(int i=1;i<len+1;i++){\\n            arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n        \\n        return arr;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328279,
                "title": "o-n-python3",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        for i in range(1,len(encoded)):\\n            encoded[i] ^= encoded[i-1]\\n        xor = 0\\n        for i in range(1+len(encoded)):\\n            xor ^= (i+1)\\n        for i in range(len(encoded)):\\n            xor ^= encoded[i]\\n        ans = [xor]\\n        for i in range(len(encoded)):\\n            ans.append(xor^encoded[i])\\n        return ans\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        for i in range(1,len(encoded)):\\n            encoded[i] ^= encoded[i-1]\\n        xor = 0\\n        for i in range(1+len(encoded)):\\n            xor ^= (i+1)\\n        for i in range(len(encoded)):\\n            xor ^= encoded[i]\\n        ans = [xor]\\n        for i in range(len(encoded)):\\n            ans.append(xor^encoded[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250476,
                "title": "python-clean-solution-detailed-explanation-96-time-99-memory-efficient",
                "content": "Python Easy Solution\\n```\\nFirst we compute the xor of first n numbers\\n\\tThere is an efficient way to do this. we just need to compute n%4\\n\\t \\t\\t if n%4 == 0 then xor = n\\n\\t \\t\\t if n%4 == 1 then xor = 1\\n\\t\\t\\t if n%4 == 2 then xor = n+1\\n\\t\\t\\t if n%4 == 3 then xor = 0\\n\\t\\n\\tThe decoded list is equal to a1^a2, a2^a3, a3^a4, a4^a5..... so to find out a1 (1 <= a1 <= n), \\n\\twe simply xor every second value (a2^a3) ^ (a4^a5) ^ (a6^a7)... with xor.\\n\\t\\n```\\n\\n**The implementation of above approach**\\n```\\ndef decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1 \\n        xor = [n, 1, n+1, 0][n%4] #xor from 1 to n\\n        for i in range(1, n-1, 2):\\n            xor ^= encoded[i]  # xor ^ a2^ a3 ^ a4 ^....\\n        encoded.insert(0, xor)\\n        for i in range(1, n):\\n            encoded[i] ^= encoded[i-1]   #simply xor with previous element to get original element\\n        return encoded\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nFirst we compute the xor of first n numbers\\n\\tThere is an efficient way to do this. we just need to compute n%4\\n\\t \\t\\t if n%4 == 0 then xor = n\\n\\t \\t\\t if n%4 == 1 then xor = 1\\n\\t\\t\\t if n%4 == 2 then xor = n+1\\n\\t\\t\\t if n%4 == 3 then xor = 0\\n\\t\\n\\tThe decoded list is equal to a1^a2, a2^a3, a3^a4, a4^a5..... so to find out a1 (1 <= a1 <= n), \\n\\twe simply xor every second value (a2^a3) ^ (a4^a5) ^ (a6^a7)... with xor.\\n\\t\\n```\n```\\ndef decode(self, encoded: List[int]) -> List[int]:\\n        n = len(encoded) + 1 \\n        xor = [n, 1, n+1, 0][n%4] #xor from 1 to n\\n        for i in range(1, n-1, 2):\\n            xor ^= encoded[i]  # xor ^ a2^ a3 ^ a4 ^....\\n        encoded.insert(0, xor)\\n        for i in range(1, n):\\n            encoded[i] ^= encoded[i-1]   #simply xor with previous element to get original element\\n        return encoded\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1240831,
                "title": "easy-c-bit-manipulation-detailed-explanation-inside",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        say, for 1,2,3,4,5, nxor = 1^2^3^4^5\\n       encoded= 1^2,2^3,3^4,4^5\\n       1=nxor^ecoded[1]^encoded[3]\\n       now use this 1, to get all remaining\\n    */\\n    vector<int> decode(vector<int>& encoded) {\\n        int nxor=0;\\n        int n=encoded.size()+1;\\n        for(int i=1;i<=n;i++)nxor^=i;\\n        //since encoded[0]=nxor^enc[1]^enc[3]^....\\n        int x=0;\\n        for(int i=1;i<n-1;i=i+2){\\n            nxor^=encoded[i];\\n        }\\n        cout<<nxor;\\n        vector<int> ans;\\n        ans.push_back(nxor);\\n        for(int i=0;i<n-1;i++){\\n            ans.push_back(encoded[i]^ans.back());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        say, for 1,2,3,4,5, nxor = 1^2^3^4^5\\n       encoded= 1^2,2^3,3^4,4^5\\n       1=nxor^ecoded[1]^encoded[3]\\n       now use this 1, to get all remaining\\n    */\\n    vector<int> decode(vector<int>& encoded) {\\n        int nxor=0;\\n        int n=encoded.size()+1;\\n        for(int i=1;i<=n;i++)nxor^=i;\\n        //since encoded[0]=nxor^enc[1]^enc[3]^....\\n        int x=0;\\n        for(int i=1;i<n-1;i=i+2){\\n            nxor^=encoded[i];\\n        }\\n        cout<<nxor;\\n        vector<int> ans;\\n        ans.push_back(nxor);\\n        for(int i=0;i<n-1;i++){\\n            ans.push_back(encoded[i]^ans.back());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1227922,
                "title": "cpp-easy-explanation-with-eg-commented-by-line",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        \\n        \\n        // eg- decoded->[1,2,3,4,5] thus decoded will => {1^2,2^3,3^4,4^5} if we take xor of all even index here => 2^3 ^ 4^5 will give all element in encoded except first\\n        int n=encoded.size();\\n        int firstDecode;\\n        int allDecodedExcpetFirst=0,allDecoded=0;\\n        for(int i=1;i<n;i+=2) // hold xor of all element except first element in encoded\\n            allDecodedExcpetFirst^=encoded[i];\\n        for(int i=1;i<=n+1;i++)  // xor of all elements in encoded from 1 to n+1\\n            allDecoded^=i;\\n        firstDecode=allDecodedExcpetFirst^allDecoded;  /// this xor gives first element\\n        vector<int> ans(n+1);\\n        ans[0]=firstDecode;  //now store first element \\n        int common=(encoded[0]^firstDecode); // if we see decoded is made by 1^2,2^3,3^2\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=common; // common between two decoded will be encode at that index\\n            common^=encoded[i];\\n        }\\n        ans[n]=common;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        \\n        \\n        // eg- decoded->[1,2,3,4,5] thus decoded will => {1^2,2^3,3^4,4^5} if we take xor of all even index here => 2^3 ^ 4^5 will give all element in encoded except first\\n        int n=encoded.size();\\n        int firstDecode;\\n        int allDecodedExcpetFirst=0,allDecoded=0;\\n        for(int i=1;i<n;i+=2) // hold xor of all element except first element in encoded\\n            allDecodedExcpetFirst^=encoded[i];\\n        for(int i=1;i<=n+1;i++)  // xor of all elements in encoded from 1 to n+1\\n            allDecoded^=i;\\n        firstDecode=allDecodedExcpetFirst^allDecoded;  /// this xor gives first element\\n        vector<int> ans(n+1);\\n        ans[0]=firstDecode;  //now store first element \\n        int common=(encoded[0]^firstDecode); // if we see decoded is made by 1^2,2^3,3^2\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=common; // common between two decoded will be encode at that index\\n            common^=encoded[i];\\n        }\\n        ans[n]=common;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208701,
                "title": "java-100-faster",
                "content": "Xor of all numbers from 1 to n Xored with non-adjacent numbers of encoded array will leave us with last number.\\n```\\n\\tpublic int[] decode(int[] encoded) {\\n        int last= 1, size= encoded.length;\\n        for(int i=2; i<=size+1; i++) last^= i;\\n        for(int i=0; i<size; i= i+2) last^= encoded[i];\\n        int[] res= new int[size+1];\\n        for(int i= size; i>0; i--){\\n            res[i]= last;\\n            last^= encoded[i-1];\\n        }\\n        res[0]= last;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Xor of all numbers from 1 to n Xored with non-adjacent numbers of encoded array will leave us with last number.\\n```\\n\\tpublic int[] decode(int[] encoded) {\\n        int last= 1, size= encoded.length;\\n        for(int i=2; i<=size+1; i++) last^= i;\\n        for(int i=0; i<size; i= i+2) last^= encoded[i];\\n        int[] res= new int[size+1];\\n        for(int i= size; i>0; i--){\\n            res[i]= last;\\n            last^= encoded[i-1];\\n        }\\n        res[0]= last;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1203160,
                "title": "c-bit-manipulaton",
                "content": "class Solution {\\npublic:\\n \\n    vector<int> decode(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> ans(n+1);\\n        int n_xor = 0, dec_xor = 0;\\n        for(int i =1; i<=n + 1; i++){\\n            n_xor ^= i; // xor of n+1 elements\\n        }\\n        for(int i = 1; i<n; i+=2){\\n            dec_xor ^= arr[i]; // Xor of all n  elements except the first element.\\n        }\\n        int val = (n_xor ^ dec_xor);  // all elements will be repeated except the first element which will be our output\\n        ans[0] = val;\\n        for(int i = 0; i<n; i++){\\n            ans[i+1] = (ans[i] ^ arr[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n \\n    vector<int> decode(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> ans(n+1);\\n        int n_xor = 0, dec_xor = 0;\\n        for(int i =1; i<=n + 1; i++){\\n            n_xor ^= i; // xor of n+1 elements\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1199326,
                "title": "simple-java-soln",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] nums) {\\n        int len = nums.length;\\n        int ans[] = new int[len + 1];\\n        int x = 0 , xor = 0;\\n        if((len / 2) % 2 == 0) x = 1;\\n        for(int i = 0 ; i < len ; i+=2) xor ^= nums[i];\\n        x ^= xor;\\n        ans[len] = x;\\n        for(int i = len - 1 ; i >= 0 ; i--) {\\n            ans[i] = x ^ nums[i];\\n            x = ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] nums) {\\n        int len = nums.length;\\n        int ans[] = new int[len + 1];\\n        int x = 0 , xor = 0;\\n        if((len / 2) % 2 == 0) x = 1;\\n        for(int i = 0 ; i < len ; i+=2) xor ^= nums[i];\\n        x ^= xor;\\n        ans[len] = x;\\n        for(int i = len - 1 ; i >= 0 ; i--) {\\n            ans[i] = x ^ nums[i];\\n            x = ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186624,
                "title": "scala-functional-programming-beats-100",
                "content": "```scala\\n  def decode(encoded: Array[Int]): Array[Int] = {\\n    var prev = 0\\n    (0 until encoded.length + 1)\\n      .map(i => {\\n        i match {\\n          case 0 =>\\n            prev = ((1 until encoded.length by 2)\\n              .map(encoded(_))\\n              .reduce(_ ^ _)) ^ ((1 to encoded.length + 1).reduce(_ ^ _))\\n          case _ => prev ^= encoded(i - 1)\\n        }\\n        prev\\n      })\\n      .toArray\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def decode(encoded: Array[Int]): Array[Int] = {\\n    var prev = 0\\n    (0 until encoded.length + 1)\\n      .map(i => {\\n        i match {\\n          case 0 =>\\n            prev = ((1 until encoded.length by 2)\\n              .map(encoded(_))\\n              .reduce(_ ^ _)) ^ ((1 to encoded.length + 1).reduce(_ ^ _))\\n          case _ => prev ^= encoded(i - 1)\\n        }\\n        prev\\n      })\\n      .toArray\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1185794,
                "title": "java-easy-to-understand-with-very-detailed-explanation",
                "content": "Since there\\'s no official solution to this question, let me explain in detail one possible approach. I will denote the XOR by \\u2295 for brevity.\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n\\n        // 1) It is easy (see below) to note that\\n        //\\n        //                                                 /\\n        //                                                |  0,  if n = 3 (mod 4),\\n        //    t := perm[0] \\u2295 perm[1] \\u2295 ... \\u2295 perm[n-1] = <\\n        //                                                |  1,  if n = 1 (mod 4).\\n        //                                                 \\\\\\n        //\\n\\n        // 2) On the other hand,\\n        //\\n        //   t \\u2295 encoded[1] \\u2295 encoded[3] \\u2295 encoded[5] \\u2295 ... \\u2295 encoded[n-2]\\n        //       = perm[0] \\u2295 perm[1] \\u2295 ... \\u2295 perm[n-1]\\n        //             \\u2295 (perm[1] \\u2295 perm[2]) \\u2295 (perm[3] \\u2295 perm[4]) \\u2295 ... (perm[n-2] \\u2295 perm[n-1])\\n        //       = perm[0]\\n\\n        // 3) Then recursively, we calculate perm[i+1] = encoded[i] \\u2295 perm[i] for i = 1, 2, ..., n-1.\\n\\n\\t\\t// (*) Morally, the recursive formulas give (n-1) equations in n variables perm[i].\\n\\t\\t//     To find a unique solution, there\\'s an extra equation coming from part 1)\\n\\n        int[] perm = new int[encoded.length+1];\\n\\n        perm[0] = ((encoded.length+1) % 4 == 3) ? 0 : 1;\\n\\n        for (int i = 1; i < encoded.length; i += 2) {\\n            perm[0] ^= encoded[i];\\n        }\\n\\n        for (int i = 1; i < perm.length; i++) {\\n            perm[i] = encoded[i-1] ^ perm[i-1];\\n        }\\n\\n        return perm;\\n    }\\n}\\n```\\n\\n(*) Here\\'s a rigorous explanation for part 1) above. Indeed, we are calculating the XOR (which I denote by \\u2295) of all numbers from 1 to n **odd**. For instance,\\n\\n* for n = 1 we have trivially 1,\\n\\n* for n = 3 we have 01 \\u2295 10 \\u2295 11 = 0,\\n\\n* and so on...\\n\\nTo pass from the cases of n = 1 and n = 3 to a proof by induction, note that **if n is odd**, then everything depends modulo 4, since\\n\\n(n+1) \\u2295 (n+2) \\u2295 (n+3) \\u2295 (n+4) = 0.\\n\\nThis is because in fact we have (**for odd n!**)\\n\\n(n+1) \\u2295 (n+3) = (n+2) \\u2295 (n+4)\\n\\nFor this e.g. recall the interpretation of binary addition via a+b = (a\\u2295b) + 2*(a&b). Hence for the last formula,\\nLHS = (n+4) - 2*((n+1)&(n+3)),\\nRHS = (n+6) - 2*((n+2)&(n+4)).\\n\\nNow e.g. consider all cases for the last three digits of n:\\n\\n```\\n|------------------------------------------|\\n| last digits | (n+1)&(n+3) | ((n+2)&(n+4))|\\n|------------------------------------------|\\n|     001     |      0      |       1      |\\n|     011     |      4      |       5      |\\n|     101     |      0      |       1      |\\n|     111     |      8      |       9      |\\n|------------------------------------------|\\n```\\n\\nThe right column differs by one, so it all works out.\\n\\n\\nFor **even n**, this is different! But it also depends mod 4:\\n\\n* if n = 0 (mod 4), then 1 \\u2295 2 \\u2295 ... \\u2295 n = n,\\n* if n = 2 (mod 4), then 1 \\u2295 2 \\u2295 ... \\u2295 n = n+1.\\n\\nWhy so? Well, simply because we just figured out what\\'s going on with 1 \\u2295 2 \\u2295 ... \\u2295 n-1: it\\'s either zero or one, in the respective cases.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n\\n        // 1) It is easy (see below) to note that\\n        //\\n        //                                                 /\\n        //                                                |  0,  if n = 3 (mod 4),\\n        //    t := perm[0] \\u2295 perm[1] \\u2295 ... \\u2295 perm[n-1] = <\\n        //                                                |  1,  if n = 1 (mod 4).\\n        //                                                 \\\\\\n        //\\n\\n        // 2) On the other hand,\\n        //\\n        //   t \\u2295 encoded[1] \\u2295 encoded[3] \\u2295 encoded[5] \\u2295 ... \\u2295 encoded[n-2]\\n        //       = perm[0] \\u2295 perm[1] \\u2295 ... \\u2295 perm[n-1]\\n        //             \\u2295 (perm[1] \\u2295 perm[2]) \\u2295 (perm[3] \\u2295 perm[4]) \\u2295 ... (perm[n-2] \\u2295 perm[n-1])\\n        //       = perm[0]\\n\\n        // 3) Then recursively, we calculate perm[i+1] = encoded[i] \\u2295 perm[i] for i = 1, 2, ..., n-1.\\n\\n\\t\\t// (*) Morally, the recursive formulas give (n-1) equations in n variables perm[i].\\n\\t\\t//     To find a unique solution, there\\'s an extra equation coming from part 1)\\n\\n        int[] perm = new int[encoded.length+1];\\n\\n        perm[0] = ((encoded.length+1) % 4 == 3) ? 0 : 1;\\n\\n        for (int i = 1; i < encoded.length; i += 2) {\\n            perm[0] ^= encoded[i];\\n        }\\n\\n        for (int i = 1; i < perm.length; i++) {\\n            perm[i] = encoded[i-1] ^ perm[i-1];\\n        }\\n\\n        return perm;\\n    }\\n}\\n```\n```\\n|------------------------------------------|\\n| last digits | (n+1)&(n+3) | ((n+2)&(n+4))|\\n|------------------------------------------|\\n|     001     |      0      |       1      |\\n|     011     |      4      |       5      |\\n|     101     |      0      |       1      |\\n|     111     |      8      |       9      |\\n|------------------------------------------|\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177391,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n        let n = encoded.len();\\n        \\n        let mut t = encoded\\n            .iter()\\n            .skip(1)\\n            .step_by(2)\\n            .fold((n % 4 == 0) as i32, |acc, x| acc ^ x);\\n        \\n        std::iter::once(t)\\n            .chain(encoded.iter().map(|x| {\\n                t ^= x;\\n                t\\n            }))\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>) -> Vec<i32> {\\n        let n = encoded.len();\\n        \\n        let mut t = encoded\\n            .iter()\\n            .skip(1)\\n            .step_by(2)\\n            .fold((n % 4 == 0) as i32, |acc, x| acc ^ x);\\n        \\n        std::iter::once(t)\\n            .chain(encoded.iter().map(|x| {\\n                t ^= x;\\n                t\\n            }))\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1177363,
                "title": "ruby-100-100",
                "content": "```\\n# @param {Integer[]} encoded\\n# @return {Integer[]}\\ndef decode(encoded)\\n  n = encoded.size\\n  t = 1.step(n - 1, 2).reduce((n + 1) % 4 % 3) { |acc, i| acc ^ encoded[i] }\\n  [t].concat(encoded.map { |x| t ^= x } )\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} encoded\\n# @return {Integer[]}\\ndef decode(encoded)\\n  n = encoded.size\\n  t = 1.step(n - 1, 2).reduce((n + 1) % 4 % 3) { |acc, i| acc ^ encoded[i] }\\n  [t].concat(encoded.map { |x| t ^= x } )\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1168527,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length + 1;\\n        int xor = 1;\\n        for (int i = 2; i <= n; i++) \\n            xor ^= i;\\n        for (int i = 0; i < n - 1; i += 2) \\n            xor ^= encoded[i];\\n        int[] ans = new int[n];\\n        ans[n - 1] = xor;\\n        for (int i = n - 2; i >= 0; i--) \\n            ans[i] = ans[i + 1] ^ encoded[i];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length + 1;\\n        int xor = 1;\\n        for (int i = 2; i <= n; i++) \\n            xor ^= i;\\n        for (int i = 0; i < n - 1; i += 2) \\n            xor ^= encoded[i];\\n        int[] ans = new int[n];\\n        ans[n - 1] = xor;\\n        for (int i = n - 2; i >= 0; i--) \\n            ans[i] = ans[i + 1] ^ encoded[i];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120757,
                "title": "js-o-n-beats-78",
                "content": "```\\n/**\\n * @param {number[]} encoded\\n * @return {number[]}\\n */\\nvar decode = function(encoded) {\\n    const len = encoded.length\\n    const n = 1 + len\\n    \\n    \\n    let target = 0\\n    for (let i = 1; i <= n; i++)\\n        target ^= i\\n    \\n    \\n    let firstVal = target\\n    for (let i = 1; i < len; i += 2) {\\n        const val = encoded[i]\\n        firstVal ^= val\\n    }\\n    \\n    \\n    let result = new Array(n)\\n    result[0] = firstVal\\n    for (const [i, val] of encoded.entries()) {\\n        const prevOutcome = result[i]\\n        let outcome = prevOutcome ^ val\\n        result[1 + i] = outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} encoded\\n * @return {number[]}\\n */\\nvar decode = function(encoded) {\\n    const len = encoded.length\\n    const n = 1 + len\\n    \\n    \\n    let target = 0\\n    for (let i = 1; i <= n; i++)\\n        target ^= i\\n    \\n    \\n    let firstVal = target\\n    for (let i = 1; i < len; i += 2) {\\n        const val = encoded[i]\\n        firstVal ^= val\\n    }\\n    \\n    \\n    let result = new Array(n)\\n    result[0] = firstVal\\n    for (const [i, val] of encoded.entries()) {\\n        const prevOutcome = result[i]\\n        let outcome = prevOutcome ^ val\\n        result[1 + i] = outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1117528,
                "title": "o-n-c-with-explanation",
                "content": "class Solution {\\npublic:\\n        // first element find then use encoded[i] for rest of the elements\\n        // for finding first element :\\n        // **store a^b, a^c, a^d ... (they are in even number) ---- 1\\n        // xor all of them and you get b^c^d... say it res.  ---- 2**\\n        // calculate xor of all elements from 1-n and then \\n      // xor it with res. Here you got first element !!!\\n```\\n    vector<int> decode(vector<int>& encoded) \\n    {\\n        int n=encoded.size();\\n        vector<int> v(n+1);\\n        int res;\\n        v[0]= encoded[0];\\n        res=v[0];\\n        for(int i=1; i<n; i++)\\n        {\\n            v[i]= encoded[i]^v[i-1];        //  1\\n            res^=v[i];                      //  2\\n        }\\n        int sum=0;\\n        for(int i=1; i<=n+1; i++)\\n            sum^=i;\\n        sum = sum^res;\\n        v[0]=sum;\\n        for(int i=1; i<=n; i++)\\n        {\\n            v[i]= v[i-1]^encoded[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> decode(vector<int>& encoded) \\n    {\\n        int n=encoded.size();\\n        vector<int> v(n+1);\\n        int res;\\n        v[0]= encoded[0];\\n        res=v[0];\\n        for(int i=1; i<n; i++)\\n        {\\n            v[i]= encoded[i]^v[i-1];        //  1\\n            res^=v[i];                      //  2\\n        }\\n        int sum=0;\\n        for(int i=1; i<=n+1; i++)\\n            sum^=i;\\n        sum = sum^res;\\n        v[0]=sum;\\n        for(int i=1; i<=n; i++)\\n        {\\n            v[i]= v[i-1]^encoded[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107203,
                "title": "o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size();\\n        int x=n+1;\\n        int tot=0;\\n        for(int i=1;i<=x;i++) // a1^a2^a3^..\\n            tot^=i;\\n        int p=0;\\n        for(int i=0;i<n;i++){ \\n            p^=encoded[i]; // (a1^a2), (a1^a3), (a1^a4)..\\n            tot^=p; \\n        }\\n        //Now tot contains the first number;\\n        vector<int> ans(n+1);\\n        ans[0]=tot;\\n        for(int i=0;i<n;i++){\\n            ans[i+1]=(tot^encoded[i]);\\n            tot=ans[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        int n=encoded.size();\\n        int x=n+1;\\n        int tot=0;\\n        for(int i=1;i<=x;i++) // a1^a2^a3^..\\n            tot^=i;\\n        int p=0;\\n        for(int i=0;i<n;i++){ \\n            p^=encoded[i]; // (a1^a2), (a1^a3), (a1^a4)..\\n            tot^=p; \\n        }\\n        //Now tot contains the first number;\\n        vector<int> ans(n+1);\\n        ans[0]=tot;\\n        for(int i=0;i<n;i++){\\n            ans[i+1]=(tot^encoded[i]);\\n            tot=ans[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099032,
                "title": "java-2ms-100",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length+1;\\n        int[] x = new int[n];\\n        x[0] = ((n/2)&1)^1;\\n        for(int i=1; i<n-1; i+=2)x[0]^=encoded[i];\\n        for(int i=1; i<n; i++){\\n            x[i] = x[i-1]^encoded[i-1];\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int n = encoded.length+1;\\n        int[] x = new int[n];\\n        x[0] = ((n/2)&1)^1;\\n        for(int i=1; i<n-1; i+=2)x[0]^=encoded[i];\\n        for(int i=1; i<n; i++){\\n            x[i] = x[i-1]^encoded[i-1];\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084548,
                "title": "c-with-short-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        // If we can find the 1st element a, then the 2nd element b is encoded[0] ^ a, 3rd element is encoded[1] ^ b ...\\n        // Since encoded[0] ^ encoded[1] = a ^ c, encoded[0] ^ ... ^ encoded[2] = a ^ d ...,\\n        // we can get create another array xors to store the values of a ^ b, a ^ c, ... etc, the size will be n - 1.\\n        // Since n - 1 is even, we get xors[0] ^ xors[1] ^ ... which is b ^ c ^ ..., hence we can get a by calculating\\n        // 1 ^ 2 ^ ... ^ n = sum, and b ^ c ^ ... ^ sum == a.\\n        // a is the 1st element of perm, we can get perm[1], perm[2] etc as mentioned earlier.\\n        int n = encoded.size() + 1, sum = 0;\\n        vector<int> res(n, encoded[0]), xors(n - 1, encoded[0]);\\n        for (int i = 1; i < n - 1; ++i)\\n        {\\n            xors[i] = (encoded[i] ^ xors[i - 1]);\\n            res[0] ^= xors[i];\\n        }\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            sum ^= i;\\n        }\\n        \\n        res[0] ^= sum;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            res[i] = (encoded[i - 1] ^ res[i - 1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded) {\\n        // If we can find the 1st element a, then the 2nd element b is encoded[0] ^ a, 3rd element is encoded[1] ^ b ...\\n        // Since encoded[0] ^ encoded[1] = a ^ c, encoded[0] ^ ... ^ encoded[2] = a ^ d ...,\\n        // we can get create another array xors to store the values of a ^ b, a ^ c, ... etc, the size will be n - 1.\\n        // Since n - 1 is even, we get xors[0] ^ xors[1] ^ ... which is b ^ c ^ ..., hence we can get a by calculating\\n        // 1 ^ 2 ^ ... ^ n = sum, and b ^ c ^ ... ^ sum == a.\\n        // a is the 1st element of perm, we can get perm[1], perm[2] etc as mentioned earlier.\\n        int n = encoded.size() + 1, sum = 0;\\n        vector<int> res(n, encoded[0]), xors(n - 1, encoded[0]);\\n        for (int i = 1; i < n - 1; ++i)\\n        {\\n            xors[i] = (encoded[i] ^ xors[i - 1]);\\n            res[0] ^= xors[i];\\n        }\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            sum ^= i;\\n        }\\n        \\n        res[0] ^= sum;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            res[i] = (encoded[i - 1] ^ res[i - 1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084426,
                "title": "three-lines-of-python-plus-comments-faster-than-99-8",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        # 1 = 1.\\n        # 1 ^ 2 ^ 3 = 1 ^ (2 ^ 3) = 1 ^ 1 = 0\\n        # 1 ^ 2 ^ 3 ^ 4 ^ 5 = 1 ^ (2 ^ 3) ^ (4 ^ 5) = 1 ^ 1 ^ 1 = 1\\n        # ...\\n        # This line quickly calculates 1 ^ 2 ..... ^ n where n is len(encoded) + 1\\n        xor_range = ((len(encoded) + 2) >> 1) & 1\\n        # We can easily determine the first element by xoring everything else out.\\n        first = xor_range ^ functools.reduce(operator.xor, encoded[1::2])\\n        # Now build the result. \\n        return list(itertools.accumulate(encoded, operator.xor, initial=first))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        # 1 = 1.\\n        # 1 ^ 2 ^ 3 = 1 ^ (2 ^ 3) = 1 ^ 1 = 0\\n        # 1 ^ 2 ^ 3 ^ 4 ^ 5 = 1 ^ (2 ^ 3) ^ (4 ^ 5) = 1 ^ 1 ^ 1 = 1\\n        # ...\\n        # This line quickly calculates 1 ^ 2 ..... ^ n where n is len(encoded) + 1\\n        xor_range = ((len(encoded) + 2) >> 1) & 1\\n        # We can easily determine the first element by xoring everything else out.\\n        first = xor_range ^ functools.reduce(operator.xor, encoded[1::2])\\n        # Now build the result. \\n        return list(itertools.accumulate(encoded, operator.xor, initial=first))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080407,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        var result = [Int](), r0 = Array(1...(encoded.count + 1)).reduce(0, ^)\\n        for i in stride(from: 1, to: encoded.count, by: 2) {\\n            r0 ^= encoded[i]\\n        }\\n        result.append(r0)\\n        for e in encoded {\\n            result.append(result.last! ^ e)\\n        }\\n        return result\\n    }\\n}\\n```\\none-liner\\n```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        return encoded.reduce(into: [encoded.enumerated().reduce(into: Array(1...(encoded.count + 1)).reduce(0, ^), { if $1.0 % 2 == 1 { $0 ^= $1.1 } })], { $0.append($0.last! ^ $1) })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        var result = [Int](), r0 = Array(1...(encoded.count + 1)).reduce(0, ^)\\n        for i in stride(from: 1, to: encoded.count, by: 2) {\\n            r0 ^= encoded[i]\\n        }\\n        result.append(r0)\\n        for e in encoded {\\n            result.append(result.last! ^ e)\\n        }\\n        return result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        return encoded.reduce(into: [encoded.enumerated().reduce(into: Array(1...(encoded.count + 1)).reduce(0, ^), { if $1.0 % 2 == 1 { $0 ^= $1.1 } })], { $0.append($0.last! ^ $1) })\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071469,
                "title": "java-short-solution",
                "content": "```\\n    public int[] decode(int[] e) {\\n        int[] res = new int[e.length+1];\\n        for(int i = 0; i <= e.length+1; i++) {\\n            res[0] ^= i;\\n            if(i < e.length && i%2 == 1) res[0] ^= e[i];\\n        }\\n\\n        for(int i = 1; i < res.length; i++) res[i] ^= res[i-1]^e[i-1];\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] decode(int[] e) {\\n        int[] res = new int[e.length+1];\\n        for(int i = 0; i <= e.length+1; i++) {\\n            res[0] ^= i;\\n            if(i < e.length && i%2 == 1) res[0] ^= e[i];\\n        }\\n\\n        for(int i = 1; i < res.length; i++) res[i] ^= res[i-1]^e[i-1];\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1066289,
                "title": "java",
                "content": "assume we have original array = {a1, a2 , a3, .... an}\\nencoded array is {a1^a2, a2^a3, a3^a4, a4^a5.........}, we can extract pairs with odd indexes(0-based), so we will have a2^a3, a4^a5, a6^a7......, then XOR them, we can get result of a2^a3^a4^a5^a6^a7......an = temp, we also know a1^a2^a3.....^an = (1^2^3^.....^n), so \\na1 = (1^2^3^.....^n) ^ temp\\n(1^2^3^.....^n) is alternant 0 or 1, for example (1^2^3)=0, (1^2^3^4^5)=1\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded) {\\n        int len = encoded.length;\\n        int[] res = new int[len+1];\\n        res[0] = len/2%2==0 ? 1 : 0;\\n        for(int i=1; i<len; i+=2)\\n            res[0]^=encoded[i];\\n        for(int i=0; i<len; i++)\\n            res[i+1] = res[i]^encoded[i];\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decode(int[] encoded) {\\n        int len = encoded.length;\\n        int[] res = new int[len+1];\\n        res[0] = len/2%2==0 ? 1 : 0;\\n        for(int i=1; i<len; i+=2)\\n            res[0]^=encoded[i];\\n        for(int i=0; i<len; i++)\\n            res[i+1] = res[i]^encoded[i];\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1059890,
                "title": "python3-xor-manipulation",
                "content": "**Algo**\\nCompute `1^2^...^n` as `x`. Since we have `x1^x2`, `x3^x4` ..., we can compute `x0` as `x ^ x1 ^ x2 ^ x3 ^ x4` .... \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        x = reduce(xor, list(range(1, len(encoded) + 2)))\\n        for i in range(1, len(encoded), 2): x ^= encoded[i]\\n        ans = [x]\\n        for x in encoded: ans.append(ans[-1] ^ x)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        x = reduce(xor, list(range(1, len(encoded) + 2)))\\n        for i in range(1, len(encoded), 2): x ^= encoded[i]\\n        ans = [x]\\n        for x in encoded: ans.append(ans[-1] ^ x)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052096,
                "title": "python-o-n-15-lines-calculate-the-perm-n-2-with-xor",
                "content": "### How does this work:\\n\\nSimple example when `n=5`:\\n\\nEncoded: `perm[0]^perm[1], perm[1]^perm[2],  perm[2]^perm[3], perm[3]^perm[4]`\\n\\nIf we apply XOR from `1` to `n`, we would get `acc=perm[0]^perm[1]^perm[2]^perm[3]^perm[4]`\\n\\nWhat we can get when we XOR the whole `encoded` array with `acc`  is `perm[0]^perm[1] ^ perm[1]^perm[2] ^  perm[2]^perm[3] ^ perm[3]^perm[4] ^ perm[0]^perm[1]^perm[2]^perm[3]^perm[4]`, which is exactly `perm[1]^perm[2]^perm[3]`. \\n*We just removed `perm[0]` and `perm[4]` from `acc`.*\\n\\nIf we apply XOR on `perm[1]^perm[2]^perm[3]`, `perm[1]^perm[2]`, and `perm[2]^perm[3]`, the results is exactly `perm[2]`. \\n\\nFollow this idea, we are able to get `perm[n//2]`. After that, the whole `perm` can be easily restored. \\n\\nThe code below is written in the same idea with a little optimization. ( `x^x = 0` )\\n\\n```python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        record={}\\n        mid=len(encoded)//2\\n        acc=len(encoded)+1\\n        ret=[0]*acc\\n        for i,item in enumerate(encoded,0):\\n            acc^=(i+1)\\n            if i<mid and i%2==0 or i>=mid and (len(encoded)-i-1)%2==0:\\n                acc^=item\\n        ret[mid]=acc\\n        for i in range(mid):\\n            ret[mid-i-1]=ret[mid-i]^encoded[mid-i-1]\\n            ret[mid+i+1]=ret[mid+i]^encoded[mid+i]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def decode(self, encoded: List[int]) -> List[int]:\\n        record={}\\n        mid=len(encoded)//2\\n        acc=len(encoded)+1\\n        ret=[0]*acc\\n        for i,item in enumerate(encoded,0):\\n            acc^=(i+1)\\n            if i<mid and i%2==0 or i>=mid and (len(encoded)-i-1)%2==0:\\n                acc^=item\\n        ret[mid]=acc\\n        for i in range(mid):\\n            ret[mid-i-1]=ret[mid-i]^encoded[mid-i-1]\\n            ret[mid+i+1]=ret[mid+i]^encoded[mid+i]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049400,
                "title": "o-n-c-easy-solution",
                "content": "Firstly find a2^a3^...^an. (say x)\\nThis can be done by taking xor of p1^p3^..^pn-1. We know numbers are from 1 to n. So find xor of 1 to n.(say k) Now taking the xor of x and k will give a1. Now we can easily find all numbers.\\n\\n\\t\\n```\\nvector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size();\\n        int x = 0, k = 0;\\n        for(int i = 1; i < n; i += 2){\\n            x ^= encoded[i];\\n        }\\n        for(int i = 1; i <= n + 1; i++){\\n            k ^= i;\\n        }\\n        vector<int> ans(n + 1);\\n        ans[0] = k ^ x;\\n        for(int i = 0; i < n; i++){\\n            ans[i+1] = ans[i] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> decode(vector<int>& encoded) {\\n        int n = encoded.size();\\n        int x = 0, k = 0;\\n        for(int i = 1; i < n; i += 2){\\n            x ^= encoded[i];\\n        }\\n        for(int i = 1; i <= n + 1; i++){\\n            k ^= i;\\n        }\\n        vector<int> ans(n + 1);\\n        ans[0] = k ^ x;\\n        for(int i = 0; i < n; i++){\\n            ans[i+1] = ans[i] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049355,
                "title": "manipulation-cpp-not-medium",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& b) {\\n        int n = b.size();\\n        vector<int> a;\\n        int k = 0 , x = 0;\\n        for(int i = 1 ; i < n ; i+=2){\\n            k^=b[i];\\n        }\\n        for(int i = 1 ; i <= n+1 ; i++){\\n            x^=i;\\n        }\\n        int a0 = x^k;\\n        a.push_back(a0);\\n        for(int i = 0 ; i < n ; i++){\\n            a0^=b[i];\\n            a.push_back(a0);\\n        }\\n        return a;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& b) {\\n        int n = b.size();\\n        vector<int> a;\\n        int k = 0 , x = 0;\\n        for(int i = 1 ; i < n ; i+=2){\\n            k^=b[i];\\n        }\\n        for(int i = 1 ; i <= n+1 ; i++){\\n            x^=i;\\n        }\\n        int a0 = x^k;\\n        a.push_back(a0);\\n        for(int i = 0 ; i < n ; i++){\\n            a0^=b[i];\\n            a.push_back(a0);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035812,
                "title": "swift-simple-solution-fast",
                "content": "```\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        var a = encoded.count / 2 % 2 == 0 ? 1 : 0\\n        for i in 0..<encoded.count {\\n            if i % 2 == 1 {\\n                a ^= encoded[i]\\n            }\\n        }\\n        var res = [a]\\n        for i in 0..<encoded.count {\\n            res.append(res[i] ^ encoded[i])\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func decode(_ encoded: [Int]) -> [Int] {\\n        var a = encoded.count / 2 % 2 == 0 ? 1 : 0\\n        for i in 0..<encoded.count {\\n            if i % 2 == 1 {\\n                a ^= encoded[i]\\n            }\\n        }\\n        var res = [a]\\n        for i in 0..<encoded.count {\\n            res.append(res[i] ^ encoded[i])\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035717,
                "title": "c-find-perm-0-firstly",
                "content": "```\\n    vector<int> decode(vector<int>& encoded) {\\n        int sum = 0, n = encoded.size()+1;\\n        for(int i=1;i<=n;i++) sum ^= i;\\n        for(int i=1;i<encoded.size();i+=2) sum ^= encoded[i];\\n        vector<int> res = {sum};\\n        for(auto x:encoded) res.emplace_back(x^res.back());\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> decode(vector<int>& encoded) {\\n        int sum = 0, n = encoded.size()+1;\\n        for(int i=1;i<=n;i++) sum ^= i;\\n        for(int i=1;i<encoded.size();i+=2) sum ^= encoded[i];\\n        vector<int> res = {sum};\\n        for(auto x:encoded) res.emplace_back(x^res.back());\\n        return res;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576699,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "Follow the link for solution with an explanation:\\nhttps://github.com/saquib-ahsan/leetcode/blob/main/all-problems/1734-Decode-XORed-Permutation.cpp"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You either need to find the first element or the last element. Once you do that you can respectively start from the begining or the ending and find the remaining elements.\n\nTo find the first or the last element consider XORing all the values in the ```perm``` array and <i>some</i> values from the encoded array.\n\n/*FinalHint!!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\n\n\n<i>some</i> :- alternate values. \nI won't say anything else now."
                    },
                    {
                        "username": "NemoKam",
                        "content": "Test 31:\\nencoded = [12,6,11,10,5,3,4,6]\\nmy_output = [2,14,8,3,9,12,15,11,13]\\nexpected = [8,4,2,9,3,6,5,1,7]\\nAm i wrong? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "yes. Encoded array has length of 8 which means you can only use numbers [1..9]. Your output contains  numbers > 9"
                    }
                ]
            },
            {
                "id": 1805437,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "Follow the link for solution with an explanation:\\nhttps://github.com/saquib-ahsan/leetcode/blob/main/all-problems/1734-Decode-XORed-Permutation.cpp"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You either need to find the first element or the last element. Once you do that you can respectively start from the begining or the ending and find the remaining elements.\n\nTo find the first or the last element consider XORing all the values in the ```perm``` array and <i>some</i> values from the encoded array.\n\n/*FinalHint!!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\n\n\n<i>some</i> :- alternate values. \nI won't say anything else now."
                    },
                    {
                        "username": "NemoKam",
                        "content": "Test 31:\\nencoded = [12,6,11,10,5,3,4,6]\\nmy_output = [2,14,8,3,9,12,15,11,13]\\nexpected = [8,4,2,9,3,6,5,1,7]\\nAm i wrong? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "yes. Encoded array has length of 8 which means you can only use numbers [1..9]. Your output contains  numbers > 9"
                    }
                ]
            },
            {
                "id": 1887557,
                "content": [
                    {
                        "username": "deleted_user",
                        "content": "Follow the link for solution with an explanation:\\nhttps://github.com/saquib-ahsan/leetcode/blob/main/all-problems/1734-Decode-XORed-Permutation.cpp"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You either need to find the first element or the last element. Once you do that you can respectively start from the begining or the ending and find the remaining elements.\n\nTo find the first or the last element consider XORing all the values in the ```perm``` array and <i>some</i> values from the encoded array.\n\n/*FinalHint!!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\n\n\n<i>some</i> :- alternate values. \nI won't say anything else now."
                    },
                    {
                        "username": "NemoKam",
                        "content": "Test 31:\\nencoded = [12,6,11,10,5,3,4,6]\\nmy_output = [2,14,8,3,9,12,15,11,13]\\nexpected = [8,4,2,9,3,6,5,1,7]\\nAm i wrong? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "yes. Encoded array has length of 8 which means you can only use numbers [1..9]. Your output contains  numbers > 9"
                    }
                ]
            }
        ]
    }
]