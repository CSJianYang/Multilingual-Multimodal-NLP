[
    {
        "title": "Stone Game",
        "question_content": "Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\nThe objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.\nAlice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\n&nbsp;\nExample 1:\n\nInput: piles = [5,3,4,5]\nOutput: true\nExplanation: \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes [3, 4, 5].\nIf Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\nExample 2:\n\nInput: piles = [3,7,2,3]\nOutput: true\n\n&nbsp;\nConstraints:\n\n\t2 <= piles.length <= 500\n\tpiles.length is even.\n\t1 <= piles[i] <= 500\n\tsum(piles[i]) is odd.",
        "solutions": [
            {
                "id": 154610,
                "title": "dp-or-just-return-true",
                "content": "## Approach 1: Just return true\\nAlex is first to pick pile.\\n`piles.length` is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles `piles[0], piles[2], ....., piles[n-2]`,\\nhe picks first `piles[0]`, then Lee can pick either `piles[1]` or `piles[n - 1]`.\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that `sum(piles)` is odd.\\nIf `sum(piles[even]) > sum(piles[odd])`, Alex just picks all evens and wins.\\nIf `sum(piles[even]) < sum(piles[odd])`, Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n\\n**C++/Java**\\n```\\n    return true;\\n```\\n\\n**Python:**\\n```\\n    return True\\n```\\n<br/>\\n\\n## Approach 2: 2D DP\\n\\nIt\\'s tricky when we have even number of piles of stones. You may not have this condition in an interview.\\n\\n**Follow-up:**\\n\\nWhat if piles.length can be odd?\\nWhat if we want to know exactly the diffenerce of score?\\nThen we need to solve it with DP.\\n\\n`dp[i][j]` means the biggest number of stones you can get more than opponent picking piles in `piles[i] ~ piles[j]`.\\nYou can first pick `piles[i]` or  `piles[j]`.\\n1. If you pick `piles[i]`, your result will be `piles[i] - dp[i + 1][j]`\\n1. If you pick `piles[j]`, your result will be `piles[j] - dp[i][j - 1]`\\n\\nSo we get:\\n`dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])`\\nWe start from smaller subarray and then we use that to calculate bigger subarray.\\n\\nNote that take evens or take odds, it\\'s just an easy strategy to win when the number of stones is even. \\n**It\\'s not the best solution!**\\nI didn\\'t find a tricky solution when the number of stones is odd (maybe there is).\\n\\n**C++:**\\n```\\n    bool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n**Python:**\\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\\n<br/>\\n\\n## Approach 3: 1D DP\\nFollow up: Use only O(N) space?\\n\\nSimplify to 1D DP.\\n\\n**C++:**\\n```\\n    bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n**Python:**\\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    return true;\\n```\n```\\n    return True\\n```\n```\\n    bool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\n    public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\n```\\n    bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\n    public boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 154660,
                "title": "java-this-is-minimax-dp-fully-detailed-explanation-generalization-easy-understand-code",
                "content": "The problem was made a \"trick problem,\" because Alex always wins, but if you want to learn the **general idea behind these problems** here is the explanation for other cases.\\n\\n```\\nclass Solution {\\n    int [][][] memo;\\n    public boolean stoneGame(int[] piles) {\\n        memo = new int[piles.length + 1][piles.length + 1][2];\\n        for(int [][] arr : memo)\\n            for(int [] subArr : arr)\\n                Arrays.fill(subArr, -1);\\n        \\n        return (helper(0, piles.length - 1, piles, 1) >= 0);\\n    }\\n    \\n    public int helper(int l, int r, int [] piles, int ID){\\n        if(r < l)\\n            return 0;\\n        if(memo[l][r][ID] != -1)\\n            return memo[l][r][ID];\\n        \\n        int next = Math.abs(ID - 1);\\n        if(ID == 1)\\n            memo[l][r][ID] = Math.max(piles[l] + helper(l + 1, r, piles, next), piles[r] + helper(l, r - 1, piles, next));\\n        else\\n            memo[l][r][ID] = Math.min(-piles[l] + helper(l + 1, r, piles, next), -piles[r] + helper(l, r - 1, piles, next));\\n        \\n        return memo[l][r][ID];\\n    }\\n}\\n```\\n\\nThis is a **Minimax** problem. Each player plays optimally to win, but you can\\'t greedily choose the optimal strategy so you have to try *all* strategies, this is DP now.\\n\\nWhat does it mean for Alex to win? Alex will win if `score(Alex) >= score(Lee)`, but this also means `score(Alex) - score(Lee) >= 0`, so here you have a **common parameter** which is a `score` variable. The `score` parameter really means `score = score(Alex) - score(Lee)`.\\n\\nNow, if each player is suppoed to play optimally, how do you decide this with one variable?\\n\\nWell since Alex is playing optimally, he wants to **maximize** the `score` variable because remember, Alex only wins if `score = score(Alex) - score(Lee) >= 0` Alex should *add* to the score because he wants to maximize it.\\nSince Lee is also playing optimally, he wants to **minimize** the `score` variable, since if the `score` variable becomes negative, Lee has more individual score than Alex. But since we have only one variable, Lee should *damage* the score (or in other words, *subtract* from the score).\\n\\nNow, let\\'s think of the brute force solution. You are at the current state, say this is Alex\\'s turn. Alex can choose either `left` or `right`, but he can\\'t greedily pick so you try *both* of them, this is `O(2^n)` for runtime.\\n\\nBut realize the `state` you are in. You can easily memoize the this, the varying parameters are `l, r, ID`, where `ID` is the player ID (`1 for Alex, 0 for Lee`), hence you can make a DP/Cache table and return answer if you have discovered the state.\\n\\nFinally, in your main function you call this `helper` function and check if you were able to get a `score >= 0`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][][] memo;\\n    public boolean stoneGame(int[] piles) {\\n        memo = new int[piles.length + 1][piles.length + 1][2];\\n        for(int [][] arr : memo)\\n            for(int [] subArr : arr)\\n                Arrays.fill(subArr, -1);\\n        \\n        return (helper(0, piles.length - 1, piles, 1) >= 0);\\n    }\\n    \\n    public int helper(int l, int r, int [] piles, int ID){\\n        if(r < l)\\n            return 0;\\n        if(memo[l][r][ID] != -1)\\n            return memo[l][r][ID];\\n        \\n        int next = Math.abs(ID - 1);\\n        if(ID == 1)\\n            memo[l][r][ID] = Math.max(piles[l] + helper(l + 1, r, piles, next), piles[r] + helper(l, r - 1, piles, next));\\n        else\\n            memo[l][r][ID] = Math.min(-piles[l] + helper(l + 1, r, piles, next), -piles[r] + helper(l, r - 1, piles, next));\\n        \\n        return memo[l][r][ID];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261718,
                "title": "step-by-step-recursive-topdown-bottomup-and-bottomup-using-o-n-space-in-java",
                "content": "Explaination : In the Questions of DP do start from the Recusive Solution of the Question then proceed to TopDown Approach and then Proceed to BottomUp and then Efficient Approach.\\n\\nIntuition : \\n__Talking about the Recursive Solution__ -> Consider a boolean variable that will decide if the turn is of Alex or Lee.\\n If it is Alex\\'s Turn then we will find the max number of stones we can get by either consuming the first pile from the piles or by consuming the last pile.\\nIf it is Lee\\'s turn then we will find the min number of stones we can get by decreasing the amount of the Alex\\'s score.\\n\\n__Talking About the TopDown Approach__ : We will take a 2 D Array and save the answer at particular index and use that value in case of redundant calls.\\n\\n__Talking About the BottomUp Approach__ : Here we will implement the same approach but Iteratively using 2D array.\\n\\n__Taking about the BottomUp Efficient Approach__ : Here we will implement the same BottomUp approach Using 1D Array.\\n\\n__Recursive Solution__\\n<pre><code=\"lang-java\">\\n// si -> Starting Index, ei -> Ending Index\\n// turn -> If True then Alex\\'s turn else Lee\\'s turn\\npublic static int gameOnInt(int[] piles, int si, int ei, boolean turn){ \\n\\n\\t\\t    if(si > ei){\\n\\t\\t     \\treturn 0;\\n\\t     \\t}\\n\\n\\t\\tif(turn){ // If its Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnInt(piles, si + 1,ei,false) + piles[si]; //Consuming from Starting Index\\n\\t\\t\\tint rr2 = gameOnInt(piles, si,ei - 1,false) + piles[ei]; //Consuming form Ending Index\\n\\t\\t\\treturn Math.max(rr1, rr2); //Choosing the Maximum From both of the results\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnInt(piles, si + 1, ei, true) - piles[si]; //Consuming from the Starting Index\\n\\t\\tint rr2 = gameOnInt(piles, si, ei - 1, true) - piles[ei];//Consuming from the Ending Index\\n\\t\\treturn Math.min(rr1, rr2); // Choosing the Minimum from the Recursion Result\\n\\t}\\n\\t\\n</code></pre>\\n\\n__TopDown Approach__\\n<pre><code=\"lang-java\">\\n// Same Code as Above just Using an 2D array to save the Calculated answer\\npublic static int gameOnIntTD(int[] piles, int si, int ei, boolean turn, int[][] strg){\\n\\t\\tif(si > ei){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If the Recursion has Calculated the Answer  \\n\\t\\tif(strg[si][ei] > 0){\\n\\t\\t\\treturn strg[si][ei]; // return that Stored Answer\\n\\t\\t}\\n\\n\\t\\tif(turn){ // If it is Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnIntTD(piles, si + 1,ei,false, strg) + piles[si]; // Same as Above\\n\\t\\t\\tint rr2 = gameOnIntTD(piles, si,ei - 1,false, strg) + piles[ei]; // Same as Above\\n\\t\\t\\tstrg[si][ei] = Math.max(rr1, rr2); // Storing the max ans at particular indices\\n\\t\\t\\treturn strg[si][ei];\\n\\t\\t}\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnIntTD(piles, si + 1, ei, true, strg) - piles[si]; //Same logic as above\\n\\t\\tint rr2 = gameOnIntTD(piles, si, ei - 1, true, strg) - piles[ei];//Same logic as above\\n\\t\\tstrg[si][ei] = Math.min(rr1, rr2); //Storing the answer at particular indices\\n\\t\\treturn strg[si][ei];\\n\\t}\\n</code></pre>\\n\\n__BottomUp Approach__ : In the Bottom Up approach, we will fill the 2D array in a Slide manner(To study the slide manner read the BottomUp approach of the Matrix Multiplication Question). In the Slide approach the array is filled like in the manner stated below :\\nHere elements below the main diagonal are of no use as there starting index is greater than the ending Index which was our Base case in the Recusive Solution as discussed above.\\n\\nConsider a 2D Matrix of 4x4 :\\nStep 1 : First we will fill the main diagonal(For Slide = 1)\\n__00__ 01 02  03\\n10 __11__ 12 13\\n20 21 __22__ 23\\n30 31 32 __33__\\n\\nStep2 : For slide = 2\\n00 __01__ 02  03\\n10 11  __12__ 13\\n20 21 22 __23__\\n30 31 32 33\\n\\nStep3 : For Slide = 3\\n00 01 __02__  03\\n10 11  12 __13__\\n20 21 22 23\\n30 31 32 33\\n\\nStep4: For Slide = 4\\n00 01 02 __03__\\n10 11  12 13\\n20 21 22 23\\n30 31 32 33\\n\\nNote : With this Approach the Answer will be available at strg[0][strg.length  - 1],\\n\\t\\t  which is the last element of the First Row.\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n\\t\\t //To calculate the Answer\\n\\t\\tint[][] strg = new int[piles.length ][piles.length ];\\n\\t\\tboolean turn = false; // To store the turn\\n\\n\\t\\t/* Slide that will help to calculate the particular si and ei, so that we can work in a slide\\n\\t\\tmanner as discussed above */\\n\\t\\tfor(int slide = 0; slide < piles.length;slide++){ \\n\\t\\t\\tfor(int si = 0;si < piles.length - slide;si++){\\n\\t\\t\\t\\tint ei = slide + si;\\n\\t\\t\\t\\t/*This condition ensures we are on the diagonal and only one pile is left. As \\n\\t\\t\\t\\tyou know if there are Even Piles and Alex starts the Game, then the Last Pile \\n\\t\\t\\t\\twill be of Lee. So We need to subtract the stones from the amount of Alex viz\\n\\t\\t\\t\\tzero   for now */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(si == ei){ \\n\\t\\t\\t\\t\\tstrg[si][ei] = -piles[si];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(turn){\\n\\t\\t\\t\\t\\t// Similar Logic as dicussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.max(strg[si + 1][ei] + piles[si] ,strg[si][ei - 1] + piles[ei]);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t//Same as discussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.min(strg[si + 1][ei] - piles[si], strg[si][ei - 1] - piles[ei]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Changing the Turn\\n\\t\\t\\tturn = !turn;\\n\\t\\t}\\n\\t\\t\\t// Answer wil be stored at this Index\\n\\t\\t\\treturn strg[0][strg.length - 1];\\n\\n\\t}\\n</code></pre>\\n\\n//Same as above bt here we need not to consider the 2D Array we can also do it using 1D too.\\n\\n\\n__BottomUp Approach - Efficient__\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n        int[] strg = new int[piles.length];\\n        strg[piles.length - 1] = piles[piles.length - 1];\\n\\n        for(int si = piles.length - 1; si >= 0;si--){\\n\\n            boolean turn = false;    \\n\\n            for(int ei = si; ei < piles.length; ei++){\\n\\n                if(si == ei){\\n\\n                    strg[ei] = piles[ei];\\n                    turn = !turn;\\n                    continue;\\n                }\\n\\n                if(turn){\\n\\n                    strg[ei] = Math.max(strg[ei] + piles[ei], strg[ei - 1] + piles[ei - 1]);\\n                }else{\\n\\n                    strg[ei] = Math.min(strg[ei] - piles[ei], strg[ei - 1] - piles[ei - 1]);\\n                }\\n\\n                turn = !turn;\\n            }\\n\\n        }\\n\\n        return strg[strg.length - 1];\\n    }\\n</pre></code>",
                "solutionTags": [],
                "code": "Explaination : In the Questions of DP do start from the Recusive Solution of the Question then proceed to TopDown Approach and then Proceed to BottomUp and then Efficient Approach.\\n\\nIntuition : \\n__Talking about the Recursive Solution__ -> Consider a boolean variable that will decide if the turn is of Alex or Lee.\\n If it is Alex\\'s Turn then we will find the max number of stones we can get by either consuming the first pile from the piles or by consuming the last pile.\\nIf it is Lee\\'s turn then we will find the min number of stones we can get by decreasing the amount of the Alex\\'s score.\\n\\n__Talking About the TopDown Approach__ : We will take a 2 D Array and save the answer at particular index and use that value in case of redundant calls.\\n\\n__Talking About the BottomUp Approach__ : Here we will implement the same approach but Iteratively using 2D array.\\n\\n__Taking about the BottomUp Efficient Approach__ : Here we will implement the same BottomUp approach Using 1D Array.\\n\\n__Recursive Solution__\\n<pre><code=\"lang-java\">\\n// si -> Starting Index, ei -> Ending Index\\n// turn -> If True then Alex\\'s turn else Lee\\'s turn\\npublic static int gameOnInt(int[] piles, int si, int ei, boolean turn){ \\n\\n\\t\\t    if(si > ei){\\n\\t\\t     \\treturn 0;\\n\\t     \\t}\\n\\n\\t\\tif(turn){ // If its Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnInt(piles, si + 1,ei,false) + piles[si]; //Consuming from Starting Index\\n\\t\\t\\tint rr2 = gameOnInt(piles, si,ei - 1,false) + piles[ei]; //Consuming form Ending Index\\n\\t\\t\\treturn Math.max(rr1, rr2); //Choosing the Maximum From both of the results\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnInt(piles, si + 1, ei, true) - piles[si]; //Consuming from the Starting Index\\n\\t\\tint rr2 = gameOnInt(piles, si, ei - 1, true) - piles[ei];//Consuming from the Ending Index\\n\\t\\treturn Math.min(rr1, rr2); // Choosing the Minimum from the Recursion Result\\n\\t}\\n\\t\\n</code></pre>\\n\\n__TopDown Approach__\\n<pre><code=\"lang-java\">\\n// Same Code as Above just Using an 2D array to save the Calculated answer\\npublic static int gameOnIntTD(int[] piles, int si, int ei, boolean turn, int[][] strg){\\n\\t\\tif(si > ei){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If the Recursion has Calculated the Answer  \\n\\t\\tif(strg[si][ei] > 0){\\n\\t\\t\\treturn strg[si][ei]; // return that Stored Answer\\n\\t\\t}\\n\\n\\t\\tif(turn){ // If it is Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnIntTD(piles, si + 1,ei,false, strg) + piles[si]; // Same as Above\\n\\t\\t\\tint rr2 = gameOnIntTD(piles, si,ei - 1,false, strg) + piles[ei]; // Same as Above\\n\\t\\t\\tstrg[si][ei] = Math.max(rr1, rr2); // Storing the max ans at particular indices\\n\\t\\t\\treturn strg[si][ei];\\n\\t\\t}\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnIntTD(piles, si + 1, ei, true, strg) - piles[si]; //Same logic as above\\n\\t\\tint rr2 = gameOnIntTD(piles, si, ei - 1, true, strg) - piles[ei];//Same logic as above\\n\\t\\tstrg[si][ei] = Math.min(rr1, rr2); //Storing the answer at particular indices\\n\\t\\treturn strg[si][ei];\\n\\t}\\n</code></pre>\\n\\n__BottomUp Approach__ : In the Bottom Up approach, we will fill the 2D array in a Slide manner(To study the slide manner read the BottomUp approach of the Matrix Multiplication Question). In the Slide approach the array is filled like in the manner stated below :\\nHere elements below the main diagonal are of no use as there starting index is greater than the ending Index which was our Base case in the Recusive Solution as discussed above.\\n\\nConsider a 2D Matrix of 4x4 :\\nStep 1 : First we will fill the main diagonal(For Slide = 1)\\n__00__ 01 02  03\\n10 __11__ 12 13\\n20 21 __22__ 23\\n30 31 32 __33__\\n\\nStep2 : For slide = 2\\n00 __01__ 02  03\\n10 11  __12__ 13\\n20 21 22 __23__\\n30 31 32 33\\n\\nStep3 : For Slide = 3\\n00 01 __02__  03\\n10 11  12 __13__\\n20 21 22 23\\n30 31 32 33\\n\\nStep4: For Slide = 4\\n00 01 02 __03__\\n10 11  12 13\\n20 21 22 23\\n30 31 32 33\\n\\nNote : With this Approach the Answer will be available at strg[0][strg.length  - 1],\\n\\t\\t  which is the last element of the First Row.\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n\\t\\t //To calculate the Answer\\n\\t\\tint[][] strg = new int[piles.length ][piles.length ];\\n\\t\\tboolean turn = false; // To store the turn\\n\\n\\t\\t/* Slide that will help to calculate the particular si and ei, so that we can work in a slide\\n\\t\\tmanner as discussed above */\\n\\t\\tfor(int slide = 0; slide < piles.length;slide++){ \\n\\t\\t\\tfor(int si = 0;si < piles.length - slide;si++){\\n\\t\\t\\t\\tint ei = slide + si;\\n\\t\\t\\t\\t/*This condition ensures we are on the diagonal and only one pile is left. As \\n\\t\\t\\t\\tyou know if there are Even Piles and Alex starts the Game, then the Last Pile \\n\\t\\t\\t\\twill be of Lee. So We need to subtract the stones from the amount of Alex viz\\n\\t\\t\\t\\tzero   for now */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(si == ei){ \\n\\t\\t\\t\\t\\tstrg[si][ei] = -piles[si];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(turn){\\n\\t\\t\\t\\t\\t// Similar Logic as dicussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.max(strg[si + 1][ei] + piles[si] ,strg[si][ei - 1] + piles[ei]);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t//Same as discussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.min(strg[si + 1][ei] - piles[si], strg[si][ei - 1] - piles[ei]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Changing the Turn\\n\\t\\t\\tturn = !turn;\\n\\t\\t}\\n\\t\\t\\t// Answer wil be stored at this Index\\n\\t\\t\\treturn strg[0][strg.length - 1];\\n\\n\\t}\\n</code></pre>\\n\\n//Same as above bt here we need not to consider the 2D Array we can also do it using 1D too.\\n\\n\\n__BottomUp Approach - Efficient__\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n        int[] strg = new int[piles.length];\\n        strg[piles.length - 1] = piles[piles.length - 1];\\n\\n        for(int si = piles.length - 1; si >= 0;si--){\\n\\n            boolean turn = false;    \\n\\n            for(int ei = si; ei < piles.length; ei++){\\n\\n                if(si == ei){\\n\\n                    strg[ei] = piles[ei];\\n                    turn = !turn;\\n                    continue;\\n                }\\n\\n                if(turn){\\n\\n                    strg[ei] = Math.max(strg[ei] + piles[ei], strg[ei - 1] + piles[ei - 1]);\\n                }else{\\n\\n                    strg[ei] = Math.min(strg[ei] - piles[ei], strg[ei - 1] - piles[ei - 1]);\\n                }\\n\\n                turn = !turn;\\n            }\\n\\n        }\\n\\n        return strg[strg.length - 1];\\n    }\\n</pre></code>",
                "codeTag": "Unknown"
            },
            {
                "id": 1384652,
                "title": "c-python-dp-no-math-easy-to-understand-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- Please note that **both players are playing optimally**, so we just play optimally regardless of who is Alex, who is Lee.\\n- Let `dp(left, right)` return `[firstScore, secondScore]` where `firstScore` is the maximum score when the **player1 play first**, `secondScore` is the maximum score when the **player2 play second**, they pick stones in `piles[left]...piles[right]`.\\n- For stones in `piles[left]...piles[right]`, there are 2 choices for the player1 to pick:\\n\\t- Pick left: `pickLeft = dp(left + 1, right)`. \\n\\t\\t- The score of the player1 = `piles[left]` + the second pick score from `pickLeft`, so `firstScore = piles[left] + pickLeft[1]`\\n\\t\\t- The score of the player2 = first pick score from `pickLeft`, so `secondScore = pickLeft[0]`\\n\\t- Pick right: `pickRight = dp(left, right - 1)`.\\n\\t\\t- The score of the player1 = `piles[right]` + the second pick score from `pickRight`,  so `firstScore = piles[right] + pickRight[1]`\\n\\t\\t- The score of the player2 = first pick score from `pickRight`, so `secondScore = pickRight[0]`.\\n- We need to get the maximum score when the player1 plays first from above 2 choices.\\n- Finally, `dp(0, len(piles) - 1)` return `[firstScore, secondScore]`, where `alexScore = firstScore` since Alex plays first, `leeScore = secondScore` since Lee plays second.\\n\\n<iframe src=\"https://leetcode.com/playground/iQ3cX7yz/shared\" frameBorder=\"0\" width=\"100%\" height=\"420\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 500` is the size of `piles` array. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Just convert from **Top down DP** to **Bottom up DP** to eliminate recursion memory stack.\\n\\n<iframe src=\"https://leetcode.com/playground/KodaRUHU/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 500` is the size of `piles` array. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Alex is always WIN!**\\n- Some notices in the problem constraint:\\n\\t- The total number of stones is odd, so there is WIN or LOSE, no tie!\\n\\t- The number of piles is even, so both Alex and Lee pick `piles.length/2` piles.\\n\\t- Alex plays first.\\n- Because Alex always choose the maximum score between 2 choices, so he\\'s always WIN!\\n\\n```python\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\\n**Complexity**\\n- Time & Space: `O(1)`.\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154607,
                "title": "alex-won-t-lose",
                "content": "Alex can always take all odd piles or always take all even piles\\nSince sum of all piles is odd then sum of all odd piles won\\'t equals sum of all even piles, Alex could just take the bigger ones. \\n```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298170,
                "title": "c-very-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    \\n    int f(int l, int r, vector <int> &piles) {\\n        if(l == r-1) return max(piles[l], piles[r]);\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int ifleft = piles[l] + max(f(l+2, r, piles), f(l+1, r-1, piles));\\n        int ifright = piles[r] + max(f(l+1, r-1, piles), f(l, r-2, piles));\\n        \\n        return dp[l][r] = max(ifleft, ifright);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0, r = piles.size()-1;\\n        memset(dp, -1, sizeof(dp));\\n        int alex = f(l, r, piles);\\n        int sum = 0;\\n        for(int i=0;i<piles.size();i++) sum += piles[i];\\n\\n        return alex > (sum - alex);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    \\n    int f(int l, int r, vector <int> &piles) {\\n        if(l == r-1) return max(piles[l], piles[r]);\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int ifleft = piles[l] + max(f(l+2, r, piles), f(l+1, r-1, piles));\\n        int ifright = piles[r] + max(f(l+1, r-1, piles), f(l, r-2, piles));\\n        \\n        return dp[l][r] = max(ifleft, ifright);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0, r = piles.size()-1;\\n        memset(dp, -1, sizeof(dp));\\n        int alex = f(l, r, piles);\\n        int sum = 0;\\n        for(int i=0;i<piles.size();i++) sum += piles[i];\\n\\n        return alex > (sum - alex);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384518,
                "title": "stone-game-3-approaches-1-d-2-d-dp-or-just-return-true-c-java-python",
                "content": "## \\u2714\\uFE0F**Approach 1: Just return true**\\n\\n* Alex is first to pick pile.\\n* `piles.length` is even, and this lead to an interesting fact:\\n* Alex can always pick odd piles or always pick even piles!\\n\\n**For example,**\\n* If Alex wants to pick even indexed piles `piles[0], piles[2], ....., piles[n-2],`\\nhe picks first `piles[0]`, then Lee can pick either `piles[1] or piles[n - 1].`\\n* Every turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\n* In the description, we know that sum(piles) is odd.\\n\\t* If `sum(piles[even]) > sum(piles[odd])`, Alex just picks all evens and wins.\\n\\t* If `sum(piles[even]) < sum(piles[odd])`, Alex just picks all odds and wins.\\n\\n*So, Alex always defeats Lee in this game*\\n\\n`In C++ OR JAVA`\\n```\\n    return true;\\n```\\n`In Python`\\n```\\n    return True\\n```\\n\\n<hr>\\n\\n## \\u2714\\uFE0F**Approach 2: 2D DP**\\n\\n* `dp[i][j]` means the biggest number of stones you can get more than opponent picking piles in `piles[i] ~ piles[j].`\\n* You can first pick `piles[i]` or `piles[j].`\\n1. If you pick piles[i], your result will be` piles[i] - dp[i + 1][j]`\\n2. If you pick piles[j], your result will be `piles[j] - dp[i][j - 1]`\\n\\nSo the result is: \\n  ``` dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])```\\n\\n* We start from smaller subarray and then we use that to calculate bigger subarray.\\n* Note that take evens or take odds, it\\'s just an easy strategy to win when the number of stones is even.\\n\\n**SOLUTION** \\n\\n`In C++`\\n```\\nbool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n`In JAVA`\\n```\\n public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n`In Python`\\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\\n\\n<hr>\\n\\n## \\u2714\\uFE0F**Approach 3: 1D DP**\\n\\nWhat if, we use only O(N) space?\\n\\n**SOLUTION**\\n`In C++`\\n```\\n bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n`In Java`\\n```\\npublic boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n`In Python`\\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```\\n\\n<hr>\\n\\nHere is a video if you need a more intuitive answer\\n[Click Here](https://www.youtube.com/watch?v=WxpIHvsu1RI)",
                "solutionTags": [],
                "code": "```\\n    return true;\\n```\n```\\n    return True\\n```\n``` dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])```\n```\\nbool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\n public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\n```\\n bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\npublic boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1384896,
                "title": "c-solution-dp-with-explanation",
                "content": "**This will work on the statement that :-\\nWhen you have to do something, do your best. But when things happen to you, prepare for worst ( HAPPY LIFE MANTRA :))**\\n*Case 1:\\nAlex takes (i)th pile than array became (i+1, j)\\nnow if Lee will take the (i+1)th pile then array became (i+2, j)\\nand if Lee will take the (j)th pile then array became (i+1, j-1)\\n=> Lee is supposed to take the maxi among 2 choices then Alex will reamin with min of these 2 choices\\n                    \\nCase 2:\\nAlex takes (j)th pile than array became (i, j-1)\\nnow if Lee will take the (i)th pile then array became (i+1, j-1)\\nand if Lee will take the (j-1)th pile then array became (i, j-2)\\n=> Lee is supposed to take the maxi among 2 choices then Alex will reamin with min of these 2 choices*\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(n));\\n        \\n        for(int gap = 0; gap < n; gap++)\\n            for(int i = 0, j = gap; j < n; i++, j++){\\n                if(gap == 0) dp[i][j] = piles[i];\\n                else if(gap == 1) dp[i][j] = max(piles[i], piles[j]);\\n                else{\\n                    int case1 = piles[i] + min(dp[i+2][j], dp[i+1][j-1]);\\n                    int case2 = piles[j] + min(dp[i+1][j-1], dp[i][j-2]);\\n                    dp[i][j] = max(case1, case2); // maximum of these 2 cases\\n                }\\n            }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(n));\\n        \\n        for(int gap = 0; gap < n; gap++)\\n            for(int i = 0, j = gap; j < n; i++, j++){\\n                if(gap == 0) dp[i][j] = piles[i];\\n                else if(gap == 1) dp[i][j] = max(piles[i], piles[j]);\\n                else{\\n                    int case1 = piles[i] + min(dp[i+2][j], dp[i+1][j-1]);\\n                    int case2 = piles[j] + min(dp[i+1][j-1], dp[i][j-2]);\\n                    dp[i][j] = max(case1, case2); // maximum of these 2 cases\\n                }\\n            }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099490,
                "title": "proof-why-should-you-return-true-only",
                "content": "```\\n** Just return true**\\n\\nAlex is first to pick pile.\\npiles.length is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles piles[0], piles[2], ....., piles[n-2],\\nhe picks first piles[0], then Lee can pick either piles[1] or piles[n - 1].\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Alex just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n```",
                "solutionTags": [],
                "code": "```\\n** Just return true**\\n\\nAlex is first to pick pile.\\npiles.length is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles piles[0], piles[2], ....., piles[n-2],\\nhe picks first piles[0], then Lee can pick either piles[1] or piles[n - 1].\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Alex just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154604,
                "title": "python-recursive-dp-mini-max",
                "content": "The idea is based on minimax algorithm for adversarial game playing.\\np1 tries to maximize his return by calling pmax. p2 tries to minimize p1\\'s return by calling pmin.\\n\\npmin(i, j) => Given a pile from i...j and its p2\\'s turn to play, return what p1 will get. \\npmax(i, j) => Given a pile from i..j and its p1\\'s turn to play, return what p1 will get.\\n\\nIn my logic, I am simply calculating what is the value that p1 will get if both play optimally. The value for p2 is the remaining and p1 > p2 tells if p1 will win.\\n\\n\\n```\\n    def stoneGame(self, piles):\\n        def pmin(i, j):\\n            if (i,j) in mincache: return mincache[(i,j)]\\n            if i == j: return 0\\n            mincache[(i,j)] =  min(pmax(i+1, j), pmax(i, j-1))\\n            return mincache[(i,j)]\\n\\n        def pmax(i, j):\\n            if (i,j) in maxcache: return maxcache[(i,j)]\\n            if i == j: return piles[i]\\n            maxcache[(i,j)] =  max(piles[i] + pmin(i+1, j), pmin(i, j-1) + piles[j])\\n            return maxcache[(i,j)]\\n\\n        mincache, maxcache = {}, {}\\n        p1 = pmax(0, len(piles)-1)\\n        p2 = sum(piles) - p1\\n        return p1 > p2\\n```",
                "solutionTags": [],
                "code": "```\\n    def stoneGame(self, piles):\\n        def pmin(i, j):\\n            if (i,j) in mincache: return mincache[(i,j)]\\n            if i == j: return 0\\n            mincache[(i,j)] =  min(pmax(i+1, j), pmax(i, j-1))\\n            return mincache[(i,j)]\\n\\n        def pmax(i, j):\\n            if (i,j) in maxcache: return maxcache[(i,j)]\\n            if i == j: return piles[i]\\n            maxcache[(i,j)] =  max(piles[i] + pmin(i+1, j), pmin(i, j-1) + piles[j])\\n            return maxcache[(i,j)]\\n\\n        mincache, maxcache = {}, {}\\n        p1 = pmax(0, len(piles)-1)\\n        p2 = sum(piles) - p1\\n        return p1 > p2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1384508,
                "title": "python-two-solutions-dp-and-math-explained",
                "content": "#### Solution 1\\nLet us `dfs(i, j)` be the maximum difference Alex can gain if he plays optimally for piles `i ... j`. There there will be two options: player can take pile `i` or pile `j`. Note, that because turn chances, we need to take gain with minus sign, so we have options `P[i] - dp(i+1, j)` and `P[j] - dp(i, j-1)` and we choose the maximum one.\\n\\n#### Complexity\\nTime and space complexity is `O(n^2)`. Space complexity is also `O(n^2)`, which can be reduced to `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def stoneGame(self, P):\\n        @lru_cache(None)\\n        def dp(i, j): \\n            if i == j: return P[i]\\n            return max(P[i] - dp(i+1, j), P[j] - dp(i, j-1))\\n        \\n        return dp(0, len(P) - 1) > 0\\n```\\n\\n#### Solution 2\\nWe can prove that Alex always wins! The idea is that he always can play in such a way that he get all odd piles or all even piles. On the first move he needs to decide what is bigger and play this strategy.\\n\\n#### Complexity\\nIt is just `O(1)`\\n\\n#### Code\\n```python\\nclass Solution:\\n    def stoneGame(self, P):\\n\\t\\treturn True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, P):\\n        @lru_cache(None)\\n        def dp(i, j): \\n            if i == j: return P[i]\\n            return max(P[i] - dp(i+1, j), P[j] - dp(i, j-1))\\n        \\n        return dp(0, len(P) - 1) > 0\\n```\n```python\\nclass Solution:\\n    def stoneGame(self, P):\\n\\t\\treturn True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497647,
                "title": "java-dp-solution",
                "content": "The dp table stores how many stones the player can win between i and j.\\nAssume every player remains sober, then dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\\n\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return true;\\n        }\\n\\n        int[][] dp = new int[nums.length][nums.length];\\n\\t\\t\\n\\t// dp initialization\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n\\t\\t\\n\\t// filling dp table\\n        for (int len = 2; len <= nums.length; len++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + len - 1;\\n                if (j >= nums.length) {\\n                    continue;\\n                }\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        return dp[0][nums.length - 1] > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return true;\\n        }\\n\\n        int[][] dp = new int[nums.length][nums.length];\\n\\t\\t\\n\\t// dp initialization\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n\\t\\t\\n\\t// filling dp table\\n        for (int len = 2; len <= nums.length; len++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + len - 1;\\n                if (j >= nums.length) {\\n                    continue;\\n                }\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        return dp[0][nums.length - 1] > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346757,
                "title": "c-minimax-game-theory-stone-game",
                "content": "- https://en.wikipedia.org/wiki/Minimax\\n\\n**Related Questions:**\\n\\n- https://leetcode.com/problems/stone-game-vii/\\n- https://leetcode.com/problems/stone-game-ii/description/\\n- https://leetcode.com/problems/nim-game/description/\\n- https://leetcode.com/problems/predict-the-winner/description/ \\n- https://leetcode.com/problems/can-i-win/description/ (Bitmasking, DP)\\n\\n\\n`score = Score(Alex) - Score(Lee)`. Alex, who is optimally playing wins only if `score > 0`, and should add to the score because he wants to maximize it. Lee, who is also playing optimally, wants to minimize the score variable, and deducts from it.\\n\\n```\\nclass Solution {\\npublic: \\n    int dp[501][501][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn) {\\n        \\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        \\n        if(turn == 0) {\\n            res = max(piles[l] + getAns(l+1,r,piles,1-turn), piles[r] + getAns(l,r-1,piles,1-turn));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn) - piles[l], getAns(l,r-1,piles,1-turn) - piles[r]);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alex) - score(Lee)\\n        int score = getAns(l, r, piles, 0); // 0 -> Alex turn\\n        \\n        return score > 0;\\n    }\\n};\\n```\\n\\n- https://leetcode.com/problems/stone-game-vii/\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn, int sum) {\\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        int L = sum - piles[l];\\n        int R = sum - piles[r];\\n        \\n        if(turn == 0) {\\n            res = max(L + getAns(l+1,r,piles,1-turn, L), R + getAns(l,r-1,piles,1-turn, R));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn, L) - L, getAns(l,r-1,piles,1-turn, R) - R);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    int stoneGameVII(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        int sum = 0;\\n        for (int i = 0; i < piles.size(); i++) {\\n            sum += piles[i];\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alice) - score(Bob)\\n        int score = getAns(l, r, piles, 0, sum); // 0 -> Alice turn\\n        return score;\\n    }\\n};\\n```\\n- https://leetcode.com/problems/divisor-game/description/\\n\\n```\\n\\n// Bottom Up\\nclass Solution {\\npublic:\\n    \\n    bool divisorGame(int N) {\\n        vector<bool> winningState(N+1);\\n        winningState[1] = false;\\n        winningState[2] = true;\\n        \\n        for(int i=3;i<=N;i++) {\\n            bool res = false;\\n            for(int j=1;j<i;j++) {\\n                if(i % j == 0) {\\n                    res |= (!winningState[i-j]);\\n                }\\n            }\\n            winningState[i] = res;\\n        }\\n        return winningState[N]; \\n    }\\n};\\n\\n// Top Down\\nclass Solution {\\npublic:\\n    \\n    map<pair<int,int>, bool> winningState; \\n    \\n    bool getAns(int N, int turn) {\\n        if(winningState.find({N,turn}) != winningState.end()) {\\n            return winningState[{N,turn}] ;\\n        }\\n        \\n        bool win = false;\\n            \\n        for(int x=1;x<N;x++) {\\n            if(N % x == 0) {\\n                bool res = getAns(N - x, turn^1);\\n                win |= (!res);\\n            } \\n        }\\n        winningState[{N,turn}] = win;\\n        return win;\\n    }\\n    \\n    bool divisorGame(int N) {\\n        return getAns(N,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[501][501][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn) {\\n        \\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        \\n        if(turn == 0) {\\n            res = max(piles[l] + getAns(l+1,r,piles,1-turn), piles[r] + getAns(l,r-1,piles,1-turn));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn) - piles[l], getAns(l,r-1,piles,1-turn) - piles[r]);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alex) - score(Lee)\\n        int score = getAns(l, r, piles, 0); // 0 -> Alex turn\\n        \\n        return score > 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn, int sum) {\\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        int L = sum - piles[l];\\n        int R = sum - piles[r];\\n        \\n        if(turn == 0) {\\n            res = max(L + getAns(l+1,r,piles,1-turn, L), R + getAns(l,r-1,piles,1-turn, R));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn, L) - L, getAns(l,r-1,piles,1-turn, R) - R);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    int stoneGameVII(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        int sum = 0;\\n        for (int i = 0; i < piles.size(); i++) {\\n            sum += piles[i];\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alice) - score(Bob)\\n        int score = getAns(l, r, piles, 0, sum); // 0 -> Alice turn\\n        return score;\\n    }\\n};\\n```\n```\\n\\n// Bottom Up\\nclass Solution {\\npublic:\\n    \\n    bool divisorGame(int N) {\\n        vector<bool> winningState(N+1);\\n        winningState[1] = false;\\n        winningState[2] = true;\\n        \\n        for(int i=3;i<=N;i++) {\\n            bool res = false;\\n            for(int j=1;j<i;j++) {\\n                if(i % j == 0) {\\n                    res |= (!winningState[i-j]);\\n                }\\n            }\\n            winningState[i] = res;\\n        }\\n        return winningState[N]; \\n    }\\n};\\n\\n// Top Down\\nclass Solution {\\npublic:\\n    \\n    map<pair<int,int>, bool> winningState; \\n    \\n    bool getAns(int N, int turn) {\\n        if(winningState.find({N,turn}) != winningState.end()) {\\n            return winningState[{N,turn}] ;\\n        }\\n        \\n        bool win = false;\\n            \\n        for(int x=1;x<N;x++) {\\n            if(N % x == 0) {\\n                bool res = getAns(N - x, turn^1);\\n                win |= (!res);\\n            } \\n        }\\n        winningState[{N,turn}] = win;\\n        return win;\\n    }\\n    \\n    bool divisorGame(int N) {\\n        return getAns(N,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882969,
                "title": "c-recursive-dp-minimax-solution",
                "content": "Runtime: 28 ms, faster than 35.53% of C++ online submissions for Stone Game.\\nMemory Usage: 9.2 MB, less than 38.94% of C++ online submissions for Stone Game.\\n\\nSolved using MiniMax Algorithm where player1 tries to maximize his score and player2 tries to \\nminimize player1\\'s score recursively. To get the game score between two player we can add player1\\'s\\nchoice and deduce player2\\'s choice which will give max score of player1 - max score of player 2 at the end,\\ngiven that player1 took the first turn in the game.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Alex\\'s turn adds piles and Lee\\'s turn deducts piles\\n    // Game result = max piles count of Alex - max piles count of Lee\\n    // dp vector tracks the game result in range l to h\\n    int dp[501][501]={};\\n    \\n    int takeStone(bool alex, int l, int h, vector<int>& piles)\\n    {\\n        // base cases\\n        if(l>h) return 0;\\n        if(l==h) return piles[l];\\n        \\n        // return precalculated result\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // alex\\'s turn, alex can take either piles[l] or piles[h] so we add them with the recursion call as\\n        // piles[l]+takeStone(l+1,h) or piles[h]+takeStone(l,h-1) and get the max value betweeen them \\n        // for getting the game result as alex always tries to maximize his pile count\\n        if(alex)    \\n            dp[l][h] = max(piles[l]+takeStone(!alex,l+1,h,piles),piles[h]+takeStone(!alex,l,h-1,piles));\\n        \\n        // lee\\'s turn, choice for lee is same as alex, only differece is that lee wants to maximize his\\n        // game result by minimizing alex\\'s result and so we return the min value between those two choices\\n        // also to get game result we deduct piles[l] or piles[h] with recursion calls\\n        else\\n            dp[l][h] = min(-piles[l]+takeStone(!alex,l+1,h,piles),-piles[h]+takeStone(!alex,l,h-1,piles));\\n\\n        return dp[l][h];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // alex turn = true, lee turn = false\\n        // Game result = max piles count of Alex - max piles count of Lee\\n        // If result > 0 then Alex wins\\n        return takeStone(true,0,n-1,piles) > 0;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Alex\\'s turn adds piles and Lee\\'s turn deducts piles\\n    // Game result = max piles count of Alex - max piles count of Lee\\n    // dp vector tracks the game result in range l to h\\n    int dp[501][501]={};\\n    \\n    int takeStone(bool alex, int l, int h, vector<int>& piles)\\n    {\\n        // base cases\\n        if(l>h) return 0;\\n        if(l==h) return piles[l];\\n        \\n        // return precalculated result\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // alex\\'s turn, alex can take either piles[l] or piles[h] so we add them with the recursion call as\\n        // piles[l]+takeStone(l+1,h) or piles[h]+takeStone(l,h-1) and get the max value betweeen them \\n        // for getting the game result as alex always tries to maximize his pile count\\n        if(alex)    \\n            dp[l][h] = max(piles[l]+takeStone(!alex,l+1,h,piles),piles[h]+takeStone(!alex,l,h-1,piles));\\n        \\n        // lee\\'s turn, choice for lee is same as alex, only differece is that lee wants to maximize his\\n        // game result by minimizing alex\\'s result and so we return the min value between those two choices\\n        // also to get game result we deduct piles[l] or piles[h] with recursion calls\\n        else\\n            dp[l][h] = min(-piles[l]+takeStone(!alex,l+1,h,piles),-piles[h]+takeStone(!alex,l,h-1,piles));\\n\\n        return dp[l][h];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // alex turn = true, lee turn = false\\n        // Game result = max piles count of Alex - max piles count of Lee\\n        // If result > 0 then Alex wins\\n        return takeStone(true,0,n-1,piles) > 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385866,
                "title": "java-python-concise-code",
                "content": "Whenever question is about two player and both plays optimally then the key to solving the problem is **making a  optimal choice in the recursion and subtract the next recursive value**\\n\\nExplaination ->\\n\\nAlex plays a optimal move  ( recursion 1 ) \\nthen\\nBob plays a optimal move ( recursion 2)\\nthen \\nAlex plays a optimal move ( recursion 3 )\\n\\t\\nFrom this we can derive we have to add the odd recursion stack values and subtract the even ones, thats why in the code we are subtracking the next recursion value\\n\\nrecursion1 \\n\\tAlex optimal choice - recursion2\\nrecursion2\\n\\tBob optimal choice - recursion3 \\n\\nsubsituting the value of recursion2 in recursion1 we get\\nrecursion1 \\n\\tAlex optimal choice - (Bob optimal choice - recursion3 ) =Alex optimal choice- (Bob optimal choice)+recursion3\\n\\nPython\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        @cache # annotation which caches the repeated recursive calls.No need to store in dp arrays\\n        def recursion( start=0,end=len(piles)-1):\\n            if start >= end:\\n                return 0\\n\\t\\t\\t\\t\\n            choice1 = piles[start] - recursion( start+1,end)\\n            choice2 = piles[end] - recursion(start,end-1)\\n      \\n            return max( choice1, choice2 )\\n        \\n        result = recursion()\\n        return result > 0\\n```\\n\\n\\nJava\\n```\\nclass Solution {\\n    Integer[][] dp = new Integer[501][501];\\n    public boolean stoneGame(int[] piles) {\\n        return recursion( 0,piles.length-1,piles) > 0;\\n    }\\n    \\n    public int recursion( int start, int end, int[] piles )\\n    {\\n        if( start > end )\\n            return 0;\\n        if( dp[start][end] != null )\\n            return dp[start][end];\\n\\t\\t\\t\\n        int option1 = piles[start]-recursion( start+1,end,piles);\\n        int option2 = piles[end]-recursion(start,end-1,piles);\\n        \\n        return dp[start][end] = Math.max(option1,option2);\\n    }\\n}\\n```\\n\\nSpace Complexity is O(n2)\\nTime Complexity is O(n2) since in the recursion call we have two parameters and order will be n2\\n\\nIf you find it useful, **Please upvote**\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        @cache # annotation which caches the repeated recursive calls.No need to store in dp arrays\\n        def recursion( start=0,end=len(piles)-1):\\n            if start >= end:\\n                return 0\\n\\t\\t\\t\\t\\n            choice1 = piles[start] - recursion( start+1,end)\\n            choice2 = piles[end] - recursion(start,end-1)\\n      \\n            return max( choice1, choice2 )\\n        \\n        result = recursion()\\n        return result > 0\\n```\n```\\nclass Solution {\\n    Integer[][] dp = new Integer[501][501];\\n    public boolean stoneGame(int[] piles) {\\n        return recursion( 0,piles.length-1,piles) > 0;\\n    }\\n    \\n    public int recursion( int start, int end, int[] piles )\\n    {\\n        if( start > end )\\n            return 0;\\n        if( dp[start][end] != null )\\n            return dp[start][end];\\n\\t\\t\\t\\n        int option1 = piles[start]-recursion( start+1,end,piles);\\n        int option2 = piles[end]-recursion(start,end-1,piles);\\n        \\n        return dp[start][end] = Math.max(option1,option2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485238,
                "title": "rz-top-down-and-bottom-up-solutions-in-python",
                "content": "In this problem there are two players picking up stones from piles, each player can pick one pile from the left end or right end and the goal is to get the most stones.\\n\\nOne important info is that both players will play optimally, so after one player makes the best move, the other player will again make his best move out of the rest piles, then the problem player two faces is a sub-problem of the one player one faces (as it has one less pile to deal with).\\n\\nSince the final winner is the one with more stones, either we compare both players stones in the end to decide who wins, this way we need to keep two numbers, one for each player, or we can just record the max difference of stones between \\'current\\' player and \\'the other\\' player, if finally the difference is greater than 0, it means player 1 can win.\\n\\n**1. Top down solution with memoization ---> O(n ^ 2) time, O(n ^ 2) space**\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return self.helper(piles, 0, len(piles) - 1, {}) > 0\\n    \\n\\t# returns the maximum number of stones current player can get more than the other player out of piles[i] ... piles[j]\\n    def helper(self, piles, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l > r:\\n            return 0\\n        if l == r:\\n            return piles[l]\\n        \\n\\t\\t\"\"\" \\n\\t\\tassume current player is player 1, then if player 1 chooses piles[l], \\n\\t\\tself.helper(piles, l + 1, r, cache) will return the maximum stones player 2 \\n\\t\\tcan get more than player 1 from the rest (piles[l + 1] ... piles[r]), then\\n\\t\\tby subtracting it from piles[l], we get how many stones player 1 can get\\n\\t\\tmore than player 2. Since we want to maximize final result, we choose the\\n\\t\\tmax of both options player 1 can make (pick piles[l] or piles[r])\\n\\t\\t\"\"\"\\n        res = max(piles[l] - self.helper(piles, l + 1, r, cache), piles[r] - self.helper(piles, l, r - 1, cache))\\n        cache[(l, r)] = res\\n        return res\\n```\\n\\n**2. Bottom up solution ---> O(n ^ 2) time, O(n ^ 2) space**\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            f[i][i] = piles[i]\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[i][j] = max(piles[i] - f[i + 1][j], piles[j] - f[i][j - 1])\\n        \\n        return f[0][n - 1] > 0\\n```\\n**3. Bottom up solution ---> O(n ^ 2) time, O(n) space**\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [0] * n\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[j] = max(piles[i] - f[j], piles[j] - f[j - 1])\\n        \\n        return f[n - 1] > 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return self.helper(piles, 0, len(piles) - 1, {}) > 0\\n    \\n\\t# returns the maximum number of stones current player can get more than the other player out of piles[i] ... piles[j]\\n    def helper(self, piles, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l > r:\\n            return 0\\n        if l == r:\\n            return piles[l]\\n        \\n\\t\\t\"\"\" \\n\\t\\tassume current player is player 1, then if player 1 chooses piles[l], \\n\\t\\tself.helper(piles, l + 1, r, cache) will return the maximum stones player 2 \\n\\t\\tcan get more than player 1 from the rest (piles[l + 1] ... piles[r]), then\\n\\t\\tby subtracting it from piles[l], we get how many stones player 1 can get\\n\\t\\tmore than player 2. Since we want to maximize final result, we choose the\\n\\t\\tmax of both options player 1 can make (pick piles[l] or piles[r])\\n\\t\\t\"\"\"\\n        res = max(piles[l] - self.helper(piles, l + 1, r, cache), piles[r] - self.helper(piles, l, r - 1, cache))\\n        cache[(l, r)] = res\\n        return res\\n```\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            f[i][i] = piles[i]\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[i][j] = max(piles[i] - f[i + 1][j], piles[j] - f[i][j - 1])\\n        \\n        return f[0][n - 1] > 0\\n```\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [0] * n\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[j] = max(piles[i] - f[j], piles[j] - f[j - 1])\\n        \\n        return f[n - 1] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564917,
                "title": "cpp-recursive-memoization-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Optimal Strategy:** \\n`Understand that both players play optimally, meaning they will always choose the move that gives them the maximum score. Keep in mind that each player will try to minimize the opponent\\'s score while maximizing their own.`\\n\\n**Recursion with Memoization**:\\n` Use recursion to explore all possible moves and outcomes. Break down the problem into subproblems by considering different choices for the current player (either picking the first or last pile). To optimize the solution, implement memoization to store and reuse previously computed results, reducing redundant calculations.`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)  The function solve takes several parameters:\\n\\n    - piles is a reference to a vector of integers representing the  piles of stones.\\n    - start and end represent the indices of the current subarray being considered.\\n    - turn is a boolean flag indicating whether it is the current player\\'s turn or not.\\n    - dp is a reference to a 2D vector used for memoization.\\n    \\n2) The base case of the recursion is checked first. If start becomes greater than end, it means there are no more piles left to consider, so the function returns 0. This represents the score of the current player when there are no more moves to make.\\n\\n3) The next step is to check if the current subproblem has already been solved and its result is stored in the dp array. If dp[start][end] is not equal to -1, it means the subproblem has already been solved and the result is returned directly from the dp array.\\n\\n4) Depending on the value of turn, two scenarios are considered:\\n\\n- If it is the current player\\'s turn (turn is true), two recursive calls are made to evaluate the scores when choosing either the first or the last pile. The scores are calculated by calling solve recursively with the updated values of start and end and turn set to false. The score of choosing the first pile is solve(piles, start+1, end, false, dp) + piles[start], and the score of choosing the last pile is solve(piles, start, end-1, false, dp) + piles[end]. The maximum score between the two options is returned and stored in dp[start][end].\\n- If it is not the current player\\'s turn (turn is false), the same process is followed, but this time the scores are calculated by subtracting the chosen pile\\'s value from the recursive calls. The score of not choosing the first pile is solve(piles, start+1, end, true, dp) - piles[start], and the score of not choosing the last pile is solve(piles, start, end-1, true, dp) - piles[end]. Again, the maximum score between the two options is returned and stored in dp[start][end].\\n\\n5. Finally, in the stoneGame function, the initial values for start, end, turn, and dp are set. The dp array is initialized with -1, indicating that no subproblems have been solved yet. Then, the solve function is called with the initial parameters, and its result is returned as the final answer.\\n\\n\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time Complexity:\\nThe time complexity of the code depends on the number of subproblems that need to be solved. Since the code uses memoization, each subproblem is solved only once. The number of subproblems is determined by the number of unique combinations of start and end indices, which is approximately (n^2)/2, where n is the number of piles. For each subproblem, the code makes two recursive calls. Therefore, the overall time complexity can be expressed as O(n^3), where n is the number of piles.\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space Complexity:\\nThe space complexity is determined by the space required for the memoization table (dp array) and the recursion stack. The size of the dp array is (n+1) x (n+1), where n is the number of piles. Hence, the space complexity for the dp array is O(n^2). The recursion stack depth is proportional to the number of recursive calls made, which is also approximately (n^2)/2. Therefore, the space complexity of the recursion stack is O(n^2).\\n\\n# **Recursive Code**\\n\\n```\\nbool solve(vector<int>& piles, int start, int end, bool turn)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false) + piles[end];\\n            return max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true) - piles[end];\\n        return max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        return solve(piles,start,end,turn);\\n    }\\n\\n```\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>& piles, int start, int end, bool turn,vector<vector<int>> &dp)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false,dp) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false,dp) + piles[end];\\n            return dp[start][end] = max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true,dp) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true,dp) - piles[end];\\n        return dp[start][end] = max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,start,end,turn,dp);\\n    }\\n};\\n```\\n![coderuns.jpeg](https://assets.leetcode.com/users/images/f089014f-419f-4fb3-bade-ffbdb3e954f1_1685278388.128951.jpeg)\\nIf you like the solution please upvote.....\\uD83D\\uDE09\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nbool solve(vector<int>& piles, int start, int end, bool turn)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false) + piles[end];\\n            return max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true) - piles[end];\\n        return max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        return solve(piles,start,end,turn);\\n    }\\n\\n```\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>& piles, int start, int end, bool turn,vector<vector<int>> &dp)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false,dp) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false,dp) + piles[end];\\n            return dp[start][end] = max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true,dp) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true,dp) - piles[end];\\n        return dp[start][end] = max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,start,end,turn,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710180,
                "title": "explanation",
                "content": "**Roadmap**\\n\\n1. \\u0917\\u094C\\u0930 \\u0915\\u0930\\u0928\\u0947 \\u0935\\u093E\\u0932\\u0947 \\u092C\\u093E\\u0924 \\u092F\\u0939 \\u0939\\u0948 \\u0915\\u0940 piles array \\u0915\\u0940 length, even \\u0939\\u0948, \\u0907\\u0938\\u0915\\u093E \\u092E\\u0924\\u0932\\u092C \\u092F\\u0939 \\u0939\\u0948 \\u0915\\u0940 array  \\u092E\\u0947\\u0902 even index  \\u0914\\u0930 odd index \\u092C\\u0930\\u093E\\u092C\\u0930 \\u0939\\u094B\\u0902\\u0917\\u0947\\u0964  \\n2. \\u0926\\u0942\\u0938\\u0930\\u0940 \\u0917\\u094C\\u0930 \\u0915\\u0930\\u0928\\u0947 \\u0935\\u093E\\u0932\\u0940 \\u092C\\u093E\\u0924 \\u092F\\u0947 \\u0939\\u0948 \\u0915\\u0940 , array \\u0915\\u0947 \\u0938\\u093E\\u0930\\u0947 stones  \\u0915\\u093E sum, odd \\u0926\\u093F\\u092F\\u093E \\u0917\\u092F\\u093E \\u0939\\u0948\\u0964  \\u0915\\u092D\\u0940 \\u092D\\u0940 \\u0915\\u094B\\u0908 2 numbers  \\u0915\\u093E sum odd \\u0924\\u092D\\u0940 \\u0906\\u0924\\u093E \\u0939\\u0948 \\u091C\\u092C \\u0939\\u092E \\u0909\\u0928 \\u0926\\u094B\\u0928\\u094B\\u0902 \\u0928\\u0902\\u092C\\u0930\\u094D\\u0938 \\u092E\\u0947\\u0902 \\u0938\\u0947 \\u0915\\u094B\\u0908 \\u090F\\u0915 odd \\u0939\\u094B \\u0914\\u0930 \\u0926\\u0942\\u0938\\u0930\\u093E even \\u0939\\u094B\\u0924\\u093E \\u0939\\u0948 . \\n3. \\u0924\\u0940\\u0938\\u0930\\u0940 \\u0917\\u094C\\u0930 \\u0915\\u0930\\u0928\\u0947 \\u0935\\u093E\\u0932\\u0940 \\u092C\\u093E\\u0924 \\u092F\\u0939 \\u0930\\u0939\\u0940 \\u0915\\u0940 \\u0905\\u0917\\u0930 piles [i] \\u092E\\u0947\\u0902 \\u091C\\u0939\\u093E \\u092D\\u0940 \\' i \\' odd \\u0939\\u0948 \\u0909\\u0928 \\u0938\\u092D\\u0940 \\u0915\\u093E \\u091C\\u094B\\u095C \\u0932\\u093F\\u092F\\u093E \\u091C\\u093E\\u090F \\u0914\\u0930 \\u091C\\u0939\\u093E \\u092D\\u0940 \\' i \\'  \\u0907\\u0935\\u0928 \\u0939\\u0948 \\u0909\\u0928\\u0915\\u093E \\u091C\\u094B\\u095C \\u0932\\u093F\\u092F\\u093E \\u091C\\u093E\\u090F \\u0924\\u094B\\u0939 \\u092C\\u093F\\u0902\\u0926\\u0941 \\u0915\\u094D\\u0930\\u092E\\u093E\\u0902\\u0915 1 \\u0914\\u0930 2 \\u0915\\u0947 \\u0915\\u093E\\u0930\\u0923 \\u0909\\u0928 \\u0926\\u094B\\u0928\\u094B\\u0902  \\u092E\\u0947\\u0902 \\u0938\\u0947 \\u090F\\u0915 odd \\u0939\\u094B\\u0917\\u093E \\u0914\\u0930 \\u0926\\u0942\\u0938\\u0930\\u093E even \\u0939\\u094B\\u0917\\u0964  \\n\\n\\u0939\\u092E \\u0926\\u0947\\u0916 \\u0932\\u0947\\u0902\\u0917\\u0947 \\u0915\\u0940 sum of all the elements at piles[even index] aur piles[odd indices] \\u092E\\u0947\\u0902 \\u0938\\u0947 \\u091C\\u094B \\u092C\\u095C\\u093E \\u0939\\u094B \\u0935\\u094B Akshay \\u0932\\u0947 \\u0932\\u0947\\u0917\\u093E \\u0914\\u0930 Binod \\u0915\\u094B \\u091B\\u094B\\u091F\\u093E \\u0935\\u093E\\u0932\\u093E sum \\u0932\\u0947\\u0928\\u093E \\u0915\\u0940 \\u092A\\u095C\\u0947\\u0917\\u0964  \\u0907\\u0938\\u0932\\u093F\\u090F \\u092F\\u0939 \\u0916\\u0947\\u0932 \\u0935\\u094B \\u091C\\u0940\\u0924\\u0947\\u0917\\u093E \\u091C\\u094B \\u092A\\u0939\\u0932\\u0947 \\u091A\\u093E\\u0932 \\u091A\\u0932\\u0947\\u0917\\u0964  Akshay \\u0915\\u094B \\u0939\\u0930\\u093E\\u0928\\u093E \\u0928\\u093E\\u092E\\u0941\\u092E\\u0915\\u093F\\u0928 \\u0939\\u0948\\u0964  \\n\\n\\u0964\\u0964  \\u0928\\u092E\\u0938\\u094D\\u0915\\u093E\\u0930\\u0964\\u0964   \\n\\n\\n**Code**\\n\\n\\n```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384682,
                "title": "python3-easy-solution",
                "content": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n\\tn=len(piles)\\n\\tdef helper(i, j, alex, lee):\\n\\t\\tif i > j:\\n\\t\\t\\treturn alex > lee\\n\\t\\treturn helper(i + 1, j - 1, alex + piles[i], lee + piles[j]) or helper(i + 1, j - 1, alex + piles[j], lee + piles[i])\\n\\treturn helper(0, n - 1, 0, 0)",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n\\tn=len(piles)\\n\\tdef helper(i, j, alex, lee):\\n\\t\\tif i > j:\\n\\t\\t\\treturn alex > lee\\n\\t\\treturn helper(i + 1, j - 1, alex + piles[i], lee + piles[j]) or helper(i + 1, j - 1, alex + piles[j], lee + piles[i])\\n\\treturn helper(0, n - 1, 0, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 3566794,
                "title": "return-true",
                "content": "Alex is first to pick pile.\\npiles.length is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles piles[0], piles[2], ....., piles[n-2],\\nhe picks first piles[0], then Lee can pick either piles[1] or piles[n - 1].\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Alex just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345713,
                "title": "c-with-memorized-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int tot = 0;\\n        for (auto& x : piles) {\\n            tot += x;            \\n        }\\n        vector<vector<int> > dp(piles.size(), vector<int>(piles.size(), 0));    \\n        return maxStone(0, piles.size()-1, piles, dp) > tot/2;\\n    }\\n\\nprivate:\\n    int maxStone(int i, int j, vector<int>& piles, vector<vector<int> >& dp) {\\n        if (dp[i][j] > 0) {\\n            return dp[i][j];\\n        }\\n        else if (i+1 == j) {\\n            dp[i][j] = max(piles[i], piles[j]);\\n            return dp[i][j];\\n        }\\n        else {\\n            int a = piles[i] + min(maxStone(i+2,j, piles, dp), maxStone(i+1,j-1,piles,dp));\\n            int b = piles[j] + min(maxStone(i+1,j-1, piles, dp), maxStone(i, j-2, piles, dp));\\n            dp[i][j] = max(a,b);\\n            return dp[i][j];        \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int tot = 0;\\n        for (auto& x : piles) {\\n            tot += x;            \\n        }\\n        vector<vector<int> > dp(piles.size(), vector<int>(piles.size(), 0));    \\n        return maxStone(0, piles.size()-1, piles, dp) > tot/2;\\n    }\\n\\nprivate:\\n    int maxStone(int i, int j, vector<int>& piles, vector<vector<int> >& dp) {\\n        if (dp[i][j] > 0) {\\n            return dp[i][j];\\n        }\\n        else if (i+1 == j) {\\n            dp[i][j] = max(piles[i], piles[j]);\\n            return dp[i][j];\\n        }\\n        else {\\n            int a = piles[i] + min(maxStone(i+2,j, piles, dp), maxStone(i+1,j-1,piles,dp));\\n            int b = piles[j] + min(maxStone(i+1,j-1, piles, dp), maxStone(i, j-2, piles, dp));\\n            dp[i][j] = max(a,b);\\n            return dp[i][j];        \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855702,
                "title": "simple-intuitive-for-interviews-top-down-memoisation",
                "content": "When preparing for interviews keep the preparation generic for variety of problems. A simple recurrsive approach for this problem that I came up with after following editorial tips.\\n\\n```\\n    int n;\\n    int dp[][];\\n\\n    public boolean stoneGame(int[] piles) {\\n        n = piles.length;\\n        dp = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        stoneGameHelper(0, piles, 0, piles.length - 1);\\n\\n        return dp[0][n - 1] > 0;\\n    }\\n\\n    private int stoneGameHelper(int playerToPlay, int[] piles, int start, int end) {\\n        if (start > end) {  // Base case for bounds\\n            return 0;\\n        }\\n\\n        if (start == end) {  // only remaining pile\\n            return piles[start];\\n        }\\n\\n        if (dp[start][end] != -1) return dp[start][end]; // Already computed window\\n\\n        int stones;\\n        if (playerToPlay == 0) { // \\'0\\' is Alex\\n            stones = Math.max(piles[start] + stoneGameHelper(1, piles, start + 1, end),\\n                    piles[end] + stoneGameHelper(1, piles, start, end - 1));\\n        } else { // Lee plays and deducts our points, since its optimal play we take the most negative value\\n            stones = Math.min(-piles[start] + stoneGameHelper(0, piles, start + 1, end),\\n                    -piles[end] + stoneGameHelper(0, piles, start, end - 1));\\n        }\\n        dp[start][end] = stones;\\n        return stones;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "When preparing for interviews keep the preparation generic for variety of problems. A simple recurrsive approach for this problem that I came up with after following editorial tips.\\n\\n```\\n    int n;\\n    int dp[][];\\n\\n    public boolean stoneGame(int[] piles) {\\n        n = piles.length;\\n        dp = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        stoneGameHelper(0, piles, 0, piles.length - 1);\\n\\n        return dp[0][n - 1] > 0;\\n    }\\n\\n    private int stoneGameHelper(int playerToPlay, int[] piles, int start, int end) {\\n        if (start > end) {  // Base case for bounds\\n            return 0;\\n        }\\n\\n        if (start == end) {  // only remaining pile\\n            return piles[start];\\n        }\\n\\n        if (dp[start][end] != -1) return dp[start][end]; // Already computed window\\n\\n        int stones;\\n        if (playerToPlay == 0) { // \\'0\\' is Alex\\n            stones = Math.max(piles[start] + stoneGameHelper(1, piles, start + 1, end),\\n                    piles[end] + stoneGameHelper(1, piles, start, end - 1));\\n        } else { // Lee plays and deducts our points, since its optimal play we take the most negative value\\n            stones = Math.min(-piles[start] + stoneGameHelper(0, piles, start + 1, end),\\n                    -piles[end] + stoneGameHelper(0, piles, start, end - 1));\\n        }\\n        dp[start][end] = stones;\\n        return stones;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 182988,
                "title": "minimax-using-alpha-beta-pruning-written-in-java",
                "content": "**WARNING** - This solution will suffer from **TLE** in the test cases since it has an exponential time complexity. It\\'s intended to provide an implementation of the well known [alpha\\u2013beta pruning algorithm](https://en.wikipedia.org/wiki/Alpha\\u2013beta_pruning).\\n\\nFor a viable solution, Alex has a winning strategy according to [Zermelo\\'s theorem](https://en.wikipedia.org/wiki/Zermelo%27s_theorem_(game_theory)). So just return `true`.\\n\\n```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return minimax(piles, 0, piles.length - 1, Integer.MIN_VALUE, Integer.MAX_VALUE, true) > 0;\\n    }\\n    \\n    private int minimax(int[] piles, int begin, int end,\\n                        int alpha, int beta, boolean maximizing) {\\n        if (begin > end) return 0;\\n        \\n        if (maximizing) {\\n            int val = Integer.MIN_VALUE;\\n            val = Math.max(val, minimax(piles, begin + 1, end, alpha, beta, false) + piles[begin]);\\n            alpha = Math.max(alpha, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.max(val, minimax(piles, begin, end - 1, alpha, beta, false) + piles[end]);\\n            return val;\\n        } else {\\n            int val = Integer.MAX_VALUE;\\n            val = Math.min(val, minimax(piles, begin + 1, end, alpha, beta, true) - piles[begin]);\\n            beta = Math.min(beta, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.min(val, minimax(piles, begin, end - 1, alpha, beta, true) - piles[end]);\\n            return val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return minimax(piles, 0, piles.length - 1, Integer.MIN_VALUE, Integer.MAX_VALUE, true) > 0;\\n    }\\n    \\n    private int minimax(int[] piles, int begin, int end,\\n                        int alpha, int beta, boolean maximizing) {\\n        if (begin > end) return 0;\\n        \\n        if (maximizing) {\\n            int val = Integer.MIN_VALUE;\\n            val = Math.max(val, minimax(piles, begin + 1, end, alpha, beta, false) + piles[begin]);\\n            alpha = Math.max(alpha, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.max(val, minimax(piles, begin, end - 1, alpha, beta, false) + piles[end]);\\n            return val;\\n        } else {\\n            int val = Integer.MAX_VALUE;\\n            val = Math.min(val, minimax(piles, begin + 1, end, alpha, beta, true) - piles[begin]);\\n            beta = Math.min(beta, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.min(val, minimax(piles, begin, end - 1, alpha, beta, true) - piles[end]);\\n            return val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385589,
                "title": "my-1-line-solution-100-logic-0-code-with-explanation",
                "content": "All we need to do is return true because the game is a biased game which gives edge to player-1 so since draw is ruled out and player-1 plays optimally , player-1 always wins.\\n\\nsince the number of piles is even, player-1 will only select from either all odd positions or all even positions.\\n\\nIf player-1 decides to select even positions (by choosing pile[0] first) player-1 can  force player-2  into picking odd positions only.\\nIf player-1 decides to select odd positions (by choosing the last element) player can force player-2 into picking even positions only.\\nSo before the first move player-1 should calculate , if the total no of stones in  even position is greater than the total no of stones at odd positions then he should go with strictly choosing even positions only . else vise-versa. \\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Player-1 just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Player-1 just picks all odds and wins\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154779,
                "title": "java-recursion-memoization",
                "content": "We know that all the `even` turns are Alex\\'s and `odd` turns are Lee\\'s.\\n\\nWe can keep two pointers one from `start`, and one from `end`. We can select one of them first and see what is the result, then select the other one and again check what is the result. In any case if `Alex` wins, we need to return `true`, because he is the first guy to start game. We can recursively keep doing these simply.\\n\\nHowever, we know that we repeat same calls. For that, we can have a `HashMap`. Key must be unique for each `start&end` pair. If you\\'d like to you can have a `hash` function for them, or basically make the key String and put a comma `,` in between `start & end` and merge them together.\\n\\nBelow is my implementation:\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Map<String,Boolean> map = new HashMap<>();\\n        return util(piles, 0, piles.length - 1, 0, 0, map);\\n    }\\n    \\n    private Boolean util(int[] piles, int start, int end, int alex, int lee, Map<String,Boolean> map) {\\n        if (end < start) {\\n            return alex > lee;\\n        } \\n        String key = start + \",\" + end;\\n        if ((start + end) % 2 == 0) {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex + piles[start], lee, map) \\n                    || util(piles, start, end - 1, alex + piles[end], lee, map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        } else {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex, lee + piles[start], map) \\n                    || util(piles, start, end - 1, alex, lee + piles[end], map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Map<String,Boolean> map = new HashMap<>();\\n        return util(piles, 0, piles.length - 1, 0, 0, map);\\n    }\\n    \\n    private Boolean util(int[] piles, int start, int end, int alex, int lee, Map<String,Boolean> map) {\\n        if (end < start) {\\n            return alex > lee;\\n        } \\n        String key = start + \",\" + end;\\n        if ((start + end) % 2 == 0) {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex + piles[start], lee, map) \\n                    || util(piles, start, end - 1, alex + piles[end], lee, map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        } else {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex, lee + piles[start], map) \\n                    || util(piles, start, end - 1, alex, lee + piles[end], map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260028,
                "title": "alice-always-wins-explained",
                "content": "**Explanation :**\\n\\n**Points to Ponder :**\\n**1) Alice will always choose the row with maximum stones(or equal stones) from extreme left/right end. \\n2) Number of rows are even.**\\n\\n**If there are just 2 piles then Alice picks the maximum one and wins the 2-Pile game.**\\n\\n**Now say if there are 4 piles, then : (1st 2nd 3rd 4th) piles\\nIf Alice takes the first pile initially, she can always take the third pile. If she takes the fourth pile initially, she can always take the second pile. At least one of first + third, second + fourth is larger, so she can always win.**\\n\\n**Now say N piles. Say the total no. of stones in the first, third, fifth, seventh, etc. piles are X, and the total no. of stones in second, fourth, sixth, eighth, etc. piles are Y. \\nAlice can always take either X or Y stones and one of the X or Y must be larger than the other.**\\n\\n**Hence, Atlast Alice will surely WIN.**\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n\\n```\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900079,
                "title": "o-1-solution-with-explanation",
                "content": "explain\\nbecause it given that array size is even alice can either pick all odd indexed stone or all the even once \\nhow so??\\n--> consider an array arr of even size [a0,a1,a2,.........an-1] of length n, now if alice pick n-1 index then bob can either pick  n-2 or 0 th which are even then after bob\\'s pick there will be a 1 or a n-3 left to pick\\nsame logic can be applied if alice pick index 0 first  but this case alice will all even indexes\\n\\nsince alice have first choice she will pick max(all_even_indexed_sum, all_odd_indexed_sum) \\nand win the game\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n          return true;\\n    }\\n};\\n\\n\\n//this is my first post do upvote it if you like it comment if my explaination isn\\'t good enough",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n          return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1755050,
                "title": "2-methods-c-bottom-up-dp-explained-and-o-1-method",
                "content": "# 1st Way \"Recursion+Memorise..\"\\nThe whole idea lie b/w the wining of alice or bob. We have only two choices `weather we select from start or select from end.`\\n==> alice has two option ( either choose first or last)\\n==> bob has two option (either choose first or last)\\n*----------------------------------------------------------------------*\\nSo, our recursive case handle some point \\n`solve(int start,int end ,piles,turn)`\\n`start`=>starting point of choices\\n`end`=>ending point of choices\\n`turn` =>its a boolean value which help` to chek weather its a turn of alice or bob.`\\n*----------------------------------------------------------------------*\\nwhen `turn =1`\\nIts` time for alice ,now alice has two choices weather select first or last`\\n=> So we` two choices`  1.`piles[i]+solve(i+1,j,piles,0)`  2.`piles[j]+solve(i,j-1,piles,0);`\\n=>we take maixum of both.\\n*----------------------------------------------------------------------*\\n`similary we do for turn =0`\\nwe try to` maximise the value of bob by decresing the value of alice.`\\n=> we `decrese the value that alice gain `.\\n=>` 1.  -piles[i]+solve(i+1,j,piles,1)`  `  2.  - piles[j]+solve(i,j-1,piles,1)`\\n=>taking minimum of both.\\n*----------------------------------------------------------------------*\\n```\\n\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n     bool solve(int i,int j,vector<int>&piles,bool turn)\\n     {\\n         if(i>j)\\n         {\\n            \\n             return 0;\\n         }\\n         if(dp[i][j]!=-1)\\n         {\\n             return dp[i][j];\\n             \\n         }\\n        \\n \\n         if(turn ==1)\\n         {\\n              dp[i][j]= max(piles[i]+solve(i+1,j,piles,0),piles[j]+solve(i,j-1,piles,0));\\n         }\\n         else\\n         {\\n             dp[i][j]= min(-piles[i]+solve(i+1,j,piles,1),-piles[j]+solve(i,j-1,piles,1));\\n         }\\n         return dp[i][j];\\n         \\n     }\\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<501;i++)\\n        {\\n            for(int j=0;j<501;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(0,n-1,piles,1);\\n        \\n    }\\n};\\n```\\n\\n# 2nd way O(1)\\n# \\nIts quite obivous that sum of al`l piles is odd `it means` we can\\'t equall divide int two part.`\\nSo if we` slect all odd position piles =>pile_odd.`\\nand` select all even postion piles =>pile_even.`\\nAfter finding it\\nWe` conclude that` weather` pile_odd is stricttly greater or pile_even is stricly grater `\\nIf` pile_odd is greater`=>**alice selcet it and win the game**\\nif `pile_even is greater` =>**alice select it and win the game**\\nBoth case** alice win the game .**\\nSo we only have to **return true**\\n```\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n     bool solve(int i,int j,vector<int>&piles,bool turn)\\n     {\\n         if(i>j)\\n         {\\n            \\n             return 0;\\n         }\\n         if(dp[i][j]!=-1)\\n         {\\n             return dp[i][j];\\n             \\n         }\\n        \\n \\n         if(turn ==1)\\n         {\\n              dp[i][j]= max(piles[i]+solve(i+1,j,piles,0),piles[j]+solve(i,j-1,piles,0));\\n         }\\n         else\\n         {\\n             dp[i][j]= min(-piles[i]+solve(i+1,j,piles,1),-piles[j]+solve(i,j-1,piles,1));\\n         }\\n         return dp[i][j];\\n         \\n     }\\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<501;i++)\\n        {\\n            for(int j=0;j<501;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(0,n-1,piles,1);\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384650,
                "title": "c-two-solution-with-explanation",
                "content": "```\\nmethod 1:(maths)\\nalex need to play optimally and and that is why he will always choose whatever suits him. As for example :[3,2,10,4]\\nhere , we may think that alex will first choose 4 and then our resulting array would be->[3,2,10] then lee will play optimally and choose 10 and so on.\\nbut alex need to play for himself as well as he also have to make lee lose in the match by choosing such a choice that in lee\\'s round he can\\'t choose best one.\\nand that is why he will choose 3 and our resulting array become->[2,10,4]\\nhere if lee play optimally then also he will pick 4 and alex automatically get 10 that is the highest one....\\nSo alex will win in each and every case...\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\nmethod 2:(dp)\\nin this method we are playing optimally without caring about alex and lee. \\nso we are choosing both first and last entry from the piles and \\nrecurse on the remainning piles so that the opponent can also play optimally\\nfor themselves.\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int i,int j,vector<int>&piles)\\n    {\\n        if(i==j)\\n            return dp[i][j]=piles[i];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=max(piles[i]-solve(i+1,j,piles),piles[j]-solve(i,j-1,piles));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,piles.size()-1,piles)>0;\\n    }\\n};\\nplz endure with my english ....do upvote if you find it useful.........\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nmethod 1:(maths)\\nalex need to play optimally and and that is why he will always choose whatever suits him. As for example :[3,2,10,4]\\nhere , we may think that alex will first choose 4 and then our resulting array would be->[3,2,10] then lee will play optimally and choose 10 and so on.\\nbut alex need to play for himself as well as he also have to make lee lose in the match by choosing such a choice that in lee\\'s round he can\\'t choose best one.\\nand that is why he will choose 3 and our resulting array become->[2,10,4]\\nhere if lee play optimally then also he will pick 4 and alex automatically get 10 that is the highest one....\\nSo alex will win in each and every case...\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\nmethod 2:(dp)\\nin this method we are playing optimally without caring about alex and lee. \\nso we are choosing both first and last entry from the piles and \\nrecurse on the remainning piles so that the opponent can also play optimally\\nfor themselves.\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int i,int j,vector<int>&piles)\\n    {\\n        if(i==j)\\n            return dp[i][j]=piles[i];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=max(piles[i]-solve(i+1,j,piles),piles[j]-solve(i,j-1,piles));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,piles.size()-1,piles)>0;\\n    }\\n};\\nplz endure with my english ....do upvote if you find it useful.........\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262913,
                "title": "using-dp-table-diagonally-filling-gap-strategy-storing-both-players-score-simultaneously",
                "content": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        pair<int, int> dp[n][n];\\n    \\n\\t\\t//filling first diagonal\\n        for(int i=0; i<n; i++)\\n            dp[i][i] = {piles[i], 0};\\n\\t\\t\\t\\n\\t\\t//second diagonal\\t\\n        for(int i=0; i<n-1; i++)\\n            dp[i][i+1] = {max(piles[i], piles[i+1]), min(piles[i], piles[i+1]) };\\n\\n        for(int k=3; k<=n; k++)\\n        {\\n            for(int i=0; i<=n-k; i++)\\n            {\\n                //i -> i+k-1....starting and ending index\\n                int x = piles[i] + dp[i+1][i+k-1].second;\\n                int y = piles[i+k-1] + dp[i][i+k-2].second;\\n\\n                if(x > y)\\n                {\\n                    dp[i][i+k-1].first = x;\\n                    dp[i][i+k-1].second = dp[i+1][i+k-1].first;\\n                }\\n                else\\n                {\\n                    dp[i][i+k-1].first = y;\\n                    dp[i][i+k-1].second = dp[i][i+k-2].first;\\n                }\\n            }\\n        }\\n\\n        return (dp[0][n-1].first > dp[0][n-1].second);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        pair<int, int> dp[n][n];\\n    \\n\\t\\t//filling first diagonal\\n        for(int i=0; i<n; i++)\\n            dp[i][i] = {piles[i], 0}",
                "codeTag": "Java"
            },
            {
                "id": 1099487,
                "title": "gap-strategy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int dp[n][n];\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;j++,i++){\\n                if(g==0)\\n                    dp[i][j]=piles[i];\\n                else if(g==1)\\n                    dp[i][j]=max(piles[i],piles[j]);\\n                else{\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int dp[n][n];\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;j++,i++){\\n                if(g==0)\\n                    dp[i][j]=piles[i];\\n                else if(g==1)\\n                    dp[i][j]=max(piles[i],piles[j]);\\n                else{\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096602,
                "title": "o-1-solution",
                "content": "0 1 2 3 4 5\\n[5 6 7 10 8 9]\\n\\nSo Alex can start with choosing odd or even indexed pile\\nSo if he chooses odd then Lee can only choose between even\\nas Suppose Alex chose 5th now l = 0 r = 4,so Lee got only even choice\\nNow as the problem says total stones are odd , so with carefull obervations if divide total number of stone as\\n\\ntotal(stones) = oddIndexed(stones) + evenIndexed(stones)\\nAs odd and even indexed stones can\\'t be equal then either of them is greater and in start Alex has the choice to restrict Lee to whatever index he wants , so if Alex plays optimally he would always win\\n\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n   return true;\\n }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n   return true;\\n }",
                "codeTag": "Java"
            },
            {
                "id": 678326,
                "title": "java-simple-dp",
                "content": "dp[i][j] means when max diff the current player can get when i piles left, starting from jth pile\\n```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1]; \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1]; \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643412,
                "title": "python-o-n-2-by-top-down-dp-w-comment",
                "content": "[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=JjgNBSb_maE&t=27s)\\n\\nPython O( n^2 ) by top-down DP\\n\\n---\\n\\n**Implementation** by top-down DP:\\n\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n        # DP Table\\n        memo = {}\\n\\n        def take(left, right):\\n            \\n            # Look-up DP Table\\n            if (left, right) in memo:\\n                return memo[(left, right)]\\n\\n            # Base case\\n            if left == right:\\n                return piles[left]\\n\\n            # General cases\\n            # Option_1\\n            take_first_pile = piles[left] - take(left+1, right)\\n\\n            # Option_2\\n            tkae_last_pile = piles[right] - take(left, right-1)\\n\\n            memo[(left, right)] = max( take_first_pile,  tkae_last_pile)\\n            return memo[(left, right)]\\n        #================================\\n        return take(0, len(piles)-1) > 0\\n```\\n\\n---\\n\\nThe solution below is just for fun and sharing\\n\\n**Implementation** by observation:\\n\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n\\t\\t# Alice always win finally\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n        # DP Table\\n        memo = {}\\n\\n        def take(left, right):\\n            \\n            # Look-up DP Table\\n            if (left, right) in memo:\\n                return memo[(left, right)]\\n\\n            # Base case\\n            if left == right:\\n                return piles[left]\\n\\n            # General cases\\n            # Option_1\\n            take_first_pile = piles[left] - take(left+1, right)\\n\\n            # Option_2\\n            tkae_last_pile = piles[right] - take(left, right-1)\\n\\n            memo[(left, right)] = max( take_first_pile,  tkae_last_pile)\\n            return memo[(left, right)]\\n        #================================\\n        return take(0, len(piles)-1) > 0\\n```\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n\\t\\t# Alice always win finally\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263935,
                "title": "always-win-and-why",
                "content": "Since there are even numbers, and sum is odd. You may decide to pick either all the odd or all the even terms, and the other person can only pick the other type of position. So if sum of all even terms is larger, you start with last one, otherwise, you start with the first one.\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910565,
                "title": "mind-blow-up-solution-beginer-friendly",
                "content": "# Intuition\\nAll the time Alice take the first number. So if alice isn\\'t stupid  she takes the big number of the list. Alice never lose the game.\\n\\n# Approach\\nWrite to the return True\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827656,
                "title": "recursion-memoization-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthis is a **(min, max) Problem**, Here for **Alice\\'s Turn** we have to **maximize the score** and for **Bob\\'s Turn** we have to **minimize the score**.\\n\\nAccording to the above situation, here i Implementate the **Recursive Code** and **Memoize** the Recursive Calls to Avoid TLE.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(N* N* 2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501][2];\\n    int solve(vector<int> arr,int i,int j,int f)\\n    {\\n        if(i>j) return 0;\\n        if(dp[i][j][f]!=-1) return dp[i][j][f];\\n        if(f) return dp[i][j][f] = max(arr[i]+solve(arr,i+1,j,0),arr[j]+solve(arr,i,j-1,0));\\n        return dp[i][j][f] = min(-arr[i]+solve(arr,i+1,j,1),-arr[j]+solve(arr,i,j-1,1));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,piles.size()-1,1)>0;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/41e4e692-ea44-4d35-b02b-7ea128cfc619_1690531535.4428308.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501][2];\\n    int solve(vector<int> arr,int i,int j,int f)\\n    {\\n        if(i>j) return 0;\\n        if(dp[i][j][f]!=-1) return dp[i][j][f];\\n        if(f) return dp[i][j][f] = max(arr[i]+solve(arr,i+1,j,0),arr[j]+solve(arr,i,j-1,0));\\n        return dp[i][j][f] = min(-arr[i]+solve(arr,i+1,j,1),-arr[j]+solve(arr,i,j-1,1));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,piles.size()-1,1)>0;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168887,
                "title": "recursion-memoization-c-explained",
                "content": "# Approach :  RECURSION\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    return max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles);\\n        return q>(ans-q);\\n    }\\n};\\n```\\n\\n# Approach :  MEMOIZATION\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)+O(N)   {RECURION STACK SPACE}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles,vector<vector<int>>&dp){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    if(dp[idx1][idx2]!=-1){\\n        return dp[idx1][idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    return dp[idx1][idx2]=max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1-1));\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles,dp);\\n        return q<(ans-q);\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    return max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles);\\n        return q>(ans-q);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles,vector<vector<int>>&dp){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    if(dp[idx1][idx2]!=-1){\\n        return dp[idx1][idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    return dp[idx1][idx2]=max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1-1));\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles,dp);\\n        return q<(ans-q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982701,
                "title": "2-d-dynamic-programming-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For each possible case, find the \\'advantage score\\' for the player who draw first. Using an intuitive 2-D DP to calculate the advantage score.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- dp[ i ][ j ] indicates the advantage score for piles[ i : j+1 ], where dp[ i ][ j ] = max(piles[ i ] - dp[ i+1 ][ j ], piles[ j ] - dp[ i ][ j-1 ]). \\n- Besides, we need to pay more attention on the order of updating, where we need to update from small-gap cases to huge-gap cases.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # allocate the space, not so efficient\\n        dp = [[0]*(len(piles)) for k in range(len(piles))]\\n\\n        # initial conditions:\\n        for i in range(len(piles)):\\n            dp[i][i] = piles[i]\\n        \\n        # make caution of the sequence of updating, from small-gap to huge-gap (controlled by d)\\n        for d in range(1, len(piles)):\\n            for i in range(len(piles) - d):\\n                dp[i][i+d] = max(piles[i] - dp[i+1][i+d], piles[i+d] - dp[i][i+d-1])\\n\\n        print(dp)      \\n        if dp[0][-1] > 0:\\n            return True\\n        \\n        return False\\n        \\n        \\n        # \\'return True\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # allocate the space, not so efficient\\n        dp = [[0]*(len(piles)) for k in range(len(piles))]\\n\\n        # initial conditions:\\n        for i in range(len(piles)):\\n            dp[i][i] = piles[i]\\n        \\n        # make caution of the sequence of updating, from small-gap to huge-gap (controlled by d)\\n        for d in range(1, len(piles)):\\n            for i in range(len(piles) - d):\\n                dp[i][i+d] = max(piles[i] - dp[i+1][i+d], piles[i+d] - dp[i][i+d-1])\\n\\n        print(dp)      \\n        if dp[0][-1] > 0:\\n            return True\\n        \\n        return False\\n        \\n        \\n        # \\'return True\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289506,
                "title": "alice-will-always-win-c-easy-solution-using-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int i,int j,int f,int alice,int bob,int sum){\\n        if(i>=j)\\n            return alice>bob;\\n        \\n        if(alice>sum)\\n            return true;\\n        if(bob>sum)\\n            return false;\\n        \\n        if(dp[i][j][f]!=-1)\\n            return dp[i][j][f];\\n        \\n        int first=0,second=0;\\n        \\n        if(f==0){\\n            first=solve(piles,i+1,j,1,alice+piles[i],bob,sum) || solve(piles,i,j-1,1,alice+piles[j],bob,sum);\\n        }\\n        \\n        if(f==1){\\n            second=solve(piles,i+1,j,0,alice,bob+piles[i],sum) || solve(piles,i,j-1,0,alice,bob+piles[j],sum);\\n        }\\n        \\n        return dp[i][j][f]=first||second;\\n        // return first||second;\\n        \\n        \\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size(),alice=0,bob=0;\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(piles,0,n-1,0,alice,bob,sum/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int i,int j,int f,int alice,int bob,int sum){\\n        if(i>=j)\\n            return alice>bob;\\n        \\n        if(alice>sum)\\n            return true;\\n        if(bob>sum)\\n            return false;\\n        \\n        if(dp[i][j][f]!=-1)\\n            return dp[i][j][f];\\n        \\n        int first=0,second=0;\\n        \\n        if(f==0){\\n            first=solve(piles,i+1,j,1,alice+piles[i],bob,sum) || solve(piles,i,j-1,1,alice+piles[j],bob,sum);\\n        }\\n        \\n        if(f==1){\\n            second=solve(piles,i+1,j,0,alice,bob+piles[i],sum) || solve(piles,i,j-1,0,alice,bob+piles[j],sum);\\n        }\\n        \\n        return dp[i][j][f]=first||second;\\n        // return first||second;\\n        \\n        \\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size(),alice=0,bob=0;\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(piles,0,n-1,0,alice,bob,sum/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169232,
                "title": "java-dp-minimax",
                "content": "This is pretty similar to [486. Predict the Winner](https://leetcode.com/problems/predict-the-winner/solution/ ). You can check the first solution of this problem to understand the algorithm.\\n```\\nclass Solution {\\n    int[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        dp = new int[n][n];\\n        return minimax(piles,0,n-1,1) > 0;\\n    }\\n    private int minimax(int[] nums, int i, int j, int turn) {\\n        if(i==j)\\n            return turn * nums[i];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n\\t\\t\\t\\n        int l = turn * nums[i] + minimax(nums, i+1, j, -turn);\\n        int r = turn * nums[j] + minimax(nums, i, j-1, -turn);\\n        dp[i][j] = turn > 0 ? Math.max(l,r) : Math.min(l,r);\\n\\t\\t\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        dp = new int[n][n];\\n        return minimax(piles,0,n-1,1) > 0;\\n    }\\n    private int minimax(int[] nums, int i, int j, int turn) {\\n        if(i==j)\\n            return turn * nums[i];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n\\t\\t\\t\\n        int l = turn * nums[i] + minimax(nums, i+1, j, -turn);\\n        int r = turn * nums[j] + minimax(nums, i, j-1, -turn);\\n        dp[i][j] = turn > 0 ? Math.max(l,r) : Math.min(l,r);\\n\\t\\t\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885111,
                "title": "simplest-just-one-line",
                "content": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\\n\\t\\t\\nALEX can ALWAYS WIN the game!!",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 787688,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n\\t// reliased the algorithm after first writing the recursion for the solution\\n\\t// in any subset, starting at i, and ending at j, alex has two choices:\\n\\t\\t//1.pick the ith stone and then Lee picks correspondingly in the set (i+1,j]\\n\\t\\t//2.pick the jth stone and then Lee picks correspondingly in the set [i,j-)\\n\\t\\t// we identify the max sum on the basis of picking either the ith or the jth values\\n\\t\\t// The max total of the set [i, j] will be the maximum of the two values above\\n    public boolean stoneGame(int[] piles) {\\n        int m =piles.length;\\n        int findMax[][] = new int[m][m];\\n\\t\\t// setting the base condition, when the subset is [i,i], the max value one player can get is piles[i]\\n        for(int i=0;i<m;i++){\\n            findMax[i][i] = piles[i];\\n        }\\n\\t\\t// as we increase the length of the subset\\n\\t\\t// we can calculate in the bottom up manner the max value for the subset[0,m-1]\\n        for(int l=2;l<=m;l++){\\n            for(int i=0;i+l-1<m;i++){\\n                int j = i+l-1;\\n\\t\\t\\t\\t// max sum possible when Alex picks i, minus when Lee picks in the range which remaining\\n                int a = piles[i] - findMax[i+1][j];\\n\\t\\t\\t\\t// max sum possible when Alex picks j, minus when Lee picks in the range which remaining\\n                int b = piles[j] - findMax[i][j-1];\\n\\t\\t\\t\\t// max sum of the subset [i,j]\\n                findMax[i][j] = Integer.max(a,b);\\n            }\\n        }\\n\\t\\treturn findMax[0][m-1]>0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\t// reliased the algorithm after first writing the recursion for the solution\\n\\t// in any subset, starting at i, and ending at j, alex has two choices:\\n\\t\\t//1.pick the ith stone and then Lee picks correspondingly in the set (i+1,j]\\n\\t\\t//2.pick the jth stone and then Lee picks correspondingly in the set [i,j-)\\n\\t\\t// we identify the max sum on the basis of picking either the ith or the jth values\\n\\t\\t// The max total of the set [i, j] will be the maximum of the two values above\\n    public boolean stoneGame(int[] piles) {\\n        int m =piles.length;\\n        int findMax[][] = new int[m][m];\\n\\t\\t// setting the base condition, when the subset is [i,i], the max value one player can get is piles[i]\\n        for(int i=0;i<m;i++){\\n            findMax[i][i] = piles[i];\\n        }\\n\\t\\t// as we increase the length of the subset\\n\\t\\t// we can calculate in the bottom up manner the max value for the subset[0,m-1]\\n        for(int l=2;l<=m;l++){\\n            for(int i=0;i+l-1<m;i++){\\n                int j = i+l-1;\\n\\t\\t\\t\\t// max sum possible when Alex picks i, minus when Lee picks in the range which remaining\\n                int a = piles[i] - findMax[i+1][j];\\n\\t\\t\\t\\t// max sum possible when Alex picks j, minus when Lee picks in the range which remaining\\n                int b = piles[j] - findMax[i][j-1];\\n\\t\\t\\t\\t// max sum of the subset [i,j]\\n                findMax[i][j] = Integer.max(a,b);\\n            }\\n        }\\n\\t\\treturn findMax[0][m-1]>0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632233,
                "title": "interview-2d-dp-brute-force-recursion-optimised-using-bottom-up-dp-explained-in-detail",
                "content": "\\n#  When num of piles are given even then there is atleast one case in which if alex plays optimally, she is able to partition the array with more stones\\n#  But if num of piles are odd, then no such mathamatical then there is no mathamatical solution exists in that case and we need to stick to our basics in following apprioches like\\n#  1) Brute Force Recursion\\n#  2) Brute Force Recursion + Memoization\\n#  3) Bottom up iterative DP (Difficult to reach in first go so be patient while solving this problem !)\\n#  \\n\\nApproach -1 \\n```\\n// Time Complexity - Exponential    // Space Complexity - O(N)\\npublic class Medium_Stone_Game {\\n    // This solution will give time limit exceeded in leetcode and we can see that only 26/46 test cases were able to pass in the permitted time\\n    // We can optimize out brute force solution using memoization of states since this recursion clearly has Optimal substructure + Overlapping sub-problem\\n    private boolean Recursion(int[] arr,int start,int end,int alex_score,int lee_score,boolean alex_turn){\\n\\n            if( (start+1)==end){    // Since both are playing optimally, they will try to maximise only there own reward only\\n                if(alex_turn){\\n                    alex_score+=Math.max(arr[start],arr[end]);\\n                    lee_score+=Math.min(arr[start],arr[end]);\\n                }else{\\n                    alex_score+=Math.min(arr[start],arr[end]);\\n                    lee_score+=Math.max(arr[start],arr[end]);\\n                }\\n                if(alex_score>lee_score)return true;\\n                return false;\\n            }\\n            int alex_score_copy=alex_score;\\n            int lee_score_copy=lee_score;\\n            // I am choosing left most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score+=arr[start];\\n            }else{\\n                lee_score+=arr[start];\\n            }\\n\\n            boolean left_recur=Recursion(arr,start+1,end,alex_score,lee_score,!alex_turn);\\n\\n            // I am choosing right most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score_copy+=arr[end];\\n            }else{\\n                lee_score_copy+=arr[end];\\n            }\\n\\n            boolean right_recur=Recursion(arr,start,end-1,alex_score_copy,lee_score_copy,!alex_turn);\\n\\n            return left_recur||right_recur;\\n    }\\n```\\n\\nApproach - 2 \\n***I leave applying memoization to reader (I was finding it really difficult to use memo instead excessive brainstoring on this lead me to its far easier bottom up solution) :)***\\n\\nApproach - 3\\n\\n// Bottom up DP solution is quite easier and intituive If you would give a deeper thought to the problem\\n    // Actually I was trying to apply memoization to above solution but instead derived new bottom up solution\\n    // The Main recurences happening are-:\\n    \\n       Alex[i][j]= Max(arr[i] + Lee[i+1][j] , arr[j] + Lee[i][j-1]\\n       Lee[i][j] = Min(Alex[i+1][j],Alex[i][j-1])\\n    \\n       Base Conditions-: Alex[i][i]=arr[i]         // Since Alex gets first turn with the only pile to pick\\n                         Lee[i][i]=0;              // Leo won\\'t get any chance to pick any pile if there is only 1 pile\\n    \\n```\\n // Time Complexity- O(N^2) Space Complexity- O(N^2)\\n    public boolean stoneGame_BottomUpDp(int[] arr){\\n            if(arr==null || arr.length==0)return false;\\n            // Minimum 1 pile garunteed\\n            if(arr.length==1)return true;\\n\\n            int[][] Alex_Score=new int[arr.length][arr.length];\\n            int[][] Lee_Score=new int[arr.length][arr.length];\\n            // considering all piles individually as base case  (For Lee it would always be 0 so no need to do anything)\\n\\n            for(int i=0;i<arr.length;i++)\\n                Alex_Score[i][i]=arr[i];\\n\\n            // Now Procesing diagnol wise (First picking piles in pairs then triplets then so on and so forth)\\n\\n            int i=0,j=1;\\n\\n            while( ((i<arr.length) && (j<arr.length)) ){\\n                int row=i,col=j;\\n\\n                for(;((row<arr.length) && (col<arr.length));row++,col++){\\n                    Alex_Score[row][col]=Math.max(arr[row] + Lee_Score[row+1][col],arr[col] + Lee_Score[row][col-1]);\\n                    Lee_Score[row][col]=Math.min(Alex_Score[row+1][col],Alex_Score[row][col-1]);\\n                }\\n                j++;\\n            }\\n\\n\\n            return ((Alex_Score[0][arr.length-1] - Lee_Score[0][arr.length-1])  >  0);\\n    }\\n```\\n\\nPlease upvote if this helped you in better understanding  :)\\nHave a nice day !",
                "solutionTags": [],
                "code": "```\\n// Time Complexity - Exponential    // Space Complexity - O(N)\\npublic class Medium_Stone_Game {\\n    // This solution will give time limit exceeded in leetcode and we can see that only 26/46 test cases were able to pass in the permitted time\\n    // We can optimize out brute force solution using memoization of states since this recursion clearly has Optimal substructure + Overlapping sub-problem\\n    private boolean Recursion(int[] arr,int start,int end,int alex_score,int lee_score,boolean alex_turn){\\n\\n            if( (start+1)==end){    // Since both are playing optimally, they will try to maximise only there own reward only\\n                if(alex_turn){\\n                    alex_score+=Math.max(arr[start],arr[end]);\\n                    lee_score+=Math.min(arr[start],arr[end]);\\n                }else{\\n                    alex_score+=Math.min(arr[start],arr[end]);\\n                    lee_score+=Math.max(arr[start],arr[end]);\\n                }\\n                if(alex_score>lee_score)return true;\\n                return false;\\n            }\\n            int alex_score_copy=alex_score;\\n            int lee_score_copy=lee_score;\\n            // I am choosing left most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score+=arr[start];\\n            }else{\\n                lee_score+=arr[start];\\n            }\\n\\n            boolean left_recur=Recursion(arr,start+1,end,alex_score,lee_score,!alex_turn);\\n\\n            // I am choosing right most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score_copy+=arr[end];\\n            }else{\\n                lee_score_copy+=arr[end];\\n            }\\n\\n            boolean right_recur=Recursion(arr,start,end-1,alex_score_copy,lee_score_copy,!alex_turn);\\n\\n            return left_recur||right_recur;\\n    }\\n```\n```\\n // Time Complexity- O(N^2) Space Complexity- O(N^2)\\n    public boolean stoneGame_BottomUpDp(int[] arr){\\n            if(arr==null || arr.length==0)return false;\\n            // Minimum 1 pile garunteed\\n            if(arr.length==1)return true;\\n\\n            int[][] Alex_Score=new int[arr.length][arr.length];\\n            int[][] Lee_Score=new int[arr.length][arr.length];\\n            // considering all piles individually as base case  (For Lee it would always be 0 so no need to do anything)\\n\\n            for(int i=0;i<arr.length;i++)\\n                Alex_Score[i][i]=arr[i];\\n\\n            // Now Procesing diagnol wise (First picking piles in pairs then triplets then so on and so forth)\\n\\n            int i=0,j=1;\\n\\n            while( ((i<arr.length) && (j<arr.length)) ){\\n                int row=i,col=j;\\n\\n                for(;((row<arr.length) && (col<arr.length));row++,col++){\\n                    Alex_Score[row][col]=Math.max(arr[row] + Lee_Score[row+1][col],arr[col] + Lee_Score[row][col-1]);\\n                    Lee_Score[row][col]=Math.min(Alex_Score[row+1][col],Alex_Score[row][col-1]);\\n                }\\n                j++;\\n            }\\n\\n\\n            return ((Alex_Score[0][arr.length-1] - Lee_Score[0][arr.length-1])  >  0);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566617,
                "title": "dp-solution-clearly-simple-solution-with-comment",
                "content": "```java\\n\\tpublic boolean stoneGame(int[] piles) {\\n\\t\\tint n = piles.length;\\n\\n\\t\\t// dp(i,j) represents the relative score that i can achieve\\n\\t\\t// if i got to play the first hand, where the piles remaining are [i, j]\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[i][i] = piles[i]; // diagonal elements, interval length = 0\\n\\t\\t}\\n\\n\\t\\t// length of interval from [1, n-1]\\n\\t\\tfor (int interval = 1; interval < n; interval++) {\\n\\n\\t\\t\\tfor (int l = 0; l < n - interval; l++) { // start of interval\\n\\n\\t\\t\\t\\tint r = l + interval; // end of interval\\n\\n\\t\\t\\t\\t// the gain of picking left stone,\\n\\t\\t\\t\\t// minus the gain of my opponent playing first hand at interval [l+1, r]\\n\\t\\t\\t\\tint pickLeft = piles[l] - dp[l + 1][r];\\n\\n\\t\\t\\t\\t// the gain of picking right stone,\\n\\t\\t\\t\\t// minus the gain of my opponent picking first hand at interval [l, r-1]\\n\\t\\t\\t\\tint pickRight = piles[r] - dp[l][r - 1];\\n\\n\\t\\t\\t\\tdp[l][r] = dp[l][r] = Math.max(pickLeft, pickRight);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1] > 0;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\n\\tpublic boolean stoneGame(int[] piles) {\\n\\t\\tint n = piles.length;\\n\\n\\t\\t// dp(i,j) represents the relative score that i can achieve\\n\\t\\t// if i got to play the first hand, where the piles remaining are [i, j]\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[i][i] = piles[i]; // diagonal elements, interval length = 0\\n\\t\\t}\\n\\n\\t\\t// length of interval from [1, n-1]\\n\\t\\tfor (int interval = 1; interval < n; interval++) {\\n\\n\\t\\t\\tfor (int l = 0; l < n - interval; l++) { // start of interval\\n\\n\\t\\t\\t\\tint r = l + interval; // end of interval\\n\\n\\t\\t\\t\\t// the gain of picking left stone,\\n\\t\\t\\t\\t// minus the gain of my opponent playing first hand at interval [l+1, r]\\n\\t\\t\\t\\tint pickLeft = piles[l] - dp[l + 1][r];\\n\\n\\t\\t\\t\\t// the gain of picking right stone,\\n\\t\\t\\t\\t// minus the gain of my opponent picking first hand at interval [l, r-1]\\n\\t\\t\\t\\tint pickRight = piles[r] - dp[l][r - 1];\\n\\n\\t\\t\\t\\tdp[l][r] = dp[l][r] = Math.max(pickLeft, pickRight);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1] > 0;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549945,
                "title": "alex-can-always-win",
                "content": "# Alex can always win\\nIn this particular problem, with all the given constraints specially `total number of stones is odd`,  suggest that alex can always win.\\n\\n## How?\\nNotice the fact that, total number of piles are even and alex always start the game, thus he has the choice that he can either choose all even numbered piles or odd numbered piles. So, if sum off odd numbered piles is greater than sum of even numbered piles he will choose them and win.\\n\\n```\\ndef stoneGame(piles):\\n\\treturn True\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(piles):\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 384891,
                "title": "explain-play-optimally-a-straightforward-solution-with-detailed-steps",
                "content": "What does \"play optimally\" mean? \\n\\nIf you are not a master on one topic, you most likely won\\'t know, such an algorithm will be impossible to implement in a short period of time, stop trying.\\n\\nHowever if you are familiar with cheating in a game or anything similar(just kidding), there is a consistent way to play optimally, it is playing with the answer directly, like you are coming from \"the future\".  In programming, recursive methods will give you this ability.\\n\\nFor the stone game, lets use stones(left,right) to indicate number of stones Alice can get given a pile array, left is pointed to the first element, and right is the pointed to the last.\\nAlex is trying to get the most stones, he can chose either the left one or the right one.\\n```\\nstones(left,right) = Math.max(piles[left] + LeesMove1 , piles[right] + LeesMove2)\\n```\\nThen its Lee\\'s turn, what he want is the most stones as well, in another word, he wants Alex to have less. He is playing based on direct answers (will have eventually) here -- choose from two moves he can make that gives Alex less-- which is as optimal as he can get. \\n\\nAs we are tracking Lee\\'s stones(only), this moves will give us a (Alex\\'s)stone state like below\\n```\\n// Alex take piles[left] previously \\nLeesMove1 = Math.min(AlexsNextMove1 , AlexsNextMove2)\\n// Alex takes piles[right] previously\\nLeesMove2 = Math.min(AlexsNextMove3 , AlexsNextMove4)\\n```\\nWhat are Alex\\'s next move 1 2 3 4? They are fixed based on the two previous moves,\\nFor example If Alex take piles[left], Lee takes piles[right], the array becomes [left+1,...,right-1],  the move will be \\n```\\nMath.max(piles[left+1] + Lee\\'s move1 , piles[right-1] + Lee\\'s move2)\\n```\\n\\nCombine one round together we will have the below function findMax(which returns max as an int)\\n\\n```\\nmax = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles), findMax(left + 1, right - 1, piles)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles), findMax(left, right - 2, piles)));\\n \\n```\\n\\nUsing this function we can calculate the max stones Alex will have from any given array. Comparing with the sum of all piles, we can tell if Alex wins this time.\\n\\nBelow is my java code, added memo to improve performance.\\n\\n```\\npublic boolean stoneGame(int[] piles) {\\n\\n        int sum = 0;\\n        for (int i : piles) {\\n            sum += i;\\n        }\\n        int[][] mem = new int[piles.length][piles.length];\\n        return 2 * findMax(0, piles.length - 1, piles, mem) >= sum;\\n    }\\n\\n    private int findMax(int left, int right, int[] piles, int[][] mem) {\\n        if (left < 0 || right < 0 || left > right)\\n            return 0;\\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        if (left == right) {\\n            mem[left][right] = piles[left];\\n            return piles[left];\\n        }\\n\\n        int max = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles, mem), findMax(left + 1, right - 1, piles, mem)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles, mem), findMax(left, right - 2, piles, mem)));\\n        mem[left][right] = max;\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nstones(left,right) = Math.max(piles[left] + LeesMove1 , piles[right] + LeesMove2)\\n```\n```\\n// Alex take piles[left] previously \\nLeesMove1 = Math.min(AlexsNextMove1 , AlexsNextMove2)\\n// Alex takes piles[right] previously\\nLeesMove2 = Math.min(AlexsNextMove3 , AlexsNextMove4)\\n```\n```\\nMath.max(piles[left+1] + Lee\\'s move1 , piles[right-1] + Lee\\'s move2)\\n```\n```\\nmax = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles), findMax(left + 1, right - 1, piles)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles), findMax(left, right - 2, piles)));\\n \\n```\n```\\npublic boolean stoneGame(int[] piles) {\\n\\n        int sum = 0;\\n        for (int i : piles) {\\n            sum += i;\\n        }\\n        int[][] mem = new int[piles.length][piles.length];\\n        return 2 * findMax(0, piles.length - 1, piles, mem) >= sum;\\n    }\\n\\n    private int findMax(int left, int right, int[] piles, int[][] mem) {\\n        if (left < 0 || right < 0 || left > right)\\n            return 0;\\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        if (left == right) {\\n            mem[left][right] = piles[left];\\n            return piles[left];\\n        }\\n\\n        int max = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles, mem), findMax(left + 1, right - 1, piles, mem)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles, mem), findMax(left, right - 2, piles, mem)));\\n        mem[left][right] = max;\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 277753,
                "title": "java-dp-solution-calculates-number-of-stones-instead-of-difference",
                "content": "The easy solution is to just return true as discussed in most of the other solutions. The problem becomes hard when you are asked to get the number of stones alex gathers at the end of the game.\\n\\nApproach 1: You can solve the problem saving the difference of number of stones at each point. \\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex choose the first pile, then your answer is piles[i] - dp[i+1][j]\\nIf Alex choose jth pile, then your answer is  piles[j] - dp[i][j-1]\\nYou can find the code here https://leetcode.com/problems/stone-game/discuss/154610/DP-or-Just-return-true\\n\\nApproach 2: You can solve the problem by saving the number of stones at each point.\\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex chooses the first pile then the optimal number of stones he can collect would be the number of stones in the first pile + minimum number of stones he can collect from the remaining piles .i.e as Lee is playing optimally \\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the first pile considering that Lee is playing optimally?\\nIf Alex choose the first pile, then Lee has two options\\n1. Lee chooses the first pile , then answer is \\n    dp[i+2][j] (Alex would get chance to choose from [i+2,j] as i+1 pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as j pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] )\\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the last pile considering that Lee is playing optimally?\\n1. Lee chooses the first pile , then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as i pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i][j-2] (Alex would get chance to choose from [i,j-2] as j-1 pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] )\\n\\nNow, Alex knows how to calculate optimal number of stones if he choose the first pile or the last pile. The answer will be the maximum of the two choices. \\n\\ndp[i][j] = max( piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] ) , piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] ))\\n\\nHere goes the code!\\n\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        boolean first = false; // to get the idea to what Alex chose .i.e the first pile or the last pile to get the optimal solution\\n        \\n        if(n == 2)\\n            return true;\\n        \\n        int [][]dp = new int[n][n];\\n        \\n\\t\\t//initialize values when there is only one pile\\n        for(int i=0;i<=n-1;i++){\\n            dp[i][i] = piles[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<=n-1;j++){\\n                if(i < j){\\n                    int firstCutMax = Math.min((i+2 >= n ? 0 : dp[i+2][j]), i+1 >= n ? 0 : dp[i+1][j-1]);\\n                    int lastCutMax = Math.min(j-1 < i+1 ? 0 : dp[i+1][j-1], j-2 < 0 ? 0 : dp[i][j-2]);\\n                    \\n                    dp[i][j] = Math.max(piles[i] + firstCutMax, piles[j] + lastCutMax);\\n                    \\n                    if(i == 0 && j == n-1){\\n                        if(piles[i] + firstCutMax > piles[j] + lastCutMax)\\n                            first = true;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n               \\n        \\n        if(first){\\n            return dp[0][n-1] > dp[1][n-1];\\n        }\\n        else{\\n            return dp[0][n-1] > dp[0][n-2];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "The easy solution is to just return true as discussed in most of the other solutions. The problem becomes hard when you are asked to get the number of stones alex gathers at the end of the game.\\n\\nApproach 1: You can solve the problem saving the difference of number of stones at each point. \\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex choose the first pile, then your answer is piles[i] - dp[i+1][j]\\nIf Alex choose jth pile, then your answer is  piles[j] - dp[i][j-1]\\nYou can find the code here https://leetcode.com/problems/stone-game/discuss/154610/DP-or-Just-return-true\\n\\nApproach 2: You can solve the problem by saving the number of stones at each point.\\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex chooses the first pile then the optimal number of stones he can collect would be the number of stones in the first pile + minimum number of stones he can collect from the remaining piles .i.e as Lee is playing optimally \\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the first pile considering that Lee is playing optimally?\\nIf Alex choose the first pile, then Lee has two options\\n1. Lee chooses the first pile , then answer is \\n    dp[i+2][j] (Alex would get chance to choose from [i+2,j] as i+1 pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as j pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] )\\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the last pile considering that Lee is playing optimally?\\n1. Lee chooses the first pile , then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as i pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i][j-2] (Alex would get chance to choose from [i,j-2] as j-1 pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] )\\n\\nNow, Alex knows how to calculate optimal number of stones if he choose the first pile or the last pile. The answer will be the maximum of the two choices. \\n\\ndp[i][j] = max( piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] ) , piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] ))\\n\\nHere goes the code!\\n\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        boolean first = false; // to get the idea to what Alex chose .i.e the first pile or the last pile to get the optimal solution\\n        \\n        if(n == 2)\\n            return true;\\n        \\n        int [][]dp = new int[n][n];\\n        \\n\\t\\t//initialize values when there is only one pile\\n        for(int i=0;i<=n-1;i++){\\n            dp[i][i] = piles[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<=n-1;j++){\\n                if(i < j){\\n                    int firstCutMax = Math.min((i+2 >= n ? 0 : dp[i+2][j]), i+1 >= n ? 0 : dp[i+1][j-1]);\\n                    int lastCutMax = Math.min(j-1 < i+1 ? 0 : dp[i+1][j-1], j-2 < 0 ? 0 : dp[i][j-2]);\\n                    \\n                    dp[i][j] = Math.max(piles[i] + firstCutMax, piles[j] + lastCutMax);\\n                    \\n                    if(i == 0 && j == n-1){\\n                        if(piles[i] + firstCutMax > piles[j] + lastCutMax)\\n                            first = true;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n               \\n        \\n        if(first){\\n            return dp[0][n-1] > dp[1][n-1];\\n        }\\n        else{\\n            return dp[0][n-1] > dp[0][n-2];\\n        }\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 169012,
                "title": "easiest-top-down-dp-approach-with-memoization-python",
                "content": "```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # If solution to piles[:n-1] and  piles[1:n] and piles[2:]\\n        # was known then how do we get the complete solution?\\n        # Possibilities:\\n        #   1.1 Alex picks from start and Lee from the start of the remaining piles. Then problem reduces to piles[2:]\\n        #   2.1: Alex picks from start and Lee from the end of the remaining piles.\\n        #   2.2: Alex picks from end and Lee picks from start.\\n        #       => Then problem reduces to piles[1:n]\\n        #   3. Alex picks from end and Lee picks from the end of the remaining piles. Then problem reduces to piles[:n-1]\\n        memo = {}\\n        def helper(alex, lee, start, end):\\n            if start > end:\\n                return alex > lee\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            ret = (helper(alex + piles[start], lee + piles[end], start + 1, end - 1) or\\n                   helper(alex + piles[start], lee + piles[start + 1], start + 2, end) or\\n                   helper(alex + piles[end], lee + piles[start], start + 1, end - 1) or\\n                   helper(alex + piles[end], lee + piles[end - 1], start, end - 2))\\n            memo[(start, end)] = ret\\n            return ret\\n        return helper(0, 0, 0, len(piles) - 1)\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # If solution to piles[:n-1] and  piles[1:n] and piles[2:]\\n        # was known then how do we get the complete solution?\\n        # Possibilities:\\n        #   1.1 Alex picks from start and Lee from the start of the remaining piles. Then problem reduces to piles[2:]\\n        #   2.1: Alex picks from start and Lee from the end of the remaining piles.\\n        #   2.2: Alex picks from end and Lee picks from start.\\n        #       => Then problem reduces to piles[1:n]\\n        #   3. Alex picks from end and Lee picks from the end of the remaining piles. Then problem reduces to piles[:n-1]\\n        memo = {}\\n        def helper(alex, lee, start, end):\\n            if start > end:\\n                return alex > lee\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            ret = (helper(alex + piles[start], lee + piles[end], start + 1, end - 1) or\\n                   helper(alex + piles[start], lee + piles[start + 1], start + 2, end) or\\n                   helper(alex + piles[end], lee + piles[start], start + 1, end - 1) or\\n                   helper(alex + piles[end], lee + piles[end - 1], start, end - 2))\\n            memo[(start, end)] = ret\\n            return ret\\n        return helper(0, 0, 0, len(piles) - 1)\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 154624,
                "title": "recursion-with-dp",
                "content": "The idea here is to use recursion + DP to cache the already computed results. \\n\\nAlex can win by choosing the first element or the last element so we try both (indexed by i and j) and if either of them succeeds, we declare him the winner\\n\\n```python\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def helper(i,j, me, other):\\n            if i > j:\\n                return me < other\\n            else:\\n                key = (i,j,me,other)\\n                if key in table:\\n                    return table[key]\\n                ans =  helper(i+1,j, other, me + piles[i]) or helper(i,j-1, other, me + piles[j])\\n                table[key] = ans\\n                return ans\\n        table = {}\\n        return helper(0, len(piles)-1, 0, 0)\\n```\\n\\nI submitted this in the contest when i had only 5 seconds left and was pleasantly surprised that it got accepted. ",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def helper(i,j, me, other):\\n            if i > j:\\n                return me < other\\n            else:\\n                key = (i,j,me,other)\\n                if key in table:\\n                    return table[key]\\n                ans =  helper(i+1,j, other, me + piles[i]) or helper(i,j-1, other, me + piles[j])\\n                table[key] = ans\\n                return ans\\n        table = {}\\n        return helper(0, len(piles)-1, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154614,
                "title": "my-one-line-python-slution",
                "content": "```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        return True\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        return True\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3563643,
                "title": "c-easy-to-understand-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& piles, int i, int j, int sum, vector<vector<int>>& dp) {\\n        if(i>j)\\n            return 0;\\n        if(i==j)\\n            return piles[i];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        return dp[i][j] = max(sum - solve(piles, i+1, j, sum-piles[i], dp), sum - solve(piles, i, j-1, sum-piles[j], dp));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int alexStones = solve(piles, 0, n-1, sum, dp);\\n        return alexStones > sum-alexStones;\\n    }\\n};\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& piles, int i, int j, int sum, vector<vector<int>>& dp) {\\n        if(i>j)\\n            return 0;\\n        if(i==j)\\n            return piles[i];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        return dp[i][j] = max(sum - solve(piles, i+1, j, sum-piles[i], dp), sum - solve(piles, i, j-1, sum-piles[j], dp));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int alexStones = solve(piles, 0, n-1, sum, dp);\\n        return alexStones > sum-alexStones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765540,
                "title": "one-word-solution-return-true",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586858,
                "title": "simple-two-pointer-approach-c-o-1-space",
                "content": "****upvote if you find helpfull and easy****\\t\\n\\t\\n\\t\\n\\tbool stoneGame(vector<int>& piles) {\\n        int a ,b,i,j;\\n        a=b=i=0;\\n        j=piles.size()-1;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                a+=piles[i++];\\n                b+=piles[j--];\\n            }\\n            else{\\n                a+=piles[j--];\\n                b+=piles[i++];\\n            }\\n        }\\n        if(a>b) return true;\\n        return false;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "****upvote if you find helpfull and easy****\\t\\n\\t\\n\\t\\n\\tbool stoneGame(vector<int>& piles) {\\n        int a ,b,i,j;\\n        a=b=i=0;\\n        j=piles.size()-1;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                a+=piles[i++];\\n                b+=piles[j--];\\n            }\\n            else{\\n                a+=piles[j--];\\n                b+=piles[i++];\\n            }\\n        }\\n        if(a>b) return true;\\n        return false;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2579538,
                "title": "c-game-theory-concept-of-min-max-o-n-2",
                "content": "* **GAME THEORY:**\\n* **pA - Player A & pB - Player B.**\\n* Played from player A perspective: To win the game pA need to maximize his score or minimize pB score.\\n* Similarly from player B perspective: To win the game pB need to maximize his score or minimize pA score.\\n* PLAYER A POINT OF VIEW -\\n* When its pA\\'s turn - Choose the option that **maximizes pA\\'s score**.\\n* When its pB\\'s turn - Choose the option that **minimizes pA\\'s score**.\\n* As the function keeps track of & returns pA\\'s score only.\\n* When it\\'s pA\\'s turn add the score & for pB\\'s turn do not add to the score (pA\\'s score) but make the choice.\\n* The function returns the optimal score of pA. Add all the values in the array to get the TOTAL score.\\n* Calculate pB score by : **pB Score = TOTAL - pA Score**.\\n* Return (pA>=pB).\\n* You can remove the variables pathA & pathB which represents the two choice a player can take to reduce space complexity.\\n* **Time Complexity = O(N^2)**\\n* Upvote!\\n```\\nclass Solution {\\npublic:\\n    //PARAMETERS:\\n    //i & j : Ends of the array.\\n    //turn : 1 If turn of player A. 0 If turn of player B.\\n    int find(int i, int j, bool turn, vector<int> &array, vector<vector<vector<int>>> &dp){\\n        if(i>j) return 0;\\n\\n        if(dp[i][j][turn]!=-1) return dp[i][j][turn]; \\n\\n        //PLAYER A: Maximize the score of player A.\\n        if(turn){\\n            int pathA = array[i] + find(i+1, j, 0, array, dp);\\n            int pathB = array[j] + find(i, j-1, 0, array, dp);\\n            return dp[i][j][turn] = max(pathA, pathB);\\n        }\\n\\n        //PLAYER B: Minimize the score of player A.\\n        else{\\n            int pathA = find(i+1, j, 1, array, dp);\\n            int pathB = find(i, j-1, 1, array, dp);\\n            return dp[i][j][turn] = min(pathA, pathB);\\n        }\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& array) {\\n        int i=0; int j=array.size()-1;\\n        int n = array.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));\\n        int pA = find(i, j, 1, array, dp);\\n\\n        int total=0; for(const int &i: array) total+=i;\\n        int pB = total - pA;\\n\\n        return (pA>=pB);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //PARAMETERS:\\n    //i & j : Ends of the array.\\n    //turn : 1 If turn of player A. 0 If turn of player B.\\n    int find(int i, int j, bool turn, vector<int> &array, vector<vector<vector<int>>> &dp){\\n        if(i>j) return 0;\\n\\n        if(dp[i][j][turn]!=-1) return dp[i][j][turn]; \\n\\n        //PLAYER A: Maximize the score of player A.\\n        if(turn){\\n            int pathA = array[i] + find(i+1, j, 0, array, dp);\\n            int pathB = array[j] + find(i, j-1, 0, array, dp);\\n            return dp[i][j][turn] = max(pathA, pathB);\\n        }\\n\\n        //PLAYER B: Minimize the score of player A.\\n        else{\\n            int pathA = find(i+1, j, 1, array, dp);\\n            int pathB = find(i, j-1, 1, array, dp);\\n            return dp[i][j][turn] = min(pathA, pathB);\\n        }\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& array) {\\n        int i=0; int j=array.size()-1;\\n        int n = array.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));\\n        int pA = find(i, j, 1, array, dp);\\n\\n        int total=0; for(const int &i: array) total+=i;\\n        int pB = total - pA;\\n\\n        return (pA>=pB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477951,
                "title": "100-faster-solution-c-just-one-line-code",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1914270,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[500+1][500+1][2];\\n    int knapsack(vector<int>&arr,int i,int j,\\n                 int chance)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j][chance]!=-1)\\n            return dp[i][j][chance];\\n        if(chance==1)\\n        {\\n            return dp[i][j][chance]= max(arr[i]+knapsack(arr,i+1,j,0),\\n                     arr[j]+knapsack(arr,i,j-1,0));\\n        }\\n        if(chance==0)\\n        {\\n            return dp[i][j][chance]= min(knapsack(arr,i+1,j,1),\\n                     knapsack(arr,i,j-1,1));\\n        }\\n        return 0;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        int sum=0;\\n        for(auto i : piles)\\n        {\\n            sum+=i;\\n        }\\n        if(sum-2*knapsack(piles,0,piles.size()-1,1)<0)\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[500+1][500+1][2];\\n    int knapsack(vector<int>&arr,int i,int j,\\n                 int chance)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j][chance]!=-1)\\n            return dp[i][j][chance];\\n        if(chance==1)\\n        {\\n            return dp[i][j][chance]= max(arr[i]+knapsack(arr,i+1,j,0),\\n                     arr[j]+knapsack(arr,i,j-1,0));\\n        }\\n        if(chance==0)\\n        {\\n            return dp[i][j][chance]= min(knapsack(arr,i+1,j,1),\\n                     knapsack(arr,i,j-1,1));\\n        }\\n        return 0;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        int sum=0;\\n        for(auto i : piles)\\n        {\\n            sum+=i;\\n        }\\n        if(sum-2*knapsack(piles,0,piles.size()-1,1)<0)\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830632,
                "title": "simple-recursion",
                "content": "As the Constraints given are too low so normal recursion will also run and no TLE will be there \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&piles,int start,int end,int sm,int total){\\n        \\n        if(start>=end){\\n            if(sm<total-sm) return false;\\n            return true;\\n        }\\n        \\n        return possible(piles,start+1,end,sm+piles[start],total)||\\n            possible(piles,start,end-1,sm+piles[end],total);\\n        \\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n                \\n        int sm=0,total=0;\\n        \\n        for(auto x:piles) total+=x;\\n        \\n        return possible(piles,0,piles.size()-1,0,total);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&piles,int start,int end,int sm,int total){\\n        \\n        if(start>=end){\\n            if(sm<total-sm) return false;\\n            return true;\\n        }\\n        \\n        return possible(piles,start+1,end,sm+piles[start],total)||\\n            possible(piles,start,end-1,sm+piles[end],total);\\n        \\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n                \\n        int sm=0,total=0;\\n        \\n        for(auto x:piles) total+=x;\\n        \\n        return possible(piles,0,piles.size()-1,0,total);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726064,
                "title": "dp-approach-recursion-memorization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(int i,int j,vector<int> &piles){\\n        if(i > j) return 0;\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int option1 = piles[i] + min(solve(i+2,j,piles) , solve(i+1,j-1,piles));\\n        \\n        int option2 = piles[j] + min(solve(i+1,j-1,piles) , solve(i,j-2,piles));\\n        \\n        int alice = max(option1,option2);\\n        \\n        return dp[i][j] = alice;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int i = 0, j = n-1;\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        int alice = solve(i,j,piles);\\n        int bob = sum - alice;\\n        \\n        int res = alice > bob;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(int i,int j,vector<int> &piles){\\n        if(i > j) return 0;\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int option1 = piles[i] + min(solve(i+2,j,piles) , solve(i+1,j-1,piles));\\n        \\n        int option2 = piles[j] + min(solve(i+1,j-1,piles) , solve(i,j-2,piles));\\n        \\n        int alice = max(option1,option2);\\n        \\n        return dp[i][j] = alice;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int i = 0, j = n-1;\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        int alice = solve(i,j,piles);\\n        int bob = sum - alice;\\n        \\n        int res = alice > bob;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439113,
                "title": "c-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nWe can see that if there are just two piles of stone , Alice will always win. Expand the idea we can see that if we marked every piles of stone with black(b) and white(w) alternately we will have \\nfor example : with piles = [5,3,4,5]  \\nwe will have W B W B so if Alice goes first she will always can have all white piles or all black piles and because the number of piles is even and sum of all piles is odd so if we divide all the piles into two kinds of black and white, the sum of all piles of one kind will larger than the other. Therefore, Alice can always chooses the kind that the sum of all piles is larger so Alice always wins no matter what.\\n\\n* **Time Complexity**\\nWe just return true so the time complexity is **O(1)**.\\n\\n* **Space Complexity**\\nBecause we do not use any variables so the space complexity is **O(1)**.\\n\\n* **Source Code**\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385343,
                "title": "c-standard-optimal-game-strategy-recur-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[501][501];\\n    int solve(vector<int>& piles, int left, int right) {\\n        if(left > right)\\n            return 0;\\n        \\n        if(left == right)\\n            return piles[left];\\n        \\n        if(t[left][right] != -1)\\n            return t[left][right];\\n        \\n        /*\\n            That\\'s how optimal game strategy works. Expect your opponent to be playing optimally\\n            -When it\\'s your turn, do your best\\n            -When it\\'s your opponent\\'s turn, expect the worst (that\\'s why min() is taken below)\\n        */\\n        int choose_left  = piles[left]  + min(solve(piles, left+2, right), solve(piles, left+1, right-1));\\n        int choose_right = piles[right] + min(solve(piles, left, right-2), solve(piles, left+1, right-1));\\n        \\n        return t[left][right] = max(choose_left, choose_right);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        n = piles.size();\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(piles), end(piles), 0);\\n        int alexScore = solve(piles, 0, n-1);\\n        \\n        return alexScore > sum/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[501][501];\\n    int solve(vector<int>& piles, int left, int right) {\\n        if(left > right)\\n            return 0;\\n        \\n        if(left == right)\\n            return piles[left];\\n        \\n        if(t[left][right] != -1)\\n            return t[left][right];\\n        \\n        /*\\n            That\\'s how optimal game strategy works. Expect your opponent to be playing optimally\\n            -When it\\'s your turn, do your best\\n            -When it\\'s your opponent\\'s turn, expect the worst (that\\'s why min() is taken below)\\n        */\\n        int choose_left  = piles[left]  + min(solve(piles, left+2, right), solve(piles, left+1, right-1));\\n        int choose_right = piles[right] + min(solve(piles, left, right-2), solve(piles, left+1, right-1));\\n        \\n        return t[left][right] = max(choose_left, choose_right);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        n = piles.size();\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(piles), end(piles), 0);\\n        int alexScore = solve(piles, 0, n-1);\\n        \\n        return alexScore > sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384929,
                "title": "a-few-solutions",
                "content": "**Synopsis:** [\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n\\n```\\n// 3:27am - 4:06am => ~39 minutes\\n\\n/*\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4394\\n\\nPlease fix the problem statement; even/odd cardinality of the input array of stones is irrelevant.\\n\\n\\u274C \"The total number of stones is odd, so there are no ties.\"\\n\\n\\u2705 \"The accumulated sum of all of the stones values is odd, so there are no ties.\"\\n\\n*/\\n\\n/*\\n\\n3:45am: game plan, take best of first/last minus whatever\\'s leftover\\n\\nthe recursive function then needs to return the best solution as the recursive stack unwinds, so we need to consider all possibilities:\\n\\na - take first\\nb - take last\\n\\n*/\\n\\n// 3:59am brute-force TLE => ~22 minutes\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                    // \\uD83D\\uDED1 base case\\n                return A[i];\\n            auto a = A[i] - go(i + 1, j),  // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);  // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return max(a, b);              // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);          // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// 4:00am +memo for AC => + ~10 seconds\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    bool stoneGame(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                              // \\uD83D\\uDED1 base case\\n                return A[i];\\n            stringstream key; key << i << \",\" << j;\\n            if (m.find(key.str()) != m.end())        // \\uD83E\\uDD14 memo\\n                return m[key.str()];\\n            auto a = A[i] - go(i + 1, j),            // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);            // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return m[key.str()] = max(a, b);         // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);                    // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// bottom-up: 4:01am - 4:06am => ~5 minutes\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N));                           // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < N; ++i)               // \\uD83D\\uDED1 base case\\n            dp[i][i] = A[i];\\n        for (auto i{ 0 }; i + 1 < N; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto a = A[i] - dp[i + 1][j],       // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                     b = A[j] - dp[i][j - 1];       // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n                dp[i][j] = max(a, b);               // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n            }\\n        }\\n        return 0 <= dp[0][N - 1];                   // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 3:27am - 4:06am => ~39 minutes\\n\\n/*\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4394\\n\\nPlease fix the problem statement; even/odd cardinality of the input array of stones is irrelevant.\\n\\n\\u274C \"The total number of stones is odd, so there are no ties.\"\\n\\n\\u2705 \"The accumulated sum of all of the stones values is odd, so there are no ties.\"\\n\\n*/\\n\\n/*\\n\\n3:45am: game plan, take best of first/last minus whatever\\'s leftover\\n\\nthe recursive function then needs to return the best solution as the recursive stack unwinds, so we need to consider all possibilities:\\n\\na - take first\\nb - take last\\n\\n*/\\n\\n// 3:59am brute-force TLE => ~22 minutes\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                    // \\uD83D\\uDED1 base case\\n                return A[i];\\n            auto a = A[i] - go(i + 1, j),  // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);  // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return max(a, b);              // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);          // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// 4:00am +memo for AC => + ~10 seconds\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    bool stoneGame(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                              // \\uD83D\\uDED1 base case\\n                return A[i];\\n            stringstream key; key << i << \",\" << j;\\n            if (m.find(key.str()) != m.end())        // \\uD83E\\uDD14 memo\\n                return m[key.str()];\\n            auto a = A[i] - go(i + 1, j),            // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);            // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return m[key.str()] = max(a, b);         // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);                    // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// bottom-up: 4:01am - 4:06am => ~5 minutes\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N));                           // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < N; ++i)               // \\uD83D\\uDED1 base case\\n            dp[i][i] = A[i];\\n        for (auto i{ 0 }; i + 1 < N; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto a = A[i] - dp[i + 1][j],       // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                     b = A[j] - dp[i][j - 1];       // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n                dp[i][j] = max(a, b);               // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n            }\\n        }\\n        return 0 <= dp[0][N - 1];                   // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265664,
                "title": "c-dp-explained-commented-code",
                "content": "I used DP to solve this question.\\nConsider a range [i,j]. This represents numbers that would be present initially. Now, I have 2 options to choose from either front i.e if i choose i or choose from back i.e choose j. \\nCase 1: If i pick i, I would be left with [i+1,j]\\nCase 2: If i pick j, I would be left with [i,j-1]\\n\\nNow, from Case 1, i have the range [i+1,j], i have again 2 choices:\\nCase 1.1: If i pick i+1, I would be left with [i+2,j]\\nCase 1.2: If i pick j, I would be left with [i+1,j-1]\\n\\nAnd, from Case 2, i have the range [i,j-1], i have again 2 choices:\\nCase 2.1: If i pick i, I would be left with [i+1,j-1]\\nCase 2.2: If i pick j-1, I would be left with [i,j-2]\\n\\nThis formulates our dp. \\nWhen n=1 : If there is only one number in the array, Alice will pick that and win always.\\nWhen n=2 : If there are two numbers in the array, Alice will pick the maximum number first and win.\\nWhen n=3 : We have to think optimally now i.e Alice should pick a number in such a way that in the next chance, even if Bob picks maximum out of the either ends, he still loses. So, we can do this by making sure that Alice always picks maximum of previous minimum.\\nIt would be more clear from the below diagram:\\n\\n![image](https://assets.leetcode.com/users/images/13a56317-e29c-4376-ac5f-fa5a4cbe3c12_1623439399.7229393.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n));      //dp[i][j] contains the number of stones that Alice would have collected in the range [i,j]\\n        for(int g=0;g<n;g++) {                  //This represents gap i.e when g=0, there is 1 number in the array, when g=1, we have 2 numbers in the array\\n            for(int i=0,j=g;j<n;i++,j++) {\\n                if(g==0)    dp[i][j]=piles[i];                when g=0, there is 1 number in the array\\n                else if(g==1)    dp[i][j]=max(piles[i],piles[j]);\\n                else {\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        int total=0;\\n        for(int i: piles)    total+=i;\\n        int second=total-dp[0][n-1];              //dp[0][n-1] will contain the maximum number of stones at the end that Alice will have\\n        return total-second > second;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n));      //dp[i][j] contains the number of stones that Alice would have collected in the range [i,j]\\n        for(int g=0;g<n;g++) {                  //This represents gap i.e when g=0, there is 1 number in the array, when g=1, we have 2 numbers in the array\\n            for(int i=0,j=g;j<n;i++,j++) {\\n                if(g==0)    dp[i][j]=piles[i];                when g=0, there is 1 number in the array\\n                else if(g==1)    dp[i][j]=max(piles[i],piles[j]);\\n                else {\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        int total=0;\\n        for(int i: piles)    total+=i;\\n        int second=total-dp[0][n-1];              //dp[0][n-1] will contain the maximum number of stones at the end that Alice will have\\n        return total-second > second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059103,
                "title": "c-fully-explained-simple-logic-for-zerosum-game-questions",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n\\t\\t\\t// ZERO SUM GAME SIMILAR TO the problem https://leetcode.com/problems/stone-game-iii/ \\n\\n\\t\\t\\tint n=piles.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\n\\t\\t\\t//dp[i][j] represents the difference between the scores of P1 & P2 for the array i to j assuming P1 starts first\\n\\t\\t\\t\\n\\t\\t\\t//P1 can be anyone and we are simulating the choice for the 2nd player also in the same step so dp[i][j] always represents the difference between Player1 and Player2\\n\\t\\t\\t//since simulating 2nd player also in the same step so no need of a player dimension\\n\\n\\n\\t\\t\\t//by seeing the recurrence, we observe that the subproblem subarray length is 1 less than this problem and this 1 is less either from start or from the end so this is a LENGTH DP *************\\n\\n\\t\\t\\t//also you get hint of length dp as when we try to enumerate base cases then we see that if 1 pile is there then ans= itself ,,if two then max-other one ....\\n\\t\\t\\t//so we see that we need to go length wise same as that of longest palindromic substring/sequent\\n\\n\\t//so recurrence : T(piles,i,j)= max(piles[i]-T(piles,i+1,j), piles[j]-T(piles,i,j-1))\\n\\n\\t\\t\\t//base case ...subarray of length =1\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tdp[i][i]=1;\\n\\n\\t\\t\\tfor(int i=2;i<=n;i++) ////outer loop for length of array considered *****remember it has to go till n as max length of array is n not n-1\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j+i-1<n;j++)    //inner loop for start index determination\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint start=j,end=j+i-1;\\n\\n\\t\\t\\t\\t\\tdp[start][end]=max(piles[start]-dp[start+1][end],piles[end]-dp[start][end-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[0][n-1] >0 ? true :false ;   //so P1-P2 >0 means than P1 scored more points and since P1 was Alex at the starting of game so if P1-P2>0 then this means Alex wins\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n\\t\\t\\t// ZERO SUM GAME SIMILAR TO the problem https://leetcode.com/problems/stone-game-iii/ \\n\\n\\t\\t\\tint n=piles.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\n\\t\\t\\t//dp[i][j] represents the difference between the scores of P1 & P2 for the array i to j assuming P1 starts first\\n\\t\\t\\t\\n\\t\\t\\t//P1 can be anyone and we are simulating the choice for the 2nd player also in the same step so dp[i][j] always represents the difference between Player1 and Player2\\n\\t\\t\\t//since simulating 2nd player also in the same step so no need of a player dimension\\n\\n\\n\\t\\t\\t//by seeing the recurrence, we observe that the subproblem subarray length is 1 less than this problem and this 1 is less either from start or from the end so this is a LENGTH DP *************\\n\\n\\t\\t\\t//also you get hint of length dp as when we try to enumerate base cases then we see that if 1 pile is there then ans= itself ,,if two then max-other one ....\\n\\t\\t\\t//so we see that we need to go length wise same as that of longest palindromic substring/sequent\\n\\n\\t//so recurrence : T(piles,i,j)= max(piles[i]-T(piles,i+1,j), piles[j]-T(piles,i,j-1))\\n\\n\\t\\t\\t//base case ...subarray of length =1\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tdp[i][i]=1;\\n\\n\\t\\t\\tfor(int i=2;i<=n;i++) ////outer loop for length of array considered *****remember it has to go till n as max length of array is n not n-1\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j+i-1<n;j++)    //inner loop for start index determination\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint start=j,end=j+i-1;\\n\\n\\t\\t\\t\\t\\tdp[start][end]=max(piles[start]-dp[start+1][end],piles[end]-dp[start][end-1]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 992564,
                "title": "alex-will-only-lose-if-even-sum-odd-sum-which-is-not-possible",
                "content": "```\\nbool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902060,
                "title": "short-clean-cpp-dp",
                "content": "similar idea shorter version\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> memo;\\n    int dfs(vector<int> &piles, int index) {\\n        if (index == piles.size() / 2) return 0;\\n        if (memo.count(index)) return memo[index];\\n        int n = piles.size() - 1;\\n        int l = piles[index] + dfs(piles, index + 1);\\n        int r = piles[n - index] + dfs(piles, index + 1);\\n        return memo[index] = max(l, r);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return dfs(piles, 0) * 2 > accumulate(begin(piles), end(piles), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> memo;\\n    int dfs(vector<int> &piles, int index) {\\n        if (index == piles.size() / 2) return 0;\\n        if (memo.count(index)) return memo[index];\\n        int n = piles.size() - 1;\\n        int l = piles[index] + dfs(piles, index + 1);\\n        int r = piles[n - index] + dfs(piles, index + 1);\\n        return memo[index] = max(l, r);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return dfs(piles, 0) * 2 > accumulate(begin(piles), end(piles), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731428,
                "title": "javascript-solution-top-down-with-memoization",
                "content": "```\\nvar stoneGame = function(piles) {\\n    const n = piles.length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        memo[i] = [];\\n    }\\n    \\n    return topDown(0, n - 1) > 0;\\n    \\n    function topDown(start, end) {\\n        if (start == end) return piles[start];\\n        if (memo[start][end]) return memo[start][end];\\n        \\n        const startPick = piles[start] - topDown(start + 1, end);\\n        const endPick = piles[end] - topDown(start, end - 1);\\n        \\n        const res = Math.max(startPick, endPick);\\n        \\n        memo[start][end] = res;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar stoneGame = function(piles) {\\n    const n = piles.length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        memo[i] = [];\\n    }\\n    \\n    return topDown(0, n - 1) > 0;\\n    \\n    function topDown(start, end) {\\n        if (start == end) return piles[start];\\n        if (memo[start][end]) return memo[start][end];\\n        \\n        const startPick = piles[start] - topDown(start + 1, end);\\n        const endPick = piles[end] - topDown(start, end - 1);\\n        \\n        const res = Math.max(startPick, endPick);\\n        \\n        memo[start][end] = res;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470957,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int>& piles, int i, int j, vector<vector<int>>& memo){\\n        if(i>=j)\\n            return 0;\\n        if(memo[i][j] != 0)\\n            return memo[i][j];\\n        int a = piles[i] + min(help(piles,i+2,j, memo),help(piles,i+1,j-1, memo));\\n        int b = piles[j] + min(help(piles,i+1,j-1, memo), help(piles,i,j-2, memo));\\n        memo[i][j] = max(a,b);\\n        return memo[i][j];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int sum = 0;\\n        int n = piles.size();\\n        for(int i=0; i<n; i++){\\n            sum += piles[i];\\n        }\\n        \\n        vector<vector<int>> memo(n, vector<int>(n, 0));\\n        int info = help(piles, 0, n-1, memo);\\n        if(info > (sum - info))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int>& piles, int i, int j, vector<vector<int>>& memo){\\n        if(i>=j)\\n            return 0;\\n        if(memo[i][j] != 0)\\n            return memo[i][j];\\n        int a = piles[i] + min(help(piles,i+2,j, memo),help(piles,i+1,j-1, memo));\\n        int b = piles[j] + min(help(piles,i+1,j-1, memo), help(piles,i,j-2, memo));\\n        memo[i][j] = max(a,b);\\n        return memo[i][j];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int sum = 0;\\n        int n = piles.size();\\n        for(int i=0; i<n; i++){\\n            sum += piles[i];\\n        }\\n        \\n        vector<vector<int>> memo(n, vector<int>(n, 0));\\n        int info = help(piles, 0, n-1, memo);\\n        if(info > (sum - info))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177041,
                "title": "c-solutin-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findwin(vector<int>&piles, int left, int right, vector<vector<int>>& dp){\\n        if(left > right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int pos1 = piles[left] + min(findwin(piles, left + 2, right, dp), findwin(piles, left+1, right-1, dp));\\n        int pos2 = piles[right] + min(findwin(piles, left+1, right-1, dp), findwin(piles, left, right-2, dp));\\n        return dp[left][right] = max(pos1, pos2);\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), -1));\\n        int left = 0;\\n        int right = piles.size()-1;\\n        int alex = findwin(piles, left, right, dp);\\n        int sum = 0;\\n        for(int i=0; i<piles.size(); i++)\\n            sum += piles[i];\\n        return alex > sum - alex;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findwin(vector<int>&piles, int left, int right, vector<vector<int>>& dp){\\n        if(left > right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int pos1 = piles[left] + min(findwin(piles, left + 2, right, dp), findwin(piles, left+1, right-1, dp));\\n        int pos2 = piles[right] + min(findwin(piles, left+1, right-1, dp), findwin(piles, left, right-2, dp));\\n        return dp[left][right] = max(pos1, pos2);\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), -1));\\n        int left = 0;\\n        int right = piles.size()-1;\\n        int alex = findwin(piles, left, right, dp);\\n        int sum = 0;\\n        for(int i=0; i<piles.size(); i++)\\n            sum += piles[i];\\n        return alex > sum - alex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828247,
                "title": "c-o-1-solution-o-1-space",
                "content": "# Intuition\\nTestCase is not Like codeforces\\n\\nAs array length is even and sum is always odd so Alice will win always.\\n\\n# Approach\\nReturn true\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n``` Just upvote it :) ```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` Just upvote it :) ```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620322,
                "title": "alice-will-win-cpp-easy-2d-dp-just-return-true",
                "content": "```\\n\\n```class Solution {\\nprivate:\\n   //function that see weather alice win if return true.\\n   //piles given vector and dp to store result and use in future and start and end to compare \\n   //both possible piles value/amount in it to choose optimal one.\\n    bool solve(vector<int>&piles,vector<vector<int>>&dp,int start,int end,int alice,int bob,int turn){\\n\\t//if both pointer cross/ at same point;\\n        if(end<=start){\\n            if(turn==0)alice+=piles[end];\\n            else bob+=piles[end];\\n\\t\\t\\t//base case alice wins\\n            if(alice>bob)return 1;\\n            return 0;\\n        }\\n\\t\\t//check this operation is previously done if return what was answer.\\n       if(dp[start][end]!=-1)return dp[start][end];\\n\\t   //all possible ways i.e 12 \\uD83E\\uDD72\\n        bool s1=0,s2=0,s3=0,s4=0,s5=0,s6=0,s7=0,s8=0,s9=0,s10=0,s11=0,s12=0;\\n\\t  //if both value present at start and end are same.\\n        if(piles[start]==piles[end]){\\n\\t\\t//if then check for turn 0 for alice and 1 for bob.\\n            if(turn==0){\\n\\t\\t\\t     //alice turn.\\n\\t\\t\\t    //go for both call because same value at start end end.\\n\\t\\t\\t\\t//start call select and go for other.\\n                s1=solve(piles,dp,start+1,end,alice+piles[start],bob,1);\\n\\t\\t\\t\\t//selecting end call and go forward.\\n                s2=solve(piles,dp,start,end-1,alice+piles[end],bob,1);\\n            }else{\\n\\t\\t\\t //if bobs turn .\\n\\t\\t\\t //start call.\\n                s3=solve(piles,dp,start+1,end,alice,bob+piles[start],0);\\n\\t\\t\\t//end call.\\n                s4=solve(piles,dp,start,end-1,alice,bob+piles[end],0);\\n            }\\n        }\\n\\t\\t//if value at start index is greater then end.\\n        if(piles[start]>piles[end]){\\n\\t\\t//alice turn.\\n             if(turn==0){\\n\\t\\t\\t   //here we need to check for both possiblity because if in futhure this kind of case may occur [3,2,10,4].\\n\\t\\t\\t   //i.e ur choosing for current position is optimal but for further calls it will not be optimal so we choose both calls.\\n                s5=solve(piles,dp,start+1,end,alice+piles[start],bob,1);\\n\\t\\t\\t\\t//very important to understand and call.\\n                s6=solve(piles,dp,start,end-1,alice+piles[end],bob,1);\\n            }\\n\\t\\t//bobs turn.\\n\\t\\t\\telse{\\n\\t\\t\\t //same as alice possibility bob also need to play optimally.\\n                s7=solve(piles,dp,start+1,end,alice,bob+piles[start],0);\\n               s8=solve(piles,dp,start,end-1,alice,bob+piles[end],0);\\n            }\\n        }else{\\n\\t\\t  //similar thought process goes for this possibility.\\n             if(turn==0){\\n\\t\\t\\t    //if end index value greater then start.\\n                s9=solve(piles,dp,start+1,end,alice+piles[start],bob,1);\\n                s10=solve(piles,dp,start,end-1,alice+piles[end],bob,1);\\n            }else{\\n                s11=solve(piles,dp,start+1,end,alice,bob+piles[start],0);\\n                s12=solve(piles,dp,start,end-1,alice,bob+piles[end],0);\\n            }\\n        }\\n\\t\\t//at the end store/return all possibilitys.\\n        return dp[start][end]=(s1||s2||s3||s4||s5||s6||s7||s8||s9||s10||s11||s12);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n\\t\\t//2d dp vector to see both side possibility start/end of row.\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return solve(piles,dp,0,n-1,0,0,0);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/5881e682-f80a-481b-915b-78fd5c8442d3_1689053130.4833167.jpeg)\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\n```\n```\\n![image](https://assets.leetcode.com/users/images/5881e682-f80a-481b-915b-78fd5c8442d3_1689053130.4833167.jpeg)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573069,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach 1: Recursive DP\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n is number of piles.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)\\n\\n\\n```\\n\\n# Approach 2: Math\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)\\n\\n\\n```\n```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565994,
                "title": "4-solutions-why-alice-always-wins-intuition-explained-brute-optimal-with-comment-explanation",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If You\\'re Thinking I Am Also Here With Rough And Same Explanations As Others Of Why Alice Always Wins. But No, Believe Me I Understand It And Made The Intuition Myself. \\n\\n- I Bet You\\'ll Say In The End That You Got It.\\n- The Only Thing You Have To Do Is To Just Look At The Code And Read The Comments With A Happy Face, Thats It!\\n\\nNote : Start reading from the Main Method\\n\\n- If you\\'re raised with any kinda doubt, The comment section is free to be filled. I will Definately Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n4 Solutions :-\\n1. Recursion\\n2. Recursion + Memoization\\n3. Easy Two Pointers\\n4. One Line Solution - With Actual Intuition & Reason\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to verify Alice wins the game or Bob as both the players are playing optimally ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <numeric>\\nusing namespace std;\\n\\n// #1 Method Helper\\nint solveWithoutMemo(vector<int>& piles, bool turn, int i, int j) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithoutMemo(piles, !turn, i+1, j); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithoutMemo(piles, !turn, i, j-1); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return currentStone;\\n}\\n\\n// #1 Method to verify Alice wins the game or Bob - O(2^N) & O(N)\\nbool stoneGame_1(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    int aliceStones = solveWithoutMemo(piles, true, 0, n-1); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: This one can give TLE\\n\\n// #2 Method Helper\\nint solveWithMemo(vector<int>& piles, bool turn, int i, int j, vector<vector<int>>& memo) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    if(memo[i][j] != -1)\\n        return memo[i][j];\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithMemo(piles, !turn, i+1, j, memo); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithMemo(piles, !turn, i, j-1, memo); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return memo[i][j] = currentStone;\\n}\\n\\n// #2 Method to verify Alice wins the game or Bob - O(N^2) & O(N^2)\\nbool stoneGame_2(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    vector<vector<int>> memo(n, vector<int>(n, -1));\\n\\n    int aliceStones = solveWithMemo(piles, true, 0, n-1, memo); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: Can also make the Bottom Up Approach\\n\\n// #3 Method to verify Alice wins the game or Bob - O(N) & O(1)\\nbool stoneGame_3(vector<int>& piles) {\\n    int i = 0;\\n    int j = piles.size() - 1;\\n\\n    int aliceStones = 0, bobStones = 0;\\n    bool aliceTurn = true; // We know Alice always starts the game that means she always wants to maximize her score\\n\\n    while(i <= j) {\\n        // If its Alice\\'s turn\\n        if(aliceTurn) {\\n            // Take the maximum score for her because she is the initial player with turn and she wants to win\\n            if(piles[i] > piles[j])\\n                aliceStones += piles[i++];\\n            else\\n                aliceStones += piles[j--];\\n        }\\n        // Else its Bob\\'s turn\\n        else {\\n            // Let him with the minimum score because the initial turn player(Alice) wants to win\\n            if(piles[i] > piles[j])\\n                bobStones += piles[j--];\\n            else\\n                bobStones += piles[i++];\\n        }\\n        \\n        aliceTurn = !aliceTurn; // Change the player turn\\n    }\\n\\n    // Alice wins if she has more stones than Bob\\n    return aliceStones > bobStones;\\n}\\n\\n// #4 Method to verify Alice wins the game or Bob - O(1) & O(1)\\nbool stoneGame_4(vector<int>& piles) {\\n    // Alice always wins the game : Read the reason with below example\\n    \\n    /* \\n        1. We know both Alice and Bob have two possibility - Is that the player with its turn can take the entire pile of stones either from the beginning or from the end of the row\\n\\n        2. If you notice the player who starts the game :-\\n            - If it chooses the possibility of taking the entire piles from extreme left than this player will absolutely moving in odd fashion \\n            - If it chooses the possibility of taking the entire piles from extreme right than this player will absolutely moving in even fashion \\n\\n        3. So, Lets understand with the Example : [5, 2, 3, 3]\\n                                        Position - 1  2  3  4\\n\\n            -> We know Alice always starts the game, Than the odd fashion results of Alice and Bob will be :-\\n                    Alice Stones - [5, 3] (Maximum is 8)\\n                    Bob Stones   - [2, 3] (Maximum is 5)\\n\\n            -> We know Alice always starts the game, Than the even fashion results of Alice and Bob will be :-\\n                    Alice Stones - [3, 2] (Maximum is 5) \\n                    Bob Stones   - [3, 5] (Maximum is 8)\\n\\n\\n            Imp: If you notice you can see both the players have choosen all positions from both the possibility\\n                That means Alice and Bob both got the maximum results, That means both are going to Win! As both made the maximum. But No, Its not like that\\n                The reason why Alice is always the winner is because Alice is ending up with all the positions first which we can see in the second possibility, Here again take a look at it :-\\n\\n                    Alice Stones - [3, 2] (Maximum is 5) --> See Alice is ending up firstly! Which means, When the player who made all the positions first from both the possibility has got the game! Because we know taking all the positions means that the larger score lies in that, and we can see from both the possibility that Alice made it first, Thats why Alice always wins the game\\n\\n                    Bob Stones   - [3, 5] (Maximum is 8) --> As Alice ended up firstly! There is no way to win for Bob       \\n\\n        4. Again, Alice always wins the game because we know the maximum result always lies in anyone possibility and hence Alice ended up with all the positions first! She\\'s got the game\\n    */\\n   \\n    return true;\\n}\\n\\n// Driver code\\nint main() {\\n    vector<int> piles{5, 2, 3, 3};\\n    // Print values\\n    for(int stone : piles)\\n        cout<<stone<<\\' \\';\\n\\n    // Method call\\n    if(stoneGame_4(piles))\\n        cout<<\"\\\\nAlice wins the game with maximum stones!\";\\n    else\\n        cout<<\"\\\\nBob wins the game with maximum stones!\";\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/stone-game/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\n// Program to verify Alice wins the game or Bob as both the players are playing optimally ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <numeric>\\nusing namespace std;\\n\\n// #1 Method Helper\\nint solveWithoutMemo(vector<int>& piles, bool turn, int i, int j) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithoutMemo(piles, !turn, i+1, j); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithoutMemo(piles, !turn, i, j-1); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return currentStone;\\n}\\n\\n// #1 Method to verify Alice wins the game or Bob - O(2^N) & O(N)\\nbool stoneGame_1(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    int aliceStones = solveWithoutMemo(piles, true, 0, n-1); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: This one can give TLE\\n\\n// #2 Method Helper\\nint solveWithMemo(vector<int>& piles, bool turn, int i, int j, vector<vector<int>>& memo) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    if(memo[i][j] != -1)\\n        return memo[i][j];\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithMemo(piles, !turn, i+1, j, memo); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithMemo(piles, !turn, i, j-1, memo); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return memo[i][j] = currentStone;\\n}\\n\\n// #2 Method to verify Alice wins the game or Bob - O(N^2) & O(N^2)\\nbool stoneGame_2(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    vector<vector<int>> memo(n, vector<int>(n, -1));\\n\\n    int aliceStones = solveWithMemo(piles, true, 0, n-1, memo); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: Can also make the Bottom Up Approach\\n\\n// #3 Method to verify Alice wins the game or Bob - O(N) & O(1)\\nbool stoneGame_3(vector<int>& piles) {\\n    int i = 0;\\n    int j = piles.size() - 1;\\n\\n    int aliceStones = 0, bobStones = 0;\\n    bool aliceTurn = true; // We know Alice always starts the game that means she always wants to maximize her score\\n\\n    while(i <= j) {\\n        // If its Alice\\'s turn\\n        if(aliceTurn) {\\n            // Take the maximum score for her because she is the initial player with turn and she wants to win\\n            if(piles[i] > piles[j])\\n                aliceStones += piles[i++];\\n            else\\n                aliceStones += piles[j--];\\n        }\\n        // Else its Bob\\'s turn\\n        else {\\n            // Let him with the minimum score because the initial turn player(Alice) wants to win\\n            if(piles[i] > piles[j])\\n                bobStones += piles[j--];\\n            else\\n                bobStones += piles[i++];\\n        }\\n        \\n        aliceTurn = !aliceTurn; // Change the player turn\\n    }\\n\\n    // Alice wins if she has more stones than Bob\\n    return aliceStones > bobStones;\\n}\\n\\n// #4 Method to verify Alice wins the game or Bob - O(1) & O(1)\\nbool stoneGame_4(vector<int>& piles) {\\n    // Alice always wins the game : Read the reason with below example\\n    \\n    /* \\n        1. We know both Alice and Bob have two possibility - Is that the player with its turn can take the entire pile of stones either from the beginning or from the end of the row\\n\\n        2. If you notice the player who starts the game :-\\n            - If it chooses the possibility of taking the entire piles from extreme left than this player will absolutely moving in odd fashion \\n            - If it chooses the possibility of taking the entire piles from extreme right than this player will absolutely moving in even fashion \\n\\n        3. So, Lets understand with the Example : [5, 2, 3, 3]\\n                                        Position - 1  2  3  4\\n\\n            -> We know Alice always starts the game, Than the odd fashion results of Alice and Bob will be :-\\n                    Alice Stones - [5, 3] (Maximum is 8)\\n                    Bob Stones   - [2, 3] (Maximum is 5)\\n\\n            -> We know Alice always starts the game, Than the even fashion results of Alice and Bob will be :-\\n                    Alice Stones - [3, 2] (Maximum is 5) \\n                    Bob Stones   - [3, 5] (Maximum is 8)\\n\\n\\n            Imp: If you notice you can see both the players have choosen all positions from both the possibility\\n                That means Alice and Bob both got the maximum results, That means both are going to Win! As both made the maximum. But No, Its not like that\\n                The reason why Alice is always the winner is because Alice is ending up with all the positions first which we can see in the second possibility, Here again take a look at it :-\\n\\n                    Alice Stones - [3, 2] (Maximum is 5) --> See Alice is ending up firstly! Which means, When the player who made all the positions first from both the possibility has got the game! Because we know taking all the positions means that the larger score lies in that, and we can see from both the possibility that Alice made it first, Thats why Alice always wins the game\\n\\n                    Bob Stones   - [3, 5] (Maximum is 8) --> As Alice ended up firstly! There is no way to win for Bob       \\n\\n        4. Again, Alice always wins the game because we know the maximum result always lies in anyone possibility and hence Alice ended up with all the positions first! She\\'s got the game\\n    */\\n   \\n    return true;\\n}\\n\\n// Driver code\\nint main() {\\n    vector<int> piles{5, 2, 3, 3};\\n    // Print values\\n    for(int stone : piles)\\n        cout<<stone<<\\' \\';\\n\\n    // Method call\\n    if(stoneGame_4(piles))\\n        cout<<\"\\\\nAlice wins the game with maximum stones!\";\\n    else\\n        cout<<\"\\\\nBob wins the game with maximum stones!\";\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/stone-game/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3565641,
                "title": "stone-game-slightly-diff-house-robber",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(int i,vector<int>& piles,vector<int>&dp)\\n    {\\n        if(i<0) return false;\\n        if(i==0) return piles[i];\\n        if(dp[i]!=-1) return dp[i];\\n        int take=f(i-1,piles,dp)+piles[i];\\n        int nott=f(i-2,piles,dp)+0;\\n        return dp[i]=max(take,nott);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<int>dp(n,-1);\\n        return max(f(n-1,piles,dp),f(0,piles,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,vector<int>& piles,vector<int>&dp)\\n    {\\n        if(i<0) return false;\\n        if(i==0) return piles[i];\\n        if(dp[i]!=-1) return dp[i];\\n        int take=f(i-1,piles,dp)+piles[i];\\n        int nott=f(i-2,piles,dp)+0;\\n        return dp[i]=max(take,nott);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<int>dp(n,-1);\\n        return max(f(n-1,piles,dp),f(0,piles,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503835,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& v) {\\n        int a=0,b=0,i=0,j=v.size()-1;\\n        while(i<j){\\n          if(v[i]>v[j]){\\n            a+=v[i];\\n            b+=v[j];\\n          }\\n          else{\\n            a+=v[j];\\n            b+=v[i];\\n          }\\n          i++;\\n          j--;\\n        }\\n        return a>b;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        int sum1=0,sum2=0,sum3=0,sum4=0;\\n        for(int i=0;i<n;i++){\\n            if((i+1)%2!=0){\\n                     sum1+=piles[i];\\n                 }else {\\n                     sum2+=piles[i];\\n                 }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n                 if(i%2!=0){\\n                     sum3+=piles[i];\\n                 }else {\\n                     sum4+=piles[i];\\n                 }\\n             }\\n        if(sum1>sum3){\\n            if(sum1>sum2)return true;\\n        }else{\\n           if(sum3>sum4)return true;\\n        }\\n        return false;         \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& v) {\\n        int a=0,b=0,i=0,j=v.size()-1;\\n        while(i<j){\\n          if(v[i]>v[j]){\\n            a+=v[i];\\n            b+=v[j];\\n          }\\n          else{\\n            a+=v[j];\\n            b+=v[i];\\n          }\\n          i++;\\n          j--;\\n        }\\n        return a>b;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        int sum1=0,sum2=0,sum3=0,sum4=0;\\n        for(int i=0;i<n;i++){\\n            if((i+1)%2!=0){\\n                     sum1+=piles[i];\\n                 }else {\\n                     sum2+=piles[i];\\n                 }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n                 if(i%2!=0){\\n                     sum3+=piles[i];\\n                 }else {\\n                     sum4+=piles[i];\\n                 }\\n             }\\n        if(sum1>sum3){\\n            if(sum1>sum2)return true;\\n        }else{\\n           if(sum3>sum4)return true;\\n        }\\n        return false;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083108,
                "title": "easy-two-pointer-solution-javascript",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {number[]} piles\\n * @return {boolean}\\n */\\nvar stoneGame = function(piles) {\\n    return true; // Alice wins anyways\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Game Theory"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @return {boolean}\\n */\\nvar stoneGame = function(piles) {\\n    return true; // Alice wins anyways\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031911,
                "title": "0ms-with-100-beats-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n    return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n    return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958537,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool helper(int start, int end, int turn, vector<int> &piles, int scorea, int scoreb, vector<vector<int>> &dp){\\n\\n        if(start == end){\\n            if(turn == 0){\\n                scorea += piles[start];\\n            }else if(turn == 1){\\n                scoreb += piles[start];\\n            }\\n            if(scorea > scoreb) return true;\\n            return false;\\n        }\\n\\n        if(dp[start][end] != -1) return dp[start][end];\\n\\n        bool check = false;\\n\\n        if(turn == 0){\\n            check = helper(start+1,end,1,piles,scorea+piles[start],scoreb,dp) || helper(start,end-1,1,piles,scorea+piles[end],scoreb,dp);\\n        }else if(turn == 1){\\n            check = helper(start+1,end,0,piles,scorea,scoreb+piles[start],dp) || helper(start,end-1,0,piles,scorea,scoreb+piles[end],dp);\\n        }\\n\\n        return dp[start][end] = check;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, -1));\\n        return helper(0,n-1,0,piles,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool helper(int start, int end, int turn, vector<int> &piles, int scorea, int scoreb, vector<vector<int>> &dp){\\n\\n        if(start == end){\\n            if(turn == 0){\\n                scorea += piles[start];\\n            }else if(turn == 1){\\n                scoreb += piles[start];\\n            }\\n            if(scorea > scoreb) return true;\\n            return false;\\n        }\\n\\n        if(dp[start][end] != -1) return dp[start][end];\\n\\n        bool check = false;\\n\\n        if(turn == 0){\\n            check = helper(start+1,end,1,piles,scorea+piles[start],scoreb,dp) || helper(start,end-1,1,piles,scorea+piles[end],scoreb,dp);\\n        }else if(turn == 1){\\n            check = helper(start+1,end,0,piles,scorea,scoreb+piles[start],dp) || helper(start,end-1,0,piles,scorea,scoreb+piles[end],dp);\\n        }\\n\\n        return dp[start][end] = check;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, -1));\\n        return helper(0,n-1,0,piles,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952643,
                "title": "java-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlice always WINS given the constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849282,
                "title": "100-fast-with-proof",
                "content": "![image](https://assets.leetcode.com/users/images/99cb3dd4-a443-4e8d-be6e-92726e6305cb_1669445820.873135.png)\\n\\nCode Source : -\\nsort(piles.begin(),piles.end());\\n        int x=piles.size();\\n        int sum=0,sum1=0;    \\n        for(int i=x-1; i>=0; i=i-2)\\n        {\\n            sum=sum+piles[i];\\n        }\\n        for(int i=x-2; i>=1; i=i-2)\\n        {\\n            sum1=sum1+piles[i];\\n        }\\n        if(sum>sum1)\\n            return true;\\n        else\\n            return false;\\n\\t\\t\\t\\nIf its help upvote...\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/99cb3dd4-a443-4e8d-be6e-92726e6305cb_1669445820.873135.png)\\n\\nCode Source : -\\nsort(piles.begin(),piles.end());\\n        int x=piles.size();\\n        int sum=0,sum1=0;    \\n        for(int i=x-1; i>=0; i=i-2)\\n        {\\n            sum=sum+piles[i];\\n        }\\n        for(int i=x-2; i>=1; i=i-2)\\n        {\\n            sum1=sum1+piles[i];\\n        }\\n        if(sum>sum1)\\n            return true;\\n        else\\n            return false;\\n\\t\\t\\t\\nIf its help upvote...\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2783421,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<int, int> pii;\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<vector<pii>> dp(n, vector<pii>(n));\\n        for (int left = n - 1; left >= 0; --left) {\\n            for (int right = left; right < n; ++right) {\\n                if (left == right) { \\n                    dp[left][right] = make_pair(piles[left], 0);\\n                    continue;\\n                }\\n                pii pickLeft = dp[left + 1][right];\\n                pii pickRight = dp[left][right - 1];\\n                if (piles[left] + pickLeft.second > piles[right] + pickRight.second) \\n                    dp[left][right] = make_pair(piles[left] + pickLeft.second, pickLeft.first);\\n                else\\n                    dp[left][right] = make_pair(piles[right] + pickRight.second, pickRight.first);\\n            }\\n        }\\n        auto[aliceScore, leeScore] = dp[0][n - 1];\\n        return aliceScore > leeScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int, int> pii;\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<vector<pii>> dp(n, vector<pii>(n));\\n        for (int left = n - 1; left >= 0; --left) {\\n            for (int right = left; right < n; ++right) {\\n                if (left == right) { \\n                    dp[left][right] = make_pair(piles[left], 0);\\n                    continue;\\n                }\\n                pii pickLeft = dp[left + 1][right];\\n                pii pickRight = dp[left][right - 1];\\n                if (piles[left] + pickLeft.second > piles[right] + pickRight.second) \\n                    dp[left][right] = make_pair(piles[left] + pickLeft.second, pickLeft.first);\\n                else\\n                    dp[left][right] = make_pair(piles[right] + pickRight.second, pickRight.first);\\n            }\\n        }\\n        auto[aliceScore, leeScore] = dp[0][n - 1];\\n        return aliceScore > leeScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691615,
                "title": "alice-always-wins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have even number of piles, Alice can pick such that she takes all even indexed piles or all odd indexed piles. And since the sum of all piles is odd, Alice always wins.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583186,
                "title": "stone-game-c-recursion-to-dp-memoisation",
                "content": "**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    // 1->alice , 0->bob\\n    bool solve(vector<int>& piles,int l, int r,int turn){\\n        if(l>r) return 0;\\n\\n        int left = piles[l]+ solve(piles,l+1,r,turn);        \\n        int right = piles[r]+ solve(piles,l,r-1,turn);\\n        int alice=0,bob=0;\\n        turn==1?alice+=max(left,right):bob+=max(left,right);\\n        \\n        return alice>bob?true:false;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return solve(piles,0,piles.size()-1,1);\\n    }\\n};\\n```\\nGives TLE, storing the overlapping cases using memoisation\\n\\n**DP[Memoisation]:**\\n\\n```\\nclass Solution {\\npublic:\\n    // turn: 1->alice , 0->bob \\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int l, int r,int tn){\\n        if(l>r) return 0;\\n        if(dp[l][r][tn]!=-1) return dp[l][r][tn]; // if case has already been encountered\\n\\n        int alice=0,bob=0;\\n        int left,right;\\n        if(tn==1){\\n            left = piles[l]+ solve(piles,l+1,r,0);        \\n            right = piles[r]+ solve(piles,l,r-1,0);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for alice\\n        }\\n        else{\\n            left = piles[l]+ solve(piles,l+1,r,1);        \\n            right = piles[r]+ solve(piles,l,r-1,1);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for bob\\n        }\\n        \\n        return 0;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(piles,0,piles.size()-1,1);\\n\\t        \\n        int sum=0;\\n        for(auto i : piles){\\n            sum+=i;\\n        }\\n        \\n        if(sum-2*solve(piles,0,piles.size()-1,1)<0) return true;\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1->alice , 0->bob\\n    bool solve(vector<int>& piles,int l, int r,int turn){\\n        if(l>r) return 0;\\n\\n        int left = piles[l]+ solve(piles,l+1,r,turn);        \\n        int right = piles[r]+ solve(piles,l,r-1,turn);\\n        int alice=0,bob=0;\\n        turn==1?alice+=max(left,right):bob+=max(left,right);\\n        \\n        return alice>bob?true:false;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return solve(piles,0,piles.size()-1,1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // turn: 1->alice , 0->bob \\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int l, int r,int tn){\\n        if(l>r) return 0;\\n        if(dp[l][r][tn]!=-1) return dp[l][r][tn]; // if case has already been encountered\\n\\n        int alice=0,bob=0;\\n        int left,right;\\n        if(tn==1){\\n            left = piles[l]+ solve(piles,l+1,r,0);        \\n            right = piles[r]+ solve(piles,l,r-1,0);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for alice\\n        }\\n        else{\\n            left = piles[l]+ solve(piles,l+1,r,1);        \\n            right = piles[r]+ solve(piles,l,r-1,1);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for bob\\n        }\\n        \\n        return 0;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(piles,0,piles.size()-1,1);\\n\\t        \\n        int sum=0;\\n        for(auto i : piles){\\n            sum+=i;\\n        }\\n        \\n        if(sum-2*solve(piles,0,piles.size()-1,1)<0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409754,
                "title": "just-return-true",
                "content": "Whoever starts first, would win this gme.\\nAs, Alice starts first, she wins everytime and hence we return true.\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322020,
                "title": "very-easy-c-solution-only-just-return-true-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276961,
                "title": "easiest-solution-just-return-true",
                "content": "```\\n\\n//Just return true;\\n//\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n//Just return true;\\n//\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170816,
                "title": "java-intuitive-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean stoneGame(int[] piles) {\\n       // Calculate total sum. \\n       int totalSum = Arrays.stream(piles).sum();\\n       int[][] dp = new int[piles.length][piles.length];\\n       for (int[] arr: dp) {\\n           Arrays.fill(arr, -1);\\n       } \\n       // We will try to maximize Alice Sum. \\n       int sum = stoneGame(0, piles.length - 1, piles, dp);\\n       // Subtract Alice Maximized Sum from total Sum to get Bob\\'s Sum and determine the result appropriately.\\n       return sum > (totalSum - sum) ? true : false;\\n    }\\n    \\n    public int stoneGame(int i, int j, int[] piles, int[][] dp) {\\n       int sum = 0;\\n       if (i < j) {\\n          if (dp[i][j] != -1) {\\n              return dp[i][j];\\n          }\\n          // If Alice chooses i, Bob can choose i + 1 or j.\\n          // If Bob chooses i + 1, In the next round Alice can choose i + 2 or j.\\n          // If Bob chooses j, In the next round  Alice can choose i + 1  or j -1.\\n          int sum1 =  piles[i] + Math.max(stoneGame(i + 2, j, piles, dp),stoneGame(i + 1, j - 1, piles, dp));\\n          // If Alice chooses j, Bob can choose i or j - 1.\\n          // If Bob chooses i, In the next round Alice can choose i + 1 or j - 1.\\n          // If Bob chooses j - 1, In the next round  Alice can choose i  or j -2. \\n          int sum2 =  piles[j] + Math.max(stoneGame(i, j - 2, piles, dp),stoneGame(i + 1, j - 1, piles, dp)) ;\\n          sum =  Math.max(sum1, sum2);\\n          dp[i][j] = sum; \\n       }\\n       return sum; \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean stoneGame(int[] piles) {\\n       // Calculate total sum. \\n       int totalSum = Arrays.stream(piles).sum();\\n       int[][] dp = new int[piles.length][piles.length];\\n       for (int[] arr: dp) {\\n           Arrays.fill(arr, -1);\\n       } \\n       // We will try to maximize Alice Sum. \\n       int sum = stoneGame(0, piles.length - 1, piles, dp);\\n       // Subtract Alice Maximized Sum from total Sum to get Bob\\'s Sum and determine the result appropriately.\\n       return sum > (totalSum - sum) ? true : false;\\n    }\\n    \\n    public int stoneGame(int i, int j, int[] piles, int[][] dp) {\\n       int sum = 0;\\n       if (i < j) {\\n          if (dp[i][j] != -1) {\\n              return dp[i][j];\\n          }\\n          // If Alice chooses i, Bob can choose i + 1 or j.\\n          // If Bob chooses i + 1, In the next round Alice can choose i + 2 or j.\\n          // If Bob chooses j, In the next round  Alice can choose i + 1  or j -1.\\n          int sum1 =  piles[i] + Math.max(stoneGame(i + 2, j, piles, dp),stoneGame(i + 1, j - 1, piles, dp));\\n          // If Alice chooses j, Bob can choose i or j - 1.\\n          // If Bob chooses i, In the next round Alice can choose i + 1 or j - 1.\\n          // If Bob chooses j - 1, In the next round  Alice can choose i  or j -2. \\n          int sum2 =  piles[j] + Math.max(stoneGame(i, j - 2, piles, dp),stoneGame(i + 1, j - 1, piles, dp)) ;\\n          sum =  Math.max(sum1, sum2);\\n          dp[i][j] = sum; \\n       }\\n       return sum; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986337,
                "title": "dp-recursive-c-explained-in-detail-with-commments",
                "content": "O(1) : return true. alice always wins\\nalice either picks only from even no oile, or odd no pile.\\nand for sure total stones in either even pile or odd pile  is greater than other bec total stones are odd.\\n\\nbut if total stones were not odd then what?\\nhence u should know how to do it with do also in generalised way.\\n\\n```\\nclass Solution {\\n    vector<int> piles;\\n   int  dp[501][501];\\n    \\npublic:\\n    bool stoneGame(vector<int>& p) {\\n        memset(dp,-1 , sizeof(dp));\\n        piles= p;\\n     int sum=0;\\n        for(auto x: piles)\\n            sum+=x;\\n        int alice = dfs(0, piles.size()-1);\\n        int bob = sum- alice;\\n        if( alice > bob)\\n            return true;\\n        else \\n            return false;\\n        \\n    }\\n    int dfs(int  l ,int r) // return the max that alcie can pick from array l,r\\n    {\\n        if( l > r) // array finished alice cant get anything from here\\n            return 0;\\n        if(dp[l][r] != -1)\\n            return dp[l][r] ;\\n        // given only even piles to start from\\n        // ots alice turn if no of piles are even\\n        int count = r-l+1;\\n        int turn =false;\\n        int left=0, right=0;\\n        if( count % 2 ==0)// alice turn\\n        {\\n            // pick from left\\n            left = piles[l] + dfs(l+1, r);\\n            right = piles[r] + dfs(l,r-1);\\n            return dp[l][r]= max(left, right); // return the best alice gets from l,r array\\n        }\\n        else // its bob turn. this chance wont contribute anything to  alice total picks\\n        {\\n            left=0 + dfs(l+1, r); // bob picks the leftmost. this chance contributed nothing to alice picks hence adding 0\\n            right = 0 + dfs(l, r-1); // bob picks the rightmost\\n            return dp[l][r]= min(left, right); // bob is playing hence he will do best that alice can pick as less stones as possible\\n            // note: used min func there\\n                        \\n        }\\n        return 0; // just for sake of returning \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<int> piles;\\n   int  dp[501][501];\\n    \\npublic:\\n    bool stoneGame(vector<int>& p) {\\n        memset(dp,-1 , sizeof(dp));\\n        piles= p;\\n     int sum=0;\\n        for(auto x: piles)\\n            sum+=x;\\n        int alice = dfs(0, piles.size()-1);\\n        int bob = sum- alice;\\n        if( alice > bob)\\n            return true;\\n        else \\n            return false;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1956577,
                "title": "just-return-true",
                "content": "```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840662,
                "title": "runtime-3ms-intuitive-solution-easy-to-understand",
                "content": "The solution is simple, it is adding maximum piles from any side. \\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int i=0,j=piles.size()-1;\\n        long long int alice=0,bobs=0;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                alice+=piles[i];\\n                bobs+=piles[j];\\n            }\\n            else{\\n                bobs+=piles[i];\\n                alice+=piles[j];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return alice>bobs;\\n    }\\n};\\n```\\n\\n**Upvote it, if you like the solution.**\\nIf you dislike the solution than please let me know the reason in comment section.",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int i=0,j=piles.size()-1;\\n        long long int alice=0,bobs=0;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                alice+=piles[i];\\n                bobs+=piles[j];\\n            }\\n            else{\\n                bobs+=piles[i];\\n                alice+=piles[j];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return alice>bobs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801625,
                "title": "c-very-easy-recursive-memoization",
                "content": "\\tint dp[501][501];\\t\\n    int solve(vector<int> &arr,int i,int j){\\n        if(i>j) return 0;\\n        if(i==j){\\n            return dp[i][j]=arr[i];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=max(solve(arr,i+1,j)+arr[i],solve(arr,i,j-1)+arr[j]);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int sum=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<piles.size();i++) sum+=piles[i];\\n        int a=solve(piles,0,piles.size()-1);\\n        int b=sum-a;\\n        return a>b;\\n        \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\tint dp[501][501];\\t\\n    int solve(vector<int> &arr,int i,int j){\\n        if(i>j) return 0;\\n        if(i==j){\\n            return dp[i][j]=arr[i];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=max(solve(arr,i+1,j)+arr[i],solve(arr,i,j-1)+arr[j]);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int sum=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<piles.size();i++) sum+=piles[i];\\n        int a=solve(piles,0,piles.size()-1);\\n        int b=sum-a;\\n        return a>b;\\n        \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1783310,
                "title": "100-faster-alice-always-wins-but-why-full-explanation-and-solution",
                "content": "We need to carefully assess the given conditions.\\n\\n**1)** **Even number of piles:** That means, each player will get equal number of piles. So basically, **the number of turns = the number of piles**.\\n**2)** **Total stones are odd:** The total stones in all the piles combined will always be odd. What does that signify? If you carefully observe, this means that a tie can never happen, since the distribution of stones cannot be evenly done. One will always have more stones than the other person.\\n\\n**What does the question ask us to do?**\\nThe question says, whether there exists a way in which alice wins. In easier words, out of all the possible combinations in which the game can be played, if there is even one possibility, where alice can win, then we need to return true.\\n\\nThere might be many possibilities of a single game, and in those possibilities, there can be many of the possibilities where alice wins. But  **what is the most optimal way in which we can push the game towards the direction where alice wins?**\\n\\nThis can happen in the case where, when it\\'s alice\\'s turn, she chooses the pile with maximum number of stones and when it\\'s bob\\'s turn, he chooses the index with the minimum number of stones. This way of playing can happen in every game. So now what can happen? Either both the people end up with same number of stones, or alice gets more stones since she always chose the maximum stones pile and bob chose the minimum stones pile.\\n\\nNow here comes the role of odd number of total stones. Since the total stones are odd, alice and bob can\\'t have equal number of stones. This leaves us with only one possibility:  **ALICE ALWAYS WINS!**\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        bool status = true;\\n        int i=0, j=n-1, alice=0, bob=0; // Keep two pointers, one at the start and one at the end\\n        while(n)\\n        {\\n            if(status)\\n            {\\n                status = false;\\n                if(piles[i]>piles[j])\\n                {\\n                    alice = alice + piles[i];\\n                    i++; // If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    alice = alice + piles[j];\\n                    j--; // If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            else\\n            {\\n                status = true;\\n                if(piles[i]<piles[j])\\n                {\\n                    bob = bob + piles[i];\\n                    i++;// If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    bob = bob + piles[j];\\n                    j--;// If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            n--;\\n        }\\n        if(alice>bob)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nSince we already know that Alice always wins, we can also **return true**, and the code works!\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n   }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        bool status = true;\\n        int i=0, j=n-1, alice=0, bob=0; // Keep two pointers, one at the start and one at the end\\n        while(n)\\n        {\\n            if(status)\\n            {\\n                status = false;\\n                if(piles[i]>piles[j])\\n                {\\n                    alice = alice + piles[i];\\n                    i++; // If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    alice = alice + piles[j];\\n                    j--; // If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            else\\n            {\\n                status = true;\\n                if(piles[i]<piles[j])\\n                {\\n                    bob = bob + piles[i];\\n                    i++;// If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    bob = bob + piles[j];\\n                    j--;// If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            n--;\\n        }\\n        if(alice>bob)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708830,
                "title": "c-o-n-time-complexity-o-1-space-greedy-faster-than-100",
                "content": "The approach is simple . As Alice will always have the chance to choose the best one out because she will be the first one to start the game , therefore she will always win the game in every condition . So , you can direct return true if you want :-\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        return true ; \\n    }\\n};\\n```\\nNow if we talk about the approach , then we just need to compare the summation of the stones at even and odd indexes . \\nIf the summation of stones at even indexes is greater , then Alice will always pick the stones from even index after which Bob will only have the option to choose the best one out of both the left and right remaining odd indexes and vice versa . Hence , Alice wins everytime !\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        if(n == 2) return true ; \\n        \\n        int even = 0 ; \\n        int odd = 0 ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                even += piles[i] ; \\n            }\\n            else odd += piles[i] ; \\n        }\\n        int l = 0 ; \\n        int r = n-1 ; \\n        int s1 = 0 ; \\n        int s2 = 0 ; \\n        int turn = 0 ; \\n        if(even > odd)\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 == 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n        else\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 != 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        return true ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        if(n == 2) return true ; \\n        \\n        int even = 0 ; \\n        int odd = 0 ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                even += piles[i] ; \\n            }\\n            else odd += piles[i] ; \\n        }\\n        int l = 0 ; \\n        int r = n-1 ; \\n        int s1 = 0 ; \\n        int s2 = 0 ; \\n        int turn = 0 ; \\n        if(even > odd)\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 == 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n        else\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 != 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601337,
                "title": "one-line-code-simple-logic-question-based-answer-no-dpp-no-recursion",
                "content": "```\\n TRY TO UNDERSTAND THIS PART OF LINE AND THINK IN A DIFFERENT WAY :: AT THE FIRST I THOUGHT WE NEED TO DO SO MUCH STUFF BUT WHEN I READ THE QUESTION CAREFULLY \\n AND TRIED TO UNDERSTAND THIS THEY SAID THEY ARE PLAYING OPTIMALLY THAT MEANS !\\n\\n ALEX IS TRYING HIS BEST TO WIN HIS GAME AND SIMILARY BOB IS ALSO TRYING HIS BEST TO WIN THIS GAME SO WE CAN SAY EASILY EVERY TIME ALEX TRIES HIS BEST TO WIN THIS GAME \\n \\n AND I THINK MY APPROACH IS DIFFERENT FROM OTHERS FROM OTHER CODERS BUT AS OURSELVES TRY TO THINK THAT WHEN WE PLAY GAME WHY WE WILL CHOOSE WRONG STEP TO  LOOSE OURSELVES SO THINK DIFFERENT BE THE ONE \\n \\n THIS SIDE MOHIT\\n Happy Coding !!!\\n \\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n TRY TO UNDERSTAND THIS PART OF LINE AND THINK IN A DIFFERENT WAY :: AT THE FIRST I THOUGHT WE NEED TO DO SO MUCH STUFF BUT WHEN I READ THE QUESTION CAREFULLY \\n AND TRIED TO UNDERSTAND THIS THEY SAID THEY ARE PLAYING OPTIMALLY THAT MEANS !\\n\\n ALEX IS TRYING HIS BEST TO WIN HIS GAME AND SIMILARY BOB IS ALSO TRYING HIS BEST TO WIN THIS GAME SO WE CAN SAY EASILY EVERY TIME ALEX TRIES HIS BEST TO WIN THIS GAME \\n \\n AND I THINK MY APPROACH IS DIFFERENT FROM OTHERS FROM OTHER CODERS BUT AS OURSELVES TRY TO THINK THAT WHEN WE PLAY GAME WHY WE WILL CHOOSE WRONG STEP TO  LOOSE OURSELVES SO THINK DIFFERENT BE THE ONE \\n \\n THIS SIDE MOHIT\\n Happy Coding !!!\\n \\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543215,
                "title": "c-very-easy-approach-using-memoization",
                "content": "```\\nclass Solution {\\n    int dp[501][501];\\n    int game(int i,int j,vector<int> &piles){\\n        if(i+1==j) return max(piles[i],piles[j]);\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int choosefromfirst = piles[i] + min(game(i+1,j-1,piles),game(i+2,j,piles));\\n        int choosefromlast = piles[j] + min(game(i+1,j-1,piles),game(i,j-2,piles));\\n        return dp[i][j] = max(choosefromfirst,choosefromlast);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int totalsum = accumulate(piles.begin(),piles.end(),0);\\n        int aliceres = game(0,piles.size()-1,piles);\\n        return (totalsum-aliceres < aliceres);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int dp[501][501];\\n    int game(int i,int j,vector<int> &piles){\\n        if(i+1==j) return max(piles[i],piles[j]);\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int choosefromfirst = piles[i] + min(game(i+1,j-1,piles),game(i+2,j,piles));\\n        int choosefromlast = piles[j] + min(game(i+1,j-1,piles),game(i,j-2,piles));\\n        return dp[i][j] = max(choosefromfirst,choosefromlast);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1484895,
                "title": "explaining-my-dp-approach-c-32-ms",
                "content": "In this problem we not only have to think about maximizing our score, but we should in a way also think about somehow minimzing the opponent\\'s score. At the end of the game, I do not want to end up maximizing my score, but my primary goal is just to have a score greater than my opponent that\\'s it.\\n\\nSo as mentioned I could pick up from the begining or the end. \\n\\nThe most fundamental subproblem that we could think of is ranges or segment of arrays.  It is because the problem kind of gives us a sense that we are wanting to shorten our range each time.\\n\\nSo why not build up  upon a solution, based on the lenght of ranges. \\n\\nLet dp(i) (j) represent Alice\\'s total score at the end of the game, if we were given the array [i....j] and not the entire array.\\n\\nSo dp(i)(i) ---> would represent the answer for all 1 length subarrays, \\n\\ndp(i) (i) , for all i E [0,n-1] = piles[i] \\nbecause if we only had one element so Alice would have picked it.\\n\\ndp(i) (i+1), for all i E [ 0, n-2] = max(piles[i], piles[i+1] )\\n\\nbecause if we only had two elements ,Alice would have picked the maximum out of the two.\\n\\n\\t\\nLet\\'s say Alice is doing a critical choice --> he has two choices,  pick the element at the beginging from the range that is availabe to him, or pick the element at the end.\\n\\nNow, his opponent also might have gone through this critical choice isn\\'t it.\\n\\nThough we are considering the fact Alice starts the game, but then in the middle of any general kth turn ,where k>=1,\\nk here represents the number of times Alice has picked up an element till now. \\nStill, we can say Alice would get a chance after Bob has picked up, because it\\'s a cyclic turnwise game that\\'s happening.\\n\\nWhen Bob was doing his picking he might have thought two things, I should give Alice a decision segment from where Alice should somehow be able to form minimum total sum, and then also I should pick a number that benefits me also.\\n\\nSo via. all the above talking we can write a dp equation like-->\\n\\nif Alice is choosing piles(i) for this current turn, then Bob might have given him min (dp(i+1 ) ( j-1 ) , dp (i+2 ) (j ) );\\nif Alice is choosing piles (j) for this current turn, then Bob might have given him min( dp(i+1) (j-1), dp(i) (j-2) );\\n\\ncase 1= piles (i )  + min( dp(i+1) (j-1) , dp(i+2 ) (j) )\\n\\ncase 2 = piles (j )  + min ( dp(i+1 ) (j-1) , dp(i) (j-2) );\\n\\nthus dp (i ) (j) = max ( case 1 , case 2);\\n\\nAnswer = dp(0) (n-1);\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        \\n        int n=piles.size();\\n        \\n        int dp[n][n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=piles[i];\\n        }\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            dp[i][i+1]= max(piles[i],piles[i+1]);\\n        }\\n        \\n        for(int len=3;len<=n;len++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                int j= len + i -1;\\n                \\n                if(i>=j || j>=n || i>=n) continue;\\n                \\n                int op1= piles[i] + min({ dp[i+1][j-1], dp[i+2][j]});\\n                \\n                int op2= piles[j] + min({dp[i+1][j-1], dp[i][j-2]});\\n                \\n                dp[i][j]= max(op1,op2);\\n                \\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++) sum+=piles[i];\\n        \\n        int alice_score= dp[0][n-1];\\n        \\n        int bob_score= sum- alice_score;\\n        \\n        // cout<<alice_score;\\n        \\n        \\n        return alice_score>=bob_score;\\n       \\n        \\n      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        \\n        int n=piles.size();\\n        \\n        int dp[n][n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=piles[i];\\n        }\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            dp[i][i+1]= max(piles[i],piles[i+1]);\\n        }\\n        \\n        for(int len=3;len<=n;len++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                int j= len + i -1;\\n                \\n                if(i>=j || j>=n || i>=n) continue;\\n                \\n                int op1= piles[i] + min({ dp[i+1][j-1], dp[i+2][j]});\\n                \\n                int op2= piles[j] + min({dp[i+1][j-1], dp[i][j-2]});\\n                \\n                dp[i][j]= max(op1,op2);\\n                \\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++) sum+=piles[i];\\n        \\n        int alice_score= dp[0][n-1];\\n        \\n        int bob_score= sum- alice_score;\\n        \\n        // cout<<alice_score;\\n        \\n        \\n        return alice_score>=bob_score;\\n       \\n        \\n      \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1386181,
                "title": "stone-game-solution-java",
                "content": "```\\npublic boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int sumAlex=0;\\n        int sumLee = 0;\\n        Arrays.sort(piles);\\n        for(int i=0;i<n;i++){     \\n            if(i%2==0){\\n                sumLee += piles[i];\\n            } \\n            else{\\n                sumAlex += piles[i];\\n            }\\n            \\n        }\\n        if(sumAlex>sumLee){\\n            return true;\\n        }\\n        else{\\n         return false;   \\n        }\\n        \\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int sumAlex=0;\\n        int sumLee = 0;\\n        Arrays.sort(piles);\\n        for(int i=0;i<n;i++){     \\n            if(i%2==0){\\n                sumLee += piles[i];\\n            } \\n            else{\\n                sumAlex += piles[i];\\n            }\\n            \\n        }\\n        if(sumAlex>sumLee){\\n            return true;\\n        }\\n        else{\\n         return false;   \\n        }\\n        \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385464,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &piles, int left, int right, vector<vector<int>> &dp) {\\n        if(left >= right) {\\n            return 0;\\n        }\\n        \\n        if(dp[left][right] != -1) return dp[left][right]; \\n        \\n        // if alex chose left\\n        // than lee can choose either left + 1 or right\\n        // so Alex next can either be from left+2 or right-1 (we are taking min because both players are playing optimally so ofcourse lee is going to choose the max one and we are going to get the min one);\\n        int choose_left = piles[left] + min(helper(piles, left+2, right, dp), helper(piles, left, right-1, dp));\\n        \\n        // if alex choose right\\n        // than lee can choose left or right-1\\n        // so Alez next can start from left + 1 or right-2 (taking min same reason as above) \\n        int choose_right = piles[right] + min(helper(piles, left, right-2, dp), helper(piles, left+1, right, dp));\\n            \\n        // we have to get max we can get by wither choosing left or right\\n        return dp[left][right] = max(choose_left, choose_right);\\n    }\\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        return helper(piles, 0, n - 1, dp) > sum/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &piles, int left, int right, vector<vector<int>> &dp) {\\n        if(left >= right) {\\n            return 0;\\n        }\\n        \\n        if(dp[left][right] != -1) return dp[left][right]; \\n        \\n        // if alex chose left\\n        // than lee can choose either left + 1 or right\\n        // so Alex next can either be from left+2 or right-1 (we are taking min because both players are playing optimally so ofcourse lee is going to choose the max one and we are going to get the min one);\\n        int choose_left = piles[left] + min(helper(piles, left+2, right, dp), helper(piles, left, right-1, dp));\\n        \\n        // if alex choose right\\n        // than lee can choose left or right-1\\n        // so Alez next can start from left + 1 or right-2 (taking min same reason as above) \\n        int choose_right = piles[right] + min(helper(piles, left, right-2, dp), helper(piles, left+1, right, dp));\\n            \\n        // we have to get max we can get by wither choosing left or right\\n        return dp[left][right] = max(choose_left, choose_right);\\n    }\\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        return helper(piles, 0, n - 1, dp) > sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385158,
                "title": "java-solution",
                "content": "Alice will always win the game as they are playing optimally to  win the game, so, there is no chance that Lee can win the game, so we can simply return true, other solution can be we can solve it using dp, dp solution is posted in stone VII problem\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385137,
                "title": "java-easy-dp-tabulation-gap-strategy",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n         int n = piles.length;\\n         int dp[][] = new int[n][n];\\n         for(int g = 0 ; g < n;g++){\\n           for(int i = 0,j = g;j < n ;i++,j ++){\\n             if(g == 0){\\n               dp[i][j] = piles[i];\\n             }\\n             else if(g == 1){\\n               dp[i][j] = Math.max(piles[i],piles[j]);\\n             }\\n             else{\\n               int val1 = piles[i] + Math.min(dp[i + 2][j],dp[i + 1][j - 1]);\\n               int val2 = piles[j] + Math.min(dp[i + 1][j - 1],dp[i][j - 2]);\\n               dp[i][j] = Math.max(val1,val2);\\n             }\\n           }\\n         }\\n      int Asum = 0;\\n      for(int val : piles){\\n        Asum += val;\\n      }\\n      int Alex = dp[0][n - 1];\\n      int Lee = Asum - Alex;\\n      if(Alex  > Lee) return true;\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n         int n = piles.length;\\n         int dp[][] = new int[n][n];\\n         for(int g = 0 ; g < n;g++){\\n           for(int i = 0,j = g;j < n ;i++,j ++){\\n             if(g == 0){\\n               dp[i][j] = piles[i];\\n             }\\n             else if(g == 1){\\n               dp[i][j] = Math.max(piles[i],piles[j]);\\n             }\\n             else{\\n               int val1 = piles[i] + Math.min(dp[i + 2][j],dp[i + 1][j - 1]);\\n               int val2 = piles[j] + Math.min(dp[i + 1][j - 1],dp[i][j - 2]);\\n               dp[i][j] = Math.max(val1,val2);\\n             }\\n           }\\n         }\\n      int Asum = 0;\\n      for(int val : piles){\\n        Asum += val;\\n      }\\n      int Alex = dp[0][n - 1];\\n      int Lee = Asum - Alex;\\n      if(Alex  > Lee) return true;\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384502,
                "title": "c-explained-solution",
                "content": "The sum of the piles in the odd indices can never be equal to the sum of the even indices, because the total number of stones is odd, so there are no ties.\\nSo Alex can choose to take all the piles in the even indices or all the piles in the odd indices, therefore he always can win.\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279947,
                "title": "c-solution-with-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& p,int i,int n,int f,vector<vector<int>> &dp)\\n    {\\n        if(i>n)\\n            return(0);\\n        if(dp[i][n]!=-1)\\n            return(dp[i][n]);\\n        if(f==0)\\n        return(dp[i][n]=max(p[i]+check(p,i+1,n,1,dp),p[n]+check(p,i,n-1,1,dp)));\\n     return(dp[i][n]=max(check(p,i+1,n,0,dp),check(p,i,n-1,0,dp)));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int s=check(piles,0,n-1,0,dp);\\n        return(accumulate(piles.begin(),piles.end(),0)-s<s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& p,int i,int n,int f,vector<vector<int>> &dp)\\n    {\\n        if(i>n)\\n            return(0);\\n        if(dp[i][n]!=-1)\\n            return(dp[i][n]);\\n        if(f==0)\\n        return(dp[i][n]=max(p[i]+check(p,i+1,n,1,dp),p[n]+check(p,i,n-1,1,dp)));\\n     return(dp[i][n]=max(check(p,i+1,n,0,dp),check(p,i,n-1,0,dp)));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int s=check(piles,0,n-1,0,dp);\\n        return(accumulate(piles.begin(),piles.end(),0)-s<s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266484,
                "title": "stone-game-simple-2-pointer-approach-solution",
                "content": "/*class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int a = 0 ;\\n        int f = 0 , l = n - 1;\\n        while(f <= l){\\n            if(f <= l && piles[f] >= piles[l]){\\n                a += piles[f];\\n                f++;\\n                if(f <=l && piles[f] >= piles[l]){\\n                    l--;\\n                }\\n                else f++;\\n            }\\n            else{\\n                a += piles[l];\\n                l--;\\n                if(f <=l && piles[f] >= piles[l]){\\n                    l--;\\n                }\\n                else f++;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i : piles){\\n            sum += i;\\n        }\\n        if(a > sum - a) return true;\\n        else return false;\\n    }\\n};*/",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int a = 0 ;\\n        int f = 0 , l = n - 1;\\n        while(f <= l){\\n            if(f <= l && piles[f] >= piles[l]){\\n                a += piles[f];\\n                f++;\\n                if(f <=l && piles[f] >= piles[l]){\\n                    l--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1266200,
                "title": "java-100-faster-easy-2-pointer-solution-for-stone-game",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        \\n        int i=0, j=piles.length-1; // two pointers\\n        int turnofalex = 1, turnoflee = 0;\\n        int sumx=0, sumy=0; // sumx is Alex\\'s score, sumy is lee\\'s score\\n        \\n        while(i<j)\\n        {\\n            if(turnofalex==1) // alex\\'s turn, score should be max\\n            {\\n                if((piles[i]+piles[j-1]) >= (piles[i+1]+piles[j])) \\n                {\\n                    sumx = sumx+piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 0;\\n                    turnoflee = 1;\\n                }       \\n                else\\n                {\\n                    sumx = sumx+piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 0;\\n                    turnoflee = 1;                    \\n                }\\n            }\\n            else // lee\\'s turn, score should be min\\n            {\\n                if((piles[i]+piles[j-1]) < (piles[i+1]+piles[j])) \\n                {\\n                    sumy+=piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }       \\n                else\\n                {\\n                    sumy+=piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }\\n            }\\n            if(i==j)\\n                break;\\n        }\\n        \\n        if(sumx>sumy)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        \\n        int i=0, j=piles.length-1; // two pointers\\n        int turnofalex = 1, turnoflee = 0;\\n        int sumx=0, sumy=0; // sumx is Alex\\'s score, sumy is lee\\'s score\\n        \\n        while(i<j)\\n        {\\n            if(turnofalex==1) // alex\\'s turn, score should be max\\n            {\\n                if((piles[i]+piles[j-1]) >= (piles[i+1]+piles[j])) \\n                {\\n                    sumx = sumx+piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 0;\\n                    turnoflee = 1;\\n                }       \\n                else\\n                {\\n                    sumx = sumx+piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 0;\\n                    turnoflee = 1;                    \\n                }\\n            }\\n            else // lee\\'s turn, score should be min\\n            {\\n                if((piles[i]+piles[j-1]) < (piles[i+1]+piles[j])) \\n                {\\n                    sumy+=piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }       \\n                else\\n                {\\n                    sumy+=piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }\\n            }\\n            if(i==j)\\n                break;\\n        }\\n        \\n        if(sumx>sumy)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259023,
                "title": "my-simple-c-solution-faster-than-100-simple-greedy-soln-works-here",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int alex=0;\\n        int lee=0;\\n        int i=0,j=piles.size()-1;\\n        while(i<j)\\n        {\\n            int x=piles[i];\\n            int y=piles[j];\\n            if(x>=y)\\n            {\\n                alex+=x;  \\n                lee+=y;\\n            }\\n            else\\n            {\\n                alex+=y;\\n                lee+=x;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(alex>lee) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int alex=0;\\n        int lee=0;\\n        int i=0,j=piles.size()-1;\\n        while(i<j)\\n        {\\n            int x=piles[i];\\n            int y=piles[j];\\n            if(x>=y)\\n            {\\n                alex+=x;  \\n                lee+=y;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1255018,
                "title": "c-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dpAlex(n, vector<int>(n, 0));\\n        vector<vector<int>> dpLee(n, vector<int>(n, 0));\\n        \\n        \\n        dpAlex[n-1][n-1] = piles[n-1];\\n        dpLee[n-1][n-1] = -piles[n-1];\\n        \\n        dpAlex[0][0] = piles[0];\\n        \\n        dpLee[0][0] = -piles[0];\\n        //B to T\\n        //L to R\\n        //only the upper triangular matrix\\n        \\n        for(int i = n-2; i>=0;i--){\\n            for(int j =i; j<n ; j++){\\n                if(i == 0 && j == 0){\\n                    continue;\\n                }\\n                dpAlex[i][j] = max(piles[i] + dpLee[i+1][j], piles[j] + dpLee[i][j-1]);\\n                dpLee[i][j] = min(-piles[i] + dpAlex[i+1][j], -piles[j] + dpAlex[i][j-1]);\\n            }\\n        }\\n        return dpAlex[0][n-1] > 0? true: false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dpAlex(n, vector<int>(n, 0));\\n        vector<vector<int>> dpLee(n, vector<int>(n, 0));\\n        \\n        \\n        dpAlex[n-1][n-1] = piles[n-1];\\n        dpLee[n-1][n-1] = -piles[n-1];\\n        \\n        dpAlex[0][0] = piles[0];\\n        \\n        dpLee[0][0] = -piles[0];\\n        //B to T\\n        //L to R\\n        //only the upper triangular matrix\\n        \\n        for(int i = n-2; i>=0;i--){\\n            for(int j =i; j<n ; j++){\\n                if(i == 0 && j == 0){\\n                    continue;\\n                }\\n                dpAlex[i][j] = max(piles[i] + dpLee[i+1][j], piles[j] + dpLee[i][j-1]);\\n                dpLee[i][j] = min(-piles[i] + dpAlex[i+1][j], -piles[j] + dpAlex[i][j-1]);\\n            }\\n        }\\n        return dpAlex[0][n-1] > 0? true: false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253004,
                "title": "1-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;\\n    }\\n};\\n```\\n\\nALEX ALWAYS WINS\\n\\nSince the total sum is odd it means either the sum of all odd elements is greater than even elements or vice versa.\\nAlex can always select in a way that ensures he get all alternating piles\\nIf he starts from the 1st pile he can get all piles at odd place.\\nIf he starts from the last pile he can get all piles at even places\\n\\nSo depending on which is more he will start from beginning or end and win.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208279,
                "title": "stone-game-recurstion-python",
                "content": "#### Python solution  using recursion \\n\\n            \\n            def abhi(s,e):\\n\\t\\t\\t\\tif s==e:\\n\\t\\t\\t\\t\\treturn piles[s]\\n\\t\\t\\t\\telif e==s+1:\\n\\t\\t\\t\\t\\treturn max(piles[s],piles[e])\\n            \\n\\t\\t\\t\\telif dp[s][e]!= -1:\\n\\t\\t\\t\\t\\treturn dp[s][e]\\n            \\n\\t\\t\\t\\tdp[s][e] =max( piles[s]+min(  abhi(s+2,e), abhi(s+1,e-1)) , piles[e]+min(abhi(s+1,e-1), abhi(s,e-2))   )\\n            \\n\\t\\t\\t\\treturn dp[s][e]\\n        \\n        dp=[ [-1 for i in range(len(piles)+1) ]  for j in range(len(piles)+1)] \\n        a= abhi(0,len(piles)-1)\\n        b=sum(piles)\\n        \\n        return a>a-b\\n\\t\\t\\n\\t\\thowever if both player are playing optimally you can just return True becaus alice will always win if they do the best so whoever starts the game will win.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "#### Python solution  using recursion \\n\\n            \\n            def abhi(s,e):\\n\\t\\t\\t\\tif s==e:\\n\\t\\t\\t\\t\\treturn piles[s]\\n\\t\\t\\t\\telif e==s+1:\\n\\t\\t\\t\\t\\treturn max(piles[s],piles[e])\\n            \\n\\t\\t\\t\\telif dp[s][e]!= -1:\\n\\t\\t\\t\\t\\treturn dp[s][e]\\n            \\n\\t\\t\\t\\tdp[s][e] =max( piles[s]+min(  abhi(s+2,e), abhi(s+1,e-1)) , piles[e]+min(abhi(s+1,e-1), abhi(s,e-2))   )\\n            \\n\\t\\t\\t\\treturn dp[s][e]\\n        \\n        dp=[ [-1 for i in range(len(piles)+1) ]  for j in range(len(piles)+1)] \\n        a= abhi(0,len(piles)-1)\\n        b=sum(piles)\\n        \\n        return a>a-b\\n\\t\\t\\n\\t\\thowever if both player are playing optimally you can just return True becaus alice will always win if they do the best so whoever starts the game will win.",
                "codeTag": "Python3"
            },
            {
                "id": 1196323,
                "title": "c-dp-memozized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recurs(vector<int>& arr,int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[start][end]!=0)\\n        {\\n            return dp[start][end];\\n        }\\n        \\nreturn dp[start][end]=max(max(arr[start]+recurs(arr,start+2,end),arr[start]+recurs(arr,start+1,end-1)),max(arr[end]+recurs(arr,start,end-2),arr[end]+recurs(arr,start+1,end-1)));\\n        \\n        \\n    }\\n        \\n        \\n    \\n    \\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n    int sum=0;\\n    \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=piles[i];\\n        }\\n        \\n        int k=recurs(piles,0,piles.size()-1);\\n        cout<<k;\\n        if(sum-k<k)\\n        {\\n            return 1;\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recurs(vector<int>& arr,int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[start][end]!=0)\\n        {\\n            return dp[start][end];\\n        }\\n        \\nreturn dp[start][end]=max(max(arr[start]+recurs(arr,start+2,end),arr[start]+recurs(arr,start+1,end-1)),max(arr[end]+recurs(arr,start,end-2),arr[end]+recurs(arr,start+1,end-1)));\\n        \\n        \\n    }\\n        \\n        \\n    \\n    \\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n    int sum=0;\\n    \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=piles[i];\\n        }\\n        \\n        int k=recurs(piles,0,piles.size()-1);\\n        cout<<k;\\n        if(sum-k<k)\\n        {\\n            return 1;\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1158606,
                "title": "python3-solution-without-dp-beats-99-8-solutions",
                "content": "Simple Python3 solution without Dynamic Programming. \\nConsidering that both the players only take optimal decisions so, to make the choices element the player will look at not only the max element they can choose but also if the other element that they encounter won\\'t be too less that it overturns the advantage gained by choosing current element.\\nHere is an example that explains my thoughts:\\nSuppose the given array is [3,7,5,3] and alex gets to choose the first element, \\n1. Now if Alex picks the 3 at start then the remaining array will be [7,5,3].\\n2. Now comes Lee, Lee will obviously choose the initial 7, the array will now be [5,3].\\n3. Now Alex will choose 5 and Lee will go with 3, causing the victory of Lee.\\n4. Now everything about this makes sense except for the blatant fact the Alex\\'s choice wasn\\'t optimal, if he would have known what\\'s the next element would would be then he would have chosen the 3 at last(not the 3 at begining).\\n5. As by choosing the 3 at last he leaves Lee with array [3,7,5]. \\n6. So the logic we can formulate here is that if Alex chooses first elements then he leaves Lee with the choice of choosing from 2nd element and last element, whereas if Alex chooses Last elements then he leaves Lee with 1st element and 2nd last element.\\n7. For the choice to be optimal Alex need to choose the max of (sum of 1st and 2nd last element, sum of 2nd element and last element).\\n8. Here is the python code for this analysis.\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        alex=0\\n        \\n        while(piles):\\n            alex+=abs(piles[0]+piles[-2] - piles[-1]+piles[1])\\n            piles=piles[2:-2]\\n            \\n        if alex>0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        alex=0\\n        \\n        while(piles):\\n            alex+=abs(piles[0]+piles[-2] - piles[-1]+piles[1])\\n            piles=piles[2:-2]\\n            \\n        if alex>0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972898,
                "title": "java-short-and-crisp-dfs-memoization-5-lines-dp-with-detailed-explanation",
                "content": "**DFS+Memoization** \\n Here as both players play optimally and as they will be switching,so at every instance we try to find maximum possible score and **add** it to score if it is Player1 or **subtract** if it is Player2.\\n **ALGO:**\\n**->** At each chance we  pick maximum stones by selecting from start or from end and passing it to next player.**Note**: if only one stone left,then you have no other way but to pick it and game over.\\n**->** DFS will be called even no.of times for Player1 and odd no.of times for Player2,So value of picked stone will get added for Player1 and subtracted for Player2. \\n**->** By doing this we are essentially finding difference of maximum scores of both players.\\nIf Difference of max scores of Player1 & 2 > ZERO, return TRUE. Else FALSE.\\n**Example:**\\n [1,2,3,4]\\n1-dfs([2,3,4])\\n .......1-(2-dfs(3,4))\\n ..............1-(2-(3-dfs(4)))\\n ....................1-(2-(3-(4)))=1-2+3-4=**score_P1(1+3)** - **score_P2(2+4)**=-2\\nSimilarly at each step we will get two chances to pick from start /  end and then we add stone_value if it is Player1 or subtract if it is Player2.\\n \\n```\\nclass Solution {\\n    HashMap<String,Integer> map=new HashMap();\\n    public boolean stoneGame(int[] piles) {\\n        return dfs(piles,0,piles.length-1)>0;\\n    }\\n    private int dfs(int[] piles,int start,int end){\\n        //Only one stone left\\n        if(start==end)return piles[start];\\n        String key=start+\" \"+end;\\n        if(map.containsKey(key)) return map.get(key);\\n\\t\\t/*Choose the better option,either picking from start or end*/\\n        int val = Math.max(piles[start]-dfs(piles,start+1,end),\\n                          piles[end]-dfs(piles,start,end-1));\\n        map.put(key,val);\\n        return val;\\n    }\\n}\\n```\\n**DP**\\nWe pre-caluculate all possibiites from length of window=1(only one stone), then try to find answers for increasing windows (from 2 to piles.length).\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        if(n==1) return true;\\n        Pair[][] memo=new Pair[n][n];\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++){\\n                memo[i][j]=new Pair();\\n\\t\\t\\t\\t/*If only one stone left,then current player picks it \\n\\t\\t\\t\\tand other player wont get any.GAME OVER.*/\\n                if(i==j) memo[i][j].first=piles[i];\\n            }\\n        }\\n        for(int len=2;len<=n;len++){\\n            for(int start=0,end=start+len-1;end<n;start++,end++){\\n\\t\\t\\t/*Choose the better option,either picking from start or end.\\n\\t\\t\\tAs players alternately select,if a current player selects now then he will become\\n\\t\\t\\tsecond player to choose from remaining stones.*/\\n                if(piles[start]+memo[start+1][end].second>piles[end]+memo[start][end-1].second){\\n                    memo[start][end].first=piles[start]+memo[start+1][end].second;\\n                    memo[start][end].second=memo[start+1][end].first;\\n                }\\n                else{\\n                    memo[start][end].first=piles[end]+memo[start][end-1].second;\\n                    memo[start][end].second=memo[start][end-1].first;\\n                }\\n            }\\n        }\\n        return memo[0][n-1].first>memo[0][n-1].second;\\n    }\\n}\\nclass Pair{\\n    int first=0,second=0;\\n    public String toString(){\\n        return first+\" \"+second;\\n    }\\n}\\n```\\nSimilar questions\\n**Stones_Game4:**\\nhttps://leetcode.com/problems/stone-game-iv/discuss/974415/Java-5-lines-of-code-or-3-Approaches-or-DFS%2BMemoization-or-DP-or-with-explanation.\\n**Stones_Game3:**\\nhttps://leetcode.com/problems/stone-game-iii/discuss/974109/Java-5-lines-of-code-or-*-DP-O(N)-TimeO(1)-Space-*-or-DFS%2BMemoization\\n**Stone_Game2:**\\nhttps://leetcode.com/problems/stone-game-ii/discuss/973053/Java-short-and-crisp-or-DFS%2BMemoization-or-with-intuition",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<String,Integer> map=new HashMap();\\n    public boolean stoneGame(int[] piles) {\\n        return dfs(piles,0,piles.length-1)>0;\\n    }\\n    private int dfs(int[] piles,int start,int end){\\n        //Only one stone left\\n        if(start==end)return piles[start];\\n        String key=start+\" \"+end;\\n        if(map.containsKey(key)) return map.get(key);\\n\\t\\t/*Choose the better option,either picking from start or end*/\\n        int val = Math.max(piles[start]-dfs(piles,start+1,end),\\n                          piles[end]-dfs(piles,start,end-1));\\n        map.put(key,val);\\n        return val;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        if(n==1) return true;\\n        Pair[][] memo=new Pair[n][n];\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++){\\n                memo[i][j]=new Pair();\\n\\t\\t\\t\\t/*If only one stone left,then current player picks it \\n\\t\\t\\t\\tand other player wont get any.GAME OVER.*/\\n                if(i==j) memo[i][j].first=piles[i];\\n            }\\n        }\\n        for(int len=2;len<=n;len++){\\n            for(int start=0,end=start+len-1;end<n;start++,end++){\\n\\t\\t\\t/*Choose the better option,either picking from start or end.\\n\\t\\t\\tAs players alternately select,if a current player selects now then he will become\\n\\t\\t\\tsecond player to choose from remaining stones.*/\\n                if(piles[start]+memo[start+1][end].second>piles[end]+memo[start][end-1].second){\\n                    memo[start][end].first=piles[start]+memo[start+1][end].second;\\n                    memo[start][end].second=memo[start+1][end].first;\\n                }\\n                else{\\n                    memo[start][end].first=piles[end]+memo[start][end-1].second;\\n                    memo[start][end].second=memo[start][end-1].first;\\n                }\\n            }\\n        }\\n        return memo[0][n-1].first>memo[0][n-1].second;\\n    }\\n}\\nclass Pair{\\n    int first=0,second=0;\\n    public String toString(){\\n        return first+\" \"+second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957282,
                "title": "python-o-n-iteration-solution-no-need-dp-or-math",
                "content": "DP too complex\\nMath too tricky\\n\\nI think the purpose of this question is only looking for a simple iteration solution.\\n\\n```\\n        def helper(s):\\n            return 0 if not s else max(s[0],s[-1])\\n        \\n        alex = 0\\n        lee = 0\\n        while piles:\\n            temp = helper(piles)\\n            alex += temp\\n            piles.pop(piles.index(temp))\\n            temp = helper(piles)\\n            lee += temp\\n        return alex > lee\\n```\\n\\nRuntime: 24 ms, faster than 75.00% of Python online submissions for Stone Game.\\nMemory Usage: 13.4 MB, less than 73.91% of Python online submissions for Stone Game.",
                "solutionTags": [],
                "code": "```\\n        def helper(s):\\n            return 0 if not s else max(s[0],s[-1])\\n        \\n        alex = 0\\n        lee = 0\\n        while piles:\\n            temp = helper(piles)\\n            alex += temp\\n            piles.pop(piles.index(temp))\\n            temp = helper(piles)\\n            lee += temp\\n        return alex > lee\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 940359,
                "title": "answer-is-always-true-so-just-return-true",
                "content": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 901421,
                "title": "always-true",
                "content": "\\'\\'\\'\\n    bool stoneGame(vector<int>& piles){\\n        // As total sum of all stones is odd\\n        // so game can be played in such a way that Alex always wins\\n        return true;\\n    }\\n\\t\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    bool stoneGame(vector<int>& piles){\\n        // As total sum of all stones is odd\\n        // so game can be played in such a way that Alex always wins\\n        return true;\\n    }\\n\\t\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 841760,
                "title": "c-bottom-up-dp",
                "content": "```\\ntypedef pair<int,int> pii;\\nbool stoneGame(vector<int>& piles) {\\n\\tint n = piles.size();\\n\\tint totalStones = accumulate(piles.begin(), piles.end(), 0);\\n\\tvector<vector<pii>> dp(n, vector<pii>(n, {0,0}));\\n\\n\\tfor(int i = 0; i < n; i++) dp[i][i] = {piles[i], 0};\\n\\n\\tfor(int len = 1; len < n; len++) {\\n\\t\\tfor(int i = 0; i < n-len; i++) {\\n\\t\\t\\tint x = i;\\n\\t\\t\\tint y = i+len;\\n\\t\\t\\tif(dp[x+1][y].second+piles[x] > dp[x][y-1].second+piles[y]) {\\n\\t\\t\\t\\tdp[x][y].first = dp[x+1][y].second+piles[x];\\n\\t\\t\\t\\tdp[x][y].second = dp[x+1][y].first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].first = dp[x][y-1].second+piles[y];\\n\\t\\t\\t\\tdp[x][y].second = dp[x][y-1].first;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1].first > totalStones/2;\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int,int> pii;\\nbool stoneGame(vector<int>& piles) {\\n\\tint n = piles.size();\\n\\tint totalStones = accumulate(piles.begin(), piles.end(), 0);\\n\\tvector<vector<pii>> dp(n, vector<pii>(n, {0,0}));\\n\\n\\tfor(int i = 0; i < n; i++) dp[i][i] = {piles[i], 0};\\n\\n\\tfor(int len = 1; len < n; len++) {\\n\\t\\tfor(int i = 0; i < n-len; i++) {\\n\\t\\t\\tint x = i;\\n\\t\\t\\tint y = i+len;\\n\\t\\t\\tif(dp[x+1][y].second+piles[x] > dp[x][y-1].second+piles[y]) {\\n\\t\\t\\t\\tdp[x][y].first = dp[x+1][y].second+piles[x];\\n\\t\\t\\t\\tdp[x][y].second = dp[x+1][y].first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].first = dp[x][y-1].second+piles[y];\\n\\t\\t\\t\\tdp[x][y].second = dp[x][y-1].first;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1].first > totalStones/2;\\n}  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 781703,
                "title": "cpp14-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        int dp[n][n][2] ; \\n        memset(dp , 0 , sizeof dp) ; \\n        for(int len = 1 ; len <= n ; ++len){\\n            for(int i = 0;  i <= n - len  ; ++i){\\n                int j = i + len - 1;  \\n               // cout << \" i \" << i << \" j \" << j << endl ; \\n                if(i == j){\\n                    dp[i][j][0] = piles[i] ; \\n                    dp[i][j][1] = 0 ; \\n                }\\n                else{\\n                    int left = piles[i] + dp[i+1][j][1] ; \\n                    int right = piles[j] + dp[i][j-1][1] ; \\n                    if(left > right){\\n                        dp[i][j][0] = left ; \\n                        dp[i][j][1] = dp[i+1][j][0] ; \\n                    }\\n                    else {\\n                        dp[i][j][0] = right ; \\n                        dp[i][j][1] = dp[i][j-1][0] ; \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int res = dp[0][n-1][0] ; \\n        int foo = dp[0][n-1][1] ; \\n        int sum = 0 ; \\n        for(auto x : piles) sum+=x ; \\n        int req = sum / 2 ; ++req ; \\n        if(res >= req) return 1; \\n        return 0 ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        int dp[n][n][2] ; \\n        memset(dp , 0 , sizeof dp) ; \\n        for(int len = 1 ; len <= n ; ++len){\\n            for(int i = 0;  i <= n - len  ; ++i){\\n                int j = i + len - 1;  \\n               // cout << \" i \" << i << \" j \" << j << endl ; \\n                if(i == j){\\n                    dp[i][j][0] = piles[i] ; \\n                    dp[i][j][1] = 0 ; \\n                }\\n                else{\\n                    int left = piles[i] + dp[i+1][j][1] ; \\n                    int right = piles[j] + dp[i][j-1][1] ; \\n                    if(left > right){\\n                        dp[i][j][0] = left ; \\n                        dp[i][j][1] = dp[i+1][j][0] ; \\n                    }\\n                    else {\\n                        dp[i][j][0] = right ; \\n                        dp[i][j][1] = dp[i][j-1][0] ; \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int res = dp[0][n-1][0] ; \\n        int foo = dp[0][n-1][1] ; \\n        int sum = 0 ; \\n        for(auto x : piles) sum+=x ; \\n        int req = sum / 2 ; ++req ; \\n        if(res >= req) return 1; \\n        return 0 ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 741240,
                "title": "clean-cpp-dp",
                "content": "```class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        // dp[i][j] is the maximum value that the first player could get,\\n        // given the sub arr of piles from i to j\\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), 0));\\n        \\n        for (int i = 0; i < piles.size(); ++i) {\\n            dp[i][i] = piles[i];\\n        }\\n        \\n        for (int left = piles.size() - 1; left >= 0; --left) {\\n            for (int right = left + 1; right < piles.size(); ++right) {\\n                int pick_left = piles[left] - dp[left + 1][right];\\n                int pick_right = piles[right] - dp[left][right - 1];\\n                dp[left][right] = max(pick_left, pick_right);\\n            }\\n        }\\n        \\n        return dp[0][piles.size() - 1] > 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        // dp[i][j] is the maximum value that the first player could get,\\n        // given the sub arr of piles from i to j\\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), 0));\\n        \\n        for (int i = 0; i < piles.size(); ++i) {\\n            dp[i][i] = piles[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 734419,
                "title": "cpp-one-line-code",
                "content": "if the no. of piles is even then answer will always be true.\\ncase 1 (piles.size()=2)\\n\\tAlice can choose either of two so alice win.\\ncase 2 (piles.size()=4)\\n\\tif you analyse the chances Alice can take you will see alice would always win.\\n\\tsuppose if Alice choose the 1st then she can choose 3rd\\n\\tor if Alice choose 4th then she can always choose 2nd \\n\\tand either of this combination will have maximum value.\\n\\twe can extend this pattern further then we will get two types of overall move like 1st 3rd 5th ... and 2nd 4th 6th ... so one of them will always be greater than other.\\n\\tso directly returning true will suffice.\\n```\\n bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718032,
                "title": "c-straightforward-dp-solution",
                "content": "The solution is for odd length of array. Please go refer to @lee215 arcticle why we only take odd into account.\\nFirst, we define Alex wins Lee amount of piles from i to j as `dp\\u1D62,\\u2C7C`. Subprobelm would be subarrary issue[1].\\nEach `dp\\u1D62,\\u1D62` means only have piles[i] for guessing[2] or initiation.\\nBecause, both of players play **optimally**, the opponent will also try to gain as more as possible piles at next round.\\nSo the transition formula `dp(i,j) ={all your can possible get} - {opponent can get}` [3]. What you can gain from piles[i] to piles[j] potentially is sum of piles(0,j)  minus sum of piles(0,i-1), and your opponent would try to lower your amount of piles. and recurrence formula would be `min(dp(i+1,j) , dp(i,j-1))`, since opponent can only pick up head or tail of array. Either i\\'s next step `i+1` or `j-1`. So Alex at i to j can gain number of piles as `dp(i,j) = sum of (i,j) - min(dp(i+1,j), dp(i,j-1))`\\n```\\ni = 1,\\nj = 3\\n[5,3,4,5]   -> [5,8,12,17]\\n   i   j\\nsum of (i,j) would be  17 - 5 = 12 (3+4+5)\\n```\\n\\nFinally, if dp(o,n-1) is larger than piles owned by opponents which can interpret as `sum(o,n-1) - {alex wins}`. Then, Alex wins, and it is our finally original problem[4]. The solution follows the description and instruction. \\n```\\nbool stoneGame(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    // dp(i,j) means from i to j alex gain how many piles from the game\\n    vector<int> presum(n+1, 0);\\n    for(int i=0; i < n; ++i)\\n        presum[i+1] = presum[i] + piles[i];\\n    vector<vector<int>> dp(n,vector<int>(n,0));\\n    for(int i=0; i < n; ++i) {\\n        dp[i][i] = piles[i];\\n    }\\n\\n    for(int l=0;  l < n-1; ++l) {\\n        for(int r=l+1; r < n; ++r) {\\n            int sum = presum[r+1] - presum[l];\\n            dp[l][r] = sum - min(dp[l+1][r], dp[l][r-1]);\\n        }\\n    }\\n    return dp[0][n-1] > presum[n] - dp[0][n-1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ni = 1,\\nj = 3\\n[5,3,4,5]   -> [5,8,12,17]\\n   i   j\\nsum of (i,j) would be  17 - 5 = 12 (3+4+5)\\n```\n```\\nbool stoneGame(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    // dp(i,j) means from i to j alex gain how many piles from the game\\n    vector<int> presum(n+1, 0);\\n    for(int i=0; i < n; ++i)\\n        presum[i+1] = presum[i] + piles[i];\\n    vector<vector<int>> dp(n,vector<int>(n,0));\\n    for(int i=0; i < n; ++i) {\\n        dp[i][i] = piles[i];\\n    }\\n\\n    for(int l=0;  l < n-1; ++l) {\\n        for(int r=l+1; r < n; ++r) {\\n            int sum = presum[r+1] - presum[l];\\n            dp[l][r] = sum - min(dp[l+1][r], dp[l][r-1]);\\n        }\\n    }\\n    return dp[0][n-1] > presum[n] - dp[0][n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717090,
                "title": "java-simple-dp",
                "content": "dp[i][j] means step i, with left array starts at index j;\\n```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706734,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\n[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities considered via top-down brute-force selecting the max of taking the first/last stones recursively\\n2. **R**emember previous subproblems\\' optimal solutions using a memo\\n3. **T**urn the top-down memoized solution upside-down for a bottom-up iterative solution\\n\\n**Note:** Prerequisites to properly understanding this solution are a handful of [game theory](https://en.wikipedia.org/wiki/Game_theory) concepts:\\n* [Zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game)\\n* [Minimax (in Zero-sum games)](https://en.wikipedia.org/wiki/Minimax#In_zero-sum_games)\\n* [Nash Equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium)\\n\\n---\\n\\n**Solution 1: Top-Down Brute-Force** (TLE)\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    };\\n    return 0 < go();\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    VI A;\\n    int go(int i, int j) {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution 2: Top-Down with Memo** (AC)\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    let go = (i = 0, j = N - 1) => {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1 \\n        let ans = m[i][j] = Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n        return ans;\\n    };\\n    return 0 < go();\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    VI A;\\n    Map m;\\n    int go(int i, int j) {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1\\n        return m[i][j] = max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution 3: Bottom-Up** (AC)\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i)\\n        dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {    \\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution 4: Bottom-Up - Optimized** (AC)\\n\\nWe don\\'t need to fill in and use the base case values `dp[i][i]` and `dp[j][j]`.  Instead we can direcly use `A[i]` and `A[j]` correspondingly in the recurrence relation.\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    };\\n    return 0 < go();\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    VI A;\\n    int go(int i, int j) {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    let go = (i = 0, j = N - 1) => {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1 \\n        let ans = m[i][j] = Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n        return ans;\\n    };\\n    return 0 < go();\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    VI A;\\n    Map m;\\n    int go(int i, int j) {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1\\n        return m[i][j] = max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i)\\n        dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599608,
                "title": "c-generalised-dp-solution",
                "content": "Clearly explained here: https://www.youtube.com/watch?v=WxpIHvsu1RI\\nLogic implemented in C++:\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& a) {\\n        int n = a.size();\\n        // Each pair denotes (Alex\\'s score, Lee\\'s score) so far\\n        pair<int, int> dp[n][n];\\n        // Fill grid diagonally first (first turn)\\n        for(int i = 0; i < n; ++i){\\n            dp[i][i].first = a[i];\\n            dp[i][i].second = 0;\\n        }\\n        for(int turn = 2; turn <= n; ++turn){\\n        // dp[i][j] = scores of players if stones from a[i, j] were\\n        // available for playing\\n            for(int i = 0; i <= n - turn; ++i){\\n                int j = i + turn - 1;\\n                int pickLeft = a[i] + dp[i+1][j].second, pickRight = a[j] + dp[i][j-1].second;\\n                dp[i][j].first = max(pickLeft, pickRight);\\n                if(dp[i][j].first == pickLeft) dp[i][j].second = dp[i+1][j].first;\\n                else dp[i][j].second = dp[i][j-1].first;\\n            }\\n        }\\n        // Check if first player scored more\\n        return dp[0][n-1].first > dp[0][n-1].second;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& a) {\\n        int n = a.size();\\n        // Each pair denotes (Alex\\'s score, Lee\\'s score) so far\\n        pair<int, int> dp[n][n];\\n        // Fill grid diagonally first (first turn)\\n        for(int i = 0; i < n; ++i){\\n            dp[i][i].first = a[i];\\n            dp[i][i].second = 0;\\n        }\\n        for(int turn = 2; turn <= n; ++turn){\\n        // dp[i][j] = scores of players if stones from a[i, j] were\\n        // available for playing\\n            for(int i = 0; i <= n - turn; ++i){\\n                int j = i + turn - 1;\\n                int pickLeft = a[i] + dp[i+1][j].second, pickRight = a[j] + dp[i][j-1].second;\\n                dp[i][j].first = max(pickLeft, pickRight);\\n                if(dp[i][j].first == pickLeft) dp[i][j].second = dp[i+1][j].first;\\n                else dp[i][j].second = dp[i][j-1].first;\\n            }\\n        }\\n        // Check if first player scored more\\n        return dp[0][n-1].first > dp[0][n-1].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587951,
                "title": "concise-java-dp-code-explained-in-detail-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int [][] dp = new int[n][n];\\n        /* prefill wher start and end == zero */\\n        for(int i=0;i<n;i++) dp[i][i] = piles[i];\\n        \\n        for(int d =1; d<n; d++){ /* d > 0 as we prefilled */\\n            for(int i= 0; i <n-d; i++){ /* start */\\n                dp[i][i+d] = Math.max(\\n       /* left choosen*/    piles[i] - dp[i+1][i+d], \\n       /* right choosen */  piles[i+d] - dp[i][i+d-1]); \\n            }\\n        }\\n    /* this will handle even when the no of piles are odd */\\n    /* example array : 5,3,4,5 \\n               index : 0,1,2,3        \\n            so if 0 to 2 that is 5,3,4 only exists than\\n            #if we choose 0 the oponent gets to choose from 1th index to 2nd index\\n                piles[i]- piles[i+1][i+d] (i+1 as we choose left and increment one index, i+d is where the array ends)\\n            \\n            #if we choose 2 then oponent gets gets to choose from 0th to 1st index \\n                piles[i+d]- piles[i][i+d-1] (i+d-1 as we choose last and so start to one index less than end)\\n    \\n    i --> indicates start of array\\n    i+d --> indicates end of array\\n    */\\n        return dp[0][n-1] >0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int [][] dp = new int[n][n];\\n        /* prefill wher start and end == zero */\\n        for(int i=0;i<n;i++) dp[i][i] = piles[i];\\n        \\n        for(int d =1; d<n; d++){ /* d > 0 as we prefilled */\\n            for(int i= 0; i <n-d; i++){ /* start */\\n                dp[i][i+d] = Math.max(\\n       /* left choosen*/    piles[i] - dp[i+1][i+d], \\n       /* right choosen */  piles[i+d] - dp[i][i+d-1]); \\n            }\\n        }\\n    /* this will handle even when the no of piles are odd */\\n    /* example array : 5,3,4,5 \\n               index : 0,1,2,3        \\n            so if 0 to 2 that is 5,3,4 only exists than\\n            #if we choose 0 the oponent gets to choose from 1th index to 2nd index\\n                piles[i]- piles[i+1][i+d] (i+1 as we choose left and increment one index, i+d is where the array ends)\\n            \\n            #if we choose 2 then oponent gets gets to choose from 0th to 1st index \\n                piles[i+d]- piles[i][i+d-1] (i+d-1 as we choose last and so start to one index less than end)\\n    \\n    i --> indicates start of array\\n    i+d --> indicates end of array\\n    */\\n        return dp[0][n-1] >0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575179,
                "title": "java-dfs-with-memoization",
                "content": "```java\\n    public boolean stoneGame(int[] piles) {\\n        if(piles == null || piles.length == 0) {\\n            return true;\\n        }\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n        return dfs(0, piles.length-1, piles, dp) > 0;\\n    }\\n\\n    /**\\n     * return the relative value Alice score - Bob score\\n     * @param l\\n     * @param r\\n     * @param piles\\n     * @return\\n     */\\n    private int dfs(int l, int r, int[] piles, int[][] dp) {\\n        if(dp[l][r] != 0) {\\n            return dp[l][r];\\n        }\\n        if(l>r) {\\n            return 0;\\n        }\\n        if(l == r) {\\n            return piles[l];\\n        }\\n\\n        // take either left or right\\n        // take left\\n        int ans1 = piles[l] - dfs(l+1, r, piles, dp);\\n        // take right\\n        int ans2 = piles[r] - dfs(l, r-1, piles, dp);\\n        return dp[l][r] = Math.max(ans1, ans2);\\n    }\\n```\\n\\n\\n\\nbottomup dp\\n\\n\\n```java\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n\\n        // initial state\\n        // bottom up, the optimal is covered in the sub optimal matrix.\\n        // init, where left == right, the player can get all the points..\\n        for(int i=0;i<n;i++) {\\n            dp[i][i] = piles[i];\\n        }\\n        for(int len = 2;len<= n;len++) {\\n            for(int i=0;i+len-1 < n;i++) {\\n                int j = i + len-1;\\n                dp[i][j] = Math.max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);\\n            }\\n        }\\n        return dp[0][n-1] > 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean stoneGame(int[] piles) {\\n        if(piles == null || piles.length == 0) {\\n            return true;\\n        }\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n        return dfs(0, piles.length-1, piles, dp) > 0;\\n    }\\n\\n    /**\\n     * return the relative value Alice score - Bob score\\n     * @param l\\n     * @param r\\n     * @param piles\\n     * @return\\n     */\\n    private int dfs(int l, int r, int[] piles, int[][] dp) {\\n        if(dp[l][r] != 0) {\\n            return dp[l][r];\\n        }\\n        if(l>r) {\\n            return 0;\\n        }\\n        if(l == r) {\\n            return piles[l];\\n        }\\n\\n        // take either left or right\\n        // take left\\n        int ans1 = piles[l] - dfs(l+1, r, piles, dp);\\n        // take right\\n        int ans2 = piles[r] - dfs(l, r-1, piles, dp);\\n        return dp[l][r] = Math.max(ans1, ans2);\\n    }\\n```\n```java\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n\\n        // initial state\\n        // bottom up, the optimal is covered in the sub optimal matrix.\\n        // init, where left == right, the player can get all the points..\\n        for(int i=0;i<n;i++) {\\n            dp[i][i] = piles[i];\\n        }\\n        for(int len = 2;len<= n;len++) {\\n            for(int i=0;i+len-1 < n;i++) {\\n                int j = i + len-1;\\n                dp[i][j] = Math.max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);\\n            }\\n        }\\n        return dp[0][n-1] > 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383835,
                "title": "python-dp",
                "content": "1. chose left\\n2. chose right\\n```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(piles)\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1,-1,-1):\\n            for j in range(i,n):\\n                if (n - (j-i+1) ) % 2 == 0:\\n                    dp[i][j] = max((dp[i][j-1] if j > 0 else 0)+piles[j],(dp[i+1][j] if i < n-1 else 0 )+piles[i])\\n                else:\\n                    dp[i][j] = min((dp[i][j-1] if j > 0 else 0)-piles[j],(dp[i+1][j] if i < n-1 else 0 )-piles[i])\\n              \\n        return dp[0][-1] > 0\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(piles)\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1,-1,-1):\\n            for j in range(i,n):\\n                if (n - (j-i+1) ) % 2 == 0:\\n                    dp[i][j] = max((dp[i][j-1] if j > 0 else 0)+piles[j],(dp[i+1][j] if i < n-1 else 0 )+piles[i])\\n                else:\\n                    dp[i][j] = min((dp[i][j-1] if j > 0 else 0)-piles[j],(dp[i+1][j] if i < n-1 else 0 )-piles[i])\\n              \\n        return dp[0][-1] > 0\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 368423,
                "title": "c-solution-using-deque-faster-than-100-submissions",
                "content": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int alex = 0, lee = 0;\\n        deque <int> d;\\n        for(int i=0;i<piles.size();i++)\\n            d.push_back(piles[i]);\\n        \\n        for(int i=0;i<d.size();i++) {\\n            alex += max(d.front(), d.back());\\n            lee += min(d.front(), d.back());\\n            d.pop_front();\\n            d.pop_back();\\n        }\\n        if(alex > lee)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int alex = 0, lee = 0;\\n        deque <int> d;\\n        for(int i=0;i<piles.size();i++)\\n            d.push_back(piles[i]);\\n        \\n        for(int i=0;i<d.size();i++) {\\n            alex += max(d.front(), d.back());\\n            lee += min(d.front(), d.back());\\n            d.pop_front();\\n            d.pop_back();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 348958,
                "title": "one-line-solution",
                "content": "A solution is, return true. Why? We can prove by induction.  General idea, we revome 2 elements of a vector, the base case is a vector with 2 elements and Alex always win. So, for a vector with size multiple of 2 Alex win again, because he chooses the major element of the two elements removed.\\n\\n```\\nExample: v = [1,2,3,4,5,6] => (3 sub-problems) \\n\\t=> [1,2,3,4],  (3 sub-problems)\\n\\t\\t\\t=> [2,3], [1,2], [3,4] (Alex always wins)\\n\\t=>[3,4,5,6 ], (3 sub-problems)\\n\\t\\t\\t=>[3,4], [4,5], [5,6] (Alex always wins)\\n\\t=>[2,3,4,5]\\n\\t\\t\\t=>[2,3],[3,4],[4,5] (Alex always wins)\\n```\\n\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nExample: v = [1,2,3,4,5,6] => (3 sub-problems) \\n\\t=> [1,2,3,4],  (3 sub-problems)\\n\\t\\t\\t=> [2,3], [1,2], [3,4] (Alex always wins)\\n\\t=>[3,4,5,6 ], (3 sub-problems)\\n\\t\\t\\t=>[3,4], [4,5], [5,6] (Alex always wins)\\n\\t=>[2,3,4,5]\\n\\t\\t\\t=>[2,3],[3,4],[4,5] (Alex always wins)\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296782,
                "title": "dp-o-n-2-and-trick-o-1-with-explanation",
                "content": "DP method: some code maybe redundant\\n```\\nclass Solution(object):\\ndef stoneGame(self, piles):\\n\"\"\"\\n:type piles: List[int]\\n:rtype: bool\\n\"\"\"\\nif len(piles)==2:\\n\\treturn True\\n#define the check interval when going through the pile\\nto_add = 3\\n#first compute the situation where only two stones are left to pick\\nsmaller = [max(piles[i],piles[i+1]) for i in range(len(piles)-1)]\\n#further compute situation where only 4,6,8.... stones are left to pick\\nwhile to_add < len(piles):\\n\\ts1 = []\\n\\t\\tfor i in range(len(piles)-to_add):\\n#the opponent plays optimally, so when caculating n+2 stones when we have the\\n#solution for n stones, we take the first stone and add its value to the minimum of\\n#the next 2 opitmal solution to get candidate one\\n#then add the value of the stone \\'to_add\\' step further to the minimum of the value\\n#of its previous two optimal solution to get candidate two\\n#the solution for the current size is the max of the two candidates\\n#for example we have [3,4,5,6], the solution for size2 is [4,5,6]\\n#we take the max(3+min(5,6),6+min(4,5)) to get the size4 solution\\n\\t\\tcand1 = piles[i]+min(smaller[i+1],smaller[i+2])\\n\\t\\tcand2 = piles[i+to_add]+min(smaller[i],smaller[i+1])\\n\\t\\tans = max(cand1,cand2)\\n\\t\\ts1.append(ans)\\n\\tto_add+=2\\n\\tsmaller = s1\\n#return true if our optimal solution is bigger than the value left\\nreturn smaller[0]>=sum(piles)-smaller[0]\\n```\\n\\nTrick: return True\\nAs you may notice, the DP solution above compute the optimal solution,\\nwhich is the maximum value we can get. However we do not need to get the maximum value to win the game.\\nIn this case, there are even number of stones,which means the index of the two stones on the ends are 1 odd and 1 even. Since we get to pick first, if we pick the last one(which has a index of odd number), we leave the opponent with two stones with even number to choose from.So no matter which one he picks, we get to choose a stone with odd index again.\\nSame for the case if we choose the first one(we then get to pick all the stones with even index). So we only need to check the sum of stones with even index and odd index and pick the larger one to win.\\nWait, we don\\'t need to know what stones to pick to win. we only need to know whether we can win, and it\\'s a fact that either sum of even index is larger or sum of odd index is larger.\\nHence we know we can always check the sum and win base on the result.\\nSo simply return True",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\ndef stoneGame(self, piles):\\n\"\"\"\\n:type piles: List[int]\\n:rtype: bool\\n\"\"\"\\nif len(piles)==2:\\n\\treturn True\\n#define the check interval when going through the pile\\nto_add = 3\\n#first compute the situation where only two stones are left to pick\\nsmaller = [max(piles[i],piles[i+1]) for i in range(len(piles)-1)]\\n#further compute situation where only 4,6,8.... stones are left to pick\\nwhile to_add < len(piles):\\n\\ts1 = []\\n\\t\\tfor i in range(len(piles)-to_add):\\n#the opponent plays optimally, so when caculating n+2 stones when we have the\\n#solution for n stones, we take the first stone and add its value to the minimum of\\n#the next 2 opitmal solution to get candidate one\\n#then add the value of the stone \\'to_add\\' step further to the minimum of the value\\n#of its previous two optimal solution to get candidate two\\n#the solution for the current size is the max of the two candidates\\n#for example we have [3,4,5,6], the solution for size2 is [4,5,6]\\n#we take the max(3+min(5,6),6+min(4,5)) to get the size4 solution\\n\\t\\tcand1 = piles[i]+min(smaller[i+1],smaller[i+2])\\n\\t\\tcand2 = piles[i+to_add]+min(smaller[i],smaller[i+1])\\n\\t\\tans = max(cand1,cand2)\\n\\t\\ts1.append(ans)\\n\\tto_add+=2\\n\\tsmaller = s1\\n#return true if our optimal solution is bigger than the value left\\nreturn smaller[0]>=sum(piles)-smaller[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288976,
                "title": "python3-beat-100-simple-and-clear-no-dp",
                "content": "both players will pick the largest value of the remaining list\\n1. you are given [5,3,4,5]\\n sort all the piles, so that it has an increaseing or decreasing order, for example [5,5,4,3]\\n2. if start with the player A,  definitely he will select the largest, which is 5[index =1], then player B select the second largest, which is 5, [index =2],\\n\\n3. then the index of piles selected by player A is : 1,3,5,7,9,...\\nthen the index of piles selected by player B is : 2,4,6,8,10,...\\n\\njust sum up the piles picked by player A and player B\\uFF0Cand by comparison you my see who wins.\\n\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        piles.sort()\\n        piles = piles[::-1]\\n        sum1 = 0\\n        i =0\\n        while i <len(piles):\\n            sum1 += piles[i]\\n            i+=2\\n        if sum1*2 > sum(piles):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        piles.sort()\\n        piles = piles[::-1]\\n        sum1 = 0\\n        i =0\\n        while i <len(piles):\\n            sum1 += piles[i]\\n            i+=2\\n        if sum1*2 > sum(piles):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252097,
                "title": "python-minimax-template",
                "content": "```\\n\"\"\"\\nminimax problem\\n\\nscore = score_Alex - score_Lee\\nif score > 0, alex win\\nis score < 0, lee win\\n\\nTo win, alex want to maximize score, lee minimize score.\\n\"\"\"\\nMAXINT = float(\\'inf\\')\\nMININT = float(\\'-inf\\')\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        # maxScore = {} # (i,j) -> maxScore\\n        # minScore = {} # (i,j) -> minScore\\n        N = len(piles)\\n        maxScore = [[float(MININT)] * N for _ in range(N)]\\n        minScore = [[float(MAXINT)] * N for _ in range(N)]\\n        \\n        def miniMaxScore(i, j, wantMax=True):\\n            if i > j: return 0\\n            if wantMax:\\n                if maxScore[i][j] != MININT: return maxScore[i][j]\\n                maxScore[i][j] = max(\\n                    piles[i] + miniMaxScore(i + 1, j, False),\\n                    piles[j] + miniMaxScore(i, j - 1, False),\\n                )\\n                return maxScore[i][j]\\n            else:\\n                if minScore[i][j] != MAXINT: return minScore[i][j]\\n                minScore[i][j] = min(\\n                    -piles[i] + miniMaxScore(i + 1, j, True),\\n                    -piles[j] + miniMaxScore(i, j - 1, True),\\n                )\\n                return minScore[i][j]\\n        return miniMaxScore(0, N - 1) > 0\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nminimax problem\\n\\nscore = score_Alex - score_Lee\\nif score > 0, alex win\\nis score < 0, lee win\\n\\nTo win, alex want to maximize score, lee minimize score.\\n\"\"\"\\nMAXINT = float(\\'inf\\')\\nMININT = float(\\'-inf\\')\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        # maxScore = {} # (i,j) -> maxScore\\n        # minScore = {} # (i,j) -> minScore\\n        N = len(piles)\\n        maxScore = [[float(MININT)] * N for _ in range(N)]\\n        minScore = [[float(MAXINT)] * N for _ in range(N)]\\n        \\n        def miniMaxScore(i, j, wantMax=True):\\n            if i > j: return 0\\n            if wantMax:\\n                if maxScore[i][j] != MININT: return maxScore[i][j]\\n                maxScore[i][j] = max(\\n                    piles[i] + miniMaxScore(i + 1, j, False),\\n                    piles[j] + miniMaxScore(i, j - 1, False),\\n                )\\n                return maxScore[i][j]\\n            else:\\n                if minScore[i][j] != MAXINT: return minScore[i][j]\\n                minScore[i][j] = min(\\n                    -piles[i] + miniMaxScore(i + 1, j, True),\\n                    -piles[j] + miniMaxScore(i, j - 1, True),\\n                )\\n                return minScore[i][j]\\n        return miniMaxScore(0, N - 1) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218258,
                "title": "easy-c-recursive-memoization-solution-o-n-2",
                "content": "For each recursion, the 4 possibility are evaluated:\\n- Both Alex and Lee get the leftmost piles\\n- Both Alex and Lee get the right piles\\n- Alex take left, Lee take right\\n- Alex take right, Lee take left\\n\\nThe conditions are in OR. Only a full run on all combination of start/end is necessary, The results are memoized and reused for the subsequent calls:\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameRec(vector<int>& piles, int start, int end, int alexScore, int leeScore, vector<vector<int>>& cache)\\n    {\\n        if (start > end)\\n           return alexScore > leeScore;\\n        \\n        if(cache[start][end] >= 0)\\n            return cache[start][end] == 1;\\n        \\n        bool res = (stoneGameRec(piles, start + 2, end, alexScore + piles[start], leeScore + piles[start + 1], cache) ||\\n                    stoneGameRec(piles, start, end - 2, alexScore + piles[end], leeScore + piles[end - 1], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[start], leeScore + piles[end], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[end], leeScore + piles[start], cache));\\n        \\n        cache[start][end] = res;\\n        \\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles)\\n    {\\n        if (piles.empty())\\n            return false;\\n        \\n        vector<vector<int>> cache(piles.size(), vector<int>(piles.size(), -1));\\n        \\n        return stoneGameRec(piles, 0, piles.size() - 1, 0, 0, cache);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameRec(vector<int>& piles, int start, int end, int alexScore, int leeScore, vector<vector<int>>& cache)\\n    {\\n        if (start > end)\\n           return alexScore > leeScore;\\n        \\n        if(cache[start][end] >= 0)\\n            return cache[start][end] == 1;\\n        \\n        bool res = (stoneGameRec(piles, start + 2, end, alexScore + piles[start], leeScore + piles[start + 1], cache) ||\\n                    stoneGameRec(piles, start, end - 2, alexScore + piles[end], leeScore + piles[end - 1], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[start], leeScore + piles[end], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[end], leeScore + piles[start], cache));\\n        \\n        cache[start][end] = res;\\n        \\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles)\\n    {\\n        if (piles.empty())\\n            return false;\\n        \\n        vector<vector<int>> cache(piles.size(), vector<int>(piles.size(), -1));\\n        \\n        return stoneGameRec(piles, 0, piles.size() - 1, 0, 0, cache);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217567,
                "title": "intuitive-dp-solution-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    //dp[i][j] = max number of coins alex has if game is played on piles[i...j]\\n    // Alex has two choices:\\n    // 1. Select leftmost : if he selects leftmost then he has to take optimal choice from dp[i+1...j]\\n    //  2. Select rigtmost : if he select rightmost then he has to take optimal choice from dp[i... j - 1]\\n    //   3. he takes maximimum of both the choices\\n    //     base case:\\n    // if one pile ---> alext takes it\\n    //     if two piles --> alex select max from two\\n    public boolean stoneGame(int[] piles) {\\n        int totalCoins = 0;\\n        for(int onePile : piles) {\\n            totalCoins += onePile;\\n        }\\n        \\n        int dp[][] = new int[piles.length][piles.length];\\n        \\n        for(int k = 0; k < piles.length; k++) {\\n            int i = 0;\\n            for(int j = k; j < piles.length; j++) {\\n                //System.out.println(i + \" \" + j);\\n                if(i == j) dp[i][j] = piles[i];\\n                else if(i == j + 1) dp[i][j] = Math.max(piles[i], piles[j + 1]);\\n                else dp[i][j] = Math.max(piles[i] + dp[i + 1][j], piles[j] + dp[i][j - 1]);\\n                i++;\\n            }\\n        }\\n        return totalCoins / 2 < dp[0][piles.length - 1] ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //dp[i][j] = max number of coins alex has if game is played on piles[i...j]\\n    // Alex has two choices:\\n    // 1. Select leftmost : if he selects leftmost then he has to take optimal choice from dp[i+1...j]\\n    //  2. Select rigtmost : if he select rightmost then he has to take optimal choice from dp[i... j - 1]\\n    //   3. he takes maximimum of both the choices\\n    //     base case:\\n    // if one pile ---> alext takes it\\n    //     if two piles --> alex select max from two\\n    public boolean stoneGame(int[] piles) {\\n        int totalCoins = 0;\\n        for(int onePile : piles) {\\n            totalCoins += onePile;\\n        }\\n        \\n        int dp[][] = new int[piles.length][piles.length];\\n        \\n        for(int k = 0; k < piles.length; k++) {\\n            int i = 0;\\n            for(int j = k; j < piles.length; j++) {\\n                //System.out.println(i + \" \" + j);\\n                if(i == j) dp[i][j] = piles[i];\\n                else if(i == j + 1) dp[i][j] = Math.max(piles[i], piles[j + 1]);\\n                else dp[i][j] = Math.max(piles[i] + dp[i + 1][j], piles[j] + dp[i][j - 1]);\\n                i++;\\n            }\\n        }\\n        return totalCoins / 2 < dp[0][piles.length - 1] ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213801,
                "title": "c-1-line-fastest-solution-alive-hacked-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201060,
                "title": "c-dp-solution",
                "content": "```\\nint min(int a, int b) {\\n\\treturn a < b ? a : b;\\n}\\n//dp[i][j]+min(d[i][j-1],d[i+1][j])=sum[i][j]\\nbool stoneGame(int* piles, int pilesSize) {\\n    int **d = (int **)malloc(sizeof(int *)*pilesSize);\\n    int **sum = (int **)malloc(sizeof(int *)*pilesSize);\\n    for(int i=0;i<pilesSize;++i){\\n        d[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        sum[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        for(int j=0;j<pilesSize;++j){\\n            if(i==j){\\n                d[i][j]=piles[i];\\n                sum[i][j]=piles[i];\\n            }\\n        }\\n    }\\n    int j;\\n    for(int l=2;l<=pilesSize;++l){\\n        for(int i=0;i<=pilesSize-l;++i){\\n            j=i+l-1;\\n            sum[i][j] = sum[i][j-1]+piles[j];\\n            d[i][j] = sum[i][j]-min(d[i][j-1],d[i+1][j]);\\n        }\\n    }\\n    bool result = (d[0][pilesSize - 1]*2 > sum[0][pilesSize-1]);\\n    for(int i=0;i<pilesSize;++i){\\n        free(d[i]);\\n        free(sum[i]);\\n    }\\n    free(d);\\n    free(sum);\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint min(int a, int b) {\\n\\treturn a < b ? a : b;\\n}\\n//dp[i][j]+min(d[i][j-1],d[i+1][j])=sum[i][j]\\nbool stoneGame(int* piles, int pilesSize) {\\n    int **d = (int **)malloc(sizeof(int *)*pilesSize);\\n    int **sum = (int **)malloc(sizeof(int *)*pilesSize);\\n    for(int i=0;i<pilesSize;++i){\\n        d[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        sum[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        for(int j=0;j<pilesSize;++j){\\n            if(i==j){\\n                d[i][j]=piles[i];\\n                sum[i][j]=piles[i];\\n            }\\n        }\\n    }\\n    int j;\\n    for(int l=2;l<=pilesSize;++l){\\n        for(int i=0;i<=pilesSize-l;++i){\\n            j=i+l-1;\\n            sum[i][j] = sum[i][j-1]+piles[j];\\n            d[i][j] = sum[i][j]-min(d[i][j-1],d[i+1][j]);\\n        }\\n    }\\n    bool result = (d[0][pilesSize - 1]*2 > sum[0][pilesSize-1]);\\n    for(int i=0;i<pilesSize;++i){\\n        free(d[i]);\\n        free(sum[i]);\\n    }\\n    free(d);\\n    free(sum);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197290,
                "title": "does-this-make-sense",
                "content": "```\\ndef stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        alex = 0\\n        other = 0\\n        start, end = 0 , len(piles) -1\\n        \\n        while start < end:\\n            \\n            alex += max(piles[start], piles[end])\\n            other += min(piles[start], piles[end])\\n            \\n            start += 1\\n            end -=1\\n        return alex > other\\n        ```",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        alex = 0\\n        other = 0\\n        start, end = 0 , len(piles) -1\\n        \\n        while start < end:\\n            \\n            alex += max(piles[start], piles[end])\\n            other += min(piles[start], piles[end])\\n            \\n            start += 1\\n            end -=1\\n        return alex > other\\n        ```",
                "codeTag": "Python3"
            },
            {
                "id": 188113,
                "title": "fundamental-concept-is-wrong-leads-to-1-line-solution-in-o-1-time",
                "content": "There is a fundamental problem in this question. \n\nIf Alice and Bob both play optimally and Alice goes first, Alice will alwasys win!!\n\nTherefore, doing this will passs all test cases: \n\n```\nclass Solution {\npublic:\n\n    bool stoneGame(vector<int>& piles) {\n        \n        return true;\n     }\n};\n```\n\n\nThough this is my recursion solution (will return TLE in large testcases)\n\n\n```\nclass Solution {\npublic:\n    int sumA, sumB;\n    int f;\n    int maxE(int a, int b){\n        if(a>b)\n            return a;\n        else return b;\n    }\n   int minE(int a, int b){\n       if(a<b)\n            return a;\n        else return b;\n   }\n    int findA(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumA)\n                sumA = max(p[s], p[e]);\n            \n            return min(p[s], p[e]);\n           \n        }\n        int val = 0;\n        val = max(p[s] + findB(p, s+1, e), p[e] + findB(p, s, e-1));\n        sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n\n        if(val > sumA)\n            sumA = val;\n      \n        return sum - val;\n        \n    }\n    int findB(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumB)\n                sumB = max(p[s], p[e]);\n            return min(p[s], p[e]);\n           \n        }\n        int val=0;\n        val = max(p[s] + findA(p, s+1, e), p[e] + findA(p, s, e-1));\n        \n         sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n      \n          if(val > sumB)\n            sumB = val;\n  \n        return sum - val;\n    }\n    bool stoneGame(vector<int>& piles) {\n        \n       // return true;\n        \n        if(piles.size()<= 2)\n            return true;\n        \n        if(piles.size()%2!=0)\n            return true;\n        int i;\n        sumA = sumB = 0;\n        int val = findA(piles, 0, piles.size()-1);\n        \n\n        if(sumA >= sumB)\n            return true;\n        else return false;\n        \n     }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n\n    bool stoneGame(vector<int>& piles) {\n        \n        return true;\n     }\n};\n```\n```\nclass Solution {\npublic:\n    int sumA, sumB;\n    int f;\n    int maxE(int a, int b){\n        if(a>b)\n            return a;\n        else return b;\n    }\n   int minE(int a, int b){\n       if(a<b)\n            return a;\n        else return b;\n   }\n    int findA(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumA)\n                sumA = max(p[s], p[e]);\n            \n            return min(p[s], p[e]);\n           \n        }\n        int val = 0;\n        val = max(p[s] + findB(p, s+1, e), p[e] + findB(p, s, e-1));\n        sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n\n        if(val > sumA)\n            sumA = val;\n      \n        return sum - val;\n        \n    }\n    int findB(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumB)\n                sumB = max(p[s], p[e]);\n            return min(p[s], p[e]);\n           \n        }\n        int val=0;\n        val = max(p[s] + findA(p, s+1, e), p[e] + findA(p, s, e-1));\n        \n         sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n      \n          if(val > sumB)\n            sumB = val;\n  \n        return sum - val;\n    }\n    bool stoneGame(vector<int>& piles) {\n        \n       // return true;\n        \n        if(piles.size()<= 2)\n            return true;\n        \n        if(piles.size()%2!=0)\n            return true;\n        int i;\n        sumA = sumB = 0;\n        int val = findA(piles, 0, piles.size()-1);\n        \n\n        if(sumA >= sumB)\n            return true;\n        else return false;\n        \n     }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 155257,
                "title": "logical-thinking-with-clear-code",
                "content": "The solution below is the same as the one of **486. Predict the Winner**. \\nLink:  https://leetcode.com/problems/predict-the-winner/discuss/155217/Logical-Thinking-with-Clear-Java-Code\\n\\n**Logical Thinking**\\nIf we regard possible selecting range as **state**,\\n`state[i][j]` as the max score the 1st player can get selecting from nums[i, j)\\n**goal**: return true if `state[0][n - 1] >= totalScores - state[0][n - 1] `\\n**state transition**:\\n```\\n        max scores 1st can get = \\n            max(nums[i] + min(max scores 1st can get next round),\\n                nums[j - 1] + min(max scores 1st can get next round))\\n        * Please note that for the next round we take \\'min\\' for the 2nd player plays to maximize his score.\\n\\t\\t\\t\\t\\n        if 1st picks nums[i], 2nd can pick from [i + 1, j)\\n                             if 2nd picks nums[i + 1], 1st can pick  from nums[i + 2, j)\\n                             if 2nd picks nums[j - 1], 1st can pick from nums[i + 1, j - 1)\\n        if 1st picks nums[j - 1], 2nd can pick from [i, j - 1)\\n                             if 2nd picks nums[i], 1st picks from nums[i + 1, j - 1)\\n                             if 2nd picks nums[j - 2], 1st picks from nums[i, j - 2)\\n\\n```\\nWe utilize **memorization** to avoid duplicate calculations.\\n\\n**Clear Java Code**\\n```\\n    int[][] memo; // -1 if unvisited, 0 if false, 1 if true\\n\\n    public boolean stoneGame(int[] piles) {\\n\\n        int sum = 0, n = piles.length;\\n        initMemo(n);\\n        for (int num : piles)\\n            sum += num;\\n        int playerOneScore = getMaxScore(piles, 0, n);\\n\\n        return playerOneScore >= sum - playerOneScore;\\n    }\\n\\n    private void initMemo(int n) {\\n\\n        memo = new int[n + 1][n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            for (int j = 0; j < n + 1; j++) {\\n                memo[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    private int getMaxScore(int[] piles, int i, int j) {\\n\\n        if (i >= j) {\\n            return 0;\\n        }\\n        if (i + 1 == j) {\\n            return piles[i];\\n        }\\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n\\n        int result = Math.max(piles[i] + Math.min(getMaxScore(piles, i + 2, j), getMaxScore(piles, i + 1, j - 1)),\\n                piles[j - 1] + Math.min(getMaxScore(piles, i, j - 2), getMaxScore(piles, i + 1, j - 1)));\\n        memo[i][j] = result;\\n\\n        return result;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**\\n",
                "solutionTags": [],
                "code": "```\\n        max scores 1st can get = \\n            max(nums[i] + min(max scores 1st can get next round),\\n                nums[j - 1] + min(max scores 1st can get next round))\\n        * Please note that for the next round we take \\'min\\' for the 2nd player plays to maximize his score.\\n\\t\\t\\t\\t\\n        if 1st picks nums[i], 2nd can pick from [i + 1, j)\\n                             if 2nd picks nums[i + 1], 1st can pick  from nums[i + 2, j)\\n                             if 2nd picks nums[j - 1], 1st can pick from nums[i + 1, j - 1)\\n        if 1st picks nums[j - 1], 2nd can pick from [i, j - 1)\\n                             if 2nd picks nums[i], 1st picks from nums[i + 1, j - 1)\\n                             if 2nd picks nums[j - 2], 1st picks from nums[i, j - 2)\\n\\n```\n```\\n    int[][] memo; // -1 if unvisited, 0 if false, 1 if true\\n\\n    public boolean stoneGame(int[] piles) {\\n\\n        int sum = 0, n = piles.length;\\n        initMemo(n);\\n        for (int num : piles)\\n            sum += num;\\n        int playerOneScore = getMaxScore(piles, 0, n);\\n\\n        return playerOneScore >= sum - playerOneScore;\\n    }\\n\\n    private void initMemo(int n) {\\n\\n        memo = new int[n + 1][n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            for (int j = 0; j < n + 1; j++) {\\n                memo[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    private int getMaxScore(int[] piles, int i, int j) {\\n\\n        if (i >= j) {\\n            return 0;\\n        }\\n        if (i + 1 == j) {\\n            return piles[i];\\n        }\\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n\\n        int result = Math.max(piles[i] + Math.min(getMaxScore(piles, i + 2, j), getMaxScore(piles, i + 1, j - 1)),\\n                piles[j - 1] + Math.min(getMaxScore(piles, i, j - 2), getMaxScore(piles, i + 1, j - 1)));\\n        memo[i][j] = result;\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155242,
                "title": "java-memorization-search",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Integer[][] memo = new Integer[piles.length][piles.length];\\n        int max = dfs(piles, 0, piles.length - 1, memo);\\n        \\n        return memo[0][piles.length - 1] > 0;\\n    }\\n    \\n    \\n    \\n    private int dfs(int[] piles, int i, int j, Integer[][] memo) {\\n        if (i > j)  return 0;\\n        if (memo[i][j] != null) return memo[i][j];\\n        \\n        memo[i][j] = Math.max(piles[i] - dfs(piles, i + 1, j, memo), piles[j] - dfs(piles, i, j - 1, memo));\\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Integer[][] memo = new Integer[piles.length][piles.length];\\n        int max = dfs(piles, 0, piles.length - 1, memo);\\n        \\n        return memo[0][piles.length - 1] > 0;\\n    }\\n    \\n    \\n    \\n    private int dfs(int[] piles, int i, int j, Integer[][] memo) {\\n        if (i > j)  return 0;\\n        if (memo[i][j] != null) return memo[i][j];\\n        \\n        memo[i][j] = Math.max(piles[i] - dfs(piles, i + 1, j, memo), piles[j] - dfs(piles, i, j - 1, memo));\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881169,
                "title": "100-beat-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        //start->end\\n        int alice=0;\\n        for(int i=0; i<piles.length; i+=2){\\n            alice+=piles[i];\\n        }\\n        int bob=0;\\n        for(int i=1; i<piles.length; i+=2){\\n            bob+=piles[i];\\n        }\\n\\n        //end->start\\n        int alice1=0;\\n        for(int i=piles.length-1; i>=0 ; i-=2){\\n            alice1+=piles[i];\\n        }\\n        int bob1=0;\\n        for(int i=piles.length-2; i>=0 ; i-=2){\\n            bob1+=piles[i];\\n        } \\n   \\n        return alice>bob || alice1>bob1;  \\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        //start->end\\n        int alice=0;\\n        for(int i=0; i<piles.length; i+=2){\\n            alice+=piles[i];\\n        }\\n        int bob=0;\\n        for(int i=1; i<piles.length; i+=2){\\n            bob+=piles[i];\\n        }\\n\\n        //end->start\\n        int alice1=0;\\n        for(int i=piles.length-1; i>=0 ; i-=2){\\n            alice1+=piles[i];\\n        }\\n        int bob1=0;\\n        for(int i=piles.length-2; i>=0 ; i-=2){\\n            bob1+=piles[i];\\n        } \\n   \\n        return alice>bob || alice1>bob1;  \\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828784,
                "title": "c-solution-dynamic-programming-clean-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\n    int solve(vector<int>& piles,int i,int j,bool f,vector<vector<int>> &dp){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(f)\\n            return dp[i][j]=max(piles[i]+solve(piles,i+1,j,!f,dp),piles[j]+solve(piles,i,j-1,!f,dp));\\n        \\n        return dp[i][j]=min(solve(piles,i+1,j,!f,dp)-piles[i],solve(piles,i,j-1,!f,dp)-piles[j]);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,0,n-1,1,dp)>0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>& piles,int i,int j,bool f,vector<vector<int>> &dp){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(f)\\n            return dp[i][j]=max(piles[i]+solve(piles,i+1,j,!f,dp),piles[j]+solve(piles,i,j-1,!f,dp));\\n        \\n        return dp[i][j]=min(solve(piles,i+1,j,!f,dp)-piles[i],solve(piles,i,j-1,!f,dp)-piles[j]);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,0,n-1,1,dp)>0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755852,
                "title": "just-1-line-code-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704111,
                "title": "easy-solution-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int a = 0;\\n        int b = 0;\\n        int n = piles.length;\\n        for(int i = 0; i < n/2; i++) {\\n            int min = piles[i];\\n            int max = piles[n-1-i];\\n            a += Math.max(max, min);\\n            b += Math.min(max, min);\\n        }\\n        return a>b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int a = 0;\\n        int b = 0;\\n        int n = piles.length;\\n        for(int i = 0; i < n/2; i++) {\\n            int min = piles[i];\\n            int max = piles[n-1-i];\\n            a += Math.max(max, min);\\n            b += Math.min(max, min);\\n        }\\n        return a>b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638300,
                "title": "what-the-hell-beats-100-code-easy-explanation",
                "content": "see alice is so smart, he knows the way to take so that bob will always lose...\\n\\n\\nfor eg, \\nin test case\\n3,7,2,3\\nalice will pick the 3 on the right instead of the 3 on thr left at start, why so?????\\n\\nbecause if she picks a 3 from the left, bob will pick the 7 in the next move in which bob will win\\n\\nso alice will always pick the path , in which bob looses\\n\\nthe winner was decided in the first move itself, the code is just for clarification\\n\\nyou could simply return true; \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return helper3(piles);\\n    }\\n    public boolean helper3(int[] piles) {\\n        int stonesBob = 0;\\n        int stonesAlice = 0;\\n        int i = 0, j = piles.length - 1;\\n        while (i < j) {\\n            if (piles[i] > piles[j]) {\\n                stonesAlice += piles[i];\\n                stonesBob += piles[j];\\n                i++;\\n                j--;\\n            } else {\\n                stonesAlice += piles[j];\\n                stonesBob += piles[i];\\n                i++;\\n                j--;\\n            }\\n        }\\n        if (stonesAlice > stonesBob) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return helper3(piles);\\n    }\\n    public boolean helper3(int[] piles) {\\n        int stonesBob = 0;\\n        int stonesAlice = 0;\\n        int i = 0, j = piles.length - 1;\\n        while (i < j) {\\n            if (piles[i] > piles[j]) {\\n                stonesAlice += piles[i];\\n                stonesBob += piles[j];\\n                i++;\\n                j--;\\n            } else {\\n                stonesAlice += piles[j];\\n                stonesBob += piles[i];\\n                i++;\\n                j--;\\n            }\\n        }\\n        if (stonesAlice > stonesBob) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572441,
                "title": "classic-easy-memo-style",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, nums: List[int]) -> bool:\\n\\n\\n        dp = {}\\n        def dfs(l,r,alic_turn):\\n\\n            if (l,r,alic_turn) in dp:\\n                return dp[(l,r,alic_turn)]\\n                \\n            if l >= r:\\n                return 0\\n\\n            a = 0\\n            b = 0\\n            if alic_turn:\\n                # alic takes from front or from back, \\n                # whatever one leads to a better score thats why max()\\n                a = max(dfs(l,r-1, not alic_turn)+nums[r] , dfs(l+1,r, not alic_turn)+nums[l])\\n            else:\\n                # bob takes from front or from back, \\n                # whatever one leads to a better score  \\n                b = max(dfs(l,r-1, not alic_turn) +nums[r], dfs(l+1,r, not alic_turn)+nums[l])\\n            \\n\\n            dp[(l,r,alic_turn)]  = a > b\\n            return a > b\\n\\n\\n        return  dfs(0,len(nums)-1,True)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, nums: List[int]) -> bool:\\n\\n\\n        dp = {}\\n        def dfs(l,r,alic_turn):\\n\\n            if (l,r,alic_turn) in dp:\\n                return dp[(l,r,alic_turn)]\\n                \\n            if l >= r:\\n                return 0\\n\\n            a = 0\\n            b = 0\\n            if alic_turn:\\n                # alic takes from front or from back, \\n                # whatever one leads to a better score thats why max()\\n                a = max(dfs(l,r-1, not alic_turn)+nums[r] , dfs(l+1,r, not alic_turn)+nums[l])\\n            else:\\n                # bob takes from front or from back, \\n                # whatever one leads to a better score  \\n                b = max(dfs(l,r-1, not alic_turn) +nums[r], dfs(l+1,r, not alic_turn)+nums[l])\\n            \\n\\n            dp[(l,r,alic_turn)]  = a > b\\n            return a > b\\n\\n\\n        return  dfs(0,len(nums)-1,True)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571966,
                "title": "o-1-time-solution-p",
                "content": "# Intuition\\nAlice always wins.\\n\\n# Code\\n```\\nfunc stoneGame(piles []int) bool {\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc stoneGame(piles []int) bool {\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565279,
                "title": "python-3-dp",
                "content": "# Intuition\\ndp\\n\\n# Approach\\ndp\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n\\n        n: int = len(piles)\\n        first: List[List[int]] = [[0] * n for _ in range(n)]\\n        second: List[List[int]] = [[0] * n for _ in range(n)]\\n        for j in range(n):\\n            first[j][j] = piles[j]\\n            for i in range(j - 1, -1, -1):\\n                first[i][j] = max(piles[i] + second[i + 1][j], piles[j] + second[i][j - 1])\\n                second[i][j] = min(first[i + 1][j], first[i][j - 1])\\n        \\n        return first[n-1][n-1] > second[n-1][n-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n\\n        n: int = len(piles)\\n        first: List[List[int]] = [[0] * n for _ in range(n)]\\n        second: List[List[int]] = [[0] * n for _ in range(n)]\\n        for j in range(n):\\n            first[j][j] = piles[j]\\n            for i in range(j - 1, -1, -1):\\n                first[i][j] = max(piles[i] + second[i + 1][j], piles[j] + second[i][j - 1])\\n                second[i][j] = min(first[i + 1][j], first[i][j - 1])\\n        \\n        return first[n-1][n-1] > second[n-1][n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563672,
                "title": "simple-check-for-even-or-odd-faster",
                "content": "To determine whether Alice or Bob will win the game, we need to analyze the game\\'s strategy and consider the initial configuration of piles.\\n\\nLet\\'s consider an example to illustrate the strategy:\\n\\nPiles: [5, 3, 4, 5]\\n\\nAlice starts the game, and the total number of stones across all piles is 17, which is an odd number.\\n\\nAt each turn, a player can choose to take the entire pile of stones from either the beginning or the end of the row. Both players aim to maximize the total number of stones they collect.\\n\\nAlice has the first move, so she has the opportunity to establish an advantage over Bob.\\n\\nAlice\\'s strategy:\\nAlice wants to ensure that the total number of stones she collects is greater than or equal to the total number of stones Bob collects.\\n\\nTo achieve this, Alice can adopt the following approach:\\n\\n1. Alice selects the first pile with 5 stones from the beginning.\\n   Piles: [3, 4, 5]\\n\\n2. Bob is now forced to choose either the first pile (3 stones) or the last pile (5 stones).\\n   Bob chooses the last pile.\\n   Piles: [3, 4]\\n\\n3. Alice now has two options: either the first pile (3 stones) or the last pile (4 stones).\\n   Alice chooses the last pile.\\n   Piles: [3]\\n\\n4. Bob has only one option left, which is the first pile with 3 stones.\\n   Piles: []\\n\\nAt this point, no piles remain, and the game is over. Alice collected a total of 9 stones, while Bob collected 8 stones.\\n\\nSince Alice has more stones than Bob, she wins the game.\\n\\nIn general, Alice can use a strategy known as \"greedy strategy\" to ensure victory. She aims to maximize the number of stones she collects at each turn, forcing Bob to settle for fewer stones.\\n\\nTherefore, given that Alice plays optimally, she will win the game if and only if the initial total number of stones across all piles is odd.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=piles[i];\\n        }\\n        if(sum%2==0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=piles[i];\\n        }\\n        if(sum%2==0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530758,
                "title": "always-true-stone-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6de4dd90-8837-4eca-a560-bd1384f947a9_1684239785.8552122.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508578,
                "title": "easy-dp-solution-java-recursion-memorization",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    Boolean[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        this.nums = piles;\\n        this.dp = new Boolean[piles.length][piles.length];\\n        return helper(0, piles.length - 1, 0, 0, true);\\n    }\\n    public boolean helper(int i, int j, int count1, int count2, boolean turn) {\\n        if(i > j) {\\n            if(count1 > count2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if(dp[i][j] != null) return dp[i][j];\\n        boolean take = false;\\n        if(turn) {\\n            take = helper(i + 1, j, count1 + nums[i], count2, false) || helper(i, j - 1, count1 + nums[j], count2, false);\\n        } else {\\n            take = helper(i + 1, j, count1, count2  + nums[i], true) || helper(i, j - 1, count1, count2 + nums[j], true);\\n        }\\n        return dp[i][j] = take;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    Boolean[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        this.nums = piles;\\n        this.dp = new Boolean[piles.length][piles.length];\\n        return helper(0, piles.length - 1, 0, 0, true);\\n    }\\n    public boolean helper(int i, int j, int count1, int count2, boolean turn) {\\n        if(i > j) {\\n            if(count1 > count2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if(dp[i][j] != null) return dp[i][j];\\n        boolean take = false;\\n        if(turn) {\\n            take = helper(i + 1, j, count1 + nums[i], count2, false) || helper(i, j - 1, count1 + nums[j], count2, false);\\n        } else {\\n            take = helper(i + 1, j, count1, count2  + nums[i], true) || helper(i, j - 1, count1, count2 + nums[j], true);\\n        }\\n        return dp[i][j] = take;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419295,
                "title": "simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int aliceStones =0;\\n        int bobStones = 0;\\n\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for (int i: piles){\\n            list.add (i);\\n        }\\n\\n        for (int round=0; round < piles.length /2; round++){\\n            int first = list.get(0);\\n            int last = list.get(list.size()-1);\\n\\n            aliceStones += Math.max (first, last);\\n            bobStones += Math.min (first, last);   \\n            \\n            list.removeFirst();\\n            list.removeLast();\\n        }\\n        \\n        return aliceStones > bobStones;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int aliceStones =0;\\n        int bobStones = 0;\\n\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for (int i: piles){\\n            list.add (i);\\n        }\\n\\n        for (int round=0; round < piles.length /2; round++){\\n            int first = list.get(0);\\n            int last = list.get(list.size()-1);\\n\\n            aliceStones += Math.max (first, last);\\n            bobStones += Math.min (first, last);   \\n            \\n            list.removeFirst();\\n            list.removeLast();\\n        }\\n        \\n        return aliceStones > bobStones;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566897,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565768,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1572939,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569412,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565761,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570009,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1566297,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570427,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569636,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1568105,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1566897,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565768,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1572939,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569412,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565761,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570009,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1566297,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570427,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569636,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1568105,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1787095,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1573759,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572473,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1569266,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1575051,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1575409,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572395,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572182,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572054,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1568104,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1568743,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1570470,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575617,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575615,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575614,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575364,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2053587,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2047978,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2045540,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2033799,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2022866,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2015746,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2014594,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2010838,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2010837,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1980454,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1980451,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1973899,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1959234,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1936980,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1929482,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1908347,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1907265,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1907185,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906971,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906960,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906278,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906132,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1905758,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1905217,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1810969,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1796038,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1777425,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1724073,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1719173,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1684214,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1629592,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1575280,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1575031,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1574888,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            }
        ]
    }
]