[
    {
        "title": "Smallest Value After Replacing With Sum of Prime Factors",
        "question_content": "You are given a positive integer n.\nContinuously replace n with the sum of its prime factors.\n\n\tNote that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n.\n\nReturn the smallest value n will take on.\n&nbsp;\nExample 1:\n\nInput: n = 15\nOutput: 5\nExplanation: Initially, n = 15.\n15 = 3 * 5, so replace n with 3 + 5 = 8.\n8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.\n6 = 2 * 3, so replace n with 2 + 3 = 5.\n5 is the smallest value n will take on.\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: Initially, n = 3.\n3 is the smallest value n will take on.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 105",
        "solutions": [
            {
                "id": 2923624,
                "title": "c-simple-prime-factorization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getSumOfFactors(int n)\\n    {\\n        int divisor = 2;\\n        long long ans = 0;\\n        while(n > 1)\\n        {\\n            if (n % divisor == 0) \\n            {\\n                ans += divisor;\\n                n = n / divisor;\\n            }\\n            else divisor++;\\n        }\\n        return ans;\\n    }\\n    int smallestValue(int n) \\n    {   \\n        while(true)\\n        {\\n            long long sumOfFactors = getSumOfFactors(n);\\n            if (n == sumOfFactors) break;\\n            n = sumOfFactors;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getSumOfFactors(int n)\\n    {\\n        int divisor = 2;\\n        long long ans = 0;\\n        while(n > 1)\\n        {\\n            if (n % divisor == 0) \\n            {\\n                ans += divisor;\\n                n = n / divisor;\\n            }\\n            else divisor++;\\n        }\\n        return ans;\\n    }\\n    int smallestValue(int n) \\n    {   \\n        while(true)\\n        {\\n            long long sumOfFactors = getSumOfFactors(n);\\n            if (n == sumOfFactors) break;\\n            n = sumOfFactors;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923847,
                "title": "simple-java-prime-factorization",
                "content": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int sum=n;\\n        while(true){\\n            int sum1=0;\\n            int c=2;\\n            //for prime factors\\n            while(n>1){\\n                \\n                if(n%c==0){\\n                    sum1+=c;\\n                    n=n/c;\\n                }\\n                else c++;\\n            }\\n            n=sum1;\\n            // no more less sum can encounter\\n            if(sum==sum1)break;\\n            else sum=sum1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int sum=n;\\n        while(true){\\n            int sum1=0;\\n            int c=2;\\n            //for prime factors\\n            while(n>1){\\n                \\n                if(n%c==0){\\n                    sum1+=c;\\n                    n=n/c;\\n                }\\n                else c++;\\n            }\\n            n=sum1;\\n            // no more less sum can encounter\\n            if(sum==sum1)break;\\n            else sum=sum1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923506,
                "title": "python-c-prime-factorization-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs prime factorization.\\n****\\n\\n**Comment.** The idea of this solution relies on the fact that a number is not less than the sum of its primes. Equality is attained for the prime numbers themselves and also for the number 4. Thus we can iteratively decompose `n` into primes and compute their sum until the sequence stabilizes.\\n\\n**Python #1.**\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        \\n        def primes(n, s=0):\\n            for i in range(2,n+1):\\n                while n % i == 0:\\n                    s += i\\n                    n //= i\\n            return s\\n        \\n        while n != (n:=primes(n)): pass\\n        \\n        return n\\n```\\n\\n**Python #2.** This can be compactified even further.\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n\\n        m, s = n, 0\\n        for i in range(2,n+1):\\n            while m % i == 0:\\n                s += i\\n                m //= i\\n\\n        return s if s == n else self.smallestValue(s)\\n```\\n\\n**C++.** The solution above compressed into three lines of code.\\n```\\nclass Solution \\n{\\npublic:\\n    int smallestValue(int n, int s = 0) \\n    {\\n        for (int i = 2, m = n; i <= n; i++)\\n            for(; m % i == 0; s += i, m /= i);\\n        return s == n ? n : smallestValue(s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        \\n        def primes(n, s=0):\\n            for i in range(2,n+1):\\n                while n % i == 0:\\n                    s += i\\n                    n //= i\\n            return s\\n        \\n        while n != (n:=primes(n)): pass\\n        \\n        return n\\n```\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n\\n        m, s = n, 0\\n        for i in range(2,n+1):\\n            while m % i == 0:\\n                s += i\\n                m //= i\\n\\n        return s if s == n else self.smallestValue(s)\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int smallestValue(int n, int s = 0) \\n    {\\n        for (int i = 2, m = n; i <= n; i++)\\n            for(; m % i == 0; s += i, m /= i);\\n        return s == n ? n : smallestValue(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923513,
                "title": "very-simple-recursion",
                "content": "```\\n\\n/*\\nHere we use the theorem to optimize the runtime, that is prime no can be always in the form of 6k+1 or 6k-1, except 2 & 3\\nSo we only itereate on 2, 3, 6k-1 & 6k + 1\\nWe have return a separate function that just keep on evluating the sum of all factor and return total sum.\\n*/\\nclass Solution {\\npublic:\\n    int find(int n, int i, int j, bool b){ \\n        if(n <= i) return n;\\n        if(n%i == 0) {\\n            return i + find(n/i, i, j, b);\\n        }\\n        int t = 0;\\n        if(i == 2) t = 3;\\n        else{\\n            if(b) { t = j*6+1; j++; }\\n            else t = j*6-1;\\n            b = !b;\\n        }\\n        return find(n, t, j, b );\\n    }\\n    int smallestValue(int n) {\\n        while(1){\\n            int t = find(n, 2, 1, false);\\n            if(t == n) return n;\\n            n = t;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n/*\\nHere we use the theorem to optimize the runtime, that is prime no can be always in the form of 6k+1 or 6k-1, except 2 & 3\\nSo we only itereate on 2, 3, 6k-1 & 6k + 1\\nWe have return a separate function that just keep on evluating the sum of all factor and return total sum.\\n*/\\nclass Solution {\\npublic:\\n    int find(int n, int i, int j, bool b){ \\n        if(n <= i) return n;\\n        if(n%i == 0) {\\n            return i + find(n/i, i, j, b);\\n        }\\n        int t = 0;\\n        if(i == 2) t = 3;\\n        else{\\n            if(b) { t = j*6+1; j++; }\\n            else t = j*6-1;\\n            b = !b;\\n        }\\n        return find(n, t, j, b );\\n    }\\n    int smallestValue(int n) {\\n        while(1){\\n            int t = find(n, 2, 1, false);\\n            if(t == n) return n;\\n            n = t;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923497,
                "title": "prime-factorization",
                "content": "We prepare the list of primes to cover up to `sqrt(10,000)`. You can either precompute them, or just use a static array.\\n\\n> This is an important optimization. We check up to 65 primes for `n`, and the complexity is \\u03C0(sqrt(n)).\\n> If, after we try all primes, `n > 1`, then `n` is a large prime. E.g. for 99951 example, the factorization looks like (33317 is a large prime):\\n> ```\\n> 99951: 3 33317\\n> 33320: 2 2 2 5 7 7 17\\n> 42: 2 3 7 1\\n> 12: 2 2 3 1\\n> 7: 7\\n> ```\\n\\nWe try to each prime and `sum` the divisors, tracking the division result in `res`. If the `sum` equal `n`, then we take on `n`. If the `sum` is zero, `n` is the large prime, and we take on `n`.\\n\\nOthersise, we recurse on `sum`. Note that if `res > 1`, this is a large prime and we need to recurse on `sum + res`.\\n\\n**C++**\\n```cpp\\nint p[65] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n    101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n    211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\nint smallestValue(int n) {\\n    int sum = 0, res = n;\\n    for (int i = 0; i < 65 && res >= p[i]; ++i)\\n        while (res % p[i] == 0) {\\n            sum += p[i];\\n            res /= p[i];\\n        }\\n    return (sum == 0 || sum == n) ? n : smallestValue(sum + (res == 1 ? 0 : res));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n> 99951: 3 33317\\n> 33320: 2 2 2 5 7 7 17\\n> 42: 2 3 7 1\\n> 12: 2 2 3 1\\n> 7: 7\\n> ```\n```cpp\\nint p[65] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n    101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n    211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\nint smallestValue(int n) {\\n    int sum = 0, res = n;\\n    for (int i = 0; i < 65 && res >= p[i]; ++i)\\n        while (res % p[i] == 0) {\\n            sum += p[i];\\n            res /= p[i];\\n        }\\n    return (sum == 0 || sum == n) ? n : smallestValue(sum + (res == 1 ? 0 : res));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924053,
                "title": "straight-forward-easy-reacursion-prime-factorization",
                "content": "Base case:  If n is prime it means we can not subdivide it, means it is in its minimum form hence return it.\\n\\nIf the sum_of_prime_factors_of_n == n then it means we can not reduce it so we return n otherwise it will create infinite loop.\\n\\n# Code\\n```\\nclass Solution {\\n    bool isPrime(int n){\\n        for(int i = 2;i * i <= n;i++){\\n            if(n % i == 0)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int smallestValue(int n) {\\n\\n        if(isPrime(n))return n;\\n\\n        int x = n;\\n        int sum = 0;\\n        //Sum all the prime factors of n\\n        for(int i = 2;i * i <= n;i++){\\n            while(x % i == 0){\\n                sum += i;\\n                x /= i;\\n            }\\n        }\\n        if(x > 1)sum += x;\\n\\n        if(sum == n)return n;\\n\\n        return smallestValue(sum);\\n    }\\n};\\n```\\nPlease Upvote if you found it helpfull\\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isPrime(int n){\\n        for(int i = 2;i * i <= n;i++){\\n            if(n % i == 0)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int smallestValue(int n) {\\n\\n        if(isPrime(n))return n;\\n\\n        int x = n;\\n        int sum = 0;\\n        //Sum all the prime factors of n\\n        for(int i = 2;i * i <= n;i++){\\n            while(x % i == 0){\\n                sum += i;\\n                x /= i;\\n            }\\n        }\\n        if(x > 1)sum += x;\\n\\n        if(sum == n)return n;\\n\\n        return smallestValue(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923645,
                "title": "beginner-friendly-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(n == 0 || n == 4)  return 4;\\n        return factors(n);\\n    }\\n    private int factors(int n){\\n        int i, sum = 0;\\n        for(i=2; i<=n; i++){\\n            while(n%i == 0){\\n                sum += i;\\n                n /= i;\\n            }\\n        }\\n        return isPrime(sum) ? sum : factors(sum);     \\n    }\\n    private boolean isPrime(int sum){\\n        for(int i=2; i<sum/2; i++){\\n            if(sum % i == 0)    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(n == 0 || n == 4)  return 4;\\n        return factors(n);\\n    }\\n    private int factors(int n){\\n        int i, sum = 0;\\n        for(i=2; i<=n; i++){\\n            while(n%i == 0){\\n                sum += i;\\n                n /= i;\\n            }\\n        }\\n        return isPrime(sum) ? sum : factors(sum);     \\n    }\\n    private boolean isPrime(int sum){\\n        for(int i=2; i<sum/2; i++){\\n            if(sum % i == 0)    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923573,
                "title": "c-java-python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af6e415cd101768ea8743ea9e4d22d788c9461c3) for solutions of weekly 324. \\n\\n**Intuition**\\nWe can simply repeatedly compute the sum of prime factors of each number and see where it ends. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic: \\n\\tint smallestValue(int n) {\\n\\t\\twhile (true) {\\n\\t\\t\\tint sm = 0; \\n\\t\\t\\tfor (int f = 2, nn = n; f <= nn; ++f) \\n\\t\\t\\t\\tfor (; nn % f == 0; nn /= f, sm += f); \\n\\t\\t\\tif (sm == n) break; \\n\\t\\t\\tn = sm;\\n\\t\\t}\\n\\t\\treturn n; \\n\\t}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic int smallestValue(int n) {\\n\\t\\twhile (true) {\\n\\t\\t\\tint s = 0; \\n\\t\\t\\tfor (int f = 2, x = n; f <= x; ++f)\\n\\t\\t\\t\\tfor (; x % f == 0; x /= f)\\n\\t\\t\\t\\t\\ts += f; \\n\\t\\t\\tif (s == n) break; \\n\\t\\t\\tn = s; \\n\\t\\t}\\n\\t\\treturn n; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n\\tdef smallestValue(self, n: int) -> int: \\n\\t\\twhile True: \\n\\t\\t\\tnn, sm = n, 0\\n\\t\\t\\tfor f in range(2, nn+1): \\n\\t\\t\\t\\twhile nn % f == 0: \\n\\t\\t\\t\\t\\tnn //= f \\n\\t\\t\\t\\t\\tsm += f\\n\\t\\t\\tif sm == n: break \\n\\t\\t\\tn = sm \\n\\t\\treturn n\\n```\\n**Complexity**\\nTime \\nSpace O(1)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n\\tint smallestValue(int n) {\\n\\t\\twhile (true) {\\n\\t\\t\\tint sm = 0; \\n\\t\\t\\tfor (int f = 2, nn = n; f <= nn; ++f) \\n\\t\\t\\t\\tfor (; nn % f == 0; nn /= f, sm += f); \\n\\t\\t\\tif (sm == n) break; \\n\\t\\t\\tn = sm;\\n\\t\\t}\\n\\t\\treturn n; \\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tpublic int smallestValue(int n) {\\n\\t\\twhile (true) {\\n\\t\\t\\tint s = 0; \\n\\t\\t\\tfor (int f = 2, x = n; f <= x; ++f)\\n\\t\\t\\t\\tfor (; x % f == 0; x /= f)\\n\\t\\t\\t\\t\\ts += f; \\n\\t\\t\\tif (s == n) break; \\n\\t\\t\\tn = s; \\n\\t\\t}\\n\\t\\treturn n; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n\\tdef smallestValue(self, n: int) -> int: \\n\\t\\twhile True: \\n\\t\\t\\tnn, sm = n, 0\\n\\t\\t\\tfor f in range(2, nn+1): \\n\\t\\t\\t\\twhile nn % f == 0: \\n\\t\\t\\t\\t\\tnn //= f \\n\\t\\t\\t\\t\\tsm += f\\n\\t\\t\\tif sm == n: break \\n\\t\\t\\tn = sm \\n\\t\\treturn n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923499,
                "title": "c-using-sieve",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sieve(int n){\\n        vector<int> isPrime(n+1, 1);\\n        isPrime[0] = isPrime[1] = 0;\\n        \\n        vector<int> prime;\\n        for(int i = 2; i <= n; i++){\\n            if(isPrime[i]){\\n                prime.push_back(i);\\n                for(long long j = (long long)i*i; j <= n; j += i) isPrime[j] = 0;\\n            }\\n        }\\n        return prime;\\n    }\\n    \\n    int smallestValue(int n) {\\n        /* generate prime numbers less than equal to n */\\n        vector<int> primes = sieve(n);\\n        \\n        while(true){\\n            int cur = n;\\n            int sum = 0;\\n            \\n            /* generate prime factors */\\n            for(int i = 0; i < primes.size() && primes[i]*primes[i] <= n; i++){\\n                while(n % primes[i] == 0){\\n                    n /= primes[i];\\n                    sum += primes[i];\\n                }\\n            }\\n            sum += (n != 1 ? n : 0);   // if last number is prime itself, it cannot be furthur broken down -> add it\\n\\n            if(sum == cur) return cur;  // if number was not further decomposable, return it\\n            n = sum;\\n        }\\n        return -1;  // never executes\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sieve(int n){\\n        vector<int> isPrime(n+1, 1);\\n        isPrime[0] = isPrime[1] = 0;\\n        \\n        vector<int> prime;\\n        for(int i = 2; i <= n; i++){\\n            if(isPrime[i]){\\n                prime.push_back(i);\\n                for(long long j = (long long)i*i; j <= n; j += i) isPrime[j] = 0;\\n            }\\n        }\\n        return prime;\\n    }\\n    \\n    int smallestValue(int n) {\\n        /* generate prime numbers less than equal to n */\\n        vector<int> primes = sieve(n);\\n        \\n        while(true){\\n            int cur = n;\\n            int sum = 0;\\n            \\n            /* generate prime factors */\\n            for(int i = 0; i < primes.size() && primes[i]*primes[i] <= n; i++){\\n                while(n % primes[i] == 0){\\n                    n /= primes[i];\\n                    sum += primes[i];\\n                }\\n            }\\n            sum += (n != 1 ? n : 0);   // if last number is prime itself, it cannot be furthur broken down -> add it\\n\\n            if(sum == cur) return cur;  // if number was not further decomposable, return it\\n            n = sum;\\n        }\\n        return -1;  // never executes\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923637,
                "title": "c-simple-prime-factorisation-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        while(n){\\n            int sum = 0;\\n            int prev = n;\\n            for(int i=2;i<=n;){\\n                if(n%i ==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            if(prev == sum )return sum;\\n            if(sum == 0)return n;\\n            n=sum;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        while(n){\\n            int sum = 0;\\n            int prev = n;\\n            for(int i=2;i<=n;){\\n                if(n%i ==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            if(prev == sum )return sum;\\n            if(sum == 0)return n;\\n            n=sum;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923483,
                "title": "java-simplest-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If a number is prime, that is the smallest value itself.\\n2. Else Calculate the sum of prime factors\\n    - Calculate first prime factor.\\n    - Add in sum\\n    - Calculate remainder\\n    - Reapeat above steps till remainder is prime.\\n    - Add remainder in sum\\n3. if sum is equal to input, it will run indefinitely, so we return the value.\\n4. Else we will repeat All above steps for the sum.\\n\\n# Complexity\\n- Time complexity: O(nlogn) (Always better than this)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(isPrime(n)) return n; // otherwise it will run forever\\n        int sum = getPrimeFactorSum(n);\\n        if(sum == n) return n;  // otherwise it will run forever\\n        return smallestValue(sum);\\n    }\\n    \\n    public boolean isPrime(int n) { // to check if number is prime\\n        if(n == 2) return true;\\n        for(int i = 2; i < Math.sqrt(n) + 1; i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int getFirstPrimeFactor(int n) { // to get first prime number\\n        if(isPrime(n)) return n;\\n        for(int i = 2; i < n; i++) {\\n            if(n % i == 0) return i;\\n        }\\n        return n;\\n    }\\n\\n    public int getPrimeFactorSum(int n) { //sum of prime factors of a number\\n        int sum = 0;\\n        while(!isPrime(n)) {\\n            int m = getFirstPrimeFactor(n);\\n            n /= m;\\n            sum += m;\\n        }\\n        sum += n;\\n        return sum;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(isPrime(n)) return n; // otherwise it will run forever\\n        int sum = getPrimeFactorSum(n);\\n        if(sum == n) return n;  // otherwise it will run forever\\n        return smallestValue(sum);\\n    }\\n    \\n    public boolean isPrime(int n) { // to check if number is prime\\n        if(n == 2) return true;\\n        for(int i = 2; i < Math.sqrt(n) + 1; i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int getFirstPrimeFactor(int n) { // to get first prime number\\n        if(isPrime(n)) return n;\\n        for(int i = 2; i < n; i++) {\\n            if(n % i == 0) return i;\\n        }\\n        return n;\\n    }\\n\\n    public int getPrimeFactorSum(int n) { //sum of prime factors of a number\\n        int sum = 0;\\n        while(!isPrime(n)) {\\n            int m = getFirstPrimeFactor(n);\\n            n /= m;\\n            sum += m;\\n        }\\n        sum += n;\\n        return sum;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926405,
                "title": "c-commented-code",
                "content": "class Solution {\\npublic:\\n    \\n    //**** Function to create a hash array for prime numbers till n ****.\\n    vector<int> hashprime(int n){\\n        vector<int> arr(n,0);\\n\\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = i;\\n        }\\n        arr[0] = arr[1] = 0;\\n        for(int i = 2 ; i < n ; i++){\\n            if(arr[i] != 0){\\n                for(int ind = i+i; ind < n ; ind += i){\\n                    arr[ind] = 0;\\n                }\\n            }\\n        }\\n\\n        return arr;\\n    }\\n    \\n    int smallestValue(int n) {\\n        int ans = n;\\n        \\n        vector<int> hash = hashprime(n+1); \\n        \\n        // while hash is not a prime number we will iterate.\\n        \\n        while(!hash[ans]){\\n            \\n            int newno = 0; // Variable to store the sum of prime factors.\\n            \\n            // storing current number to maintain the for loop in next line.\\n            int sz  = ans;\\n            \\n            for(int i = 2 ; i  <= sz/2; i++){\\n                while(ans%i == 0){\\n                    newno += i;\\n                    ans /= i;\\n                }\\n            }\\n            \\n        // if the number is equal to the sum of its prime factors then return in order to avoid infinite loop.\\n            if(sz == newno)\\n                return newno;\\n            \\n            // replace original number with sum of its prime factors.\\n            \\n            ans = newno;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //**** Function to create a hash array for prime numbers till n ****.\\n    vector<int> hashprime(int n){\\n        vector<int> arr(n,0);\\n\\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2923638,
                "title": "two-solution-factorization-is-optimized-using-sieve-of-eratosthenes",
                "content": "# Intuition\\nWe know that product of numbers are always greater than sum of numbers, if the numbers are greater than 1. Hence,  we repeatedly find the sum of the factors of a given number until the sum is itself. \\n\\n\\n# Space Complexity: $\\\\mathcal{O}(1)$\\n\\n\\n# Solution 1\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while n != (n:=self.factorization(n)) pass\\n        return n\\n    \\n    def factorization(self, n):\\n        factors_sum = 0\\n        i = 2\\n        while n > 1:\\n            while n % i == 0:\\n                n //= i\\n                factors_sum +=i\\n            i += 1\\n        return factors_sum\\n        \\n        \\n```\\n# Solution 2\\nPre-compute a list of prime numbers up to the n using Sieve of Eratosthenes and store them. https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes. This algorithm is a fastest algorithm to find prime factors.\\n\\nThen use precomputed primes to avoid checking primality of the number during factorization. \\n\\n# Worst case Space Complexity: $\\\\mathcal{O}(\\\\sqrt{n})$\\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        self.primes = self.sieve_of_eratosthenes(n)\\n        while n != (n:=self.factorization(n)) pass\\n        return n\\n\\n    def factorization(self, n):\\n        factors = 0\\n        for prime in self.primes:\\n            while n % prime == 0:\\n                n //= prime\\n                factors += prime\\n            if n==1: break\\n        return factors\\n    \\n    def sieve_of_eratosthenes(self, n):\\n        primes = [True] * (n + 1)\\n        primes[0] = primes[1] = False\\n        for i in range(2, int(n ** 0.5) + 1):\\n            if primes[i]:\\n                for j in range(i ** 2, n + 1, i): primes[j] = False\\n        return [i for i in range(2, n + 1) if primes[i]]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while n != (n:=self.factorization(n)) pass\\n        return n\\n    \\n    def factorization(self, n):\\n        factors_sum = 0\\n        i = 2\\n        while n > 1:\\n            while n % i == 0:\\n                n //= i\\n                factors_sum +=i\\n            i += 1\\n        return factors_sum\\n        \\n        \\n```\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        self.primes = self.sieve_of_eratosthenes(n)\\n        while n != (n:=self.factorization(n)) pass\\n        return n\\n\\n    def factorization(self, n):\\n        factors = 0\\n        for prime in self.primes:\\n            while n % prime == 0:\\n                n //= prime\\n                factors += prime\\n            if n==1: break\\n        return factors\\n    \\n    def sieve_of_eratosthenes(self, n):\\n        primes = [True] * (n + 1)\\n        primes[0] = primes[1] = False\\n        for i in range(2, int(n ** 0.5) + 1):\\n            if primes[i]:\\n                for j in range(i ** 2, n + 1, i): primes[j] = False\\n        return [i for i in range(2, n + 1) if primes[i]]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923529,
                "title": "simple-c",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primeFactorsFind(int n)\\n    {\\n        int newNum=0;\\n        while (n % 2 == 0)\\n        {\\n            newNum += 2;\\n            n = n/2;\\n        }\\n\\n       \\n        for (int i = 3; i <= sqrt(n); i = i + 2)\\n        {\\n           \\n            while (n % i == 0)\\n            {\\n                 newNum += i;\\n                n = n/i;\\n            }\\n        }\\n\\n        if (n > 2)\\n            newNum += n;\\n        return newNum;\\n    }\\n    \\n    bool isPrimeNum(int n)\\n    {\\n        \\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        unordered_set<int> st;\\n        \\n        while(1){\\n            \\n            st.insert(n);\\n            \\n            //checking wheteher n is prime or not\\n            if(isPrimeNum(n))   \\n                return n;\\n            \\n            //finding sum of it\\'s prime factors\\n            n = primeFactorsFind(n);\\n            \\n            //checking whether value of n is repeating or not\\n            if(st.find(n) != st.end()){\\n                return n;\\n            }\\n            \\n        }\\n        return n;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primeFactorsFind(int n)\\n    {\\n        int newNum=0;\\n        while (n % 2 == 0)\\n        {\\n            newNum += 2;\\n            n = n/2;\\n        }\\n\\n       \\n        for (int i = 3; i <= sqrt(n); i = i + 2)\\n        {\\n           \\n            while (n % i == 0)\\n            {\\n                 newNum += i;\\n                n = n/i;\\n            }\\n        }\\n\\n        if (n > 2)\\n            newNum += n;\\n        return newNum;\\n    }\\n    \\n    bool isPrimeNum(int n)\\n    {\\n        \\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        unordered_set<int> st;\\n        \\n        while(1){\\n            \\n            st.insert(n);\\n            \\n            //checking wheteher n is prime or not\\n            if(isPrimeNum(n))   \\n                return n;\\n            \\n            //finding sum of it\\'s prime factors\\n            n = primeFactorsFind(n);\\n            \\n            //checking whether value of n is repeating or not\\n            if(st.find(n) != st.end()){\\n                return n;\\n            }\\n            \\n        }\\n        return n;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923486,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int k=n;\\n        if(n<=4)\\n            return n;\\n\\t\\twhile(true)\\n        {\\n            int sum=0;\\n            for (int i=2;i<=n/2;i++)\\n            {\\n                //System.out.println(i);\\n                if(prime(i))\\n                {\\n                    while(n%i==0)\\n                    {\\n                        sum+=i;\\n                        n/=i;\\n                        //System.out.println(i);\\n                    }\\n                }\\n\\t\\t    }\\n            if(n==1)\\n            {\\n                sum-=1;\\n            }\\n\\t\\t    sum+=n;\\n\\t\\t    if(n==sum)\\n\\t\\t    {\\n                k=sum;\\n                break;\\n\\t\\t    }\\n\\t\\t    else\\n\\t\\t    {\\n                n=sum;\\n                k=sum;\\n\\t\\t    }\\n        }\\n\\t\\treturn k;\\n    }\\n    public boolean prime(int n)\\n    {\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int k=n;\\n        if(n<=4)\\n            return n;\\n\\t\\twhile(true)\\n        {\\n            int sum=0;\\n            for (int i=2;i<=n/2;i++)\\n            {\\n                //System.out.println(i);\\n                if(prime(i))\\n                {\\n                    while(n%i==0)\\n                    {\\n                        sum+=i;\\n                        n/=i;\\n                        //System.out.println(i);\\n                    }\\n                }\\n\\t\\t    }\\n            if(n==1)\\n            {\\n                sum-=1;\\n            }\\n\\t\\t    sum+=n;\\n\\t\\t    if(n==sum)\\n\\t\\t    {\\n                k=sum;\\n                break;\\n\\t\\t    }\\n\\t\\t    else\\n\\t\\t    {\\n                n=sum;\\n                k=sum;\\n\\t\\t    }\\n        }\\n\\t\\treturn k;\\n    }\\n    public boolean prime(int n)\\n    {\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837511,
                "title": "c-maths",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int x ,k,i;\\n        while(n){\\n            x = 0;\\n            k = n;\\n            for(i = 2; i <= sqrt(n); i++){\\n                while(n%i == 0){\\n                    x += i;\\n                    n /= i;\\n                }\\n            }\\n            if(n>1)x += n;\\n            if(k == x)return x;\\n            n = x;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int x ,k,i;\\n        while(n){\\n            x = 0;\\n            k = n;\\n            for(i = 2; i <= sqrt(n); i++){\\n                while(n%i == 0){\\n                    x += i;\\n                    n /= i;\\n                }\\n            }\\n            if(n>1)x += n;\\n            if(k == x)return x;\\n            n = x;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120052,
                "title": "c-easy-solution-using-prime-factarization-and-seive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nint n=1e5;\\nvector<int> prime(n,0);\\nclass Solution {\\npublic:\\nvoid fun(){\\nfor(int i=2;i*i<n;i++){\\n    if(prime[i]==0){\\nfor(int j=i*i;j<n;j+=i){\\n   prime[j]=1;\\n}\\n    }\\n}\\n}\\nint primefactor(int n){\\n int sum=0;\\n           for(int i=2;i<=sqrt(n);i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n          }\\n          if(n>1) \\n           sum+=n;\\n          \\n         \\n          return sum;\\n}\\n\\n    int smallestValue(int n) {\\n          int sum=0;\\n          fun();\\n      while(1){\\n        sum=primefactor(n);\\n       if(prime[sum]==0) return sum;\\n       if(n==sum) break;\\n       n=sum;\\n      }\\n      \\n      return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nint n=1e5;\\nvector<int> prime(n,0);\\nclass Solution {\\npublic:\\nvoid fun(){\\nfor(int i=2;i*i<n;i++){\\n    if(prime[i]==0){\\nfor(int j=i*i;j<n;j+=i){\\n   prime[j]=1;\\n}\\n    }\\n}\\n}\\nint primefactor(int n){\\n int sum=0;\\n           for(int i=2;i<=sqrt(n);i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n          }\\n          if(n>1) \\n           sum+=n;\\n          \\n         \\n          return sum;\\n}\\n\\n    int smallestValue(int n) {\\n          int sum=0;\\n          fun();\\n      while(1){\\n        sum=primefactor(n);\\n       if(prime[sum]==0) return sum;\\n       if(n==sum) break;\\n       n=sum;\\n      }\\n      \\n      return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933274,
                "title": "using-prime-factor",
                "content": "# Intuition\\nUsing prime factore\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int smallestValue(int n) {\\n        int x=n;\\n        int sum=0,j=0;\\n        if(n<=5){\\n            return n;\\n        }\\n        // if(n==4) return \\n        while(true){\\n            int i=2;\\n            sum=0;\\n            while (n>1) {\\n                if(n%i==0){\\n                    sum+=i;\\n                    n=n/i;\\n                }\\n                else i++;\\n            }\\n            n=sum;\\n           if(sum==x) break;\\n           else x=sum;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int smallestValue(int n) {\\n        int x=n;\\n        int sum=0,j=0;\\n        if(n<=5){\\n            return n;\\n        }\\n        // if(n==4) return \\n        while(true){\\n            int i=2;\\n            sum=0;\\n            while (n>1) {\\n                if(n%i==0){\\n                    sum+=i;\\n                    n=n/i;\\n                }\\n                else i++;\\n            }\\n            n=sum;\\n           if(sum==x) break;\\n           else x=sum;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926597,
                "title": "python-3-10-lines-recursion-w-brief-explanation-t-m-128-ms-13-8mb",
                "content": "```\\nclass Solution:\\n    def smallestValue(self, n):\\n\\n        prev, ans = n, 0\\n\\n        while not n%2:                  # 2 is the unique even prime\\n                ans += 2\\n                n//= 2\\n\\n        for i in range(3,n+1,2):        #  <\\u2013\\u2013 prune even divisors...\\n                while not n%i:\\n                    ans += i\\n                    n//= i\\n\\n        return self.smallestValue(ans) if ans != prev else ans\\n```\\n[https://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/submissions/861795582/](http://)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n):\\n\\n        prev, ans = n, 0\\n\\n        while not n%2:                  # 2 is the unique even prime\\n                ans += 2\\n                n//= 2\\n\\n        for i in range(3,n+1,2):        #  <\\u2013\\u2013 prune even divisors...\\n                while not n%i:\\n                    ans += i\\n                    n//= i\\n\\n        return self.smallestValue(ans) if ans != prev else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923867,
                "title": "check-prime",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O((log n) ^ 2)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(log n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        int sqr = sqrt(n);\\n        for(int i = 2; i <= sqr; i++)\\n            if(n % i == 0)\\n                return false;\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(isPrime(n))\\n            return n;\\n        int sum = 0, N = n;\\n        for(int i = 2; i <= n; i++) {\\n            while(n % i == 0) {\\n                n /= i;\\n                sum += i;\\n            }\\n        }\\n        if(sum == N)\\n            return N;\\n        return smallestValue(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        int sqr = sqrt(n);\\n        for(int i = 2; i <= sqr; i++)\\n            if(n % i == 0)\\n                return false;\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(isPrime(n))\\n            return n;\\n        int sum = 0, N = n;\\n        for(int i = 2; i <= n; i++) {\\n            while(n % i == 0) {\\n                n /= i;\\n                sum += i;\\n            }\\n        }\\n        if(sum == N)\\n            return N;\\n        return smallestValue(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923478,
                "title": "easy-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int primes = primeFactors(n);\\n        if(primes ==  n) {\\n            return n;\\n        }\\n        return smallestValue(primes);\\n    }\\n    int primeFactors(int n) {\\n       int result = 0;\\n           while (n % 2 == 0)\\n           {\\n               result += 2;\\n               n = n/2;\\n           }\\n           for (int i = 3; i <= sqrt(n); i = i + 2)\\n           {\\n               while (n % i == 0)\\n               {\\n                   result += i;\\n                   n = n/i;\\n               }\\n           }\\n        if(n > 2) {\\n           result += n;\\n        }\\n     return result;\\n}\\n \\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int primes = primeFactors(n);\\n        if(primes ==  n) {\\n            return n;\\n        }\\n        return smallestValue(primes);\\n    }\\n    int primeFactors(int n) {\\n       int result = 0;\\n           while (n % 2 == 0)\\n           {\\n               result += 2;\\n               n = n/2;\\n           }\\n           for (int i = 3; i <= sqrt(n); i = i + 2)\\n           {\\n               while (n % i == 0)\\n               {\\n                   result += i;\\n                   n = n/i;\\n               }\\n           }\\n        if(n > 2) {\\n           result += n;\\n        }\\n     return result;\\n}\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570881,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int k=n;\\n        if(n<=4)\\n            return n;\\n\\t\\twhile(true)\\n        {\\n            int sum=0;\\n            for (int i=2;i<=n/2;i++)\\n            {\\n                //System.out.println(i);\\n                if(prime(i))\\n                {\\n                    while(n%i==0)\\n                    {\\n                        sum+=i;\\n                        n/=i;\\n                        //System.out.println(i);\\n                    }\\n                }\\n\\t\\t    }\\n            if(n==1)\\n            {\\n                sum-=1;\\n            }\\n\\t\\t    sum+=n;\\n\\t\\t    if(n==sum)\\n\\t\\t    {\\n                k=sum;\\n                break;\\n\\t\\t    }\\n\\t\\t    else\\n\\t\\t    {\\n                n=sum;\\n                k=sum;\\n\\t\\t    }\\n        }\\n\\t\\treturn k;\\n    }\\n    public boolean prime(int n)\\n    {\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int k=n;\\n        if(n<=4)\\n            return n;\\n\\t\\twhile(true)\\n        {\\n            int sum=0;\\n            for (int i=2;i<=n/2;i++)\\n            {\\n                //System.out.println(i);\\n                if(prime(i))\\n                {\\n                    while(n%i==0)\\n                    {\\n                        sum+=i;\\n                        n/=i;\\n                        //System.out.println(i);\\n                    }\\n                }\\n\\t\\t    }\\n            if(n==1)\\n            {\\n                sum-=1;\\n            }\\n\\t\\t    sum+=n;\\n\\t\\t    if(n==sum)\\n\\t\\t    {\\n                k=sum;\\n                break;\\n\\t\\t    }\\n\\t\\t    else\\n\\t\\t    {\\n                n=sum;\\n                k=sum;\\n\\t\\t    }\\n        }\\n\\t\\treturn k;\\n    }\\n    public boolean prime(int n)\\n    {\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924381,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n<=3) return n;\\n        int sum=0;\\n        for(int i=2; i<=n; i++){\\n            while(n%i == 0){\\n                sum += i;\\n                n = n/i;\\n            }\\n        }\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int result = solve(n);\\n        while(true){\\n            int ans = solve(result);\\n            if(ans < result) result = ans;\\n            else return result;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n<=3) return n;\\n        int sum=0;\\n        for(int i=2; i<=n; i++){\\n            while(n%i == 0){\\n                sum += i;\\n                n = n/i;\\n            }\\n        }\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int result = solve(n);\\n        while(true){\\n            int ans = solve(result);\\n            if(ans < result) result = ans;\\n            else return result;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923575,
                "title": "c-simple-solution-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findPrimeFactors(int n) {\\n    vector<int> prime_factors;\\n    // 2 is the smallest prime number\\n    while (n % 2 == 0) {\\n        prime_factors.push_back(2);\\n        n = n / 2;\\n    }\\n    // check for other prime numbers up to sqrt(n)\\n    for (int i = 3; i <= sqrt(n); i += 2) {\\n        while (n % i == 0) {\\n            prime_factors.push_back(i);\\n            n = n / i;\\n        }\\n    }\\n    // if n is a prime number itself, add it to the list\\n    if (n > 2) {\\n        prime_factors.push_back(n);\\n    }\\n    return prime_factors;\\n}\\n    int smallestValue(int n) {\\n        while (true) {\\n        vector<int> prime_factors = findPrimeFactors(n);\\n        int new_n = 0;\\n        for (int i : prime_factors) {\\n            new_n += i;\\n        }\\n        if (new_n == n) {\\n            return n;\\n        } else {\\n            n = new_n;\\n        }\\n    }\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findPrimeFactors(int n) {\\n    vector<int> prime_factors;\\n    // 2 is the smallest prime number\\n    while (n % 2 == 0) {\\n        prime_factors.push_back(2);\\n        n = n / 2;\\n    }\\n    // check for other prime numbers up to sqrt(n)\\n    for (int i = 3; i <= sqrt(n); i += 2) {\\n        while (n % i == 0) {\\n            prime_factors.push_back(i);\\n            n = n / i;\\n        }\\n    }\\n    // if n is a prime number itself, add it to the list\\n    if (n > 2) {\\n        prime_factors.push_back(n);\\n    }\\n    return prime_factors;\\n}\\n    int smallestValue(int n) {\\n        while (true) {\\n        vector<int> prime_factors = findPrimeFactors(n);\\n        int new_n = 0;\\n        for (int i : prime_factors) {\\n            new_n += i;\\n        }\\n        if (new_n == n) {\\n            return n;\\n        } else {\\n            n = new_n;\\n        }\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923528,
                "title": "python3-finding-prime-factors-intuitive-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def prime_factors(self, n):\\n        i = 2\\n        factors = []\\n        while i * i <= n:\\n            if n % i:\\n                i += 1\\n            else:\\n                n //= i\\n                factors.append(i)\\n        if n > 1:\\n            factors.append(n)\\n        return factors\\n    \\n    def smallestValue(self, n: int) -> int:\\n        num = n\\n        seen = set()\\n        while num > 0:\\n            factors = self.prime_factors(num)\\n            if len(factors) == 1:\\n                return factors[0]\\n            num = sum(factors)\\n            if num in seen:\\n                break\\n            seen.add(num)\\n        return num\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def prime_factors(self, n):\\n        i = 2\\n        factors = []\\n        while i * i <= n:\\n            if n % i:\\n                i += 1\\n            else:\\n                n //= i\\n                factors.append(i)\\n        if n > 1:\\n            factors.append(n)\\n        return factors\\n    \\n    def smallestValue(self, n: int) -> int:\\n        num = n\\n        seen = set()\\n        while num > 0:\\n            factors = self.prime_factors(num)\\n            if len(factors) == 1:\\n                return factors[0]\\n            num = sum(factors)\\n            if num in seen:\\n                break\\n            seen.add(num)\\n        return num\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923485,
                "title": "easy-and-simple-recursive-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int f(int n)\\n{\\n    int sm=0;\\n    while (n % 2 == 0)\\n    {\\n        // cout << 2 << \" \";\\n        sm+=2;\\n        n = n/2;\\n    }\\n \\n   \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n         \\n        while (n % i == 0)\\n        {\\n            // cout << i << \" \";\\n            sm+=i;\\n            n = n/i;\\n        }\\n    }\\n \\n    \\n    if (n > 2)\\n        // cout << n << \" \";\\n        sm+=n;\\n        \\n        \\n        return sm;\\n}\\n    int smallestValue(int n) {\\n        int ans=f(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int n)\\n{\\n    int sm=0;\\n    while (n % 2 == 0)\\n    {\\n        // cout << 2 << \" \";\\n        sm+=2;\\n        n = n/2;\\n    }\\n \\n   \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n         \\n        while (n % i == 0)\\n        {\\n            // cout << i << \" \";\\n            sm+=i;\\n            n = n/i;\\n        }\\n    }\\n \\n    \\n    if (n > 2)\\n        // cout << n << \" \";\\n        sm+=n;\\n        \\n        \\n        return sm;\\n}\\n    int smallestValue(int n) {\\n        int ans=f(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3922656,
                "title": "c-javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(sqrt(n))\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int findAns(int n){\\n        int div=2,ans=0;\\n        while(n%2==0){\\n            ans+=2;\\n            n/=2;\\n        }\\n        int res=sqrt(n);\\n        for(int i=3;i<=res;i+=2){\\n            while(n%i==0){\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>2) ans+=n;\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        while(1){\\n            int ans=findAns(n);\\n            if(ans==n) return n;\\n            n=ans;\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar smallestValue = function(n) {\\n    const findAns=(n)=>{\\n        let ans=0;\\n        while(n%2==0){\\n            ans+=2;\\n            n/=2;\\n        }\\n        let res=Math.sqrt(n);\\n        for(let i=3;i<=res;i+=2){\\n            while(n%i==0){\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>2) ans+=n;\\n        return ans;\\n    }\\n    while(1){\\n        let ans=findAns(n);\\n        if(ans==n) return n;\\n        n=ans;\\n    }\\n    return n;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findAns(int n){\\n        int div=2,ans=0;\\n        while(n%2==0){\\n            ans+=2;\\n            n/=2;\\n        }\\n        int res=sqrt(n);\\n        for(int i=3;i<=res;i+=2){\\n            while(n%i==0){\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>2) ans+=n;\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        while(1){\\n            int ans=findAns(n);\\n            if(ans==n) return n;\\n            n=ans;\\n        }\\n        return n;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar smallestValue = function(n) {\\n    const findAns=(n)=>{\\n        let ans=0;\\n        while(n%2==0){\\n            ans+=2;\\n            n/=2;\\n        }\\n        let res=Math.sqrt(n);\\n        for(let i=3;i<=res;i+=2){\\n            while(n%i==0){\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>2) ans+=n;\\n        return ans;\\n    }\\n    while(1){\\n        let ans=findAns(n);\\n        if(ans==n) return n;\\n        n=ans;\\n    }\\n    return n;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432419,
                "title": "simple-maths-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) \\n    {\\n         while(true)\\n         {\\n             int sum = getsum(n);\\n\\n             if(sum == n)\\n             return n;\\n\\n             n= sum;\\n         }    \\n         return -1;\\n    }\\n    int getsum(int n)\\n    {\\n        int sum = 0;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            while((n%i) == 0)\\n            {\\n                sum = sum + i;\\n                n = n /i;\\n            }\\n        }\\n        if(n > 1) sum = sum + n;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) \\n    {\\n         while(true)\\n         {\\n             int sum = getsum(n);\\n\\n             if(sum == n)\\n             return n;\\n\\n             n= sum;\\n         }    \\n         return -1;\\n    }\\n    int getsum(int n)\\n    {\\n        int sum = 0;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            while((n%i) == 0)\\n            {\\n                sum = sum + i;\\n                n = n /i;\\n            }\\n        }\\n        if(n > 1) sum = sum + n;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051979,
                "title": "easy-c-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint  primeFactors(int n ,int  ans)\\n{\\n    int n1=n;\\n    while (n % 2 == 0)\\n    {\\n        ans+=2;\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        while (n % i == 0)\\n        {\\n            ans +=i;\\n            n = n/i;\\n        }\\n    }\\n \\n    if (n > 2){\\n        ans+=n;}\\n        if(ans>=n1){\\n            return n1 ;\\n        }\\n        else{\\n            cout<<ans;\\n            return primeFactors(ans,0);\\n        }\\n}\\n    int smallestValue(int n) {\\n        int ans=0;\\n\\n          return primeFactors( n, ans);\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint  primeFactors(int n ,int  ans)\\n{\\n    int n1=n;\\n    while (n % 2 == 0)\\n    {\\n        ans+=2;\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        while (n % i == 0)\\n        {\\n            ans +=i;\\n            n = n/i;\\n        }\\n    }\\n \\n    if (n > 2){\\n        ans+=n;}\\n        if(ans>=n1){\\n            return n1 ;\\n        }\\n        else{\\n            cout<<ans;\\n            return primeFactors(ans,0);\\n        }\\n}\\n    int smallestValue(int n) {\\n        int ans=0;\\n\\n          return primeFactors( n, ans);\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019325,
                "title": "c-beats-80-recursion-prime-factor",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /* intution : Recursion\\n        base case\\n         if(isPrime(n))\\n          return n;\\n         else\\n          n tak k prime factor nekal le\\n          eg 15 - 2,3,5,7,11,13 -> yaha se calculate newN\\n    */\\n    bool isPrime(int n){\\n     for(int i = 2;i * i <= n;i++){\\n            if(n % i == 0)return false;\\n        }\\n     return true;\\n}  \\n    int solve(int n)\\n    {\\n        // base case\\n    if(isPrime(n)){\\n            return n;\\n    }\\n        vector<int> temp;\\n        int d=2;\\n        int x=n;\\n        while(x>1)\\n        {\\n            if(x%d==0)\\n            {\\n                temp.push_back(d);\\n                x=x/d;\\n            }\\n            else\\n             d++;\\n        }\\n\\n        int newN=0;\\n        for(int i=0;i<temp.size();i++)\\n            newN+=temp[i];\\n        \\n        if(newN == n)\\n         return n;\\n        return solve(newN);\\n    }\\n    int smallestValue(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* intution : Recursion\\n        base case\\n         if(isPrime(n))\\n          return n;\\n         else\\n          n tak k prime factor nekal le\\n          eg 15 - 2,3,5,7,11,13 -> yaha se calculate newN\\n    */\\n    bool isPrime(int n){\\n     for(int i = 2;i * i <= n;i++){\\n            if(n % i == 0)return false;\\n        }\\n     return true;\\n}  \\n    int solve(int n)\\n    {\\n        // base case\\n    if(isPrime(n)){\\n            return n;\\n    }\\n        vector<int> temp;\\n        int d=2;\\n        int x=n;\\n        while(x>1)\\n        {\\n            if(x%d==0)\\n            {\\n                temp.push_back(d);\\n                x=x/d;\\n            }\\n            else\\n             d++;\\n        }\\n\\n        int newN=0;\\n        for(int i=0;i<temp.size();i++)\\n            newN+=temp[i];\\n        \\n        if(newN == n)\\n         return n;\\n        return solve(newN);\\n    }\\n    int smallestValue(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970847,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkPrime(int n){\\n        if(n<=1)\\n            return false;\\n        if(n==2 || n==3)\\n            return true;\\n        if(n%2==0 || n%3==0)\\n            return false;\\n        for(int i=5;i*i<=n;i+=6){\\n            if(n%i==0 || n%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(n==4){\\n            return 4;\\n        }\\n        while(checkPrime(n)==false){\\n            int sum=0;\\n            while(n%2==0){\\n                sum+=2;\\n                n/=2;\\n            }\\n            for(int i=3;i<=sqrt(n);i++){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n            }\\n            if(checkPrime(n))\\n                sum+=n;\\n            // cout<<sum<<endl;\\n            n=sum;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPrime(int n){\\n        if(n<=1)\\n            return false;\\n        if(n==2 || n==3)\\n            return true;\\n        if(n%2==0 || n%3==0)\\n            return false;\\n        for(int i=5;i*i<=n;i+=6){\\n            if(n%i==0 || n%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(n==4){\\n            return 4;\\n        }\\n        while(checkPrime(n)==false){\\n            int sum=0;\\n            while(n%2==0){\\n                sum+=2;\\n                n/=2;\\n            }\\n            for(int i=3;i<=sqrt(n);i++){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n            }\\n            if(checkPrime(n))\\n                sum+=n;\\n            // cout<<sum<<endl;\\n            n=sum;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2955090,
                "title": "smallest-value-after-replacing-with-sum-of-prime-factors-c-solution",
                "content": "Runtime: 3 ms, faster than 74.91% of C++ online submissions for Smallest Value After Replacing With Sum of Prime Factors.\\nMemory Usage: 5.9 MB, less than 72.81% of C++ online submissions for Smallest Value After Replacing With Sum of Prime Factors.\\n```\\n\\nint prime(int num)\\n{\\n        int x=num;\\n        int sum=0;\\n        for(int i=2;x>1;i++)\\n        {\\n            while(x%i==0)\\n            {\\n                sum=sum+i;\\n                x=x/i;\\n            }\\n        }\\n        return sum;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int smallestValue(int n) \\n    {\\n        int sum=prime(n);\\n        if(sum==n)\\n        {\\n            return sum;\\n        }\\n        else \\n        {\\n            return smallestValue(sum);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint prime(int num)\\n{\\n        int x=num;\\n        int sum=0;\\n        for(int i=2;x>1;i++)\\n        {\\n            while(x%i==0)\\n            {\\n                sum=sum+i;\\n                x=x/i;\\n            }\\n        }\\n        return sum;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int smallestValue(int n) \\n    {\\n        int sum=prime(n);\\n        if(sum==n)\\n        {\\n            return sum;\\n        }\\n        else \\n        {\\n            return smallestValue(sum);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950073,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primeFactors(int n){\\n        vector<int> ans;\\n        while (n % 2 == 0){\\n            ans.push_back(2);\\n            n = n/2;\\n        }\\n        for (int i = 3; i <= sqrt(n); i = i + 2){\\n            while (n % i == 0){\\n                ans.push_back(i);\\n                n = n/i;\\n            }\\n        }\\n        if (n > 2) ans.push_back(n);\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        if(n<6) return n;\\n        vector<int> temp;\\n        temp = primeFactors(n);\\n        n = accumulate(temp.begin(),temp.end(),0);\\n        while(n>0 && temp.size()>1){\\n            temp.clear();\\n            temp=primeFactors(n);\\n            n=accumulate(temp.begin(),temp.end(),0);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primeFactors(int n){\\n        vector<int> ans;\\n        while (n % 2 == 0){\\n            ans.push_back(2);\\n            n = n/2;\\n        }\\n        for (int i = 3; i <= sqrt(n); i = i + 2){\\n            while (n % i == 0){\\n                ans.push_back(i);\\n                n = n/i;\\n            }\\n        }\\n        if (n > 2) ans.push_back(n);\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        if(n<6) return n;\\n        vector<int> temp;\\n        temp = primeFactors(n);\\n        n = accumulate(temp.begin(),temp.end(),0);\\n        while(n>0 && temp.size()>1){\\n            temp.clear();\\n            temp=primeFactors(n);\\n            n=accumulate(temp.begin(),temp.end(),0);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949426,
                "title": "c-contestsolution-easytounderstand",
                "content": "Runtime: 3 ms, faster than 75.04% of C++ online submissions for Smallest Value After Replacing With Sum of Prime Factors.\\nMemory Usage: 5.9 MB, less than 95.21% of C++ online submissions for Smallest Value After Replacing With Sum of Prime Factors.\\n\\nclass Solution {\\npublic:\\n    \\n    int primeFactor(int n){\\n        int sum=0;\\n        for(int i=2;n>1;i++){\\n            while(n%i==0){\\n                sum=sum+i;\\n                n=n/i;\\n            }\\n        }\\n            return sum;\\n    }\\n    int smallestValue(int n) {\\n        \\n        int sum=primeFactor(n);\\n        if(sum == n)\\n            return sum;\\n        else\\n            return smallestValue(sum); \\n\\t\\t\\t\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int primeFactor(int n){\\n        int sum=0;\\n        for(int i=2;n>1;i++){\\n            while(n%i==0){\\n                sum=sum+i;\\n                n=n/i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2948690,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck prime number at every step from 2 to n -> brute force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck prime and find prime factors accordingly compxty will be reduced\\n// Md Arham kalam Ansari\\n# Complexity\\n- Time complexity: O(sqrt(n)*sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check_prime(int n)\\n    {\\n        if(n<=1) return false;\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    void sol(int &n,vector<int> &v)\\n    {\\n        \\n        while(n%2==0)\\n        {\\n            v.push_back(2);\\n            n=n/2;\\n        }\\n        for(int i=3;i<=sqrt(n);i=i+2)\\n        {\\n            while(n%i==0)\\n            {\\n                v.push_back(i);\\n                n=n/i;\\n            }\\n        }\\n        if(n>2) v.push_back(n);\\n    }\\n    int smallestValue(int n) {\\n        vector<int> v;\\n        if(n==4) return n;\\n        if(check_prime(n)==true) return n;\\n        while(check_prime(n)==false)\\n        {\\n            sol(n,v);\\n            int ans=0;\\n            for(int i=0;i<v.size();i++) ans+=v[i];\\n            //accumulate(v.begin(),v.end(),ans);\\n            n=ans;\\n            v.clear();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_prime(int n)\\n    {\\n        if(n<=1) return false;\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    void sol(int &n,vector<int> &v)\\n    {\\n        \\n        while(n%2==0)\\n        {\\n            v.push_back(2);\\n            n=n/2;\\n        }\\n        for(int i=3;i<=sqrt(n);i=i+2)\\n        {\\n            while(n%i==0)\\n            {\\n                v.push_back(i);\\n                n=n/i;\\n            }\\n        }\\n        if(n>2) v.push_back(n);\\n    }\\n    int smallestValue(int n) {\\n        vector<int> v;\\n        if(n==4) return n;\\n        if(check_prime(n)==true) return n;\\n        while(check_prime(n)==false)\\n        {\\n            sol(n,v);\\n            int ans=0;\\n            for(int i=0;i<v.size();i++) ans+=v[i];\\n            //accumulate(v.begin(),v.end(),ans);\\n            n=ans;\\n            v.clear();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930617,
                "title": "simplest-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. We recursively call `factorial` function which calculates the sum of factorial and pass it to the `smallestValue`  function.\\nThe only problem we will face is when sum of factorial be equal to the number `n` so we handle the case by using the `if` clause.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int a = 2;\\n    public int smallestValue(int n) {\\n        int sum = factorial(n,2);\\n        // handle the anamoly\\n        if(sum == n)\\n            return n;\\n        return smallestValue(sum);\\n    }\\n    public static int factorial(int n , int a){\\n        if (n == 1) return 0;\\n\\n        if(n%a == 0) return a + factorial(n/a, a);\\n        else return factorial(n, a+1);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int a = 2;\\n    public int smallestValue(int n) {\\n        int sum = factorial(n,2);\\n        // handle the anamoly\\n        if(sum == n)\\n            return n;\\n        return smallestValue(sum);\\n    }\\n    public static int factorial(int n , int a){\\n        if (n == 1) return 0;\\n\\n        if(n%a == 0) return a + factorial(n/a, a);\\n        else return factorial(n, a+1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930174,
                "title": "exception-handling-solution-java",
                "content": "# Intro\\nProblem isn`t hard, so only one problem that i had is stackoverflow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nYeah, you can make it faster by making 1 more check. But stackOverflow helped me alot in my life so i decided to leave it here^_^ss\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 959 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 466.4 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int smallestValue(int n) {\\n        try {\\n            int sum=0;\\n            int prev = n;\\n            for (int i = 2; i <= Math.sqrt(n); i++) {\\n                if (n%i==0){sum+=i; n/=i;i--;}\\n            }\\n            if (sum==0) return n;\\n            return smallestValue(sum+n);\\n        } catch (StackOverflowError a) {return n*2;}\\n    }\\n}}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int smallestValue(int n) {\\n        try {\\n            int sum=0;\\n            int prev = n;\\n            for (int i = 2; i <= Math.sqrt(n); i++) {\\n                if (n%i==0){sum+=i; n/=i;i--;}\\n            }\\n            if (sum==0) return n;\\n            return smallestValue(sum+n);\\n        } catch (StackOverflowError a) {return n*2;}\\n    }\\n}}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926601,
                "title": "simple-recursive-approach",
                "content": "# Approach\\nWe will calculate the sum of all possible prime factors and compare it with the number of which we are calculating for if sum is less we will recursively calculate for it or else return it since it breaks condition;\\n# Complexity\\n- Time complexity:\\n- It is recursive in approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n)\\n    {\\n        int q=n;\\n        int p=0;\\n        while(n%2==0)\\n        {\\n            p=p+2;\\n            n=n/2;\\n        }\\n        for(int i=3;i<=sqrt(n);i=i+2)\\n        {\\n            while(n%i==0)\\n            {\\n                p=p+i;\\n                n=n/i;\\n            }\\n        }\\n        if (n > 2)\\n        {\\n            p=p+n;\\n        }\\n        if(q>p)\\n        {\\n            q=p;\\n            return smallestValue(p);\\n        }\\n        else\\n        {\\n            return p;\\n        }\\n    }\\n};\\n\\nPlease upvote if it helps!!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int smallestValue(int n)\\n    {\\n        int q=n;\\n        int p=0;\\n        while(n%2==0)\\n        {\\n            p=p+2;\\n            n=n/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2926436,
                "title": "clean-code-c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    int smallestValue(int n) {\\n        int x = n;\\n        int ans = n;\\n        \\n        while(true) {\\n            int check = x; // Storing x in another variable as x will be lost in each iteration\\n            \\n            \\n            int num = x; // Condition variable to be used in for loop\\n            \\n            x = 0; // Reusing variable to store sum of factors\\n            \\n            \\n            // Sieve Algorithm to get prime factorisation\\n            \\n            for(int i = 2; i <= num; i++) {\\n                while(num % i == 0) {\\n                    num = num / i;\\n                    x += i; // Adding factor to x;\\n                }\\n            }\\n            \\n            ans = min(x, ans);\\n            \\n            if(x == check) break; // Base condition to break out i.e Sum of factors = Product of factors\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n     \\n    int smallestValue(int n) {\\n        int x = n;\\n        int ans = n;\\n        \\n        while(true) {\\n            int check = x; // Storing x in another variable as x will be lost in each iteration\\n            \\n            \\n            int num = x; // Condition variable to be used in for loop\\n            \\n            x = 0; // Reusing variable to store sum of factors\\n            \\n            \\n            // Sieve Algorithm to get prime factorisation\\n            \\n            for(int i = 2; i <= num; i++) {\\n                while(num % i == 0) {\\n                    num = num / i;\\n                    x += i; // Adding factor to x;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2926176,
                "title": "c-simple-solution-by-help-of-ai",
                "content": "I gave my solution to ChatGPT and it returned me this solution....\\uD83D\\uDE0D\\uD83D\\uDE0D\\uD83D\\uDE0D\\nAlthough it\\'s run-time is costly but managed to pass all the test cases.\\n\\nclass Solution {\\npublic:\\n    const int MAXN = 100005;\\n\\n    int getPrimeFactorSum(int x) {\\n        // Implement a function for computing the sum of the prime factors of x here\\n        // For example, using trial division:\\n        int sum = 0;\\n        for (int i = 2; i <= x / i; i++) {\\n            while (x % i == 0) {\\n                sum += i;\\n                x /= i;\\n            }\\n        }\\n        if (x > 1) {\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n    \\n    int getFactorization(int x){\\n        return getPrimeFactorSum(x);\\n    }\\n    \\n    int smallestValue(int n) {\\n        vector<int> pre(n + 1, 0);\\n        for(int i = 2; i <= n; i++){\\n            pre[i] = getFactorization(i);\\n        }\\n        \\n        int ans = INT_MAX;\\n        map<int, int> mp;\\n        while(n > 1){\\n            ans = min(ans, pre[n]);\\n            n = pre[n];\\n            if(mp.count(n))\\n                break;\\n            mp[n]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    const int MAXN = 100005;\\n\\n    int getPrimeFactorSum(int x) {\\n        // Implement a function for computing the sum of the prime factors of x here\\n        // For example, using trial division:\\n        int sum = 0;\\n        for (int i = 2; i <= x / i; i++) {\\n            while (x % i == 0) {\\n                sum += i;\\n                x /= i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2925477,
                "title": "simple-and-efficient-c-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll f(int n)\\n    {\\n        ll s=0;\\n        ll y=n;\\n        for(int i=2;i<y;i++)\\n        {\\n            if(isprime(i))\\n            {\\n                while(n%i==0)\\n                {\\n                    n/=i;\\n                     s+=i;\\n                    if(isprime(n))\\n                    {\\n                        s+=n;\\n                        return s;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return s;\\n    }\\n    bool isprime(int n)\\n    {\\n        for(int i=2;i<n;i++)\\n        {\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        ll mini=n;\\n        ll s=n;\\n        while(!isprime(n))\\n        {\\n            ll x=f(n);\\n            n=x;\\n            mini=min(mini,x);\\n            if(s==x)\\n            return mini;\\n            s=x;\\n           \\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll f(int n)\\n    {\\n        ll s=0;\\n        ll y=n;\\n        for(int i=2;i<y;i++)\\n        {\\n            if(isprime(i))\\n            {\\n                while(n%i==0)\\n                {\\n                    n/=i;\\n                     s+=i;\\n                    if(isprime(n))\\n                    {\\n                        s+=n;\\n                        return s;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return s;\\n    }\\n    bool isprime(int n)\\n    {\\n        for(int i=2;i<n;i++)\\n        {\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        ll mini=n;\\n        ll s=n;\\n        while(!isprime(n))\\n        {\\n            ll x=f(n);\\n            n=x;\\n            mini=min(mini,x);\\n            if(s==x)\\n            return mini;\\n            s=x;\\n           \\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925087,
                "title": "my-submission-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    \\n    int cal(int num){\\n        int out=0;\\n        for(int i = 2; i< num; i++) {\\n           while(num%i == 0) {\\n              out+=i;\\n              num = num/i;\\n           }\\n        }\\n        if(num >2) {\\n           out+=num;\\n        }\\n        return out;\\n    }\\n    \\n    public int smallestValue(int n) {\\n        while(n!=cal(n)){\\n           \\n            if(n<4)\\n                return n; \\n            n=cal(n);\\n        }\\n              \\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    int cal(int num){\\n        int out=0;\\n        for(int i = 2; i< num; i++) {\\n           while(num%i == 0) {\\n              out+=i;\\n              num = num/i;\\n           }\\n        }\\n        if(num >2) {\\n           out+=num;\\n        }\\n        return out;\\n    }\\n    \\n    public int smallestValue(int n) {\\n        while(n!=cal(n)){\\n           \\n            if(n<4)\\n                return n; \\n            n=cal(n);\\n        }\\n              \\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925047,
                "title": "simple-python-solution",
                "content": "# Intuition\\nMy intuition is that if I encounter any prime number in the process then that is the minimum of till now will be the answer or if we come across same number twice then we will return the minimum value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import sqrt\\n\\nclass Solution:\\n    def primeFactors(self,n):\\n        x=0\\n        while n % 2 == 0:\\n            x+=2\\n            n = n // 2\\n\\n        for i in range(3,int(math.sqrt(n))+1,2):\\n            while n % i== 0:\\n                x+=i\\n                n = n // i\\n        if n > 2:\\n            x+=n\\n        return x\\n\\n    def isPrime(self,n):\\n        prime_flag = 0\\n        if(n > 1):\\n            for i in range(2, int(sqrt(n)) + 1):\\n                if (n % i == 0):\\n                    prime_flag = 1\\n                    break\\n            if (prime_flag == 0):\\n                return True\\n            else:\\n                return False\\n        else:\\n            return True\\n\\n    def smallestValue(self, n: int) -> int:\\n        lst=[0]*100001\\n        mn=n\\n        \\n        while True:\\n            if lst[n]==1:\\n                return mn\\n            if self.isPrime(n):\\n                return min(n,mn)\\n            lst[n]=1\\n            n=self.primeFactors(n)\\n            mn=min(mn,n)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import sqrt\\n\\nclass Solution:\\n    def primeFactors(self,n):\\n        x=0\\n        while n % 2 == 0:\\n            x+=2\\n            n = n // 2\\n\\n        for i in range(3,int(math.sqrt(n))+1,2):\\n            while n % i== 0:\\n                x+=i\\n                n = n // i\\n        if n > 2:\\n            x+=n\\n        return x\\n\\n    def isPrime(self,n):\\n        prime_flag = 0\\n        if(n > 1):\\n            for i in range(2, int(sqrt(n)) + 1):\\n                if (n % i == 0):\\n                    prime_flag = 1\\n                    break\\n            if (prime_flag == 0):\\n                return True\\n            else:\\n                return False\\n        else:\\n            return True\\n\\n    def smallestValue(self, n: int) -> int:\\n        lst=[0]*100001\\n        mn=n\\n        \\n        while True:\\n            if lst[n]==1:\\n                return mn\\n            if self.isPrime(n):\\n                return min(n,mn)\\n            lst[n]=1\\n            n=self.primeFactors(n)\\n            mn=min(mn,n)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924861,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n --->   61 ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n \\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def pr(n):\\n            x=[]\\n            while n % 2 == 0:\\n                x.append(2)\\n                n = n / 2\\n            for i in range(3,int(math.sqrt(n))+1,2):\\n                while n % i== 0:\\n                    x.append(i)\\n                    n = n / i\\n            if n > 2:\\n                x.append(n)\\n            return sum(x)\\n        while(n!=pr(n)):\\n            n=pr(n)\\n        return int(n)            \\n              \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def pr(n):\\n            x=[]\\n            while n % 2 == 0:\\n                x.append(2)\\n                n = n / 2\\n            for i in range(3,int(math.sqrt(n))+1,2):\\n                while n % i== 0:\\n                    x.append(i)\\n                    n = n / i\\n            if n > 2:\\n                x.append(n)\\n            return sum(x)\\n        while(n!=pr(n)):\\n            n=pr(n)\\n        return int(n)            \\n              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924255,
                "title": "easy-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   bool isprime(int n){\\n    if (n <= 1)return false;\\n    for (int i = 2; i < n; i++)\\n        if (n % i == 0)return false;\\n    return true;\\n}\\n void primeFactors(int n,vector<int>&v){\\n    while (n % 2 == 0){\\n        v.push_back(2);\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2){\\n        while (n % i == 0)\\n        {\\n            v.push_back(i);\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)\\n        v.push_back(n);\\n}\\n    int smallestValue(int n) {\\n        if(n==0||n==1||n==4)return n;\\n        int sum;\\n        while(!isprime(n)){\\n            sum=0;\\n            vector<int>v;\\n            primeFactors(n,v);\\n            for(int i=0;i<v.size();i++)sum+=v[i];\\n            n=sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isprime(int n){\\n    if (n <= 1)return false;\\n    for (int i = 2; i < n; i++)\\n        if (n % i == 0)return false;\\n    return true;\\n}\\n void primeFactors(int n,vector<int>&v){\\n    while (n % 2 == 0){\\n        v.push_back(2);\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2){\\n        while (n % i == 0)\\n        {\\n            v.push_back(i);\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)\\n        v.push_back(n);\\n}\\n    int smallestValue(int n) {\\n        if(n==0||n==1||n==4)return n;\\n        int sum;\\n        while(!isprime(n)){\\n            sum=0;\\n            vector<int>v;\\n            primeFactors(n,v);\\n            for(int i=0;i<v.size();i++)sum+=v[i];\\n            n=sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924225,
                "title": "codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def find_factors_sum(n):\\n            sum_ = 0\\n            for i in range(2,n):\\n                while n%i==0:\\n                    sum_+=i\\n                    n = n//i\\n            return sum_\\n        while find_factors_sum(n) and n!=find_factors_sum(n):\\n            n = find_factors_sum(n)\\n        return n\\n            \\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def find_factors_sum(n):\\n            sum_ = 0\\n            for i in range(2,n):\\n                while n%i==0:\\n                    sum_+=i\\n                    n = n//i\\n            return sum_\\n        while find_factors_sum(n) and n!=find_factors_sum(n):\\n            n = find_factors_sum(n)\\n        return n\\n            \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923943,
                "title": "java-sieve-of-eratosthenes-approach-highly-optimised-code",
                "content": "**Intuition:**\\n*Keep breaking the number into sum of prime factors. Stop when the number becomes a prime number. Because prime numbers cannot be broken further.*\\n\\n```java\\nclass Solution {\\n    public int smallestValue(int n) {\\n        fillPrimes(n);     // finding all primes upto n by sieve of eratosthenes\\n        \\n        int prev = n;\\n        while (!isPrime[n]) {\\n            n = sumOfPrimeFactors(n);\\n            if (prev == n) break;\\n            prev = n;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    int sumOfPrimeFactors(int n) {\\n        int sum = 0;\\n        int i = 2;\\n        while (i <= n) {\\n            if (isPrime[i] && n%i == 0) {\\n                n /= i;\\n                sum += i;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        return sum;\\n    }\\n\\t\\n\\tboolean[] isPrime;\\n\\tboolean[] vis;\\n\\tvoid fill(int n) {\\n\\t\\tisPrime = new boolean[n+1];\\n\\t\\tArrays.fill(isPrime, true);\\n\\t\\tvis = new boolean[n+1];\\n\\t\\t\\n\\t\\tfor (int i = 2; i <= n/i; i++) {\\n\\t\\t\\tif (!vis[i]) {\\n\\t\\t\\t\\tint num = i;\\n\\t\\t\\t\\tint mul = 2;\\n\\t\\t\\t\\twhile (num * mul < isPrime.length) {\\n\\t\\t\\t\\t\\tint prod = num*mul;\\n\\t\\t\\t\\t\\tisPrime[prod] = false;\\n\\t\\t\\t\\t\\tvis[prod] = true;\\n\\t\\t\\t\\t\\tmul++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int smallestValue(int n) {\\n        fillPrimes(n);     // finding all primes upto n by sieve of eratosthenes\\n        \\n        int prev = n;\\n        while (!isPrime[n]) {\\n            n = sumOfPrimeFactors(n);\\n            if (prev == n) break;\\n            prev = n;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    int sumOfPrimeFactors(int n) {\\n        int sum = 0;\\n        int i = 2;\\n        while (i <= n) {\\n            if (isPrime[i] && n%i == 0) {\\n                n /= i;\\n                sum += i;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        return sum;\\n    }\\n\\t\\n\\tboolean[] isPrime;\\n\\tboolean[] vis;\\n\\tvoid fill(int n) {\\n\\t\\tisPrime = new boolean[n+1];\\n\\t\\tArrays.fill(isPrime, true);\\n\\t\\tvis = new boolean[n+1];\\n\\t\\t\\n\\t\\tfor (int i = 2; i <= n/i; i++) {\\n\\t\\t\\tif (!vis[i]) {\\n\\t\\t\\t\\tint num = i;\\n\\t\\t\\t\\tint mul = 2;\\n\\t\\t\\t\\twhile (num * mul < isPrime.length) {\\n\\t\\t\\t\\t\\tint prod = num*mul;\\n\\t\\t\\t\\t\\tisPrime[prod] = false;\\n\\t\\t\\t\\t\\tvis[prod] = true;\\n\\t\\t\\t\\t\\tmul++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923914,
                "title": "c-beginer-friendly-easy-solution-simplified",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int num=n;\\n        n=prime(n);\\n       \\n        while(num!=n)\\n        {\\n            num=n;       \\n            n=prime(n);\\n            \\n        }\\n        return num;\\n    }   \\n    int prime(int n)\\n    {\\n        int a=n;\\n    int ans =0;\\n    for(int i=2;i<a;++i)\\n    {\\n        while(n%i==0)\\n        {\\n            ans+=i;\\n            n/=i;\\n        }\\n    }\\n    if(ans==0)\\n        return a;\\n    else return ans ;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int num=n;\\n        n=prime(n);\\n       \\n        while(num!=n)\\n        {\\n            num=n;       \\n            n=prime(n);\\n            \\n        }\\n        return num;\\n    }   \\n    int prime(int n)\\n    {\\n        int a=n;\\n    int ans =0;\\n    for(int i=2;i<a;++i)\\n    {\\n        while(n%i==0)\\n        {\\n            ans+=i;\\n            n/=i;\\n        }\\n    }\\n    if(ans==0)\\n        return a;\\n    else return ans ;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923809,
                "title": "c-fully-explained-5-line-code",
                "content": "# Intuition\\nFirst thought is to solve with the help of bool prime and so on, but recursively we don\\'t need to find the prime. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923767,
                "title": "javascript-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar smallestValue = function(n) {\\n    let s=(primeFactors(n))\\n    if(s==n){\\n        return s\\n    }\\n   while(true){\\n       let nn=primeFactors(n)\\n       if(nn==n){\\n           return n\\n       }\\n       n=nn\\n   }\\n    \\n    return 0\\n    \\n    \\n};\\n\\nfunction primeFactors(n)\\n{\\n    let ans=0\\n    let c = 2;\\n    while(n > 1)\\n    {\\n        if(n % c == 0){\\n            ans+=c\\n            n /= c;\\n        }\\n        else c++;\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar smallestValue = function(n) {\\n    let s=(primeFactors(n))\\n    if(s==n){\\n        return s\\n    }\\n   while(true){\\n       let nn=primeFactors(n)\\n       if(nn==n){\\n           return n\\n       }\\n       n=nn\\n   }\\n    \\n    return 0\\n    \\n    \\n};\\n\\nfunction primeFactors(n)\\n{\\n    let ans=0\\n    let c = 2;\\n    while(n > 1)\\n    {\\n        if(n % c == 0){\\n            ans+=c\\n            n /= c;\\n        }\\n        else c++;\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923736,
                "title": "java-simplest-and-shortest",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int ori = n, ans = n;\\n        int k = 2, sum = 0;\\n\\n        while (true) {\\n            if (n % k == 0) {\\n                sum += k;\\n                n /= k;\\n            }\\n            else k++;\\n\\n            if (n == 1) {\\n                if (sum == ori) {\\n                    break;\\n                }\\n                ori = n = sum;\\n                sum = 0;\\n                k = 2;\\n                ans = Math.min(ans, n);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int ori = n, ans = n;\\n        int k = 2, sum = 0;\\n\\n        while (true) {\\n            if (n % k == 0) {\\n                sum += k;\\n                n /= k;\\n            }\\n            else k++;\\n\\n            if (n == 1) {\\n                if (sum == ori) {\\n                    break;\\n                }\\n                ori = n = sum;\\n                sum = 0;\\n                k = 2;\\n                ans = Math.min(ans, n);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923728,
                "title": "simple-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool prime(int n){\\n        if (n <= 1)\\n        return false;\\n \\n    \\n    for (int i = 2; i < n; i++)\\n        if (n % i == 0)\\n            return false;\\n \\n    return true;\\n        \\n    }\\n    \\n    int cal(int n){\\n        \\n       vector<int> vec;\\n        \\n        for(int i=2;i<n;i++){\\n            // cout<<i;\\n            if(prime(i) && n%i==0){\\n                n=n/i;\\n                vec.push_back(i);\\n                i=1;\\n                if(prime(n)) vec.push_back(n);\\n            }\\n            // cout<<n;\\n            \\n        }\\n        \\n        \\n        int sum=0;\\n        \\n        for(auto i: vec) sum+=i;\\n        vec.clear();\\n        return sum;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        cout<<\"hi\";\\n        \\n        while(!prime(n)){\\n            if(n==4) return 4;\\n            n=cal(n);\\n            \\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool prime(int n){\\n        if (n <= 1)\\n        return false;\\n \\n    \\n    for (int i = 2; i < n; i++)\\n        if (n % i == 0)\\n            return false;\\n \\n    return true;\\n        \\n    }\\n    \\n    int cal(int n){\\n        \\n       vector<int> vec;\\n        \\n        for(int i=2;i<n;i++){\\n            // cout<<i;\\n            if(prime(i) && n%i==0){\\n                n=n/i;\\n                vec.push_back(i);\\n                i=1;\\n                if(prime(n)) vec.push_back(n);\\n            }\\n            // cout<<n;\\n            \\n        }\\n        \\n        \\n        int sum=0;\\n        \\n        for(auto i: vec) sum+=i;\\n        vec.clear();\\n        return sum;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        cout<<\"hi\";\\n        \\n        while(!prime(n)){\\n            if(n==4) return 4;\\n            n=cal(n);\\n            \\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2923716,
                "title": "simplest-easiest-solution-c",
                "content": "\\n    int smallestValue(int n)\\n    {\\n\\n        int sum = 0;\\n        bool flag = false;\\n        int i = 2;\\n        while (i <= n / 2)\\n        {\\n            if (n % i == 0)\\n            {\\n                sum += i;\\n                flag = true;\\n                n /= i;\\n                continue;\\n            }\\n            i++;\\n        }\\n        if (n != 1 && flag == 1)\\n        {\\n            sum += n;\\n        }\\n        if (n == 2 && sum == 4)\\n        {\\n            return sum;\\n        }\\n        if (flag == 0)\\n        {\\n            return n;\\n        }\\n        return smallestValue(sum);\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "\\n    int smallestValue(int n)\\n    {\\n\\n        int sum = 0;\\n        bool flag = false;\\n        int i = 2;\\n        while (i <= n / 2)\\n        {\\n            if (n % i == 0)\\n            {\\n                sum += i;\\n                flag = true;\\n                n /= i;\\n                continue;\\n            }\\n            i++;\\n        }\\n        if (n != 1 && flag == 1)\\n        {\\n            sum += n;\\n        }\\n        if (n == 2 && sum == 4)\\n        {\\n            return sum;\\n        }\\n        if (flag == 0)\\n        {\\n            return n;\\n        }\\n        return smallestValue(sum);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2923689,
                "title": "java-easy-to-understand-solution-comments-5-ms-solution",
                "content": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        while(true){\\n            int sum = sumOfPrimeFactors(n);\\n            if(sum == n) break; //if sum and n both becomes equal than break the loop\\n            n = sum; //update n with sum of its prime factors\\n        }\\n        \\n        return n;\\n    }\\n    \\n    public int sumOfPrimeFactors(int num){\\n        int factor = 2;\\n        int sum = 0;\\n\\n        while(num != 1){ //Repeat the loop till number becomes 1.\\n            if(num % factor == 0){ //Check if factor divides the number.\\n                num /= factor; //If yes, update the number.\\n                sum += factor; //Add factor to sum.\\n                continue;\\n            } \\n            \\n            factor++; //If the current number is not a factor, check the next number.\\n        }\\n        return sum;\\n    } \\n} \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        while(true){\\n            int sum = sumOfPrimeFactors(n);\\n            if(sum == n) break; //if sum and n both becomes equal than break the loop\\n            n = sum; //update n with sum of its prime factors\\n        }\\n        \\n        return n;\\n    }\\n    \\n    public int sumOfPrimeFactors(int num){\\n        int factor = 2;\\n        int sum = 0;\\n\\n        while(num != 1){ //Repeat the loop till number becomes 1.\\n            if(num % factor == 0){ //Check if factor divides the number.\\n                num /= factor; //If yes, update the number.\\n                sum += factor; //Add factor to sum.\\n                continue;\\n            } \\n            \\n            factor++; //If the current number is not a factor, check the next number.\\n        }\\n        return sum;\\n    } \\n} \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923688,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while True:\\n            c=2\\n            t=0\\n            b=n\\n\\n            while c*c<=n:\\n                while n%c==0:\\n                    n//=c\\n                    t+=c\\n\\n                c+=1\\n\\n            if t==0:\\n                return n\\n\\n            if t>=b:\\n                return b\\n\\n            if n>1:\\n                t+=n\\n\\n            n=t                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while True:\\n            c=2\\n            t=0\\n            b=n\\n\\n            while c*c<=n:\\n                while n%c==0:\\n                    n//=c\\n                    t+=c\\n\\n                c+=1\\n\\n            if t==0:\\n                return n\\n\\n            if t>=b:\\n                return b\\n\\n            if n>1:\\n                t+=n\\n\\n            n=t                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923664,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n<2) return false;\\n        for(int i=2 ; i<=sqrt(n) ; i++){\\n            if(n%i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(isPrime(n)) return n;\\n        int mini = INT_MAX;\\n        int m = n;\\n        int sum;\\n        do\\n        { \\n            sum = 0;\\n            while(n%2==0){\\n                sum += 2;\\n                n=n/2;\\n            }\\n            for(int i=3 ; i<=sqrt(n) ; i=i+2){\\n                while(n%i == 0){\\n                    sum += i;\\n                    n = n/i;\\n                }\\n            }\\n            if(n>2){\\n                sum += n;\\n            }\\n            mini = min(mini , sum);\\n            n = sum;\\n        }while(isPrime(sum) == false && sum < m);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n<2) return false;\\n        for(int i=2 ; i<=sqrt(n) ; i++){\\n            if(n%i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(isPrime(n)) return n;\\n        int mini = INT_MAX;\\n        int m = n;\\n        int sum;\\n        do\\n        { \\n            sum = 0;\\n            while(n%2==0){\\n                sum += 2;\\n                n=n/2;\\n            }\\n            for(int i=3 ; i<=sqrt(n) ; i=i+2){\\n                while(n%i == 0){\\n                    sum += i;\\n                    n = n/i;\\n                }\\n            }\\n            if(n>2){\\n                sum += n;\\n            }\\n            mini = min(mini , sum);\\n            n = sum;\\n        }while(isPrime(sum) == false && sum < m);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923649,
                "title": "c-beats-92-prime-factorization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int primeFactors(int n)\\n    {\\n        int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0    int count = 2;\\n\\xA0\\xA0\\xA0\\xA0    while(n>1)\\n\\xA0\\xA0\\xA0 \\xA0   {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0    if(n % count == 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0        sum += count;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0        n/=count;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0    }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0    else count++;\\n\\xA0\\xA0\\xA0\\xA0    }\\n        \\n        return sum;\\n    }\\n    \\n    int smallestValue(int num) {\\n        int sum = 0;\\n        int prev = 0;\\n        \\n        map<int,int> visited;\\n\\xA0       \\n        while (num) {\\n            prev = num;\\n\\xA0\\xA0\\xA0\\xA0        num = primeFactors(num);\\n            \\n            // if current prime factor is visited again then return the previous factor\\n            if (visited[num]) {\\n                return prev;\\n            } else {\\n                visited[num] = 1;\\n            }\\n        }\\n        \\n\\xA0\\xA0\\xA0\\xA0    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primeFactors(int n)\\n    {\\n        int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0    int count = 2;\\n\\xA0\\xA0\\xA0\\xA0    while(n>1)\\n\\xA0\\xA0\\xA0 \\xA0   {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0    if(n % count == 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0        sum += count;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0        n/=count;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0    }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0    else count++;\\n\\xA0\\xA0\\xA0\\xA0    }\\n        \\n        return sum;\\n    }\\n    \\n    int smallestValue(int num) {\\n        int sum = 0;\\n        int prev = 0;\\n        \\n        map<int,int> visited;\\n\\xA0       \\n        while (num) {\\n            prev = num;\\n\\xA0\\xA0\\xA0\\xA0        num = primeFactors(num);\\n            \\n            // if current prime factor is visited again then return the previous factor\\n            if (visited[num]) {\\n                return prev;\\n            } else {\\n                visited[num] = 1;\\n            }\\n        }\\n        \\n\\xA0\\xA0\\xA0\\xA0    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923617,
                "title": "python",
                "content": "# Complexity\\n- Time complexity: This Approach takes O(log n) for all composite numbers and O(n) otherwise.\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def prime(n):\\n            prev_n = n\\n            s = 0\\n            c = 2\\n            while(n > 1):\\n                if(n % c == 0):\\n                    s += c\\n                    n = n / c\\n                else:\\n                    c = c + 1\\n            if s == prev_n:\\n                return False\\n            else:\\n                return s\\n            \\n        ans = n\\n        while 1:\\n            res = prime(ans)\\n            if res:\\n                ans = res\\n            else:\\n                break\\n        \\n        return ans\\n```\\n\\n----------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def prime(n):\\n            prev_n = n\\n            s = 0\\n            c = 2\\n            while(n > 1):\\n                if(n % c == 0):\\n                    s += c\\n                    n = n / c\\n                else:\\n                    c = c + 1\\n            if s == prev_n:\\n                return False\\n            else:\\n                return s\\n            \\n        ans = n\\n        while 1:\\n            res = prime(ans)\\n            if res:\\n                ans = res\\n            else:\\n                break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923606,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int check = n;\\n        while (isPrime(check) != 1) {\\n            int curr = getValue(check);\\n            if (curr == check) {\\n                return check;\\n            }\\n            check = curr;\\n        }\\n        return check;\\n    }\\n    public int getValue(int n) {\\n        int res = 0;\\n        int check = n;\\n        for (int i = 2; i <= n; i++) {\\n            if (isPrime(i) == 1) {\\n                while (check % i == 0) {\\n                    res += i;\\n                    check /= i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int isPrime(int n) {\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            while (n % i == 0) {\\n                return i;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int check = n;\\n        while (isPrime(check) != 1) {\\n            int curr = getValue(check);\\n            if (curr == check) {\\n                return check;\\n            }\\n            check = curr;\\n        }\\n        return check;\\n    }\\n    public int getValue(int n) {\\n        int res = 0;\\n        int check = n;\\n        for (int i = 2; i <= n; i++) {\\n            if (isPrime(i) == 1) {\\n                while (check % i == 0) {\\n                    res += i;\\n                    check /= i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int isPrime(int n) {\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            while (n % i == 0) {\\n                return i;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923547,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int sum = 0;\\n        int ans=Integer.MAX_VALUE;\\n        HashSet<Integer> hs=new HashSet<>();\\n        while(!hs.contains(n)){\\n            hs.add(n);\\n            // check from 2 to n whenever n is the factor of c add it to the sum\\n            int c = 2;\\n            while (n > 1) {\\n                if (n % c == 0) {\\n                    sum+=c;\\n                    n /= c;\\n                }\\n                else\\n                    c++;\\n            }\\n            ans=Math.min(sum,ans);\\n            n=sum;\\n            sum=0;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int sum = 0;\\n        int ans=Integer.MAX_VALUE;\\n        HashSet<Integer> hs=new HashSet<>();\\n        while(!hs.contains(n)){\\n            hs.add(n);\\n            // check from 2 to n whenever n is the factor of c add it to the sum\\n            int c = 2;\\n            while (n > 1) {\\n                if (n % c == 0) {\\n                    sum+=c;\\n                    n /= c;\\n                }\\n                else\\n                    c++;\\n            }\\n            ans=Math.min(sum,ans);\\n            n=sum;\\n            sum=0;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923514,
                "title": "easy-understandable-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int k=2;\\n        int sum=0;\\n        int maxi=n;\\n        int mini=n;\\n        while(true){\\n            if(n%k==0){\\n                sum+=k;\\n                n=n/k;\\n            }\\n            else k++;\\n            if(n==1){\\n                if(sum==maxi) break;\\n                n=sum;\\n                sum=0;\\n                mini=min(n,mini);\\n                k=2;\\n                maxi=n;\\n            }\\n            \\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int k=2;\\n        int sum=0;\\n        int maxi=n;\\n        int mini=n;\\n        while(true){\\n            if(n%k==0){\\n                sum+=k;\\n                n=n/k;\\n            }\\n            else k++;\\n            if(n==1){\\n                if(sum==maxi) break;\\n                n=sum;\\n                sum=0;\\n                mini=min(n,mini);\\n                k=2;\\n                maxi=n;\\n            }\\n            \\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923488,
                "title": "java-brute-force-with-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDecrease n with brute force.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWatch out the $$4 = 2 * 2$$, decrease n with prime sum.\\n\\nFor some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int smallestValue(int n) {\\n    // watch out 4 = 2 * 2\\n    if (n == 4) {\\n      return 4;\\n    }\\n\\n    while (!prime(n)) {\\n      int total = 0;\\n      for (int i = 2; i <= n; i++) {\\n        if (prime(i)) {\\n          while (n % i == 0) {\\n            total += i;\\n            n /= i;\\n          }\\n        }\\n      }\\n      n = total;\\n    }\\n    return n;\\n  }\\n\\n  private boolean prime(int n) {\\n    if (n < 4) {\\n      return true;\\n    }\\n    for (int i = 2; i * i <= n; i++) {\\n      if (n % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public int smallestValue(int n) {\\n    // watch out 4 = 2 * 2\\n    if (n == 4) {\\n      return 4;\\n    }\\n\\n    while (!prime(n)) {\\n      int total = 0;\\n      for (int i = 2; i <= n; i++) {\\n        if (prime(i)) {\\n          while (n % i == 0) {\\n            total += i;\\n            n /= i;\\n          }\\n        }\\n      }\\n      n = total;\\n    }\\n    return n;\\n  }\\n\\n  private boolean prime(int n) {\\n    if (n < 4) {\\n      return true;\\n    }\\n    for (int i = 2; i * i <= n; i++) {\\n      if (n % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072212,
                "title": "iterative-approach-easiest-intuitive-solin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primes(self,n):\\n        i=2\\n        primes=0\\n        while n>1:\\n            while n%i==0:\\n                primes+=i\\n                n=n//i\\n            i+=1\\n        return primes\\n\\n    def smallestValue(self, n: int) -> int:\\n        r=self.primes(n)\\n        if r==n:\\n            return n\\n        return self.smallestValue(r)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primes(self,n):\\n        i=2\\n        primes=0\\n        while n>1:\\n            while n%i==0:\\n                primes+=i\\n                n=n//i\\n            i+=1\\n        return primes\\n\\n    def smallestValue(self, n: int) -> int:\\n        r=self.primes(n)\\n        if r==n:\\n            return n\\n        return self.smallestValue(r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072190,
                "title": "recursive-approach-easiest-intuitive-solin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primes(self,n):\\n        i=2\\n        primes=0\\n        while n>1:\\n            while n%i==0:\\n                primes+=i\\n                n=n//i\\n            i+=1\\n        return primes\\n\\n    def smallestValue(self, n: int) -> int:\\n        r=self.primes(n)\\n        if r==n:\\n            return n\\n        return self.smallestValue(r)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primes(self,n):\\n        i=2\\n        primes=0\\n        while n>1:\\n            while n%i==0:\\n                primes+=i\\n                n=n//i\\n            i+=1\\n        return primes\\n\\n    def smallestValue(self, n: int) -> int:\\n        r=self.primes(n)\\n        if r==n:\\n            return n\\n        return self.smallestValue(r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056763,
                "title": "simple-prime-factorization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool ispri(int n)\\n{\\n    //vector<int> v;\\n    for(int i=2; i<=sqrt(n); i++)\\n    {\\n        if(n%i==0)\\n        return 0;\\n    }\\n    return 1;\\n}\\n    int smallestValue(int n) {\\n        int d=n;\\n        while(1)\\n        {\\n            int sum=0;\\n            int k=d;\\n            while(d%2==0)\\n            {\\n                sum+=2;\\n                d/=2;\\n            }\\n            for(int i=3; i<=sqrt(d); i+=2)\\n            {\\n                while(d%i==0)\\n                {\\n                    sum+=i;\\n                    d/=i;\\n                }\\n            }\\n            \\n            if(d>1)\\n            sum+=d;\\n            cout<<sum<<endl;\\n            if(ispri(sum) || sum==k)\\n            {\\n                d=sum;\\n                break;\\n            }\\n            \\n            d=sum;\\n        }\\n\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool ispri(int n)\\n{\\n    //vector<int> v;\\n    for(int i=2; i<=sqrt(n); i++)\\n    {\\n        if(n%i==0)\\n        return 0;\\n    }\\n    return 1;\\n}\\n    int smallestValue(int n) {\\n        int d=n;\\n        while(1)\\n        {\\n            int sum=0;\\n            int k=d;\\n            while(d%2==0)\\n            {\\n                sum+=2;\\n                d/=2;\\n            }\\n            for(int i=3; i<=sqrt(d); i+=2)\\n            {\\n                while(d%i==0)\\n                {\\n                    sum+=i;\\n                    d/=i;\\n                }\\n            }\\n            \\n            if(d>1)\\n            sum+=d;\\n            cout<<sum<<endl;\\n            if(ispri(sum) || sum==k)\\n            {\\n                d=sum;\\n                break;\\n            }\\n            \\n            d=sum;\\n        }\\n\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4043916,
                "title": "java-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere is my method and recursion based solution in Java\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMethod and Recursion\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n3 ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n38.9 mb\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n         int i=2, sum=0;\\n         while(n>1){\\n                if(n%i==0){\\n                    n=n/i;\\n                    sum+=i;\\n                }else{\\n                    i++;\\n                } \\n            }\\n        if(isPrime(sum)==true){\\n            return sum;\\n        } \\n        return smallestValue(sum);\\n     }   \\n    public boolean isPrime(int k){\\n        if(k<2){\\n            return false;\\n        }   \\n        for (int p = 2; p < k/2; p++) {\\n                if (k % p == 0) {\\n                return false;\\n            }\\n        } \\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n         int i=2, sum=0;\\n         while(n>1){\\n                if(n%i==0){\\n                    n=n/i;\\n                    sum+=i;\\n                }else{\\n                    i++;\\n                } \\n            }\\n        if(isPrime(sum)==true){\\n            return sum;\\n        } \\n        return smallestValue(sum);\\n     }   \\n    public boolean isPrime(int k){\\n        if(k<2){\\n            return false;\\n        }   \\n        for (int p = 2; p < k/2; p++) {\\n                if (k % p == 0) {\\n                return false;\\n            }\\n        } \\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039919,
                "title": "easy-straight-forward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int res = primeFactorsSum(n);\\n        int prevRes = n;\\n        \\n        while(isprime(res) != 1 && res != prevRes){\\n            prevRes = res;\\n            res = primeFactorsSum(res);\\n            \\n        }\\n\\n        return res;\\n    }\\n\\n    public int primeFactorsSum(int n){\\n        int sum = 0;\\n      for(int i = 2; i<= n; i++){\\n          if(isprime(i)==1){\\n             int x = n;\\n             while(x%i==0){\\n                x /= i;\\n                sum += i;\\n             }\\n          }\\n       }\\n       return sum;\\n   }\\n\\n\\n   public int isprime(int n){\\n      for(int i = 2; i<=Math.sqrt(n); i++){\\n        if(n%i==0)\\n          return 0;\\n      }\\n\\n      return 1;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int res = primeFactorsSum(n);\\n        int prevRes = n;\\n        \\n        while(isprime(res) != 1 && res != prevRes){\\n            prevRes = res;\\n            res = primeFactorsSum(res);\\n            \\n        }\\n\\n        return res;\\n    }\\n\\n    public int primeFactorsSum(int n){\\n        int sum = 0;\\n      for(int i = 2; i<= n; i++){\\n          if(isprime(i)==1){\\n             int x = n;\\n             while(x%i==0){\\n                x /= i;\\n                sum += i;\\n             }\\n          }\\n       }\\n       return sum;\\n   }\\n\\n\\n   public int isprime(int n){\\n      for(int i = 2; i<=Math.sqrt(n); i++){\\n        if(n%i==0)\\n          return 0;\\n      }\\n\\n      return 1;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036818,
                "title": "smallest-value-after-replacing-with-sum-of-prime-factors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n)  {\\n       int primeSum = getPrimeSum(n);\\n    while (n != primeSum) {\\n      n = primeSum;\\n      primeSum = getPrimeSum(n);\\n    }\\n    return n;\\n  }\\n\\n  private int getPrimeSum(int n) {\\n    int primeSum = 0;\\n    for (int i = 2; i <= n; ++i)\\n      while (n % i == 0) {\\n        n /= i;\\n        primeSum += i;\\n      }\\n    return primeSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n)  {\\n       int primeSum = getPrimeSum(n);\\n    while (n != primeSum) {\\n      n = primeSum;\\n      primeSum = getPrimeSum(n);\\n    }\\n    return n;\\n  }\\n\\n  private int getPrimeSum(int n) {\\n    int primeSum = 0;\\n    for (int i = 2; i <= n; ++i)\\n      while (n % i == 0) {\\n        n /= i;\\n        primeSum += i;\\n      }\\n    return primeSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011302,
                "title": "beats-100-in-runtime-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n   \\n    if (n <= 1)\\n        return false;\\n\\n    for (int i = 2; i <= n / 2; i++)\\n        if (n % i == 0)\\n            return false;\\n \\n    return true;\\n} \\n\\n    int primeFactors(int n){\\n    int sum=0;\\n    while (n % 2 == 0)\\n    {\\n        sum+=2;\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        while (n % i == 0)\\n        {\\n            sum+=i;\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)\\n        sum+=n;\\n\\n        return sum;\\n}\\n\\n    int smallestValue(int n) {\\n        int x=primeFactors(n);\\n        if(x==n){\\n            return n;\\n        }\\n        while(!isPrime(x)){\\n            x=primeFactors(x);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n   \\n    if (n <= 1)\\n        return false;\\n\\n    for (int i = 2; i <= n / 2; i++)\\n        if (n % i == 0)\\n            return false;\\n \\n    return true;\\n} \\n\\n    int primeFactors(int n){\\n    int sum=0;\\n    while (n % 2 == 0)\\n    {\\n        sum+=2;\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        while (n % i == 0)\\n        {\\n            sum+=i;\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)\\n        sum+=n;\\n\\n        return sum;\\n}\\n\\n    int smallestValue(int n) {\\n        int x=primeFactors(n);\\n        if(x==n){\\n            return n;\\n        }\\n        while(!isPrime(x)){\\n            x=primeFactors(x);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006156,
                "title": "simple-brute-force-solution-beats-100-continue-until-num-becomes-prime",
                "content": "# Intuition\\nThe num will keep on reducing via the given critera , until it becomes a prime number;\\n\\n# Approach\\nSimple brute force using the given method to reduce a number , until the number itself becomes a prime one...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        for(int i=2;i<=n/2;i++){\\n            if(n%i==0)return false;\\n        }  \\n        return true;\\n    }\\n\\n    vector<int> helper(int n){\\n        vector<int> facts;\\n        int num=2;\\n        while(!isPrime(n)){\\n            if(isPrime(num)){\\n                while(n%num==0){\\n                    facts.push_back(num);\\n                    n/=num;\\n                }\\n            }\\n            num++;\\n        }\\n        if(n>1)facts.push_back(n);\\n        return facts;\\n    }\\n\\n    int smallestValue(int n) {\\n        int out=n;\\n        while(!isPrime(n)){\\n            vector<int> facts=helper(n);\\n            int sum=0;\\n            for(auto num:facts)sum+=num;\\n            if(n==sum)break;\\n            n=sum;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        for(int i=2;i<=n/2;i++){\\n            if(n%i==0)return false;\\n        }  \\n        return true;\\n    }\\n\\n    vector<int> helper(int n){\\n        vector<int> facts;\\n        int num=2;\\n        while(!isPrime(n)){\\n            if(isPrime(num)){\\n                while(n%num==0){\\n                    facts.push_back(num);\\n                    n/=num;\\n                }\\n            }\\n            num++;\\n        }\\n        if(n>1)facts.push_back(n);\\n        return facts;\\n    }\\n\\n    int smallestValue(int n) {\\n        int out=n;\\n        while(!isPrime(n)){\\n            vector<int> facts=helper(n);\\n            int sum=0;\\n            for(auto num:facts)sum+=num;\\n            if(n==sum)break;\\n            n=sum;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993377,
                "title": "beats-56-20-of-users-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     public int smallestValue(int n) {\\n         if(n == 4) return 4;\\n        List<Integer> pF = primeFactors(n);\\n        while (pF.size() != 1) {\\n            pF = primeFactors(pF.stream().reduce(Integer::sum).get());\\n        }\\n\\n        return pF.get(0);\\n    }\\n\\n    private List<Integer> primeFactors(int n) {\\n        List<Integer> pf = new ArrayList<>();\\n        while (n % 2 == 0) {\\n            pf.add(2);\\n            n /= 2;\\n        }\\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            // While i divides n, print i and divide n\\n            while (n % i == 0) {\\n                pf.add(i);\\n                n /= i;\\n            }\\n        }\\n        if (n > 2)\\n            pf.add(n);\\n\\n        return pf;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int smallestValue(int n) {\\n         if(n == 4) return 4;\\n        List<Integer> pF = primeFactors(n);\\n        while (pF.size() != 1) {\\n            pF = primeFactors(pF.stream().reduce(Integer::sum).get());\\n        }\\n\\n        return pF.get(0);\\n    }\\n\\n    private List<Integer> primeFactors(int n) {\\n        List<Integer> pf = new ArrayList<>();\\n        while (n % 2 == 0) {\\n            pf.add(2);\\n            n /= 2;\\n        }\\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            // While i divides n, print i and divide n\\n            while (n % i == 0) {\\n                pf.add(i);\\n                n /= i;\\n            }\\n        }\\n        if (n > 2)\\n            pf.add(n);\\n\\n        return pf;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982938,
                "title": "c-recursive-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int SmallestValue(int n)\\n    {\\n        if (n == 4)\\n        {\\n            return 4;\\n        }\\n\\n        var list = new List<int>();\\n\\n        for (var i = 2; i <= n; i++)\\n        {\\n            while (n % i == 0)\\n            {\\n                n /= i;\\n                list.Add(i);\\n            }\\n        }\\n\\n        if (list.Count == 1)\\n        {\\n            return list[0];\\n        }\\n\\n        var result = list.Sum();\\n\\n        return SmallestValue(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int SmallestValue(int n)\\n    {\\n        if (n == 4)\\n        {\\n            return 4;\\n        }\\n\\n        var list = new List<int>();\\n\\n        for (var i = 2; i <= n; i++)\\n        {\\n            while (n % i == 0)\\n            {\\n                n /= i;\\n                list.Add(i);\\n            }\\n        }\\n\\n        if (list.Count == 1)\\n        {\\n            return list[0];\\n        }\\n\\n        var result = list.Sum();\\n\\n        return SmallestValue(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917157,
                "title": "very-easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){    // function to check prime or not\\n        if(n==1) return false;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }   \\n\\n    int smallestValue(int n) {\\n        if(isPrime(n)) return n;    \\n        int sum=0;\\n\\n        for(int i=1;i<sqrt(n);i++){\\n            if(n%i==0 && isPrime(i)){  // prime factor hoga tbhi add krna hai\\n                int m = n;\\n                while(m%i==0){   // agr num ek hi integer se bar bar kte to sbko add krna hai\\n                    sum += i;\\n                    m /= i;\\n                }\\n            }\\n        }\\n        for(int i=sqrt(n);i>=1;i--){\\n            if(n%i==0 && isPrime(n/i)){\\n                int m = n;\\n                while(m%(n/i)==0){\\n                    sum += n/i;\\n                    m /= (n/i);\\n                }\\n            }\\n        }\\n        if(n==4) return 4;  \\n        return smallestValue(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){    // function to check prime or not\\n        if(n==1) return false;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }   \\n\\n    int smallestValue(int n) {\\n        if(isPrime(n)) return n;    \\n        int sum=0;\\n\\n        for(int i=1;i<sqrt(n);i++){\\n            if(n%i==0 && isPrime(i)){  // prime factor hoga tbhi add krna hai\\n                int m = n;\\n                while(m%i==0){   // agr num ek hi integer se bar bar kte to sbko add krna hai\\n                    sum += i;\\n                    m /= i;\\n                }\\n            }\\n        }\\n        for(int i=sqrt(n);i>=1;i--){\\n            if(n%i==0 && isPrime(n/i)){\\n                int m = n;\\n                while(m%(n/i)==0){\\n                    sum += n/i;\\n                    m /= (n/i);\\n                }\\n            }\\n        }\\n        if(n==4) return 4;  \\n        return smallestValue(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898543,
                "title": "c-easy-to-understand-prime-factorization-intuitive",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int  sumPrimeFactors(int n)\\n    {\\n    int sum=0;\\n    while (n % 2 == 0)\\n    {\\n        sum+=2;\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        while (n % i == 0)\\n        {\\n            sum+=i;\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)sum+=n;\\n    return sum;\\n}\\n\\n    int smallestValue(int n) {\\n      while(true)  {\\n          int sum=sumPrimeFactors(n);\\n          if(n==sum)break;\\n          n=sum;\\n      }\\n      return n;\\n    }\\n};\\n```\\n![vote.png](https://assets.leetcode.com/users/images/23286c0f-6550-4aa1-a692-51dc2b82344e_1691832793.5628052.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  sumPrimeFactors(int n)\\n    {\\n    int sum=0;\\n    while (n % 2 == 0)\\n    {\\n        sum+=2;\\n        n = n/2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n        while (n % i == 0)\\n        {\\n            sum+=i;\\n            n = n/i;\\n        }\\n    }\\n    if (n > 2)sum+=n;\\n    return sum;\\n}\\n\\n    int smallestValue(int n) {\\n      while(true)  {\\n          int sum=sumPrimeFactors(n);\\n          if(n==sum)break;\\n          n=sum;\\n      }\\n      return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894747,
                "title": "beginner-friendly-java-solution-with-seive-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static void seive(int n, boolean[] arr){\\n        arr[0]=false;\\n        arr[1]=false;\\n        for (int prime=2; prime*prime<=n; prime++){\\n            if (arr[prime]){\\n                for (int fact=2*prime; fact<=n; fact+=prime){\\n                    arr[fact]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int getSum(int n, boolean[] arr) {\\n        int sum=0;\\n        for (int i=2; i<=n/2; i++){\\n            if (arr[i]){\\n                while (n%i == 0){\\n                    sum += i;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        if(n > 1){\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n\\n    public int smallestValue(int n) {\\n        if(n<=5){\\n            return n;\\n        }\\n\\n        boolean[] arr = new boolean[n+1];\\n        Arrays.fill(arr,true);\\n        seive(n,arr);\\n\\n        // System.out.println(Arrays.toString(arr));\\n        \\n        while (!arr[n]){\\n            int sum=getSum(n,arr);\\n            if (arr[sum]){\\n                return sum;\\n            }\\n            if(sum == n){\\n                break;\\n            }\\n            n = sum;\\n        }\\n\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void seive(int n, boolean[] arr){\\n        arr[0]=false;\\n        arr[1]=false;\\n        for (int prime=2; prime*prime<=n; prime++){\\n            if (arr[prime]){\\n                for (int fact=2*prime; fact<=n; fact+=prime){\\n                    arr[fact]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int getSum(int n, boolean[] arr) {\\n        int sum=0;\\n        for (int i=2; i<=n/2; i++){\\n            if (arr[i]){\\n                while (n%i == 0){\\n                    sum += i;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        if(n > 1){\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n\\n    public int smallestValue(int n) {\\n        if(n<=5){\\n            return n;\\n        }\\n\\n        boolean[] arr = new boolean[n+1];\\n        Arrays.fill(arr,true);\\n        seive(n,arr);\\n\\n        // System.out.println(Arrays.toString(arr));\\n        \\n        while (!arr[n]){\\n            int sum=getSum(n,arr);\\n            if (arr[sum]){\\n                return sum;\\n            }\\n            if(sum == n){\\n                break;\\n            }\\n            n = sum;\\n        }\\n\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846602,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n      k = n \\n      while k != self.primefactorssum(k):\\n        k = self.primefactorssum(k)\\n      return k\\n    def primefactorssum(self,n):\\n      factorssum = 0\\n      for i in range(2,int(n**0.5)+1):\\n        if n%i == 0:\\n          while n%i == 0:\\n            factorssum+= i\\n            n//= i\\n      if n >= 2:\\n        factorssum+=n\\n      return factorssum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n      k = n \\n      while k != self.primefactorssum(k):\\n        k = self.primefactorssum(k)\\n      return k\\n    def primefactorssum(self,n):\\n      factorssum = 0\\n      for i in range(2,int(n**0.5)+1):\\n        if n%i == 0:\\n          while n%i == 0:\\n            factorssum+= i\\n            n//= i\\n      if n >= 2:\\n        factorssum+=n\\n      return factorssum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788684,
                "title": "golang-solution",
                "content": "# Code\\n```Go\\nfunc smallestValue(n int) int {\\n\\tsortPrimes := make([]int, 0, 16)\\n\\tprimeMap := make(map[int]bool)\\n\\n\\t// n maybe prime value!\\n\\t// we must calculte to n, inclusive\\n\\tfor i := 1 ; i <= n; i++ {\\n\\t\\tif isPrime(i) {\\n\\t\\t\\tsortPrimes = append(sortPrimes, i)\\n\\t\\t\\tprimeMap[i] = true\\n\\t\\t}\\n\\t}\\n\\n\\tfor {\\n\\t\\tnext := primeSum(n, sortPrimes, primeMap)\\n\\t\\tif next == n {\\n\\t\\t\\t// take care of 4!\\n\\t\\t\\t// no less value, return as result\\n\\t\\t\\treturn next\\n\\t\\t}\\n\\t\\tn = next\\n\\t}\\n}\\n\\nfunc primeSum(n int, sortPrimes []int, primeMap map[int]bool) int {\\n\\tsummation := 0\\n\\tfor n != 1 {\\n\\t\\tif primeMap[n] {\\n\\t\\t\\tsummation += n\\n\\t\\t\\treturn summation\\n\\t\\t}\\n\\t\\tfor i := 0; i < len(sortPrimes); {\\n\\t\\t\\tif n % sortPrimes[i] == 0 {\\n\\t\\t\\t\\tn = n / sortPrimes[i]\\n\\t\\t\\t\\tsummation += sortPrimes[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn summation\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v%2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i*i <= v; i += 2 {\\n\\t\\tif v%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```Go\\nfunc smallestValue(n int) int {\\n\\tsortPrimes := make([]int, 0, 16)\\n\\tprimeMap := make(map[int]bool)\\n\\n\\t// n maybe prime value!\\n\\t// we must calculte to n, inclusive\\n\\tfor i := 1 ; i <= n; i++ {\\n\\t\\tif isPrime(i) {\\n\\t\\t\\tsortPrimes = append(sortPrimes, i)\\n\\t\\t\\tprimeMap[i] = true\\n\\t\\t}\\n\\t}\\n\\n\\tfor {\\n\\t\\tnext := primeSum(n, sortPrimes, primeMap)\\n\\t\\tif next == n {\\n\\t\\t\\t// take care of 4!\\n\\t\\t\\t// no less value, return as result\\n\\t\\t\\treturn next\\n\\t\\t}\\n\\t\\tn = next\\n\\t}\\n}\\n\\nfunc primeSum(n int, sortPrimes []int, primeMap map[int]bool) int {\\n\\tsummation := 0\\n\\tfor n != 1 {\\n\\t\\tif primeMap[n] {\\n\\t\\t\\tsummation += n\\n\\t\\t\\treturn summation\\n\\t\\t}\\n\\t\\tfor i := 0; i < len(sortPrimes); {\\n\\t\\t\\tif n % sortPrimes[i] == 0 {\\n\\t\\t\\t\\tn = n / sortPrimes[i]\\n\\t\\t\\t\\tsummation += sortPrimes[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn summation\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v%2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i*i <= v; i += 2 {\\n\\t\\tif v%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736703,
                "title": "simple-no-recursion-easy-peasy-java-solution",
                "content": "class Solution {\\n    public int smallestValue(int n) {\\n        int prev = 0; \\n        while(n!=prev) {\\n            prev = n ;\\n            int d =2 ; int ans = 0 ;\\n            while(n>1) {\\n                if(n%d==0) {\\n                    ans+=d ;\\n                    n=n/d ;\\n                }\\n                else {\\n                    d++ ;\\n                    continue ;\\n                }\\n            }\\n            n=ans ;\\n        }\\n        return n ;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int smallestValue(int n) {\\n        int prev = 0; \\n        while(n!=prev) {\\n            prev = n ;\\n            int d =2 ; int ans = 0 ;\\n            while(n>1) {\\n                if(n%d==0) {\\n                    ans+=d ;\\n                    n=n/d ;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3735025,
                "title": "c-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic: \\n    int helper(int n)\\n    {\\n        int sum=0;\\n        for(int i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>1) sum+=n;\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int sum;\\n        while(true){\\n            sum=helper(sum);\\n            if(sum==n) break;\\n            n=sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int helper(int n)\\n    {\\n        int sum=0;\\n        for(int i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>1) sum+=n;\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int sum;\\n        while(true){\\n            sum=helper(sum);\\n            if(sum==n) break;\\n            n=sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720149,
                "title": "c-solution-faster-than-100-simple-solution",
                "content": "class Solution {\\npublic:\\n    int simulate(int n)\\n    {\\n        int t=0;\\n        while(n%2==0)\\n        {\\n            t+=2;\\n            n/=2;\\n        }\\n        for(int i=3;i<=sqrt(n);i+=2)\\n        {\\n            while(n%i==0)\\n            {\\n                t+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>1)\\n            t+=n;\\n        return t;\\n    }\\n    bool isprime(int n)\\n    {\\n        for(int i=2;i<=sqrt(n);i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(n==4)\\n            return 4;\\n        while(!isprime(n))\\n        {\\n            n=simulate(n);\\n        }\\n        return n;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int simulate(int n)\\n    {\\n        int t=0;\\n        while(n%2==0)\\n        {\\n            t+=2;\\n            n/=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3676061,
                "title": "c-easy-solution-recursion-and-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(SQRT(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    { \\n        if(x==1)\\n        { \\n            return false;\\n        }\\n        for(int i=2;i<=sqrt(x);i++)\\n        { \\n            if(x%i==0)\\n            { \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(isPrime(n))\\n            return n;\\n        int sum =0;\\n\\n        for(int i=1;i<sqrt(n);i++)\\n        { \\n            if(n%i==0 && isPrime(i))\\n            { \\n                int m = n;\\n                while(m%i==0)\\n                { \\n                    sum+=i;\\n                    m/=i;\\n                }\\n            }\\n        }\\n        for(int i=sqrt(n);i>1;i--)\\n        { \\n             if(n%i==0 && isPrime(n/i))\\n            { \\n                int m = n;\\n                while(m%(n/i)==0)\\n                { \\n                    sum+=(n/i);\\n                    m/=(n/i);\\n                }\\n            }\\n\\n        }\\n        if(sum==n)\\n            return n;\\n\\n        return smallestValue(sum);\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    { \\n        if(x==1)\\n        { \\n            return false;\\n        }\\n        for(int i=2;i<=sqrt(x);i++)\\n        { \\n            if(x%i==0)\\n            { \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        if(isPrime(n))\\n            return n;\\n        int sum =0;\\n\\n        for(int i=1;i<sqrt(n);i++)\\n        { \\n            if(n%i==0 && isPrime(i))\\n            { \\n                int m = n;\\n                while(m%i==0)\\n                { \\n                    sum+=i;\\n                    m/=i;\\n                }\\n            }\\n        }\\n        for(int i=sqrt(n);i>1;i--)\\n        { \\n             if(n%i==0 && isPrime(n/i))\\n            { \\n                int m = n;\\n                while(m%(n/i)==0)\\n                { \\n                    sum+=(n/i);\\n                    m/=(n/i);\\n                }\\n            }\\n\\n        }\\n        if(sum==n)\\n            return n;\\n\\n        return smallestValue(sum);\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672976,
                "title": "easiest-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pf(int number) {\\n    int primeSum = 0;\\n    int divisor = 2;\\n\\n    while (number > 1) {\\n        if (number % divisor == 0) {\\n            primeSum += divisor;\\n            number /= divisor;\\n        } else {\\n            divisor++;\\n        }\\n    }\\n\\n    return primeSum;\\n}\\n    int smallestValue(int n) {\\n        int num = pf(n);\\n        if(num== n)\\n            return n;\\n        else \\n            return smallestValue(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pf(int number) {\\n    int primeSum = 0;\\n    int divisor = 2;\\n\\n    while (number > 1) {\\n        if (number % divisor == 0) {\\n            primeSum += divisor;\\n            number /= divisor;\\n        } else {\\n            divisor++;\\n        }\\n    }\\n\\n    return primeSum;\\n}\\n    int smallestValue(int n) {\\n        int num = pf(n);\\n        if(num== n)\\n            return n;\\n        else \\n            return smallestValue(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665841,
                "title": "c-easy-to-understand-math-0-ms-runtime-beats-93",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        int sum=0;\\n        while (n%2==0) \\n        {\\n            sum+=2;\\n            n=n/2;\\n        }\\n        for(int i=3;i<=sqrt(n);i+=2) \\n        {\\n            while(n%i==0) \\n            {\\n                sum+=i;\\n                n=n/i;\\n            }\\n        }\\n        if(n>2) sum+=n;\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int m;\\n        while(1)\\n        {\\n            m=solve(n);\\n            if(n==m) return n;\\n            n=m;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        int sum=0;\\n        while (n%2==0) \\n        {\\n            sum+=2;\\n            n=n/2;\\n        }\\n        for(int i=3;i<=sqrt(n);i+=2) \\n        {\\n            while(n%i==0) \\n            {\\n                sum+=i;\\n                n=n/i;\\n            }\\n        }\\n        if(n>2) sum+=n;\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int m;\\n        while(1)\\n        {\\n            m=solve(n);\\n            if(n==m) return n;\\n            n=m;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663124,
                "title": "new-approach-iterative-you-will-like-it",
                "content": "# Intuition\\nkeep updating n according to question\\n\\n# Approach\\ncalculate factor and its count in pair of vector\\nand udating n and calculating pair of vector again\\noutput is prime or number itself(eg->4) when new n  is equal to old value of n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(N)) for is_prime and for  calculating primefactorization O(sizeofprimefactorizationarray) for calculation new array this whole multiply by number of time our loop itrates\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(sizeofprimefactorizationarray)*number of times loop iterates\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void primefactorizationoptimized(int n,vector<pair<int,int>>&v){  for(int i=2; i*i<=n; i++){ if(n%i==0){ int cnt=0;   while (n%i==0) {cnt++;n/=i;} v.push_back({i,cnt});}}if(n>1) {v.push_back({n,1});}}\\n   long long int func(vector<pair<int,int>>&v) {\\n      long long   int sum = 0;\\n        for(auto it:v) {\\n            sum+=(it.first*it.second);\\n        }\\n       return sum;\\n    }\\n    bool is_prime(int n) {\\n        for(int i =2;i*i<=n;i++) {\\n            if(n%i==0 ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        \\n        \\n       \\n       \\n       while(true) {\\n          \\n           vector<pair<int,int>>v;\\n            primefactorizationoptimized(n,v);\\n         \\n            if(func(v)==n) {\\n               return n;\\n           }\\n             n = func(v);\\n           if(is_prime(n)){\\n               return n;\\n           }\\n       }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void primefactorizationoptimized(int n,vector<pair<int,int>>&v){  for(int i=2; i*i<=n; i++){ if(n%i==0){ int cnt=0;   while (n%i==0) {cnt++;n/=i;} v.push_back({i,cnt});}}if(n>1) {v.push_back({n,1});}}\\n   long long int func(vector<pair<int,int>>&v) {\\n      long long   int sum = 0;\\n        for(auto it:v) {\\n            sum+=(it.first*it.second);\\n        }\\n       return sum;\\n    }\\n    bool is_prime(int n) {\\n        for(int i =2;i*i<=n;i++) {\\n            if(n%i==0 ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int smallestValue(int n) {\\n        \\n        \\n       \\n       \\n       while(true) {\\n          \\n           vector<pair<int,int>>v;\\n            primefactorizationoptimized(n,v);\\n         \\n            if(func(v)==n) {\\n               return n;\\n           }\\n             n = func(v);\\n           if(is_prime(n)){\\n               return n;\\n           }\\n       }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656496,
                "title": "prime-factorization-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans;\\n    int y;\\n    bool isPrime (int n){\\n        for (int i = 2; i*i<=n; i++){\\n            if (n%i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void SR(int n){\\n        int divisor = 2;\\n        int sm = 0;\\n        while (!isPrime(n)){\\n            sm = 0;\\n            divisor = 2;\\n            while (n != 1){\\n                if (n%divisor == 0){\\n                    sm += divisor;\\n                    n = n/divisor;\\n                }\\n                else{\\n                    divisor++;\\n                }\\n            }\\n            n = sm;\\n            if (n == y){\\n                break;\\n            }\\n        }\\n        ans = n;\\n        \\n    }\\n\\n    int smallestValue(int n) {\\n        if (isPrime(n)){\\n            return n;\\n        }\\n        y = n;\\n        ans = INT_MAX;\\n        SR(n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans;\\n    int y;\\n    bool isPrime (int n){\\n        for (int i = 2; i*i<=n; i++){\\n            if (n%i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void SR(int n){\\n        int divisor = 2;\\n        int sm = 0;\\n        while (!isPrime(n)){\\n            sm = 0;\\n            divisor = 2;\\n            while (n != 1){\\n                if (n%divisor == 0){\\n                    sm += divisor;\\n                    n = n/divisor;\\n                }\\n                else{\\n                    divisor++;\\n                }\\n            }\\n            n = sm;\\n            if (n == y){\\n                break;\\n            }\\n        }\\n        ans = n;\\n        \\n    }\\n\\n    int smallestValue(int n) {\\n        if (isPrime(n)){\\n            return n;\\n        }\\n        y = n;\\n        ans = INT_MAX;\\n        SR(n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649419,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n     bool isPrime(int n){\\n    if(n==1 || n<0) return false;\\n    for(int i=2;i<=sqrt(n);i++){\\n        if(n%i==0) return false;\\n    }\\n    return true;\\n}\\n    int smallestValue(int n) {\\n        if(isPrime(n)) return n;\\n        int sum =0;\\n         for(int i=1;i<sqrt(n);i++){\\n        if(n%i==0 && isPrime(i)){\\n            int m= n;\\n            while(m%i==0){\\n                sum +=i;\\n               m= m/i;\\n            }\\n        }\\n    }\\n    for(int i=sqrt(n);i>=1;i--){\\n        if(n%i==0 && isPrime(n/i)){\\n            int m = n;\\n            while(m%(n/i)==0){\\n                sum +=n/i;\\n                m=m/(n/i);\\n            }\\n\\n        }\\n    }\\n\\n    if(sum==n) return n;\\n    return  smallestValue(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n     bool isPrime(int n){\\n    if(n==1 || n<0) return false;\\n    for(int i=2;i<=sqrt(n);i++){\\n        if(n%i==0) return false;\\n    }\\n    return true;\\n}\\n    int smallestValue(int n) {\\n        if(isPrime(n)) return n;\\n        int sum =0;\\n         for(int i=1;i<sqrt(n);i++){\\n        if(n%i==0 && isPrime(i)){\\n            int m= n;\\n            while(m%i==0){\\n                sum +=i;\\n               m= m/i;\\n            }\\n        }\\n    }\\n    for(int i=sqrt(n);i>=1;i--){\\n        if(n%i==0 && isPrime(n/i)){\\n            int m = n;\\n            while(m%(n/i)==0){\\n                sum +=n/i;\\n                m=m/(n/i);\\n            }\\n\\n        }\\n    }\\n\\n    if(sum==n) return n;\\n    return  smallestValue(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632633,
                "title": "ruby-solution-with-memoization-50-100",
                "content": "# Intuition\\nFind the prime factors of each number and add them until the number itself is prime.\\n\\n# Approach\\n1. Create a memo as a class variable (since this function is called multiple times).  Include the edge case four; every other number will stop when it\\'s prime.\\n2. Have a list of primes up to the square root of 10**5.\\n\\n3. Check memo and return the memoized solution if possible.\\n4. Find a list of prime factors using a helper function.\\n5. If there\\'s only one prime factor, return that number.  Otherwise, add the factors and run the function again.  Memoize either way.\\n\\nHelper function:\\n6. Iterate through the list of primes:\\n    - If prime is greater than the square root of n, you can stop checking; either num is 1 or num is prime.\\n    - If prime is a factor, divide num by prime as many times as possible, putting the factors into factor.\\n7. If num is greater than 1, it\\'s prime, so put it in factors.  (This could happen either from breaking the loop early or from having a larger prime factor like 317.)\\n8. Return factors.\\n\\n\\n# Code\\n```\\n@memo = {4 => 4}\\n@primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n\\n\\ndef smallest_value(n)\\n    return @memo[n] if @memo[n]\\n    factors = primes(n)\\n    @memo[n] = factors.length == 1 ? factors[0] : smallest_value(factors.sum)\\nend\\n\\ndef primes(num)\\n    factors = []\\n    sqrt = Math.sqrt(num)\\n\\n    @primes.each do |prime|\\n        break if prime > sqrt\\n            num /= prime\\n            factors << prime\\n        end\\n    end\\n\\n    factors << num if num > 1\\n    factors\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n@memo = {4 => 4}\\n@primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n\\n\\ndef smallest_value(n)\\n    return @memo[n] if @memo[n]\\n    factors = primes(n)\\n    @memo[n] = factors.length == 1 ? factors[0] : smallest_value(factors.sum)\\nend\\n\\ndef primes(num)\\n    factors = []\\n    sqrt = Math.sqrt(num)\\n\\n    @primes.each do |prime|\\n        break if prime > sqrt\\n            num /= prime\\n            factors << prime\\n        end\\n    end\\n\\n    factors << num if num > 1\\n    factors\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3608209,
                "title": "sieve-based-solution-easy-simple",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBase on sieve of eratothons (prime number finding algorithm)\\n# Complexity\\n- Time complexity: O(n*log(log(n)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint smallestValue(int n) {\\n\\t\\tvector<int>spf(n + 1, 0);\\n        // spf[i] =  smallest prime factor which devides i\\n\\t\\tfor (int i = 2; i <= n; i++) spf[i] = i;\\n\\t\\t// sieve of eratothons modification\\n        for (int i = 2; i <= n; i++) {\\n\\t\\t\\tif (i <= n / i) { // i*i Int overflow handling\\n\\t\\t\\t\\tfor (int j = i * i; j <= n; j += i) {\\n\\t\\t\\t\\t\\tif (spf[j] == j) {\\n\\t\\t\\t\\t\\t\\tspf[j] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint val = n, factorSum, curval;\\n\\t\\twhile (true) {\\n\\t\\t\\tcurval = val;\\n\\t\\t\\tfactorSum = 0;\\n\\t\\t\\twhile (spf[val] != val) {\\n\\t\\t\\t\\tfactorSum += spf[val];\\n\\t\\t\\t\\tval = val / spf[val];\\n\\t\\t\\t}\\n\\t\\t\\tfactorSum += spf[val];\\n\\t\\t\\t// 4 = 2 * 2 => 2 + 2 = 4 => infinite loop handeling\\n\\t\\t\\tif (factorSum == curval) {\\n\\t\\t\\t\\treturn curval;\\n\\t\\t\\t}\\n\\t\\t\\tval = factorSum;\\n\\t\\t}\\n\\t\\treturn val;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint smallestValue(int n) {\\n\\t\\tvector<int>spf(n + 1, 0);\\n        // spf[i] =  smallest prime factor which devides i\\n\\t\\tfor (int i = 2; i <= n; i++) spf[i] = i;\\n\\t\\t// sieve of eratothons modification\\n        for (int i = 2; i <= n; i++) {\\n\\t\\t\\tif (i <= n / i) { // i*i Int overflow handling\\n\\t\\t\\t\\tfor (int j = i * i; j <= n; j += i) {\\n\\t\\t\\t\\t\\tif (spf[j] == j) {\\n\\t\\t\\t\\t\\t\\tspf[j] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint val = n, factorSum, curval;\\n\\t\\twhile (true) {\\n\\t\\t\\tcurval = val;\\n\\t\\t\\tfactorSum = 0;\\n\\t\\t\\twhile (spf[val] != val) {\\n\\t\\t\\t\\tfactorSum += spf[val];\\n\\t\\t\\t\\tval = val / spf[val];\\n\\t\\t\\t}\\n\\t\\t\\tfactorSum += spf[val];\\n\\t\\t\\t// 4 = 2 * 2 => 2 + 2 = 4 => infinite loop handeling\\n\\t\\t\\tif (factorSum == curval) {\\n\\t\\t\\t\\treturn curval;\\n\\t\\t\\t}\\n\\t\\t\\tval = factorSum;\\n\\t\\t}\\n\\t\\treturn val;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550403,
                "title": "easy-solution-in-python-with-10-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n):\\n        prev, ans = n, 0\\n        while not n%2:\\n                ans += 2\\n                n//= 2\\n        for i in range(3,n+1,2):\\n                while not n%i:\\n                    ans += i\\n                    n//= i\\n\\n        return self.smallestValue(ans) if ans != prev else ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n):\\n        prev, ans = n, 0\\n        while not n%2:\\n                ans += 2\\n                n//= 2\\n        for i in range(3,n+1,2):\\n                while not n%i:\\n                    ans += i\\n                    n//= i\\n\\n        return self.smallestValue(ans) if ans != prev else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538724,
                "title": "100-faster-simple-java-solution-with-explanation-easy-to-understand-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to add the prime factors until it beomes a prime number or any other number for which the sum of its prime factors will results the number itself\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nouter loop:O(log(n));\\ninner loop:O(sqrt(n));\\ntotal time complexity:O(sqrt(n)(log(n)));\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int curr=n;\\n        int flag=0;\\n        int prev=n;\\n        while(true)\\n        {\\n            n=curr;\\n            prev=n;\\n            curr=0;\\n            flag=0;\\n//The below loop takes O(sqrt(n)) time\\n            for(int i=2;i*i<=n;i++)\\n            {\\n                while(n%i==0)\\n                {\\n                 curr+=i;  //adding factors of n\\n                 n/=i;\\n                 flag=1;\\n                }\\n            }\\n//if n is a perfect square we also need to add the remaining value if its greater than 1\\n            if(n>1)\\n            curr+=n;\\n//if flag==0 then curr is a prime number ,or if the prev value is \\n//same as curr then we\\'ll enter into a infinte loop so that will be the smallest value we can return curr here\\n            if(flag==0 || prev==curr)\\n            return cur;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int curr=n;\\n        int flag=0;\\n        int prev=n;\\n        while(true)\\n        {\\n            n=curr;\\n            prev=n;\\n            curr=0;\\n            flag=0;\\n//The below loop takes O(sqrt(n)) time\\n            for(int i=2;i*i<=n;i++)\\n            {\\n                while(n%i==0)\\n                {\\n                 curr+=i;  //adding factors of n\\n                 n/=i;\\n                 flag=1;\\n                }\\n            }\\n//if n is a perfect square we also need to add the remaining value if its greater than 1\\n            if(n>1)\\n            curr+=n;\\n//if flag==0 then curr is a prime number ,or if the prev value is \\n//same as curr then we\\'ll enter into a infinte loop so that will be the smallest value we can return curr here\\n            if(flag==0 || prev==curr)\\n            return cur;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520858,
                "title": "prime-factor-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool prime(int n){\\nif(n==1)\\n return false;\\nif(n<=3)\\nreturn true;\\nfor(int i=2;i*i<=n;i++){\\n    if(n%i==0)\\n     return false;\\n}\\nreturn true;\\n}\\n   int smallestValue(int n){\\n       int sum=0,cnt=0,x=n;\\n       for(int i=2;i*i<=n;i++){\\n           cnt=0;\\n           if(n%i==0){\\n               while(n%i==0){\\n                   cnt++;\\n                   n/=i;\\n               }\\n               sum+=cnt*i;\\n           }\\n       }\\n       if(n>1){\\n           sum+=n;\\n       }\\n       if(prime(sum) or sum==x){\\n           return sum;\\n       }\\n       return smallestValue(sum);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool prime(int n){\\nif(n==1)\\n return false;\\nif(n<=3)\\nreturn true;\\nfor(int i=2;i*i<=n;i++){\\n    if(n%i==0)\\n     return false;\\n}\\nreturn true;\\n}\\n   int smallestValue(int n){\\n       int sum=0,cnt=0,x=n;\\n       for(int i=2;i*i<=n;i++){\\n           cnt=0;\\n           if(n%i==0){\\n               while(n%i==0){\\n                   cnt++;\\n                   n/=i;\\n               }\\n               sum+=cnt*i;\\n           }\\n       }\\n       if(n>1){\\n           sum+=n;\\n       }\\n       if(prime(sum) or sum==x){\\n           return sum;\\n       }\\n       return smallestValue(sum);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516949,
                "title": "java-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(n<=5)\\n            return n;\\n        while(prime(n) == false){\\n            int sum =0;\\n            for(int i =2;i<=n;i++){\\n                if(prime(i)){\\n                    while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                    }\\n                }\\n            }\\n            n = sum;\\n        }\\n        return n;\\n    }\\n    public boolean prime(int n){\\n        for(int i = 2;i<=Math.sqrt(n);i++){\\n            if(n%i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(n<=5)\\n            return n;\\n        while(prime(n) == false){\\n            int sum =0;\\n            for(int i =2;i<=n;i++){\\n                if(prime(i)){\\n                    while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                    }\\n                }\\n            }\\n            n = sum;\\n        }\\n        return n;\\n    }\\n    public boolean prime(int n){\\n        for(int i = 2;i<=Math.sqrt(n);i++){\\n            if(n%i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475356,
                "title": "simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isPrime(int n)\\n{\\n    for(int i=2;i<=n/2;i++)\\n    {\\n        if(n%i==0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nint prime_sum(int n)\\n{\\n    for(int i=2;i<n;i++)\\n    {\\n        if(n%i==0)\\n        {\\n            return i+prime_sum(n/i);\\n        }\\n    }\\n    return n;\\n}\\npublic:\\n    int smallestValue(int n) {\\n        if(n==4)\\n        {\\n            return 4;\\n        }\\n        if(isPrime(n))\\n        {\\n            return n;\\n        }\\n        return smallestValue(prime_sum(n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isPrime(int n)\\n{\\n    for(int i=2;i<=n/2;i++)\\n    {\\n        if(n%i==0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nint prime_sum(int n)\\n{\\n    for(int i=2;i<n;i++)\\n    {\\n        if(n%i==0)\\n        {\\n            return i+prime_sum(n/i);\\n        }\\n    }\\n    return n;\\n}\\npublic:\\n    int smallestValue(int n) {\\n        if(n==4)\\n        {\\n            return 4;\\n        }\\n        if(isPrime(n))\\n        {\\n            return n;\\n        }\\n        return smallestValue(prime_sum(n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469369,
                "title": "c-solution-easy-to-understand",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int SmallestValue(int n) {\\n        \\n        int sumPrimeFactors(int number){\\n            int sum = 0;\\n            for(int i = 2; i * i <= number;i++){\\n                while(number % i == 0){\\n                    number/= i;\\n                    sum+=i;\\n                }    \\n            }\\n            if(number > 1) sum+= number;\\n            return sum;\\n        }\\n\\n        while(true){\\n            int prev = n;\\n            n = sumPrimeFactors(n);\\n            if(prev == n) break;\\n        }\\n        return n;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public int SmallestValue(int n) {\\n        \\n        int sumPrimeFactors(int number){\\n            int sum = 0;\\n            for(int i = 2; i * i <= number;i++){\\n                while(number % i == 0){\\n                    number/= i;\\n                    sum+=i;\\n                }    \\n            }\\n            if(number > 1) sum+= number;\\n            return sum;\\n        }\\n\\n        while(true){\\n            int prev = n;\\n            n = sumPrimeFactors(n);\\n            if(prev == n) break;\\n        }\\n        return n;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363561,
                "title": "prime-factorization-fundamental-theorem-of-arithmetic-python",
                "content": "```\\n\"\"\"\\nTreatment: prime decomposition / fundamental theorem of arithmetic\\n\\nHere the question reduces to the task of decomposing an integer into product of primes.\\nOnce we could do this, then get the desired value is just a while loop.\\n\\nSo our focus is on writing an utility function to do prime factorization.\\n\\n15 = 3 * 5; [3, 5]\\n24 = (2 ** 3) * 3; [2, 2, 2, 3]\\n504 = (2 ** 3) * (3 ** 2) * 7; [2, 2, 2, 3, 3, 7]\\n\"\"\"\\n\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        \\n        # step-1 prime factorization\\n        def get_prime_factors(number):\\n            prime_factors = []\\n            # get all 2\\'s\\n            while number % 2 == 0:\\n                prime_factors.append(2)\\n                number //= 2\\n            # get larger prime factors\\n            for i in range(3, int(number ** 0.5) + 1, 2):\\n                while number % i == 0:\\n                    prime_factors.append(i)\\n                    number //= i\\n            if number > 2:\\n                prime_factors.append(number)\\n            return prime_factors, sum(prime_factors)\\n        \\n        # step-2 problem logic\\n        res = get_prime_factors(n)[1]\\n        while res != get_prime_factors(res)[1]:\\n            res = get_prime_factors(res)[1]\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: prime decomposition / fundamental theorem of arithmetic\\n\\nHere the question reduces to the task of decomposing an integer into product of primes.\\nOnce we could do this, then get the desired value is just a while loop.\\n\\nSo our focus is on writing an utility function to do prime factorization.\\n\\n15 = 3 * 5; [3, 5]\\n24 = (2 ** 3) * 3; [2, 2, 2, 3]\\n504 = (2 ** 3) * (3 ** 2) * 7; [2, 2, 2, 3, 3, 7]\\n\"\"\"\\n\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        \\n        # step-1 prime factorization\\n        def get_prime_factors(number):\\n            prime_factors = []\\n            # get all 2\\'s\\n            while number % 2 == 0:\\n                prime_factors.append(2)\\n                number //= 2\\n            # get larger prime factors\\n            for i in range(3, int(number ** 0.5) + 1, 2):\\n                while number % i == 0:\\n                    prime_factors.append(i)\\n                    number //= i\\n            if number > 2:\\n                prime_factors.append(number)\\n            return prime_factors, sum(prime_factors)\\n        \\n        # step-2 problem logic\\n        res = get_prime_factors(n)[1]\\n        while res != get_prime_factors(res)[1]:\\n            res = get_prime_factors(res)[1]\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354269,
                "title": "c-math-faster-easy-to-understand",
                "content": "* ***Math***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int find_sum(int n)\\n    {\\n        int sum = 0;\\n        \\n        // find sum of prime factors\\n        \\n        // first of all find no. of 2 as a prime factors\\n        \\n        while(n % 2 == 0)\\n        {\\n            sum += 2;\\n            \\n            n /= 2;\\n        }\\n        \\n        for(int i = 3; i * i <= n; i += 2)\\n        {\\n            while(n % i == 0)\\n            {\\n                sum += i;\\n                \\n                n /= i;\\n            }\\n        }\\n        \\n        if(n > 2)\\n        {\\n            sum += n;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        while(find_sum(n) < n)\\n        {\\n            n = find_sum(n);\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find_sum(int n)\\n    {\\n        int sum = 0;\\n        \\n        // find sum of prime factors\\n        \\n        // first of all find no. of 2 as a prime factors\\n        \\n        while(n % 2 == 0)\\n        {\\n            sum += 2;\\n            \\n            n /= 2;\\n        }\\n        \\n        for(int i = 3; i * i <= n; i += 2)\\n        {\\n            while(n % i == 0)\\n            {\\n                sum += i;\\n                \\n                n /= i;\\n            }\\n        }\\n        \\n        if(n > 2)\\n        {\\n            sum += n;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        while(find_sum(n) < n)\\n        {\\n            n = find_sum(n);\\n        }\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325907,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int primefactor(int n){\\n       int sum=0;\\n       for(int i=2;1<n;i++){\\n           while(n%i==0){\\n               sum+=i;\\n               n/=i;\\n           }\\n       }\\n       return sum;\\n   }\\n    int smallestValue(int n) {\\n         int sum=primefactor(n);\\n         if(sum==n)return sum;\\n         else\\n       return  smallestValue(sum);\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int primefactor(int n){\\n       int sum=0;\\n       for(int i=2;1<n;i++){\\n           while(n%i==0){\\n               sum+=i;\\n               n/=i;\\n           }\\n       }\\n       return sum;\\n   }\\n    int smallestValue(int n) {\\n         int sum=primefactor(n);\\n         if(sum==n)return sum;\\n         else\\n       return  smallestValue(sum);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321480,
                "title": "java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int ans =0;\\n     while(true){\\n       \\n         int sum =0;\\n         for(int i =2;i<=n;i++){\\n             if(prime(i)){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n             }\\n\\n         }\\n       \\n   \\n         \\n         \\n  int res =sum;\\n   if(ans==res){\\n             break;\\n         }else{\\n             ans = res;\\n         }\\n          n = res;\\n          \\n        //   System.out.print(n+\" \");\\n     } \\n     return ans;\\n    }\\n      public boolean prime(int n)\\n    {\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int ans =0;\\n     while(true){\\n       \\n         int sum =0;\\n         for(int i =2;i<=n;i++){\\n             if(prime(i)){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n             }\\n\\n         }\\n       \\n   \\n         \\n         \\n  int res =sum;\\n   if(ans==res){\\n             break;\\n         }else{\\n             ans = res;\\n         }\\n          n = res;\\n          \\n        //   System.out.print(n+\" \");\\n     } \\n     return ans;\\n    }\\n      public boolean prime(int n)\\n    {\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321224,
                "title": "prime-factorisation-easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calcsum(int n)\\n    {\\n        int sum=0;\\n        int i=2;\\n        while(n>1)\\n        {\\n            if(n%i==0)\\n            {\\n                sum+=i;\\n                n=n/i;\\n            }\\n            else i++;\\n\\n        }\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int flag=0;\\n        int minn=INT_MAX;\\n        while(flag==0)\\n        {\\n            int sum=calcsum(n);\\n            if(sum==n)\\n            flag=1;\\n            minn=min(minn,sum);\\n            n=sum;\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calcsum(int n)\\n    {\\n        int sum=0;\\n        int i=2;\\n        while(n>1)\\n        {\\n            if(n%i==0)\\n            {\\n                sum+=i;\\n                n=n/i;\\n            }\\n            else i++;\\n\\n        }\\n        return sum;\\n    }\\n    int smallestValue(int n) {\\n        int flag=0;\\n        int minn=INT_MAX;\\n        while(flag==0)\\n        {\\n            int sum=calcsum(n);\\n            if(sum==n)\\n            flag=1;\\n            minn=min(minn,sum);\\n            n=sum;\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301566,
                "title": "c-easy-sober-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findnew(int n)\\n{\\n    int divisior = 2;\\nint ans = 0;\\n    while(n>1)\\n    {\\n        if(n%divisior==0)\\n        {\\n            ans = ans + divisior;\\n            n= n/divisior;\\n        }\\n        else\\n        divisior++;\\n    }\\n    return ans;\\n\\n}\\n    int smallestValue(int n) {\\n        \\n        //first seen : blank\\n        //second :   finding pattern   27 3 * 3 *3\\n        //find all pf at every stage  finding diificult to implement\\n        //not efficient\\n\\n        //blankkkkkkkkkkkkkkkkkkkkkkkkkkkk\\n\\n\\n        //see solution . find all pf\\nint number =0;\\nwhile(true)\\n{\\n         number = findnew(n);\\n        if(number==n)\\n        break;\\n        n= number;\\n    }\\n    return  number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findnew(int n)\\n{\\n    int divisior = 2;\\nint ans = 0;\\n    while(n>1)\\n    {\\n        if(n%divisior==0)\\n        {\\n            ans = ans + divisior;\\n            n= n/divisior;\\n        }\\n        else\\n        divisior++;\\n    }\\n    return ans;\\n\\n}\\n    int smallestValue(int n) {\\n        \\n        //first seen : blank\\n        //second :   finding pattern   27 3 * 3 *3\\n        //find all pf at every stage  finding diificult to implement\\n        //not efficient\\n\\n        //blankkkkkkkkkkkkkkkkkkkkkkkkkkkk\\n\\n\\n        //see solution . find all pf\\nint number =0;\\nwhile(true)\\n{\\n         number = findnew(n);\\n        if(number==n)\\n        break;\\n        n= number;\\n    }\\n    return  number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297990,
                "title": "c-2ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> PrimeFactors(int n){\\n        vector<int> prime_factors;\\n        for (int i = 2; i <= sqrt(n); i++){\\n            while (n%i == 0) {\\n                prime_factors.push_back(i);\\n                n /= i;\\n            }\\n        }\\n        if (n>1){\\n            prime_factors.push_back(n);\\n        }\\n\\n        return prime_factors;\\n    }\\n\\n    int smallestValue(int n){\\n        while(true){\\n            vector<int> prime_factors = PrimeFactors(n);\\n            int sum = 0;\\n            for (int val : prime_factors){\\n                sum += val;\\n            }\\n            if (sum == n) return n;\\n            else n = sum;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> PrimeFactors(int n){\\n        vector<int> prime_factors;\\n        for (int i = 2; i <= sqrt(n); i++){\\n            while (n%i == 0) {\\n                prime_factors.push_back(i);\\n                n /= i;\\n            }\\n        }\\n        if (n>1){\\n            prime_factors.push_back(n);\\n        }\\n\\n        return prime_factors;\\n    }\\n\\n    int smallestValue(int n){\\n        while(true){\\n            vector<int> prime_factors = PrimeFactors(n);\\n            int sum = 0;\\n            for (int val : prime_factors){\\n                sum += val;\\n            }\\n            if (sum == n) return n;\\n            else n = sum;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284516,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def help(n: Int, i: Int, res: List[Int]): List[Int] = {\\n        if(n < i) res\\n        else if(n % i == 0) help(n / i, i, i +: res)\\n        else help(n, i + 1, res)\\n    }\\n\\n    def smallestValue(n: Int): Int = {\\n        val res = help(n, 2, List.empty[Int]).sum\\n        if(res == n) n\\n        else smallestValue(res)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def help(n: Int, i: Int, res: List[Int]): List[Int] = {\\n        if(n < i) res\\n        else if(n % i == 0) help(n / i, i, i +: res)\\n        else help(n, i + 1, res)\\n    }\\n\\n    def smallestValue(n: Int): Int = {\\n        val res = help(n, 2, List.empty[Int]).sum\\n        if(res == n) n\\n        else smallestValue(res)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3262572,
                "title": "c-iterative",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int p = primeSum(n);\\n        while(n != p){\\n            n = p;\\n            p = primeSum(n);\\n        }\\n        return n;\\n    }\\n\\n    int primeSum(int n){\\n        int lim = n;\\n        int sum = 0;\\n        for(int i = 2; i <= lim; i++){\\n            \\n            while(n % i == 0){\\n                    n /= i;\\n                    sum += i;\\n                }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int p = primeSum(n);\\n        while(n != p){\\n            n = p;\\n            p = primeSum(n);\\n        }\\n        return n;\\n    }\\n\\n    int primeSum(int n){\\n        int lim = n;\\n        int sum = 0;\\n        for(int i = 2; i <= lim; i++){\\n            \\n            while(n % i == 0){\\n                    n /= i;\\n                    sum += i;\\n                }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259556,
                "title": "rust-100-less-100-faster-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn smallest_value(n: i32) -> i32 {\\n        // 2 <= n <= 105\\n        fn find_all_sub_expr(\\n            num: i32,\\n            cache: &mut HashMap<i32, Vec<i32>>,\\n        ) -> Vec<i32> {\\n            for i in (2..) {\\n                if i * i > num {\\n                    break;\\n                }\\n                if num % i == 0 {\\n                    let mut ret = find_all_sub_expr(num / i, cache);\\n                    ret.push(i);\\n                    cache.entry(num).or_insert(ret.clone());\\n                    return ret;\\n                }\\n            }\\n            let ret = vec![num];\\n            cache.entry(num).or_insert(ret.clone());\\n            ret\\n        };\\n\\n        fn caclculate(\\n            num: i32,\\n            cache: &mut HashMap<i32, Vec<i32>>,\\n            cache_res: &mut HashMap<i32, i32>,\\n        ) -> i32 {\\n            if let Some(&v) = cache_res.get(&num) {\\n                return v;\\n            }\\n            for i in (2..) {\\n                if i * i > num {\\n                    break;\\n                }\\n                if num % i == 0 {\\n                    let ret = find_all_sub_expr(num / i, cache);\\n                    let ret: i32 = ret.into_iter().sum();\\n                    if (i + ret) == num {\\n                        cache_res.entry(num).or_insert(num);\\n                        return num;\\n                    }\\n                    cache_res.entry(num).or_insert(ret);\\n                    return caclculate(ret + i, cache, cache_res);\\n                }\\n            }\\n            cache_res.entry(num).or_insert(num);\\n\\n            num\\n        };\\n\\n        let mut cache = HashMap::new();\\n        let mut cache_res = HashMap::new();\\n        caclculate(n, &mut cache, &mut cache_res)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn smallest_value(n: i32) -> i32 {\\n        // 2 <= n <= 105\\n        fn find_all_sub_expr(\\n            num: i32,\\n            cache: &mut HashMap<i32, Vec<i32>>,\\n        ) -> Vec<i32> {\\n            for i in (2..) {\\n                if i * i > num {\\n                    break;\\n                }\\n                if num % i == 0 {\\n                    let mut ret = find_all_sub_expr(num / i, cache);\\n                    ret.push(i);\\n                    cache.entry(num).or_insert(ret.clone());\\n                    return ret;\\n                }\\n            }\\n            let ret = vec![num];\\n            cache.entry(num).or_insert(ret.clone());\\n            ret\\n        };\\n\\n        fn caclculate(\\n            num: i32,\\n            cache: &mut HashMap<i32, Vec<i32>>,\\n            cache_res: &mut HashMap<i32, i32>,\\n        ) -> i32 {\\n            if let Some(&v) = cache_res.get(&num) {\\n                return v;\\n            }\\n            for i in (2..) {\\n                if i * i > num {\\n                    break;\\n                }\\n                if num % i == 0 {\\n                    let ret = find_all_sub_expr(num / i, cache);\\n                    let ret: i32 = ret.into_iter().sum();\\n                    if (i + ret) == num {\\n                        cache_res.entry(num).or_insert(num);\\n                        return num;\\n                    }\\n                    cache_res.entry(num).or_insert(ret);\\n                    return caclculate(ret + i, cache, cache_res);\\n                }\\n            }\\n            cache_res.entry(num).or_insert(num);\\n\\n            num\\n        };\\n\\n        let mut cache = HashMap::new();\\n        let mut cache_res = HashMap::new();\\n        caclculate(n, &mut cache, &mut cache_res)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223011,
                "title": "simple-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        boolean flag = true;\\n        int previous = n;\\n        int calculate = 0;\\n\\n      while(true){\\n       calculate = 0;     \\n       previous = n;\\n         while (n%2==0 && n!=0)\\n        {\\n            n /= 2;\\n            calculate +=2;\\n        }\\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\\n        {\\n            while (n%i == 0)\\n            {\\n        \\n               n /= i;\\n               calculate +=i;\\n            }\\n        }\\n        if (n > 2)\\n\\t\\t\\tcalculate+=n;\\n         n = calculate;\\n        if(previous == calculate) break;\\n       \\n        }\\n        return calculate;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        boolean flag = true;\\n        int previous = n;\\n        int calculate = 0;\\n\\n      while(true){\\n       calculate = 0;     \\n       previous = n;\\n         while (n%2==0 && n!=0)\\n        {\\n            n /= 2;\\n            calculate +=2;\\n        }\\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\\n        {\\n            while (n%i == 0)\\n            {\\n        \\n               n /= i;\\n               calculate +=i;\\n            }\\n        }\\n        if (n > 2)\\n\\t\\t\\tcalculate+=n;\\n         n = calculate;\\n        if(previous == calculate) break;\\n       \\n        }\\n        return calculate;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219675,
                "title": "interesting-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        \\n          int answer = 0, x = sqrt(n);\\n        \\n          for(int i =2; i <=x; i++){\\n                  \\n                   while(n%i==0){\\n                         n/=i;\\n                         answer+=i;\\n                   }\\n          }\\n        \\n          if(n >1)answer+=n;\\n        \\n          return answer;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        \\n        while(n!=solve(n)){\\n             n= solve(n);\\n        }\\n        \\n        return solve(n);\\n    }\\n};```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        \\n          int answer = 0, x = sqrt(n);\\n        \\n          for(int i =2; i <=x; i++){\\n                  \\n                   while(n%i==0){\\n                         n/=i;\\n                         answer+=i;\\n                   }\\n          }\\n        \\n          if(n >1)answer+=n;\\n        \\n          return answer;\\n    }\\n    \\n    int smallestValue(int n) {\\n        \\n        \\n        while(n!=solve(n)){\\n             n= solve(n);\\n        }\\n        \\n        return solve(n);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3216440,
                "title": "c-shaving-primes-off-n-100-time-0ms-75-space-6mb",
                "content": "Some core thoughts about this one:\\n* we need a list of primes to quickly and efficiently parse `n`;\\n* we need to repeat the operation until we get a number lower enough that it never changes (so, either a prime, or, if you are curious, `4`).\\n\\nTo do so, we will start with a few support variables:\\n* `res` will store our fina result, initially set to `n`;\\n* `prevN` will store the previous value of `n` and since we want to run our main loop at least once, we will give it any value out of range, like `-1`;\\n* `primes` will contain all the primes necessary to cover our range and since it goes up to `10e5`, primes until its square root are enough; I just googled to get a few, but in an interview be sure to quickly come up with a sieve (I just could not be bothered to do that chore again here).\\n\\nAs previously mentioned, our main loop will go on `while` we are still able to reduce `n` to a new value (ie: `prevN != n`) and it will:\\n* record the current value of `n` in `prevN`;\\n* reset `res` to be `0`;\\n* shave off all the primes up to the root of the top of the range, checking for each potential prime divisor `d` in `primes` and:\\n    * check if `d > n` - if so, no point in parsing any bigger prime and we can just `break` out of the loop;\\n    * `while` `d` can still divide `n` (ie: `n & d == 0`) we will:\\n        * add `d` to `res`;\\n        * update `n` to be the quotient of the division by `d`;\\n* if we still got `n != 1`, it means we have a big prime left (no other way we can come out of that loop) and thus we just flatly add it to `res`;\\n* we can now update `n` to be `res`.\\n\\nAfter the loop, we can just `return` `res` :) \\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\n    int primes[65] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\npublic:\\n    int smallestValue(int n) {\\n        int res = n, prevN = -1;\\n        // reducing n\\n        while (prevN != n) {\\n            prevN = n;\\n            res = 0;\\n            // shaving primes off n\\n            for (int d: primes) {\\n                // done shaving\\n                if (d > n) {\\n                    break;\\n                }\\n                // divisor found\\n                while (n % d == 0) res += d, n/= d;\\n            }\\n            // capturing leftover primes\\n            if (n != 1) res += n;\\n            n = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```cpp\\nclass Solution {\\n    int primes[65] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\npublic:\\n    int smallestValue(int n) {\\n        int res = n, prevN = -1;\\n        // reducing n\\n        while (prevN != n) {\\n            prevN = n;\\n            res = 0;\\n            // shaving primes off n\\n            for (int d: primes) {\\n                // done shaving\\n                if (d > n) {\\n                    break;\\n                }\\n                // divisor found\\n                while (n % d == 0) res += d, n/= d;\\n            }\\n            // capturing leftover primes\\n            if (n != 1) res += n;\\n            n = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148081,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    bool isPrime(int n) {\\n        if(n == 1) return false;\\n        for(int i = 2; i <= sqrt(n); i++) {\\n            if(n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int smallestValue(int n) {\\n        map<int, bool> seen;\\n        while(!seen[n] && !isPrime(n)) {\\n            seen[n] = true;\\n            int sum = 0;\\n            for(int i = 2; i <= sqrt(n); i++) {\\n                if(!isPrime(i)) continue;\\n                while(n % i == 0) {\\n                    sum += i;\\n                    n /= i;\\n                }\\n            }\\n            sum += n > 1? n: 0;\\n            n = sum;\\n        }\\n        return n;\\n    }\\n};\\n\\n\\n// Golang\\nfunc isPrime(n int) bool {\\n    if n == 1 {return false}\\n    var sqrtN int = int(math.Sqrt(float64(n)))\\n    for i := 2; i <= sqrtN; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc smallestValue(n int) int {\\n    seen := make(map[int]bool)\\n    for !seen[n] && !isPrime(n) {\\n        seen[n] = true\\n        var sum int = 0\\n        var sqrtN int = int(math.Sqrt(float64(n)))\\n        for i := 2; i <= sqrtN; i++ {\\n            if !isPrime(i) {continue}\\n            for n % i == 0 {\\n                sum += i\\n                n /= i\\n            }\\n        }\\n        if n > 1 {\\n            sum += n\\n        }\\n        n = sum\\n    }\\n    return n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    bool isPrime(int n) {\\n        if(n == 1) return false;\\n        for(int i = 2; i <= sqrt(n); i++) {\\n            if(n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int smallestValue(int n) {\\n        map<int, bool> seen;\\n        while(!seen[n] && !isPrime(n)) {\\n            seen[n] = true;\\n            int sum = 0;\\n            for(int i = 2; i <= sqrt(n); i++) {\\n                if(!isPrime(i)) continue;\\n                while(n % i == 0) {\\n                    sum += i;\\n                    n /= i;\\n                }\\n            }\\n            sum += n > 1? n: 0;\\n            n = sum;\\n        }\\n        return n;\\n    }\\n};\\n\\n\\n// Golang\\nfunc isPrime(n int) bool {\\n    if n == 1 {return false}\\n    var sqrtN int = int(math.Sqrt(float64(n)))\\n    for i := 2; i <= sqrtN; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc smallestValue(n int) int {\\n    seen := make(map[int]bool)\\n    for !seen[n] && !isPrime(n) {\\n        seen[n] = true\\n        var sum int = 0\\n        var sqrtN int = int(math.Sqrt(float64(n)))\\n        for i := 2; i <= sqrtN; i++ {\\n            if !isPrime(i) {continue}\\n            for n % i == 0 {\\n                sum += i\\n                n /= i\\n            }\\n        }\\n        if n > 1 {\\n            sum += n\\n        }\\n        n = sum\\n    }\\n    return n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141336,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int sumOfPrimeFactors(int input){\\n        for(int divisor = 2; divisor < input; divisor++){\\n            if(input % divisor == 0){\\n                int dividedValue = input / divisor;\\n                return divisor + sumOfPrimeFactors(dividedValue);\\n            }\\n        }\\n        return input;\\n    }\\n    public int smallestValue(int n) {\\n        int currentValue = n;\\n        while(true){\\n            int nextValue = sumOfPrimeFactors(currentValue);\\n            if(nextValue == currentValue) break;\\n            currentValue = nextValue;\\n        }\\n        return currentValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumOfPrimeFactors(int input){\\n        for(int divisor = 2; divisor < input; divisor++){\\n            if(input % divisor == 0){\\n                int dividedValue = input / divisor;\\n                return divisor + sumOfPrimeFactors(dividedValue);\\n            }\\n        }\\n        return input;\\n    }\\n    public int smallestValue(int n) {\\n        int currentValue = n;\\n        while(true){\\n            int nextValue = sumOfPrimeFactors(currentValue);\\n            if(nextValue == currentValue) break;\\n            currentValue = nextValue;\\n        }\\n        return currentValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125211,
                "title": "golang-with-cache",
                "content": "```\\nvar mmap = map[int]int{}\\nvar primes = make([]int, 100000+1)\\nvar ok = false\\n\\nfunc smallestValue(n int) int {\\n\\tif !ok {\\n\\t\\tfor i := 2; i*i <= 100000; i++ {\\n\\t\\t\\tif primes[i] == 0 {\\n\\t\\t\\t\\tfor j := i * i; j <= 100000; j += i {\\n\\t\\t\\t\\t\\tprimes[j] = -1\\n\\t\\t\\t\\t\\tok = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar xx = func(n int) int {\\n\\t\\tif x, ok := mmap[n]; ok {\\n\\t\\t\\treturn x\\n\\t\\t}\\n\\n\\t\\ts := 0\\n\\t\\tfor n%2 == 0 {\\n\\t\\t\\tn = n / 2\\n\\t\\t\\ts += 2\\n\\t\\t}\\n\\n\\t\\td := 3\\n\\t\\tfor n > 1 {\\n\\t\\t\\tif n%d == 0 {\\n\\t\\t\\t\\ts += d\\n\\t\\t\\t\\tn = n / d\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor d < len(primes) {\\n\\t\\t\\t\\t\\tif primes[d] >= 0 && n%d == 0 {\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\td++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmmap[n] = s\\n\\t\\treturn s\\n\\t}\\n\\tpn := n\\n\\tfor primes[n] == -1 {\\n\\t\\tn = xx(n)\\n\\t\\tif n == pn {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tpn = n\\n\\t}\\n\\treturn n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar mmap = map[int]int{}\\nvar primes = make([]int, 100000+1)\\nvar ok = false\\n\\nfunc smallestValue(n int) int {\\n\\tif !ok {\\n\\t\\tfor i := 2; i*i <= 100000; i++ {\\n\\t\\t\\tif primes[i] == 0 {\\n\\t\\t\\t\\tfor j := i * i; j <= 100000; j += i {\\n\\t\\t\\t\\t\\tprimes[j] = -1\\n\\t\\t\\t\\t\\tok = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar xx = func(n int) int {\\n\\t\\tif x, ok := mmap[n]; ok {\\n\\t\\t\\treturn x\\n\\t\\t}\\n\\n\\t\\ts := 0\\n\\t\\tfor n%2 == 0 {\\n\\t\\t\\tn = n / 2\\n\\t\\t\\ts += 2\\n\\t\\t}\\n\\n\\t\\td := 3\\n\\t\\tfor n > 1 {\\n\\t\\t\\tif n%d == 0 {\\n\\t\\t\\t\\ts += d\\n\\t\\t\\t\\tn = n / d\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor d < len(primes) {\\n\\t\\t\\t\\t\\tif primes[d] >= 0 && n%d == 0 {\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\td++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmmap[n] = s\\n\\t\\treturn s\\n\\t}\\n\\tpn := n\\n\\tfor primes[n] == -1 {\\n\\t\\tn = xx(n)\\n\\t\\tif n == pn {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tpn = n\\n\\t}\\n\\treturn n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3114091,
                "title": "why-this-code-has-time-complexity-still-passing-209-209-test-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int smallestValue(int n) {\\n        int s=0,x=n;\\n        cout<<n;\\n        for(int i = 2;i<=n;i++){\\n            if(isprime(i)){\\n                while(n!=1)\\n                    if(n%i==0){\\n                        s+=i;\\n                        n/=i;\\n                    }else break;\\n            }\\n            if((isprime(s)|| x==s) && n==1) return s;\\n            else if(n==1) {n=s;i=1;s=0;}\\n        }\\n        return 0;\\n    }\\nprivate:\\n    bool isprime(int n){\\n        for(int i =2;i<=n/2;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n209/209 get passed and facing issue with time complexity anyone explain why it is so\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int smallestValue(int n) {\\n        int s=0,x=n;\\n        cout<<n;\\n        for(int i = 2;i<=n;i++){\\n            if(isprime(i)){\\n                while(n!=1)\\n                    if(n%i==0){\\n                        s+=i;\\n                        n/=i;\\n                    }else break;\\n            }\\n            if((isprime(s)|| x==s) && n==1) return s;\\n            else if(n==1) {n=s;i=1;s=0;}\\n        }\\n        return 0;\\n    }\\nprivate:\\n    bool isprime(int n){\\n        for(int i =2;i<=n/2;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n209/209 get passed and facing issue with time complexity anyone explain why it is so\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3113343,
                "title": "using-sieve-of-eratosthenes",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    //FIND PRIME FACTOR \\n    //ADD TILL NUMBER BECOMES ONE\\n    //FIND PRIME FACTOR FOR IT N REPEAT UNTIL THE NO IS PRIME\\n  \\n    \\n    int smallestValue(int n) {\\n     vector<int> spf(n+1);\\n        \\n        for(int i=0; i<=n;i++){\\n           spf[i]=i;\\n       } \\n        \\n        for(int i=2;i<=n;i++){\\n            if(spf[i]==i && i<=n/i){\\n                for(int j=i*i;j<=n;j+=i){\\n                   if (spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n        if(spf[n]==n){\\n            return n;\\n        }\\n        while(spf[n]!=n || n>1){\\n            //n=reducenum(n);\\n        int p=spf[n];\\n        int k=n,sum=0;\\n        while(n>1){\\n       \\n        sum+=p;\\n            cout<<n<<\" \"<<sum<<endl;\\n             n=n/p;\\n        p=spf[n];\\n        }\\n        n=sum;\\n        if(spf[n]==n ||sum==k)break;     \\n           \\n         }\\n        \\n        return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //FIND PRIME FACTOR \\n    //ADD TILL NUMBER BECOMES ONE\\n    //FIND PRIME FACTOR FOR IT N REPEAT UNTIL THE NO IS PRIME\\n  \\n    \\n    int smallestValue(int n) {\\n     vector<int> spf(n+1);\\n        \\n        for(int i=0; i<=n;i++){\\n           spf[i]=i;\\n       } \\n        \\n        for(int i=2;i<=n;i++){\\n            if(spf[i]==i && i<=n/i){\\n                for(int j=i*i;j<=n;j+=i){\\n                   if (spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n        if(spf[n]==n){\\n            return n;\\n        }\\n        while(spf[n]!=n || n>1){\\n            //n=reducenum(n);\\n        int p=spf[n];\\n        int k=n,sum=0;\\n        while(n>1){\\n       \\n        sum+=p;\\n            cout<<n<<\" \"<<sum<<endl;\\n             n=n/p;\\n        p=spf[n];\\n        }\\n        n=sum;\\n        if(spf[n]==n ||sum==k)break;     \\n           \\n         }\\n        \\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3112020,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findPrimeFactors(int n) {\\n    vector<int> prime_factors;\\n    while (n % 2 == 0) {\\n        prime_factors.push_back(2);\\n        n = n / 2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i += 2) {\\n        while (n % i == 0) {\\n            prime_factors.push_back(i);\\n            n = n / i;\\n        }\\n    }\\n    if (n > 2) {\\n        prime_factors.push_back(n);\\n    }\\n    return prime_factors;\\n}\\n    int smallestValue(int n) {\\n        while (true) {\\n        vector<int> prime_factors = findPrimeFactors(n);\\n        int new_n = 0;\\n        for (int i : prime_factors) {\\n            new_n += i;\\n        }\\n        if (new_n == n) {\\n            return n;\\n        } else {\\n            n = new_n;\\n        }\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findPrimeFactors(int n) {\\n    vector<int> prime_factors;\\n    while (n % 2 == 0) {\\n        prime_factors.push_back(2);\\n        n = n / 2;\\n    }\\n    for (int i = 3; i <= sqrt(n); i += 2) {\\n        while (n % i == 0) {\\n            prime_factors.push_back(i);\\n            n = n / i;\\n        }\\n    }\\n    if (n > 2) {\\n        prime_factors.push_back(n);\\n    }\\n    return prime_factors;\\n}\\n    int smallestValue(int n) {\\n        while (true) {\\n        vector<int> prime_factors = findPrimeFactors(n);\\n        int new_n = 0;\\n        for (int i : prime_factors) {\\n            new_n += i;\\n        }\\n        if (new_n == n) {\\n            return n;\\n        } else {\\n            n = new_n;\\n        }\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100511,
                "title": "c-recursion-15-lines-3-ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int tmp = n;\\n        int sum =0 ;\\n        for (int i =2;1ll*i*i<=1ll*n;i++)\\n            while(tmp % i ==0)\\n                {\\n                    sum+=i;\\n                    tmp/=i;\\n                }\\n        if (tmp >1) sum+=tmp;\\n        if (sum==n) return n;\\n        else return smallestValue(sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int tmp = n;\\n        int sum =0 ;\\n        for (int i =2;1ll*i*i<=1ll*n;i++)\\n            while(tmp % i ==0)\\n                {\\n                    sum+=i;\\n                    tmp/=i;\\n                }\\n        if (tmp >1) sum+=tmp;\\n        if (sum==n) return n;\\n        else return smallestValue(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081576,
                "title": "swift-solution-worked",
                "content": "# Explanation\\n1. The smallestValue() function will return the smallest value which is the sum of the prime factors of a given number.\\n2. It will check if the given number is prime, if it is, then it will return the number itself. If not, it will run the getPrimeFactorSum() function and return the sum of the prime factors of the given number.\\n3. isPrime() function will check if the given number is prime or not. It will return true if the number is prime, otherwise it will return false.\\n4. getFirstPrimeFactor() function will return the first prime factor of a given number.\\n5. getPrimeFactorSum() function will return the sum of the prime factors of a given number.\\n6. It will check if the given number is prime or not. If it is prime, it will return the number itself. If not, it will run the getFirstPrimeFactor() function and return the sum of the prime factors of the given number.\\n\\n# Approach\\n1. If the number is prime, return the number.\\n2. If the number is not prime, get the sum of its prime factors.\\n3. If the sum is equal to the number, return the number.\\n4. Otherwise, recursively call the function on the sum.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func smallestValue(_ n: Int) -> Int \\n{\\n        if(isPrime(n)) \\n        {\\n            return n;\\n        }\\n        let sum = getPrimeFactorSum(n);\\n        if(sum == n) \\n        {\\n            return n;\\n        }\\n        return smallestValue(sum);\\n    }\\n    \\n    func isPrime(_ n: Int) -> Bool \\n{ \\n        if(n == 2) \\n        {\\n            return true\\n        };\\n        for i in 2..<Int(sqrt(Double(n)) + 1) {\\n            if(n % i == 0) \\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    func getFirstPrimeFactor(_ n: Int) -> Int \\n{ \\n        if(isPrime(n)) \\n        {\\n            return n;\\n        }\\n        for i in 2..<n {\\n            if(n % i == 0) \\n            {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n\\n    func getPrimeFactorSum(_ n: Int) -> Int \\n{ \\n        var sum = 0;\\n        var n = n;\\n        while(!isPrime(n)) {\\n            let m = getFirstPrimeFactor(n);\\n            n /= m;\\n            sum += m;\\n        }\\n        sum += n;\\n        return sum;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallestValue(_ n: Int) -> Int \\n{\\n        if(isPrime(n)) \\n        {\\n            return n;\\n        }\\n        let sum = getPrimeFactorSum(n);\\n        if(sum == n) \\n        {\\n            return n;\\n        }\\n        return smallestValue(sum);\\n    }\\n    \\n    func isPrime(_ n: Int) -> Bool \\n{ \\n        if(n == 2) \\n        {\\n            return true\\n        };\\n        for i in 2..<Int(sqrt(Double(n)) + 1) {\\n            if(n % i == 0) \\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    func getFirstPrimeFactor(_ n: Int) -> Int \\n{ \\n        if(isPrime(n)) \\n        {\\n            return n;\\n        }\\n        for i in 2..<n {\\n            if(n % i == 0) \\n            {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n\\n    func getPrimeFactorSum(_ n: Int) -> Int \\n{ \\n        var sum = 0;\\n        var n = n;\\n        while(!isPrime(n)) {\\n            let m = getFirstPrimeFactor(n);\\n            n /= m;\\n            sum += m;\\n        }\\n        sum += n;\\n        return sum;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078539,
                "title": "easy-solution-in-java-clean-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(n==4){\\n            return 4;\\n        }\\n        while(!isPrime(n)){\\n            n = primeFactsum(n);\\n        }\\n        return n;\\n    }\\n    public static int primeFactsum(int n){\\n        int c = 2;\\n        int sum = 0;\\n        while (n > 1) {\\n            if (n % c == 0) {\\n                sum += c;\\n                n /= c;\\n            }\\n            else\\n                c++;\\n        }\\n        return sum;\\n    }\\n    static boolean isPrime(int n){\\n        if (n <= 1)\\n            return false;\\n        for (int i = 2; i < n; i++){\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        if(n==4){\\n            return 4;\\n        }\\n        while(!isPrime(n)){\\n            n = primeFactsum(n);\\n        }\\n        return n;\\n    }\\n    public static int primeFactsum(int n){\\n        int c = 2;\\n        int sum = 0;\\n        while (n > 1) {\\n            if (n % c == 0) {\\n                sum += c;\\n                n /= c;\\n            }\\n            else\\n                c++;\\n        }\\n        return sum;\\n    }\\n    static boolean isPrime(int n){\\n        if (n <= 1)\\n            return false;\\n        for (int i = 2; i < n; i++){\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071335,
                "title": "easy-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        \\n        int ans=0;\\n        while(true){\\n            int total=0;\\n            int i=2;\\n            while(n>1){\\n\\n                if(n%i==0){\\n                    total+=i;\\n                    n=n/i;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            n=total;\\n            if(total==ans){\\n                break;\\n            }\\n            else{\\n                ans=total;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        \\n        int ans=0;\\n        while(true){\\n            int total=0;\\n            int i=2;\\n            while(n>1){\\n\\n                if(n%i==0){\\n                    total+=i;\\n                    n=n/i;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            n=total;\\n            if(total==ans){\\n                break;\\n            }\\n            else{\\n                ans=total;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063934,
                "title": "c-easy-solution",
                "content": "**Time Complexity** : O(N*sqrt(N))\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        int sum=0;\\n        while(n%2==0){\\n            sum += 2;\\n            n/=2;\\n        }\\n        \\n        for(int i=3; i<=sqrt(n); i=i+2){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        \\n        if(n>2) sum+=n;\\n        return sum;\\n    }\\n    \\n    int smallestValue(int n) {\\n        int x = INT_MAX;\\n        while(x != solve(n)){\\n            x=solve(n);\\n            n=x;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        int sum=0;\\n        while(n%2==0){\\n            sum += 2;\\n            n/=2;\\n        }\\n        \\n        for(int i=3; i<=sqrt(n); i=i+2){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        \\n        if(n>2) sum+=n;\\n        return sum;\\n    }\\n    \\n    int smallestValue(int n) {\\n        int x = INT_MAX;\\n        while(x != solve(n)){\\n            x=solve(n);\\n            n=x;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053821,
                "title": "simplest-recursive-approach-java-6lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int res=0;\\n        int b=n;\\n        for(int i=2;i<b;i++)\\n        {\\n            if(n==1 || n==0) break;\\n            while(n%i==0)\\n            {\\n                res+=i;\\n                n=n/i;\\n            }\\n        }\\n        if(res==0 || res==b) return b;\\n        return smallestValue(res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int res=0;\\n        int b=n;\\n        for(int i=2;i<b;i++)\\n        {\\n            if(n==1 || n==0) break;\\n            while(n%i==0)\\n            {\\n                res+=i;\\n                n=n/i;\\n            }\\n        }\\n        if(res==0 || res==b) return b;\\n        return smallestValue(res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053378,
                "title": "100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int sum(int a)\\n    {\\n        long long int su=0;\\n        while(a%2==0)\\n        {\\n            su=su+2;\\n            a=a/2;\\n        }\\n        for(int i=3;i<=sqrt(a);i=i+2)\\n        {\\n            while(a%i==0)\\n            {\\n                su=su+i;\\n                a=a/i;\\n            }\\n        }\\n        if(a>2)\\n        {\\n            su=su+a;\\n        }\\n        return su;\\n    }\\n    int smallestValue(int n) {\\n        long long int f=-1,g=0;\\n        while(1)\\n        {\\n            g=n;\\n            f=sum(n);\\n            n=f;\\n         \\n            if(g==f)\\n            {\\n                break;\\n            }\\n          \\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int sum(int a)\\n    {\\n        long long int su=0;\\n        while(a%2==0)\\n        {\\n            su=su+2;\\n            a=a/2;\\n        }\\n        for(int i=3;i<=sqrt(a);i=i+2)\\n        {\\n            while(a%i==0)\\n            {\\n                su=su+i;\\n                a=a/i;\\n            }\\n        }\\n        if(a>2)\\n        {\\n            su=su+a;\\n        }\\n        return su;\\n    }\\n    int smallestValue(int n) {\\n        long long int f=-1,g=0;\\n        while(1)\\n        {\\n            g=n;\\n            f=sum(n);\\n            n=f;\\n         \\n            if(g==f)\\n            {\\n                break;\\n            }\\n          \\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050796,
                "title": "easy-recursive-loop-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primeDivisors(int n){\\n        int ans=0;\\n        for(int i=2;i<=n;i++){\\n            while(n%i == 0){\\n                ans+=i;\\n                n=n/i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        int s = primeDivisors(n);\\n        if(s == n) return s;\\n        return smallestValue(s);\\n        \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primeDivisors(int n){\\n        int ans=0;\\n        for(int i=2;i<=n;i++){\\n            while(n%i == 0){\\n                ans+=i;\\n                n=n/i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        int s = primeDivisors(n);\\n        if(s == n) return s;\\n        return smallestValue(s);\\n        \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050145,
                "title": "python-easiest-mindset-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefine a basic isPrime(x) function that determines if a number is prime or not and use this to determine whether a divisor of number is prime or not and use % i.e. modulus operator to see if that prime divisor fully divides it with remainder zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck out the code comments for easy and fully detailed explanation.\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def isPrime(x):\\n            if x<=1: return False\\n            for i in range(2, int(x**0.5)+1):\\n                if x%i==0:return False\\n            return True\\n        N = n\\n        while True:\\n            sumx = 0\\n            z = 2\\n            while z <= n:  # I did what? \\n            # Let\\'s see...eg. 48 = 2*2*2*2*3...n = 48 and we start with z = 2...while z < n\\n            # let that z divide n and that n goes to n//z so that next time we see\\n            # starting from same z if that z divides n again and if it does then \\n            # repeat the same process but if it doesnot divide n this time then increment z\\n            # to see if new z i.e. 3 can divide left over 48->24->12->6->3 and yes 3 will \\n            # divide 3 when 2 failed to divide 3 so we get value of sumx and \\n                if isPrime(z) and n % z == 0:\\n                    sumx += z \\n                    n //= z\\n                else:\\n                    z += 1\\n            n = sumx #+ n      # note this step of adding non-zero n also or \\n                               # declare while z<=n instead of while z < n\\n\\n            # print(n)\\n            if N == n:         # This checks if n remained same after all the procedure\\n                break          #  and if it did then break because now there will be no further \\n                               # reduction in value of n.\\n            N = n   # else do this\\n        return n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        def isPrime(x):\\n            if x<=1: return False\\n            for i in range(2, int(x**0.5)+1):\\n                if x%i==0:return False\\n            return True\\n        N = n\\n        while True:\\n            sumx = 0\\n            z = 2\\n            while z <= n:  # I did what? \\n            # Let\\'s see...eg. 48 = 2*2*2*2*3...n = 48 and we start with z = 2...while z < n\\n            # let that z divide n and that n goes to n//z so that next time we see\\n            # starting from same z if that z divides n again and if it does then \\n            # repeat the same process but if it doesnot divide n this time then increment z\\n            # to see if new z i.e. 3 can divide left over 48->24->12->6->3 and yes 3 will \\n            # divide 3 when 2 failed to divide 3 so we get value of sumx and \\n                if isPrime(z) and n % z == 0:\\n                    sumx += z \\n                    n //= z\\n                else:\\n                    z += 1\\n            n = sumx #+ n      # note this step of adding non-zero n also or \\n                               # declare while z<=n instead of while z < n\\n\\n            # print(n)\\n            if N == n:         # This checks if n remained same after all the procedure\\n                break          #  and if it did then break because now there will be no further \\n                               # reduction in value of n.\\n            N = n   # else do this\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048404,
                "title": "easiest-approach-for-this-question",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int sumofprimefactors(int n){\\n        int sum=0;\\n        while(n%2==0){\\n            sum+=2;\\n            n/=2;\\n        }\\n        for(int i=3;i<=sqrt(n);i=i+2){  \\n            while(n%i==0){ \\n              sum+=i; \\n              n=n/i; \\n            }\\n        }\\n        if(n>2){\\n           sum+=n;\\n        }\\n        return sum;    \\n    }\\n    int smallestValue(int n){\\n        int num=sumofprimefactors(n);\\n        if(n==num){return n;}\\n        else{\\n            return smallestValue(num);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofprimefactors(int n){\\n        int sum=0;\\n        while(n%2==0){\\n            sum+=2;\\n            n/=2;\\n        }\\n        for(int i=3;i<=sqrt(n);i=i+2){  \\n            while(n%i==0){ \\n              sum+=i; \\n              n=n/i; \\n            }\\n        }\\n        if(n>2){\\n           sum+=n;\\n        }\\n        return sum;    \\n    }\\n    int smallestValue(int n){\\n        int num=sumofprimefactors(n);\\n        if(n==num){return n;}\\n        else{\\n            return smallestValue(num);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044518,
                "title": "c-12-lines-recursive-prime-factor-0-ms-beats-100",
                "content": "# Approach\\n**Step 1** - Iterate a for loop from 2 to the square root of n, and copy n into the new variable k.\\n**Step 2** - Divide n by i and add i to ans till it is divisible by i.\\n**Step 3** - After the for loop, if n is not equal to 1, add it to ans (because it is definitely the prime factor of k).\\n**Step 4** -  If ans is equal to k (or given n), it cannot be minimised further return ans.\\n**Step 5** - Otherwise, use recursion to find the smallest number and return the answer.\\xA0\\n\\n# Code\\n\\n## Recursive\\n\\n```\\nint smallestValue(int n) {\\n    int ans = 0, sq = sqrt(n), k =n;\\n    for(int i=2;i<=sq;i++){\\n        while(n%i==0){\\n            ans += i;\\n            n/=i;\\n        }\\n    }\\n    if(n!=1) ans += n;\\n    if(ans==k) return k;\\n    return smallestValue(ans);\\n}\\n```\\n\\n## Iterative\\n\\n```\\nint smallestValue(int n) {\\n    int sq,k,sum;\\n    do{\\n        sum=0; sq = sqrt(n); k = n;\\n        for(int i=2;i<=sq;i++) while(n%i==0){\\n                sum += i;\\n                n/=i;\\n        }\\n        if(n!=1) sum += n;\\n        n = sum;\\n    }while(n!=k);\\n    return k;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint smallestValue(int n) {\\n    int ans = 0, sq = sqrt(n), k =n;\\n    for(int i=2;i<=sq;i++){\\n        while(n%i==0){\\n            ans += i;\\n            n/=i;\\n        }\\n    }\\n    if(n!=1) ans += n;\\n    if(ans==k) return k;\\n    return smallestValue(ans);\\n}\\n```\n```\\nint smallestValue(int n) {\\n    int sq,k,sum;\\n    do{\\n        sum=0; sq = sqrt(n); k = n;\\n        for(int i=2;i<=sq;i++) while(n%i==0){\\n                sum += i;\\n                n/=i;\\n        }\\n        if(n!=1) sum += n;\\n        n = sum;\\n    }while(n!=k);\\n    return k;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042295,
                "title": "c-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all the factors of N and check which ones of them are prime. If the factor is prime, add it to SUM as many times it divides N. Then move to the next factor. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSieve of Eratosthenes algorithm can be used to check if a factor is prime or not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> seive(int n) {\\n        vector<bool> primes(n+1, true);\\n        primes[0]=false, primes[1]=false;\\n        int root=sqrt(n);\\n        for(int i=2; i<=root; i++) {\\n            if(primes[i]==true) {\\n                for(int j=i*i; j<=n; j=j+i) {\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n        return primes;\\n    }\\n    bool solve(int& n, vector<bool>& primes) {\\n        if(primes[n]==true) {\\n            return false;\\n        }\\n        int sum=0;\\n        bool result=false;\\n        for(int factor=2; factor<=n/2; factor++) {\\n            if(n%factor==0 and primes[factor]==true) {\\n                result=true;\\n                int temp=n;\\n                while(temp%factor==0) {\\n                    sum+=factor;\\n                    temp/=factor;\\n                }\\n            }\\n        }\\n        if(n==sum) {\\n            return false;\\n        }\\n        n=sum;\\n        return result;\\n    }\\n    int smallestValue(int n) {\\n        vector<bool> primes=seive(n);\\n        while(solve(n,primes)) {\\n\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> seive(int n) {\\n        vector<bool> primes(n+1, true);\\n        primes[0]=false, primes[1]=false;\\n        int root=sqrt(n);\\n        for(int i=2; i<=root; i++) {\\n            if(primes[i]==true) {\\n                for(int j=i*i; j<=n; j=j+i) {\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n        return primes;\\n    }\\n    bool solve(int& n, vector<bool>& primes) {\\n        if(primes[n]==true) {\\n            return false;\\n        }\\n        int sum=0;\\n        bool result=false;\\n        for(int factor=2; factor<=n/2; factor++) {\\n            if(n%factor==0 and primes[factor]==true) {\\n                result=true;\\n                int temp=n;\\n                while(temp%factor==0) {\\n                    sum+=factor;\\n                    temp/=factor;\\n                }\\n            }\\n        }\\n        if(n==sum) {\\n            return false;\\n        }\\n        n=sum;\\n        return result;\\n    }\\n    int smallestValue(int n) {\\n        vector<bool> primes=seive(n);\\n        while(solve(n,primes)) {\\n\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041039,
                "title": "intuitive-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int sumOfFactors(int n) {\\n        int ret = 0;\\n        int cur = 2;\\n        while (n != 1) {\\n            while (n % cur == 0) {\\n                ret += cur;\\n                n /= cur;\\n            }\\n            ++cur;\\n        }\\n        return ret;\\n    }\\n\\npublic:\\n    int smallestValue(int n) {\\n        auto ret = sumOfFactors(n);\\n        while (ret < n) {\\n            n = ret;\\n            ret = sumOfFactors(n);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int sumOfFactors(int n) {\\n        int ret = 0;\\n        int cur = 2;\\n        while (n != 1) {\\n            while (n % cur == 0) {\\n                ret += cur;\\n                n /= cur;\\n            }\\n            ++cur;\\n        }\\n        return ret;\\n    }\\n\\npublic:\\n    int smallestValue(int n) {\\n        auto ret = sumOfFactors(n);\\n        while (ret < n) {\\n            n = ret;\\n            ret = sumOfFactors(n);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026384,
                "title": "c-100-faster-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple run a loop till all the factors are not get of any number and replace that new sum with the old number.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrun a loop from i=1 to i*i<=n where all the factors will get.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n)*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        long long int sum=0,f=0;   // sum to get a new number.\\n        int prev = n;\\n        for(int i=2;i*i<=n;++i)   // to get all the factors.\\n        {\\n            f=0;\\n            if(n%i ==0)\\n            {\\n                f=1;\\n                while(n%i==0)\\n                {\\n                    n = n/i;\\n                    sum += i;\\n                }\\n                \\n            }\\n            if(n==1)\\n            {\\n                f=1;\\n                if(prev ==sum)     // if new is equal to previous number then it cant be breakdown further.\\n                return sum;\\n\\n                n = sum;\\n                prev= n;\\n                // cout<<n<<endl;\\n                sum=0;\\n                i=1;\\n                f=0;\\n                continue;\\n                // break;\\n            }\\n            int p = i+1;\\n            if(p*p>n && n>1)\\n            {\\n                if(sum==0)\\n                {\\n                    return n;\\n                }\\n                sum += n;\\n                if(prev ==sum)\\n                return sum;\\n                n = sum;\\n                prev=n;\\n                sum=0;\\n                i=1;\\n                f=0;\\n            }\\n            \\n        }\\n        if(sum!=0)\\n        n += sum;\\n        \\n       \\n            return n;\\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        long long int sum=0,f=0;   // sum to get a new number.\\n        int prev = n;\\n        for(int i=2;i*i<=n;++i)   // to get all the factors.\\n        {\\n            f=0;\\n            if(n%i ==0)\\n            {\\n                f=1;\\n                while(n%i==0)\\n                {\\n                    n = n/i;\\n                    sum += i;\\n                }\\n                \\n            }\\n            if(n==1)\\n            {\\n                f=1;\\n                if(prev ==sum)     // if new is equal to previous number then it cant be breakdown further.\\n                return sum;\\n\\n                n = sum;\\n                prev= n;\\n                // cout<<n<<endl;\\n                sum=0;\\n                i=1;\\n                f=0;\\n                continue;\\n                // break;\\n            }\\n            int p = i+1;\\n            if(p*p>n && n>1)\\n            {\\n                if(sum==0)\\n                {\\n                    return n;\\n                }\\n                sum += n;\\n                if(prev ==sum)\\n                return sum;\\n                n = sum;\\n                prev=n;\\n                sum=0;\\n                i=1;\\n                f=0;\\n            }\\n            \\n        }\\n        if(sum!=0)\\n        n += sum;\\n        \\n       \\n            return n;\\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3012019,
                "title": "easiest-solution-c-using-set-and-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int>s;\\n    int primeFactors(int n)\\n{\\n        int res=n;\\n        if(s.find(n)!=s.end())\\n            return n;\\n        int sum=0;\\n\\twhile (n%2 == 0)\\n\\t{\\n        s.insert(2);\\n\\t\\tsum+=2;\\n\\t\\tn = n/2;\\n\\t}\\n\\tfor (int i = 3; i <= sqrt(n); i = i+2)\\n\\t{\\n\\t\\twhile (n%i==0)\\n\\t\\t{\\n            s.insert(i);\\n\\t\\t\\tsum+=i;\\n\\t\\t\\tn = n/i;\\n\\t\\t}\\n\\t}\\n\\tif (n > 2)\\n    {  s.insert(n);\\n\\t\\tsum+=n;\\n    }\\n        if(sum==res)\\n            return res;\\n        else\\n      return  primeFactors(sum);\\n}\\n    int smallestValue(int n) {\\n\\treturn primeFactors(n);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int>s;\\n    int primeFactors(int n)\\n{\\n        int res=n;\\n        if(s.find(n)!=s.end())\\n            return n;\\n        int sum=0;\\n\\twhile (n%2 == 0)\\n\\t{\\n        s.insert(2);\\n\\t\\tsum+=2;\\n\\t\\tn = n/2;\\n\\t}\\n\\tfor (int i = 3; i <= sqrt(n); i = i+2)\\n\\t{\\n\\t\\twhile (n%i==0)\\n\\t\\t{\\n            s.insert(i);\\n\\t\\t\\tsum+=i;\\n\\t\\t\\tn = n/i;\\n\\t\\t}\\n\\t}\\n\\tif (n > 2)\\n    {  s.insert(n);\\n\\t\\tsum+=n;\\n    }\\n        if(sum==res)\\n            return res;\\n        else\\n      return  primeFactors(sum);\\n}\\n    int smallestValue(int n) {\\n\\treturn primeFactors(n);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011556,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SmallestValue(int n) {\\n        var list = new List<int>();\\n        int result = 0;\\n        if(n == 4){\\n            return 4;\\n        }\\n        for(int i=2; i<=n; i++){\\n            while (n%i == 0) {\\n                n /= i;\\n                list.Add(i);\\n            }\\n        }\\n        if(list.Count == 1){\\n            return list[0];\\n        }\\n        if(list.Count > 1){\\n            for(int j = 0; j < list.Count; j++){\\n                result += list[j];\\n            }\\n        }\\n        return SmallestValue(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SmallestValue(int n) {\\n        var list = new List<int>();\\n        int result = 0;\\n        if(n == 4){\\n            return 4;\\n        }\\n        for(int i=2; i<=n; i++){\\n            while (n%i == 0) {\\n                n /= i;\\n                list.Add(i);\\n            }\\n        }\\n        if(list.Count == 1){\\n            return list[0];\\n        }\\n        if(list.Count > 1){\\n            for(int j = 0; j < list.Count; j++){\\n                result += list[j];\\n            }\\n        }\\n        return SmallestValue(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006995,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int a = n;\\n        while(n != -1){ \\n            a = n;\\n            n = prime(n);\\n        }\\n        return a;\\n    }\\n\\n    private static int prime(int n) {\\n        if(n == 2 || n == 1 || n==4) return -1;\\n        boolean flag = false;\\n        int ans = 0;\\n        while(n%2==0) {\\n            flag = true;\\n            ans+=2;\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i++) {\\n            while(n%i==0) {\\n                flag = true;\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n > 2) {\\n            ans += n;\\n        }\\n        return flag? ans : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int a = n;\\n        while(n != -1){ \\n            a = n;\\n            n = prime(n);\\n        }\\n        return a;\\n    }\\n\\n    private static int prime(int n) {\\n        if(n == 2 || n == 1 || n==4) return -1;\\n        boolean flag = false;\\n        int ans = 0;\\n        while(n%2==0) {\\n            flag = true;\\n            ans+=2;\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i++) {\\n            while(n%i==0) {\\n                flag = true;\\n                ans+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n > 2) {\\n            ans += n;\\n        }\\n        return flag? ans : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006484,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int n){\\n        long long ans=0;\\n        int d = 2;\\n        while(n>1){\\n            if(n%d==0){\\n                n/=d;\\n                ans+=d;\\n            }else{\\n                d++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        while(true){\\n            int k = solve(n);\\n            if(k==n)break;\\n            n=k;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int n){\\n        long long ans=0;\\n        int d = 2;\\n        while(n>1){\\n            if(n%d==0){\\n                n/=d;\\n                ans+=d;\\n            }else{\\n                d++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int smallestValue(int n) {\\n        while(true){\\n            int k = solve(n);\\n            if(k==n)break;\\n            n=k;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004059,
                "title": "100-faster-solution-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck minimum prime number \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple approach of using while loop until it find prime number \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        bool check = true;\\n    int primSum(int n)\\n        \\n    {\\n        int x = n ;\\n        int sum = 0;\\n        for (int i = 2; i * i <= n; i++)\\n        {\\n            while (n % i == 0)\\n            {\\n                sum += i;\\n                n /= i;\\n            }\\n        }\\n        if (n > 1) sum += n;\\n        if (sum == x)\\n            check = false;\\n        return sum;\\n    }\\n\\n    int smallestValue(int n)\\n    {\\n        int ans = INT_MAX;\\n        int ps = n;\\n        while (check)\\n        {\\n            ps = primSum(ps);\\n\\n            ans = min(ans, ps);\\n        }\\n        return ans;\\n    }\\n};\\n\\nplease upvote if you like the approach . feel free to ask \\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool check = true;\\n    int primSum(int n)\\n        \\n    {\\n        int x = n ;\\n        int sum = 0;\\n        for (int i = 2; i * i <= n; i++)\\n        {\\n            while (n % i == 0)\\n            {\\n                sum += i;\\n                n /= i;\\n            }\\n        }\\n        if (n > 1) sum += n;\\n        if (sum == x)\\n            check = false;\\n        return sum;\\n    }\\n\\n    int smallestValue(int n)\\n    {\\n        int ans = INT_MAX;\\n        int ps = n;\\n        while (check)\\n        {\\n            ps = primSum(ps);\\n\\n            ans = min(ans, ps);\\n        }\\n        return ans;\\n    }\\n};\\n\\nplease upvote if you like the approach . feel free to ask \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003945,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n       // System.out.println(n);\\n\\n        int temp = n;\\n\\n        ArrayList<Integer> li = new ArrayList<>();\\n\\n        while(n!=1){\\n            for(int i=2; i<=n; i++){\\n                if(n%i==0){\\n                    li.add(i);\\n                    n /= i;\\n                    break;\\n                }\\n            }\\n        }\\n\\n\\n        if(li.size()==1){\\n            return li.get(0);\\n        }\\n\\n        int sum = 0;\\n        for(int i=0; i<li.size(); i++){\\n            //System.out.print(li.get(i)+\" \");\\n            sum += li.get(i);\\n        }\\n        //System.out.println();\\n\\n        if(sum==temp){\\n            return sum;\\n        }\\n\\n\\n        return smallestValue(sum);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n       // System.out.println(n);\\n\\n        int temp = n;\\n\\n        ArrayList<Integer> li = new ArrayList<>();\\n\\n        while(n!=1){\\n            for(int i=2; i<=n; i++){\\n                if(n%i==0){\\n                    li.add(i);\\n                    n /= i;\\n                    break;\\n                }\\n            }\\n        }\\n\\n\\n        if(li.size()==1){\\n            return li.get(0);\\n        }\\n\\n        int sum = 0;\\n        for(int i=0; i<li.size(); i++){\\n            //System.out.print(li.get(i)+\" \");\\n            sum += li.get(i);\\n        }\\n        //System.out.println();\\n\\n        if(sum==temp){\\n            return sum;\\n        }\\n\\n\\n        return smallestValue(sum);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992929,
                "title": "c-solution-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        if(n<=5)    return n;\\n        int ans =0,i=2,given =n;\\n        while(i<=sqrt(n)){\\n            if(n%i==0){\\n                n/=i;\\n                ans+=i;\\n            }else i++;\\n            if(n==1)break;\\n        }\\n        if(n!=given and n!=1)\\n            ans+=n;\\n        return n!=given ? smallestValue(ans):n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        if(n<=5)    return n;\\n        int ans =0,i=2,given =n;\\n        while(i<=sqrt(n)){\\n            if(n%i==0){\\n                n/=i;\\n                ans+=i;\\n            }else i++;\\n            if(n==1)break;\\n        }\\n        if(n!=given and n!=1)\\n            ans+=n;\\n        return n!=given ? smallestValue(ans):n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992133,
                "title": "golang-solution",
                "content": "# Intuition\\nFor each iteration calculate prime factors sum and repeat until sum is not equal to number from previous iteration.\\n\\n\\n# Code\\n```\\nfunc smallestValue(n int) int {\\n\\ts := getPrimeFactorsSum(n)\\n\\tfor s != n {\\n\\t\\tn = s\\n\\t\\ts = getPrimeFactorsSum(n)\\n\\t}\\n\\treturn s\\n}\\n\\nfunc getPrimeFactorsSum(n int) int {\\n\\ts := 0\\n\\tfor i := 2; i <= n; i++ {\\n\\t\\tfor n%i == 0 {\\n\\t\\t\\ts = s + i\\n\\t\\t\\tn = n / i\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc smallestValue(n int) int {\\n\\ts := getPrimeFactorsSum(n)\\n\\tfor s != n {\\n\\t\\tn = s\\n\\t\\ts = getPrimeFactorsSum(n)\\n\\t}\\n\\treturn s\\n}\\n\\nfunc getPrimeFactorsSum(n int) int {\\n\\ts := 0\\n\\tfor i := 2; i <= n; i++ {\\n\\t\\tfor n%i == 0 {\\n\\t\\t\\ts = s + i\\n\\t\\t\\tn = n / i\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991940,
                "title": "time-complexity-derived-o-n-for-primes-o-logn-logn-composites",
                "content": "# Time Complexity Derivation\\nActually the function - SumOfPrimes() takes\\n\\n- O(Log N ) for composites\\n- O(N) for primes\\n[Why? Take an example 4 - It goes till 2 only, 2 itself divides it twice. Take 5 - It takes 5 iterations - else part Divisor++ happens]\\n\\nThe outer While loop -\\n- O(1) for Prime nums [Why? Bcoz What PrimeFactorization you will do for a prime number]\\n- O(Log N) for Composites [Why? Take 16 : 16 = 2^4 => 8 = 2^3 => 6 => 2*3 Almost 4 iterations]\\n\\nThereby OVERALL,\\n- If N is prime O(N * 1) = O(N)\\n- If N is composite O(LogN * LogN)\\n\\nI hope this is the time complexity derivation.\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    int sumOfPrimes(int n){\\n        int div = 2;\\n        int ans = 0;\\n\\n        while(n>1){\\n            if(n%div ==0){\\n                n = n/div;\\n                ans+=div;\\n            }\\n            else{\\n                div++; \\n                //we start with lower prime 2 and go on and on\\n                //so no need to check for prime or not. \\n                //As when it comes it 4 its automatically resolved in 2\\n            }\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int smallestValue(int n) {\\n        //All we need to do is prime factorization \\n        //We can write a function that takes N and returns sum of prime facs\\n        while(true){\\n            int sum = sumOfPrimes(n);\\n            if(sum == n) break; // we are no more able to break into sums\\n            n = sum;\\n        }\\n\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    int sumOfPrimes(int n){\\n        int div = 2;\\n        int ans = 0;\\n\\n        while(n>1){\\n            if(n%div ==0){\\n                n = n/div;\\n                ans+=div;\\n            }\\n            else{\\n                div++; \\n                //we start with lower prime 2 and go on and on\\n                //so no need to check for prime or not. \\n                //As when it comes it 4 its automatically resolved in 2\\n            }\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int smallestValue(int n) {\\n        //All we need to do is prime factorization \\n        //We can write a function that takes N and returns sum of prime facs\\n        while(true){\\n            int sum = sumOfPrimes(n);\\n            if(sum == n) break; // we are no more able to break into sums\\n            n = sum;\\n        }\\n\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989289,
                "title": "easy-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to add prime factors\\n    int prime(int n){\\n        int result = 0;\\n\\n        // Add 2 as many times it divides the number completely\\n        while(n % 2 == 0){\\n            result += 2;\\n            n = n/2;\\n        }\\n\\n        // Loop to determine other prime factors\\n        for(int i=3;i<=sqrt(n);i=i+2){\\n            while(n % i == 0){\\n                result += i;\\n                n = n/i;\\n            }\\n        }\\n\\n        if(n > 2){\\n            result += n;\\n        }\\n\\n        return result;\\n    }\\n    int smallestValue(int n) {\\n        int p = prime(n);\\n        if(p == n){\\n            return n;\\n        }\\n\\n        return smallestValue(p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to add prime factors\\n    int prime(int n){\\n        int result = 0;\\n\\n        // Add 2 as many times it divides the number completely\\n        while(n % 2 == 0){\\n            result += 2;\\n            n = n/2;\\n        }\\n\\n        // Loop to determine other prime factors\\n        for(int i=3;i<=sqrt(n);i=i+2){\\n            while(n % i == 0){\\n                result += i;\\n                n = n/i;\\n            }\\n        }\\n\\n        if(n > 2){\\n            result += n;\\n        }\\n\\n        return result;\\n    }\\n    int smallestValue(int n) {\\n        int p = prime(n);\\n        if(p == n){\\n            return n;\\n        }\\n\\n        return smallestValue(p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988148,
                "title": "java-math-solution-o-n-sqrt-n-explained-in-detail-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem necessitates a way to find the prime factors of a number efficiently. If we have such a function, the problem becomes relatively simple as we find the prime factors of a number and then keep repeating the process with the resulting sum of the factors until we reach a prime number.\\n# Approach\\n\\n1. Implement an efficient prime factorization function\\n\\nIt is known that all primes greater than 3 can be represented in the form 6\\uD835\\uDC5A\\xB11. You can read more about this property of the primes [here](https://math.stackexchange.com/questions/41623/is-that-true-that-all-the-prime-numbers-are-of-the-form-6m-pm-1)\\n\\nMoreover, we can take into consideration that any number n, prime or composite, cannot have factors that are greater than $$sqrt(n)$$ \\n\\nWith all of this knowledge, we can implement a prime factorizing function that runs in square root time, $$O(sqrt(n))$$ (This function can be slightly modified to get a similarly efficient prime number checker.)\\n\\n2. Implement the main function\\n\\nThe main driver function is relatively simple; we start by initializing an integer nn as the sum of the prime factors of our input n. Then, with the help of a while loop, in each iteration, we assign n to the current value nn and nn to the prime factor sum of itself. This process is repeated until nn and n are equal.\\n\\nWe return the value of n when nn and n are equal(prime).\\n\\nThis driver code has a time complexity of $$O(n)$$ in the worst case. If we multiply this value with the value of the prime factorization function we get a total time complexity of $$O(N*sqrt(N))$$ and since we only use constant additional space, the space complexity is $$O(1)$$\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(N*sqrt(N))$$ \\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int nn = primeFactors(n);\\n        while (nn != n) {\\n            n = nn;\\n            nn = primeFactors(n);\\n        }\\n\\n        return n;\\n  }\\n\\n    //prime factorization function\\n    int primeFactors(int n) {\\n        int ans = 0;\\n        while (n % 2 == 0) {\\n            ans += 2;\\n            n /= 2;\\n        }\\n        while (n % 3 == 0) {\\n            ans += 3;\\n            n /= 3;\\n        }\\n\\n\\n        for (int i = 5; i <= Math.sqrt(n); i = i + 6) {\\n            if (n % i == 0) {\\n                while (n % i == 0) {\\n                    ans += i;\\n                    n /= i;\\n                }\\n            }\\n            if (n % (i + 2) == 0) { //Edge case: twin primes exist\\n                while (n % (i + 2) == 0) {\\n                    ans += (i + 2);\\n                    n /= (i + 2);\\n                }\\n            }\\n\\n        }\\n\\n        // Edge case: n may be a prime number greater than 2 after the loop\\n        if (n > 2)\\n            ans += n;\\n\\n        return ans;\\n    }\\n}\\n   \\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int nn = primeFactors(n);\\n        while (nn != n) {\\n            n = nn;\\n            nn = primeFactors(n);\\n        }\\n\\n        return n;\\n  }\\n\\n    //prime factorization function\\n    int primeFactors(int n) {\\n        int ans = 0;\\n        while (n % 2 == 0) {\\n            ans += 2;\\n            n /= 2;\\n        }\\n        while (n % 3 == 0) {\\n            ans += 3;\\n            n /= 3;\\n        }\\n\\n\\n        for (int i = 5; i <= Math.sqrt(n); i = i + 6) {\\n            if (n % i == 0) {\\n                while (n % i == 0) {\\n                    ans += i;\\n                    n /= i;\\n                }\\n            }\\n            if (n % (i + 2) == 0) { //Edge case: twin primes exist\\n                while (n % (i + 2) == 0) {\\n                    ans += (i + 2);\\n                    n /= (i + 2);\\n                }\\n            }\\n\\n        }\\n\\n        // Edge case: n may be a prime number greater than 2 after the loop\\n        if (n > 2)\\n            ans += n;\\n\\n        return ans;\\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986957,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def prime_test(self, n):\\n        for c in range(2, int(n**(1/2)) + 1):\\n            if n % c == 0:\\n                return False\\n        return True\\n\\n    def smallestValue(self, n: int) -> int:\\n        if self.prime_test(n):\\n            return n\\n\\n        temp = []\\n        for c in range(2, n + 1):\\n            if self.prime_test(c):\\n                n_ = int(n)\\n                while n_ % c == 0:\\n                    temp.append(c)\\n                    n_ = n_ // c\\n        sum_ = 0\\n        for k in temp:\\n            sum_ += k\\n        if sum_ == n:\\n            return n\\n        else:\\n            return min(n, self.smallestValue(sum_))\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prime_test(self, n):\\n        for c in range(2, int(n**(1/2)) + 1):\\n            if n % c == 0:\\n                return False\\n        return True\\n\\n    def smallestValue(self, n: int) -> int:\\n        if self.prime_test(n):\\n            return n\\n\\n        temp = []\\n        for c in range(2, n + 1):\\n            if self.prime_test(c):\\n                n_ = int(n)\\n                while n_ % c == 0:\\n                    temp.append(c)\\n                    n_ = n_ // c\\n        sum_ = 0\\n        for k in temp:\\n            sum_ += k\\n        if sum_ == n:\\n            return n\\n        else:\\n            return min(n, self.smallestValue(sum_))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986903,
                "title": "very-easy-prime-sieve-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> prime;\\n    unordered_set<int> st;\\n    int help(int n, vector<int> &tmp){\\n        if(prime[n]) return n;\\n        int ans=0;\\n        for(int i=0;i<tmp.size();i++){\\n            while(n%tmp[i]==0){\\n                n /= tmp[i];\\n                ans += tmp[i];\\n            }\\n        }\\n        if(st.count(ans)) return ans;\\n        st.insert(ans);\\n        return help(ans,tmp);\\n    }\\n\\n    int smallestValue(int n) {\\n        prime =  vector<bool>(n+1,true);\\n        prime[0]=false,prime[1]=false;\\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n        vector<int> tmp;\\n        for(int i=2;i<=n;i++) if(prime[i]) tmp.push_back(i);\\n        return help(n,tmp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> prime;\\n    unordered_set<int> st;\\n    int help(int n, vector<int> &tmp){\\n        if(prime[n]) return n;\\n        int ans=0;\\n        for(int i=0;i<tmp.size();i++){\\n            while(n%tmp[i]==0){\\n                n /= tmp[i];\\n                ans += tmp[i];\\n            }\\n        }\\n        if(st.count(ans)) return ans;\\n        st.insert(ans);\\n        return help(ans,tmp);\\n    }\\n\\n    int smallestValue(int n) {\\n        prime =  vector<bool>(n+1,true);\\n        prime[0]=false,prime[1]=false;\\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n        vector<int> tmp;\\n        for(int i=2;i<=n;i++) if(prime[i]) tmp.push_back(i);\\n        return help(n,tmp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985100,
                "title": "python3-recursevily-sum-primes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while ((r := self.sumPrimes(n)) != n):\\n            n = r\\n\\n        return n\\n\\n    def sumPrimes(self, n: int) -> int:\\n        sum = 0\\n        for k in range(2, n + 1):\\n            if (n % k == 0):\\n                sum += k + self.sumPrimes(n // k)\\n                break\\n\\n        return sum\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while ((r := self.sumPrimes(n)) != n):\\n            n = r\\n\\n        return n\\n\\n    def sumPrimes(self, n: int) -> int:\\n        sum = 0\\n        for k in range(2, n + 1):\\n            if (n % k == 0):\\n                sum += k + self.sumPrimes(n // k)\\n                break\\n\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984047,
                "title": "c-brute-force-easy-beginner-friendly",
                "content": "class Solution {\\npublic:\\n    int smallestValue(int n){\\n        \\n        while(n){\\n        \\n             int sum=0; \\n             int prev=n;\\n            \\n        for(int i=2;i<=sqrt(n);i++){\\n          \\n              while(n%i==0){\\n                  sum+=i;\\n                   n/=i;\\n              }\\n          \\n         }  \\n   \\n            if(sum==0) return n;\\n            \\n            if(sum==prev) return sum; \\n            \\n             if(n>1) n+=sum;\\n            \\n             if(n==1) n=sum;\\n            \\n      }\\n\\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int smallestValue(int n){\\n        \\n        while(n){\\n        \\n             int sum=0; \\n             int prev=n;\\n            \\n        for(int i=2;i<=sqrt(n);i++){\\n          \\n              while(n%i==0){\\n                  sum+=i;\\n                   n/=i;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 2983596,
                "title": "simplest-and-easiest-java-solutuion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int s=n;\\n        while(true)\\n        {\\n            int s1=0;\\n            int c=2;\\n            while(n>1){\\n                \\n                if(n%c==0){\\n                    s1+=c;\\n                    n=n/c;\\n                }\\n                else c++;\\n            }\\n            n=s1;\\n            if(s==s1)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                s=s1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int s=n;\\n        while(true)\\n        {\\n            int s1=0;\\n            int c=2;\\n            while(n>1){\\n                \\n                if(n%c==0){\\n                    s1+=c;\\n                    n=n/c;\\n                }\\n                else c++;\\n            }\\n            n=s1;\\n            if(s==s1)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                s=s1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979610,
                "title": "100-faster-simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int ans=0;\\n        int cnt=0;\\n        while(true){\\n            \\n            ans=0;\\n            int c=sqrt(n);\\n            for(int i=2 ;i<=c;i++){\\n                if(n%i==0){\\n                    while(n%i==0){\\n                        ans+=i;\\n                        n=n/i;\\n                    }\\n                }\\n            }\\n            if(ans==0) return n;\\n            else if(ans==c*c) return ans;\\n            else if(n!=1) n+=ans;\\n            else  n=ans;\\n            \\n          \\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {\\n        int ans=0;\\n        int cnt=0;\\n        while(true){\\n            \\n            ans=0;\\n            int c=sqrt(n);\\n            for(int i=2 ;i<=c;i++){\\n                if(n%i==0){\\n                    while(n%i==0){\\n                        ans+=i;\\n                        n=n/i;\\n                    }\\n                }\\n            }\\n            if(ans==0) return n;\\n            else if(ans==c*c) return ans;\\n            else if(n!=1) n+=ans;\\n            else  n=ans;\\n            \\n          \\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965820,
                "title": "easy-java-solution-simple-and-neat-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear time complexity \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int min = n;\\n        while (true) {\\n            int new_n = f(n);\\n            if(new_n==n) return min;\\n            n=new_n;\\n            min = Math.min(min, n);\\n        }\\n    }\\n\\n    public int f(int num) {\\n        if (num == 1)\\n            return num;\\n        for (int i = 2; i < num; i++) {\\n            if (num % i == 0)\\n                return i + f(num / i);\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int smallestValue(int n) {\\n        int min = n;\\n        while (true) {\\n            int new_n = f(n);\\n            if(new_n==n) return min;\\n            n=new_n;\\n            min = Math.min(min, n);\\n        }\\n    }\\n\\n    public int f(int num) {\\n        if (num == 1)\\n            return num;\\n        for (int i = 2; i < num; i++) {\\n            if (num % i == 0)\\n                return i + f(num / i);\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962589,
                "title": "beats-90-even-with-this-naive-factorisation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        if n == 4: return 4\\n        tab = [0, n]\\n        while len(tab) > 1:\\n            n = sum(tab)\\n            newtab = []\\n            i = 2\\n            while i <= int(sqrt(n)):\\n                if n % i == 0:\\n                    n /= i\\n                    newtab.append(i)\\n                else:\\n                    i += 1\\n            tab = newtab\\n            tab.append(n)\\n        return int(tab[0])\\n                    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        if n == 4: return 4\\n        tab = [0, n]\\n        while len(tab) > 1:\\n            n = sum(tab)\\n            newtab = []\\n            i = 2\\n            while i <= int(sqrt(n)):\\n                if n % i == 0:\\n                    n /= i\\n                    newtab.append(i)\\n                else:\\n                    i += 1\\n            tab = newtab\\n            tab.append(n)\\n        return int(tab[0])\\n                    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962249,
                "title": "prime-factorization-c-python-java-javascript-ruby",
                "content": "Simple prime factorization.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {  \\n        while(1){\\n            int sum=0;\\n            int init=n;\\n            for(int i=2;i*i<=n;i++){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n            }\\n            if(n>1) sum+=n;\\n            if(n==init||sum==init) return init;\\n            n=sum;\\n        }\\n        return n;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while True:\\n            sum=0\\n            init=n\\n            i=2\\n            while i*i<=n:\\n                while n%i==0:\\n                    sum+=i\\n                    n//=i\\n                i+=1\\n            if n>1 : sum+=n\\n            if n==init or sum==init: return init\\n            n=sum\\n        return n\\n```\\n```java []\\nclass Solution {\\n    public int smallestValue(int n) {\\n        while(true) {\\n            int sum=0;\\n            int init=n;\\n            for(int i=2;i*i<=n;i++){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n            }\\n            if(n>1) sum+=n;\\n            if(n==init||sum==init) return init;\\n            n=sum;\\n        }        \\n    }\\n}\\n\\n```\\n```javascript []\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar smallestValue = function(n) {\\n    while(true) {\\n        let sum=0;\\n        let init=n;\\n        for(let i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>1) sum+=n;\\n        if(n==init||sum==init) return init;\\n        n=sum;\\n    }\\n};\\n\\n```\\n``` ruby []\\n# @param {Integer} n\\n# @return {Integer}\\ndef smallest_value(n)\\n    while true\\n      sum = 0\\n      init = n\\n      (2..Math.sqrt(n)).each do |i|\\n        while n % i == 0\\n          sum += i\\n          n /= i\\n        end\\n      end\\n      sum += n if n > 1\\n      return init if n == init || sum == init\\n      n = sum\\n    end\\n  end\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Ruby"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int smallestValue(int n) {  \\n        while(1){\\n            int sum=0;\\n            int init=n;\\n            for(int i=2;i*i<=n;i++){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n            }\\n            if(n>1) sum+=n;\\n            if(n==init||sum==init) return init;\\n            n=sum;\\n        }\\n        return n;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def smallestValue(self, n: int) -> int:\\n        while True:\\n            sum=0\\n            init=n\\n            i=2\\n            while i*i<=n:\\n                while n%i==0:\\n                    sum+=i\\n                    n//=i\\n                i+=1\\n            if n>1 : sum+=n\\n            if n==init or sum==init: return init\\n            n=sum\\n        return n\\n```\n```java []\\nclass Solution {\\n    public int smallestValue(int n) {\\n        while(true) {\\n            int sum=0;\\n            int init=n;\\n            for(int i=2;i*i<=n;i++){\\n                while(n%i==0){\\n                    sum+=i;\\n                    n/=i;\\n                }\\n            }\\n            if(n>1) sum+=n;\\n            if(n==init||sum==init) return init;\\n            n=sum;\\n        }        \\n    }\\n}\\n\\n```\n```javascript []\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar smallestValue = function(n) {\\n    while(true) {\\n        let sum=0;\\n        let init=n;\\n        for(let i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                sum+=i;\\n                n/=i;\\n            }\\n        }\\n        if(n>1) sum+=n;\\n        if(n==init||sum==init) return init;\\n        n=sum;\\n    }\\n};\\n\\n```\n``` ruby []\\n# @param {Integer} n\\n# @return {Integer}\\ndef smallest_value(n)\\n    while true\\n      sum = 0\\n      init = n\\n      (2..Math.sqrt(n)).each do |i|\\n        while n % i == 0\\n          sum += i\\n          n /= i\\n        end\\n      end\\n      sum += n if n > 1\\n      return init if n == init || sum == init\\n      n = sum\\n    end\\n  end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954065,
                "title": "easy-to-understand-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> prime;\\n    void sieve(int n)\\n    {\\n        prime.resize(n+1,true);\\n        prime[0]=prime[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(prime[i]==true)\\n            {\\n                for(int j=2*i;j<=n;j+=i)\\n                {\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n    }\\n    map<int,int> primeFactorise(int n)\\n    {\\n        map<int,int> mp;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                int count=0;\\n                while(n%i==0)\\n                {\\n                    n/=i;\\n                    count++;\\n                }\\n                mp[i]=count;\\n            }\\n        }\\n        if(n>1)\\n        {\\n            mp[n]=1;\\n        }\\n        return mp;\\n    }\\n    int smallestValue(int n) {\\n        sieve(1e5+1);\\n        while(!prime[n])\\n        {\\n            map<int,int> factors=primeFactorise(n);\\n            int z=0;\\n            for(auto &pr:factors)\\n            {\\n                z+=pr.first*pr.second;\\n            }\\n            if(z==n)\\n            {\\n                break;\\n            }\\n            n=z;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> prime;\\n    void sieve(int n)\\n    {\\n        prime.resize(n+1,true);\\n        prime[0]=prime[1]=false;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(prime[i]==true)\\n            {\\n                for(int j=2*i;j<=n;j+=i)\\n                {\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n    }\\n    map<int,int> primeFactorise(int n)\\n    {\\n        map<int,int> mp;\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                int count=0;\\n                while(n%i==0)\\n                {\\n                    n/=i;\\n                    count++;\\n                }\\n                mp[i]=count;\\n            }\\n        }\\n        if(n>1)\\n        {\\n            mp[n]=1;\\n        }\\n        return mp;\\n    }\\n    int smallestValue(int n) {\\n        sieve(1e5+1);\\n        while(!prime[n])\\n        {\\n            map<int,int> factors=primeFactorise(n);\\n            int z=0;\\n            for(auto &pr:factors)\\n            {\\n                z+=pr.first*pr.second;\\n            }\\n            if(z==n)\\n            {\\n                break;\\n            }\\n            n=z;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953386,
                "title": "recursion-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int sumOfPrimeFactors(int n, int sum)\\n    {\\n        if(n==1) return sum;\\n        for(int x=2; x<=n; x++)\\n        {\\n            if(n%x==0) return sumOfPrimeFactors(n/x,sum+x);\\n        }\\n        return -1;\\n    }\\n    int smallestValue(int n) \\n    {\\n        int a=sumOfPrimeFactors(n,0);\\n        while(n!=a)\\n        {\\n            n=a;\\n            a=sumOfPrimeFactors(n,0);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int sumOfPrimeFactors(int n, int sum)\\n    {\\n        if(n==1) return sum;\\n        for(int x=2; x<=n; x++)\\n        {\\n            if(n%x==0) return sumOfPrimeFactors(n/x,sum+x);\\n        }\\n        return -1;\\n    }\\n    int smallestValue(int n) \\n    {\\n        int a=sumOfPrimeFactors(n,0);\\n        while(n!=a)\\n        {\\n            n=a;\\n            a=sumOfPrimeFactors(n,0);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949313,
                "title": "java-recursion-with-memo-o-n",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> memo = new HashMap<>();\\n    \\n    public int smallestValue(int n) {\\n        while (get(n) != n) {\\n            n = get(n);\\n        }\\n        return n;\\n    }\\n    \\n    private int get(int n) {   \\n        if (memo.containsKey(n)) return memo.get(n);\\n        \\n        double r = Math.pow(n, 0.5);\\n        int R = (int)r;\\n        if (r - R == 0) {\\n            return 2 * get(R);\\n        }\\n        \\n        int res = 0;\\n        for (int i = R; i >= 2; i--) {\\n            if (n % i == 0) {\\n                res = get(i) + get(n / i);\\n            }\\n        }\\n        \\n        res = res == 0 ? n : res;\\n        memo.put(n, res);\\n        \\n        return res;\\n    }\\n}\\n```\\nTime Complexity: O( \\u221An)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> memo = new HashMap<>();\\n    \\n    public int smallestValue(int n) {\\n        while (get(n) != n) {\\n            n = get(n);\\n        }\\n        return n;\\n    }\\n    \\n    private int get(int n) {   \\n        if (memo.containsKey(n)) return memo.get(n);\\n        \\n        double r = Math.pow(n, 0.5);\\n        int R = (int)r;\\n        if (r - R == 0) {\\n            return 2 * get(R);\\n        }\\n        \\n        int res = 0;\\n        for (int i = R; i >= 2; i--) {\\n            if (n % i == 0) {\\n                res = get(i) + get(n / i);\\n            }\\n        }\\n        \\n        res = res == 0 ? n : res;\\n        memo.put(n, res);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1734569,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            },
            {
                "id": 1720040,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            },
            {
                "id": 1720529,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            },
            {
                "id": 1720460,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            },
            {
                "id": 1720302,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            },
            {
                "id": 1719993,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            },
            {
                "id": 1726291,
                "content": [
                    {
                        "username": "digital_ddu",
                        "content": "for n = 12, the expected answer is 7. Based on my understanding of the question, it should be 5. What am I missing?\\ne.g. \\n12 => [2, 3, 4, 6] => [2, 3, 2, 2, 2, 3] => sum is 14\\n14 => [2, 7] => sum is 9\\n9 => [3, 3] => sum is 6\\n6 => [2, 3] => sum is 5\\n\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "Prime factors of 12=>[2,2,3]\\n\\nTo verify if you find product of prime factors of a number (n) you will get that number (n) back. According to you if prime factors of 12=>[2,3,2,2,2,3] then their product is equal to 144 != 12.\\n\\n"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "Easiest recursive solution\\uD83E\\uDEB6\\uD83E\\uDEB6(c++)\\n\\nApproach:\\nFirst calculate all the prime factor of the number, then sum all of it.\\nThen u recursively pass the sum to our function, and check if the sum is equal to previously existing number.\\nFor ex :\\nWe take 15 -\\nfactors are - 3 ,5,15\\nprime no are - 3,5\\nsum is 8.\\n\\nnow we have to find out the prime factor of 8.\\nwhich is 2, 2 ,2.\\nsum is 6.\\n\\nagain we pass 6 as we know 8 != 6.\\nprime factor of 6 = 2,3\\nsum is 5.\\n\\nagain we pass 5, because 5 != 6.\\n5 is prime number. prime factor = 5 only.\\n\\nwe pass 5 again which stisfy the condition, 5==5\\nHence base case satisfied we return 5 as the answer.\\n\\n\\nC++\\n\\nCODE :\\n\\n\\nclass Solution {\\npublic:\\nint check(int n){\\n    int sum = 0;\\n        int c = 2; \\n        while(n > 1){\\n            if(n % c == 0){\\n                sum += c;\\n                n /= c;\\n            }\\n            else{\\n                c++;\\n            }\\n        }\\n      return sum;\\n}\\n\\n    int smallestValue(int n) {\\n         int ans=check(n);\\n        if(ans==n) return ans;\\n        else return smallestValue(ans);\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Take care for case n =4 That totally screwed me\n\nI was trying this way Link below\nhttps://leetcode.com/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solutions/2925152/care-for-n-4-screwed-me/?orderBy=most_votes"
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "create a one functoin that returns a sum of prime factor of any number and then replace \"n\" with this sum(function) while \"n\" not equal to sum, then return n.\\nbest & easy approch ....! thank you.....!"
                    },
                    {
                        "username": "tangj1905",
                        "content": "Fun fact - what we\\'re calculating is known as the [sum of prime factors function](https://mathworld.wolfram.com/SumofPrimeFactors.html), denoted by sopfr(n). Here, we\\'re actually just trying to find the fixed point as we iterate this function over and over.\\n\\nThe results for all *n* > 1 are prime - except for 4! This is the only non-prime value such that the sum of its prime factors is equal to the number itself.\\n\\nHere\\'s an OEIS entry with some more interesting details: https://oeis.org/A029908"
                    },
                    {
                        "username": "0x4C0DE",
                        "content": "For some one want to find the math: [Fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)"
                    },
                    {
                        "username": "adarsh2dubey",
                        "content": "Below is my Short solution in java\n`class Solution {\n    public int smallestValue(int n) {\n        if(n==1) return n;\n        \n        while(!isPrime(n)){\n            int sum=0;\n             int p=n;\n            while(p%2==0){\n                sum+=2;\n                p=p/2;\n            }\n            for(int i=3;i*i<=n;i+=2){\n                while(p%i==0){\n                    sum+=i;\n                    p=p/i;\n                }\n            } \n            if(p!=1) sum+=p;\n            if(sum==n) return n;\n            n=sum;\n        }                                  \n        return n;\n    }\n    boolean isPrime(int n){\n        if(n==1) return false;\n        for(int i=2;i*i<=n;i++) if(n%i==0) return false;\n        return true;\n    }\n}`"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Dont post solutions in discussion"
                    }
                ]
            }
        ]
    }
]