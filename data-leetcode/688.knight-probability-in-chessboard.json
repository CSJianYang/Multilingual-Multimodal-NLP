[
    {
        "title": "House Robber II",
        "question_content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\nExample 2:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 1000",
        "solutions": [
            {
                "id": 59934,
                "title": "simple-ac-solution-in-java-in-o-n-with-explanation",
                "content": "Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.\\n    \\n    private int rob(int[] num, int lo, int hi) {\\n        int include = 0, exclude = 0;\\n        for (int j = lo; j <= hi; j++) {\\n            int i = include, e = exclude;\\n            include = e + num[j];\\n            exclude = Math.max(e, i);\\n        }\\n        return Math.max(include, exclude);\\n    }\\n\\nNow the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob *num[lo]* is entirely our choice. But, it is now constrained by whether *num[hi]* is robbed. \\n\\nHowever, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.\\n\\nFor example, 1 -> 2 -> 3 -> 1 becomes 2 -> 3 if 1 is not robbed.\\n\\nSince every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.\\n\\n    public int rob(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Since this question is a follow-up to House Robber, we can assume we already have a way to solve the simpler question, i.e. given a 1 row of house, we know how to rob them. So we already have such a helper function. We modify it a bit to rob a given range of houses.\\n    \\n    private int rob(int[] num, int lo, int hi) {\\n        int include = 0, exclude = 0;\\n        for (int j = lo; j <= hi; j++) {\\n            int i = include, e = exclude;\\n            include = e + num[j];\\n            exclude = Math.max(e, i);\\n        }\\n        return Math.max(include, exclude);\\n    }\\n\\nNow the question is how to rob a circular row of houses. It is a bit complicated to solve like the simpler question. It is because in the simpler question whether to rob *num[lo]* is entirely our choice. But, it is now constrained by whether *num[hi]* is robbed. \\n\\nHowever, since we already have a nice solution to the simpler problem. We do not want to throw it away. Then, it becomes how can we reduce this problem to the simpler one. Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.\\n\\nFor example, 1 -> 2 -> 3 -> 1 becomes 2 -> 3 if 1 is not robbed.\\n\\nSince every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.\\n\\n    public int rob(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59921,
                "title": "9-lines-0ms-o-1-space-c-solution",
                "content": "This problem is a little tricky at first glance. However, if you have finished the **House Robber** problem, this problem can simply  be **decomposed into two House Robber problems**. \\n    Suppose there are `n` houses, since house `0` and `n - 1` are now neighbors, we cannot rob them together and thus the solution is now the maximum of\\n\\n 1. Rob houses `0` to `n - 2`;\\n 2. Rob houses `1` to `n - 1`.\\n\\nThe code is as follows. Some edge cases (`n < 2`) are handled explicitly.\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int n = nums.size(); \\n            if (n < 2) return n ? nums[0] : 0;\\n            return max(robber(nums, 0, n - 2), robber(nums, 1, n - 1));\\n        }\\n    private:\\n        int robber(vector<int>& nums, int l, int r) {\\n            int pre = 0, cur = 0;\\n            for (int i = l; i <= r; i++) {\\n                int temp = max(pre + nums[i], cur);\\n                pre = cur;\\n                cur = temp;\\n            }\\n            return cur;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int n = nums.size(); \\n            if (n < 2) return n ? nums[0] : 0;\\n            return max(robber(nums, 0, n - 2), robber(nums, 1, n - 1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 59986,
                "title": "c-super-simple-0ms-solution-with-explanation",
                "content": "Since you cannot rob both the first and last house, just create two separate vectors, one excluding the first house, and another excluding the last house. The best solution generated from these two vectors using the original House Robber DP algorithm is the optimal one. \\n\\n    class Solution {\\n    public:\\n    \\n        int robOriginal(vector<int>& nums) {\\n            int a = 0, b = 0, res = 0;\\n            \\n            for(int i = 0; i < nums.size(); ++i){\\n                res = max(b + nums[i], a);\\n                b = a;\\n                a = res;\\n            }\\n            \\n            return res;\\n        }\\n    \\n        int rob(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            if(nums.size() == 1) return nums[0];\\n            \\n            vector<int> numsA(nums.begin() + 1, nums.end());\\n            vector<int> numsB(nums.begin(), nums.end()-1);\\n            \\n            return max(robOriginal(numsA), robOriginal(numsB));\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        int robOriginal(vector<int>& nums) {\\n            int a = 0, b = 0, res = 0;\\n            \\n            for(int i = 0; i < nums.size(); ++i){\\n                res = max(b + nums[i], a);\\n                b = a;\\n                a = res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 299071,
                "title": "python-o-n-time-o-1-space",
                "content": "Notice that the first house and the last house can not be both robbed, so we have rob(nums) = max(rob(nums[1:], nums[:-1]). Since there are no circles in both nums[1:] and nums[:-1], we can simply apply the answers from **House Rob**. https://leetcode.com/problems/house-robber/discuss/299056/Python-O(n)-time-O(1)-space-4-lines\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```\\n\\nSlicing a list is actually O(n) space in Python (thanks post2web for pointing out). In our case, nums[1:], nums[:-1] create copies, to avoid this, we can pass indices into the simple_rob function instead of sliced lists. Below is the less elegant, but true O(1) space solution:\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def simple_rob(nums, i, j):\\n            rob, not_rob = 0, 0\\n            for idx in range(i, j):\\n                num = nums[idx]\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            n = len(nums)\\n            return max(simple_rob(nums, 1, n), simple_rob(nums, 0, n-1))",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def simple_rob(nums):\\n            rob, not_rob = 0, 0\\n            for num in nums:\\n                rob, not_rob = not_rob + num, max(rob, not_rob)\\n            return max(rob, not_rob)\\n        \\n        if not nums:\\n            return 0\\n        elif len(nums) == 1:\\n            return nums[0]\\n        else:\\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893957,
                "title": "python-just-use-house-robber-twice",
                "content": "This problem can be seen as follow-up question for problem **198. House Robber**. Imagine, that we can already solve this problem: for more detailes please see my post:\\nhttps://leetcode.com/problems/house-robber/discuss/846004/Python-4-lines-easy-dp-solution-explained\\n\\nNow, what we have here is circular pattern. Imagine, that we have `10` houses: `a0, a1, a2, a3, ... a9`: Then we have two possible options:\\n1. Rob house `a0`, then we can not rob `a0` or `a9` and we have `a2, a3, ..., a8` range to rob\\n2. Do not rob house `a0`, then we have `a1, a2, ... a9` range to rob.\\n\\nThen we just choose maximum of these two options and we are done!\\n\\n**Complexity**: time complexity is `O(n)`, because we use `dp` problem with complexity `O(n)` twice. Space complexity is `O(1)`, because in python lists passed by reference and space complexity of House Robber problem is `O(1)`.\\n\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        def rob_helper(nums):\\n            dp1, dp2 = 0, 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n            return dp2\\n    \\n        return max(nums[0] + rob_helper(nums[2:-1]), rob_helper(nums[1:]))\\n ```\\n \\n If you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        def rob_helper(nums):\\n            dp1, dp2 = 0, 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n            return dp2\\n    \\n        return max(nums[0] + rob_helper(nums[2:-1]), rob_helper(nums[1:]))\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 893946,
                "title": "c-super-simple-and-short-dp-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int houseRobber(vector<int>& nums) {\\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // either use first house and can\\'t use last or last and not first:\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(houseRobber(v1), houseRobber(v2));\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int houseRobber(vector<int>& nums) {\\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // either use first house and can\\'t use last or last and not first:\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(houseRobber(v1), houseRobber(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60044,
                "title": "good-performance-dp-solution-using-java",
                "content": "    public class Solution {\\n        public int rob(int[] nums) {\\n            if (nums.length == 0)\\n                return 0;\\n            if (nums.length < 2)\\n                return nums[0];\\n            \\n            int[] startFromFirstHouse = new int[nums.length + 1];\\n            int[] startFromSecondHouse = new int[nums.length + 1];\\n            \\n            startFromFirstHouse[0]  = 0;\\n            startFromFirstHouse[1]  = nums[0];\\n            startFromSecondHouse[0] = 0;\\n            startFromSecondHouse[1] = 0;\\n            \\n            for (int i = 2; i <= nums.length; i++) {\\n                startFromFirstHouse[i] = Math.max(startFromFirstHouse[i - 1], startFromFirstHouse[i - 2] + nums[i-1]);\\n                startFromSecondHouse[i] = Math.max(startFromSecondHouse[i - 1], startFromSecondHouse[i - 2] + nums[i-1]);\\n            }\\n            \\n            return Math.max(startFromFirstHouse[nums.length - 1], startFromSecondHouse[nums.length]);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int rob(int[] nums) {\\n            if (nums.length == 0)\\n                return 0;\\n            if (nums.length < 2)\\n                return nums[0];\\n            \\n            int[] startFromFirstHouse = new int[nums.length + 1];\\n            int[] startFromSecondHouse = new int[nums.length + 1];\\n            \\n            startFromFirstHouse[0]  = 0;\\n            startFromFirstHouse[1]  = nums[0];\\n            startFromSecondHouse[0] = 0;\\n            startFromSecondHouse[1] = 0;\\n            \\n            for (int i = 2; i <= nums.length; i++) {\\n                startFromFirstHouse[i] = Math.max(startFromFirstHouse[i - 1], startFromFirstHouse[i - 2] + nums[i-1]);\\n                startFromSecondHouse[i] = Math.max(startFromSecondHouse[i - 1], startFromSecondHouse[i - 2] + nums[i-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 894594,
                "title": "java-bottom-up-dp-explained-o-n-extra-space",
                "content": "The main point is that you **can\\'t rob both the first and last** houses.\\n\\nTherefore, the core idea is to **apply DP twice**: when you rob the first house, and when you don\\'t (you rob the last one).\\n\\n**The DP algorithm:**\\n\\n1. Iterate over houses\\n2. At *ith* house you have 2 options:\\n \\t- Keep the money from the *(i-1)th* (previous) house, skipping the *ith* house\\n \\t- Rob the *ith* house after the *(i-2)th* house, skipping the *(i-1)th*\\n 3. Choose the most profitable option (obviously)\\n 4. Return the sum you\\'ve got after the last house\\n \\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)    return nums[0];\\n        if(nums.length == 2)    return Math.max(nums[0], nums[1]);\\n        \\n        // 1st option: including the 1st and excluding the last house\\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        // 2nd option: excluding the 1st and including the last house\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        // Return the maximum of the two results\\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end){        \\n        if(start == end)    return nums[start];\\n        \\n        // Array to store the maximum sum at the current iteration\\n        // while traversing all houses\\n        int money[] = new int[nums.length];\\n        \\n        /* Base case */\\n        money[start] = nums[start];\\n        \\n        // At the 2nd house, we decide to rob\\n        // either the 1st house or the 2nd\\n        // This is the core idea of the transition function\\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n            /* At ith house we have two options:\\n             1. not rob it, keeping the money from the (i-1)th house\\n             2. rob it after the (i-2)th house, skipping the (i-1)th house\\n              We choose the one that gives the max amount */\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        // Return the sum that we have at the last house\\n        return money[end];\\n    }\\n}\\n```\\n\\nThis solution runs in O(n) because we make two passes over an array that is one item smaller than the input array.\\n\\nO(n) extra space is required to store the amount of money after each house",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)    return nums[0];\\n        if(nums.length == 2)    return Math.max(nums[0], nums[1]);\\n        \\n        // 1st option: including the 1st and excluding the last house\\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        // 2nd option: excluding the 1st and including the last house\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        // Return the maximum of the two results\\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end){        \\n        if(start == end)    return nums[start];\\n        \\n        // Array to store the maximum sum at the current iteration\\n        // while traversing all houses\\n        int money[] = new int[nums.length];\\n        \\n        /* Base case */\\n        money[start] = nums[start];\\n        \\n        // At the 2nd house, we decide to rob\\n        // either the 1st house or the 2nd\\n        // This is the core idea of the transition function\\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n            /* At ith house we have two options:\\n             1. not rob it, keeping the money from the (i-1)th house\\n             2. rob it after the (i-2)th house, skipping the (i-1)th house\\n              We choose the one that gives the max amount */\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        // Return the sum that we have at the last house\\n        return money[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227366,
                "title": "thinking-process-from-easy-question-to-harder-question-within-the-same-question-set",
                "content": "I notice there are already some easy to adapt solutions from House Robber I, just in case for someone who want to build a problem solving strategy about how to build the thinking process from easy question to harder question within the same question set.\\n\\n**First, find the difference:**\\nFrom HRI, we already have the solution to a non circular houses, meaning we don\\'t need to worry about the first and the last.\\nFor this problem, the only major thing that is different is that we have to worry about the first and the last. *You want the first, leave the last. You want the last, leave the first.*\\n\\n**Second, brainstorm possible solutions**\\n*If else?* That seems really intuitive, but it is hard to do so involving so many possibilities. \\n*Divide the array into left and right*, then we can check left and right at the same time, but this basically the same as the original, since we still need to worry about the new first and the new last.\\n.\\n.\\n.\\n**Third, refocus on the difference and think about why the previous algorithm fails**\\nIf we use the old algorithm, we just simply overcount, since the new situation will always face more limitations due to the circular structure. If we overcount, how about just substracting the overcounted value.\\n*The intuitive solution is just to subtract the first*, so that we will not overcount them when using the old algorithm.\\n\\n**Fourth, real solution emerges**\\nIf we just subtract the first, we will meet the situation that we will oversubtract values, since we will subtract the first even though we don\\'t want to rob the first. \\n*Pay attention to the difference again* : You want the first, leave the last. You want the last, leave the first.\\nNow, we know we need to distinguish **Rob the first or do not rob the first**\\nIf we rob the first: then we cannot rob the last, so nums[:-1]\\nif we do not rob the first, then we can rob the last, so nums[1:]\\nAnd the final answer is just max of them using the old algorithm.\\n\\nSo basically, first gather all the information you have, then distinguish the difference and why old algorithm fails, find the essense of the difference, in this case *You want the first, leave the last. You want the last, leave the first.*. Then, brainstorming possible solutions, through constant testing and refocus on the difference, the final answer will eventually emerge.\\n\\nNote 0 is including current value, 1 is excluding the current value\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:return nums[0]\\n        def recursion(nums):\\n            if not nums: return [0 for _ in range(2)]\\n            previous = recursion(nums[1:])\\n            res = [0 for _ in range(2)]\\n            res[0] = nums[0] + previous[1]\\n            res[1] = max(previous)\\n            return res\\n        return max(max(recursion(nums[:-1])), max(recursion(nums[1:])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:return nums[0]\\n        def recursion(nums):\\n            if not nums: return [0 for _ in range(2)]\\n            previous = recursion(nums[1:])\\n            res = [0 for _ in range(2)]\\n            res[0] = nums[0] + previous[1]\\n            res[1] = max(previous)\\n            return res\\n        return max(max(recursion(nums[:-1])), max(recursion(nums[1:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893953,
                "title": "python-very-simple-and-clean-dp-solution-faster-than-97",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def houseRobber(nums):\\n            # dynamic programming - decide each problem by its sub-problems:\\n            dp = [0]*len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2, len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n\\n            return dp[-1]\\n        \\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # either use first house and can\\'t use last or last and not first:\\n        return max(houseRobber(nums[:-1]), houseRobber(nums[1:]))\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def houseRobber(nums):\\n            # dynamic programming - decide each problem by its sub-problems:\\n            dp = [0]*len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2, len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n\\n            return dp[-1]\\n        \\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # either use first house and can\\'t use last or last and not first:\\n        return max(houseRobber(nums[:-1]), houseRobber(nums[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59944,
                "title": "twice-pass-solution-c",
                "content": "Twice pass:\\n\\n1. not rob nums[n-1]\\n2. not rob nums[0]\\n\\nand the other is same as [House Robber](https://leetcode.com/problems/house-robber/ ).\\n\\n    int rob(vector<int>& nums)\\n    {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        \\n        int pre1 = 0, cur1 = 0;\\n        for(int i = 0; i < nums.size() - 1; ++ i)\\n        {\\n            int temp = pre1;\\n            pre1 = cur1;\\n            cur1 = max(temp + nums[i], pre1);\\n        }\\n        \\n        int pre2 = 0, cur2 = 0;\\n        for(int i = 1; i < nums.size(); ++ i)\\n        {\\n            int temp = pre2;\\n            pre2 = cur2;\\n            cur2 = max(temp + nums[i], pre2);\\n        }\\n        \\n        return max(cur1, cur2);\\n    }",
                "solutionTags": [],
                "code": "Twice pass:\\n\\n1. not rob nums[n-1]\\n2. not rob nums[0]\\n\\nand the other is same as [House Robber](https://leetcode.com/problems/house-robber/ ).\\n\\n    int rob(vector<int>& nums)\\n    {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        \\n        int pre1 = 0, cur1 = 0;\\n        for(int i = 0; i < nums.size() - 1; ++ i)\\n        {\\n            int temp = pre1;\\n            pre1 = cur1;\\n            cur1 = max(temp + nums[i], pre1);\\n        }\\n        \\n        int pre2 = 0, cur2 = 0;\\n        for(int i = 1; i < nums.size(); ++ i)\\n        {\\n            int temp = pre2;\\n            pre2 = cur2;\\n            cur2 = max(temp + nums[i], pre2);\\n        }\\n        \\n        return max(cur1, cur2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1442044,
                "title": "python-bottom-up-dp-o-1-space-clean-concise",
                "content": "**Idea**\\n- Since the houses form a circle, so we need to avoid robbing on `house[0]` and `house[n-1]` together.\\n- So we divide 2 cases:\\n\\t- Case 1: Rob the maximum of amount money in `houses[0..n-2]`.\\n\\t- Case 2: Rob the maximum of amount money in `houses[1..n-1]`.\\n- To solve case 1, case 2, please check this solution [198. House Robber](https://leetcode.com/problems/house-robber/discuss/263528).\\n- Pick the maximum of amount money we can rob in case 1 and case 2.\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(left, right):\\n            dp, dp1, dp2 = 0, 0, 0\\n            for i in range(left, right+1):\\n                dp = max(dp1, dp2 + nums[i])\\n                dp2 = dp1\\n                dp1 = dp\\n            return dp1\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        return max(solve(0, n-2), solve(1, n-1))\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(left, right):\\n            dp, dp1, dp2 = 0, 0, 0\\n            for i in range(left, right+1):\\n                dp = max(dp1, dp2 + nums[i])\\n                dp2 = dp1\\n                dp1 = dp\\n            return dp1\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        return max(solve(0, n-2), solve(1, n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59929,
                "title": "java-clean-short-solution-dp",
                "content": "    public class Solution {\\n\\tpublic int rob(int[] nums) {\\n\\t\\treturn Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n\\t}\\n\\t\\n    public int rob(int[] nums, int lo, int hi) {\\n        int preRob = 0, preNotRob = 0, rob = 0, notRob = 0;\\n        for (int i = lo; i <= hi; i++) {\\n          \\trob = preNotRob + nums[i];\\n        \\tnotRob = Math.max(preRob, preNotRob);\\n        \\t\\n        \\tpreNotRob = notRob;\\n        \\tpreRob = rob;\\n        }\\n        return Math.max(rob, notRob);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic int rob(int[] nums) {\\n\\t\\treturn Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 59978,
                "title": "6-lines-function-body",
                "content": "Standard solution, I guess, except I take a shortcut for the one-house case.\\n\\n    class Solution:\\n        def rob(self, nums):\\n            def rob(nums):\\n                now = prev = 0\\n                for n in nums:\\n                    now, prev = max(now, prev + n), now\\n                return now\\n            return max(rob(nums[len(nums) != 1:]), rob(nums[:-1]))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Standard solution, I guess, except I take a shortcut for the one-house case.\\n\\n    class Solution:\\n        def rob(self, nums):\\n            def rob(nums):\\n                now = prev = 0\\n                for n in nums:\\n                    now, prev = max(now, prev + n), now\\n                return now\\n            return max(rob(nums[len(nums) != 1:]), rob(nums[:-1]))",
                "codeTag": "Java"
            },
            {
                "id": 182957,
                "title": "omg-super-simple-java-dp-solution-with-explanation",
                "content": "The only difference from [House Robber I](https://leetcode.com/problems/house-robber/description/) is that all the houses are in the circle here, which simply means **if you select the first one then you WON\\'T be able to select the last one since they are neignbors. Only when you NOT select the first one, you then COULD select the last one.** Hey, why don\\'t we break the circle => e.g. houses are [2,7,9,3,1],  if I select the first one (which has money 2), I don\\'t even care about the last one, question will become to rob [2,7,9,3] instead. Same, if we did not select first one, question becomes to rob [7,9,3,1], and the final result would be the larger result between them. OMG House Robber II really is want us to do [House Robber I](https://leetcode.com/problems/house-robber/description/)  twice! Take a look at my beating-100% [solution](https://leetcode.com/problems/house-robber/discuss/182943/Super-intuitive-Java-solution) for house robber, finish this up and move on to house robber III  !\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length==0) return 0;\\n        if (nums.length==1) return nums[0];\\n        int[] circutBreaker1 = Arrays.copyOfRange(nums, 0, nums.length-1);\\n        int[] circutBreaker2 = Arrays.copyOfRange(nums, 1, nums.length);\\n        return Math.max(robSub(circutBreaker1), robSub(circutBreaker2));\\n    }\\n    \\n    private int robSub(int[] nums) {\\n        int[] dp = new int[nums.length+2];\\n        dp[0]=0;\\n        dp[1]=0;\\n        for (int i=2; i<dp.length; i++) {\\n            dp[i]=Math.max(dp[i-2]+nums[i-2], dp[i-1]);\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length==0) return 0;\\n        if (nums.length==1) return nums[0];\\n        int[] circutBreaker1 = Arrays.copyOfRange(nums, 0, nums.length-1);\\n        int[] circutBreaker2 = Arrays.copyOfRange(nums, 1, nums.length);\\n        return Math.max(robSub(circutBreaker1), robSub(circutBreaker2));\\n    }\\n    \\n    private int robSub(int[] nums) {\\n        int[] dp = new int[nums.length+2];\\n        dp[0]=0;\\n        dp[1]=0;\\n        for (int i=2; i<dp.length; i++) {\\n            dp[i]=Math.max(dp[i-2]+nums[i-2], dp[i-1]);\\n        }\\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219244,
                "title": "c-dp-beats-100-space-optimization",
                "content": "# Intuition\\nWe know that the houses are arranged in a circle so the only difference between this question and \"HOUSE ROBBER I\" is that here you can\\'t take the first house if you have taken the last one, or vice-versa.\\n\\n# Approach\\nCreate 2 different vector, say v1 and v2.\\nvector v1 contains the 1st house but exclude the last house.\\nvector v2 contains the last house but excludes the first house.\\nreturn the max solution by v1 and v2.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums)\\n    {\\n        int n=nums.size();\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n\\n        for(int i=2;i<n;i++)\\n        {\\n           int curr=max(prev1,prev2+nums[i]);\\n           prev2=prev1;\\n           prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n         return nums[0];\\n        if(n==2)\\n         return max(nums[0],nums[1]);\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=0)\\n             v1.push_back(nums[i]);\\n            if(i!=nums.size()-1)\\n             v2.push_back(nums[i]);\\n        }\\n        int ans=max(solve(v1),solve(v2));\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/6e9307ea-d9cb-4d65-a377-ff7a5f24ec08_1677089524.1039042.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums)\\n    {\\n        int n=nums.size();\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n\\n        for(int i=2;i<n;i++)\\n        {\\n           int curr=max(prev1,prev2+nums[i]);\\n           prev2=prev1;\\n           prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n         return nums[0];\\n        if(n==2)\\n         return max(nums[0],nums[1]);\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=0)\\n             v1.push_back(nums[i]);\\n            if(i!=nums.size()-1)\\n             v2.push_back(nums[i]);\\n        }\\n        int ans=max(solve(v1),solve(v2));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682761,
                "title": "c-4-approaches-dp-memo-o-1-space-and-o-n-time",
                "content": "**RECURSIVE APPROACH -**         *(TIME - O(2^N) & AUXILIARY SPACE - O(N))*\\n```\\nclass Solution {\\nprivate:\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\\n\\n**MEMOIZATION -**  *(TIME - O(N) & SPACE - O(2N))*\\n```\\nclass Solution {\\nprivate:\\n    int dp[101][2];\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        if(dp[i][robFirst]!=-1) return dp[i][robFirst];\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return dp[i][robFirst] = max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof dp);\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\\n**TABULATION APPRAOCH -**  *(TIME - O(N) & SPACE - O(2N))*\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n+1], dp1[n+1];\\n        dp[0] = 0 ; \\n        dp[1] = nums[0];\\n        dp1[0] = 0;\\n        dp1[1] = 0;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i == n) dp[i] = dp[i-1];\\n            else dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n            dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i-1]);\\n        }  \\n        return max(dp[n], dp1[n]);\\n    }\\n};\\n```\\n**2 VARIABLE DP APPROACH -**  *(TIME - O(N) & SPACE - O(1))*\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int a1 = 0, b1 = nums[0], a2 = 0, b2 = 0, temp1, temp2;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i != n) {\\n                temp1 = b1;\\n                b1 = max(a1 + nums[i-1], b1);\\n                a1 = temp1;\\n            }\\n            temp2 = b2;\\n            b2 = max(a2 + nums[i-1], b2);\\n            a2 = temp2;\\n        }  \\n        return max(b1, b2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int dp[101][2];\\n    int getMax(vector<int>&nums, int i, bool robFirst){\\n        if(i >= nums.size() || (i==nums.size()-1 && robFirst)) return 0;\\n        if(dp[i][robFirst]!=-1) return dp[i][robFirst];\\n        int rob = 0, notRob = 0; \\n        if(i==0) rob = getMax(nums,i+2,1)+nums[i]; \\n        else rob = getMax(nums,i+2,robFirst)+nums[i];\\n        notRob = getMax(nums,i+1,robFirst);\\n        return dp[i][robFirst] = max(rob, notRob);\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof dp);\\n        return getMax(nums, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n+1], dp1[n+1];\\n        dp[0] = 0 ; \\n        dp[1] = nums[0];\\n        dp1[0] = 0;\\n        dp1[1] = 0;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i == n) dp[i] = dp[i-1];\\n            else dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n            dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i-1]);\\n        }  \\n        return max(dp[n], dp1[n]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int a1 = 0, b1 = nums[0], a2 = 0, b2 = 0, temp1, temp2;\\n        for(int i = 2 ; i <= n ; i++){\\n            if(i != n) {\\n                temp1 = b1;\\n                b1 = max(a1 + nums[i-1], b1);\\n                a1 = temp1;\\n            }\\n            temp2 = b2;\\n            b2 = max(a2 + nums[i-1], b2);\\n            a2 = temp2;\\n        }  \\n        return max(b1, b2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523568,
                "title": "one-pass-simple-solution-c-python",
                "content": "If you have already solved the problem [House Robber I](/https://leetcode.com/problems/house-robber//), then it\\'s just an extension to it.\\n\\nAs houses are circular and we cannot rob house 1 and n together, so we have 2 choices:\\n\\n**1> Rob houses from 1 to n-1\\n2> Rob houses from 2 to n**\\n\\nHere we can use two dp arrays to store the maximum profit for these two cases like this:\\n\\n<br>\\n\\n# C++ code:\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n\\t\\t// dp1 -> 1 to n-1\\n\\t\\t// dp2 -> 2 to n\\n\\t\\t\\n        int dp1[n], dp2[n];\\n\\t\\t\\n\\t\\t// if we have robbed the first house, then we can\\'t rob the second house\\n        dp1[0] = nums[0];\\n        dp1[1] = nums[0];\\n\\t\\t\\n\\t\\t// if we didn\\'t rob the first house, we will definetely rob the second\\n        dp2[0] = 0;\\n        dp2[1] = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n\\t\\t\\n\\t\\t\\t// make optimal choice at each house\\n            dp1[i] = max(nums[i] + dp1[i-2], dp1[i-1]);\\n            dp2[i] = max(nums[i] + dp2[i-2], dp2[i-1]);\\n        }\\n        \\n\\t\\t// dp1 is for nums[1 - (n-1)] so we won\\'t consider the last house in this case and dp1[n-2] will be max profit\\n\\t\\t// and dp2 is for nums[2 - n] so we can take the last house\\n        return max(dp1[n-2], dp2[n-1]);\\n    }\\n};\\n```\\n<br>\\n\\n# Python code:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        if n == 2: return max(nums[0], nums[1])\\n        \\n        dp1, dp2 = [0] * n, [0] * n\\n        \\n        dp1[0] = nums[0]\\n        dp1[1] = nums[0]\\n        dp2[0] = 0\\n        dp2[1] = nums[1]\\n        \\n        for i in range(2, n):\\n            dp1[i] = max(nums[i] + dp1[i - 2], dp1[i - 1])\\n            dp2[i] = max(nums[i] + dp2[i - 2], dp2[i - 1])\\n        \\n        return max(dp1[n - 2], dp2[n - 1])\\n```\\n\\n<br>**Felt happy for the first time after helping a robber (Though that doesn\\'t mean I\\'ve helped any other robber before  )**<br>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n\\t\\t// dp1 -> 1 to n-1\\n\\t\\t// dp2 -> 2 to n\\n\\t\\t\\n        int dp1[n], dp2[n];\\n\\t\\t\\n\\t\\t// if we have robbed the first house, then we can\\'t rob the second house\\n        dp1[0] = nums[0];\\n        dp1[1] = nums[0];\\n\\t\\t\\n\\t\\t// if we didn\\'t rob the first house, we will definetely rob the second\\n        dp2[0] = 0;\\n        dp2[1] = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n\\t\\t\\n\\t\\t\\t// make optimal choice at each house\\n            dp1[i] = max(nums[i] + dp1[i-2], dp1[i-1]);\\n            dp2[i] = max(nums[i] + dp2[i-2], dp2[i-1]);\\n        }\\n        \\n\\t\\t// dp1 is for nums[1 - (n-1)] so we won\\'t consider the last house in this case and dp1[n-2] will be max profit\\n\\t\\t// and dp2 is for nums[2 - n] so we can take the last house\\n        return max(dp1[n-2], dp2[n-1]);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        if n == 2: return max(nums[0], nums[1])\\n        \\n        dp1, dp2 = [0] * n, [0] * n\\n        \\n        dp1[0] = nums[0]\\n        dp1[1] = nums[0]\\n        dp2[0] = 0\\n        dp2[1] = nums[1]\\n        \\n        for i in range(2, n):\\n            dp1[i] = max(nums[i] + dp1[i - 2], dp1[i - 1])\\n            dp2[i] = max(nums[i] + dp2[i - 2], dp2[i - 1])\\n        \\n        return max(dp1[n - 2], dp2[n - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230657,
                "title": "python-solution",
                "content": "Since `nums[0]` and `nums[-1]` cannot be robbed simultaneously, The robber has to rob houses in `nums[:-1]` or in `nums[1:]`, whichever is larger. Therefore, the problem reduces to two LC 198. House Robber I problems, which have already been solved. \\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        rec = curr_max\\n        \\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1, 0, -1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        return max(rec, curr_max)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        rec = curr_max\\n        \\n        prev_max = 0\\n        curr_max = 0\\n        for i in range(len(nums)-1, 0, -1):\\n            tmp = curr_max\\n            curr_max = max(curr_max, prev_max+nums[i])\\n            prev_max = tmp\\n        return max(rec, curr_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767457,
                "title": "java-dp-step-by-step-house-robber-i-ii-noobs-whiteboarding",
                "content": "Lets start this problem by solving it with a naive approach and incrementally optimize it and make it as an efficient one. Writing this post to share my understanding on dynamic programming.\\n\\n\\n**House Robber**\\n\\nThe problem requests you to find the maximum sum that you can obtain with elements that will be selected where they are not next to each other. \\nLets take the below array of three elements to solve the problem\\nnums => [5,3,4]\\nWe are given options to choose either the ith + i-2th element or i-1th element. \\nIf we say i=2 (nums.length-1)\\nThen max(nums[i-2]+nums[i],nums[i-1]) => max value of the array.\\n\\nLets start the problem with the above intuition with a larger array [5,3,4,15,6] . \\n\\n\\n```\\npublic int rob(int[] nums) {\\n\\treturn naive(nums,nums.length-1);\\n\\t}\\n    \\npublic int naive(int[] nums,int i){\\n\\tif(i<0)\\n\\t\\treturn 0;\\n\\tint select=naive(nums,i-2)+nums[i];\\n\\tint p_select=naive(nums,i-1);\\n\\treturn Math.max(select,p_select);\\n\\t}\\n\\t\\n```\\n\\nThe above program recursion steps will be as below. The repesentation of numbers 0,1,2,3,4 represents the index i.\\n\\n![image](https://assets.leetcode.com/users/images/e44f65f7-635f-45b9-a8e3-2d0764da992f_1596311359.3493848.png)\\n\\n\\nNow if we observe the recursion tree there were repeated calls made for indexes 0,1,2. We can avoid them by storing the solution that we obtain in their appropriate index in a cache array.\\n\\n![image](https://assets.leetcode.com/users/images/6ef29d33-4e1b-49a2-9008-9b5db480b0ad_1596311660.058376.png)\\n\\nTime Complexity : O(2^n) \\nSpace Complexity : O(1) If we consider stack space it will be O(n)\\nI have avoided the recursion calls in the above images that yields value of i <1 but those calls will be made which yields time complexity to 2^n\\n\\nIntroducing Cache Layer in the recursive approach saves the additional iterations made\\n\\n```\\npublic int rob(int[] nums) {        \\n        int[] cache=new int[nums.length];\\n        return dp(nums,nums.length-1,cache);\\n    }\\n    \\npublic int naive(int[] nums,int i,int[] cache){\\n        if(i<0)\\n            return 0;\\n        if(cache[i]!=0)\\n            return cache[i];\\n        int select=dp(nums,i-2,cache)+nums[i];\\n        int p_select=dp(nums,i-1,cache);\\n        return Math.max(select,p_select);\\n    }\\n```\\n\\nNow we can transform the above approach to top down hence rewriting the above code in top down approach is given below.\\n\\n```\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        int[] cache=new int[nums.length];\\n        cache[0]=nums[0];\\n        cache[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            cache[i]=cache[i-2]+nums[i];\\n            cache[i]=Math.max(cache[i],cache[i-1]);\\n        }\\n        return cache[nums.length-1];\\n    }\\n```\\nTime Complexity : O(n) \\nSpace Complexity : O(n) \\n\\n\\nIf we observe the approach above all we are looking for is to just track two values of cache eithe it will be cache[i-1] or cache[i-2] + nums[i]. Hence we dont need this additonal memory to find out the max amount/sum the robber can steal.\\n\\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];        \\n        int first=nums[0];\\n        int second=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```\\n\\nTime Complexity : O(n) \\nSpace Complexity : O(1) \\n\\nIn the above approach we declare two variables first and second to capture the first value and max of first and second value in the array respectively. This yields to track always the max of nums[i-2]+nums[i] in second variable and nums[i-1] in first variable.\\n\\nIf you have taken time to reach here with this post i assume you got an understanding of the problem approach on implementing dp and the next problem on House Robber II can be solved very easily. \\n\\n**House Robber II**\\nThe approch to solve this problem is same as House Robber but the only restriction is to consider either the first or the last house to account for the max value the robber can steal from houses. Considering this condition and applying it to the problem must be straight forward by selecting the first index and skipping the last one or skipping the first index and selecting the last one.\\n\\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        return Math.max(dp(nums,0,nums.length-2),dp(nums,1,nums.length-1));\\n    }\\n    \\n    public int dp(int[] nums,int start,int end){\\n        int first=nums[start];\\n        int second=Math.max(nums[start],nums[start+1]);\\n        for(int i=start+2;i<=end;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```\\n\\nTime Complexity : O(n) \\nSpace Complexity : O(1) \\n\\nYou can write much concise code from the above suggested solutions but I have explained it in detail so that people who are starting to understand the basics of DP might understand better.\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int rob(int[] nums) {\\n\\treturn naive(nums,nums.length-1);\\n\\t}\\n    \\npublic int naive(int[] nums,int i){\\n\\tif(i<0)\\n\\t\\treturn 0;\\n\\tint select=naive(nums,i-2)+nums[i];\\n\\tint p_select=naive(nums,i-1);\\n\\treturn Math.max(select,p_select);\\n\\t}\\n\\t\\n```\n```\\npublic int rob(int[] nums) {        \\n        int[] cache=new int[nums.length];\\n        return dp(nums,nums.length-1,cache);\\n    }\\n    \\npublic int naive(int[] nums,int i,int[] cache){\\n        if(i<0)\\n            return 0;\\n        if(cache[i]!=0)\\n            return cache[i];\\n        int select=dp(nums,i-2,cache)+nums[i];\\n        int p_select=dp(nums,i-1,cache);\\n        return Math.max(select,p_select);\\n    }\\n```\n```\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        int[] cache=new int[nums.length];\\n        cache[0]=nums[0];\\n        cache[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            cache[i]=cache[i-2]+nums[i];\\n            cache[i]=Math.max(cache[i],cache[i-1]);\\n        }\\n        return cache[nums.length-1];\\n    }\\n```\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];        \\n        int first=nums[0];\\n        int second=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```\n```\\npublic int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        return Math.max(dp(nums,0,nums.length-2),dp(nums,1,nums.length-1));\\n    }\\n    \\n    public int dp(int[] nums,int start,int end){\\n        int first=nums[start];\\n        int second=Math.max(nums[start],nums[start+1]);\\n        for(int i=start+2;i<=end;i++){\\n            int temp=second;\\n            second=Math.max(first+nums[i],second);\\n            first=temp;\\n        }\\n        return second;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482985,
                "title": "javascript-easy-solution",
                "content": "```javascript\\nvar rob = function(nums) {\\n    if (nums.length < 2) {\\n        return nums[0] || 0;\\n    }\\n    \\n    const memo1 = [nums[0]];\\n    const memo2 = [0, nums[1]];\\n    \\n    for (let i=1; i<nums.length - 1; i++) {\\n        memo1[i] = Math.max(nums[i] + (memo1[i - 2] || 0), memo1[i - 1]);\\n    }\\n    \\n    for (let i=2; i<nums.length; i++) {\\n        memo2[i] = Math.max(nums[i] + memo2[i - 2], memo2[i - 1]);\\n    }\\n    \\n    return Math.max(memo1.pop(), memo2.pop());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar rob = function(nums) {\\n    if (nums.length < 2) {\\n        return nums[0] || 0;\\n    }\\n    \\n    const memo1 = [nums[0]];\\n    const memo2 = [0, nums[1]];\\n    \\n    for (let i=1; i<nums.length - 1; i++) {\\n        memo1[i] = Math.max(nums[i] + (memo1[i - 2] || 0), memo1[i - 1]);\\n    }\\n    \\n    for (let i=2; i<nums.length; i++) {\\n        memo2[i] = Math.max(nums[i] + memo2[i - 2], memo2[i - 1]);\\n    }\\n    \\n    return Math.max(memo1.pop(), memo2.pop());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60020,
                "title": "jave-o-1-space-o-n-time-optimal-solution",
                "content": "Helper method returns DP solution from 0 - n-2  and 1 - n-1. Final answer is the max between two. \\n\\n \\n\\n      public class Solution {\\n            public int rob(int[] nums) {\\n                if (nums == null || nums.length == 0)\\n                    return 0;\\n                int n = nums.length;\\n                if (n == 1) {\\n                    return nums[0];\\n                }\\n                return Math.max(robHelper(nums, 0, n - 2), robHelper(nums, 1, n - 1));\\n            }\\n            \\n            private int robHelper(int[] nums, int start, int end) {\\n                int curr, prev, prev2;\\n                curr = prev = prev2 = 0;\\n                for (int i = start; i <= end; i++) {\\n                    curr = Math.max(prev2 + nums[i], prev);\\n                    prev2 = prev;\\n                    prev = curr;\\n                }\\n                return curr;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public int rob(int[] nums) {\\n                if (nums == null || nums.length == 0)\\n                    return 0;\\n                int n = nums.length;\\n                if (n == 1) {\\n                    return nums[0];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 667454,
                "title": "python-explanation-with-very-simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. Only 2 scenarios possible \\n        ##     a) Rob 1st and donot rob last \\n        ##     b) Rob last and donot rob first. \\n        ## We take maximum of both cases.\\n        \\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def house_robber(nums):\\n            dp = [0] * len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2,len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n            return max(dp[-1], dp[-2])\\n        \\n        if len(nums) <=2 : return max([0] + nums)\\n        return max( house_robber(nums[1:]), house_robber(nums[:-1]) )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. Only 2 scenarios possible \\n        ##     a) Rob 1st and donot rob last \\n        ##     b) Rob last and donot rob first. \\n        ## We take maximum of both cases.\\n        \\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def house_robber(nums):\\n            dp = [0] * len(nums)\\n            dp[0] = nums[0]\\n            dp[1] = max(nums[0], nums[1])\\n            for i in range(2,len(nums)):\\n                dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n            return max(dp[-1], dp[-2])\\n        \\n        if len(nums) <=2 : return max([0] + nums)\\n        return max( house_robber(nums[1:]), house_robber(nums[:-1]) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057642,
                "title": "beats-100-in-time-memoized-solution-explained",
                "content": "**Recursive Solution**\\n\\nThe selection can be done in two ways-\\n1. If nums[0] is selected, we can\\'t select nums[1]. Hence the call is made to nums[2]. \\n\\t*Also, there is an additional restriction that the list is circular. So the last element can also not be selected if the first element is selected. Hence, in the solve function, a first flag is maintained to denote if the first element is selected or not.*\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums, int n, int i, bool first)\\n    {\\n\\t\\n        if(i>=n)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t// If we have to decide for the last element, check if first element is selected or not.\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        \\n\\t\\t// At current position ,we have the same two options again\\n        int a = nums[i]+solve(nums, n, i+2, first);\\n        int b = solve(nums, n, i+1, first);\\n\\t\\t// Return maximum of both combinations\\n        return max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n\\t\\t\\t\\n\\t\\t// Return max of values starting selection from first or second element\\n        return max(nums[0]+solve(nums, n, 2, true), solve(nums, n, 1, false));\\n    }\\n};\\n```\\n\\n**Memoized Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int n, int i, bool first, vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(dp[i][first]!=-1)\\n            return dp[i][first];\\n        int a = nums[i]+solve(nums, n, i+2, first, dp);\\n        int b = solve(nums, n, i+1, first, dp);\\n        return dp[i][first]=max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        if(n==1)\\n            return nums[0];\\n        return max(nums[0]+solve(nums, n, 2, true, dp), solve(nums, n, 1, false, dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums, int n, int i, bool first)\\n    {\\n\\t\\n        if(i>=n)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t// If we have to decide for the last element, check if first element is selected or not.\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        \\n\\t\\t// At current position ,we have the same two options again\\n        int a = nums[i]+solve(nums, n, i+2, first);\\n        int b = solve(nums, n, i+1, first);\\n\\t\\t// Return maximum of both combinations\\n        return max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n\\t\\t\\t\\n\\t\\t// Return max of values starting selection from first or second element\\n        return max(nums[0]+solve(nums, n, 2, true), solve(nums, n, 1, false));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int n, int i, bool first, vector<vector<int>> &dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(i==(n-1))\\n        {\\n            if(first==true)\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(dp[i][first]!=-1)\\n            return dp[i][first];\\n        int a = nums[i]+solve(nums, n, i+2, first, dp);\\n        int b = solve(nums, n, i+1, first, dp);\\n        return dp[i][first]=max(a, b);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        if(n==1)\\n            return nums[0];\\n        return max(nums[0]+solve(nums, n, 2, true, dp), solve(nums, n, 1, false, dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354170,
                "title": "c-recursion-memoization-tabulation-space-optimization",
                "content": "***This question is the slight modification of the [House Robber-198](https://leetcode.com/problems/house-robber/) .***\\n\\n# Method-1[Recursion - Bruteforce]\\n![image](https://assets.leetcode.com/users/images/8a38320b-73ca-4e58-b17b-4be4812cf9ca_1659165415.5374784.png)\\n\\n***This gives TLE!***\\n**n==number of nodes in the Recursion Tree\\nT->O(2^n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxsum(int i,vector<int>& nums){\\n\\t\\t\\tif(i<0)return 0;\\n\\t\\t\\tint pick=nums[i]+maxsum(i-2,nums);\\n\\t\\t\\tint notpick=maxsum(i-1,nums);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(maxsum(n-2,nums1),maxsum(n-2,nums2)); \\n\\t\\t}\\n\\t};\\n\\t\\n# Method-2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/da4beb7a-7b1d-4a8d-b21c-2fae3d4769a7_1659165893.5073082.png)\\n\\n**n==nums,size()\\nT->O(n) && S->O(n) [Recursion Stack space]+O(n) [Space for dp array]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxsum(int i,vector<int>& nums,vector<int>& dp){\\n\\t\\t\\tif(i<0)return 0;\\n\\t\\t\\tif(dp[i]!=-1)return dp[i];\\n\\t\\t\\tint pick=nums[i]+maxsum(i-2,nums,dp);\\n\\t\\t\\tint notpick=maxsum(i-1,nums,dp);\\n\\t\\t\\treturn dp[i]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2,dp1(n-1,-1),dp2(n-1,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(maxsum(n-2,nums1,dp1),maxsum(n-2,nums2,dp2)); \\n\\t\\t}\\n\\t};\\n\\t\\n# Method-3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/251b3c0f-a82a-4cf2-ab31-c3bc9adfd963_1659167767.8728886.png)\\n\\n**Tabulation is bottom-up**\\n**n==nums.size()\\nT->O(n) && S->O(n) [Space for dp array]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2,dp1(n-1),dp2(n-1);\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tdp1[0]=nums1[0];\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tint pick=nums1[i];\\n\\t\\t\\t\\tif(i!=1)pick+=dp1[i-2];\\n\\t\\t\\t\\tint notpick=dp1[i-1];\\n\\t\\t\\t\\tdp1[i]=max(pick,notpick);\\n\\t\\t\\t}\\n\\t\\t\\tdp2[0]=nums2[0];\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tint pick=nums2[i];\\n\\t\\t\\t\\tif(i!=1)pick+=dp2[i-2];\\n\\t\\t\\t\\tint notpick=dp2[i-1];\\n\\t\\t\\t\\tdp2[i]=max(pick,notpick);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(dp1[n-2],dp2[n-2]); \\n\\t\\t}\\n\\t};\\n\\t\\n# Method-4 [Space Optimization]\\n\\n![image](https://assets.leetcode.com/users/images/a7f89487-0be5-450c-8adb-16874f1aac73_1659169357.2019129.png)\\n\\n**n==nums.size()\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum(int i,vector<int>& nums){\\n\\t\\t\\tint p1=nums[0],p2;\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tint pick=nums[i];\\n\\t\\t\\t\\tif(i!=1)pick+=p2;\\n\\t\\t\\t\\tint notpick=p1;\\n\\t\\t\\t\\tint curri=max(pick,notpick);\\n\\t\\t\\t\\tp2=p1;\\n\\t\\t\\t\\tp1=curri;\\n\\t\\t\\t}\\n\\t\\t\\treturn p1;\\n\\t\\t}\\n\\n\\t\\tint rob(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tif(n==1)return nums[0];\\n\\t\\t\\tvector<int>nums1,nums2,dp1(n-1),dp2(n-1);\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(i!=0)nums1.push_back(nums[i]);\\n\\t\\t\\t\\tif(i!=n-1)nums2.push_back(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(sum(n-2,nums1),sum(n-2,nums2)); \\n\\t\\t}\\n\\t};\\n\\n\\t\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxsum(int i,vector<int>& nums){\\n\\t\\t\\tif(i<0)return 0;\\n\\t\\t\\tint pick=nums[i]+maxsum(i-2,nums);\\n\\t\\t\\tint notpick=maxsum(i-1,nums);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 893903,
                "title": "house-robber-ii-java-c-kotlin-o-n-time-o-1-space",
                "content": "For a circle case, in order to make sure don\\'t rob both the first and the last houses, we can seperate it to 2 linear cases and find the max.  Let\\'s say there are n houses and there will two cases:\\n\\n1. Rob the first house.  So can\\'t rob the last one.  That is rob from 0 to n-2 houses\\n1. Don\\'t rob the first house and can rob the last one.  That is rob from 1 to n-1 houses. \\n1. The result must be one of them.  Let\\'s get the max of 1 and 2\\n\\nNext, how to rob a linear houses with size n. This is **House Robber** (leetcode 191).  Assume that we have an array profits of size n.  **profit[i]** is the the maximum amount of money you can rob from house 0 to house i.   For the i+1th house, we have \\n\\n**profit[i+1] = max( profit[i-1] + nums[i+1], profits[i])** \\n\\nSo we can have a stardard dp solution. \\n\\nThis solution is for the linear case and **NOT** for this question.  Have to add this since there are complains about it doesn\\'t work.  I add this soluton so we can find and understand the optimized solution.  \\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return nums[0];\\n        int[] profit = new int[n];\\n        profit[0] = nums[0];\\n        profit[1] = Math.max(nums[0], nums[1]);\\n        for (int i = 2; i < n; i++)\\n        {\\n            profit[i] = Math.max(profit[i-2] + nums[i], profit[i-1]);\\n        }\\n        return profit[n-1];\\n    }\\n}\\n```\\n\\nThe space complexity for this is O(N).  Notice that each profit only depends on **the previous two values(dark green)**.  So we only need two variable for that.  Now we can have a space **O(1)** solution.  The follow solutions are Time **O(N)** Space **O(1)** solutions. \\n\\n![image](https://assets.leetcode.com/users/images/ce31152b-5a4f-450e-ab75-00219b581fa1_1602662738.7130792.png)\\n\\n\\nIf you like it, please upvote it. Thanks.\\n\\n**java**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length ==1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n    }\\n    private int rob(int[]nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() ==1) return nums[0];\\n        return max(rob(nums, 0, nums.size()-2), rob(nums, 1, nums.size()-1));\\n    }\\nprivate:\\n    int rob(vector<int>&nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n};\\n```\\n\\n**kotlin**\\n```\\nclass Solution {\\n    fun rob(nums: IntArray): Int {\\n        if (nums.size == 1) return nums[0]\\n        return Math.max(rob(nums, 0, nums.size-2), rob(nums, 1, nums.size-1))\\n    }\\n    private fun rob(nums: IntArray, start: Int, end: Int): Int\\n    {\\n        var a = 0\\n        var b = 0\\n        for (i in start..end)\\n        {\\n            var temp: Int = b\\n            if (a + nums[i] > b)\\n            {\\n                b = a + nums[i]\\n            }\\n            a = temp\\n        }\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return nums[0];\\n        int[] profit = new int[n];\\n        profit[0] = nums[0];\\n        profit[1] = Math.max(nums[0], nums[1]);\\n        for (int i = 2; i < n; i++)\\n        {\\n            profit[i] = Math.max(profit[i-2] + nums[i], profit[i-1]);\\n        }\\n        return profit[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length ==1) return nums[0];\\n        return Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\\n    }\\n    private int rob(int[]nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() ==1) return nums[0];\\n        return max(rob(nums, 0, nums.size()-2), rob(nums, 1, nums.size()-1));\\n    }\\nprivate:\\n    int rob(vector<int>&nums, int start, int end)\\n    {\\n        int a = 0, b = 0;\\n        for (int i = start; i <= end; i++)\\n        {\\n            int temp = b;\\n            if (nums[i] + a > b)\\n            {\\n                b = nums[i] + a;\\n            }\\n            a = temp;\\n        }\\n        return b;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun rob(nums: IntArray): Int {\\n        if (nums.size == 1) return nums[0]\\n        return Math.max(rob(nums, 0, nums.size-2), rob(nums, 1, nums.size-1))\\n    }\\n    private fun rob(nums: IntArray, start: Int, end: Int): Int\\n    {\\n        var a = 0\\n        var b = 0\\n        for (i in start..end)\\n        {\\n            var temp: Int = b\\n            if (a + nums[i] > b)\\n            {\\n                b = a + nums[i]\\n            }\\n            a = temp\\n        }\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477572,
                "title": "java-few-solutions-recursion-memoization-dp",
                "content": "**Recursion : TLE**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int one = helper(nums,0,nums.length-2);\\n        int two = helper(nums,1,nums.length-1);\\n        return Math.max(one,two);\\n    }\\n    public int helper(int nums[],int start,int n){\\n        if(n < start)return 0;\\n        if(n == start)return nums[start];\\n        return Math.max(helper(nums,start,n-1),helper(nums,start,n-2) + nums[n]);\\n    }\\n}\\n```\\n**Memoization :\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\nMemory Usage: 36.2 MB, less than 89.84% of Java online submissions for House Robber II.**\\n```\\nclass Solution {\\n    int dp[][];\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        dp = new int[nums.length+1][2];\\n        for(int i[] : dp)Arrays.fill(i,-1);\\n        \\n        int one = helper(nums,0,nums.length-2,0);\\n        int two = helper(nums,1,nums.length-1,1);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int helper(int nums[],int start,int n,int idx){\\n        if(n < start)return 0;\\n        if(n == start)return dp[n][idx] = nums[start];\\n        if(dp[n][idx] != -1)return dp[n][idx];\\n        return dp[n][idx] = Math.max(helper(nums,start,n-1,idx),helper(nums,start,n-2,idx) + nums[n]);\\n    }\\n}\\n```\\n**DP :O(N) Space\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\nMemory Usage: 36.7 MB, less than 46.15% of Java online submissions for House Robber II.**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int dp[][] = new int[nums.length + 1][2];\\n        int one = HouseRobberOne(nums,1,nums.length-1,dp,0);\\n        int two = HouseRobberOne(nums,2,nums.length,dp,1);\\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end,int[][] dp,int idx){\\n        dp[start][idx] = nums[start - 1];\\n        for(int i = start;i<end;i++){\\n            dp[i+1][idx] = Math.max(dp[i][idx],dp[i-1][idx] + nums[i]); \\n        }\\n        return dp[end][idx];\\n    }\\n}\\n```\\n**DP : O(1) Space\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\nMemory Usage: 36.7 MB, less than 46.15% of Java online submissions for House Robber II.**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        int one = HouseRobberOne(nums,0,nums.length-1);\\n        int two = HouseRobberOne(nums,1,nums.length);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end){\\n        int rob = nums[start],no_rob = 0;\\n        \\n        for(int i = start + 1;i<end;i++){\\n            int new_rob = no_rob + nums[i];\\n            int new_no_rob = Math.max(no_rob,rob);\\n            rob = new_rob;\\n            no_rob = new_no_rob;\\n        }\\n        \\n        return Math.max(rob,no_rob);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int one = helper(nums,0,nums.length-2);\\n        int two = helper(nums,1,nums.length-1);\\n        return Math.max(one,two);\\n    }\\n    public int helper(int nums[],int start,int n){\\n        if(n < start)return 0;\\n        if(n == start)return nums[start];\\n        return Math.max(helper(nums,start,n-1),helper(nums,start,n-2) + nums[n]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int dp[][];\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        dp = new int[nums.length+1][2];\\n        for(int i[] : dp)Arrays.fill(i,-1);\\n        \\n        int one = helper(nums,0,nums.length-2,0);\\n        int two = helper(nums,1,nums.length-1,1);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int helper(int nums[],int start,int n,int idx){\\n        if(n < start)return 0;\\n        if(n == start)return dp[n][idx] = nums[start];\\n        if(dp[n][idx] != -1)return dp[n][idx];\\n        return dp[n][idx] = Math.max(helper(nums,start,n-1,idx),helper(nums,start,n-2,idx) + nums[n]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int dp[][] = new int[nums.length + 1][2];\\n        int one = HouseRobberOne(nums,1,nums.length-1,dp,0);\\n        int two = HouseRobberOne(nums,2,nums.length,dp,1);\\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end,int[][] dp,int idx){\\n        dp[start][idx] = nums[start - 1];\\n        for(int i = start;i<end;i++){\\n            dp[i+1][idx] = Math.max(dp[i][idx],dp[i-1][idx] + nums[i]); \\n        }\\n        return dp[end][idx];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        \\n        int one = HouseRobberOne(nums,0,nums.length-1);\\n        int two = HouseRobberOne(nums,1,nums.length);\\n        \\n        return Math.max(one,two);\\n    }\\n    \\n    public int HouseRobberOne(int []nums,int start,int end){\\n        int rob = nums[start],no_rob = 0;\\n        \\n        for(int i = start + 1;i<end;i++){\\n            int new_rob = no_rob + nums[i];\\n            int new_no_rob = Math.max(no_rob,rob);\\n            rob = new_rob;\\n            no_rob = new_no_rob;\\n        }\\n        \\n        return Math.max(rob,no_rob);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60034,
                "title": "simple-and-easy-c-solution-modified-from-the-best-solution-of-house-robber-easy",
                "content": "    int rob_line(vector<int>& nums, int start, int end) {\\n        int odd_sum=0;\\n        int even_sum=0;\\n        \\n        for(int i=start; i<end; i++) {\\n            if(i%2)\\n                odd_sum = max(even_sum, odd_sum+nums[i]);\\n            else\\n                even_sum = max(odd_sum, even_sum+nums[i]);\\n        }\\n        \\n        return max(odd_sum, even_sum);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        else if(nums.size()==1) return nums[0];\\n        else return max(rob_line(nums,0,nums.size()-1), rob_line(nums,1,nums.size()));\\n    }",
                "solutionTags": [],
                "code": "    int rob_line(vector<int>& nums, int start, int end) {\\n        int odd_sum=0;\\n        int even_sum=0;\\n        \\n        for(int i=start; i<end; i++) {\\n            if(i%2)\\n                odd_sum = max(even_sum, odd_sum+nums[i]);\\n            else\\n                even_sum = max(odd_sum, even_sum+nums[i]);\\n        }\\n        \\n        return max(odd_sum, even_sum);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        else if(nums.size()==1) return nums[0];\\n        else return max(rob_line(nums,0,nums.size()-1), rob_line(nums,1,nums.size()));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 442219,
                "title": "simple-code-beating-100-java-solution-by-dp-with-explanation",
                "content": "The intuition is to set u two dp arrays to store largest gain.\\nThe first one is just like a normal dp (house robber 1), where the last element cannot be used.\\nThe second one initialise the first dp element as 0 to simulte when the first element is not used\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        //set two dp arrays\\n        //dp--> the first element is used\\n        //dp2 --> the first element is not used\\n        int[] dp = new int[n];\\n        int[] dp2 = new int[n];\\n        \\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        //pretend first element is not used by initilize it as 0\\n        dp2[0]=0;\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i],dp2[i-1]);\\n        }\\n        // for dp[] if we use the first element, the last element cnanot be used, \\n        //so the largest profit is max(dp[n-2],dp2[n-1])\\n        \\n        return Math.max(dp[n-2],dp2[n-1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        //set two dp arrays\\n        //dp--> the first element is used\\n        //dp2 --> the first element is not used\\n        int[] dp = new int[n];\\n        int[] dp2 = new int[n];\\n        \\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        //pretend first element is not used by initilize it as 0\\n        dp2[0]=0;\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i],dp2[i-1]);\\n        }\\n        // for dp[] if we use the first element, the last element cnanot be used, \\n        //so the largest profit is max(dp[n-2],dp2[n-1])\\n        \\n        return Math.max(dp[n-2],dp2[n-1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894847,
                "title": "house-robber-ii-dp-editorial-c-java",
                "content": "***Dynamic programming Approach:***\\n\\n**Though Process :**\\n1. dp[i] = k , here i will be the *house position* and k is the  *maximum amount of money you can rob*.\\n2. Here, if we suppose, at any house index i, do we need to keep track , that how we reached here? Well, if we think too deeply, we can think some points below:\\n  i.) if we reach l-1 (last) house, and robs it, we can only do so , if house 0th house is not robbed else we cant rob it if 0th house is also robbed.\\n  May be we should keep track wheter or not house 0 is robbed or not.\\n \\n  \\n**Editorial :**\\nBut we may not go that way, because that will get bit complicated.\\nOther thing that comes to mind is :,\\n- Either 0 will be robbed and l-1 will not be robbed , \\n OR\\n - 0 will not be robbed , and l-1 will be robbed.\\n \\n**So we find two valuses : find maximum amount robbed in going from houses 0 tp l-2  and maximum amount robbed in going from house 1 to l-1.\\n And get the maximum value of the two.**\\n \\nNow the problem is broken into two sub problems of l-2 size. Each subproblem can be solved by following method:\\n \\n` dp[i] = max (dp[i-1] , dp[i-2]+nums[i-1]);`\\n where `dp[0] = nums[0]` and `dp[1] = nums[1];`\\n \\n What above equation means is :\\n**Either we**\\n` dont rob house i ; in that case  dp[i] =  (dp[i-1])`\\n**OR**\\n `rob house i and donot rob house i-1 ; in this case dp[i] = (dp[i-2] + nums[i])`\\n \\n My solution in c++:\\n ```\\nint rob(vector<int>& nums) {\\n    int l = nums.size();\\n    if (l == 0) return 0;\\n    if (l == 1) return nums[0];\\n    if (l == 2) return max(nums[0], nums[1]);\\n\\t\\n\\t//Subproblem 1\\n    vector<int> arr(l);\\n    arr[0] = nums[0]; //start from index 0\\n    arr[1] = max(nums[1], arr[0]);\\n    for (int i = 2; i < l-1; i++) { //end at index l-2\\n        arr[i] = max(nums[i] + arr[i - 2], arr[i - 1]);        \\n    }\\n\\n    //Subproblem 2\\n    vector<int> arr2(l);\\n    arr2[0] = 0;\\n    arr2[1] = nums[1];//start from index 1\\n    arr2[2] = max(nums[2], arr2[1]);\\n    for (int i = 3; i < l; i++) { //end at index l-1\\n        arr2[i] = max(nums[i] + arr2[i - 2], arr2[i - 1]);\\n    }\\n\\t\\n\\t/*debug\\n    for (int i = 0; i < l; i++) {\\n        cout << arr[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n    for (int i = 0; i < l; i++) {\\n        cout << arr2[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n\\t*/\\n    \\n    return max(arr[l-2] , arr2[l-1]) ;\\n}\\n ```\\n \\n Happy Coding Forever!\\n \\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint rob(vector<int>& nums) {\\n    int l = nums.size();\\n    if (l == 0) return 0;\\n    if (l == 1) return nums[0];\\n    if (l == 2) return max(nums[0], nums[1]);\\n\\t\\n\\t//Subproblem 1\\n    vector<int> arr(l);\\n    arr[0] = nums[0]; //start from index 0\\n    arr[1] = max(nums[1], arr[0]);\\n    for (int i = 2; i < l-1; i++) { //end at index l-2\\n        arr[i] = max(nums[i] + arr[i - 2], arr[i - 1]);        \\n    }\\n\\n    //Subproblem 2\\n    vector<int> arr2(l);\\n    arr2[0] = 0;\\n    arr2[1] = nums[1];//start from index 1\\n    arr2[2] = max(nums[2], arr2[1]);\\n    for (int i = 3; i < l; i++) { //end at index l-1\\n        arr2[i] = max(nums[i] + arr2[i - 2], arr2[i - 1]);\\n    }\\n\\t\\n\\t/*debug\\n    for (int i = 0; i < l; i++) {\\n        cout << arr[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n    for (int i = 0; i < l; i++) {\\n        cout << arr2[i] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n\\t*/\\n    \\n    return max(arr[l-2] , arr2[l-1]) ;\\n}\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 60015,
                "title": "0ms-o-n-time-o-1-space-c-solution",
                "content": "This solution is based on house robber 1. The idea is that either the first house or the last house is not robbed. The final solution is max of (house robber without last element) and (house robber without the first element). Note *endIndex* is not inclusive in the second rob function.\\n\\n    class Solution {\\n    public:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, nums.size()-1), rob(nums, 1, 0));\\n    }\\n\\n    int rob(vector<int>& nums, int startIndex, int endIndex) {\\n        int p = 0, q = 0;\\n        for (int i = startIndex; i != endIndex; /* do nothing */) {\\n            int tmp = p;\\n            p = max(p, q + nums[i]);\\n            q = tmp;\\n            i = (i + 1) % nums.size();\\n        }\\n        return p;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, nums.size()-1), rob(nums, 1, 0));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3145559,
                "title": "c-beats-100-dp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Like House Robber I do the same but call for two times first from `0 to n-1` and second from `1 to n` because ` 0 and n` are neighbours so we should not include both of them (either 0 or n).\\nSo just do like original House Robber and call for these two ranges.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint gen_rob(vector<int>& arr,int st,int end) {\\n        int p1=0,p2=0;\\n        int p3=0;\\n        for(int i=st;i<end;i++){\\n            p3=max(arr[i]+p2,p1);\\n            p2=p1;\\n            p1=p3;\\n        }\\n        return p3;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return nums[0];\\n        return max(gen_rob(nums,0,n-1),gen_rob(nums,1,n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint gen_rob(vector<int>& arr,int st,int end) {\\n        int p1=0,p2=0;\\n        int p3=0;\\n        for(int i=st;i<end;i++){\\n            p3=max(arr[i]+p2,p1);\\n            p2=p1;\\n            p1=p3;\\n        }\\n        return p3;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return nums[0];\\n        return max(gen_rob(nums,0,n-1),gen_rob(nums,1,n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577360,
                "title": "c-recursive-memoization-commented-0-1-knapsack-variation-t-c-o-2-n",
                "content": "* This problem is a variation of problem **[House Robber](https://leetcode.com/problems/house-robber/)**.\\n* The given solution is **90% simmiler** to my solution of **[House Robber](https://leetcode.com/problems/house-robber/discuss/1577300/c%2B%2B-oror-recursive-%2B-memoization-oror-0-1-knapsack-variation-oror-T.C.-O(2*n))**\\n* This solution will be a *cake-walk* if you go through the solution of  **[House Robber](https://leetcode.com/problems/house-robber/discuss/1577300/c%2B%2B-oror-recursive-%2B-memoization-oror-0-1-knapsack-variation-oror-T.C.-O(2*n))**\\n\\n\\n**Observations:**\\n1. Since House[1] and House[n] are adjacent, they cannot be robbed together. \\n2. Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], depending on which choice offers more money. \\n3. Now the problem has degenerated to the [House Robber](https://leetcode.com/problems/house-robber/), which is already been solved.\\n```\\nclass Solution {\\npublic:\\n    int dp[101][2];\\n\\n    int solve(vector<int>& nums, int n, int pos, bool isValid){\\n        if(pos>=n) return 0;\\n        if(dp[pos][isValid] != -1) return dp[pos][isValid];\\n        \\n        int rob = 0, notrob = 0;\\n        if(isValid) rob = nums[pos] + solve(nums,n,pos+1,false); //can rob, only when the previous house is not robbed\\n        notrob = solve(nums,n,pos+1,true); //cannot rob\\n        \\n        return dp[pos][isValid] = max(rob,notrob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0]; //exception condition, which we have to handle separately\\n\\t\\t//when n==1, case1 and case2 return 0 but we have to select the house as there are no adjecent house.\\n        \\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 1: rob from 0...n-1, because all houses are in circular so nth is adjecent to 0th house\\n        int case1 = solve(nums,n-1,0,true);\\n\\t\\t\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 2: rob from 1...n,\\n        int case2 = solve(nums,n,1,true);\\n\\t\\t\\n\\t\\t//return maximum between case1 & case2\\n        return max(case1,case2);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][2];\\n\\n    int solve(vector<int>& nums, int n, int pos, bool isValid){\\n        if(pos>=n) return 0;\\n        if(dp[pos][isValid] != -1) return dp[pos][isValid];\\n        \\n        int rob = 0, notrob = 0;\\n        if(isValid) rob = nums[pos] + solve(nums,n,pos+1,false); //can rob, only when the previous house is not robbed\\n        notrob = solve(nums,n,pos+1,true); //cannot rob\\n        \\n        return dp[pos][isValid] = max(rob,notrob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0]; //exception condition, which we have to handle separately\\n\\t\\t//when n==1, case1 and case2 return 0 but we have to select the house as there are no adjecent house.\\n        \\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 1: rob from 0...n-1, because all houses are in circular so nth is adjecent to 0th house\\n        int case1 = solve(nums,n-1,0,true);\\n\\t\\t\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//case 2: rob from 1...n,\\n        int case2 = solve(nums,n,1,true);\\n\\t\\t\\n\\t\\t//return maximum between case1 & case2\\n        return max(case1,case2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893882,
                "title": "java-dp-solution-with-detailed-simple-explanation-memoization-0-ms-best-approach",
                "content": "**EXPLANATION**\\n\\nWe will do the same thing which we used to do in the normal House Robber Problem but with only the following 2 modifications:\\n\\n1. When we select the first house, then we cannot select the last house, so we make the (N-2)th house the last house and do the same thing as the generic house robber problem. **That is, run the program for indices *[0 to N-2]*.**\\n\\n2. When we do not select the first house, then we can select the last house.  In this case, we do the same thing as house robber problem from house number 2 (**index 1**) to the last house. **That is, run the program for indices *[1 to N-1]*.**\\n\\nReturn the **maximum** of the 2 options.\\n\\n-------------------------**How to solve the generic House Robber Problem?**--------------------------\\n\\nSimple, we can either select a house or not select a house, i.e. we have 2 choices.  So, we create a recursive function and return the **maximum** value when we either select a house or not select a house.  Whenever, we select a house, we call the recursive function with the next index as **(current index + 2)** because we cannot select the neighbouring house.  If we do not select the house, then we call the recursive function with the next index as **(current index + 1)** because now we can select the neighbouring house.\\n\\nThis is a simple recursive approach.  Now, to make this approach optimal, we can memoize the recursive code using a 1D DP array.  This is because for every house when we calculate the maximum possible value, we can simply use that in our future recursive calls.  We do not need to calculate the values again.\\n\\n*------Please **upvote** if you liked the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n```\\nclass Solution {\\n    \\n    public int dp [];\\n    \\n    public int rob (int[] nums) {\\n        if (nums.length == 2)\\n            return Math.max (nums [0], nums [1]);\\n        if (nums.length == 1)\\n            return nums [0];\\n        int N = nums.length;\\n        dp = new int [N];\\n        Arrays.fill (dp, -1);\\n        int max1 = Solve (nums, 0, N-2);\\n        Arrays.fill (dp, -1);\\n        int max2 = Solve (nums, 1, N-1);\\n        return Math.max (max1, max2);\\n    }\\n    \\n    public int Solve (int arr [], int index, int N) {\\n        if (index > N)\\n            return 0;\\n        if (dp [index] != -1)\\n            return dp [index];\\n        int max1 = arr [index] + Solve (arr, index + 2, N);\\n        int max2 = Solve (arr, index + 1, N);\\n        return dp [index] = Math.max (max1, max2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int dp [];\\n    \\n    public int rob (int[] nums) {\\n        if (nums.length == 2)\\n            return Math.max (nums [0], nums [1]);\\n        if (nums.length == 1)\\n            return nums [0];\\n        int N = nums.length;\\n        dp = new int [N];\\n        Arrays.fill (dp, -1);\\n        int max1 = Solve (nums, 0, N-2);\\n        Arrays.fill (dp, -1);\\n        int max2 = Solve (nums, 1, N-1);\\n        return Math.max (max1, max2);\\n    }\\n    \\n    public int Solve (int arr [], int index, int N) {\\n        if (index > N)\\n            return 0;\\n        if (dp [index] != -1)\\n            return dp [index];\\n        int max1 = arr [index] + Solve (arr, index + 2, N);\\n        int max2 = Solve (arr, index + 1, N);\\n        return dp [index] = Math.max (max1, max2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894185,
                "title": "c-dp-solution-explained-100-time-100-memory",
                "content": "Ah, the joy of knowing you did not have to trade off memory for time or the other way around!\\n\\nAnyway, my solution will first of all store the length of the input in `len`, then weed out a couple of simple (yet potentially annoying) edge cases and finally return the maximum value our burglar might get by either looting all the houses but the last or all the houses but the first.\\n\\nIn order to compute it, we will use our helper function `loot` that takes 3 parameters:\\n* `houses`, directly from the main function and without any changes - be sure to pass it as a reference!;\\n* `start` and `finish`, the starting and ending points of our search, respectively.\\n\\nThen the magic happens: no need to store all the `finish - start + 1` values, as we just need the last 3 values to keep our DP computation rolling; now, a lot of people would just keep reassining variables, shifting then like:\\n\\n```cpp\\na = b;\\nb = c;\\nc = newStuff;\\n```\\n\\nBut that is kinda cumbersome, so I tried to to just use an array of 3 values and instead of shifting them, I work on them using the modulo operator.\\n\\nI initialise the value in position `start % 3` to be `houses[start]`, the one in position `(start + 1) % 3` to be `max(houses[start], houses[start + 1])` and I just go on with a loop for all the other remaining values, making so that each one is the maximum of either the previous or the value of 2 positions ago plue the matching value in `houses`, with the expression: `max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3])`.\\n\\nOnce I am done, I can just return the value of the last element parsed: `dp[(finish - 1)  % 3]`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[(start + 1) % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = start + 2; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n    int rob(vector<int> &houses) {\\n        int len = houses.size();\\n        // begone, edge cases!\\n        if (len < 3) return len == 1 ? houses[0] : max(houses[0], houses[1]);\\n        return max(loot(houses, 0, len - 1), loot(houses, 1, len));\\n    }\\n};\\n```\\n\\nTiny stylistic variant in `loot`, using the prefix operator on `start`:\\n\\n```cpp\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[++start % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = ++start; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\na = b;\\nb = c;\\nc = newStuff;\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[(start + 1) % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = start + 2; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n    int rob(vector<int> &houses) {\\n        int len = houses.size();\\n        // begone, edge cases!\\n        if (len < 3) return len == 1 ? houses[0] : max(houses[0], houses[1]);\\n        return max(loot(houses, 0, len - 1), loot(houses, 1, len));\\n    }\\n};\\n```\n```cpp\\n    int loot(vector<int>& houses, int start, int finish) {\\n        // support variable: all values juggled here!\\n        int dp[3];\\n        dp[start % 3] = houses[start];\\n        dp[++start % 3] = max(houses[start], houses[start + 1]);\\n        for (int i = ++start; i < finish; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], houses[i] + dp[(i - 2) % 3]);\\n        }\\n        return dp[(finish - 1)  % 3];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761965,
                "title": "c-fastest-solution-o-n-dp",
                "content": "``` \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        // there are 2 ways to rob \\n        int dp[nums.size()];\\n        \\n        // 1. rob the first house => u can\\'t rob the last one\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i=2 ; i<nums.size()-1 ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        int amt1 = dp[nums.size()-2];\\n        \\n        // 2. rob the second house till the last one\\n        dp[0] = 0;\\n        dp[1] = nums[1];\\n        for(int i=2 ; i<nums.size() ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        \\n        return max(amt1, dp[nums.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 0)\\n            return 0;\\n        if(nums.size() == 1)\\n            return nums[0];\\n        // there are 2 ways to rob \\n        int dp[nums.size()];\\n        \\n        // 1. rob the first house => u can\\'t rob the last one\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i=2 ; i<nums.size()-1 ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        int amt1 = dp[nums.size()-2];\\n        \\n        // 2. rob the second house till the last one\\n        dp[0] = 0;\\n        dp[1] = nums[1];\\n        for(int i=2 ; i<nums.size() ; i++)\\n            dp[i] = max( nums[i]+ dp[i-2], dp[i-1] );\\n        \\n        return max(amt1, dp[nums.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420934,
                "title": "easy-java-recursion-memoization-extending-from-house-robber-i",
                "content": "Let me take you step by step:\\nYou know thet For House Rober 1 the solution is easy. it\\'s Inclusion and Exclusion Recurssion.\\n\\n House Rober 1 : LC : 198 (link = https://leetcode.com/problems/house-robber/ )\\n````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int[] cache = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        return rob(nums,0,nums.length-1,cache);\\n        \\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n````\\n\\nNow for House Robber 2\\n\\n````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        if(nums==null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n       \\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache1,-1);\\n        \\n        int excludeFirstHouse = rob(nums,1,nums.length-1,cache1); // Now you can consider the last \\n        int includeFirstHouse = rob(nums,0,nums.length-2,cache2);  // Now u cannot consider the last \\n     \\n        return Math.max(excludeFirstHouse,includeFirstHouse);\\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n````\\n\\nThe rob(int[] nums) is same both solutions, But you call it twice from the driver for House Rober 2\\n\\nIf you liked the solution giev thumbsup.",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int[] cache = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        return rob(nums,0,nums.length-1,cache);\\n        \\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n```\n````\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        if(nums==null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n       \\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache,-1);\\n        \\n        int[] cache1 = new int[nums.length];\\n        Arrays.fill(cache1,-1);\\n        \\n        int excludeFirstHouse = rob(nums,1,nums.length-1,cache1); // Now you can consider the last \\n        int includeFirstHouse = rob(nums,0,nums.length-2,cache2);  // Now u cannot consider the last \\n     \\n        return Math.max(excludeFirstHouse,includeFirstHouse);\\n    }\\n    \\n     public int rob(int[] nums, int start , int end, int[] cache) {\\n     \\n         if(start>end) return 0;\\n\\n         if(cache[start]!=-1) return cache[start];\\n         \\n       \\n         int include = nums[start]+rob(nums,start+2,end,cache);\\n         int exclude = rob(nums,start+1,end,cache); \\n         cache[start] = Math.max(include,exclude);\\n         return cache[start];\\n         \\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621942,
                "title": "python-easy-solution-with-explanation-faster-than-95",
                "content": "# Dynamic programming with memoization\\nRuntime: 32 ms, faster than **94.51%**\\nMemory Usage: 13.8 MB, less than **70.92%**\\n\\nThen problem breaks down to the another leetcode problem, which I recommend doing first: [House robber](https://leetcode.com/problems/house-robber/). Here the problem is quite the same except houses are located in the circle, so we cannot take first and last house at the same time. We have two possible cases here:\\n1. We take first house and consider all houses except the last one\\n2. We take the last one and consider all houses except the first one\\n```\\nreturn max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\\n\\nBut we also have to take into consideration the situation when we have only one house, then we would take 0 houses in both cases, so we need if statement:\\n```\\nif len(nums) == 1:\\n            return nums[0]\\n```\\n\\nThe robInLine function is the solution for House robber problem, I explained it [here](https://leetcode.com/problems/house-robber/discuss/2621841/Python-EASY-dynamic-programming-with-explanation)\\n\\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        mem = [0] * (len(nums) + 2)\\n        for idx in range(len(nums)-1,-1,-1):\\n            mem[idx] = max(nums[idx] + mem[idx+2], mem[idx+1])\\n        return mem[0]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\\n\\n# Without memoization\\nRuntime: 49 ms, faster than **60.69%**\\nMemory Usage: 14 MB, less than **23.81%**\\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        r_neigh, r_r_neigh = 0, 0\\n        for idx in range(len(nums)-1,-1,-1):\\n            r_neigh, r_r_neigh = max(r_neigh, r_r_neigh + nums[idx]), r_neigh\\n        return r_neigh\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\\n\\nIf you liked the solution please upvote! c:",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nreturn max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\n```\\nif len(nums) == 1:\\n            return nums[0]\\n```\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        mem = [0] * (len(nums) + 2)\\n        for idx in range(len(nums)-1,-1,-1):\\n            mem[idx] = max(nums[idx] + mem[idx+2], mem[idx+1])\\n        return mem[0]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```\n```\\nclass Solution:\\n    def robInLine(self, nums):\\n        r_neigh, r_r_neigh = 0, 0\\n        for idx in range(len(nums)-1,-1,-1):\\n            r_neigh, r_r_neigh = max(r_neigh, r_r_neigh + nums[idx]), r_neigh\\n        return r_neigh\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        return max(self.robInLine(nums[1:]), self.robInLine(nums[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239869,
                "title": "c-dp-solution-recursive-memoization-tabulation",
                "content": "Recursion is the heart of dynamic programming. Without solving recursively and directly jumping to tabulation, I don\\'t think is the right approach. We understand the main concept by doing it recursively first, memoizing it and then converting it into tabulation form. In this solution I will follow all the steps mentioned.\\nThis question is a variation of knapsack.\\nWe have two options for each house:-\\n\\nEither take the money in it.\\nOr Leave it.\\n\\nIf we take the money, then we cannot take the money from the neighbouring house, but if we don\\'t take the money, money can be taken from the neighbouring house.\\n\\nIf we take the money from the first house, then we cannot take the money from the last house as the houses are arranged in circle. So we call functions for two cases, in which we consider houses from first to second last and other from second to last. \\n\\nWe have to find a way in which the maximum amount of money can be taken.\\n\\n**Recursion (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums){\\n        if(idx >= n) return 0;\\n        return max(nums[idx] + solve(idx+2,n,nums), solve(idx+1,n,nums));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        return max(solve(0,n-1,nums), solve(1,n,nums));\\n    }\\n};\\n```\\n\\n**Memoization (0ms, beats 100%)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums, vector<int>&dp){\\n        if(idx >= n) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(nums[idx] + solve(idx+2,n,nums,dp), solve(idx+1,n,nums,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int>dp1(n+1,-1);\\n        vector<int>dp2(n+1,-1);\\n        return max(solve(0,n-1,nums,dp1), solve(1,n,nums,dp2));\\n    }\\n};\\n```\\n\\n**Tabulation (0ms, beats 100%)**\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>dp(n+1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<n+1; i++){\\n            dp[i] = max(dp[i-1], nums[i-1] + dp[i-2]);\\n        }\\n        return dp[n];\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(solve(v1), solve(v2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums){\\n        if(idx >= n) return 0;\\n        return max(nums[idx] + solve(idx+2,n,nums), solve(idx+1,n,nums));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        return max(solve(0,n-1,nums), solve(1,n,nums));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int idx, int n, vector<int>&nums, vector<int>&dp){\\n        if(idx >= n) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(nums[idx] + solve(idx+2,n,nums,dp), solve(idx+1,n,nums,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int>dp1(n+1,-1);\\n        vector<int>dp2(n+1,-1);\\n        return max(solve(0,n-1,nums,dp1), solve(1,n,nums,dp2));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>dp(n+1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<n+1; i++){\\n            dp[i] = max(dp[i-1], nums[i-1] + dp[i-2]);\\n        }\\n        return dp[n];\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        vector<int> v1(nums.begin(), nums.end()-1);\\n        vector<int> v2(nums.begin()+1, nums.end());\\n        return max(solve(v1), solve(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427939,
                "title": "very-simple-dp-explanation-using-python",
                "content": "This post is meant to help those who is having hard time understanding. The code isn\\'t simplified by any mean, as the code is meant to be easy to read and understand.\\n\\nFrom House Robber I problem [https://leetcode.com/problems/house-robber/](http://), we can simply run House Robber problem twice, once without the first element, and second without the last element. Then, we take the max between the two answers. Below is the Python3 code.\\n\\nrobDP method is the code for House Robber I problem. The rob method simply runs it twice, then return the max of the two.\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:       \\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        numsExcludeLast = nums[:len(nums) - 1]\\n        numsExcludeFirst = nums[1:]\\n        \\n        excludeLastAns = self.robDP(numsExcludeLast)\\n        excludeFirstAns = self.robDP(numsExcludeFirst)\\n        \\n        return max(excludeLastAns, excludeFirstAns)\\n    \\n    def robDP(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(dp[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n            \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:       \\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        numsExcludeLast = nums[:len(nums) - 1]\\n        numsExcludeFirst = nums[1:]\\n        \\n        excludeLastAns = self.robDP(numsExcludeLast)\\n        excludeFirstAns = self.robDP(numsExcludeFirst)\\n        \\n        return max(excludeLastAns, excludeFirstAns)\\n    \\n    def robDP(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(dp[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n            \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59979,
                "title": "my-python-solution",
                "content": "    class Solution(object):\\n        def rob(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            if n == 0: return 0\\n            if n < 4: return max(nums)\\n    \\n            first, second = 0, 0\\n            for i in nums[:-1]: first, second = second, max(first + i, second)\\n            result = second\\n    \\n            first, second = 0, 0\\n            for i in nums[1:]: first, second = second, max(first + i, second)\\n            return max(result, second)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def rob(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            if n == 0: return 0\\n            if n < 4: return max(nums)\\n    \\n            first, second = 0, 0\\n            for i in nums[:-1]: first, second = second, max(first + i, second)\\n            result = second\\n    \\n            first, second = 0, 0\\n            for i in nums[1:]: first, second = second, max(first + i, second)\\n            return max(result, second)",
                "codeTag": "Java"
            },
            {
                "id": 3385990,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n       int n=v.size();\\n       if(n==1)return v[0];\\n       int dp1[n],dp2[n];\\n       dp1[0]=v[0];\\n       dp1[1]=max(v[0],v[1]);\\n       for(int i=2;i<n-1;i++)dp1[i]=max(dp1[i-1],v[i]+dp1[i-2]);\\n       dp2[0]=0;\\n       dp2[1]=v[1];\\n       for(int i=2;i<n;i++)dp2[i]=max(dp2[i-1],dp2[i-2]+v[i]);\\n       return max(dp1[n-2],dp2[n-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n       int n=v.size();\\n       if(n==1)return v[0];\\n       int dp1[n],dp2[n];\\n       dp1[0]=v[0];\\n       dp1[1]=max(v[0],v[1]);\\n       for(int i=2;i<n-1;i++)dp1[i]=max(dp1[i-1],v[i]+dp1[i-2]);\\n       dp2[0]=0;\\n       dp2[1]=v[1];\\n       for(int i=2;i<n;i++)dp2[i]=max(dp2[i-1],dp2[i-2]+v[i]);\\n       return max(dp1[n-2],dp2[n-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206593,
                "title": "easy-dp-js-solution",
                "content": "```\\nvar rob = function(nums) {\\n    if (nums.length <= 3) {\\n        return Math.max(...nums);\\n    }\\n    let money1 = robHelper(0, nums.length - 2, nums);\\n    let money2 = robHelper(1, nums.length - 1, nums);\\n    return Math.max(money1, money2);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/*\\ndp[i] is the max amount of money that can be robbed without alerting the police at house i\\n\\ndp[i] = max(dp[i-1], dp[i-2] + nums[i]) \\nbecause if we rob the previous house, we can\\'t rob the current house, but, else,\\nwe can rob the current house and still take the money robbed until the previous, previous house\\n*/\\nconst robHelper = (start, end, nums) => {\\n    let dp = new Array(start + (end - start + 1));\\n    for (let i = start; i <= end; i++) {\\n        dp[i] = Math.max((dp[i-1] ? dp[i-1] : 0), (dp[i-2] ? dp[i-2] : 0) + nums[i]);\\n    }\\n    return dp[end];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    if (nums.length <= 3) {\\n        return Math.max(...nums);\\n    }\\n    let money1 = robHelper(0, nums.length - 2, nums);\\n    let money2 = robHelper(1, nums.length - 1, nums);\\n    return Math.max(money1, money2);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/*\\ndp[i] is the max amount of money that can be robbed without alerting the police at house i\\n\\ndp[i] = max(dp[i-1], dp[i-2] + nums[i]) \\nbecause if we rob the previous house, we can\\'t rob the current house, but, else,\\nwe can rob the current house and still take the money robbed until the previous, previous house\\n*/\\nconst robHelper = (start, end, nums) => {\\n    let dp = new Array(start + (end - start + 1));\\n    for (let i = start; i <= end; i++) {\\n        dp[i] = Math.max((dp[i-1] ? dp[i-1] : 0), (dp[i-2] ? dp[i-2] : 0) + nums[i]);\\n    }\\n    return dp[end];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 894504,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The **ART** of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n\\n---\\n\\n**A**ll possibilities for each `i`<sup>th</sup> house:\\n\\n1. The optimal solution is to `\\u2705`  **take** the `i`<sup>th</sup> house\\n2. The optimal solution is to `\\uD83D\\uDEAB`  **skip** the `i`<sup>th</sup> house\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var take = go(i + 2, n) + A[i]\\n            var skip = go(i + 1, n)\\n            return Math.max(take, skip)\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var k = \"$i,$n\"\\n            if (!m.contains(k)) {\\n                var take = go(i + 2, n) + A[i]\\n                var skip = go(i + 1, n)\\n                m[k] = Math.max(take, skip)\\n            }\\n            return m[k]!!\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var dp = IntArray(N + 2) { 0 }\\n            for (i in end - 1 downTo start) {\\n                var take = dp[i + 2] + A[i]\\n                var skip = dp[i + 1]\\n                dp[i] = Math.max(take, skip)\\n            }\\n            return dp[start]\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var (a, b, c) = Triple(0, 0, 0)\\n            for (i in end - 1 downTo start) {\\n                var take = c + A[i]\\n                var skip = b\\n                a = Math.max(take, skip)\\n                c = b; b = a\\n            }\\n            return a\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let take = go(i + 2, n) + A[i],\\n            skip = go(i + 1, n);\\n        return Math.max(take, skip);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let k = `${i},${n}`;\\n        if (!m.has(k)) {\\n            let take = go(i + 2, n) + A[i],\\n                skip = go(i + 1, n);\\n            m.set(k, Math.max(take, skip));\\n        }\\n        return m.get(k);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let dp = Array(N + 2).fill(0);\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = dp[i + 2] + A[i],\\n                skip = dp[i + 1];\\n            dp[i] = Math.max(take, skip);\\n        }\\n        return dp[start];\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let [a, b, c] = [0, 0, 0];\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = c + A[i],\\n                skip = b;\\n            a = Math.max(take, skip);\\n            c = b, b = a;\\n        }\\n        return a;\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        @cache\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            dp = [0] * (N + 2)\\n            for i in range(end - 1, start - 1, -1):\\n                take = dp[i + 2] + A[i]\\n                skip = dp[i + 1]\\n                dp[i] = max(take, skip)\\n            return dp[start]\\n        return max(best(0, N - 1), best(1, N))\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            a, b, c = 0, 0, 0\\n            for i in range(end - 1, start - 1, -1):\\n                take = c + A[i]\\n                skip = b\\n                a = max(take, skip)\\n                c = b; b = a\\n            return a\\n        return max(best(0, N - 1), best(1, N))\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n\\t\\tif (N == 1)\\n\\t\\t    return A[0];\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto take = go(i + 2, n) + A[i],\\n                 skip = go(i + 1, n);\\n            return max(take, skip);\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto key = [](auto i, auto n) {\\n            stringstream ss; ss << i << \",\" << n;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto k = key(i, n);\\n            if (m.find(k) == m.end()) {\\n                auto take = go(i + 2, n) + A[i],\\n                     skip = go(i + 1, n);\\n                m[k] = max(take, skip);\\n            }\\n            return m[k];\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            VI dp(N + 2);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = dp[i + 2] + A[i],\\n                     skip = dp[i + 1];\\n                dp[i] = max(take, skip);\\n            }\\n            return dp[start];\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```\\n\\n4. bottom-up memory optimization, ie. a, b, c == dp[i], dp[i + 1], dp[i + 2]\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            auto [a, b, c] = make_tuple(0, 0, 0);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = c + A[i],\\n                     skip = b;\\n                a = max(take, skip);\\n                c = b, b = a;\\n            }\\n            return a;\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var take = go(i + 2, n) + A[i]\\n            var skip = go(i + 1, n)\\n            return Math.max(take, skip)\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int, n: Int): Int {\\n            if (n <= i)\\n                return 0\\n            var k = \"$i,$n\"\\n            if (!m.contains(k)) {\\n                var take = go(i + 2, n) + A[i]\\n                var skip = go(i + 1, n)\\n                m[k] = Math.max(take, skip)\\n            }\\n            return m[k]!!\\n        }\\n        return Math.max(go(0, N - 1), go(1, N))\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var dp = IntArray(N + 2) { 0 }\\n            for (i in end - 1 downTo start) {\\n                var take = dp[i + 2] + A[i]\\n                var skip = dp[i + 1]\\n                dp[i] = Math.max(take, skip)\\n            }\\n            return dp[start]\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        if (N == 1)\\n            return A[0]\\n        fun best(start: Int, end: Int): Int {\\n            var (a, b, c) = Triple(0, 0, 0)\\n            for (i in end - 1 downTo start) {\\n                var take = c + A[i]\\n                var skip = b\\n                a = Math.max(take, skip)\\n                c = b; b = a\\n            }\\n            return a\\n        }\\n        return Math.max(best(0, N - 1), best(1, N))\\n    }\\n}\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let take = go(i + 2, n) + A[i],\\n            skip = go(i + 1, n);\\n        return Math.max(take, skip);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let go = (i, n) => {\\n        if (n <= i)\\n            return 0;\\n        let k = `${i},${n}`;\\n        if (!m.has(k)) {\\n            let take = go(i + 2, n) + A[i],\\n                skip = go(i + 1, n);\\n            m.set(k, Math.max(take, skip));\\n        }\\n        return m.get(k);\\n    };\\n    return Math.max(go(0, N - 1), go(1, N));\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let dp = Array(N + 2).fill(0);\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = dp[i + 2] + A[i],\\n                skip = dp[i + 1];\\n            dp[i] = Math.max(take, skip);\\n        }\\n        return dp[start];\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    if (N == 1)\\n        return A[0];\\n    let best = (start, end) => {\\n        let [a, b, c] = [0, 0, 0];\\n        for (let i = end - 1; start <= i; --i) {\\n            let take = c + A[i],\\n                skip = b;\\n            a = Math.max(take, skip);\\n            c = b, b = a;\\n        }\\n        return a;\\n    };\\n    return Math.max(best(0, N - 1), best(1, N));\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        @cache\\n        def go(i, n):\\n            if n <= i:\\n                return 0\\n            take = go(i + 2, n) + A[i]\\n            skip = go(i + 1, n)\\n            return max(take, skip)\\n        return max(go(0, N - 1), go(1, N))\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            dp = [0] * (N + 2)\\n            for i in range(end - 1, start - 1, -1):\\n                take = dp[i + 2] + A[i]\\n                skip = dp[i + 1]\\n                dp[i] = max(take, skip)\\n            return dp[start]\\n        return max(best(0, N - 1), best(1, N))\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N == 1:\\n            return A[0]\\n        def best(start, end):\\n            a, b, c = 0, 0, 0\\n            for i in range(end - 1, start - 1, -1):\\n                take = c + A[i]\\n                skip = b\\n                a = max(take, skip)\\n                c = b; b = a\\n            return a\\n        return max(best(0, N - 1), best(1, N))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n\\t\\tif (N == 1)\\n\\t\\t    return A[0];\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto take = go(i + 2, n) + A[i],\\n                 skip = go(i + 1, n);\\n            return max(take, skip);\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto key = [](auto i, auto n) {\\n            stringstream ss; ss << i << \",\" << n;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto n) {\\n            if (n <= i)\\n                return 0;\\n            auto k = key(i, n);\\n            if (m.find(k) == m.end()) {\\n                auto take = go(i + 2, n) + A[i],\\n                     skip = go(i + 1, n);\\n                m[k] = max(take, skip);\\n            }\\n            return m[k];\\n        };\\n        return max(go(0, N - 1), go(1, N));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            VI dp(N + 2);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = dp[i + 2] + A[i],\\n                     skip = dp[i + 1];\\n                dp[i] = max(take, skip);\\n            }\\n            return dp[start];\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        if (N == 1)\\n            return A[0];\\n        auto best = [&](auto start, auto end) {\\n            auto [a, b, c] = make_tuple(0, 0, 0);\\n            for (auto i{ end - 1 }; start <= i; --i) {\\n                auto take = c + A[i],\\n                     skip = b;\\n                a = max(take, skip);\\n                c = b, b = a;\\n            }\\n            return a;\\n        };\\n        return max(best(0, N - 1), best(1, N));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134907,
                "title": "logical-thinking-with-clear-code",
                "content": "**Logical Thinking**\\n**state definition**\\n`circularState(i, j)` as maximum amount of money I can rob from house i to house j if arranged in a circle.\\n`oneWayState(i, j)` as maximum amount of money I can rob from house i to house j if not arranged in a circle.\\n**goal state**\\t\\n`circularState(0, nums.length - 1)`\\n**state resolution**\\t\\nCurrently I rob from house i to house j, I can decide whether to rob house i or not. \\nIf I rob house i, `circularState(i, j) = oneWayState(i, j - 1)`.\\nIf I abort house i, `circularState(i, j) = oneWayState(i + 1, j)`\\n**goal state**\\t\\n`circularState(0, nums.length - 1) = max(oneWayState(0, nums.lenght - 2), oneWayState(1, nums.length - 1))`\\n\\nIn 198. House Robber, we have solved `oneWayState()`. [https://leetcode.com/problems/house-robber/discuss/156910/Code-Beats-100-with-Explanation-and-Optimization]\\n\\nPlease note that **nums[1..nums.length - 2]** will be calculated twice in `Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1))`, so we apply **Memorization** technique.\\n\\n**Clear Code**\\n```\\n    int[][] memo;\\n    \\n    public int rob(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return 0;\\n        }\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        \\n        memo = new int[nums.length][nums.length];\\n        for (int[] tmp : memo)\\n            Arrays.fill(tmp, -1);\\n        \\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }\\n    \\n    \\n    \\n    public int rob(int[] nums, int start, int end) {\\n\\n        if (memo[start][end] != -1) {\\n            return memo[start][end];\\n        }\\n        \\n        if (nums == null || end < start) {\\n            return 0;\\n        }\\n\\n        int n = nums.length;\\n        int rob = nums[start];\\n        int abort = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int preAbort = abort;\\n            abort = Math.max(abort, rob);\\n            rob = preAbort + nums[i];\\n        }\\n\\n        memo[start][end] = Math.max(abort, rob);\\n        return memo[start][end];\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    int[][] memo;\\n    \\n    public int rob(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return 0;\\n        }\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        \\n        memo = new int[nums.length][nums.length];\\n        for (int[] tmp : memo)\\n            Arrays.fill(tmp, -1);\\n        \\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\\n    }\\n    \\n    \\n    \\n    public int rob(int[] nums, int start, int end) {\\n\\n        if (memo[start][end] != -1) {\\n            return memo[start][end];\\n        }\\n        \\n        if (nums == null || end < start) {\\n            return 0;\\n        }\\n\\n        int n = nums.length;\\n        int rob = nums[start];\\n        int abort = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int preAbort = abort;\\n            abort = Math.max(abort, rob);\\n            rob = preAbort + nums[i];\\n        }\\n\\n        memo[start][end] = Math.max(abort, rob);\\n        return memo[start][end];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60061,
                "title": "an-easy-understanding-solution-in-c",
                "content": "This problem is an advanced version of Problem \"House Robber\", the only difference is that the houses are arranged in a circle, which means the first house is adjacent to the last house.\\n\\nFrom a global view, any rob solution has two possible cases: rob the first house, or not.\\n\\nIf we rob the first house, we can't rob the last house, so the problem transfer to \"how to rob in house[1, n-1]\". If we do not rob the first house, the problem transfer to \"how to rob in house[2, n]\".\\n\\nAssuming that we have understand the solution for problem \"House Robber\", now we can simply design the new strategy as below:\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int> &nums) {\\n            if (nums.size() == 0) {\\n                return 0;\\n            }\\n            if (nums.size() == 1) {\\n                return nums.at(0);\\n            }\\n            vector<int> case1(nums);\\n            vector<int> case2(nums);\\n        \\n            vector<int>::iterator v1 = case1.begin();\\n            case1.erase(v1);\\n            case2.pop_back();\\n        \\n            int maxRobValue1 = simpleRob(case1);\\n            int maxRobValue2 = simpleRob(case2);\\n            int maxRobValue = max(maxRobValue1, maxRobValue2);\\n            return maxRobValue;\\n        }\\n        int simpleRob(vector<int> &num){\\n            int *f = new int[num.size() + 1];\\n            f[0] = 0;\\n            for (int i = 1; i <= num.size(); i++) {\\n                if (i == 1) {\\n                    f[i] = num.at(i-1);\\n                }\\n                else {\\n                    f[i] = max(f[i-2] + num.at(i-1), f[i-1]);\\n                }\\n            }\\n            int robMaxValue = f[num.size()];\\n            return robMaxValue;\\n        }    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int> &nums) {\\n            if (nums.size() == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609143,
                "title": "c-0ms-100-faster-o-n-explaination-memoized-recursion",
                "content": "\\n\\n```\\n\\n\\nclass Solution {\\n    int l;\\n    int dp[103];\\n    \\n    int recurse(int index,vector<int>& a)\\n    {\\n        if(index>=l )\\n            return 0;\\n      \\n        if(dp[index]>-1)\\n            return dp[index];\\n        \\n\\t\\t// donothing means robber is not choosing to rob this house for whatever reason( even if he can)\\n\\t\\t// and chooses to move forward \\n        int donothing= recurse(index+1,a);\\n\\t\\t\\n\\t\\t// dosomething means he will rob this house and move to the 2nd next house from this one\\n        int dosomething= a[index]+recurse(index+2, a);\\n        return dp[index]=max(donothing, dosomething);\\n    }\\n    \\n    \\npublic:\\n    int rob(vector<int>& a) {\\n       if(a.size()==1)\\n           return a[0];\\n        // since circular, \\n        //trying from index 0 to l-2;\\n        memset(dp,-1,sizeof(dp));\\n        l= a.size()-1;\\n        int maxvalue=0;\\n        maxvalue= max(maxvalue, recurse(0,a));\\n        \\n\\t\\t// we have the max answer if we choose to rob from house 0 to l-2\\n\\t\\t// now will check the max answer from house 1 to l-1\\n\\t\\t\\n        // trying from index 0 to l-1\\n        memset(dp,-1, sizeof(dp));\\n        l=a.size();\\n        maxvalue= max(maxvalue, recurse(1,a));\\n        return maxvalue;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n\\nUpvote if you like the solution, and if you have any doubt, post it in the comments.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    int l;\\n    int dp[103];\\n    \\n    int recurse(int index,vector<int>& a)\\n    {\\n        if(index>=l )\\n            return 0;\\n      \\n        if(dp[index]>-1)\\n            return dp[index];\\n        \\n\\t\\t// donothing means robber is not choosing to rob this house for whatever reason( even if he can)\\n\\t\\t// and chooses to move forward \\n        int donothing= recurse(index+1,a);\\n\\t\\t\\n\\t\\t// dosomething means he will rob this house and move to the 2nd next house from this one\\n        int dosomething= a[index]+recurse(index+2, a);\\n        return dp[index]=max(donothing, dosomething);\\n    }\\n    \\n    \\npublic:\\n    int rob(vector<int>& a) {\\n       if(a.size()==1)\\n           return a[0];\\n        // since circular, \\n        //trying from index 0 to l-2;\\n        memset(dp,-1,sizeof(dp));\\n        l= a.size()-1;\\n        int maxvalue=0;\\n        maxvalue= max(maxvalue, recurse(0,a));\\n        \\n\\t\\t// we have the max answer if we choose to rob from house 0 to l-2\\n\\t\\t// now will check the max answer from house 1 to l-1\\n\\t\\t\\n        // trying from index 0 to l-1\\n        memset(dp,-1, sizeof(dp));\\n        l=a.size();\\n        maxvalue= max(maxvalue, recurse(1,a));\\n        return maxvalue;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n\\nUpvote if you like the solution, and if you have any doubt, post it in the comments.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372853,
                "title": "easy-clear-python-3-solution-recursive-memo-top-down",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        a=dp(len(nums)-2)\\n        memo=[-1 for _ in range(len(nums))]\\n        nums.pop(0)\\n        b=dp(len(nums)-1)\\n        return max(a,b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        a=dp(len(nums)-2)\\n        memo=[-1 for _ in range(len(nums))]\\n        nums.pop(0)\\n        b=dp(len(nums)-1)\\n        return max(a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300086,
                "title": "o-n-approach-time-complexity",
                "content": "\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n    #time complexity---->O(N)\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n    #time complexity---->O(N)\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224581,
                "title": "213-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the class Solution, which contains the rob() method that takes a list of integers as input and returns an integer.\\n2. Check the edge case where the input list is empty. If this is true, return 0 because there is nothing to rob.\\n3. Check the edge case where the input list has only one element. If this is true, return that element because it is the only one that can be robbed without alerting the police.\\n4. Define a nested function rob(l: int, r: int) -> int that takes two integers l and r as input and returns an integer.\\n5. Initialize two variables dp1 and dp2 to 0. These will hold the dynamic programming values for the current and previous houses, respectively.\\n6. Loop through the range of indices from l to r inclusive.\\n7. Store the current value of dp1 in a temporary variable temp.\\n8. Update dp1 to be the maximum of dp1 and dp2 plus the value of the current house.\\n9. Update dp2 to be the previous value of dp1 (i.e., temp).\\n10. Return dp1, which holds the maximum amount of money that can be robbed without alerting the police.\\n11. In the main rob() function, call rob(0, len(nums) - 2) to calculate the maximum amount that can be robbed without robbing the last house (because it is adjacent to the first house in a circular arrangement).\\n12. Also call rob(1, len(nums) - 1) to calculate the maximum amount that can be robbed without robbing the first house.\\n13. Return the maximum of these two values, which represents the maximum amount that can be robbed without alerting the police in the circular arrangement of houses.\\n# Complexity\\n- Time complexity:\\nBeats\\n65.76%\\n\\n- Space complexity:\\nBeats\\n97.69%\\n\\n# Code\\n```\\nclass Solution:\\n  def rob(self, nums: List[int]) -> int:\\n    if not nums:\\n      return 0\\n    if len(nums) < 2:\\n      return nums[0]\\n\\n    def rob(l: int, r: int) -> int:\\n      dp1 = 0\\n      dp2 = 0\\n\\n      for i in range(l, r + 1):\\n        temp = dp1\\n        dp1 = max(dp1, dp2 + nums[i])\\n        dp2 = temp\\n\\n      return dp1\\n\\n    return max(rob(0, len(nums) - 2),\\n               rob(1, len(nums) - 1))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def rob(self, nums: List[int]) -> int:\\n    if not nums:\\n      return 0\\n    if len(nums) < 2:\\n      return nums[0]\\n\\n    def rob(l: int, r: int) -> int:\\n      dp1 = 0\\n      dp2 = 0\\n\\n      for i in range(l, r + 1):\\n        temp = dp1\\n        dp1 = max(dp1, dp2 + nums[i])\\n        dp2 = temp\\n\\n      return dp1\\n\\n    return max(rob(0, len(nums) - 2),\\n               rob(1, len(nums) - 1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057696,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int robber(vector<int> nums)\\n    {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0]=max(nums[0],0);\\n        dp[1]=max({0,nums[0], nums[1]});\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            dp[i]=max(dp[i-1], nums[i]+dp[i-2]);\\n        }\\n        return max(dp[nums.size()-1],0);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n        return 0;\\n        else if(n==1)\\n        return max(nums[0],0);\\n        else if(n==2)\\n        return max({0,nums[0], nums[1]});\\n        \\n        vector<int> v1(nums.begin()+1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end()-1);\\n        return max(robber(v1), robber(v2));\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int robber(vector<int> nums)\\n    {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0]=max(nums[0],0);\\n        dp[1]=max({0,nums[0], nums[1]});\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            dp[i]=max(dp[i-1], nums[i]+dp[i-2]);\\n        }\\n        return max(dp[nums.size()-1],0);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n        return 0;\\n        else if(n==1)\\n        return max(nums[0],0);\\n        else if(n==2)\\n        return max({0,nums[0], nums[1]});\\n        \\n        vector<int> v1(nums.begin()+1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end()-1);\\n        return max(robber(v1), robber(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023016,
                "title": "c-dp-easy-new-and-100-fast-approach",
                "content": "\\n# Approach\\nCalling recursion function (using dp) to compute the maximum money possible. This function is called 2 times. \\n- First when considering 1st house to be looted then last house can\\'t to looted due to circular arrangement. \\n- Second when considering last house to be looted then leaving the 1st house.\\n\\nOur answer will be maximum of both the returning value.\\n\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    int dfs(int i, int n, vector<int>& nums, vector<int> &dp){\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int money = nums[i] + dfs(i+2, n, nums, dp);\\n        money = max(money, dfs(i+1, n, nums, dp));\\n\\n        dp[i] = money;\\n        return money;\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<int> dp(n, -1);\\n        int cost1 = nums[0] + dfs(2, n-1, nums, dp);\\n\\n        dp = vector<int>(n, -1);\\n        int cost2 = dfs(1, n, nums, dp);\\n\\n        return max(cost1, cost2);\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    int dfs(int i, int n, vector<int>& nums, vector<int> &dp){\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int money = nums[i] + dfs(i+2, n, nums, dp);\\n        money = max(money, dfs(i+1, n, nums, dp));\\n\\n        dp[i] = money;\\n        return money;\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<int> dp(n, -1);\\n        int cost1 = nums[0] + dfs(2, n-1, nums, dp);\\n\\n        dp = vector<int>(n, -1);\\n        int cost2 = dfs(1, n, nums, dp);\\n\\n        return max(cost1, cost2);\\n    }\\n};\\n```\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912310,
                "title": "java-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        int s1 = robRange(nums, 0, n - 2);\\n        int s2 = robRange(nums, 1, n - 1);\\n        return Math.max(s1, s2);\\n    }\\n\\n    private int robRange(int[] nums, int l, int r) {\\n        int a = 0, b = nums[l];\\n        for (int i = l + 1; i <= r; ++i) {\\n            int c = Math.max(nums[i] + a, b);\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        int s1 = robRange(nums, 0, n - 2);\\n        int s2 = robRange(nums, 1, n - 1);\\n        return Math.max(s1, s2);\\n    }\\n\\n    private int robRange(int[] nums, int l, int r) {\\n        int a = 0, b = nums[l];\\n        for (int i = l + 1; i <= r; ++i) {\\n            int c = Math.max(nums[i] + a, b);\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807371,
                "title": "house-robber-2-solution-follow-up-house-robber-1-recursion",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n==1)return nums[0];\\n        int arr1[] = new int[n-1];\\n        int arr2[] = new int[n-1];\\n        for(int i=0; i<n-1; i++){\\n            arr1[i] = nums[i];    //include first element and not include last element\\n            arr2[i] = nums[i+1];  //not include first element and include last element\\n        }\\n        int x = arr1.length-1;\\n        //1.Recursion\\n        // return Math.max(help(arr1,x), help(arr2,x));\\n        \\n        //2.Memoization - Top-Down DP\\n        // int dp[] = new int[x+1];\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans1 = Memo(x,arr1,dp);\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans2 = Memo(x,arr2,dp);\\n        // return Math.max(ans1,ans2);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return Math.max(DP(arr1), DP(arr2));\\n    }\\n    public int help(int[] nums,int index){\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        \\n        int include = nums[index] + help(nums,index-2);\\n        int notInclude = help(nums,index-1);\\n        \\n        return Math.max(include,notInclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums){\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n==1)return nums[0];\\n        int arr1[] = new int[n-1];\\n        int arr2[] = new int[n-1];\\n        for(int i=0; i<n-1; i++){\\n            arr1[i] = nums[i];    //include first element and not include last element\\n            arr2[i] = nums[i+1];  //not include first element and include last element\\n        }\\n        int x = arr1.length-1;\\n        //1.Recursion\\n        // return Math.max(help(arr1,x), help(arr2,x));\\n        \\n        //2.Memoization - Top-Down DP\\n        // int dp[] = new int[x+1];\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans1 = Memo(x,arr1,dp);\\n        // for(int i=0; i<x+1; i++)\\n        //     dp[i]=-1;\\n        // int ans2 = Memo(x,arr2,dp);\\n        // return Math.max(ans1,ans2);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return Math.max(DP(arr1), DP(arr2));\\n    }\\n    public int help(int[] nums,int index){\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        \\n        int include = nums[index] + help(nums,index-2);\\n        int notInclude = help(nums,index-1);\\n        \\n        return Math.max(include,notInclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums){\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177085,
                "title": "python-dp-beats-99-very-clearly-explained",
                "content": "***Problem***\\nThis problem is a follow up question for the [House Robber](https://leetcode.com/problems/house-robber/) which I already written a clearly explained 95% solution on [here.](https://leetcode.com/problems/house-robber/discuss/2172617/python-dp-and-dfs-95-solution-very-clearly-explained) I highly recommend you checking that solution first before checking this one so that you can understand this solution better, but it\\'s not required.\\n\\nFirst, we should first identify the difference(s) between the House Robber and House Robber II. The main difference is that in the House Robber question the array is in a straight line while in this question the houses will be circular. \\n>Hint: Think about what impact houses ordered circularly will make on the original question where houses are ordered on a straight line.\\n\\nBefore we proceed, I have renamed the input `nums` to `houses` for clarity sake as I will be using the variable `nums` as input of a function in the code.\\n\\n**Intuition**\\nWe notices 3 main differences between a linear and a circular arrangement:\\n* `houses[-1]` is directly adjacent to `houses[0]` as it is arranged in a circle unlike the original House Robber question.\\n* We can travel starting from `houses[0]` both left and right in a circle. What this means is that you can go right like the original linear House Robber question, meaning you go from `houses[0]` to `houses[1]` to `houses[2]` all the way to `houses[-2]`, or you can go from `houses[0]` to `houses[-1]` to `houses[-2]` until we reach `houses[2]`. Notice how we stopped on `houses[-2]` and `houses[2]` respectively, the reason is because of the first condition that `houses[-1]` is adjacent to `houses[0]`, thus we need to remove `houses[1]` if we are going left and `houses[-1]` if we decide to go right. Ultimately, the maximum output we get from left and right will be our final output, or `max(left, right)`.\\n* There is one more edge case we need to cover. Due to the first difference that `houses[0]` is adjacent to `houses[-1]`, an array with length of 3, or `len(houses) == 3`, can only rob one house. Thus, if that is the case we must rob the 1 house with the most money, or `max(houses)`.\\n\\nThus, our code can be almost the exact same as the code I wrote for the original [House Robber](https://leetcode.com/problems/house-robber/discuss/2172617/python-dp-and-dfs-95-solution-very-clearly-explainedhttp://) problem, but addressing the 3 main differences above.\\n\\n**Algorithm**\\nOur algorithm will be very similar for the original House Robber problem. We first need to address the new edge case of `len(houses) == 3`, which we can do by simply returning the max of houses, or `return max(houses)`. Then, we need to address the other 2 differences, notice that going left and right while removing `houses[1]` and `houses[-1]` respective are simply `max(left, right)`, or `max(houses[1:], houses[:-1])`.\\n\\nBut we need to find out what `left` and `right` will actually be before we find the max of the two. So, we need to start a function which I will name `find()`, and the parameter will be `nums`, which will be a linear array instead of a circle one. Does the code inside the function look familiar? Yes - that is the exact code for the original House Robber question that I copied into this function, you can check my solution for the original question for explanation of that.\\n\\nThus, `return max(find(houses[1:]), find(houses[:-1]))` will be our correct output.\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def rob(self, houses: List[int]) -> int:\\n        if len(houses) == 1:\\n            return houses[0]\\n        if len(houses) == 2 or len(houses) == 3:\\n            return max(houses)\\n        \\n        def find(nums):\\n            n = len(nums)\\n        \\n            dp = [0] * n\\n            dp[0], dp[1], dp[2] = nums[0], nums[1], nums[2] + nums[0]\\n        \\n            for i in range(3, n):\\n                dp[i] = max(dp[i-2], dp[i-3]) + nums[i]\\n        \\n       \\n            return max(dp[-1], dp[-2])\\n    \\n        return max(find(houses[1:]), find(houses[:-1]))\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n**Please consider upvoting if this solution helped you. Good luck!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, houses: List[int]) -> int:\\n        if len(houses) == 1:\\n            return houses[0]\\n        if len(houses) == 2 or len(houses) == 3:\\n            return max(houses)\\n        \\n        def find(nums):\\n            n = len(nums)\\n        \\n            dp = [0] * n\\n            dp[0], dp[1], dp[2] = nums[0], nums[1], nums[2] + nums[0]\\n        \\n            for i in range(3, n):\\n                dp[i] = max(dp[i-2], dp[i-3]) + nums[i]\\n        \\n       \\n            return max(dp[-1], dp[-2])\\n    \\n        return max(find(houses[1:]), find(houses[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855234,
                "title": "java-dynamic-programming-memoization-recursion",
                "content": "1. I have here used start variable for validating it is starting with 0-index or 1-index\\n2. we should use 2 recursion\\'s with dp because we can have edge in this problem\\n```\\nclass Solution {\\n    public int rec(int i,int start,int arr[],int dp[]){\\n        if(i>=arr.length)\\n            return 0;\\n        if(i==arr.length-1&&start==0)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=Math.max(rec(i+1,start,arr,dp),arr[i]+rec(i+2,start,arr,dp));\\n    }\\n    public int rob(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        int result=rec(0,0,nums,dp);\\n        Arrays.fill(dp,-1);\\n        result=Math.max(result,rec(1,1,nums,dp));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rec(int i,int start,int arr[],int dp[]){\\n        if(i>=arr.length)\\n            return 0;\\n        if(i==arr.length-1&&start==0)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=Math.max(rec(i+1,start,arr,dp),arr[i]+rec(i+2,start,arr,dp));\\n    }\\n    public int rob(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        int result=rec(0,0,nums,dp);\\n        Arrays.fill(dp,-1);\\n        result=Math.max(result,rec(1,1,nums,dp));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700049,
                "title": "java-faster-than-100-00",
                "content": "### **JAVA**\\n\\n```\\nclass Solution {\\n\\tpublic static int rob(int[] nums, int s, int e) {\\n\\t\\tint n1 = 0;\\n\\t\\tint n2 = 0;\\n\\t\\tif (e > s)\\n\\t\\t\\tn1 = nums[e - 1];\\n\\t\\tif (e > s + 1)\\n\\t\\t\\tn2 = Math.max(nums[e - 2], n1);\\n\\n\\t\\tfor (int i = e - 3; i >= s; i--) { \\n\\t\\t\\tint ans = Math.max(n2, nums[i] + n1); \\n\\t\\t\\tn1 = n2;\\n\\t\\t\\tn2 = ans;\\n\\t\\t}\\n\\t\\treturn n2;\\n\\t}\\n\\n\\tpublic static int rob(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn nums[0];\\n\\t\\tif (n == 2)\\n\\t\\t\\treturn Math.max(nums[1], nums[0]);\\n\\t\\treturn Math.max(rob(nums, 0, n - 1), rob(nums, 1, n));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int rob(int[] nums, int s, int e) {\\n\\t\\tint n1 = 0;\\n\\t\\tint n2 = 0;\\n\\t\\tif (e > s)\\n\\t\\t\\tn1 = nums[e - 1];\\n\\t\\tif (e > s + 1)\\n\\t\\t\\tn2 = Math.max(nums[e - 2], n1);\\n\\n\\t\\tfor (int i = e - 3; i >= s; i--) { \\n\\t\\t\\tint ans = Math.max(n2, nums[i] + n1); \\n\\t\\t\\tn1 = n2;\\n\\t\\t\\tn2 = ans;\\n\\t\\t}\\n\\t\\treturn n2;\\n\\t}\\n\\n\\tpublic static int rob(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn nums[0];\\n\\t\\tif (n == 2)\\n\\t\\t\\treturn Math.max(nums[1], nums[0]);\\n\\t\\treturn Math.max(rob(nums, 0, n - 1), rob(nums, 1, n));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530791,
                "title": "c-faster-than-100-approach-explained",
                "content": "```\\n  /*\\n    This problem is exactly the House Robber problem with a variation that here there can be two possibilites-\\n    1) Rob first house and skip last house\\n\\t2) Rob last house and skip the first house  \\n\\tOur required answer will be the max of these two possibilites. So we use dp two times-  from 0 to n-2(considering first element\\n\\tand leaving out the last) and from 1 to n-1(considering last element and leaving out the first)\\n    For any house n, Recursive relation- maxmoney[n]=max(maxmoney[n-1],maxmoney[n-2]+money[n-1])\\n */\\nclass Solution {\\n\\npublic:\\n    vector<int> dpstart; //house 0 to n-2 \\n    vector<int> dpend; //house 1 to n-1\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        dpstart.resize(n+1,0);\\n        dpend.resize(n+1,0); \\n        dpstart[0]=0;\\n        dpstart[1]=nums[0];\\n        dpend[1]=0;\\n        dpend[2]=nums[1]; \\n        for(int i=2;i<n;i++){\\n            dpstart[i]=max(dpstart[i-1],dpstart[i-2]+nums[i-1]);\\n        }\\n        for(int i=3;i<=n;i++){\\n            dpend[i]=max(dpend[i-1],dpend[i-2]+nums[i-1]);\\n        }\\n        return max(dpstart[n-1],dpend[n]);\\n    }\\n};\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  /*\\n    This problem is exactly the House Robber problem with a variation that here there can be two possibilites-\\n    1) Rob first house and skip last house\\n\\t2) Rob last house and skip the first house  \\n\\tOur required answer will be the max of these two possibilites. So we use dp two times-  from 0 to n-2(considering first element\\n\\tand leaving out the last) and from 1 to n-1(considering last element and leaving out the first)\\n    For any house n, Recursive relation- maxmoney[n]=max(maxmoney[n-1],maxmoney[n-2]+money[n-1])\\n */\\nclass Solution {\\n\\npublic:\\n    vector<int> dpstart; //house 0 to n-2 \\n    vector<int> dpend; //house 1 to n-1\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        dpstart.resize(n+1,0);\\n        dpend.resize(n+1,0); \\n        dpstart[0]=0;\\n        dpstart[1]=nums[0];\\n        dpend[1]=0;\\n        dpend[2]=nums[1]; \\n        for(int i=2;i<n;i++){\\n            dpstart[i]=max(dpstart[i-1],dpstart[i-2]+nums[i-1]);\\n        }\\n        for(int i=3;i<=n;i++){\\n            dpend[i]=max(dpend[i-1],dpend[i-2]+nums[i-1]);\\n        }\\n        return max(dpstart[n-1],dpend[n]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234674,
                "title": "javascript-dp-time-o-n-space-o-1",
                "content": "```\\nvar rob = function(nums) {\\n    if(nums.length === 1) return nums[0];\\n    if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n    //case 1, don\\'t consider the last house;\\n    var secondLast = nums[0];\\n    var last = Math.max(nums[0], nums[1]);\\n    var result1 = last;\\n    for(var i = 2; i < nums.length - 1; i++) {\\n        result1 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result1;\\n    }\\n    //case 2, don\\'t consider the first house;\\n    secondLast = nums[1];\\n    last = Math.max(nums[1], nums[2]);\\n    var result2 = last;\\n    for(var i = 3; i < nums.length; i++) {\\n        result2 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result2;\\n    }\\n    return Math.max(result1, result2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    if(nums.length === 1) return nums[0];\\n    if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n    //case 1, don\\'t consider the last house;\\n    var secondLast = nums[0];\\n    var last = Math.max(nums[0], nums[1]);\\n    var result1 = last;\\n    for(var i = 2; i < nums.length - 1; i++) {\\n        result1 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result1;\\n    }\\n    //case 2, don\\'t consider the first house;\\n    secondLast = nums[1];\\n    last = Math.max(nums[1], nums[2]);\\n    var result2 = last;\\n    for(var i = 3; i < nums.length; i++) {\\n        result2 = Math.max(last, secondLast + nums[i]);\\n        secondLast = last;\\n        last = result2;\\n    }\\n    return Math.max(result1, result2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209265,
                "title": "clean-dp-java-solution-with-explanation-3ms-beat-98-71",
                "content": "- **dp1**: largest sum when *remove* the **last** house (nums[0] to nums[nums.length-2])\\n- **dp2**: largest sum when *remove* the **first** house (nums[1] to nums[nums.length-1])\\n- **return** the **larger** sum (Math.max(dp1[dp1.length-1]. dp2[dp2.length-1]))\\n- **edge cases**\\n\\t- *empty*  -> 0\\n\\t- only has *one* house -> nums[0]\\n\\t- only has *two* houses -> Math.max(nums[0], nums[1])\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        int[] dp1 = new int[nums.length-1];\\n        int[] dp2 = new int[nums.length-1];\\n        \\n        dp1[0] = nums[0];\\n        dp2[0] = nums[1];\\n        dp1[1] = Math.max(nums[1], dp1[0]);\\n        dp2[1] = Math.max(nums[2], dp2[0]);\\n        \\n        for(int i = 2; i < nums.length-1; i++) {\\n            dp1[i] = Math.max(dp1[i-2]+nums[i], dp1[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i+1], dp2[i-1]);\\n        }\\n        return Math.max(dp1[dp1.length-1], dp2[dp2.length-1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        int[] dp1 = new int[nums.length-1];\\n        int[] dp2 = new int[nums.length-1];\\n        \\n        dp1[0] = nums[0];\\n        dp2[0] = nums[1];\\n        dp1[1] = Math.max(nums[1], dp1[0]);\\n        dp2[1] = Math.max(nums[2], dp2[0]);\\n        \\n        for(int i = 2; i < nums.length-1; i++) {\\n            dp1[i] = Math.max(dp1[i-2]+nums[i], dp1[i-1]);\\n            dp2[i] = Math.max(dp2[i-2]+nums[i+1], dp2[i-1]);\\n        }\\n        return Math.max(dp1[dp1.length-1], dp2[dp2.length-1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60048,
                "title": "my-15-line-c-code-0ms-runtime-for-test-data",
                "content": "       /************************************\\n       **  author : s2003zy\\n       **  blog :  s2003zy.com\\n       ** weibo:  weibo.com/songzy982\\n       ****************************************/ \\n       class Solution {\\n        public:\\n            int res(vector<int>& nums, int left, int right) {\\n                int last = 0, lastlast = 0;\\n                for (int i = left; i < right; i++) {\\n                    lastlast = max(last, lastlast + nums[i]);\\n                    swap(last, lastlast);\\n                }\\n                return last;\\n            }\\n            int rob(vector<int>& nums) {\\n                if (nums.size() == 1) return nums[0];\\n                return max(res(nums, 0, nums.size() - 1) ,res(nums, 1, nums.size()));\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int res(vector<int>& nums, int left, int right) {\\n                int last = 0, lastlast = 0;\\n                for (int i = left; i < right; i++) {\\n                    lastlast = max(last, lastlast + nums[i]);\\n                    swap(last, lastlast);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3678450,
                "title": "c-house-robber-1-to-n-or-0-to-n-1",
                "content": "This problem is very similar to problem [House Robber](https://leetcode.com/problems/house-robber/solutions/3678350/c-most-optimal-code-with-explanation-and-comments/). \\nI suggest you to go through my solution on that problem first and then this problem is a cake walk.\\n\\n---\\n\\n\\n# Intuition\\n- The problem revolves around finding the maximum amount of money that can be robbed from houses arranged in a circular street, where adjacent houses have a security system connected.\\n- The objective is to devise a strategy that allows the robber to accumulate the highest possible sum of money without alerting the police.\\n- To achieve this, we need to consider two scenarios: one where the first house is robbed and one where it is not.\\n- By considering these two scenarios separately, we cover all possible combinations of robbing and skipping houses.\\n- The goal is to identify the optimal scenario that results in the maximum amount of money being robbed.\\n \\n\\n---\\n\\n\\n# Approach\\n- Divide the problem into two parts: one where the first house is robbed and one where it is not.\\n- Create a function robHelper which utilizes the dynamic programming technique, maintaining two variables (currMax and prevMax) to track the maximum amount of money that can be robbed.\\n- Call the robHelper function twice: once considering robbing the first house to the second-to-last house, and once considering skipping the first house and robbing the rest.\\n- Finally, return the maximum amount between the two scenarios as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- **Time complexity**:\\nThe time complexity of the solution is **O(N)**, where N is the size of the input array (the number of houses). The robHelper function which is used to iterate through the houses is called twice, thus the time complexity is O(N).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**:\\nThe space complexity is **O(1)** because the solution uses a constant amount of additional space to store the currMax and prevMax variables in the robHelper function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return nums[0];\\n        }\\n        \\n        int robFirstHouse = robHelper(nums, 0, nums.size() - 2); // Rob the first house to the second-to-last house\\n        int skipFirstHouse = robHelper(nums, 1, nums.size() - 1); // Skip the first house and rob the rest\\n        \\n        return max(robFirstHouse, skipFirstHouse);\\n    }\\n    \\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int currMax = 0;\\n        int prevMax = 0;\\n        \\n        for (int i = start; i <= end; i++) {\\n            int temp = max(prevMax + nums[i], currMax);\\n            prevMax = currMax;\\n            currMax = temp;\\n        }\\n        \\n        return currMax;\\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return nums[0];\\n        }\\n        \\n        int robFirstHouse = robHelper(nums, 0, nums.size() - 2); // Rob the first house to the second-to-last house\\n        int skipFirstHouse = robHelper(nums, 1, nums.size() - 1); // Skip the first house and rob the rest\\n        \\n        return max(robFirstHouse, skipFirstHouse);\\n    }\\n    \\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int currMax = 0;\\n        int prevMax = 0;\\n        \\n        for (int i = start; i <= end; i++) {\\n            int temp = max(prevMax + nums[i], currMax);\\n            prevMax = currMax;\\n            currMax = temp;\\n        }\\n        \\n        return currMax;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657452,
                "title": "c-solution-dp-100-beat-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint houseRobber(vector<int> &arr) {\\n        int n = arr.size();\\n        int prev2 = 0;\\n        int prev = arr[0];\\n        int curr;\\n        for (int i=1; i<n; i++) {\\n            int pick = arr[i];\\n            if (i > 1) pick += prev2;\\n            int notPick = 0 + prev;\\n            curr = max(pick, notPick);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        vector<int> temp1(begin(nums), end(nums)-1);\\n        vector<int> temp2(begin(nums)+1, end(nums));\\n        return max(houseRobber(temp1) , houseRobber(temp2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint houseRobber(vector<int> &arr) {\\n        int n = arr.size();\\n        int prev2 = 0;\\n        int prev = arr[0];\\n        int curr;\\n        for (int i=1; i<n; i++) {\\n            int pick = arr[i];\\n            if (i > 1) pick += prev2;\\n            int notPick = 0 + prev;\\n            curr = max(pick, notPick);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        vector<int> temp1(begin(nums), end(nums)-1);\\n        vector<int> temp2(begin(nums)+1, end(nums));\\n        return max(houseRobber(temp1) , houseRobber(temp2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447785,
                "title": "house-robber-ii-dp-c-solution-space-optimisation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**DP TABULATION APPROACH (TOP - DOWN) WITH SPACE OPTIMISATION**\\n\\nThe function **solve** iterates through the list of houses and for each house, two possible values can be calculated :\\n\\n- **take**, which represents the maximum amount of money that can be robbed if the current house is robbed, and\\n- **notTake**, which represents the maximum amount of money that can be robbed if the current house is not robbed.\\n\\nThe **curr** variable then stores the **maximum** value between take and notTake. Then the prev2 and prev1 variables accordingly changed.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &arr){\\n        //using tabulation(top-down) approach with space optimisation\\n\\n        int n = arr.size();\\n        int prev1 = arr[0];\\n        int prev2 = 0;\\n\\n        for(int i = 1; i < n; i++){\\n            int take = arr[i];\\n            \\n            if(i > 1)\\n                take += prev2;\\n\\n            int notTake = 0 + prev1;\\n            int curr = max(take,notTake);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        long long int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n\\n        //contain all the houses except the first one\\n        vector<int> temp1;\\n\\n        //contain all the houses except the last one\\n        vector<int> temp2;\\n\\n        for(int i = 0; i < n; i++){\\n            if(i != 0)\\n                temp1.push_back(nums[i]);\\n\\n            if(i != n-1)\\n                temp2.push_back(nums[i]);\\n        }\\n        return max( solve(temp1) , solve(temp2) );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &arr){\\n        //using tabulation(top-down) approach with space optimisation\\n\\n        int n = arr.size();\\n        int prev1 = arr[0];\\n        int prev2 = 0;\\n\\n        for(int i = 1; i < n; i++){\\n            int take = arr[i];\\n            \\n            if(i > 1)\\n                take += prev2;\\n\\n            int notTake = 0 + prev1;\\n            int curr = max(take,notTake);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        long long int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n\\n        //contain all the houses except the first one\\n        vector<int> temp1;\\n\\n        //contain all the houses except the last one\\n        vector<int> temp2;\\n\\n        for(int i = 0; i < n; i++){\\n            if(i != 0)\\n                temp1.push_back(nums[i]);\\n\\n            if(i != n-1)\\n                temp2.push_back(nums[i]);\\n        }\\n        return max( solve(temp1) , solve(temp2) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300063,
                "title": "dynamic-programming-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n    #please upvote me it would encourage me alot\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def house(nums):\\n            rob1,rob2=0,0\\n            for num in nums:\\n                temp=max(num+rob1,rob2)\\n                rob1=rob2\\n                rob2=temp\\n            return rob2\\n        return max(house(nums[1:]),house(nums[:-1]),nums[0])\\n    #please upvote me it would encourage me alot\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200178,
                "title": "python-dynamic-programming-approach-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        def solve(nums):\\n            dp1 = dp2 = 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)\\n            return dp2\\n        return max(solve(nums[1:]), solve(nums[:len(nums)-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        def solve(nums):\\n            dp1 = dp2 = 0\\n            for num in nums:\\n                dp1, dp2 = dp2, max(dp1 + num, dp2)\\n            return dp2\\n        return max(solve(nums[1:]), solve(nums[:len(nums)-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541299,
                "title": "my-java-solution-by-1-recursion-tle-2-memoization-3-tabulation-4-space-optimisation",
                "content": "```\\n1. Recursion\\n\\n\\n/*\\n\\nSince last element is the adjacent of the first element, we can have 3 observations.\\n\\n1. In our answer, there will not be both first and last element together.\\n2. If we leave the first element, then its solving house robber 1 from index 1 to n.\\n3. If we leave the last element, then its solving house robber 1 from index 0 to n - 1.\\n\\nSo our final answer will be max(step2, step3).\\n\\nBut this recursive solution will gives TLE as there are so many overlapping subproblems\\n\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1);\\n        return Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\\n\\n\\n```\\n2. Memoization\\n\\n/*\\n\\nUse 2 dp tables. One to track the results while we are not cosnidering the first element and the first one while we are considering the first element.\\n\\nThen just apply the dp tables and save the result at the very end where we are doing the return statement.\\n\\nTC : O(N)\\nSC : O(N) + O(N) + O(Stack Space)\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        // dp1 will be for the case where we do not consider the first element\\n        dp1[0] = nums[1];\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        // dp2 will be for the case where we consider the first element\\n        dp2[0] = nums[0];\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1, dp1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2, dp2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end, int [] dp) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        if (dp[end] != -1) {\\n            return dp[end];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2, dp);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1, dp);\\n        return dp[end] = Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\\n\\n\\n```\\n3. Tabulation\\n\\n/*\\n\\nNow we can go for the tabulation method and get rid of the extra stack space we are using\\n\\nTC : O(N)\\nSC : O(N) + O(N) [Didn;t considered the temp arraylist created] \\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        ArrayList<Integer> arr1=new ArrayList<>();\\n        ArrayList<Integer> arr2=new ArrayList<>();\\n\\n        // storing the elements to two separate list\\n        for(int i=0; i<length; i++){\\n\\n            if(i != 0) arr1.add(nums[i]);\\n            if(i != length - 1) arr2.add(nums[i]);\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(arr1, dp1), \\n                      maxResultLeavingNotLeavingFirstLast(arr2, dp2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(ArrayList<Integer> nums, int [] dp) {\\n        dp[0] = nums.get(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            int pickElement = nums.get(i);\\n            if (i > 1) {\\n                pickElement += dp[i - 2];\\n            }\\n            int notPickElement = dp[i - 1];\\n            dp[i] = Math.max(pickElement, notPickElement);\\n        }\\n        return dp[nums.size() - 1];\\n    }\\n}\\n```\\n\\n\\n```\\n4. Space Optimized\\n\\n/*\\n\\nWe can make 1 more observation that, we only care about the previous house and the previous previous house. So instead of the dp arrays, we can just make use of two variable and apply the same logic which will reduce our space further\\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(nums, 1, length - 1), \\n                      maxResultLeavingNotLeavingFirstLast(nums, 0, length - 2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(int [] nums, int start, int end) {\\n        int previous = nums[start];\\n        int previousPrevious = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int pick = nums[i] + previousPrevious;\\n            int notPick = previous;\\n            int result = Math.max(pick, notPick);\\n            previousPrevious = previous;\\n            previous = result;\\n        }\\n        return previous;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n1. Recursion\\n\\n\\n/*\\n\\nSince last element is the adjacent of the first element, we can have 3 observations.\\n\\n1. In our answer, there will not be both first and last element together.\\n2. If we leave the first element, then its solving house robber 1 from index 1 to n.\\n3. If we leave the last element, then its solving house robber 1 from index 0 to n - 1.\\n\\nSo our final answer will be max(step2, step3).\\n\\nBut this recursive solution will gives TLE as there are so many overlapping subproblems\\n\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1);\\n        return Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\n```\\n2. Memoization\\n\\n/*\\n\\nUse 2 dp tables. One to track the results while we are not cosnidering the first element and the first one while we are considering the first element.\\n\\nThen just apply the dp tables and save the result at the very end where we are doing the return statement.\\n\\nTC : O(N)\\nSC : O(N) + O(N) + O(Stack Space)\\n*/\\n\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n         if (length == 1) {\\n            return nums[0];\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        // dp1 will be for the case where we do not consider the first element\\n        dp1[0] = nums[1];\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        // dp2 will be for the case where we consider the first element\\n        dp2[0] = nums[0];\\n        // the first option is do not consider the first element, but the last element\\n        // the second option is we consider first element, but not the last element.\\n        return Math.max(findMaxWealthNotTakingFirstOrLast(nums, 1, length - 1, dp1), findMaxWealthNotTakingFirstOrLast(nums, 0, length - 2, dp2));\\n    }\\n    \\n    private int findMaxWealthNotTakingFirstOrLast(int [] nums, int start, int end, int [] dp) {\\n        if (end < start) {\\n            return 0;\\n        }\\n        if (end == start) {\\n            return nums[start];\\n        }\\n        if (dp[end] != -1) {\\n            return dp[end];\\n        }\\n        int pickThisElement = nums[end] + findMaxWealthNotTakingFirstOrLast(nums, start, end - 2, dp);\\n        int notPickThisElement = findMaxWealthNotTakingFirstOrLast(nums, start, end - 1, dp);\\n        return dp[end] = Math.max(pickThisElement, notPickThisElement);\\n    }\\n}\\n```\n```\\n3. Tabulation\\n\\n/*\\n\\nNow we can go for the tabulation method and get rid of the extra stack space we are using\\n\\nTC : O(N)\\nSC : O(N) + O(N) [Didn;t considered the temp arraylist created] \\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        ArrayList<Integer> arr1=new ArrayList<>();\\n        ArrayList<Integer> arr2=new ArrayList<>();\\n\\n        // storing the elements to two separate list\\n        for(int i=0; i<length; i++){\\n\\n            if(i != 0) arr1.add(nums[i]);\\n            if(i != length - 1) arr2.add(nums[i]);\\n        }\\n        int [] dp1 = new int [length];\\n        Arrays.fill(dp1, -1);\\n        int [] dp2 = new int [length];\\n        Arrays.fill(dp2, -1);\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(arr1, dp1), \\n                      maxResultLeavingNotLeavingFirstLast(arr2, dp2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(ArrayList<Integer> nums, int [] dp) {\\n        dp[0] = nums.get(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            int pickElement = nums.get(i);\\n            if (i > 1) {\\n                pickElement += dp[i - 2];\\n            }\\n            int notPickElement = dp[i - 1];\\n            dp[i] = Math.max(pickElement, notPickElement);\\n        }\\n        return dp[nums.size() - 1];\\n    }\\n}\\n```\n```\\n4. Space Optimized\\n\\n/*\\n\\nWe can make 1 more observation that, we only care about the previous house and the previous previous house. So instead of the dp arrays, we can just make use of two variable and apply the same logic which will reduce our space further\\n*/\\n\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int length = nums.length;\\n        if (length == 1) {\\n            return nums[0];\\n        }\\n        return Math.max(maxResultLeavingNotLeavingFirstLast(nums, 1, length - 1), \\n                      maxResultLeavingNotLeavingFirstLast(nums, 0, length - 2));\\n    }\\n    \\n    // just the house robber logic\\n    private int maxResultLeavingNotLeavingFirstLast(int [] nums, int start, int end) {\\n        int previous = nums[start];\\n        int previousPrevious = 0;\\n        for (int i = start + 1; i <= end; i++) {\\n            int pick = nums[i] + previousPrevious;\\n            int notPick = previous;\\n            int result = Math.max(pick, notPick);\\n            previousPrevious = previous;\\n            previous = result;\\n        }\\n        return previous;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280879,
                "title": "c-solution-with-comments-representation-house-robber-i-modification",
                "content": "***Please Upvote if it helps......***\\n***\\n***Solution :***\\n***\\n***\\nThis question can be solved using the approach discussed in the Maximum Sum of non-adjacent elements. Readers are highly advised to go through that solution first and then read this. The rest of the solution will refer to the previous solution as ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)***  and will relate to that approach. \\n\\nNow, we have a single test case. Three houses have money as shown.\\n![image](https://assets.leetcode.com/users/images/0e54a364-8578-4442-87c5-17d687584179_1657790986.524139.png)\\n***\\nAccording to ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** , the answer will be 4(2+2) as we are taking the maximum sum of non-adjacent elements.\\nIn this question, the first and last element are also adjacent(circular street), therefore the answer will be 3.\\n***\\n***\\n***Modification to Article DP5\\u2019s Approach***\\n***\\nWe were finding the maximum sum of non-adjacent elements in the previous questions. For a circular street, the first and last house are adjacent, therefore one thing we know for sure is that the answer will not consider the first and last element simultaneously (as they are adjacent).\\n\\nNow building on the ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** , we can say that maybe the last element is not considered in the answer. In that case, we can consider the first element. Let\\u2019s call this answer ans1. Hence we have reduced our array(arr- last element), say arr1, and found ans1 on it by using the ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** approach.\\n![image](https://assets.leetcode.com/users/images/21eb13d2-6fdc-4b2f-be89-0930ac24e63c_1657791058.8511071.png)\\n\\n\\n\\nNow, it can also happen that the final answer does consider the last element. If we consider the last element, we can\\u2019t consider the first element( again adjacent elements). We again use the same approach on our reduced array( arr \\u2013 first element), say arr2. Let\\u2019s call the answer we get as ans2.\\n![image](https://assets.leetcode.com/users/images/e881aee1-e3d5-4be6-b76f-8c3581589fe2_1657791108.8978257.png)\\nNow, the final answer can be either ans1 or ans2. As we have to return the maximum money robbed by the robber, we will return max(ans1, ans2) as our final answer.\\n***\\n***\\n***Approach:***\\n***\\nThe approach to solving this problem can be summarized as:\\n\\n* Make two reduced arrays \\u2013 arr1(arr-last element) and arr2(arr-first element).\\n* Find the maximum of non-adjacent elements as mentioned in ***[House Robber I](https://leetcode.com/problems/house-robber/discuss/2280017/c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space)*** on arr1 and arr2 separately. Let\\u2019s call the answers we got as ans1 and ans2 respectively.\\n* Return max(ans1, ans2) as our final answer.\\n***\\n***\\n***C++ Code:***\\n\\n```\\nlong long int solve(vector<int>& arr){\\n    int n = arr.size();\\n    long long int prev = arr[0];\\n    long long int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        long long int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int long long nonPick = 0 + prev;\\n        \\n        long long int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n\\nlong long int robStreet(int n, vector<int> &arr){\\n    vector<int> arr1;\\n    vector<int> arr2;\\n    \\n    for(int i=0; i<n; i++){\\n        \\n        if(i!=0) arr1.push_back(arr[i]);\\n        if(i!=n-1) arr2.push_back(arr[i]);\\n    }\\n    \\n    long long int ans1 = solve(arr1);\\n    long long int ans2 = solve(arr2);\\n    \\n    return max(ans1,ans2);\\n}\\n```\\n***\\n***Output: 11***\\n***\\n***Time Complexity: O(N )***\\n\\n***Reason:*** We are running a simple iterative loop, two times. Therefore total time complexity will be O(N) + O(N) \\u2248 O(N)\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using extra space.\\n***\\n***\\n***Please Upvote if it helps......***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nlong long int solve(vector<int>& arr){\\n    int n = arr.size();\\n    long long int prev = arr[0];\\n    long long int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        long long int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int long long nonPick = 0 + prev;\\n        \\n        long long int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n\\nlong long int robStreet(int n, vector<int> &arr){\\n    vector<int> arr1;\\n    vector<int> arr2;\\n    \\n    for(int i=0; i<n; i++){\\n        \\n        if(i!=0) arr1.push_back(arr[i]);\\n        if(i!=n-1) arr2.push_back(arr[i]);\\n    }\\n    \\n    long long int ans1 = solve(arr1);\\n    long long int ans2 = solve(arr2);\\n    \\n    return max(ans1,ans2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60006,
                "title": "simple-dp-java-solution-in-1ms",
                "content": "public class Solution {\\n\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int rob=0,notrob=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int currob=notrob+nums[i];\\n            notrob=Math.max(rob,notrob);\\n            rob=currob;\\n        }\\n        int firstcase=Math.max(rob,notrob);\\n        rob=0;notrob=0;\\n        for(int i=1;i<nums.length;i++){\\n            int currob=notrob+nums[i];\\n            notrob=Math.max(rob,notrob);\\n            rob=currob;\\n        }\\n        int secondcase=Math.max(rob,notrob);\\n        return Math.max(firstcase,secondcase);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int rob=0,notrob=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int currob=notrob+nums[i];\\n            notrob=Math.max(rob,notrob);\\n            rob=currob;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3826217,
                "title": "dp-memoization-explained-with-intution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince we are given a circular array , means the first and the last index are connected so we cant pick both of them in one case\\nso what we can do is, we will break the problem into two parts\\n1 - from index 0 to n - 1 ( where n is the last element ) -> we are picking the 0th element but not picking the last element\\n2 - from index 1 to n -> here we are not picking the 0th element but picking the last index\\nWe are doing this because our answer will be any ONE from these two cases so we\\'ll return the max of the two cases\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// recursive function to give max of an array not picking adjacent elements\\n\\n    int maxRob(vector<int>& nums, int end , int n , vector<int>& dp ){\\n        if(n == end) return nums[end]; // we we\\'ll reach n == end only when we were previously at n+2, we\\'ll never reach here from n+1, so we dont need to worry about skipping it or not , if we reach here means it WILL get picked\\n        if( n < end ) return 0; // when n = 1 and we picked then we\\'ll call for n-2 and that is -1  so in that case well return 0\\n        if( dp[n] != -1 ) return dp[n];\\n\\n        int pick = nums[n] + maxRob(nums,end, n-2, dp);  // since we are picking that element we\\'ll add that element (nums[n] ) and call for n-2  because we have to skip 1 element\\n        int notPick = 0 + maxRob(nums,end, n-1, dp); // here we are not picking that element ( that\\'s why adding 0 ) and call for n-1 cause we don\\'t need to skip this time since we are not picking the current element\\n\\n        return dp[n] = max(pick, notPick); // store in dp and return max\\n\\n\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        if( n == 1 ) return nums[0];\\n\\n        vector<int> dp1(n+1,-1);\\n        vector<int> dp2(n+1,-1);\\n\\n        int case1 = maxRob(nums,0, n-2, dp1); // in case 1 we are passing the nums array from 0 to n-2 ( excluding one from last but including the 0th element )\\n        int case2 = maxRob(nums,1, n-1, dp2);  // in case 1 we are passing the nums array from 0 to n-1 (till last, but excluding the 0th element)\\n\\n        return max(case1, case2); // we\\'ll return max of case1 and case2\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// recursive function to give max of an array not picking adjacent elements\\n\\n    int maxRob(vector<int>& nums, int end , int n , vector<int>& dp ){\\n        if(n == end) return nums[end]; // we we\\'ll reach n == end only when we were previously at n+2, we\\'ll never reach here from n+1, so we dont need to worry about skipping it or not , if we reach here means it WILL get picked\\n        if( n < end ) return 0; // when n = 1 and we picked then we\\'ll call for n-2 and that is -1  so in that case well return 0\\n        if( dp[n] != -1 ) return dp[n];\\n\\n        int pick = nums[n] + maxRob(nums,end, n-2, dp);  // since we are picking that element we\\'ll add that element (nums[n] ) and call for n-2  because we have to skip 1 element\\n        int notPick = 0 + maxRob(nums,end, n-1, dp); // here we are not picking that element ( that\\'s why adding 0 ) and call for n-1 cause we don\\'t need to skip this time since we are not picking the current element\\n\\n        return dp[n] = max(pick, notPick); // store in dp and return max\\n\\n\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        if( n == 1 ) return nums[0];\\n\\n        vector<int> dp1(n+1,-1);\\n        vector<int> dp2(n+1,-1);\\n\\n        int case1 = maxRob(nums,0, n-2, dp1); // in case 1 we are passing the nums array from 0 to n-2 ( excluding one from last but including the 0th element )\\n        int case2 = maxRob(nums,1, n-1, dp2);  // in case 1 we are passing the nums array from 0 to n-1 (till last, but excluding the 0th element)\\n\\n        return max(case1, case2); // we\\'ll return max of case1 and case2\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772069,
                "title": "easy-java-beats-100-double-tabulation-time-optimized-no-recursion-used",
                "content": "# Intuition\\nEither the problem will contain the first house or the last\\n\\n# Approach\\nUsing tabulation, create two tables\\n- One that contains the first house and not the last.\\n- The other one contaions the last house and not the first.\\n- return the maximum of both possibilities.\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int n = nums.length;\\n        int[] dp1 = new int[n-1];\\n        int[] dp2 = new int[n-1];\\n        dp1[0] = nums[0];\\n        dp1[1] = Math.max(nums[1],dp1[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp1[i] = Math.max(nums[i] + dp1[i-2], dp1[i-1]);\\n        }\\n        dp2[0] = nums[1];\\n        dp2[1] = Math.max(nums[2],dp2[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp2[i] = Math.max(nums[i+1] + dp2[i-2], dp2[i-1]);\\n        }\\n        int f =  Math.max(dp1[n-2],dp1[n-3]);\\n        int s = Math.max(dp2[n-2], dp2[n-3]);\\n        return Math.max(s, f);\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/5fe145aa-ca91-4414-a597-66c52260e2a9_1689488289.7580066.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int n = nums.length;\\n        int[] dp1 = new int[n-1];\\n        int[] dp2 = new int[n-1];\\n        dp1[0] = nums[0];\\n        dp1[1] = Math.max(nums[1],dp1[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp1[i] = Math.max(nums[i] + dp1[i-2], dp1[i-1]);\\n        }\\n        dp2[0] = nums[1];\\n        dp2[1] = Math.max(nums[2],dp2[0]);\\n        for(int i = 2;i<n-1;i++){\\n            dp2[i] = Math.max(nums[i+1] + dp2[i-2], dp2[i-1]);\\n        }\\n        int f =  Math.max(dp1[n-2],dp1[n-3]);\\n        int s = Math.max(dp2[n-2], dp2[n-3]);\\n        return Math.max(s, f);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712626,
                "title": "c-2-methods-dp-beats-100-runtime-96-97-memory",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Method2 (Dp) : further space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(1)\\n    */\\n    // /*\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // special case : when (n = 1)\\n        if(n == 1)\\n            return nums[0];\\n        \\n        // exclude element at last index and find \\'ans1\\'\\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n-1; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        int ans1 = prev1;\\n\\n\\n        // exclude element at first index and find \\'ans2\\'\\n        int prev4 = 0;\\n        int prev3 = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n            int incl = prev4 + nums[i];\\n            int excl = prev3 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev4 = prev3;\\n            prev3 = ans;\\n        }\\n\\n        int ans2 = prev3;\\n\\n        return max(ans1, ans2);\\n    }\\n    // */\\n```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    // Method1 (Dp) : space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(n)\\n    */\\n    /*\\n    public:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        return prev1;\\n    }\\n\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> first, last; // SC: O(2n)\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            if(i != n-1)\\n                first.push_back(nums[i]);\\n            if(i != 0)\\n                last.push_back(nums[i]);\\n        }\\n\\n        return max(solve(first), solve(last)); // TC: O(2n)\\n    }\\n    */\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // Method2 (Dp) : further space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(1)\\n    */\\n    // /*\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // special case : when (n = 1)\\n        if(n == 1)\\n            return nums[0];\\n        \\n        // exclude element at last index and find \\'ans1\\'\\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n-1; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        int ans1 = prev1;\\n\\n\\n        // exclude element at first index and find \\'ans2\\'\\n        int prev4 = 0;\\n        int prev3 = nums[1];\\n        \\n        for(int i = 2; i < n; i++) {\\n            int incl = prev4 + nums[i];\\n            int excl = prev3 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev4 = prev3;\\n            prev3 = ans;\\n        }\\n\\n        int ans2 = prev3;\\n\\n        return max(ans1, ans2);\\n    }\\n    // */\\n```\n```\\n    // Method1 (Dp) : space optimization\\n    /*\\n    TC : O(n)\\n    SC : O(n)\\n    */\\n    /*\\n    public:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int prev2 = 0;\\n        int prev1 = nums[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            int incl = prev2 + nums[i];\\n            int excl = prev1 + 0;\\n\\n            int ans = max(incl, excl);\\n\\n            // shifting\\n            prev2 = prev1;\\n            prev1 = ans;\\n        }\\n\\n        return prev1;\\n    }\\n\\n    public:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> first, last; // SC: O(2n)\\n        for(int i = 0; i < n; i++) { // TC: O(n)\\n            if(i != n-1)\\n                first.push_back(nums[i]);\\n            if(i != 0)\\n                last.push_back(nums[i]);\\n        }\\n\\n        return max(solve(first), solve(last)); // TC: O(2n)\\n    }\\n    */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634492,
                "title": "using-memoization-easy-c-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->we will check for two cases \\n1- if we rob from first house then we will not rob from last house i,e from i=0 to n-2 .\\n2- if we rob from last house then we will not rob from first house i,e from i=1 to n-1.\\nThen we will return the max from the result of these two cases.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i ,vector<int>& nums,int n, vector<int>&dp)\\n    {\\n        if(i>n)  return 0;      //base case\\n      \\n        if(dp[i]!=-1)return dp[i];  //check if already evaluated for that value of i\\n\\n        int pick = nums[i]+ helper(i+2 ,nums ,n,dp);\\n        int notpick = helper(i+1,nums,n,dp);  //to skip that house\\n        return dp[i]=max(pick ,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return nums[0];\\n        vector<int>dp(n,-1);  \\n        int fHouse = helper(0,nums,n-2,dp); //if we want to take first house\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=-1;  //changing values of dp back to -1\\n        }\\n        int notFirstHouse = helper(1,nums,n-1,dp); //if we want to take last house\\n        return max(fHouse,notFirstHouse);\\n    }\\n};\\n```\\n![leetl.jpg](https://assets.leetcode.com/users/images/6d356838-909e-42c7-83a9-4cd23c179359_1686680032.6498754.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i ,vector<int>& nums,int n, vector<int>&dp)\\n    {\\n        if(i>n)  return 0;      //base case\\n      \\n        if(dp[i]!=-1)return dp[i];  //check if already evaluated for that value of i\\n\\n        int pick = nums[i]+ helper(i+2 ,nums ,n,dp);\\n        int notpick = helper(i+1,nums,n,dp);  //to skip that house\\n        return dp[i]=max(pick ,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return nums[0];\\n        vector<int>dp(n,-1);  \\n        int fHouse = helper(0,nums,n-2,dp); //if we want to take first house\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=-1;  //changing values of dp back to -1\\n        }\\n        int notFirstHouse = helper(1,nums,n-1,dp); //if we want to take last house\\n        return max(fHouse,notFirstHouse);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342983,
                "title": "using-house-robber-1-twice-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int houseRobberOne(vector<int>& arr) {\\n        int N = arr.size();\\n        if (N == 1) return arr[0];\\n        vector<int> dp(N, 0);\\n        dp[0] = arr[0];\\n        dp[1] = max(arr[0], arr[1]);\\n        for(int i = 2; i < N; i++){\\n            dp[i] = max(dp[i-1], dp[i-2] + arr[i]);\\n        }\\n        return dp[N-1];\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N == 1) return nums[0];\\n        vector<int> v1(nums.begin() + 1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end() - 1);\\n        return max(houseRobberOne(v1), houseRobberOne(v2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int houseRobberOne(vector<int>& arr) {\\n        int N = arr.size();\\n        if (N == 1) return arr[0];\\n        vector<int> dp(N, 0);\\n        dp[0] = arr[0];\\n        dp[1] = max(arr[0], arr[1]);\\n        for(int i = 2; i < N; i++){\\n            dp[i] = max(dp[i-1], dp[i-2] + arr[i]);\\n        }\\n        return dp[N-1];\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N == 1) return nums[0];\\n        vector<int> v1(nums.begin() + 1, nums.end());\\n        vector<int> v2(nums.begin(), nums.end() - 1);\\n        return max(houseRobberOne(v1), houseRobberOne(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323600,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> dp1(n, -1), dp2(n, -1);\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(n-2, num1, dp1);\\n        int max2 = solve(n-2, num2, dp2);\\n        return max (max1, max2);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(num1);\\n        int max2 = solve(num2);\\n        return max (max1, max2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> dp1(n, -1), dp2(n, -1);\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(n-2, num1, dp1);\\n        int max2 = solve(n-2, num2, dp2);\\n        return max (max1, max2);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }    \\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        vector <int> num1, num2;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0)\\n                num1.push_back(nums[i]);\\n            if (i != n-1)\\n                num2.push_back(nums[i]);    \\n        }\\n        int max1 = solve(num1);\\n        int max2 = solve(num2);\\n        return max (max1, max2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261995,
                "title": "python3-very-easy-solution-uwu",
                "content": "\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        def helper(nums):\\n            prev, curr = 0, 0\\n            for n in nums:\\n                prev, curr = curr, max(n + prev, curr)\\n            return curr\\n\\n        return max(helper(nums[1:]), helper(nums[:-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        def helper(nums):\\n            prev, curr = 0, 0\\n            for n in nums:\\n                prev, curr = curr, max(n + prev, curr)\\n            return curr\\n\\n        return max(helper(nums[1:]), helper(nums[:-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206106,
                "title": "compact-fast-100-and-space-efficient-90",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        if(nums.length==2) return Math.max(nums[nums.length-1],nums[nums.length-2]);\\n        int nums2[] = new int[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0)nums2[i-1]=nums[i];\\n        }\\n        for(int i=2;i<nums2.length;i++){\\n            nums[i]+=(i-3>=0)?Math.max(nums[i-2],nums[i-3]):nums[i-2];\\n            nums2[i]+=(i-3>=0)?Math.max(nums2[i-2],nums2[i-3]):nums2[i-2];\\n        }\\n        return Math.max(Math.max(nums[nums.length-2],nums[nums.length-3]),Math.max(nums2[nums2.length-1],nums2[nums2.length-2]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        if(nums.length==2) return Math.max(nums[nums.length-1],nums[nums.length-2]);\\n        int nums2[] = new int[nums.length-1];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0)nums2[i-1]=nums[i];\\n        }\\n        for(int i=2;i<nums2.length;i++){\\n            nums[i]+=(i-3>=0)?Math.max(nums[i-2],nums[i-3]):nums[i-2];\\n            nums2[i]+=(i-3>=0)?Math.max(nums2[i-2],nums2[i-3]):nums2[i-2];\\n        }\\n        return Math.max(Math.max(nums[nums.length-2],nums[nums.length-3]),Math.max(nums2[nums2.length-1],nums2[nums2.length-2]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182033,
                "title": "java-c-100-solution-using-dynamic-programming-house-robber-ii",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return max(tempAns,prev);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return Math.max(tempAns,prev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            curr = max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return max(tempAns,prev);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n        int prev = nums[0],prev2 = 0, curr;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int tempAns = prev;\\n        prev = nums[1];prev2 = 0;\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            curr = Math.max(prev2+nums[i],prev);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return Math.max(tempAns,prev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072557,
                "title": "c-very-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        vector<int> dp1(n, 0), dp2(n, 0);\\n        \\n        dp1[1] = nums[0];\\n        dp2[1] = nums[1];\\n        for(int i=2; i<n; i++) {\\n            dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i-1]);\\n            dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i]);\\n        }\\n\\n        return max(dp1[n-1], dp2[n-1]);\\n    }\\n};\\n```\\n\\n# Explanation\\n- ***dp1*** contains the first house, ***dp2*** contains the last house\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        vector<int> dp1(n, 0), dp2(n, 0);\\n        \\n        dp1[1] = nums[0];\\n        dp2[1] = nums[1];\\n        for(int i=2; i<n; i++) {\\n            dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i-1]);\\n            dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i]);\\n        }\\n\\n        return max(dp1[n-1], dp2[n-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507891,
                "title": "c-memoization-solution-100-fast",
                "content": "This problem is a little tricky at first glance. However, if you have finished the House Robber problem, this problem can simply be decomposed into two House Robber problems.\\nSuppose there are n houses, since house 0 and n - 1 are now neighbors, we cannot rob them together and thus the solution is now the maximum of\\n\\nRob houses 0 to n - 2;\\nRob houses 1 to n - 1.\\nThe code is as follows. Some edge cases (n < 2) are handled explicitly.\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums,int i,int j,vector<int> &dp){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,j,dp)+nums[i];\\n        int notake=help(nums,i+1,j,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        vector<int> dp1(nums.size()+1,-1);\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        return max(help(nums,0,nums.size()-1,dp),help(nums,1,nums.size(),dp1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<int> &nums,int i,int j,vector<int> &dp){\\n        if(i>=j){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,j,dp)+nums[i];\\n        int notake=help(nums,i+1,j,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        vector<int> dp1(nums.size()+1,-1);\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        return max(help(nums,0,nums.size()-1,dp),help(nums,1,nums.size(),dp1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345845,
                "title": "success-details-runtime-41-ms-python3-vimla-kushwaha",
                "content": "![image](https://assets.leetcode.com/users/images/3b4eb15e-fc7e-4438-9ddc-e7f6ef2b35bf_1659011185.294158.png)\\n**First best Solution**\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        a1 = 0\\n        b1 = nums[0]\\n        a2 = 0\\n        b2 = nums[1]\\n        for i in range(1, len(nums) - 1):\\n            a1, b1 = b1, max(a1 + nums[i], b1)\\n            a2, b2 = b2, max(a2 + nums[i + 1], b2)\\n        return max(b1, b2)\\n```\\n***upvote*** if this helped you out!!\\n\\n**Second Best Solution**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        # step 1 or 2\\n        if n<=2:\\n            return max(nums)\\n        \\n        \\n        return max(self.helper(nums[:-1]),self.helper(nums[1:]))\\n    \\n    \\n    def helper(self,nums):\\n        \\n        \\n        dp=[0]*len(nums)\\n        \\n        \\n        dp[0]=nums[0]\\n        dp[1]=max(nums[0],nums[1])\\n        \\n        for i in range(2,len(nums)):\\n            dp[i]=max(nums[i]+dp[i-2],dp[i-1])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        a1 = 0\\n        b1 = nums[0]\\n        a2 = 0\\n        b2 = nums[1]\\n        for i in range(1, len(nums) - 1):\\n            a1, b1 = b1, max(a1 + nums[i], b1)\\n            a2, b2 = b2, max(a2 + nums[i + 1], b2)\\n        return max(b1, b2)\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        # step 1 or 2\\n        if n<=2:\\n            return max(nums)\\n        \\n        \\n        return max(self.helper(nums[:-1]),self.helper(nums[1:]))\\n    \\n    \\n    def helper(self,nums):\\n        \\n        \\n        dp=[0]*len(nums)\\n        \\n        \\n        dp[0]=nums[0]\\n        dp[1]=max(nums[0],nums[1])\\n        \\n        for i in range(2,len(nums)):\\n            dp[i]=max(nums[i]+dp[i-2],dp[i-1])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183434,
                "title": "java-dp-solution-in-depth-explanation",
                "content": "If you have not completed **LC. 198 House Robber** yet, I strongly recommend you to do that problem first because the problem is a minor extension to the LC.198 House Robber. The only difference between LC. 213 House Robber II and LC. 198 House Robber is that we can see the houses are arranged as a circle here. We can not rob first house and last house simultaenously because the two houses are connected. You can use the image below as a reference. \\n   \\n   Therefore, we can divide the given input array into two diffrent array[ ]. Let\\'s say we create house1 and house2 array:\\n   \\n   `nums    = [7, 4, 1, 9, 3, 8, 6, 5]`\\n   `house1 = [7, 4, 1, 9, 3, 8, 6]`\\n   `house2 = [4, 1, 9, 3, 8, 6, 5]`\\n   \\n   We image us, as the professional robbers, try to rob several houses on **two different streets**. Then we return maxmium profit of these two streets. I believe it\\'s pretty clear at this point. We pass these two ArrayList<Integer> into our helper method, and we return the max profit from two helper methods.\\n   \\n   ![image](https://assets.leetcode.com/users/images/39a30a99-4b56-4112-ab7b-2253d1fbe8cb_1655906349.5961971.png)\\n   \\n   Below is my solution in Java. You could notice we can achieve O(n) time | O(n) space. If you wanna optimize the space complexity, then we don\\'t create ArrayList. We pass startIdx and endIdx into hellper method, and we use variables to track the max profit. Hence, we can achieve O(n) time | O(1) space. \\n   \\n```\\nclass Solution\\n{\\n    public int rob(int[] nums)\\n    {\\n        /*\\n        nums = [7, 4, 1, 9, 3, 8, 6, 5]\\n        Street1 = [7, 4, 1, 9, 3, 8, 6]\\n        Street2 = [4, 1, 9, 3, 8, 6, 5]\\n        */\\n        \\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        ArrayList<Integer> house1 = new ArrayList<>();\\n        ArrayList<Integer> house2 = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n            house1.add(nums[i]);\\n        \\n        for(int i = 1; i < nums.length; i++)\\n            house2.add(nums[i]);\\n        \\n        int max1 = helper(house1);\\n        int max2 = helper(house2);\\n        \\n        \\n        System.out.println(max1);\\n        System.out.println(max2);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    public int helper(ArrayList<Integer> house)\\n    {\\n        if(house.size() == 0)   return 0;\\n        if(house.size() == 1)   return house.get(0);\\n        \\n        int[] maxSum = new int[house.size()];\\n        maxSum[0] = house.get(0);\\n        maxSum[1] = Math.max(house.get(0), house.get(1));\\n        \\n        for(int i = 2; i < house.size(); i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + house.get(i));\\n        \\n        return maxSum[maxSum.length-1];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int rob(int[] nums)\\n    {\\n        /*\\n        nums = [7, 4, 1, 9, 3, 8, 6, 5]\\n        Street1 = [7, 4, 1, 9, 3, 8, 6]\\n        Street2 = [4, 1, 9, 3, 8, 6, 5]\\n        */\\n        \\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        ArrayList<Integer> house1 = new ArrayList<>();\\n        ArrayList<Integer> house2 = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n            house1.add(nums[i]);\\n        \\n        for(int i = 1; i < nums.length; i++)\\n            house2.add(nums[i]);\\n        \\n        int max1 = helper(house1);\\n        int max2 = helper(house2);\\n        \\n        \\n        System.out.println(max1);\\n        System.out.println(max2);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    public int helper(ArrayList<Integer> house)\\n    {\\n        if(house.size() == 0)   return 0;\\n        if(house.size() == 1)   return house.get(0);\\n        \\n        int[] maxSum = new int[house.size()];\\n        maxSum[0] = house.get(0);\\n        maxSum[1] = Math.max(house.get(0), house.get(1));\\n        \\n        for(int i = 2; i < house.size(); i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + house.get(i));\\n        \\n        return maxSum[maxSum.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158878,
                "title": "do-house-robber-twice",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = {}\\n        def getResult(a,i):\\n            if i>=len(a):\\n                return 0\\n            if i in dp:\\n                return dp[i]\\n            \\n            sum = 0\\n            if i<len(a)-1:\\n                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))\\n            else:\\n                sum+=a[i]+getResult(a,i+2)\\n            dp[i] = sum\\n            return sum\\n            \\n        x = getResult(nums[:len(nums)-1],0)\\n        dp = {}\\n        y = getResult(nums[1:],0)\\n            \\n        return max(x, y)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = {}\\n        def getResult(a,i):\\n            if i>=len(a):\\n                return 0\\n            if i in dp:\\n                return dp[i]\\n            \\n            sum = 0\\n            if i<len(a)-1:\\n                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))\\n            else:\\n                sum+=a[i]+getResult(a,i+2)\\n            dp[i] = sum\\n            return sum\\n            \\n        x = getResult(nums[:len(nums)-1],0)\\n        dp = {}\\n        y = getResult(nums[1:],0)\\n            \\n        return max(x, y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880441,
                "title": "100-faster-with-explanation-dp",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Explanation :-**\\n\\n![image](https://assets.leetcode.com/users/images/00257e40-83bb-4806-ab71-9c7aed44b285_1648145851.9563727.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n - 1) , dp2(n);\\n        \\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        if(n == 2){\\n            return max(nums[0] , nums[1]);\\n        }\\n         \\n        dp1[0] = dp1[1] = nums[0]; // First house is robbed\\n        for(int i = 2 ; i < n - 1 ; i++){\\n            dp1[i] = max(dp1[i - 1] , dp1[i - 2] + nums[i]);\\n        }\\n        \\n\\t    dp2[1] = nums[1]; // First house is not robbed\\n        dp2[2] = max(nums[1] , nums[2]);\\n        for(int i = 3 ; i < n ; i++){\\n            dp2[i] = max(dp2[i - 1] , dp2[i - 2] + nums[i]);   \\n        }\\n        return max(dp1[n - 2] , dp2[n - 1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n - 1) , dp2(n);\\n        \\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        if(n == 2){\\n            return max(nums[0] , nums[1]);\\n        }\\n         \\n        dp1[0] = dp1[1] = nums[0]; // First house is robbed\\n        for(int i = 2 ; i < n - 1 ; i++){\\n            dp1[i] = max(dp1[i - 1] , dp1[i - 2] + nums[i]);\\n        }\\n        \\n\\t    dp2[1] = nums[1]; // First house is not robbed\\n        dp2[2] = max(nums[1] , nums[2]);\\n        for(int i = 3 ; i < n ; i++){\\n            dp2[i] = max(dp2[i - 1] , dp2[i - 2] + nums[i]);   \\n        }\\n        return max(dp1[n - 2] , dp2[n - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614654,
                "title": "simple-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n     int solve(vector<int>& nums) {\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        //corner cases\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        if(n==2) return max(nums[0],nums[1]);\\n         \\n        vector<int>v1(nums.begin(),nums.end()-1); //Exculde first house and include last house\\n        vector<int>v2(nums.begin()+1,nums.end()); //Exculde last house and include first house\\n        \\n        return max(solve(v1),solve(v2));\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     int solve(vector<int>& nums) {\\n        int dp[nums.size()+1];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1544251,
                "title": "javascript-memoized-recursion-beats-100-time-commented-code",
                "content": "As the last house is connected back to first house in a circular way, we cannot have a loot which involves both first house and last house. So, we can split the problem into 2 parts: \\n\\t1. To start from house1 and go till house n-1 (last house - 1)\\n\\t2. To start from house2 and go till house n (last house)\\nand then take the maximum of the two loots and return.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar rob = function(nums) {\\n  let dp = []; //to memoize the repetitive calls\\n  \\n  function helpRob(start, house){\\n    //base condition to return 0 if we to try go past the starting house\\n    if(house < start.start) return 0;\\n\\t\\n    //if we have already visited this house, then directly return the value memoized in the array\\n    if(dp[house] >= 0) return dp[house];\\n\\t\\n    //else store and return the maximum of either choosing to rob the current house \\n//and going 2 houses back or choosing to not rob the house and going to the previous house\\n    dp[house] = Math.max((nums[house] + helpRob({start: start.start}, house-2))\\n                          , helpRob({start: start.start}, house-1));\\n    \\n    return dp[house];\\n  }\\n  \\n  if(nums.length === 1) return nums[0];\\n  if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n  \\n  //travelling from house 1 to house n-1\\n  //passing the start as an object as it is passed by reference.\\n  let first = helpRob({start: 0}, nums.length-2);\\n  \\n  //resetting the memoized array after the first travel\\n  dp = [];\\n  \\n  //travelling from house 2 to house n-2\\n  let second = helpRob({start: 1}, nums.length-1);\\n  \\n  //returning the maximum between two traversals\\n  return Math.max(first, second);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar rob = function(nums) {\\n  let dp = []; //to memoize the repetitive calls\\n  \\n  function helpRob(start, house){\\n    //base condition to return 0 if we to try go past the starting house\\n    if(house < start.start) return 0;\\n\\t\\n    //if we have already visited this house, then directly return the value memoized in the array\\n    if(dp[house] >= 0) return dp[house];\\n\\t\\n    //else store and return the maximum of either choosing to rob the current house \\n//and going 2 houses back or choosing to not rob the house and going to the previous house\\n    dp[house] = Math.max((nums[house] + helpRob({start: start.start}, house-2))\\n                          , helpRob({start: start.start}, house-1));\\n    \\n    return dp[house];\\n  }\\n  \\n  if(nums.length === 1) return nums[0];\\n  if(nums.length === 2) return Math.max(nums[0], nums[1]);\\n  \\n  //travelling from house 1 to house n-1\\n  //passing the start as an object as it is passed by reference.\\n  let first = helpRob({start: 0}, nums.length-2);\\n  \\n  //resetting the memoized array after the first travel\\n  dp = [];\\n  \\n  //travelling from house 2 to house n-2\\n  let second = helpRob({start: 1}, nums.length-1);\\n  \\n  //returning the maximum between two traversals\\n  return Math.max(first, second);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265840,
                "title": "java-dynamic-programming-with-explanation",
                "content": "# Approach\\nThe approach is similar to the basic house robber problem. The only new constraint is that the houses are arranged in a circular manner (last house being the neighbor of the first house).\\n\\nSo, if I choose the first house in the final result, last house cannot be included and vice versa. I can split the solution into solving for two arrays, one from index 0 to n - 1 and other from 1 to n (n being the length of the array). Finally I can return the max between these two answers. This leads to a time complexity of twice of the basic house robber problem, but it can be ignored due to being a constant. \\n\\n# Implementations\\n\\n## 1. Recursion\\nTime complexity: O(2^n)\\nSpace complexity: O(n)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n\\t\\t// edge case\\n\\t\\tif (nums.length == 1)\\n            return nums[0];\\n\\t\\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // return maximum between the two cases\\n        return Math.max(recurse(0, nums.length - 1),\\n                        recurse(1, nums.length));\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        return Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n    }\\n}\\n```\\n\\n## 2. Top-down DP\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums, memo;\\n    \\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // initialize dp table\\n        memo = new int[nums.length];\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int first = recurse(0, nums.length - 1);\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int second = recurse(1, nums.length);\\n        \\n        // return the maximum result between the two cases\\n        return Math.max(first, second);\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        else if (memo[cur] != -1) return memo[cur];\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        memo[cur] = Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n        \\n        return memo[cur];\\n    }\\n}\\n```\\n\\n## 3. Bottom-up DP\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        // initialize dp table\\n        int[] memo = new int[nums.length];\\n        \\n        // set base cases\\n        memo[start] = nums[start];\\n        if (end > start + 1)\\n            memo[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]);\\n        }\\n        \\n        return memo[end - 1];\\n    }\\n}\\n```\\n\\n## 4. Bottom-up DP with constant space\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        int oneBack = 0, twoBack = 0;\\n        \\n        // set base cases        \\n        if (end > start + 1) {\\n            oneBack = Math.max(nums[start], nums[start + 1]);\\n            twoBack = nums[start];\\n        }\\n        else {\\n            oneBack = nums[start];\\n        }\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            int cur = Math.max(oneBack, nums[i] + twoBack);\\n            twoBack = oneBack;\\n            oneBack = cur;\\n        }\\n        \\n        return oneBack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n\\t\\t// edge case\\n\\t\\tif (nums.length == 1)\\n            return nums[0];\\n\\t\\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // return maximum between the two cases\\n        return Math.max(recurse(0, nums.length - 1),\\n                        recurse(1, nums.length));\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        return Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    int[] nums, memo;\\n    \\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        // setting as class variable for convenience\\n        this.nums = nums;\\n        \\n        // initialize dp table\\n        memo = new int[nums.length];\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int first = recurse(0, nums.length - 1);\\n        \\n        // reset dp table and calculate\\n        Arrays.fill(memo, -1);\\n        int second = recurse(1, nums.length);\\n        \\n        // return the maximum result between the two cases\\n        return Math.max(first, second);\\n    }\\n    \\n    private int recurse(int cur, int end) {\\n        // base case\\n        if (cur >= end)\\n            return 0;\\n        else if (memo[cur] != -1) return memo[cur];\\n        \\n        // return maximum between choosing the current element and skipping it.\\n        memo[cur] = Math.max(recurse(cur + 1, end),\\n                        nums[cur] + recurse(cur + 2, end));\\n        \\n        return memo[cur];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        // initialize dp table\\n        int[] memo = new int[nums.length];\\n        \\n        // set base cases\\n        memo[start] = nums[start];\\n        if (end > start + 1)\\n            memo[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]);\\n        }\\n        \\n        return memo[end - 1];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    \\n    int[] nums;\\n    \\n    public int rob(int[] nums) {\\n        // edge case\\n        if (nums.length == 1)\\n            return nums[0];\\n        \\n        this.nums = nums;\\n        \\n        // return max between two cases\\n        return Math.max(helper(0, nums.length - 1),\\n                        helper(1, nums.length));\\n    }\\n    \\n    private int helper(int start, int end) {\\n        int oneBack = 0, twoBack = 0;\\n        \\n        // set base cases        \\n        if (end > start + 1) {\\n            oneBack = Math.max(nums[start], nums[start + 1]);\\n            twoBack = nums[start];\\n        }\\n        else {\\n            oneBack = nums[start];\\n        }\\n        \\n        for (int i = start + 2; i < end; i++) {\\n            int cur = Math.max(oneBack, nums[i] + twoBack);\\n            twoBack = oneBack;\\n            oneBack = cur;\\n        }\\n        \\n        return oneBack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232868,
                "title": "c-0ms-top-down-dp-recursive-memoization-line-by-line-explanation",
                "content": "Step by Step solution. \\n```\\nclass Solution {\\npublic:\\n    int dp[105][2];\\n    int getAns(vector<int>&a,int i,int f){ //f is used to check if the first house is looted or not.\\n        if(i>=a.size())return 0;\\n        if(i==a.size()-1&&f)return 0; // if first house is looted, then he cannot loot in the last house.\\n        if(i==a.size()-1&&!f)return a[i]; // if first house is not looted, he will definitely loot the last house. \\n        if(dp[i][f]!=-1)return dp[i][f];\\n        if(i==0){\\n            \\n        return dp[i][f]=max(a[i]+getAns(a,i+2,1),getAns(a,i+1,0));// at i=0, we have to take both the condition, what will be the max value he get if it loots the first house versus what value he will get if he not loots the first house.\\n        }\\n        else{\\n            //if he will loot the current house, he cannot loot the next house so he will go to i+2 th house., and if he not loots the house he can go to i+1 th house. \\n            return dp[i][f]=max(a[i]+getAns(a,i+2,f),getAns(a,i+1,f));\\n            \\n        }\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return getAns(nums,0,0);   \\n    }\\n};\\n```\\nDo upvote if you liked the solution!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][2];\\n    int getAns(vector<int>&a,int i,int f){ //f is used to check if the first house is looted or not.\\n        if(i>=a.size())return 0;\\n        if(i==a.size()-1&&f)return 0; // if first house is looted, then he cannot loot in the last house.\\n        if(i==a.size()-1&&!f)return a[i]; // if first house is not looted, he will definitely loot the last house. \\n        if(dp[i][f]!=-1)return dp[i][f];\\n        if(i==0){\\n            \\n        return dp[i][f]=max(a[i]+getAns(a,i+2,1),getAns(a,i+1,0));// at i=0, we have to take both the condition, what will be the max value he get if it loots the first house versus what value he will get if he not loots the first house.\\n        }\\n        else{\\n            //if he will loot the current house, he cannot loot the next house so he will go to i+2 th house., and if he not loots the house he can go to i+1 th house. \\n            return dp[i][f]=max(a[i]+getAns(a,i+2,f),getAns(a,i+1,f));\\n            \\n        }\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return getAns(nums,0,0);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894003,
                "title": "c-one-pass-6-lines",
                "content": "Just process the first and last number (house) separately.\\n```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i)\\n\\t\\ta1 = exchange(a2, max(a1 + nums[i], a2)), b1 = exchange(b2, max(b1 + nums[i], b2));\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```\\n\\nCode below does exactly same thing:\\n```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i) {\\n\\t\\tint t = a1;\\n\\t\\ta1 = a2;\\n\\t\\ta2 = max(t + nums[i], a2);\\n\\t\\tt = b1;\\n\\t\\tb1 = b2;\\n\\t\\tb2 = max(t + nums[i], b2);\\n\\t}\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```\\n\\nIf you don\\'t know what => [std::exchange()](https://en.cppreference.com/w/cpp/utility/exchange) <= is",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i)\\n\\t\\ta1 = exchange(a2, max(a1 + nums[i], a2)), b1 = exchange(b2, max(b1 + nums[i], b2));\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```\n```cpp\\nint rob(vector<int>& nums) {\\n\\tif (nums.size() == 1) return nums[0];\\n\\tint a1 = 0, a2 = nums[0], b1 = 0, b2 = 0;\\n\\tfor (int i = 1; i < nums.size() - 1; ++i) {\\n\\t\\tint t = a1;\\n\\t\\ta1 = a2;\\n\\t\\ta2 = max(t + nums[i], a2);\\n\\t\\tt = b1;\\n\\t\\tb1 = b2;\\n\\t\\tb2 = max(t + nums[i], b2);\\n\\t}\\n\\tb2 = max(b1 + nums.back(), b2);\\n\\treturn max(a2, b2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540739,
                "title": "java-100-dp-solution-no-offset",
                "content": "Just try to find the best solution from two options:\\n1. Dont use the last entry.\\n2. Dont use the first entry.\\n\\n```class Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n                                 \\n        return Math.max(robHelper(nums, 0 , nums.length -1), robHelper(nums, 1 , nums.length)) ;\\n    }\\n    \\n    private int robHelper(int[] nums, int start, int end) {\\n        int[] result = new int[nums.length];\\n        result[start] = nums[start];\\n        result[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        for (int i = 2; i < end; i++){\\n            result[i] = Math.max(result[i - 1],result[i-2] + nums[i]);\\n        }\\n        return Math.max(result[end - 1], result[end - 2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n                                 \\n        return Math.max(robHelper(nums, 0 , nums.length -1), robHelper(nums, 1 , nums.length)) ;\\n    }\\n    \\n    private int robHelper(int[] nums, int start, int end) {\\n        int[] result = new int[nums.length];\\n        result[start] = nums[start];\\n        result[start + 1] = Math.max(nums[start], nums[start + 1]);\\n        for (int i = 2; i < end; i++){\\n            result[i] = Math.max(result[i - 1],result[i-2] + nums[i]);\\n        }\\n        return Math.max(result[end - 1], result[end - 2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409271,
                "title": "python-simple-solution-same-as-house-robber",
                "content": "\\tdef rob(nums):\\n\\t\\tif not nums:\\n\\t\\t\\treturn 0\\n\\t\\tif len(nums)==1:\\n\\t\\t\\treturn nums[0]\\n\\t\\tif len(nums)==2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tdp = nums[:3]+[0]*(len(nums)-3)\\n\\t\\tdp[2]+=nums[0]\\n\\t\\tfor i in range(3,len(nums)):\\n\\t\\t\\tdp[i]=nums[i]+ max(dp[i-2], dp[i-3])\\n\\t\\treturn max(dp[-1], dp[-2])\\n\\n\\tclass Solution:\\n\\t\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\t\\tif not nums:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn nums[0]\\n\\t\\t\\tif len(nums)==2:\\n\\t\\t\\t\\treturn max(nums)\\n\\t\\t\\treturn max([rob(nums[:-1]), rob(nums[1:])])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef rob(nums):\\n\\t\\tif not nums:\\n\\t\\t\\treturn 0\\n\\t\\tif len(nums)==1:\\n\\t\\t\\treturn nums[0]\\n\\t\\tif len(nums)==2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tdp = nums[:3]+[0]*(len(nums)-3)\\n\\t\\tdp[2]+=nums[0]\\n\\t\\tfor i in range(3,len(nums)):\\n\\t\\t\\tdp[i]=nums[i]+ max(dp[i-2], dp[i-3])\\n\\t\\treturn max(dp[-1], dp[-2])\\n\\n\\tclass Solution:\\n\\t\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\t\\tif not nums:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn nums[0]\\n\\t\\t\\tif len(nums)==2:\\n\\t\\t\\t\\treturn max(nums)\\n\\t\\t\\treturn max([rob(nums[:-1]), rob(nums[1:])])",
                "codeTag": "Java"
            },
            {
                "id": 156641,
                "title": "100-single-pass-python",
                "content": "```python\\nclass Solution:\\n    def rob(self, houses):\\n        n = len(houses)\\n        if n == 0:\\n            return 0\\n        if n <= 2:\\n            return max(houses)\\n        a = b = c = d = 0\\n        best = 0\\n        for i, x in enumerate(houses):\\n            if i < n-1:\\n                a, b = b, max(x+a, b)\\n            if i > 0:\\n                c, d = d, max(x+c, d)\\n            best = max(best, b, d)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, houses):\\n        n = len(houses)\\n        if n == 0:\\n            return 0\\n        if n <= 2:\\n            return max(houses)\\n        a = b = c = d = 0\\n        best = 0\\n        for i, x in enumerate(houses):\\n            if i < n-1:\\n                a, b = b, max(x+a, b)\\n            if i > 0:\\n                c, d = d, max(x+c, d)\\n            best = max(best, b, d)\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59966,
                "title": "intuitive-python-dp-solution-one-loop",
                "content": "Two cases:\\n1) Don't rob last house, then it becomes a House Robber I problem from House 1 to House n-1.\\n2) Don't rob first house, then it becomes a House Robber I problem from House 2 to House n.\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 0:\\n            return 0;\\n        elif len(nums) == 1:\\n            return nums[0];\\n        elif len(nums) == 2:\\n            return max(nums[0],nums[1]);\\n        elif len(nums) == 3:\\n            return max(nums[0],nums[1],nums[2]);\\n            \\n        dp1 = [0] * (len(nums)-1);\\n        dp2 = [0] * (len(nums)-1);\\n\\n        dp1[0] = nums[0];\\n        dp1[1] = max(nums[0],nums[1]);\\n        dp2[0] = nums[1];\\n        dp2[1] = max(nums[1],nums[2]);\\n\\n        for i in xrange(2,len(nums)-1):\\n            dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i]);\\n            dp2[i] = max(dp2[i-1],dp2[i-2]+nums[i+1]);\\n        \\n        return max(dp1[-1],dp2[-1]);\\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 0:\\n            return 0;\\n        elif len(nums) == 1:\\n            return nums[0];\\n        elif len(nums) == 2:\\n            return max(nums[0],nums[1]);\\n        elif len(nums) == 3:\\n            return max(nums[0],nums[1],nums[2]);\\n            \\n        dp1 = [0] * (len(nums)-1);\\n        dp2 = [0] * (len(nums)-1);\\n\\n        dp1[0] = nums[0];\\n        dp1[1] = max(nums[0],nums[1]);\\n        dp2[0] = nums[1];\\n        dp2[1] = max(nums[1],nums[2]);\\n\\n        for i in xrange(2,len(nums)-1):\\n            dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i]);\\n            dp2[i] = max(dp2[i-1],dp2[i-2]+nums[i+1]);\\n        \\n        return max(dp1[-1],dp2[-1]);\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 59999,
                "title": "java-solution-beats-96-of-submissions",
                "content": "I maintained 4 variables, \\n**firstInc**: the sum that includes the current element of nums[], and can also contain the first number of nums[];\\n\\n**firstExc**: the sum that excludes the current element of nums[], and can also contain the first number of nums[];\\n\\n**nonFirstInc**: the sum that includes the current element of nums[], and DOES NOT contain the first number of nums[];\\n\\n**nonFirstExc**: the sum that excludes the current element of nums[], and DOES NOT contain the first number of nums[];\\n\\n  \\n\\n      public class Solution {\\n            public int rob(int[] nums) {\\n                if(nums.length == 0) return 0;\\n                if(nums.length == 1) return nums[0];\\n                int firstInc = nums[0];\\n                int firstExc = 0;\\n                int nonFirstInc = 0;\\n                int nonFirstExc = 0;\\n                \\n                for(int i = 1; i < nums.length; i++) {\\n                    int preFirstInc = firstInc;\\n                    firstInc = firstExc + nums[i];\\n                    firstExc = Math.max(preFirstInc, firstExc);\\n                    \\n                    int preNFinc = nonFirstInc;\\n                    nonFirstInc = nonFirstExc + nums[i];\\n                    nonFirstExc = Math.max(preNFinc, nonFirstExc);\\n                }\\n                \\n                int maxInc = Math.min(firstInc, nonFirstInc);\\n                \\n                return Math.max(maxInc, firstExc);\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int rob(int[] nums) {\\n                if(nums.length == 0) return 0;\\n                if(nums.length == 1) return nums[0];\\n                int firstInc = nums[0];\\n                int firstExc = 0;\\n                int nonFirstInc = 0;\\n                int nonFirstExc = 0;\\n                \\n                for(int i = 1; i < nums.length; i++) {\\n                    int preFirstInc = firstInc;\\n                    firstInc = firstExc + nums[i];\\n                    firstExc = Math.max(preFirstInc, firstExc);\\n                    \\n                    int preNFinc = nonFirstInc;\\n                    nonFirstInc = nonFirstExc + nums[i];\\n                    nonFirstExc = Math.max(preNFinc, nonFirstExc);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4082265,
                "title": "java-easy-dp-beats-100-runtime-88-memory",
                "content": "**Logic**\\n\\nProblem is very similar to House Robber one and the logic remains mostly the same. I\\'d recommend you try that problem first as it\\'s essentially the foundation for this one. But to quickly go over the base logic, we can break this problem into it\\'s subproblems by simply looking at the max value obtainable in a growing subarray from 1 to n, where n is the length of the array. Since we can\\'t take two adjacent cells, then our dichotemy becomes whether we take the current cell and exclude his neighbors or skip the cell. We can express this in our bellman equation as follows:\\n\\nSolution[i] = max {\\n\\t//take current cell\\n\\tsolution[i-2] + nums[i]\\n\\t//skip cell\\n\\tsolution[i-1]\\n}\\n\\nwhere solution[i] represents the max value at that current index or subarray.\\n\\nThe extra consideration in House Robber II is that taking the start house prevents you from taking the end house as they are neighbors. The question becomes whether to take the start or the end house, how can we do that without breaking the definition of our solution array where each cell is meant to represent the max up until that index? One such way is to add an extra dimension to our solution matrix, or create two arrays. One representing the path where we take the start house, and the other the path where we don\\'t take the start house (where we can possibly take the end house). We can then return the max of the end of these two arrays which should hold the max value possible for that array whether we take the start or end house.\\n\\n**Algorithm**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n\\t\\t//2 solution arrays\\n        int[][] solution = new int[nums.length][2];\\n        \\n        if(nums.length == 1)\\n            return nums[0];\\n        \\n\\t\\t//base cases\\n        solution[0][0] = nums[0];\\n        solution[0][1] = 0;\\n        solution[1][0] = solution[0][0];\\n        solution[1][1] = nums[1];\\n        \\n\\t\\t//iterate over solution array\\n        for(int i = 2; i < solution.length; i++){\\n\\t\\t\\t//if on last house, set path with the start house = to prior max\\n\\t\\t\\t//keep dichotemy of take or leave cell on the path without the start house\\n            if(i == solution.length-1){\\n                solution[i][0] = solution[i-1][0];\\n                solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n                break;\\n            }\\n\\t\\t\\t//Bellman Equation\\n            solution[i][0] = Math.max(solution[i-2][0] + nums[i], solution[i-1][0]);\\n            solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n        }\\n        \\n\\t\\t//return max of path without and with start house which is our solution\\n        return Math.max(solution[nums.length-1][1], solution[nums.length-1][0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n\\t\\t//2 solution arrays\\n        int[][] solution = new int[nums.length][2];\\n        \\n        if(nums.length == 1)\\n            return nums[0];\\n        \\n\\t\\t//base cases\\n        solution[0][0] = nums[0];\\n        solution[0][1] = 0;\\n        solution[1][0] = solution[0][0];\\n        solution[1][1] = nums[1];\\n        \\n\\t\\t//iterate over solution array\\n        for(int i = 2; i < solution.length; i++){\\n\\t\\t\\t//if on last house, set path with the start house = to prior max\\n\\t\\t\\t//keep dichotemy of take or leave cell on the path without the start house\\n            if(i == solution.length-1){\\n                solution[i][0] = solution[i-1][0];\\n                solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n                break;\\n            }\\n\\t\\t\\t//Bellman Equation\\n            solution[i][0] = Math.max(solution[i-2][0] + nums[i], solution[i-1][0]);\\n            solution[i][1] = Math.max(solution[i-2][1] + nums[i], solution[i-1][1]);\\n        }\\n        \\n\\t\\t//return max of path without and with start house which is our solution\\n        return Math.max(solution[nums.length-1][1], solution[nums.length-1][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885713,
                "title": "python-99-19-faster-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(a,n):\\n            n=len(a)\\n            prev=a[0]\\n            prev2=0\\n            curr=0\\n            for i in range(1,n):\\n                pick=a[i]\\n                if i>1:\\n                    pick+=prev2\\n                non_pick=prev\\n                curr=max(pick,non_pick)\\n                prev2=prev\\n                prev=curr\\n            return prev\\n        if len(nums)==1:\\n            return nums[0]\\n        n=len(nums)\\n        return max(solve(nums[1:],n),solve(nums[:-1],n))\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def solve(a,n):\\n            n=len(a)\\n            prev=a[0]\\n            prev2=0\\n            curr=0\\n            for i in range(1,n):\\n                pick=a[i]\\n                if i>1:\\n                    pick+=prev2\\n                non_pick=prev\\n                curr=max(pick,non_pick)\\n                prev2=prev\\n                prev=curr\\n            return prev\\n        if len(nums)==1:\\n            return nums[0]\\n        n=len(nums)\\n        return max(solve(nums[1:],n),solve(nums[:-1],n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881298,
                "title": "memoization-tabulation-space-optimization",
                "content": "**Memoization**\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N) + O(N) (recursive stack space + dp array space)\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1); \\n        int x = solve(nums,0,n-1,dp);\\n        Arrays.fill(dp,-1); \\n        int y = solve(nums,1,n,dp);\\n        return Math.max(x,y);\\n    }\\n    public int solve(int[] nums, int idx, int n, int dp[]){\\n       if(idx>=n){\\n           return 0;\\n       }\\n       if(dp[idx]!=-1){\\n           return dp[idx];\\n       }\\n       return dp[idx]=Math.max(nums[idx] + solve(nums,idx+2,n,dp), 0 + solve(nums,idx+1,n,dp));\\n    }\\n}\\n```\\n\\n**Tabulation**\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N) (dp array space)\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst,dp),solve(includelast,dp));\\n    }\\n    public int solve(int[] nums,int dp[]){\\n        dp[nums.length] = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=dp[i+2];\\n            }\\n            int nottake = 0 + dp[i+1];\\n            dp[i] = Math.max(take,nottake);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n**Space Optimization**\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1)\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst),solve(includelast));\\n    }\\n    public int solve(int[] nums){\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=prev2;\\n            }\\n            int nottake = 0 + prev1;\\n            int cur = Math.max(take,nottake);\\n            prev2 = prev1;\\n            prev1 = cur;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1); \\n        int x = solve(nums,0,n-1,dp);\\n        Arrays.fill(dp,-1); \\n        int y = solve(nums,1,n,dp);\\n        return Math.max(x,y);\\n    }\\n    public int solve(int[] nums, int idx, int n, int dp[]){\\n       if(idx>=n){\\n           return 0;\\n       }\\n       if(dp[idx]!=-1){\\n           return dp[idx];\\n       }\\n       return dp[idx]=Math.max(nums[idx] + solve(nums,idx+2,n,dp), 0 + solve(nums,idx+1,n,dp));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst,dp),solve(includelast,dp));\\n    }\\n    public int solve(int[] nums,int dp[]){\\n        dp[nums.length] = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=dp[i+2];\\n            }\\n            int nottake = 0 + dp[i+1];\\n            dp[i] = Math.max(take,nottake);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(nums.length == 1) \\n            return nums[0];\\n        int includefirst[] = new int[n];\\n        int includelast[] = new int[n];\\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                includefirst[i] = nums[i];\\n            }\\n            if(i!=n-1){\\n                includelast[i] = nums[i];\\n            }\\n        }\\n        return Math.max(solve(includefirst),solve(includelast));\\n    }\\n    public int solve(int[] nums){\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int take = nums[i];\\n            if(i<nums.length-2){\\n                take+=prev2;\\n            }\\n            int nottake = 0 + prev1;\\n            int cur = Math.max(take,nottake);\\n            prev2 = prev1;\\n            prev1 = cur;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843713,
                "title": "easy-java-solution-beats-100-tabulation-with-space-optimisation-dp",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n\\n        int n = nums.length;\\n        if(n == 1) {\\n            return nums[0];\\n        }\\n        \\n        return Math.max(maxMoney(nums, 0, n - 1), maxMoney(nums, 1, n));\\n    }\\n\\n    static int maxMoney(int[] nums, int start, int end) {\\n\\n        int prev2 = 0;\\n        int prev1 = nums[start];\\n\\n        for(int i = start + 1; i < end; i++) {\\n            int include = prev2 + nums[i];\\n            int exclude = prev1;\\n            int curri = Math.max(include, exclude);\\n            prev2 = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n}\\n```\\n\\n![cat-min.jpeg](https://assets.leetcode.com/users/images/b7d42ed5-428d-4958-abcd-b71eeb9e75c1_1690819411.6471684.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n\\n        int n = nums.length;\\n        if(n == 1) {\\n            return nums[0];\\n        }\\n        \\n        return Math.max(maxMoney(nums, 0, n - 1), maxMoney(nums, 1, n));\\n    }\\n\\n    static int maxMoney(int[] nums, int start, int end) {\\n\\n        int prev2 = 0;\\n        int prev1 = nums[start];\\n\\n        for(int i = start + 1; i < end; i++) {\\n            int include = prev2 + nums[i];\\n            int exclude = prev1;\\n            int curri = Math.max(include, exclude);\\n            prev2 = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717902,
                "title": "0-n-space-solution-using-c",
                "content": "\\n# Approach\\nSince the houses are arranged in a circle, we need to consider two scenarios:\\na. Rob the first house and exclude the last house.\\nb. Rob the last house and exclude the first house.\\n\\nTo handle these scenarios, we can break down the problem into two separate instances of the House Robber problem:\\na. Rob houses from index 0 to n-2 (excluding the last house).\\nb. Rob houses from index 1 to n-1 (excluding the first house).\\n\\nWe can use a similar dynamic programming approach as in the original House Robber problem to calculate the maximum amount of money that can be robbed in each scenario.\\n\\nFor each scenario, we maintain two variables to keep track of the maximum amount of money that can be robbed up to the current house:\\na. prev1: Maximum amount of money that can be robbed up to the previous house.\\nb. prev2: Maximum amount of money that can be robbed up to the second previous house.\\n\\nWe iterate through the house array and calculate the maximum amount by considering whether to include the current house or exclude it:\\na. include = prev2 + current house value\\nb. exclude = prev1\\n\\nUpdate prev2 and prev1 for the next iteration:\\na. prev2 = prev1\\nb. prev1 = max(include, exclude)\\n\\nFinally, return the maximum amount of money obtained from the two scenarios: max(max1, max2).\\n\\nBy breaking down the problem into two instances of the House Robber problem and considering the maximum amount that can be robbed in each scenario, we can solve the House Robber II problem efficiently.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) {\\n            return 0;\\n        } else if (n == 1) {\\n            return nums[0];\\n        }\\n\\n        // Calculate the maximum amount by considering two cases:\\n        // 1. Exclude the first house and consider houses from index 1 to n-1.\\n        // 2. Exclude the last house and consider houses from index 0 to n-2.\\n        int max1 = robHelper(nums, 1, n - 1);\\n        int max2 = robHelper(nums, 0, n - 2);\\n\\n        // Return the maximum amount from the two cases.\\n        return max(max1, max2);\\n    }\\n\\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int prev2 = 0;\\n        int prev1 = 0;\\n\\n        for (int i = start; i <= end; i++) {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) {\\n            return 0;\\n        } else if (n == 1) {\\n            return nums[0];\\n        }\\n\\n        // Calculate the maximum amount by considering two cases:\\n        // 1. Exclude the first house and consider houses from index 1 to n-1.\\n        // 2. Exclude the last house and consider houses from index 0 to n-2.\\n        int max1 = robHelper(nums, 1, n - 1);\\n        int max2 = robHelper(nums, 0, n - 2);\\n\\n        // Return the maximum amount from the two cases.\\n        return max(max1, max2);\\n    }\\n\\n    int robHelper(vector<int>& nums, int start, int end) {\\n        int prev2 = 0;\\n        int prev1 = 0;\\n\\n        for (int i = start; i <= end; i++) {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467225,
                "title": "house-robber-ii-easy-c-code-recursion-memoization",
                "content": "/* we are solving the question using 2 function one will solve from (0 to n-2) index and find out the maximum let say we are storing it in ans1 and another function will solve for (1 to n-1) and we will store it in ans2 and then return the maximum .\\n*/\\n\\nclass Solution {\\npublic:\\n     int solve2(vector<int>& nums , int n  , vector<int>&dp2){\\n        \\n        if(n == nums.size()-2)\\n            return nums[nums.size()-2];\\n        \\n        if(n >= nums.size()-1)\\n            return 0 ;\\n        \\n        if(dp2[n] != -1){\\n            return dp2[n];\\n        }\\n        \\n        int include = nums[n] + solve2(nums , n+2 , dp2);\\n        int exclude = 0 + solve2(nums , n+1 , dp2);\\n        \\n        return dp2[n] =  max(include ,exclude);\\n    }\\n     int solve1(vector<int>& nums , int n  , vector<int>&dp){\\n        \\n        if(n == 1)\\n            return nums[1];\\n        \\n        if(n <= 0)\\n            return 0 ;\\n        \\n        if(dp[n] != -1){\\n            return dp[n];\\n        }\\n        \\n        int include = nums[n] + solve1(nums , n-2 , dp);\\n        int exclude = 0 + solve1(nums , n-1 , dp);\\n        \\n        return dp[n] =  max(include ,exclude);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> dp(n+1 , -1);\\n         vector<int> dp2(n+1 , -1);\\n        int ans1 = solve1(nums , n-1 ,dp);\\n        int ans2 = solve2(nums , 0 , dp2);\\n        return max(ans1 , ans2);\\n\\n        \\n        //int rob(vector<int>& nums) {\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int solve2(vector<int>& nums , int n  , vector<int>&dp2){\\n        \\n        if(n == nums.size()-2)\\n            return nums[nums.size()-2];\\n        \\n        if(n >= nums.size()-1)\\n            return 0 ;\\n        \\n        if(dp2[n] != -1){\\n            return dp2[n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3389174,
                "title": "beats-100-max-adjacent-sum-easy-approach-c",
                "content": "# Intuition and Approach\\n> ***This is just the extended version of max adjacent sum problem.**\\nIf you dont know how to find max adjacent sum then please go through that problem(i.e. House Robber I on leetcode)*\\n\\nThe intution for solving this problem is that if we take first house then we cant rob last house and vice versa if we rob last house then we cant rob first house\\n\\nso with that observation we have to divide the nums vector in two parts such that one part have first house but no last house and second part have last but not the first house\\n\\nthen we can calculate max adjacent sum in both of them and then return the max from both.\\n*refer code \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //code to find max adjacent sum\\n    int max_non_adj(vector<int>& n,int start,int end){\\n        int prev=n[start];\\n        int prev1=0;\\n\\n        int ans=max(prev,prev1);\\n\\n        for(int i=start+1;i<end;i++){\\n            int incl=prev1+n[i];\\n            int excl=prev+0;\\n\\n            ans=max(incl,excl);\\n\\n            prev1=prev;\\n            prev=ans;\\n        }\\n\\n        return ans;\\n    }\\n    //main function\\n    int rob(vector<int>& n) {\\n        int a=n.size();        \\n\\n        if(a==1){\\n            return n[0];\\n        }        \\n        int first =max_non_adj(n,0,a-1);//excluding last house\\n        int second =max_non_adj(n,1,a);//excluding first house\\n\\n        return max(first,second);//return the max of both\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //code to find max adjacent sum\\n    int max_non_adj(vector<int>& n,int start,int end){\\n        int prev=n[start];\\n        int prev1=0;\\n\\n        int ans=max(prev,prev1);\\n\\n        for(int i=start+1;i<end;i++){\\n            int incl=prev1+n[i];\\n            int excl=prev+0;\\n\\n            ans=max(incl,excl);\\n\\n            prev1=prev;\\n            prev=ans;\\n        }\\n\\n        return ans;\\n    }\\n    //main function\\n    int rob(vector<int>& n) {\\n        int a=n.size();        \\n\\n        if(a==1){\\n            return n[0];\\n        }        \\n        int first =max_non_adj(n,0,a-1);//excluding last house\\n        int second =max_non_adj(n,1,a);//excluding first house\\n\\n        return max(first,second);//return the max of both\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357003,
                "title": "dp-solution-easy-to-understand",
                "content": "\\n***Prerequisite:*** Recursion, DP, Max Sum of Non-Adjacent Elements in an array.\\n\\n# Approach\\nCreate two vectors containing elements other than the first and the last respectively. Then proceed with the same trick just like we do while calculating the Max Sum of Non-Adjacent Elements of array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int> a){\\n        int n = a.size();\\n        int prev = a[0];\\n        int prev2 = 0;\\n        for(int i = 1; i < n; i ++){\\n            int take = a[i];\\n                if(i > 1) take += prev2;\\n            int notTake = 0 + prev;\\n            int curri = max( take, notTake);\\n            prev2 = prev;\\n            prev = curri;\\n        }\\n        return prev;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp1,tmp2;\\n        if(n == 1) return nums[0];\\n        for(int i = 0; i < n; i ++){\\n            if(i != 0) tmp1.push_back(nums[i]);\\n            if(i != n-1) tmp2.push_back(nums[i]);\\n        }\\n        return max(solve(tmp1),solve(tmp2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int> a){\\n        int n = a.size();\\n        int prev = a[0];\\n        int prev2 = 0;\\n        for(int i = 1; i < n; i ++){\\n            int take = a[i];\\n                if(i > 1) take += prev2;\\n            int notTake = 0 + prev;\\n            int curri = max( take, notTake);\\n            prev2 = prev;\\n            prev = curri;\\n        }\\n        return prev;\\n    }\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp1,tmp2;\\n        if(n == 1) return nums[0];\\n        for(int i = 0; i < n; i ++){\\n            if(i != 0) tmp1.push_back(nums[i]);\\n            if(i != n-1) tmp2.push_back(nums[i]);\\n        }\\n        return max(solve(tmp1),solve(tmp2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345343,
                "title": "easy-c-solution-using-previous-house-robber-code",
                "content": "# Intuition\\nWe can see that only the last and first houses(elements) cannot be taken together, thus, we can use the same code as in house robber 1, and pass it 2 arrays, one not containing the first element, and the other not containing the last element. As, the answer will def lie in one of those two arrays. Thus, we return the max of the two.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans(vector<int> nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++) {\\n            int curr_i=max(nums[i]+prev2,prev1);\\n            prev2=prev1;\\n            prev1=curr_i;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> v1(nums.begin()+1,nums.end());\\n        vector<int> v2(nums.begin(),nums.end()-1);\\n        return max(ans(v1),ans(v2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans(vector<int> nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        int prev2=nums[0];\\n        int prev1=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++) {\\n            int curr_i=max(nums[i]+prev2,prev1);\\n            prev2=prev1;\\n            prev1=curr_i;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> v1(nums.begin()+1,nums.end());\\n        vector<int> v2(nums.begin(),nums.end()-1);\\n        return max(ans(v1),ans(v2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188968,
                "title": "house-robber-ii-sabse-easy-solution-no-dp-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Reference\\nhttps://leetcode.com/problems/house-robber/solutions/3188808/sabse-easy-solution-no-dp-100-faster/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        // excluding last element\\n        int prev1 = nums[0], prev2 = 0;\\n        for(int i = 1; i<n-1; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int first = max(prev1, prev2);\\n        \\n        //excluding first element\\n        prev1 = nums[1], prev2 = 0;\\n        for(int i = 2; i<n; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int last = max(prev1, prev2);\\n        \\n        //returning the max of first and last\\n        return max(first, last);\\n    }\\n};\\n```\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        // excluding last element\\n        int prev1 = nums[0], prev2 = 0;\\n        for(int i = 1; i<n-1; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int first = max(prev1, prev2);\\n        \\n        //excluding first element\\n        prev1 = nums[1], prev2 = 0;\\n        for(int i = 2; i<n; i++){\\n            int temp = prev2;\\n            prev2 = max(prev1,prev2);\\n            prev1 = nums[i] + temp;\\n        }\\n        int last = max(prev1, prev2);\\n        \\n        //returning the max of first and last\\n        return max(first, last);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108739,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n        return nums[0];\\n        if(nums.length == 2)\\n        return Math.max(nums[0], nums[1]);\\n        \\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end) {        \\n        if(start == end)\\n        return nums[start];\\n        \\n        int money[] = new int[nums.length];\\n        \\n        money[start] = nums[start];\\n        \\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        return money[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1)\\n        return nums[0];\\n        if(nums.length == 2)\\n        return Math.max(nums[0], nums[1]);\\n        \\n        int resultWithFirst = solve(nums, 0, nums.length - 2);\\n        int resultWithLast = solve(nums, 1, nums.length - 1);\\n        \\n        return Math.max(resultWithFirst, resultWithLast);\\n    }\\n    \\n    public int solve(int[] nums, int start, int end) {        \\n        if(start == end)\\n        return nums[start];\\n        \\n        int money[] = new int[nums.length];\\n        \\n        money[start] = nums[start];\\n        \\n        money[start + 1] = Math.max(nums[start + 1], nums[start]);\\n        \\n        for (int i = start + 2; i <= end; ++i)\\n\\n            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);\\n        \\n        return money[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030738,
                "title": "c-fast-dp-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* recursion logic for reference only\\n    unordered_map<int,int> memo;\\n    int profit (vector<int>& nums, int house){\\n        if (memo.find(house)!= memo.end()){\\n            return memo[house];\\n        }\\n        if (house >= nums.size()){ //no more house to rob\\n            memo.emplace(house,0);\\n            return 0;\\n        }\\n\\n        int profit1 = nums[house] + profit(nums, house+2);//rob this house\\n        int profit2 = profit(nums,house+1); //not rob this house\\n        memo.emplace(house,max(profit1,profit2));\\n        return memo[house];\\n    }\\n*/\\n    int rob(vector<int>& nums) {\\n        \\n        //if we don\\'t rob the first house, we can rob the last one\\n        //we just need to run the same dp as rob house I until house index number 1\\n        if (nums.size() == 1){\\n            return nums[0];\\n        }\\n        const int n = nums.size()+2;\\n        int dp1[n];\\n        dp1[n-1] = 0;\\n        dp1[n-2] = 0;\\n        for(int i=n-3; i>=1; i--){ //don\\'t rob the first house\\n            dp1[i] = max(nums[i]+ dp1[i+2],dp1[i+1]);\\n        }\\n        //if we rob the first house, we couldn\\'t rob the last one\\n        int dp2[n];\\n        dp2[n-1] = 0;\\n        dp2[n-2] = 0;\\n        dp2[n-3] = 0;//we set up the profit of last house as 0\\n\\n        for(int i=n-4; i>=0; i--){ // rob the first house\\n            dp2[i] = max(nums[i]+ dp2[i+2],dp2[i+1]);\\n        }\\n        return max(dp1[1], dp2[0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* recursion logic for reference only\\n    unordered_map<int,int> memo;\\n    int profit (vector<int>& nums, int house){\\n        if (memo.find(house)!= memo.end()){\\n            return memo[house];\\n        }\\n        if (house >= nums.size()){ //no more house to rob\\n            memo.emplace(house,0);\\n            return 0;\\n        }\\n\\n        int profit1 = nums[house] + profit(nums, house+2);//rob this house\\n        int profit2 = profit(nums,house+1); //not rob this house\\n        memo.emplace(house,max(profit1,profit2));\\n        return memo[house];\\n    }\\n*/\\n    int rob(vector<int>& nums) {\\n        \\n        //if we don\\'t rob the first house, we can rob the last one\\n        //we just need to run the same dp as rob house I until house index number 1\\n        if (nums.size() == 1){\\n            return nums[0];\\n        }\\n        const int n = nums.size()+2;\\n        int dp1[n];\\n        dp1[n-1] = 0;\\n        dp1[n-2] = 0;\\n        for(int i=n-3; i>=1; i--){ //don\\'t rob the first house\\n            dp1[i] = max(nums[i]+ dp1[i+2],dp1[i+1]);\\n        }\\n        //if we rob the first house, we couldn\\'t rob the last one\\n        int dp2[n];\\n        dp2[n-1] = 0;\\n        dp2[n-2] = 0;\\n        dp2[n-3] = 0;//we set up the profit of last house as 0\\n\\n        for(int i=n-4; i>=0; i--){ // rob the first house\\n            dp2[i] = max(nums[i]+ dp2[i+2],dp2[i+1]);\\n        }\\n        return max(dp1[1], dp2[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909931,
                "title": "beats-95-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return max(nums)\\n        def helper(nums):\\n            h1,h2 = 0,0\\n            for n in nums:\\n                h_n = max(n+h1,h2)\\n                h1 = h2\\n                h2 = h_n\\n            return h_n\\n        return max (helper(nums[1:]),helper(nums[:len(nums)-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return max(nums)\\n        def helper(nums):\\n            h1,h2 = 0,0\\n            for n in nums:\\n                h_n = max(n+h1,h2)\\n                h1 = h2\\n                h2 = h_n\\n            return h_n\\n        return max (helper(nums[1:]),helper(nums[:len(nums)-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892140,
                "title": "all-solutions-discussed",
                "content": "**PLS UPVOTE IF You like the SOLUTION:)**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIN THIS problem we reuse the HOUSE ROBBER-1 code \\nsince now the houses are in circular fashion so we cannot pick both first and last indices.\\n\\nThus we make two cases:\\n1. picking first house and not last.\\n2. picking last house but not first.\\n\\nand call the HOUSE ROBBER 1 CODE\\n\\nEXPLANATION OF HOUSE ROBBER\\nWriting BASIC RECURSION:\\nWE start from last index and for a particular index we have two cases that is\\npick - if picked we cannot pick the adjacent element on left side.\\nnot pick-not picked ,move to left index.\\n\\nBASE CASE:-\\nindex=0 :- this is only possible when we come through 2, thus we include this index in our sum as we want maximum.\\n\\nindex<0:- we return 0 since no element exists.\\nALL THREE APPROACHES DISCUSSION:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### Approach 1\\nWe optimise our recursion code by storing the previously already calculated values so that if needed again we can easily look up.(DONE by MEMOISATION)\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N) + O(N)     i.e stack space and array space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Approach 2\\nWe Leave recursion and move to TABULATION thus we now go from bottom to top. Thus we will reach the asked ans by starting from the base cases.\\nSo at a moment, we will do dp[i]=max(pick,notpick) {see code}and in the end return dp[n-1] and make the code iterative.\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)     only array space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Approach 3\\nWe Leave space in Iterative method and we notice a pattern that at a given moment we  are actually doing this:\\n            int curr=max(pick,notpick);\\n            prev2=prev1;\\n            prev1=curr;\\n\\nand our ans in actually prev 1. Thus leaving the extra space here as well\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n#### Solution 1\\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        if(index==chk)\\n            return nums.at(index);\\n        if(index<chk)\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int pick=nums.at(index)+maxm(index-2,chk,nums,dp);\\n        int notpick=0+maxm(index-1,chk,nums,dp);\\n        return dp[index]=max(pick,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};    \\n```\\n#### Solution 2\\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        dp[chk]=nums.at(chk);\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=dp[i-2];\\n            int notpick=0+dp[i-1];\\n            dp[i]=max(pick,notpick);\\n        }\\n        return dp[index];\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n\\n```\\n\\n#### Solution 3\\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums){\\n        int prev1=nums.at(chk),prev2=0;\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=prev2;\\n            int notpick=0+prev1;\\n            int curr=max(pick,notpick);\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        int removeFirst=maxm(index,1,nums);\\n        int removeEnd=maxm(index-1,0,nums);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        if(index==chk)\\n            return nums.at(index);\\n        if(index<chk)\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int pick=nums.at(index)+maxm(index-2,chk,nums,dp);\\n        int notpick=0+maxm(index-1,chk,nums,dp);\\n        return dp[index]=max(pick,notpick);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};    \\n```\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums,vector<int>&dp){\\n        dp[chk]=nums.at(chk);\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=dp[i-2];\\n            int notpick=0+dp[i-1];\\n            dp[i]=max(pick,notpick);\\n        }\\n        return dp[index];\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        vector<int>dp(index+1,-1);\\n        int removeFirst=maxm(index,1,nums,dp);\\n        for(int i{0};i<=index;++i){\\n            dp.at(i)=-1;\\n        }\\n        int removeEnd=maxm(index-1,0,nums,dp);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxm(int index,int chk,vector<int>&nums){\\n        int prev1=nums.at(chk),prev2=0;\\n        for(int i{chk+1};i<=index;++i){\\n            int pick=nums.at(i);\\n            if(i>=(chk+2))\\n                pick+=prev2;\\n            int notpick=0+prev1;\\n            int curr=max(pick,notpick);\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.at(0);\\n        int index=nums.size()-1;\\n        int removeFirst=maxm(index,1,nums);\\n        int removeEnd=maxm(index-1,0,nums);\\n        return max(removeFirst,removeEnd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830306,
                "title": "easy-to-understand-c-solution",
                "content": "**class Solution {\\npublic:**\\n    \\n    int sol(vector<vector<int>> &temp,int s,int e,vector<int> &nums,int n){\\n        //if lower index is greater than higher index or s or e go out of range\\n        if(s>e || s<0 || e>=n){\\n            return 0;\\n        }\\n        //if the ans is already computed\\n        else if(temp[s][e]!=-1){\\n            return temp[s][e];\\n        }\\n        //if there is a single element in the range\\n        else if(s==e){\\n            temp[s][e]=nums[s];\\n            return temp[s][e];\\n        }\\n        else{\\n            //temporary variavle\\n            int rt=0;\\n            for(int i=s;i<=e;i++){\\n                //ans = current element + ans from leftside + ans from rightside\\n                rt=max(rt,nums[i]+sol(temp,s,i-2,nums,n)+sol(temp,i+2,e,nums,n));\\n            }\\n            //update th computed solution and return it\\n            temp[s][e]=rt;\\n            return rt;\\n        }\\n        return temp[s][e];\\n    }\\n\\n    \\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n         int ans=0;\\n        //temp vector stores solution for smaller sub cases\\n        vector<vector<int>> temp(n,vector<int>(n,-1));\\n       \\n        \\n        //Case 1  0th element is included\\n        ans=max(ans,nums[0]+sol(temp,2,n-2,nums,n));\\n        \\n        //Case 2 last element is included\\n        ans=max(ans,nums[n-1]+sol(temp,1,n-3,nums,n));\\n        \\n        //Case 3 both the elements are excluded\\n        ans=max(ans,sol(temp,1,n-2,nums,n));\\n      \\n        return ans;\\n    }\\n**};**",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:**\\n    \\n    int sol(vector<vector<int>> &temp,int s,int e,vector<int> &nums,int n){\\n        //if lower index is greater than higher index or s or e go out of range\\n        if(s>e || s<0 || e>=n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2764664,
                "title": "clear-and-concise-video-explanation",
                "content": "I posted a clear and concise video explanation here: https://youtu.be/DL8Ybsy-yq8\\nIt shows the intuition behind the problem and time and space complexities, as well as the code.\\nHope it helps!",
                "solutionTags": [
                    "Python"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2725145,
                "title": "99-faster-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo1=[-1 for i in range(len(nums)-1)]\\n        memo2=[-1 for i in range(len(nums)-1)]\\n        res1= self.solve(nums[0:len(nums)-1],len(nums)-2,memo1)\\n        res2= self.solve(nums[1:],len(nums)-2,memo2)\\n        return max(res1,res2)\\n    def solve(self,nums,n,memo):\\n        if n<0:\\n            return 0\\n        if memo[n]!=-1:\\n            return memo[n]\\n        memo[n]= max(nums[n]+self.solve(nums,n-2,memo),self.solve(nums,n-1,memo))\\n        return memo[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        memo1=[-1 for i in range(len(nums)-1)]\\n        memo2=[-1 for i in range(len(nums)-1)]\\n        res1= self.solve(nums[0:len(nums)-1],len(nums)-2,memo1)\\n        res2= self.solve(nums[1:],len(nums)-2,memo2)\\n        return max(res1,res2)\\n    def solve(self,nums,n,memo):\\n        if n<0:\\n            return 0\\n        if memo[n]!=-1:\\n            return memo[n]\\n        memo[n]= max(nums[n]+self.solve(nums,n-2,memo),self.solve(nums,n-1,memo))\\n        return memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722568,
                "title": "100-c-solution-commented-and-explained",
                "content": "My dp idea(maybe not the most optimal) is to **create 2 array of size n-1**, arr0 and arr1\\n\\narr0[i] is the max the thief can take until the i\\'th house, stop at arr0[n-1] (don\\'t take into account the last house)\\narr1[i] is the max the thief can take until the (i+1)\\'th house without taking the first house\\n\\n**Define with :**\\narr0[0] = nums[0] | Max(nums[0],nums[1])\\narr1[0] = nums[1] | Max(nums[1],nums[2])\\n\\nand **iterate with** :\\narr0[i]=Max(arr0[i-2]+nums[i],arr0[i-1])\\narr1[i]=Max(arr1[i-2]+nums[i+1],arr1[i-1])\\n\\n**for example** with nums = [10,3,2,1,10] we will have\\narr0=[10,10,12,12]\\narr1=[3,3,4,13]\\nans = max(13,12) = 13\\n\\n**The answer to the problem is** the max of the last element between the 2 array **because the tief can\\'t take the first house and the last house** :\\nanswer = Max(arr0[n-2],arr1[n-2])\\n\\nWhich make\\n**Time Complexity : O(n)**  and reach 100% in time speed\\n**Space Complexity : O(n)**\\n\\nI found this answer by doing several tests with a pen and  paper\\n\\n```\\nint max(int a, int b)  //return the max\\n{\\n    if (a<b){return b;}\\n    return a;\\n}\\n\\nint rob(int* nums, int numsSize)\\n{\\n    if (numsSize == 1 ){return nums[0];}                //if n=1 or n=2\\n    if (numsSize == 2 ){return max(nums[0],nums[1]);}\\n    \\n    int* arr1 =(int*) malloc((numsSize-1)*sizeof(int)); //allocate memory with malloc\\n    int* arr0 =(int*) malloc((numsSize-1)*sizeof(int));\\n    \\n    arr1[0]=nums[1];      //initiate the first 2 elements of each array\\n    arr0[0]=nums[0];\\n    arr1[1]=max(nums[1],nums[2]);\\n    arr0[1]=max(nums[0],nums[1]);\\n    \\n    for (int i = 2;i<(numsSize-1);i++)\\n    {\\n        arr0[i]=max(arr0[i-2]+nums[i],arr0[i-1]);   //iterate each array until the end\\n        arr1[i]=max(arr1[i-2]+nums[i+1],arr1[i-1]);\\n    }\\n    int ans = max(arr0[numsSize-2],arr1[numsSize-2]); \\n\\t//save the answer in order to free both arrays before sending the result\\n    \\n    free(arr1);  //free allocated memory\\n    free(arr0);\\n    return(ans);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint max(int a, int b)  //return the max\\n{\\n    if (a<b){return b;}\\n    return a;\\n}\\n\\nint rob(int* nums, int numsSize)\\n{\\n    if (numsSize == 1 ){return nums[0];}                //if n=1 or n=2\\n    if (numsSize == 2 ){return max(nums[0],nums[1]);}\\n    \\n    int* arr1 =(int*) malloc((numsSize-1)*sizeof(int)); //allocate memory with malloc\\n    int* arr0 =(int*) malloc((numsSize-1)*sizeof(int));\\n    \\n    arr1[0]=nums[1];      //initiate the first 2 elements of each array\\n    arr0[0]=nums[0];\\n    arr1[1]=max(nums[1],nums[2]);\\n    arr0[1]=max(nums[0],nums[1]);\\n    \\n    for (int i = 2;i<(numsSize-1);i++)\\n    {\\n        arr0[i]=max(arr0[i-2]+nums[i],arr0[i-1]);   //iterate each array until the end\\n        arr1[i]=max(arr1[i-2]+nums[i+1],arr1[i-1]);\\n    }\\n    int ans = max(arr0[numsSize-2],arr1[numsSize-2]); \\n\\t//save the answer in order to free both arrays before sending the result\\n    \\n    free(arr1);  //free allocated memory\\n    free(arr0);\\n    return(ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494250,
                "title": "easy-solution-beats-100",
                "content": "House robber 1 but passing two arrays\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n=nums.length;\\n        if(n==1)\\n            return nums[0];\\n        int[] t1=new int[n-1];\\n        int[] t2=new int[n-1];\\n        \\n\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n                t1[a]=nums[i];\\n                a++;\\n            }\\n            if(i!= nums.length-1){\\n                t2[b] =nums[i];\\n                b++;\\n            }\\n        }\\n        \\n        //max of array withput first and arr without last\\n        return Math.max(solve(t1),solve(t2));\\n        \\n    }\\n    \\n    static int solve(int[] arr){\\n        int n = arr.length;\\n        int prev = arr[0];\\n        int prev2 =0;\\n\\n        for(int i=1; i<n; i++){\\n            int pick = arr[i];\\n            if(i>1)\\n                pick += prev2;\\n            int nonPick = 0 + prev;\\n\\n            int cur_i = Math.max(pick, nonPick);\\n            prev2 = prev;\\n            prev= cur_i;\\n\\n        }\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n=nums.length;\\n        if(n==1)\\n            return nums[0];\\n        int[] t1=new int[n-1];\\n        int[] t2=new int[n-1];\\n        \\n\\n        int a=0,b=0;\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n                t1[a]=nums[i];\\n                a++;\\n            }\\n            if(i!= nums.length-1){\\n                t2[b] =nums[i];\\n                b++;\\n            }\\n        }\\n        \\n        //max of array withput first and arr without last\\n        return Math.max(solve(t1),solve(t2));\\n        \\n    }\\n    \\n    static int solve(int[] arr){\\n        int n = arr.length;\\n        int prev = arr[0];\\n        int prev2 =0;\\n\\n        for(int i=1; i<n; i++){\\n            int pick = arr[i];\\n            if(i>1)\\n                pick += prev2;\\n            int nonPick = 0 + prev;\\n\\n            int cur_i = Math.max(pick, nonPick);\\n            prev2 = prev;\\n            prev= cur_i;\\n\\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473326,
                "title": "c-easy-and-simple-without-dp",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\n int solve(vector<int>&nums){\\n        int n=nums.size();\\n        \\n         int prev2=0;\\n         int prev1=nums[0];\\n        for(int i=1;i<n;i++){\\n             int include= prev2+nums[i];\\n             int exclude=prev1+0;\\n             int ans=max(include,exclude);\\n            prev2=prev1;\\n            prev1=ans;\\n        }\\n        return prev1;\\n        \\n       \\n    }\\n    int rob(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if(n==0 ) return 0;\\n        if(n==1) return nums[0];\\n        vector<int>first,second;\\n        for(int i=0;i<n;i++){\\n            if(i!=n-1) first.push_back(nums[i]);\\n            if(i!=0) second.push_back(nums[i]);\\n        }\\n        return max(solve(first),solve(second));\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int solve(vector<int>&nums){\\n        int n=nums.size();\\n        \\n         int prev2=0;\\n         int prev1=nums[0];\\n        for(int i=1;i<n;i++){\\n             int include= prev2+nums[i];\\n             int exclude=prev1+0;\\n             int ans=max(include,exclude);\\n            prev2=prev1;\\n            prev1=ans;\\n        }\\n        return prev1;\\n        \\n       \\n    }\\n    int rob(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if(n==0 ) return 0;\\n        if(n==1) return nums[0];\\n        vector<int>first,second;\\n        for(int i=0;i<n;i++){\\n            if(i!=n-1) first.push_back(nums[i]);\\n            if(i!=0) second.push_back(nums[i]);\\n        }\\n        return max(solve(first),solve(second));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355020,
                "title": "python-dp-bottom-up-approach-easy-understanding-memory-better-than-80",
                "content": "## Very important: \\n1) When you create nested list, like this: any_list[x:y], you create a NEW list.  SO, if other function change it, in changes NOT any_list, but any_list[x:y].\\n2) It is pretty obvious, but just so you know, we use self.function, because that is how classes work. If you don\\'t understand it, go and read about classes.\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln < 4:\\n            return max(nums)\\n        elif ln == 4:\\n            return max(nums[0] + nums[2], nums[1] + nums[3])\\n        \\n        return max(self.counter(nums[:-1]), self.counter(nums[1:]))\\n    \\n    \\n    def counter(self, nums):\\n        nums[2] += nums[0]\\n        for x in range(3, len(nums)):\\n            nums[x] += max(nums[x - 2], nums[x - 3])\\n        return max(nums[-1], nums[-2])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln < 4:\\n            return max(nums)\\n        elif ln == 4:\\n            return max(nums[0] + nums[2], nums[1] + nums[3])\\n        \\n        return max(self.counter(nums[:-1]), self.counter(nums[1:]))\\n    \\n    \\n    def counter(self, nums):\\n        nums[2] += nums[0]\\n        for x in range(3, len(nums)):\\n            nums[x] += max(nums[x - 2], nums[x - 3])\\n        return max(nums[-1], nums[-2])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122322,
                "title": "c-greedy-dynamic-programming-faster-than-100-00-0-ms-explained",
                "content": "It was a good continuation to the [House Robber](https://leetcode.com/problems/house-robber/) problem and I was pretty satisfied with the time and space complexity I obtained.\\n\\n**Thinking Process:**\\nAll we need to do here is move our solution up a level. What I mean by that is that we need to decide the inclusion of nums[0] manually and based on that decision we need to do the calculate the answer of the rest of the part, exactly the same way as we did in House Robber problem.\\n\\n- When nums[0] is included:\\n\\tIn this case our only option is to exclude nums[1] (Since nums[0] is included and we cannot rob two adjacent houses). Hence, it is logical to calculate an ans `ans1` according to the nums array from index i=2 to i=n. But we need to make sure that the last element is excluded.\\n- When nums[0] is excluded:\\n\\tIn this case we just need to find out the ans `ans2` based on  the nums array from index i=1 to i=n because we already excluded nums[0] and can now choose for i=1 and so on.\\n\\t\\nThe answer would be the maximum of `ans1` and `ans2`.\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int in1ex = 0;\\n        int ex1ex = 0;\\n        \\n        for(int i=1; i<nums.size(); ++i)  {\\n            int tempin = ex1ex + nums[i];\\n            int tempex = max(ex1ex, in1ex);\\n            \\n            in1ex = tempin;\\n            ex1ex = tempex;\\n        }\\n        \\n        int ans1 = max(in1ex, ex1ex);\\n        \\n        int in1in = nums[0];\\n        int ex1in = nums[0];\\n        \\n        \\n        for(int i=2; i<nums.size(); ++i)  {\\n            int tempin = ex1in + nums[i];\\n            int tempex = max(ex1in, in1in);\\n            \\n            in1in = tempin;\\n            ex1in = tempex;\\n        }\\n        \\n        int ans2 = ex1in;\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n        \\n    }\\n};\\n```\\nPlease upvote if my solution was of any help.\\nP.S.: Comment for any query.\\nHave a great day ;)\\n![image](https://assets.leetcode.com/users/images/57ada758-ab5e-49f0-b3fe-c037dab3eab5_1654603860.3649662.png)\\n\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int in1ex = 0;\\n        int ex1ex = 0;\\n        \\n        for(int i=1; i<nums.size(); ++i)  {\\n            int tempin = ex1ex + nums[i];\\n            int tempex = max(ex1ex, in1ex);\\n            \\n            in1ex = tempin;\\n            ex1ex = tempex;\\n        }\\n        \\n        int ans1 = max(in1ex, ex1ex);\\n        \\n        int in1in = nums[0];\\n        int ex1in = nums[0];\\n        \\n        \\n        for(int i=2; i<nums.size(); ++i)  {\\n            int tempin = ex1in + nums[i];\\n            int tempex = max(ex1in, in1in);\\n            \\n            in1in = tempin;\\n            ex1in = tempex;\\n        }\\n        \\n        int ans2 = ex1in;\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047805,
                "title": "dp-is-new-love",
                "content": "similar as house robber only difference making that in one run we can either include start point or end point \\n```\\nclass Solution {\\n     public int fun(int[]dp,int nums[], int s,int e){\\n            if(e<s)return 0;\\n            if(dp[e]!=-1)return dp[e];\\n            if(e==s+1)return Math.max(nums[e],nums[e-1]);\\n            if(e==s)return nums[s];\\n            return dp[e]=Math.max(nums[e]+fun(dp,nums,s,e-2),fun(dp,nums,s,e-1));\\n}\\n    public int rob(int[] nums) {\\n        if (nums.length==1)return nums[0];\\n       int dp[]=new int [nums.length];\\n        for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int a=fun(dp,nums,0,dp.length-2);\\n         for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int b=fun(dp,nums,1,nums.length-1);\\n        return Math.max(a,b);\\n       // return Math.max(fun(dp,nums,0,dp.length-2),fun(dp,nums,1,nums.length-1));\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     public int fun(int[]dp,int nums[], int s,int e){\\n            if(e<s)return 0;\\n            if(dp[e]!=-1)return dp[e];\\n            if(e==s+1)return Math.max(nums[e],nums[e-1]);\\n            if(e==s)return nums[s];\\n            return dp[e]=Math.max(nums[e]+fun(dp,nums,s,e-2),fun(dp,nums,s,e-1));\\n}\\n    public int rob(int[] nums) {\\n        if (nums.length==1)return nums[0];\\n       int dp[]=new int [nums.length];\\n        for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int a=fun(dp,nums,0,dp.length-2);\\n         for(int i=0;i<dp.length;i++)dp[i]=-1;\\n        int b=fun(dp,nums,1,nums.length-1);\\n        return Math.max(a,b);\\n       // return Math.max(fun(dp,nums,0,dp.length-2),fun(dp,nums,1,nums.length-1));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009646,
                "title": "self-explanatory-c-0-ms",
                "content": "**SELF-EXPLANATORY || C++ || 0 ms ||**\\nidea credits : [Tatv Kamdar](https://leetcode.com/kamdartatv1/)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        int prev = 0, prev2 = 0, curr = 0;\\n        // considering last element\\n        for(int i = 1; i < nums.size(); i++){\\n            curr = max(prev, prev2 + nums[i]);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int prev_ = 0, prev2_ = 0, curr_ = 0;\\n        // considering 1st element\\n        for(int i = 0; i < nums.size()-1; i++){\\n            curr_ = max(prev_, prev2_ + nums[i]);\\n            prev2_ = prev_;\\n            prev_ = curr_;\\n        }\\n        return max(curr, curr_);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        int prev = 0, prev2 = 0, curr = 0;\\n        // considering last element\\n        for(int i = 1; i < nums.size(); i++){\\n            curr = max(prev, prev2 + nums[i]);\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        int prev_ = 0, prev2_ = 0, curr_ = 0;\\n        // considering 1st element\\n        for(int i = 0; i < nums.size()-1; i++){\\n            curr_ = max(prev_, prev2_ + nums[i]);\\n            prev2_ = prev_;\\n            prev_ = curr_;\\n        }\\n        return max(curr, curr_);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008177,
                "title": "javascript-memoization-recursive-approach-dp-fast",
                "content": "```\\n// Recursive Approach: TLE\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    function helper(i, arr) {\\n        if (i < 0) return 0;\\n\\n        return Math.max(\\n            helper(i - 1, arr),\\n            arr[i] + helper(i - 2, arr)\\n        )\\n    }\\n\\n    const arr1 = nums.slice(0, nums.length - 1);\\n    const arr2 = nums.slice(1, nums.length);\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1), helper(n, arr2));\\n};\\n\\n\\n// Memoized Recursion\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    let dp1 = new Array(nums.length).fill(-1);\\n    let dp2 = [...dp1];\\n    function helper(i, arr, dp) {\\n        if (i < 0) return 0;\\n        if (dp[i] !== -1) return dp[i];\\n\\n        return dp[i] = Math.max(\\n            helper(i - 1, arr, dp),\\n            arr[i] + helper(i - 2, arr, dp)\\n        )\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1, dp1), helper(n, arr2, dp2));\\n};\\n\\n// Space optimized solution\\nvar rob = function (nums) {\\n    function helper(arr) {\\n        let rob1 = 0, rob2 = 0;\\n        for (let num of arr) {\\n            const tmp = Math.max(rob1 + num, rob2);\\n            rob1 = rob2;\\n            rob2 = tmp;\\n        }\\n        return rob2;\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(nums[0], helper(arr1), helper(arr2));\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursive Approach: TLE\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    function helper(i, arr) {\\n        if (i < 0) return 0;\\n\\n        return Math.max(\\n            helper(i - 1, arr),\\n            arr[i] + helper(i - 2, arr)\\n        )\\n    }\\n\\n    const arr1 = nums.slice(0, nums.length - 1);\\n    const arr2 = nums.slice(1, nums.length);\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1), helper(n, arr2));\\n};\\n\\n\\n// Memoized Recursion\\nvar rob = function (nums) {\\n    if (nums.length === 1) return nums[0];\\n    let dp1 = new Array(nums.length).fill(-1);\\n    let dp2 = [...dp1];\\n    function helper(i, arr, dp) {\\n        if (i < 0) return 0;\\n        if (dp[i] !== -1) return dp[i];\\n\\n        return dp[i] = Math.max(\\n            helper(i - 1, arr, dp),\\n            arr[i] + helper(i - 2, arr, dp)\\n        )\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(helper(n, arr1, dp1), helper(n, arr2, dp2));\\n};\\n\\n// Space optimized solution\\nvar rob = function (nums) {\\n    function helper(arr) {\\n        let rob1 = 0, rob2 = 0;\\n        for (let num of arr) {\\n            const tmp = Math.max(rob1 + num, rob2);\\n            rob1 = rob2;\\n            rob2 = tmp;\\n        }\\n        return rob2;\\n    }\\n\\n    const [arr1, arr2] = [nums.slice(0, nums.length - 1), nums.slice(1, nums.length)];\\n    const n = arr1.length - 1;\\n    return Math.max(nums[0], helper(arr1), helper(arr2));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988108,
                "title": "c-tabulation-o-n-time-o-1-space",
                "content": "This problem is very similar to House Robber. The only difference is that if the robber chooses to rob the first house, they cannot rob the last and vice versa.\\n\\nGiven this constraint, the problem can be broken down into two subproblems: what is the maximum amount that can be robbed from the first n-1 houses and what is the maximum amount that can be robbed from the last n-1 houses. The maximum amount for the overall problem is the max of these two values.\\n\\nThe `int rob(vector<int>& nums, int start, int len)` helper function executes the house robber algorithm as if the houses are in a line not wrapped in a circle. It uses the tabulation method of dynamic programming to determine the maximum possible amount. Iterating over the vector of houses, the maximum robbery amount for each index is either the max amount for the previous house, or the current house\\'s amount plus the max amount for 2 houses previous.\\n\\n**Time complexity: O(n)** because we are iterating linearly over vector `nums` twice.\\n**Space complexity: O(1)** because even though we are using tabulation which typically uses O(n) space, we only need to maintain the max amounts for the previous 2 houses at any step.\\n\\nThis problem can also be solve with memoization instead of tabulation. That solution would have the same time complexity, but would require recursion and only achieve O(n) space complexity.\\n\\n```\\nclass Solution {\\npublic:\\n    // uses tabulation to determine most money possible from linear set of houses\\n    int rob(vector<int>& nums, int start, int len) {\\n        int prevPrev = 0;       // max sum for 2 houses previous\\n        int prev = nums[start]; // max sum for previous house\\n        int curr;\\n        for (int i = 2; i < len + 1; i++) {\\n            curr = max(prevPrev + nums[start+i-1], prev);\\n            prevPrev = prev;\\n            prev = curr;\\n        }\\n        return curr;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, n-1), rob(nums, 1, n-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // uses tabulation to determine most money possible from linear set of houses\\n    int rob(vector<int>& nums, int start, int len) {\\n        int prevPrev = 0;       // max sum for 2 houses previous\\n        int prev = nums[start]; // max sum for previous house\\n        int curr;\\n        for (int i = 2; i < len + 1; i++) {\\n            curr = max(prevPrev + nums[start+i-1], prev);\\n            prevPrev = prev;\\n            prev = curr;\\n        }\\n        return curr;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        \\n        return max(rob(nums, 0, n-1), rob(nums, 1, n-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982836,
                "title": "easy-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        int[] dp1 = new int[n + 2];\\n\\t\\t// with first house\\n        for(int i = n - 2; i >= 0; i--){\\n            dp1[i] = Math.max(dp1[i + 1], nums[i] + dp1[i + 2]);\\n        }\\n        int[] dp2 = new int[n + 2];\\n\\t\\t// without first house but with last house\\n        for(int i = n - 1; i > 0; i--){\\n            dp2[i] = Math.max(dp2[i + 1], nums[i] + dp2[i + 2]);\\n        }\\n\\t\\t// In dp2 array we should take dp2[1] into consideration instead of dp2[0], because dp2[1] is the final ans for dp2.\\n        return Math.max(dp1[0], dp2[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        int[] dp1 = new int[n + 2];\\n\\t\\t// with first house\\n        for(int i = n - 2; i >= 0; i--){\\n            dp1[i] = Math.max(dp1[i + 1], nums[i] + dp1[i + 2]);\\n        }\\n        int[] dp2 = new int[n + 2];\\n\\t\\t// without first house but with last house\\n        for(int i = n - 1; i > 0; i--){\\n            dp2[i] = Math.max(dp2[i + 1], nums[i] + dp2[i + 2]);\\n        }\\n\\t\\t// In dp2 array we should take dp2[1] into consideration instead of dp2[0], because dp2[1] is the final ans for dp2.\\n        return Math.max(dp1[0], dp2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943255,
                "title": "faster-than-100-dp-memoization-concise-solution",
                "content": "class Solution {\\npublic:int dp[101][2];\\n    int solve(int first,int house, vector<int > &nums){\\n        if(house>=nums.size())\\n            return 0;\\n                if( first==1 && house==nums.size()-1)\\n            return 0;\\n        if(dp[house][first]!=-1)\\n            return dp[house][first];\\n        int ans1,ans2;\\n        if(house==0){\\n            ans1=nums[house]+solve(1,house+2,nums);\\n            ans2=solve(0,house+1,nums);\\n        }\\n        else{\\n                        ans1=nums[house]+solve(first,house+2,nums);\\n            ans2=solve(first,house+1,nums);   \\n        }\\n        return dp[house][first]=max(ans1,ans2);\\n    }\\n    int rob(vector<int >& nums) {\\n      memset(dp,-1,sizeof dp);\\n        return solve(0,0,nums);  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:int dp[101][2];\\n    int solve(int first,int house, vector<int > &nums){\\n        if(house>=nums.size())\\n            return 0;\\n                if( first==1 && house==nums.size()-1)\\n            return 0;\\n        if(dp[house][first]!=-1)\\n            return dp[house][first];\\n        int ans1,ans2;\\n        if(house==0){\\n            ans1=nums[house]+solve(1,house+2,nums);\\n            ans2=solve(0,house+1,nums);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1806899,
                "title": "simple-solution-in-java-100-faster-o-1-space-and-o-n-time",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        \\n        int n = nums.length;\\n        \\n        /* The array is in the circular format, we would want to convert it into the linear\\n           In one case, we would allow to rob from the first house then we will make the last house inaccessible\\n           In second case, we would allow to rob in the last house and make the first house robbery inaccessible\\n        */\\n        \\n        // Include first, restrict last \\n        int incl1 = 0;\\n        int excl1 = 0;\\n            \\n        // Restrict first, include last \\n        int incl2 = 0;\\n        int excl2 = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(i >= 0  && i < n-1){\\n                int temp = incl1;\\n                incl1 = Math.max(excl1 + nums[i], incl1);\\n                excl1 = temp;\\n            }\\n            if(i>=1 && i <= n-1){\\n                int temp = incl2;\\n                incl2 = Math.max(excl2 + nums[i], incl2);\\n                excl2 = temp;\\n            }\\n        }\\n        \\n        return Math.max(incl1, incl2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        \\n        int n = nums.length;\\n        \\n        /* The array is in the circular format, we would want to convert it into the linear\\n           In one case, we would allow to rob from the first house then we will make the last house inaccessible\\n           In second case, we would allow to rob in the last house and make the first house robbery inaccessible\\n        */\\n        \\n        // Include first, restrict last \\n        int incl1 = 0;\\n        int excl1 = 0;\\n            \\n        // Restrict first, include last \\n        int incl2 = 0;\\n        int excl2 = 0;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(i >= 0  && i < n-1){\\n                int temp = incl1;\\n                incl1 = Math.max(excl1 + nums[i], incl1);\\n                excl1 = temp;\\n            }\\n            if(i>=1 && i <= n-1){\\n                int temp = incl2;\\n                incl2 = Math.max(excl2 + nums[i], incl2);\\n                excl2 = temp;\\n            }\\n        }\\n        \\n        return Math.max(incl1, incl2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793611,
                "title": "python-solution",
                "content": "This is similar to \\'[House Robber](https://leetcode.com/problems/house-robber/)\\' problem:\\n```\\ndef rob(nums):\\n\\tnums = [0, 0, 0] + nums\\n\\tfor i in range(3, len(nums)):\\n\\t\\tnums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n\\treturn max(nums[-2], nums[-1])\\n```\\nthere\\'s only one difference, you can either rob nums[0] or nums[-1]. So, we are gonne call above function with two different lists as an input:\\n* nums[:-1] to include nums[0]  and exclude nums[-1]\\n* nums[1:] to exclude nums[0]  and include nums[-1]\\n\\nHere\\'s my solution:\\n```\\n# Runtime: 44 ms, faster than 53.19% of Python3 online submissions for House Robber II.\\n# Memory Usage: 14 MB, less than 57.59% of Python3 online submissions for House Robber II.\\nclass Solution:\\n    def rob(self, nums):\\n\\t\\n        def rob(nums):\\n            nums = [0, 0, 0] + nums\\n            for i in range(3, len(nums)):\\n                nums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n            return max(nums[-2], nums[-1])\\n\\t\\t\\n        return max(nums[0], rob(nums[:-1], rob(nums[1:])))\\n```\\nnote: we include nums[0] to handle len(nums)==1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rob(nums):\\n\\tnums = [0, 0, 0] + nums\\n\\tfor i in range(3, len(nums)):\\n\\t\\tnums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n\\treturn max(nums[-2], nums[-1])\\n```\n```\\n# Runtime: 44 ms, faster than 53.19% of Python3 online submissions for House Robber II.\\n# Memory Usage: 14 MB, less than 57.59% of Python3 online submissions for House Robber II.\\nclass Solution:\\n    def rob(self, nums):\\n\\t\\n        def rob(nums):\\n            nums = [0, 0, 0] + nums\\n            for i in range(3, len(nums)):\\n                nums[i] = max(nums[i-3]+nums[i], nums[i-2]+nums[i])\\n            return max(nums[-2], nums[-1])\\n\\t\\t\\n        return max(nums[0], rob(nums[:-1], rob(nums[1:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741405,
                "title": "house-robber-ii-c-easy-dp",
                "content": "\\'\\'\\'\\nPlease upvote the solution if feel it is helpful for you\\nif any doubt please ask and comment below\\n```\\nint solve(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n-1)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        return dp[i]=max(nums[i]+solve(nums,i+2,n,dp),solve(nums,i+1,n,dp));\\n    }\\n     int solve2(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n          return dp[i]=max(nums[i]+solve2(nums,i+2,n,dp),solve2(nums,i+1,n,dp));\\n     }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,-1);\\n        vector<int>dp2(n,-1);\\n       if(n==1)return nums[0];\\n        \\n        int ans1=solve(nums,0,n,dp1);\\n        int ans2=solve2(nums,1,n,dp2);\\n        return max(ans1,ans2);\\n    }",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "\\'\\'\\'\\nPlease upvote the solution if feel it is helpful for you\\nif any doubt please ask and comment below\\n```\\nint solve(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n-1)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        return dp[i]=max(nums[i]+solve(nums,i+2,n,dp),solve(nums,i+1,n,dp));\\n    }\\n     int solve2(vector<int>&nums,int i,int n,vector<int>&dp)\\n    {\\n        if(i>=n)\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n          return dp[i]=max(nums[i]+solve2(nums,i+2,n,dp),solve2(nums,i+1,n,dp));\\n     }\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,-1);\\n        vector<int>dp2(n,-1);\\n       if(n==1)return nums[0];\\n        \\n        int ans1=solve(nums,0,n,dp1);\\n        int ans2=solve2(nums,1,n,dp2);\\n        return max(ans1,ans2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1699138,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>nums) {\\n        if(nums.size()==1)return nums[0];\\n        if(nums.size()==2)return max(nums[0],nums[1]);\\n        nums[2]=max(nums[0]+nums[2],nums[1]);\\n        for(int i=3;i<nums.size();i++){\\n            nums[i]+=max(nums[i-2],nums[i-3]);\\n        }\\n        return max(nums[nums.size()-1],nums[nums.size()-2]);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        if(nums.size()==2) return max(nums[0],nums[1]);\\n        return max(fun(vector<int>(nums.begin()+1,nums.end())),fun(vector<int>(nums.begin(),nums.end()-1)));\\n    } \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>nums) {\\n        if(nums.size()==1)return nums[0];\\n        if(nums.size()==2)return max(nums[0],nums[1]);\\n        nums[2]=max(nums[0]+nums[2],nums[1]);\\n        for(int i=3;i<nums.size();i++){\\n            nums[i]+=max(nums[i-2],nums[i-3]);\\n        }\\n        return max(nums[nums.size()-1],nums[nums.size()-2]);\\n    }\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        if(nums.size()==2) return max(nums[0],nums[1]);\\n        return max(fun(vector<int>(nums.begin()+1,nums.end())),fun(vector<int>(nums.begin(),nums.end()-1)));\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689141,
                "title": "consider-2-cases-runtime-0ms-faster-than-100",
                "content": "**Idea?**\\n* Fix that 1st house is robbed, then last house must not be robbed. Find the maximum amount that can be robbed by considering either current house can be robbed or not?\\n* Again Fix that 1st House shouldn\\'t be robbed...Hence we can rob the last house.\\n* Find the same, maxm amount that can be robbed.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(N)\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums.back();\\n        vector<int> dp1(n),dp2(n);\\n        // rob 1st house fixed\\n        dp1[0] = dp1[1] = nums[0];\\n        for(int i=2;i<n-1;i++)\\n            dp1[i] = max(dp1[i-2]+nums[i],dp1[i-1]);\\n        //  we can\\'t rob the last house since first house is robbed (fixed)\\n        dp1[n-1] = dp1[n-2];\\n        \\n        // don\\'t rob 1st house\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++)\\n            dp2[i] = max(dp2[i-2]+nums[i],dp2[i-1]);\\n        return max(dp1.back(),dp2.back());\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N)\\n    // Space Complexity:- O(N)\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums.back();\\n        vector<int> dp1(n),dp2(n);\\n        // rob 1st house fixed\\n        dp1[0] = dp1[1] = nums[0];\\n        for(int i=2;i<n-1;i++)\\n            dp1[i] = max(dp1[i-2]+nums[i],dp1[i-1]);\\n        //  we can\\'t rob the last house since first house is robbed (fixed)\\n        dp1[n-1] = dp1[n-2];\\n        \\n        // don\\'t rob 1st house\\n        dp2[1] = nums[1];\\n        for(int i=2;i<n;i++)\\n            dp2[i] = max(dp2[i-2]+nums[i],dp2[i-1]);\\n        return max(dp1.back(),dp2.back());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600554,
                "title": "dp-based-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[105];\\n    int solution(vector<int> nums, int s){\\n        int n=nums.size();\\n        if(s>=n)\\n            return 0;\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        return dp[s]=max(nums[s]+solution(nums, s+2), solution(nums, s+1));\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        memset(dp, -1, sizeof(dp));\\n        int n=nums.size();\\n        int a1 = solution(nums, 1);\\n        nums.pop_back();\\n        memset(dp, -1, sizeof(dp));\\n        int a2 = solution(nums, 0);\\n        return max(a1, a2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[105];\\n    int solution(vector<int> nums, int s){\\n        int n=nums.size();\\n        if(s>=n)\\n            return 0;\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        return dp[s]=max(nums[s]+solution(nums, s+2), solution(nums, s+1));\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        memset(dp, -1, sizeof(dp));\\n        int n=nums.size();\\n        int a1 = solution(nums, 1);\\n        nums.pop_back();\\n        memset(dp, -1, sizeof(dp));\\n        int a2 = solution(nums, 0);\\n        return max(a1, a2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505691,
                "title": "python-single-pass-iterative-dp",
                "content": "For the first version of the [House Robber](https://leetcode.com/problems/house-robber/), we have the following iterative DP solution:\\n\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = 0\\n        for n in nums: \\n            a, b = b, max(b, a + n)\\n        return b\\n```\\n\\nWe can call the same `rob()` for `nums[:-1]` and `nums[1:]` and then pick the max of the two, which gives us the following two pass solution:\\n_Note: To handle `len(nums) == 1` we can just throw `nums[0]` in the `max()` call_\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        def rob(nums):\\n            a = b = 0\\n            for n in nums: \\n\\t\\t\\t\\ta, b = b, max(b, a + n)\\n            return b\\n        return max(nums[0], rob(nums[:-1]), rob(nums[1:]))\\n```\\n\\nIn fact, we can implement it in a single pass as follows:\\n\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = c = d = 0\\n        for i in range(len(nums)-1):\\n            a, b = b, max(b, a + nums[i])\\n            c, d = d, max(d, c + nums[i+1])\\n        \\n        return max(b, d, nums[0])\\n```\\nTime Complexity: `O(n)`\\nSpace Complecity: `O(1)`\\n\\n_Sorry for the lame choice of variable names_\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = 0\\n        for n in nums: \\n            a, b = b, max(b, a + n)\\n        return b\\n```\n```\\n    def rob(self, nums: List[int]) -> int:\\n        def rob(nums):\\n            a = b = 0\\n            for n in nums: \\n\\t\\t\\t\\ta, b = b, max(b, a + n)\\n            return b\\n        return max(nums[0], rob(nums[:-1]), rob(nums[1:]))\\n```\n```\\n    def rob(self, nums: List[int]) -> int:\\n        a = b = c = d = 0\\n        for i in range(len(nums)-1):\\n            a, b = b, max(b, a + nums[i])\\n            c, d = d, max(d, c + nums[i+1])\\n        \\n        return max(b, d, nums[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1495475,
                "title": "c-top-down-recursive-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp1[101];\\n    int helper1(vector<int>& nums,int i)\\n    {\\n        if(nums.size()-1<=i) return 0;\\n        \\n        if(dp1[i]!=-1) return dp1[i];\\n        \\n        int sum1=helper1(nums,i+1);\\n        int sum2=nums[i]+helper1(nums,i+2);\\n        \\n        return dp1[i] =max(sum1,sum2);\\n        \\n    }\\n    \\n    int dp2[101];\\n    int helper2(vector<int>& nums,int i)\\n    {\\n        if(nums.size()<=i) return 0;\\n        \\n        if(dp2[i]!=-1){\\n            return dp2[i];\\n        }\\n        int sum1=helper2(nums,i+1);\\n        int sum2=nums[i]+helper2(nums,i+2);\\n        \\n        return dp2[i]= max(sum1,sum2);\\n        \\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        memset(dp1,-1,sizeof(dp1));\\n        memset(dp2,-1,sizeof(dp2));\\n        \\n        int sum1 = helper1(nums,0);\\n        int sum2 = helper2(nums,1);\\n        cout<<sum1<<\" \"<<sum2;\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp1[101];\\n    int helper1(vector<int>& nums,int i)\\n    {\\n        if(nums.size()-1<=i) return 0;\\n        \\n        if(dp1[i]!=-1) return dp1[i];\\n        \\n        int sum1=helper1(nums,i+1);\\n        int sum2=nums[i]+helper1(nums,i+2);\\n        \\n        return dp1[i] =max(sum1,sum2);\\n        \\n    }\\n    \\n    int dp2[101];\\n    int helper2(vector<int>& nums,int i)\\n    {\\n        if(nums.size()<=i) return 0;\\n        \\n        if(dp2[i]!=-1){\\n            return dp2[i];\\n        }\\n        int sum1=helper2(nums,i+1);\\n        int sum2=nums[i]+helper2(nums,i+2);\\n        \\n        return dp2[i]= max(sum1,sum2);\\n        \\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        memset(dp1,-1,sizeof(dp1));\\n        memset(dp2,-1,sizeof(dp2));\\n        \\n        int sum1 = helper1(nums,0);\\n        int sum2 = helper2(nums,1);\\n        cout<<sum1<<\" \"<<sum2;\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1495268,
                "title": "similar-to-house-robber-problem",
                "content": "This problem is similar to house robber problem \\nIt is divided into 2 subproblems\\n1. we need to find from 0 to n-2\\n2. we need to find from 1 to n-1 \\n    return max of both\\n\\'\\'\\'class Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size(); \\n        if (n < 2) return n ? nums[0] : 0;\\n        return max(robber(nums, 0, n-2), robber(nums, 1, n - 1));\\n    }\\nprivate:\\n    int robber(vector<int>& nums, int l, int r) {\\n        int pre = 0, cur = 0;\\n        for (int i = l; i <= r; i++) {\\n            int temp = max(pre + nums[i], cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size(); \\n        if (n < 2) return n ? nums[0] : 0;\\n        return max(robber(nums, 0, n-2), robber(nums, 1, n - 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1466296,
                "title": "c-100-fast-same-as-house-robber-1-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //helper function same as house robber\\n    int helper(vector<int> nums) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        \\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<=n; i++){\\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        if(n==2) return max(nums[0], nums[1]);\\n        \\n        // a -> ignoring the last element of the array \\n        // when considering first element\\n        int a = helper(vector<int>(nums.begin(), nums.end()-1));\\n        \\n        // b -> ignoring the first element of the array \\n        // when considering last element\\n        int b = helper(vector<int>(nums.begin()+1, nums.end()));\\n        \\n        return max(a,b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //helper function same as house robber\\n    int helper(vector<int> nums) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        \\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for(int i=2; i<=n; i++){\\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i-1]);\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n        if(n==2) return max(nums[0], nums[1]);\\n        \\n        // a -> ignoring the last element of the array \\n        // when considering first element\\n        int a = helper(vector<int>(nums.begin(), nums.end()-1));\\n        \\n        // b -> ignoring the first element of the array \\n        // when considering last element\\n        int b = helper(vector<int>(nums.begin()+1, nums.end()));\\n        \\n        return max(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400820,
                "title": "java-dp-solution-in-o-n-using-o-n-space-complexity",
                "content": "This is the follow up of [House Robber](https://leetcode.com/problems/house-robber/) problem. In, house robber we do not have a circular array, so we can freely choose our start and end position. But here due to constraints we need to choose the best outcome, so we can divide the problem in two sub-problems\\n1. Finding the solution for index 0 to n - 2\\n2. Finding the solution for index 1 to n - 1\\nAnd the answer would be the max of these two sub problems\\n\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1)\\n            return nums[0];\\n        return Math.max(solve(Arrays.copyOfRange(nums, 0, n - 1)),solve(Arrays.copyOfRange(nums, 1, n)));\\n    }\\n    \\n    private int solve(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int [n + 1];\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for (int i = 2; i <= n; i++) \\n            dp[i] = Math.max(nums[i - 1] + dp[i - 2], dp[i - 1]);\\n        return dp[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1)\\n            return nums[0];\\n        return Math.max(solve(Arrays.copyOfRange(nums, 0, n - 1)),solve(Arrays.copyOfRange(nums, 1, n)));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1064306,
                "title": "python-dp-o-n",
                "content": "Use house rober 1 logic from [0, N-1] and [1 to N]\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums)==1: return nums[0]\\n        \\n        def f(nums):\\n            prev_max = 0\\n            cur_max = 0\\n            for p in nums:\\n                temp = cur_max\\n                cur_max = max(cur_max, prev_max+p)\\n                prev_max = temp\\n            return cur_max\\n        \\n        return max( f(nums[:-1]), f(nums[1:]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums)==1: return nums[0]\\n        \\n        def f(nums):\\n            prev_max = 0\\n            cur_max = 0\\n            for p in nums:\\n                temp = cur_max\\n                cur_max = max(cur_max, prev_max+p)\\n                prev_max = temp\\n            return cur_max\\n        \\n        return max( f(nums[:-1]), f(nums[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935356,
                "title": "c-dp",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        if (N == 0) return 0;\\n        \\n        if (N == 1) return nums[0];\\n        \\n        vector<int> numsA(nums.begin() + 1, nums.end());\\n        vector<int> numsB(nums.begin(), nums.end()-1);\\n        \\n        return max(robber(numsA), robber(numsB));\\n    }\\n    \\n    int robber (vector<int>& nums)\\n    {\\n        int dp1 = 0, dp2 = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int dp = max(dp2 + nums[i], dp1);\\n            \\n            dp2 = dp1;\\n            \\n            dp1 = dp;\\n        }\\n        \\n        return dp1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        \\n        if (N == 0) return 0;\\n        \\n        if (N == 1) return nums[0];\\n        \\n        vector<int> numsA(nums.begin() + 1, nums.end());\\n        vector<int> numsB(nums.begin(), nums.end()-1);\\n        \\n        return max(robber(numsA), robber(numsB));\\n    }\\n    \\n    int robber (vector<int>& nums)\\n    {\\n        int dp1 = 0, dp2 = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int dp = max(dp2 + nums[i], dp1);\\n            \\n            dp2 = dp1;\\n            \\n            dp1 = dp;\\n        }\\n        \\n        return dp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920372,
                "title": "normal-recursive-memory-recursive-dp",
                "content": "\\n#### Normal Recursive\\n```java\\n/**\\n  *  maybe timeout ? \\n  */\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n\\n        if (i == 0) {\\n            return Math.max(nums[i] + process(nums, i + 2, 1), process(nums, i + 1, 0));\\n        } else {\\n            return Math.max(nums[i] + process(nums, i + 2, usingFirst), process(nums, i + 1, usingFirst));\\n        }\\n    }\\n}\\n```\\n\\n#### Memory Search Recursive \\n```java\\n/**\\n  * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n  * Memory Usage: 36.4 MB, less than 5.01% of Java online submissions for House Robber II.\\n  */\\nclass Solution {\\n    \\n    private int[][] cache;\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        cache = new int[2][n + 1];\\n        int[] i1 = new int[n + 1];\\n        int[] i2 = new int[n + 1];\\n        Arrays.fill(i1, -1);\\n        Arrays.fill(i2, -1);\\n        cache[0] = i1;\\n        cache[1] = i2;\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n        \\n        if (cache[usingFirst][i] == -1) {\\n            if (i == 0) {\\n                if (cache[1][i + 2] == -1) {\\n                    cache[1][i + 2] = process(nums, i + 2, 1);\\n                }\\n                if (cache[0][i + 1] == -1) {\\n                    cache[0][i + 1] = process(nums, i + 1, 0);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[1][i + 2], cache[0][i + 1]);\\n            } else {\\n                if (cache[usingFirst][i + 2] == -1) {\\n                    cache[usingFirst][i + 2] = process(nums, i + 2, usingFirst);\\n                }\\n                if (cache[usingFirst][i + 1] == -1) {\\n                    cache[usingFirst][i + 1] = process(nums, i + 1, usingFirst);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[usingFirst][i + 2], cache[usingFirst][i + 1]);\\n            }\\n        }\\n        return cache[usingFirst][i];\\n    }\\n}\\n```\\n\\n#### DP\\n```java\\nclass Solution {\\n    /**\\n\\t * \\n    * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n    * Memory Usage: 35.4 MB, less than 95.01% of Java online submissions for House Robber II.\\n     */\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        int[][] dp = new int[2][n + 1];\\n        dp[0][n - 1] = nums[n - 1];\\n        dp[1][n - 1] = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i == 0) {\\n                dp[0][i] = dp[0][i + 1];\\n                dp[1][i] = nums[i] + dp[1][i + 2];\\n            } else {\\n                dp[0][i] = Math.max(nums[i] + dp[0][i + 2], dp[0][i + 1]);\\n                dp[1][i] = Math.max(nums[i] + dp[1][i + 2], dp[1][i + 1]);\\n            }\\n        }\\n        return Math.max(dp[0][0], dp[1][0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n  *  maybe timeout ? \\n  */\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n\\n        if (i == 0) {\\n            return Math.max(nums[i] + process(nums, i + 2, 1), process(nums, i + 1, 0));\\n        } else {\\n            return Math.max(nums[i] + process(nums, i + 2, usingFirst), process(nums, i + 1, usingFirst));\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n  * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n  * Memory Usage: 36.4 MB, less than 5.01% of Java online submissions for House Robber II.\\n  */\\nclass Solution {\\n    \\n    private int[][] cache;\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        cache = new int[2][n + 1];\\n        int[] i1 = new int[n + 1];\\n        int[] i2 = new int[n + 1];\\n        Arrays.fill(i1, -1);\\n        Arrays.fill(i2, -1);\\n        cache[0] = i1;\\n        cache[1] = i2;\\n        return process(nums, 0, 0);\\n    }\\n\\n    private int process(int[] nums, int i, int usingFirst) {\\n        int n = nums.length;\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (i == n - 1) {\\n            return usingFirst == 1 ? 0 : nums[n - 1];\\n        }\\n        \\n        if (cache[usingFirst][i] == -1) {\\n            if (i == 0) {\\n                if (cache[1][i + 2] == -1) {\\n                    cache[1][i + 2] = process(nums, i + 2, 1);\\n                }\\n                if (cache[0][i + 1] == -1) {\\n                    cache[0][i + 1] = process(nums, i + 1, 0);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[1][i + 2], cache[0][i + 1]);\\n            } else {\\n                if (cache[usingFirst][i + 2] == -1) {\\n                    cache[usingFirst][i + 2] = process(nums, i + 2, usingFirst);\\n                }\\n                if (cache[usingFirst][i + 1] == -1) {\\n                    cache[usingFirst][i + 1] = process(nums, i + 1, usingFirst);\\n                }\\n                cache[usingFirst][i] = Math.max(nums[i] + cache[usingFirst][i + 2], cache[usingFirst][i + 1]);\\n            }\\n        }\\n        return cache[usingFirst][i];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    /**\\n\\t * \\n    * Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.\\n    * Memory Usage: 35.4 MB, less than 95.01% of Java online submissions for House Robber II.\\n     */\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[n - 1];\\n\\n        int[][] dp = new int[2][n + 1];\\n        dp[0][n - 1] = nums[n - 1];\\n        dp[1][n - 1] = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i == 0) {\\n                dp[0][i] = dp[0][i + 1];\\n                dp[1][i] = nums[i] + dp[1][i + 2];\\n            } else {\\n                dp[0][i] = Math.max(nums[i] + dp[0][i + 2], dp[0][i + 1]);\\n                dp[1][i] = Math.max(nums[i] + dp[1][i + 2], dp[1][i + 1]);\\n            }\\n        }\\n        return Math.max(dp[0][0], dp[1][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900810,
                "title": "python-w-explanation",
                "content": "**IDEA**: This problem is an extension of the \\'[LC 198: House Robber](https://leetcode.com/problems/house-robber/)\\' problem. (As provided) \\n\\nThe aim of the \\'House Robber\\' problem is to maximize profits while ensuring that none of the two consecutive houses are robbed. (Visualize the street to be linear here)\\nThus, the cases are:\\n1. 1 house only: max profit -> profit from the only house\\n2. 2 houses: max profit -> max(profit from 1st house, profit from 2nd house)\\n3. 3 or more houses: max profit -> max(profit from the last to last house + profit from current house, profit from last house)\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev+num, curr)\\n        return curr\\n```\\n\\nThe current problem has an additional constraint that the street is circular. Thus, the first and the (pseudo) last house can\\'t be robbed together. \\nThus, apart from the cases described abvove, there are two cases in the broader picture:\\n(Assuming houses are 1, 2, 3, 4 ... n )\\n1. Rob houses 1 to (n-1)\\n2. Rob houses 2 to n \\n\\nThus, the above code can be resused with added constraints as under:\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        return max(nums[0] + self._helper(nums[2:-1]), self._helper(nums[1:]))\\n    \\n    def _helper(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev + num, curr)\\n        return curr\\n```\\n\\nTime Complexity: O(N) where, N: length of input list \\'nums\\'\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev+num, curr)\\n        return curr\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        return max(nums[0] + self._helper(nums[2:-1]), self._helper(nums[1:]))\\n    \\n    def _helper(self, nums: List[int]) -> int:\\n        prev, curr = 0, 0\\n        for num in nums:\\n            prev, curr = curr, max(prev + num, curr)\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895299,
                "title": "java-clean-concise-code-dynamic-programming-approach",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int rob (int[] nums) {\\n\\t\\t\\n\\t\\tint n = nums.length;\\n\\t\\tint first = 0;\\n\\t\\tint second1 = n == 1 ? 0 : nums[0];\\n\\t\\tint second2 = nums[0];\\n\\t\\t\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint max = Math.max (second1, first + nums[i]);\\n\\t\\t\\tfirst = second1;\\n\\t\\t\\tsecond1 = second2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = n; i < n + n; i++) {\\n\\t\\t\\tint max = Math.max (second2, first + nums[i - n]);\\n\\t\\t\\tfirst = second2;\\n\\t\\t\\tsecond2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn second2 - second1;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int rob (int[] nums) {\\n\\t\\t\\n\\t\\tint n = nums.length;\\n\\t\\tint first = 0;\\n\\t\\tint second1 = n == 1 ? 0 : nums[0];\\n\\t\\tint second2 = nums[0];\\n\\t\\t\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint max = Math.max (second1, first + nums[i]);\\n\\t\\t\\tfirst = second1;\\n\\t\\t\\tsecond1 = second2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = n; i < n + n; i++) {\\n\\t\\t\\tint max = Math.max (second2, first + nums[i - n]);\\n\\t\\t\\tfirst = second2;\\n\\t\\t\\tsecond2 = max;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn second2 - second1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880828,
                "title": "javascript-very-easy-solution-dynamic-programming",
                "content": "```\\nvar rob = function(nums) {\\n    let n = nums.length;\\n    if(n===0) return 0;\\n    if(n===1) return nums[0];\\n    if(n===2) return Math.max(nums[0],nums[1])\\n    \\n    let dp1 = new Array(n);\\n    let dp2 = new Array(n);\\n    \\n    computeResult(0,n-2,dp1,nums);\\n    computeResult(1,n-1,dp2,nums);\\n    \\n    function computeResult(i,n,dp,nums){\\n        dp[i] = nums[i]\\n        dp[i+1] = Math.max(dp[i],nums[i+1])\\n        \\n        for(let j=i+2; j<=n; j++){\\n            dp[j] = Math.max(dp[j-1],dp[j-2]+nums[j])\\n        }\\n    }\\n    return Math.max(dp1[n-2],dp2[n-1])\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    let n = nums.length;\\n    if(n===0) return 0;\\n    if(n===1) return nums[0];\\n    if(n===2) return Math.max(nums[0],nums[1])\\n    \\n    let dp1 = new Array(n);\\n    let dp2 = new Array(n);\\n    \\n    computeResult(0,n-2,dp1,nums);\\n    computeResult(1,n-1,dp2,nums);\\n    \\n    function computeResult(i,n,dp,nums){\\n        dp[i] = nums[i]\\n        dp[i+1] = Math.max(dp[i],nums[i+1])\\n        \\n        for(let j=i+2; j<=n; j++){\\n            dp[j] = Math.max(dp[j-1],dp[j-2]+nums[j])\\n        }\\n    }\\n    return Math.max(dp1[n-2],dp2[n-1])\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 869568,
                "title": "do-dp-twice-the-first-round-rob-house0-the-second-round-not",
                "content": "1. if we do not rob house0, then we could rob house n-1.\\n2. if we rob house0, then we could ignore house n-1, just loop to n-2 \\n\\nchoose the max answer in these 2 options. \\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null) return 0;\\n        int n = nums.length;\\n        if(n ==0) return 0;\\n        if(n ==1) return nums[0];\\n        \\n        int[] dp = new int[n];\\n        \\n        //first round, we do not rob house 0\\n        dp[0] = 0;// do not rob house 0\\n        dp[1] = nums[1];\\n        for(int i=2; i<n; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n\\t\\t\\n        int max = dp[n-1];\\n      \\n        //seond round, rob house0, in this case we could ignore house n-1\\n        dp[0] = nums[0];//rob house 0\\n        dp[1] = dp[0];\\n\\t\\t//loop to n-2, ignore house N-1\\n        for(int i=2; i<n-1; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        max = Math.max(max,dp[n-2]);\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null) return 0;\\n        int n = nums.length;\\n        if(n ==0) return 0;\\n        if(n ==1) return nums[0];\\n        \\n        int[] dp = new int[n];\\n        \\n        //first round, we do not rob house 0\\n        dp[0] = 0;// do not rob house 0\\n        dp[1] = nums[1];\\n        for(int i=2; i<n; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n\\t\\t\\n        int max = dp[n-1];\\n      \\n        //seond round, rob house0, in this case we could ignore house n-1\\n        dp[0] = nums[0];//rob house 0\\n        dp[1] = dp[0];\\n\\t\\t//loop to n-2, ignore house N-1\\n        for(int i=2; i<n-1; i++){\\n            dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        max = Math.max(max,dp[n-2]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791317,
                "title": "dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        //case 1 rob from 1 to n-1\\n        //case 2 rob from 2 to n\\n        //max of both\\n        int len = nums.length;\\n        if(len == 1){\\n            return nums[0];\\n        }\\n        else if(len==2){\\n            return Math.max(nums[0],nums[1]);// since houses are in circular\\n        }\\n        \\n        \\n        return Math.max(robHouses(nums,0,len-2),robHouses(nums,1,len-1));\\n    }\\n    public int robHouses(int[] nums,int fromIndex,int toIndex){\\n        int prev1 = 0;//amount robbed till previous house\\n        int prev2 = 0;// amount robbed till previous of prev1\\n        for(int i=fromIndex;i<=toIndex;i++){\\n            int temp = prev1;\\n            prev1 = Math.max((prev2+nums[i]),prev1);//robber can either select pre1 or curr+prev2\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        //case 1 rob from 1 to n-1\\n        //case 2 rob from 2 to n\\n        //max of both\\n        int len = nums.length;\\n        if(len == 1){\\n            return nums[0];\\n        }\\n        else if(len==2){\\n            return Math.max(nums[0],nums[1]);// since houses are in circular\\n        }\\n        \\n        \\n        return Math.max(robHouses(nums,0,len-2),robHouses(nums,1,len-1));\\n    }\\n    public int robHouses(int[] nums,int fromIndex,int toIndex){\\n        int prev1 = 0;//amount robbed till previous house\\n        int prev2 = 0;// amount robbed till previous of prev1\\n        for(int i=fromIndex;i<=toIndex;i++){\\n            int temp = prev1;\\n            prev1 = Math.max((prev2+nums[i]),prev1);//robber can either select pre1 or curr+prev2\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703829,
                "title": "javascript-solution",
                "content": "I obviously did not come up with this solution. If you need a good explanation of the code below, I would suggest you look up the submission by [@lxx223](https://leetcode.com/problems/house-robber-ii/discuss/59934/Simple-AC-solution-in-Java-in-O(n)-with-explanation) which is the most voted. For me personally, I thought it will be good to practice the offsetting of indexes for arrays since I been having issues with them in more difficult problems. So, the extra use of the variable `j` and adding 2 zeroes for the dp, and use of  `start + i` was done on purpose. Please let me know if you have any questions or ways of improving the code. Thank you and have a wonderful day all!\\n\\n<br>\\n\\n```\\nvar rob = function(nums) {\\n    \\n    if (!nums || nums.length == 0) return 0; // not neceesary, but for completeness sake\\n    \\n    const n = nums.length;\\n    if (n == 1) return nums[0]; // edge case where there is only 1 element in the array\\n    \\n    return Math.max(robHomes(1, n - 1), robHomes(0, n - 2));\\n    \\n    function robHomes(start, end) {\\n        const len = end - start + 1;\\n        const dp = [];\\n        dp[0] = 0, dp[1] = 0; // For look-backs\\n        \\n        for (let i = 0, j = 2; i < len; i++, j++) {\\n            const num = nums[start + i];\\n            dp[j] = Math.max(num + dp[j - 2], dp[j - 1]);\\n        }\\n        \\n        return dp[dp.length - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    \\n    if (!nums || nums.length == 0) return 0; // not neceesary, but for completeness sake\\n    \\n    const n = nums.length;\\n    if (n == 1) return nums[0]; // edge case where there is only 1 element in the array\\n    \\n    return Math.max(robHomes(1, n - 1), robHomes(0, n - 2));\\n    \\n    function robHomes(start, end) {\\n        const len = end - start + 1;\\n        const dp = [];\\n        dp[0] = 0, dp[1] = 0; // For look-backs\\n        \\n        for (let i = 0, j = 2; i < len; i++, j++) {\\n            const num = nums[start + i];\\n            dp[j] = Math.max(num + dp[j - 2], dp[j - 1]);\\n        }\\n        \\n        return dp[dp.length - 1];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693341,
                "title": "python-6-line-less-obscure-dp-solution",
                "content": "Both `dp1` and `dp2` records the maximum value robbed along the way, however under different conditions:\\n- `dp1`: first house is robbed \\n- `dp2`: first house is NOT robbed\\n\\nApplied a little trick in the initialization of `dp2` to deal with single-house cases.\\n```python\\ndef rob(self, nums: List[int]) -> int:\\n    dp1 = [0, 0]\\n    dp2 = [-nums[0] if len(nums) > 1 else 0, 0]\\n    for i, n in enumerate(nums):\\n        dp1.append(max(dp1[i+1], n + dp1[i]))\\n        dp2.append(max(dp2[i+1], n + dp2[i]))\\n    return max(dp1[-2], dp2[-1])\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef rob(self, nums: List[int]) -> int:\\n    dp1 = [0, 0]\\n    dp2 = [-nums[0] if len(nums) > 1 else 0, 0]\\n    for i, n in enumerate(nums):\\n        dp1.append(max(dp1[i+1], n + dp1[i]))\\n        dp2.append(max(dp2[i+1], n + dp2[i]))\\n    return max(dp1[-2], dp2[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 594651,
                "title": "python3-o-n-solution",
                "content": "2 scenarios: Buy the first one and don\\'t buy the last one or don\\'t buy the first one and consider buying the last one \\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        boughtFirst = self.maxProfit(nums[:len(nums)-1])\\n        boughtFirstNot = self.maxProfit(nums[1:])\\n        return max(boughtFirst, boughtFirstNot)\\n    \\n    def maxProfit(self,nums):\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        dp = [nums[0], max(nums[0],nums[1])]\\n        for i in range(2, len(nums)):\\n            dp.append(max(dp[i-2] + nums[i], dp[i-1]))\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n        boughtFirst = self.maxProfit(nums[:len(nums)-1])\\n        boughtFirstNot = self.maxProfit(nums[1:])\\n        return max(boughtFirst, boughtFirstNot)\\n    \\n    def maxProfit(self,nums):\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        dp = [nums[0], max(nums[0],nums[1])]\\n        for i in range(2, len(nums)):\\n            dp.append(max(dp[i-2] + nums[i], dp[i-1]))\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577231,
                "title": "0ms-java-100-simple-solution-dp",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0; \\n        if(nums.length==1)\\n            return nums[0];\\n \\n        int max1 = robHelper(nums, 0, nums.length-2);\\n        int max2 = robHelper(nums, 1, nums.length-1);\\n        return Math.max(max1, max2);\\n    }\\n    public int robHelper(int[] nums, int i, int j){\\n        if(i==j){\\n            return nums[i];\\n        }\\n        int[] dp = new int[nums.length];\\n        dp[i]=nums[i];\\n        dp[i+1]=Math.max(nums[i+1], dp[i]);\\n        for(int k=i+2; k<=j; k++){\\n            dp[k]=Math.max(dp[k-1], dp[k-2]+nums[k]);    \\n        }\\n        return dp[j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums==null || nums.length==0)\\n            return 0; \\n        if(nums.length==1)\\n            return nums[0];\\n \\n        int max1 = robHelper(nums, 0, nums.length-2);\\n        int max2 = robHelper(nums, 1, nums.length-1);\\n        return Math.max(max1, max2);\\n    }\\n    public int robHelper(int[] nums, int i, int j){\\n        if(i==j){\\n            return nums[i];\\n        }\\n        int[] dp = new int[nums.length];\\n        dp[i]=nums[i];\\n        dp[i+1]=Math.max(nums[i+1], dp[i]);\\n        for(int k=i+2; k<=j; k++){\\n            dp[k]=Math.max(dp[k-1], dp[k-2]+nums[k]);    \\n        }\\n        return dp[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413151,
                "title": "simple-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        \\n        if (n == 0)\\n            return 0;\\n        else if (n==1)\\n            return nums[0];\\n        else if (n==2)\\n            return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[n];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i < n-1;i++){//rob first house\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n            // System.out.println(Arrays.toString(dp));\\n        }\\n        dp[n-1] = dp[n-2]; //only choose between nums[2,n-2], then stay the same\\n        \\n        int tmpMax = dp[n-1] ;\\n        \\n        //skip first house\\n        dp = new int[n];\\n        dp[1] = nums[1]; \\n        dp[2] = Math.max(nums[1],nums[2]);\\n        for (int i = 3; i < n;i++){\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n        }\\n        \\n        return Math.max(dp[n-1],tmpMax);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n =nums.length;\\n        \\n        if (n == 0)\\n            return 0;\\n        else if (n==1)\\n            return nums[0];\\n        else if (n==2)\\n            return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[n];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i < n-1;i++){//rob first house\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n            // System.out.println(Arrays.toString(dp));\\n        }\\n        dp[n-1] = dp[n-2]; //only choose between nums[2,n-2], then stay the same\\n        \\n        int tmpMax = dp[n-1] ;\\n        \\n        //skip first house\\n        dp = new int[n];\\n        dp[1] = nums[1]; \\n        dp[2] = Math.max(nums[1],nums[2]);\\n        for (int i = 3; i < n;i++){\\n            dp[i] = Math.max(dp[i-1],dp[i-2] +nums[i]);\\n        }\\n        \\n        return Math.max(dp[n-1],tmpMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408090,
                "title": "swift-with-explanation",
                "content": "This is the same problem as House Robber I except you must solve the problem twice and take the max.\\n1. Solve the problem for the range 0 to n-2. (Excludes the last house)\\n2. Solve the problem for the range 1 to n-1. (Excludes the first house)\\n\\n```\\nfunc rob(_ nums: [Int]) -> Int {\\n\\tguard !nums.isEmpty else { return 0 }\\n\\n\\tif nums.count == 1 { return nums[0] }\\n\\tif nums.count == 2 { return max(nums[0], nums[1]) }\\n\\n\\tlet n = nums.count\\n\\n\\treturn max(robHelper(Array(nums[0...n-2])), robHelper(Array(nums[1...n-1])))\\n}\\n\\nfunc robHelper(_ nums: [Int]) -> Int {\\n\\tvar maxMoney = 0\\n\\tvar dp = Array(repeating: 0, count: nums.count)\\n\\n\\tdp[0] = nums[0]\\n\\tdp[1] = max(nums[1], nums[0])\\n\\n\\tif nums.count == 2 { return dp[1] }\\n\\n\\tfor i in 2..<nums.count {\\n\\t\\tdp[i] = max(dp[i-1], nums[i] + dp[i-2])\\n\\t\\tmaxMoney = max(dp[i], maxMoney)\\n\\t}\\n\\n\\treturn maxMoney\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rob(_ nums: [Int]) -> Int {\\n\\tguard !nums.isEmpty else { return 0 }\\n\\n\\tif nums.count == 1 { return nums[0] }\\n\\tif nums.count == 2 { return max(nums[0], nums[1]) }\\n\\n\\tlet n = nums.count\\n\\n\\treturn max(robHelper(Array(nums[0...n-2])), robHelper(Array(nums[1...n-1])))\\n}\\n\\nfunc robHelper(_ nums: [Int]) -> Int {\\n\\tvar maxMoney = 0\\n\\tvar dp = Array(repeating: 0, count: nums.count)\\n\\n\\tdp[0] = nums[0]\\n\\tdp[1] = max(nums[1], nums[0])\\n\\n\\tif nums.count == 2 { return dp[1] }\\n\\n\\tfor i in 2..<nums.count {\\n\\t\\tdp[i] = max(dp[i-1], nums[i] + dp[i-2])\\n\\t\\tmaxMoney = max(dp[i], maxMoney)\\n\\t}\\n\\n\\treturn maxMoney\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371982,
                "title": "c-o-n-dp-solution",
                "content": "DP1: Include 1st element and ignore last element.\\nDP2: Include last and ignore first.\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        if(n<2) return nums[0];\\n        int dp1[n+1];\\n        int dp2[n+1];\\n        dp1[0] = 0;\\n        dp1[1] = nums[0];\\n        dp2[0] = 0;\\n        dp2[1] = 0;\\n        for(int i = 2; i <= n; i++) {\\n            dp1[i] = max(dp1[i-1], nums[i-1] + dp1[i-2]);\\n            dp2[i] = max(dp2[i-1], nums[i-1] + dp2[i-2]);\\n        }\\n        return max(dp1[n-1], dp2[n]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        if(n<2) return nums[0];\\n        int dp1[n+1];\\n        int dp2[n+1];\\n        dp1[0] = 0;\\n        dp1[1] = nums[0];\\n        dp2[0] = 0;\\n        dp2[1] = 0;\\n        for(int i = 2; i <= n; i++) {\\n            dp1[i] = max(dp1[i-1], nums[i-1] + dp1[i-2]);\\n            dp2[i] = max(dp2[i-1], nums[i-1] + dp2[i-2]);\\n        }\\n        return max(dp1[n-1], dp2[n]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305658,
                "title": "javascript-solution-o-n-time-o-2n-space",
                "content": "```\\nvar rob = function(nums) {\\n  const N = nums.length\\n  if (N === 0) return 0;\\n  if (N === 1) return nums[0];\\n  \\n  // robbing first house\\n  const dp = [nums[0], Math.max(nums[0], nums[1])]\\n  \\n  // robbing last house\\n  const dp2 = [0, nums[1]]\\n  \\n  for (let i = 2; i < N; i++) {\\n    dp[i] = i === N - 1 ? dp[i-1] : Math.max(dp[i-1], dp[i - 2] + nums[i]);\\n    dp2[i] = Math.max(dp2[i-1], dp2[i - 2] + nums[i])\\n  \\n  }\\n\\n  return Math.max(dp[N - 1], dp2[N - 1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rob = function(nums) {\\n  const N = nums.length\\n  if (N === 0) return 0;\\n  if (N === 1) return nums[0];\\n  \\n  // robbing first house\\n  const dp = [nums[0], Math.max(nums[0], nums[1])]\\n  \\n  // robbing last house\\n  const dp2 = [0, nums[1]]\\n  \\n  for (let i = 2; i < N; i++) {\\n    dp[i] = i === N - 1 ? dp[i-1] : Math.max(dp[i-1], dp[i - 2] + nums[i]);\\n    dp2[i] = Math.max(dp2[i-1], dp2[i - 2] + nums[i])\\n  \\n  }\\n\\n  return Math.max(dp[N - 1], dp2[N - 1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295085,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        var n = nums.Length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var numList = new List<int>(nums);\\n        numList.RemoveAt(0);\\n        var candidate1 = Rob(numList);\\n\\n        numList = new List<int>(nums);\\n        numList.RemoveAt(n - 1);\\n        var cnadidate2 = Rob(numList);\\n\\n        return Math.Max(candidate1, cnadidate2);\\n    }\\n\\n    private int Rob(List<int> nums) {\\n        var n = nums.Count;\\n\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var prePre = 0;\\n        var pre = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            var cur = Math.Max(prePre + nums[i], pre);\\n            prePre = pre;\\n            pre = cur;\\n        }\\n\\n        return pre;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        var n = nums.Length;\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var numList = new List<int>(nums);\\n        numList.RemoveAt(0);\\n        var candidate1 = Rob(numList);\\n\\n        numList = new List<int>(nums);\\n        numList.RemoveAt(n - 1);\\n        var cnadidate2 = Rob(numList);\\n\\n        return Math.Max(candidate1, cnadidate2);\\n    }\\n\\n    private int Rob(List<int> nums) {\\n        var n = nums.Count;\\n\\n        if (n == 0) return 0;\\n        if (n == 1) return nums[0];\\n\\n        var prePre = 0;\\n        var pre = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            var cur = Math.Max(prePre + nums[i], pre);\\n            prePre = pre;\\n            pre = cur;\\n        }\\n\\n        return pre;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1763354,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1573452,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1829110,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1566907,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1575858,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1572254,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1567918,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1807059,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1576601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1755175,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1763354,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1573452,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1829110,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1566907,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1575858,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1572254,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1567918,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1807059,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1576601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1755175,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "After AI has replaced programmers,we now have tips for becoming a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "Chronoviser",
                        "content": "You will be able to do this only if **you have solved HOUSE ROBBER I** :\\n1. apply house robber I on nums(1,n-1)                     //*left to right*\\n2. apply house robber I on nums(n,2)                       //r*ight to left*\\n3. return max(answer obtained in step 1, answer obtained in step 2)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "orrca",
                        "content": "Actually, i\\'ve seen this a few times but you don\\'t need to apply the second house robber right to left. The main thing we\\'re concerned about here is just applying house robber twice: once without the first element, and once without the last element. By iterating backwards we\\'re adding an extra taxing step that will lower the runtime of your solution. Additionally, this just makes the code more readable, since you\\'re not passing in the array reversed excluding the 0th element."
                    },
                    {
                        "username": "himanshu_vyas",
                        "content": "Great suggestion! "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "Oye Pols Aa Gayi Pols...................."
                    },
                    {
                        "username": "stevenwittkopf",
                        "content": "In any situation with two houses, you cannot rob either house as they are adjacent on both sides. This should give the outcome zero. Instead the solution favors the maximum of either house."
                    },
                    {
                        "username": "y986873c",
                        "content": "It says you cannot rob two adjacent houses, TWO! So if you only rob either one of the two adjacent houses, it won\\'t trigger the alert."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE  of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "user8174k",
                        "content": "you can\\'t rob both, but still you can rob one of them "
                    },
                    {
                        "username": "unknownunit",
                        "content": "I have a question: When input is [1, 1], the answer given is 1. Should it not be 0 since you cannot rob either house?"
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "I think you would be able to rob one or the other, but not both. "
                    },
                    {
                        "username": "makeapp",
                        "content": "Can someone point out why this is 16?\\n\\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\\n  Output:\\n  15\\n  Expected:\\n  16\\n\\n"
                    },
                    {
                        "username": "mrkeyzzz",
                        "content": "Remember, you don\\'t have to select every other house. If you want to skip 2 you can."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "Rob houses, 3,5,3,5 -- gives you 16."
                    },
                    {
                        "username": "yueyub",
                        "content": "if only two houses, we can not rob either of them. Because as stated in the question, the first house to connected to the second, and then the second is also connected to the first, to form a two-point loop."
                    },
                    {
                        "username": "janhs",
                        "content": "If you only rob ONE of the two houses, then you haven\\'t robbed two adjacent houses, because you haven\\'t robbed two houses"
                    },
                    {
                        "username": "orrca",
                        "content": "This is actually not true. The question states that we can\\'t rob two adjacent houses, but we can rob one of the two. This makes the base case a lot more simple, as you just find the max value of the two elements."
                    },
                    {
                        "username": "bookworm5253",
                        "content": "Proof that maximum robbed lies in g1 = f[0, n-2] or g2 = f[1, n-1]. i.e max_robbed = max(g1, g2)\ng1, g2 represent maximum that can be robbed from given indices.\nf -> returns max earnings wrt indices passed.\nConsider non-circular case:\nmax_robbed contains:\ni) both 0 & n-1;\nii) either 0 or n-1;\niii) neither 0 or n-1;\n\nIn case-i:\nWe'll have to eliminate either house at 0 or n-1, as adjacent houses are not allowed. If we eliminate 0, we get g2. On the other hand, if we eliminate house at n - 1, we get g1. Now, we have to find out eliminating which will result in a lesser decrease in our earnings. Hence, max_robbed = max(g1, g2);\n\nIn case-ii:\nIf max_robbed contains 0 but not n-1, then g1 == f(0, n-1)\nSimilarly, if max_robbed only contains n-1, g2 == f(0, n-1)\nAgain, we can get max_robbed by getting max(g1, g2)\n\nIn case-iii\nSince, max_robbed does not contain either 0 or n-1;\ng1 == g2 == f(0, n-1) == f(1, n-2)\nhence, max_robbed = max(g1, g2) == f(1, n-2)"
                    },
                    {
                        "username": "helloworld000",
                        "content": "I am looking for a bottom up dp solution, where by I want to understand how to handle the choosing from [1,n-1] or [2,n] since house are in circular fashion."
                    },
                    {
                        "username": "shakticse",
                        "content": "Hey ! .. if you solved this problem  { https://leetcode.com/problems/house-robber/?envType=study-plan&id=dynamic-programming-i } .. then i believe you have the battle won .\\nFor this question the only thing you need to make sure is that you dont rob the first house if you want to rob the last house and vica-versa.\\nYou solution to this why bother about the bigger problem \\nSee there are only two cases possible with our constraint that we either \\na.) take first house and leave the last one \\nb.) leave first house and take last one \\nSo just simply dont consider that there is a first house , that handles (a) and then simply dont consider the last house , that handles (b) , now the max of these is our final answer"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "The way I did it was dp solution, but since it was circular that made it complex.  The way to make it linear is to just solve it twice.\\n\\nFirst solve as though the first house is robbed, then solve as though the first house is not robbed.\\n\\nReturn the max of those two."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/house-robber-ii/solutions/3043403/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please stop spamming your solutions everywhere in every discussion session. The discussion session isn\\'t ment for solutions, that\\'s what the \\'Solutions\\' tab is for. "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "There is no such thing as FAANG, it is now MAANG"
                    }
                ]
            },
            {
                "id": 1629825,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1573936,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1568464,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1569025,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1571439,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 2054231,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 2049683,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 2027590,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1980019,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1959915,
                "content": [
                    {
                        "username": "kushal_singh22",
                        "content": "observing from the test cases is the key!"
                    },
                    {
                        "username": "shameek_ag",
                        "content": "can someone please provide with a proof for this question??\\nlike i understand that A[n - 1] cannot depend on A[0] so we should split but i am not exactly convinced"
                    },
                    {
                        "username": "lgarciao",
                        "content": "I am not sure what your question is, but I think going over this test case may help:\\n[200,3,140,20,10]"
                    },
                    {
                        "username": "KaustubhKhulbe",
                        "content": "Hey everyone! I am new to this type of stuff and just wanted to know what does a \"lexicgoraphically sorted\" string mean. For today\\'s daily problem, they inputed cbacdcbc and it outputed acdb. Why is it not abcd? Thanks!"
                    },
                    {
                        "username": "chadrickj8",
                        "content": "Generalization of the alphabetical order or going from lowest to highest in this case"
                    },
                    {
                        "username": "camcam",
                        "content": "Expected to be 1. But in this case, they cannot be robbed. Shouldn't the result be 0????"
                    },
                    {
                        "username": "nadirwu",
                        "content": "Is it possible to solve it in one pass?"
                    },
                    {
                        "username": "qqqaaasss",
                        "content": "When len(nums) == 2, the answer should be 0 since these two houses are connected together in a loop! However, the answer is max(nums), which is incorrect. "
                    },
                    {
                        "username": "SidharthVerma",
                        "content": "the expample\\'s last test case [1,2,3] is wrong i guess because house at index 1 can only be robbed so the answer must be 2"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Using dp twice over [0,n-2] and [1,n-1] is brilliant!"
                    },
                    {
                        "username": "prnvsgr",
                        "content": "Can anyone explain why this is not working and showing wrong answer for [200,3,140,20,10]\\n\\nclass Solution {\\n    public int solve(int[] nums, int[] memo, int index, int lastHouse) {\\n        if (index > lastHouse) return 0;\\n        \\n        if (memo[index] != -1) return memo[index];\\n        // steal\\n        int robValue = nums[index] + solve(nums, memo, index + 2, lastHouse);\\n        // skip \\n        int skipValue = solve(nums, memo, index + 1, lastHouse);\\n\\n        return memo[index] = Math.max(robValue, skipValue);\\n    }\\n    \\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        int[] memo = new int[n];\\n        if (n == 1) return nums[0];\\n        if (n == 2) return Math.max(nums[0], nums[1]); \\n        Arrays.fill(memo, -1);\\n        \\n        return Math.max(solve(nums, memo, 1, n - 1), solve(nums, memo, 0, n - 2));\\n    }\\n}"
                    },
                    {
                        "username": "layyy",
                        "content": "split the problem into two subproblems of size 0 to n-1 and 1 to n"
                    }
                ]
            },
            {
                "id": 1945578,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1940322,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1939538,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1935910,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1927920,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1863467,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1841566,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1785338,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1757520,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            },
            {
                "id": 1734673,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Philosophical questions: How can one house be arranged in a circle? Would it be adjacent to itself?"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Be a good programmer, also a house robber \\uD83D\\uDE02"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A very weird corner case is present,think hard folks"
                    },
                    {
                        "username": "riyagondwal1390",
                        "content": "for the same question using memoization approach we are getting two wrong test cases on coding ninjas platform, whereas it is submitting here , can anybody figure out why?\\nhttps://www.codingninjas.com/codestudio/problems/house-robber_839733?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1.\\nthis is the link of the stated problem"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "CAN SOMEONE PLEASE TELL ME WHAT'S WRONG WITH THIS CODE\n\nclass Solution {\npublic:\n    int f(int ind, vector<int>& nums, vector<int>& dp) {\n    if(ind == 1)\n    {\n        return max(nums[0], nums[1]);\n    }\n    if (ind < 0) \n    {\n        return 0;\n    }\n    if (dp[ind] != -1) {\n        return dp[ind];\n    }\n    int pick = nums[ind] + f(ind - 2, nums, dp);\n    int notPick = f(ind - 1, nums, dp);\n    return dp[ind] = max(pick, notPick);\n}\n    int rob(vector<int>& nums) \n    {\n            vector<int> dp(nums.size(), -1);\n            vector<int> v1 =  nums;\n            vector<int> v2 = nums;\n            if(v1.size() > 1 && v2.size() > 1)\n            {\n            v1.erase(v1.end()-1);\n            v2.erase(v2.begin());\n            }\n            int ans1 = f(v1.size()-1, v1, dp);\n            int ans2 = f(v2.size()-1, v2, dp);\n            return max(ans1, ans2);\n    }\n};"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "How does Leetcode know who I am?"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": "can anyone tell issue in this code \\nnot running for testcase 1231 \\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        vector<int> temp1,temp2;\\n        for(int i=0;i<n;i++){\\n           if(i !=0) temp1.push_back(nums[i]);\\n           if(i !=n-1) temp2.push_back(nums[i]);\\n        }\\n        int x = temp1.size();\\n        int y= temp2.size();\\n        return max(f(temp1,x-1,dp),f(temp2,y-1,dp));\\n    }\\n    int f(vector<int>& nums,int i,vector<int>& dp){\\n        \\n        if(i==0) return nums[i];\\n        if(i<0) return 0;\\n        if(dp[i] !=-1) return dp[i];\\n        int pick = nums[i] +f(nums,i-2,dp);\\n        int notpick  = f(nums,i-1,dp);\\n        \\n        return dp[i] = max(pick,notpick);\\n    }\\n};"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. make two arrays : nums[1:n] and nums[0:n-1]\\n2. use houserobber method on both arrays and return the max of them. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ayushdubeymanu0786",
                        "content": "compiler is crashed\\nit is not giving right results for [200,3,140,20,10] this one plz correct this"
                    }
                ]
            }
        ]
    },
    {
        "title": "Knight Probability in Chessboard",
        "question_content": "<p>On an <code>n x n</code> chessboard, a knight starts at the cell <code>(row, column)</code> and attempts to make exactly <code>k</code> moves. The rows and columns are <strong>0-indexed</strong>, so the top-left cell is <code>(0, 0)</code>, and the bottom-right cell is <code>(n - 1, n - 1)</code>.</p>\n\n<p>A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.</p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/knight.png\" style=\"width: 300px; height: 300px;\" />\n<p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p>\n\n<p>The knight continues moving until it has made exactly <code>k</code> moves or has moved off the chessboard.</p>\n\n<p>Return <em>the probability that the knight remains on the board after it has stopped moving</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 2, row = 0, column = 0\n<strong>Output:</strong> 0.06250\n<strong>Explanation:</strong> There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 0, row = 0, column = 0\n<strong>Output:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 25</code></li>\n\t<li><code>0 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= row, column &lt;= n - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 113954,
                "title": "evolve-from-recursive-to-dp-beats-94",
                "content": "recursive version(TLE):\\n```\\nclass Solution {\\n    private int[][]dir = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        return find(N,K,r,c);\\n    }\\n    public double find(int N,int K,int r,int c){\\n        if(r < 0 || r > N - 1 || c < 0 || c > N - 1) return 0;\\n        if(K == 0)  return 1;\\n        double rate = 0;\\n        for(int i = 0;i < dir.length;i++){\\n            rate += 0.125 * find(N,K - 1,r + dir[i][0],c + dir[i][1]);\\n        }\\n        return rate;\\n    }\\n}\\n```\\n\\ndp version:\\n```\\nclass Solution {\\n    private int[][]dir = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    private double[][][] dp;\\n    public double knightProbability(int N, int K, int r, int c) {\\n        dp = new double[N][N][K + 1];\\n        return find(N,K,r,c);\\n    }\\n    public double find(int N,int K,int r,int c){\\n        if(r < 0 || r > N - 1 || c < 0 || c > N - 1) return 0;\\n        if(K == 0)  return 1;\\n        if(dp[r][c][K] != 0) return dp[r][c][K];\\n        double rate = 0;\\n        for(int i = 0;i < dir.length;i++)   rate += 0.125 * find(N,K - 1,r + dir[i][0],c + dir[i][1]);\\n        dp[r][c][K] = rate;\\n        return rate;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][]dir = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        return find(N,K,r,c);\\n    }\\n    public double find(int N,int K,int r,int c){\\n        if(r < 0 || r > N - 1 || c < 0 || c > N - 1) return 0;\\n        if(K == 0)  return 1;\\n        double rate = 0;\\n        for(int i = 0;i < dir.length;i++){\\n            rate += 0.125 * find(N,K - 1,r + dir[i][0],c + dir[i][1]);\\n        }\\n        return rate;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[][]dir = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    private double[][][] dp;\\n    public double knightProbability(int N, int K, int r, int c) {\\n        dp = new double[N][N][K + 1];\\n        return find(N,K,r,c);\\n    }\\n    public double find(int N,int K,int r,int c){\\n        if(r < 0 || r > N - 1 || c < 0 || c > N - 1) return 0;\\n        if(K == 0)  return 1;\\n        if(dp[r][c][K] != 0) return dp[r][c][K];\\n        double rate = 0;\\n        for(int i = 0;i < dir.length;i++)   rate += 0.125 * find(N,K - 1,r + dir[i][0],c + dir[i][1]);\\n        dp[r][c][K] = rate;\\n        return rate;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115213,
                "title": "c-memoization-easy-to-understand",
                "content": "```\nclass Solution {\nprivate:\n    unordered_map<int, unordered_map<int, unordered_map<int, double>>>dp;\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        if(dp.count(r) && dp[r].count(c) && dp[r][c].count(K)) return dp[r][c][K];\n        if(r < 0 || r >= N || c < 0 || c >= N) return 0;\n        if(K == 0) return 1;\n        double total = knightProbability(N, K - 1, r - 1, c - 2) + knightProbability(N, K - 1, r - 2, c - 1) \n                     + knightProbability(N, K - 1, r - 1, c + 2) + knightProbability(N, K - 1, r - 2, c + 1) \n                     + knightProbability(N, K - 1, r + 1, c + 2) + knightProbability(N, K - 1, r + 2, c + 1) \n                     + knightProbability(N, K - 1, r + 1, c - 2) + knightProbability(N, K - 1, r + 2, c - 1);\n        double res = total / 8;\n        dp[r][c][K] = res;\n        return res;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\nprivate:\n    unordered_map<int, unordered_map<int, unordered_map<int, double>>>dp;\npublic:\n    double knightProbability(int N, int K, int r, int c) {\n        if(dp.count(r) && dp[r].count(c) && dp[r][c].count(K)) return dp[r][c][K];\n        if(r < 0 || r >= N || c < 0 || c >= N) return 0;\n        if(K == 0) return 1;\n        double total = knightProbability(N, K - 1, r - 1, c - 2) + knightProbability(N, K - 1, r - 2, c - 1) \n                     + knightProbability(N, K - 1, r - 1, c + 2) + knightProbability(N, K - 1, r - 2, c + 1) \n                     + knightProbability(N, K - 1, r + 1, c + 2) + knightProbability(N, K - 1, r + 2, c + 1) \n                     + knightProbability(N, K - 1, r + 1, c - 2) + knightProbability(N, K - 1, r + 2, c - 1);\n        double res = total / 8;\n        dp[r][c][K] = res;\n        return res;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 162722,
                "title": "simple-java-dp-solution-with-explanation",
                "content": "The first solution uses O(k*n^2) space for simplicity:\\nAt every k and position i j we store the probability that the knight landed at position i j at step k.  We know that this probability is the sum of probabilities of the 8 directions in the previous step k-1 because in the previous step all 8 of those knight\\'s have a chance of moving here.  For example since one of the directions is 2, 1 we take the current i-2 and j-1 and add that probability/8.0 (because if the knight is currently at i-2, j-1 the chance is only /8.0 that he\\'ll choose this direction out of his 7 other choices).  \\nWe initialize the r , c index of the k==0 board to 1, because at step 0, we already have the knight at position r, c so the chance it lands there in 0 steps is 100%.\\nThe result is the sum of probabilities in all areas of the board in the Kth index Board.\\n```\\nclass Solution {\\n    int [][] direction =new int[][]{{2,1},{-2,1},{2,-1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n   \\n    public double knightProbability(int N, int K, int r, int c) {\\n        double [][][] ways = new double[K+1][N][N];\\n        ways[0][r][c]=1;\\n        for(int k=1; k<=K;++k){\\n            for(int i=0; i<N;++i){\\n                for(int j=0; j<N;++j){\\n                    for(int [] dir: direction){\\n                        int oldR = i-dir[0];\\n                        int oldC = j-dir[1];\\n                        if(oldR>=0 && oldC>=0 && oldR<N && oldC<N){\\n                            ways[k][i][j]+=(ways[k-1][oldR][oldC]/8.0);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        double res = 0;\\n        for(int i=0; i<N;++i){\\n            for(int j=0; j<N;++j){\\n                res+=ways[K][i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nbecause we only use the k and k-1 at every step we can just make the new Kth board be a variable and set the previous one to a previous variable, reducing the space to O(n^2):\\n```\\nclass Solution {\\n    int [][] direction =new int[][]{{2,1},{-2,1},{2,-1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n   \\n    public double knightProbability(int N, int K, int r, int c) {\\n        double [][] prevWays = new double[N][N];\\n        prevWays[r][c]=1;\\n        double res = 0;\\n        for(int k=1; k<=K;++k){\\n            double [][] ways = new double[N][N];\\n            for(int i=0; i<N;++i){\\n                for(int j=0; j<N;++j){\\n                    for(int [] dir: direction){\\n                        int oldR = i-dir[0];\\n                        int oldC = j-dir[1];\\n                        if(oldR>=0 && oldC>=0 && oldR<N && oldC<N){\\n                            ways[i][j]+=(prevWays[oldR][oldC]/8.0);\\n                        }\\n                    }\\n                }\\n            }\\n            prevWays=ways;\\n        }\\n        for(int i=0; i<N;++i){\\n            for(int j=0; j<N;++j){\\n                res+=prevWays[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][] direction =new int[][]{{2,1},{-2,1},{2,-1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n   \\n    public double knightProbability(int N, int K, int r, int c) {\\n        double [][][] ways = new double[K+1][N][N];\\n        ways[0][r][c]=1;\\n        for(int k=1; k<=K;++k){\\n            for(int i=0; i<N;++i){\\n                for(int j=0; j<N;++j){\\n                    for(int [] dir: direction){\\n                        int oldR = i-dir[0];\\n                        int oldC = j-dir[1];\\n                        if(oldR>=0 && oldC>=0 && oldR<N && oldC<N){\\n                            ways[k][i][j]+=(ways[k-1][oldR][oldC]/8.0);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        double res = 0;\\n        for(int i=0; i<N;++i){\\n            for(int j=0; j<N;++j){\\n                res+=ways[K][i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int [][] direction =new int[][]{{2,1},{-2,1},{2,-1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n   \\n    public double knightProbability(int N, int K, int r, int c) {\\n        double [][] prevWays = new double[N][N];\\n        prevWays[r][c]=1;\\n        double res = 0;\\n        for(int k=1; k<=K;++k){\\n            double [][] ways = new double[N][N];\\n            for(int i=0; i<N;++i){\\n                for(int j=0; j<N;++j){\\n                    for(int [] dir: direction){\\n                        int oldR = i-dir[0];\\n                        int oldC = j-dir[1];\\n                        if(oldR>=0 && oldC>=0 && oldR<N && oldC<N){\\n                            ways[i][j]+=(prevWays[oldR][oldC]/8.0);\\n                        }\\n                    }\\n                }\\n            }\\n            prevWays=ways;\\n        }\\n        for(int i=0; i<N;++i){\\n            for(int j=0; j<N;++j){\\n                res+=prevWays[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889598,
                "title": "c-dp-solution-explained",
                "content": "Runtime: 8 ms, faster than 86.35% of C++ online submissions for Knight Probability in Chessboard.\\nMemory Usage: 6.9 MB, less than 5.54% of C++ online submissions for Knight Probability in Chessboard.\\n\\n```\\nHere knight\\'s each move has probability 1.0/8.0 = 0.125. Now intially in position start = (r,c) the proabability\\nof knight move is 1.0 so, when there is a move from start to new position child (r+x, c+y), the probability of\\nnew position will be prob_new_pos += prob_start/ 8.0 and same goes for all other parent and child positions.\\nAs there can be multiple way to end up in a position from different positions, we add their probability as\\nthose are mutually exclusive events and also from parent to child position we divide parent probability by\\n8.0 as those events are dependent or in chain and every move has proability 1/8.  After K steps , we sum up\\nall the probability of the chess board positions.\\n\\nExample: N = 3, K = 2, r= 0, c = 0\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/1fdc28a2-1430-4be5-8c21-7b422ac450dc_1602412179.1889427.png)\\n\\n```\\nSo, total probability =  0.015625 * 4 = 0.0625\\n\\n\\'Time Complexity = O(N * N * K)\\'\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    double knightProbability(int N, int K, int r, int c){\\n        \\n        // no moves so probability 1\\n        if(K==0) return 1.0;\\n        \\n        // parent chess board\\n        vector<vector<double>> parentBoard(N,vector<double>(N,0.0));\\n        \\n        // child chess board\\n        vector<vector<double>> childBoard(N,vector<double>(N,0.0));\\n        \\n        // row and col offset for generating next move or child positions\\n        int rowoffset[] = {-2,-2,-1,-1,2,2,1,1};\\n        int coloffset[] = {1,-1,2,-2,1,-1,2,-2};\\n        \\n        int cx,cy;\\n        \\n        // initial position probability 1\\n        parentBoard[r][c] = 1.0;\\n        \\n        // Run K steps\\n        // Each step update the child position probability from parent position \\n        // After each step assign child as parent board and create new child board\\n        for(int i=0;i<K;i++)\\n        {\\n            for(int p=0;p<N;p++)\\n            {\\n                for(int q=0;q<N;q++)\\n                { \\n                    // calculate child position proabilty once from parent position probability\\n                    double moveProb = parentBoard[p][q]/8.0;\\n                    \\n                    // generate valid child positions\\n                    for(int w=0;w<8;w++)\\n                    {\\n                        cx = p + rowoffset[w];\\n                        cy = q + coloffset[w];\\n\\n                        // update child position probability\\n                        if(cx>=0 && cx<N && cy>=0 && cy<N)\\n                            childBoard[cx][cy] += moveProb;\\n                    }                    \\n                }\\n            }\\n            \\n            parentBoard = childBoard;\\n            fill(childBoard.begin(),childBoard.end(),vector<double>(N,0.0));\\n        }\\n        \\n\\n        \\n        double knightProb = 0.0;\\n        \\n        // Loop through parent board after K steps and sum up all probability\\n        for(int p=0;p<N;p++)\\n            for(int q=0;q<N;q++)\\n                   knightProb+=parentBoard[p][q];\\n\\n        return knightProb;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nHere knight\\'s each move has probability 1.0/8.0 = 0.125. Now intially in position start = (r,c) the proabability\\nof knight move is 1.0 so, when there is a move from start to new position child (r+x, c+y), the probability of\\nnew position will be prob_new_pos += prob_start/ 8.0 and same goes for all other parent and child positions.\\nAs there can be multiple way to end up in a position from different positions, we add their probability as\\nthose are mutually exclusive events and also from parent to child position we divide parent probability by\\n8.0 as those events are dependent or in chain and every move has proability 1/8.  After K steps , we sum up\\nall the probability of the chess board positions.\\n\\nExample: N = 3, K = 2, r= 0, c = 0\\n```\n```\\nSo, total probability =  0.015625 * 4 = 0.0625\\n\\n\\'Time Complexity = O(N * N * K)\\'\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    double knightProbability(int N, int K, int r, int c){\\n        \\n        // no moves so probability 1\\n        if(K==0) return 1.0;\\n        \\n        // parent chess board\\n        vector<vector<double>> parentBoard(N,vector<double>(N,0.0));\\n        \\n        // child chess board\\n        vector<vector<double>> childBoard(N,vector<double>(N,0.0));\\n        \\n        // row and col offset for generating next move or child positions\\n        int rowoffset[] = {-2,-2,-1,-1,2,2,1,1};\\n        int coloffset[] = {1,-1,2,-2,1,-1,2,-2};\\n        \\n        int cx,cy;\\n        \\n        // initial position probability 1\\n        parentBoard[r][c] = 1.0;\\n        \\n        // Run K steps\\n        // Each step update the child position probability from parent position \\n        // After each step assign child as parent board and create new child board\\n        for(int i=0;i<K;i++)\\n        {\\n            for(int p=0;p<N;p++)\\n            {\\n                for(int q=0;q<N;q++)\\n                { \\n                    // calculate child position proabilty once from parent position probability\\n                    double moveProb = parentBoard[p][q]/8.0;\\n                    \\n                    // generate valid child positions\\n                    for(int w=0;w<8;w++)\\n                    {\\n                        cx = p + rowoffset[w];\\n                        cy = q + coloffset[w];\\n\\n                        // update child position probability\\n                        if(cx>=0 && cx<N && cy>=0 && cy<N)\\n                            childBoard[cx][cy] += moveProb;\\n                    }                    \\n                }\\n            }\\n            \\n            parentBoard = childBoard;\\n            fill(childBoard.begin(),childBoard.end(),vector<double>(N,0.0));\\n        }\\n        \\n\\n        \\n        double knightProb = 0.0;\\n        \\n        // Loop through parent board after K steps and sum up all probability\\n        for(int p=0;p<N;p++)\\n            for(int q=0;q<N;q++)\\n                   knightProb+=parentBoard[p][q];\\n\\n        return knightProb;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108181,
                "title": "my-accepted-dp-solution",
                "content": "```\\nint[][] moves = {{1, 2}, {1, -2}, {2, 1}, {2, -1}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}};\\npublic double knightProbability(int N, int K, int r, int c) {\\n    int len = N;\\n    double dp0[][] = new double[len][len];\\n    for(double[] row : dp0) Arrays.fill(row, 1);\\n    for(int l = 0; l < K; l++) {\\n        double[][] dp1 = new double[len][len];\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < len; j++) {\\n                for(int[] move : moves) {\\n                    int row = i + move[0];\\n                    int col = j + move[1];\\n                    if(isLegal(row, col, len)) dp1[i][j] += dp0[row][col];\\n                }\\n            }\\n        }\\n        dp0 = dp1;\\n    }\\n    return dp0[r][c] / Math.pow(8, K); \\n}\\nprivate boolean isLegal(int r, int c, int len) {\\n    return r >= 0 && r < len && c >= 0 && c < len;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint[][] moves = {{1, 2}, {1, -2}, {2, 1}, {2, -1}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}};\\npublic double knightProbability(int N, int K, int r, int c) {\\n    int len = N;\\n    double dp0[][] = new double[len][len];\\n    for(double[] row : dp0) Arrays.fill(row, 1);\\n    for(int l = 0; l < K; l++) {\\n        double[][] dp1 = new double[len][len];\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < len; j++) {\\n                for(int[] move : moves) {\\n                    int row = i + move[0];\\n                    int col = j + move[1];\\n                    if(isLegal(row, col, len)) dp1[i][j] += dp0[row][col];\\n                }\\n            }\\n        }\\n        dp0 = dp1;\\n    }\\n    return dp0[r][c] / Math.pow(8, K); \\n}\\nprivate boolean isLegal(int r, int c, int len) {\\n    return r >= 0 && r < len && c >= 0 && c < len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799090,
                "title": "image-explanation-probability-dp-super-easy-to-understand",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Knight Probability in Chessboard` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/acce3365-b682-4427-9a7d-48dd8a552a82_1690004822.287437.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/8dd19903-ef79-4485-a560-ad90b37b6142_1689999085.8943114.png)\\n![image.png](https://assets.leetcode.com/users/images/f41143d0-407f-48ef-b9df-6ceed7766fa0_1689999099.2577646.png)\\n![image.png](https://assets.leetcode.com/users/images/c9071a3a-1828-4ccc-bbd0-6eb225e4ad4e_1689999107.0034423.png)\\n![image.png](https://assets.leetcode.com/users/images/3173cfc3-f142-4421-9e52-53d36bac1400_1689999114.0475938.png)\\n![image.png](https://assets.leetcode.com/users/images/912286d9-24bd-4d09-a1af-287df6e92733_1689999122.240634.png)\\n![image.png](https://assets.leetcode.com/users/images/edc0a9e1-a2b8-43d7-b5b9-e071fef130c4_1689999132.0428724.png)\\n![image.png](https://assets.leetcode.com/users/images/e6f44c97-bc1d-4511-b614-9cd480fcc1c9_1689999142.0163636.png)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<string,double> mp;\\n    int dir[8][8] = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        return find(n,k,row,column);\\n    }\\n\\n    double find(int n, int moves, int r, int c) {\\n        if(r<0 || r>=n || c<0 || c>=n)\\n            return 0;\\n        \\n        if(moves == 0)\\n            return 1;\\n        \\n        string key = to_string(r) + \"aryan\" + to_string(c) + \"mittal\" + to_string(moves);\\n        if(mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n        double probability = 0;\\n        for(int i=0; i<8; i++)\\n            probability += find(n,moves-1, r+dir[i][0], c+dir[i][1])/8.0 ;\\n        \\n        mp[key] = probability;\\n        return mp[key];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<string,double> mp;\\n    int dir[8][8] = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        return find(n,k,row,column);\\n    }\\n\\n    double find(int n, int moves, int r, int c) {\\n        if(r<0 || r>=n || c<0 || c>=n)\\n            return 0;\\n        \\n        if(moves == 0)\\n            return 1;\\n        \\n        string key = to_string(r) + \"aryan\" + to_string(c) + \"mittal\" + to_string(moves);\\n        if(mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n        double probability = 0;\\n        for(int i=0; i<8; i++)\\n            probability += find(n,moves-1, r+dir[i][0], c+dir[i][1])/8.0 ;\\n        \\n        mp[key] = probability;\\n        return mp[key];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143583,
                "title": "python-short-simple-dfs-w-memoization",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, N, K, r, c):\\n        memo = {}\\n        def dfs(i, j, p, k): \\n            if 0 <= i < N and 0 <= j < N and k < K:\\n                sm = 0\\n                for x, y in ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)):\\n                    if (i + x, j + y, k) not in memo:\\n                        memo[(i + x, j + y, k)] = dfs(i + x, j + y, p / 8, k + 1)\\n                    sm += memo[(i + x, j + y, k)]\\n                return sm\\n            else:\\n                return 0 <= i < N and 0 <= j < N and p or 0\\n        return dfs(r, c, 1, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, N, K, r, c):\\n        memo = {}\\n        def dfs(i, j, p, k): \\n            if 0 <= i < N and 0 <= j < N and k < K:\\n                sm = 0\\n                for x, y in ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)):\\n                    if (i + x, j + y, k) not in memo:\\n                        memo[(i + x, j + y, k)] = dfs(i + x, j + y, p / 8, k + 1)\\n                    sm += memo[(i + x, j + y, k)]\\n                return sm\\n            else:\\n                return 0 <= i < N and 0 <= j < N and p or 0\\n        return dfs(r, c, 1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800461,
                "title": "easy-to-understand-dp-with-explanation",
                "content": "# Intuition\\n\\n- The code uses dynamic programming to solve the knight probability problem. The probability array is initialized to all zeros, and then the probability of the knight being on the board after each move is calculated. The base case is that the knight is already on the board, so the probability is 1. The recursive step is to iterate over all possible moves and update the probability of the knight being on the board after each move. The final probability is the probability that the knight is on the board after k moves.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code below uses the DP approach. This approach is more efficient than recursion because it stores the probabilities for moves that have already been made. \\na step-by-step approach for the optimized code to find the probability that the knight remains on the board after making exactly k moves:\\n\\n1. Initialize a 2D dp array of size n x n to store the probabilities of the knight being on the board from a specific cell.\\n2. Set the initial probability of the starting cell (row, column) to 1.0, as the knight starts from this cell.\\n3. For each move from 1 to k, do the following:\\na. Create a new 2D newDp array to store the updated probabilities after one move.\\nb. Iterate through each cell (r, c) in the original dp array:\\n    - For each possible move of the knight, calculate the new position (nr, nc) after the move.\\n    - If the new position (nr, nc) is within the bounds of the n x n chessboard, update the probability in newDp[r][c] by adding the probability from the original dp[nr][nc] / 8.0. This is because the knight moves uniformly at random, so each move has a probability of 1/8 to be chosen.\\n    - Set dp to newDp to keep the updated probabilities for the next iteration.\\n4. After completing all k moves, calculate the total probability of the knight remaining on the board by summing up all the probabilities from the final dp array.\\n5. Return the total probability as the result.\\n\\n- The isValid helper function is used to check whether a move is valid, i.e., whether the new position (r, c) after the move is within the bounds of the n x n chessboard. This function returns true if the move is valid, and false otherwise.\\n\\n# Complexity\\n- Time complexity: O(n^2 * k). \\nThis is because the outer loop iterates over all possible values of k, and the inner loop iterates over all possible rows and columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    private final int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][] dp = new double[n][n];\\n        dp[row][column] = 1.0;\\n\\n        for(int move = 1; move<=k; move++) {\\n            double[][] ndp = new double[n][n];\\n            for(int r = 0; r<n; r++) {\\n                for(int c = 0; c<n; c++) {\\n                    for(int[] m: moves) {\\n                        int nr = r+m[0];\\n                        int nc = c+m[1];\\n                        if (isValid(nr, nc, n)) ndp[r][c] += dp[nr][nc]/8.0;\\n                    }\\n                }\\n            }\\n            dp = ndp;\\n        }\\n\\n        double prob = 0.0;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                prob += dp[r][c];\\n            }\\n        }\\n\\n        return prob;\\n    }\\n\\n    private boolean isValid(int r, int c, int n) {\\n        return r >= 0 && r < n && c >= 0 && c < n;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        dp[row][column] = 1;\\n\\n        vector<vector<int>> moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n        for (int move = 1; move <= k; move++) {\\n            vector<vector<double>> newDp(n, vector<double>(n, 0));\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (const auto& m : moves) {\\n                        int newR = r + m[0];\\n                        int newC = c + m[1];\\n                        if (isValid(newR, newC, n)) {\\n                            newDp[r][c] += dp[newR][newC] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = newDp;\\n        }\\n\\n        double probability = 0;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                probability += dp[r][c];\\n            }\\n        }\\n\\n        return probability;\\n    }\\n\\n    bool isValid(int r, int c, int n) {\\n        return r >= 0 && r < n && c >= 0 && c < n;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        dp = [[0] * n for _ in range(n)]\\n        dp[row][column] = 1\\n\\n        moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]\\n\\n        for move in range(1, k + 1):\\n            new_dp = [[0] * n for _ in range(n)]\\n            for r in range(n):\\n                for c in range(n):\\n                    for m in moves:\\n                        new_r = r + m[0]\\n                        new_c = c + m[1]\\n                        if 0 <= new_r < n and 0 <= new_c < n:\\n                            new_dp[r][c] += dp[new_r][new_c] / 8.0\\n            dp = new_dp\\n\\n        probability = 0.0\\n        for r in range(n):\\n            for c in range(n):\\n                probability += dp[r][c]\\n\\n        return probability\\n```\\n```C []\\ndouble knightProbability(int n, int k, int row, int column) {\\n    double dp[n][n];\\n    memset(dp, 0, sizeof(dp));\\n    dp[row][column] = 1;\\n\\n    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n    for (int move = 1; move <= k; move++) {\\n        double newDp[n][n];\\n        memset(newDp, 0, sizeof(newDp));\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                for (int i = 0; i < 8; i++) {\\n                    int newR = r + moves[i][0];\\n                    int newC = c + moves[i][1];\\n                    if (newR >= 0 && newR < n && newC >= 0 && newC < n) {\\n                        newDp[r][c] += dp[newR][newC] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n        memcpy(dp, newDp, sizeof(dp));\\n    }\\n\\n    double probability = 0;\\n    for (int r = 0; r < n; r++) {\\n        for (int c = 0; c < n; c++) {\\n            probability += dp[r][c];\\n        }\\n    }\\n\\n    return probability;\\n}\\n```\\n\\n> If you find my solution helpful, I would greatly appreciate your one upvote.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```Java []\\nclass Solution {\\n    private final int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][] dp = new double[n][n];\\n        dp[row][column] = 1.0;\\n\\n        for(int move = 1; move<=k; move++) {\\n            double[][] ndp = new double[n][n];\\n            for(int r = 0; r<n; r++) {\\n                for(int c = 0; c<n; c++) {\\n                    for(int[] m: moves) {\\n                        int nr = r+m[0];\\n                        int nc = c+m[1];\\n                        if (isValid(nr, nc, n)) ndp[r][c] += dp[nr][nc]/8.0;\\n                    }\\n                }\\n            }\\n            dp = ndp;\\n        }\\n\\n        double prob = 0.0;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                prob += dp[r][c];\\n            }\\n        }\\n\\n        return prob;\\n    }\\n\\n    private boolean isValid(int r, int c, int n) {\\n        return r >= 0 && r < n && c >= 0 && c < n;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        dp[row][column] = 1;\\n\\n        vector<vector<int>> moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n        for (int move = 1; move <= k; move++) {\\n            vector<vector<double>> newDp(n, vector<double>(n, 0));\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (const auto& m : moves) {\\n                        int newR = r + m[0];\\n                        int newC = c + m[1];\\n                        if (isValid(newR, newC, n)) {\\n                            newDp[r][c] += dp[newR][newC] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = newDp;\\n        }\\n\\n        double probability = 0;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                probability += dp[r][c];\\n            }\\n        }\\n\\n        return probability;\\n    }\\n\\n    bool isValid(int r, int c, int n) {\\n        return r >= 0 && r < n && c >= 0 && c < n;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        dp = [[0] * n for _ in range(n)]\\n        dp[row][column] = 1\\n\\n        moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]\\n\\n        for move in range(1, k + 1):\\n            new_dp = [[0] * n for _ in range(n)]\\n            for r in range(n):\\n                for c in range(n):\\n                    for m in moves:\\n                        new_r = r + m[0]\\n                        new_c = c + m[1]\\n                        if 0 <= new_r < n and 0 <= new_c < n:\\n                            new_dp[r][c] += dp[new_r][new_c] / 8.0\\n            dp = new_dp\\n\\n        probability = 0.0\\n        for r in range(n):\\n            for c in range(n):\\n                probability += dp[r][c]\\n\\n        return probability\\n```\n```C []\\ndouble knightProbability(int n, int k, int row, int column) {\\n    double dp[n][n];\\n    memset(dp, 0, sizeof(dp));\\n    dp[row][column] = 1;\\n\\n    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n    for (int move = 1; move <= k; move++) {\\n        double newDp[n][n];\\n        memset(newDp, 0, sizeof(newDp));\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                for (int i = 0; i < 8; i++) {\\n                    int newR = r + moves[i][0];\\n                    int newC = c + moves[i][1];\\n                    if (newR >= 0 && newR < n && newC >= 0 && newC < n) {\\n                        newDp[r][c] += dp[newR][newC] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n        memcpy(dp, newDp, sizeof(dp));\\n    }\\n\\n    double probability = 0;\\n    for (int r = 0; r < n; r++) {\\n        for (int c = 0; c < n; c++) {\\n            probability += dp[r][c];\\n        }\\n    }\\n\\n    return probability;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108214,
                "title": "my-easy-understand-dp-solution",
                "content": "```java\\nclass Solution {\\n    private int[][] dirs = new int[][]{{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][][] dp = new double[K + 1][N][N];\\n        dp[0][r][c] = 1;\\n        for (int step = 1; step <= K; step++) {\\n            for (int i = 0; i < N; i++) {\\n                for (int j = 0; j < N; j++) {\\n                    for (int[] dir : dirs) {\\n                        int x = dir[0] + i;\\n                        int y = dir[1] + j;\\n                        if (x < 0 || x >= N || y < 0 || y >= N) continue;\\n                        dp[step][i][j] += dp[step - 1][x][y] * 0.125;\\n                    }\\n                }\\n            }\\n        }\\n        double res = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                res += dp[K][i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private int[][] dirs = new int[][]{{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][][] dp = new double[K + 1][N][N];\\n        dp[0][r][c] = 1;\\n        for (int step = 1; step <= K; step++) {\\n            for (int i = 0; i < N; i++) {\\n                for (int j = 0; j < N; j++) {\\n                    for (int[] dir : dirs) {\\n                        int x = dir[0] + i;\\n                        int y = dir[1] + j;\\n                        if (x < 0 || x >= N || y < 0 || y >= N) continue;\\n                        dp[step][i][j] += dp[step - 1][x][y] * 0.125;\\n                    }\\n                }\\n            }\\n        }\\n        double res = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                res += dp[K][i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798820,
                "title": "very-easy-to-understand-video-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust do dfs and after dfs count all the cells that are visited after k move then \\njust calculate by formula p=favorableoutcome/totaloutcome.Dfs and memoize also so that we are not solving problems that are already solved.this will reduce time complexity.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/abaZ13EXgxQ\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The solution defines a class named \"Solution\" with a public function \"knightProbability\" that takes four parameters: n (size of the chessboard), k (number of moves), row (starting row index), and col (starting column index).\\n\\n2. The class contains a 3D array \"dp\" to store the results of subproblems. dp[i][j][k] will store the probability of the knight remaining on the board after making k moves starting from position (i, j).\\n\\n3. Two integer arrays, \"xmove\" and \"ymove,\" are used to represent all possible moves a knight can make on the chessboard.\\n\\n4. The \"solve\" function is a recursive function that calculates the probability of the knight remaining on the board after k moves starting from position (row, col).\\n\\n5. The base cases for the recursive function are:\\n   - If the knight moves outside the board (row < 0, col < 0, row >= n, col >= n), the probability is 0.\\n   - If the number of moves (k) becomes 0, the probability is 1 (since the knight remains on the board after 0 moves).\\n\\n6. The function first checks if the result for the current state (row, col, k) is already calculated and stored in the \"dp\" array. If so, it returns the precalculated value to avoid redundant calculations.\\n\\n7. If the result for the current state is not available, the function computes it using a loop that iterates over all possible knight moves. For each move, it recursively calls the \"solve\" function to get the probability of the knight remaining on the board after making k-1 moves from the new position (row+xmove[i], col+ymove[i]). The result is then accumulated in the \"ans\" variable.\\n\\n8. The probability for the current state (row, col, k) is stored in the \"dp\" array to avoid recomputation in future calls with the same parameters.\\n\\n9. In the \"knightProbability\" function, the \"dp\" array is initialized with -1.0 for all positions and moves using a nested loop.\\n\\n10. The function then calls the \"solve\" function to calculate the probability of the knight remaining on the board after k moves starting from the given position (row, col).\\n\\n11. The final result is the favorable outcome (the probability of the knight remaining on the board) divided by the total number of possible outcomes (8^k), which is the total number of valid knight moves in k steps.\\n\\n12. The function returns the computed probability.\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n*n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*n*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\ndouble dp[26][26][102];\\n    int xmove[8] = {-2,-2,-1,-1,1,1,2,2};\\n    int ymove[8] = {-1,1,-2,2,-2,2,-1,1};\\n  double solve(int row,int col,int n,int k){\\n        if(row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[row][col][k] != -1.0) return dp[row][col][k];\\n        \\n       double ans = 0;\\n        \\n        for(int i=0;i<8;i++){\\n            ans += solve(row+xmove[i], col+ymove[i], n, k-1);\\n        }\\n        \\n        return dp[row][col][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                for(int k=0;k<102;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        double favourableoutcome = solve(row,col,n,k);\\n        double totaloutcome = pow(8,k);\\n        return favourableoutcome/totaloutcome;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    double[][][] dp;\\n    int[] xmove = {-2, -2, -1, -1, 1, 1, 2, 2};\\n    int[] ymove = {-1, 1, -2, 2, -2, 2, -1, 1};\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        dp = new double[n][n][k + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1.0);\\n            }\\n        }\\n        double favourableOutcome = solve(row, col, n, k);\\n        double totalOutcome = Math.pow(8, k);\\n        return favourableOutcome / totalOutcome;\\n    }\\n\\n    private double solve(int row, int col, int n, int k) {\\n        if (row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if (k == 0) return 1;\\n        if (dp[row][col][k] != -1.0) return dp[row][col][k];\\n\\n        double ans = 0;\\n\\n        for (int i = 0; i < 8; i++) {\\n            ans += solve(row + xmove[i], col + ymove[i], n, k - 1);\\n        }\\n\\n        return dp[row][col][k] = ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = None\\n        self.xmove = [-2, -2, -1, -1, 1, 1, 2, 2]\\n        self.ymove = [-1, 1, -2, 2, -2, 2, -1, 1]\\n\\n    def knightProbability(self, n: int, k: int, row: int, col: int) -> float:\\n        self.dp = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]\\n        favourableOutcome = self.solve(row, col, n, k)\\n        totalOutcome = 8 ** k\\n        return favourableOutcome / totalOutcome\\n\\n    def solve(self, row: int, col: int, n: int, k: int) -> float:\\n        if row < 0 or col < 0 or row >= n or col >= n:\\n            return 0\\n        if k == 0:\\n            return 1\\n        if self.dp[row][col][k] != -1.0:\\n            return self.dp[row][col][k]\\n\\n        ans = 0\\n        for i in range(8):\\n            ans += self.solve(row + self.xmove[i], col + self.ymove[i], n, k - 1)\\n\\n        self.dp[row][col][k] = ans\\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\ndouble dp[26][26][102];\\n    int xmove[8] = {-2,-2,-1,-1,1,1,2,2};\\n    int ymove[8] = {-1,1,-2,2,-2,2,-1,1};\\n  double solve(int row,int col,int n,int k){\\n        if(row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[row][col][k] != -1.0) return dp[row][col][k];\\n        \\n       double ans = 0;\\n        \\n        for(int i=0;i<8;i++){\\n            ans += solve(row+xmove[i], col+ymove[i], n, k-1);\\n        }\\n        \\n        return dp[row][col][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                for(int k=0;k<102;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        double favourableoutcome = solve(row,col,n,k);\\n        double totaloutcome = pow(8,k);\\n        return favourableoutcome/totaloutcome;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    double[][][] dp;\\n    int[] xmove = {-2, -2, -1, -1, 1, 1, 2, 2};\\n    int[] ymove = {-1, 1, -2, 2, -2, 2, -1, 1};\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        dp = new double[n][n][k + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1.0);\\n            }\\n        }\\n        double favourableOutcome = solve(row, col, n, k);\\n        double totalOutcome = Math.pow(8, k);\\n        return favourableOutcome / totalOutcome;\\n    }\\n\\n    private double solve(int row, int col, int n, int k) {\\n        if (row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if (k == 0) return 1;\\n        if (dp[row][col][k] != -1.0) return dp[row][col][k];\\n\\n        double ans = 0;\\n\\n        for (int i = 0; i < 8; i++) {\\n            ans += solve(row + xmove[i], col + ymove[i], n, k - 1);\\n        }\\n\\n        return dp[row][col][k] = ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = None\\n        self.xmove = [-2, -2, -1, -1, 1, 1, 2, 2]\\n        self.ymove = [-1, 1, -2, 2, -2, 2, -1, 1]\\n\\n    def knightProbability(self, n: int, k: int, row: int, col: int) -> float:\\n        self.dp = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]\\n        favourableOutcome = self.solve(row, col, n, k)\\n        totalOutcome = 8 ** k\\n        return favourableOutcome / totalOutcome\\n\\n    def solve(self, row: int, col: int, n: int, k: int) -> float:\\n        if row < 0 or col < 0 or row >= n or col >= n:\\n            return 0\\n        if k == 0:\\n            return 1\\n        if self.dp[row][col][k] != -1.0:\\n            return self.dp[row][col][k]\\n\\n        ans = 0\\n        for i in range(8):\\n            ans += self.solve(row + self.xmove[i], col + self.ymove[i], n, k - 1)\\n\\n        self.dp[row][col][k] = ans\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206720,
                "title": "share-my-intuitive-recursive-java-solution",
                "content": "```\\nclass Solution {\\n    private static final int[][] dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n    Map<String, Double> map = new HashMap<>();\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if (r < 0 || r >= N || c < 0 || c >= N || K < 0) {\\n            return 0;\\n        }\\n        if (K == 0) {\\n            return 1;\\n        }\\n        String key = K + \",\" + r + \",\" + c;\\n        if (map.containsKey(key)) {\\n            return map.get(key);\\n        }\\n        double result = 0;\\n        for (int[] dir: dirs) {\\n            int row = r + dir[0];\\n            int col = c + dir[1];\\n            result += knightProbability(N, K - 1, row, col);\\n        }\\n        map.put(key, 0.125 * result);\\n        return 0.125 * result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n    Map<String, Double> map = new HashMap<>();\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if (r < 0 || r >= N || c < 0 || c >= N || K < 0) {\\n            return 0;\\n        }\\n        if (K == 0) {\\n            return 1;\\n        }\\n        String key = K + \",\" + r + \",\" + c;\\n        if (map.containsKey(key)) {\\n            return map.get(key);\\n        }\\n        double result = 0;\\n        for (int[] dir: dirs) {\\n            int row = r + dir[0];\\n            int col = c + dir[1];\\n            result += knightProbability(N, K - 1, row, col);\\n        }\\n        map.put(key, 0.125 * result);\\n        return 0.125 * result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837261,
                "title": "dfs-and-bfs-solutions-in-python",
                "content": "## Convert the problem into tree traversing\\nThe question is actually equivalent to a tree traverse problem.\\nConsider the start point as the root, the children of which are the in-board coordinates out of all 8 possible positions. The out-of-board positions are pruned. \\nLet `p(K, r, c)` be the in-board possiblity that Knight starts at `(r, c)` and moves `K` steps.\\nExample:\\n ```\\n K = 2, N = 3, r = 0, c = 0\\nStart:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tK 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp(2, 0, 0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n1st Move:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0                               0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0                               0 0 K\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 K 0                               0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\tp(1, 2, 1)                           p(1, 1, 2)\\n\\n2nd Move:\\n\\t\\t\\t\\t\\t\\t\\tK 0 0            0 0 K           K 0 0        0 0 0\\n\\t\\t\\t\\t\\t\\t\\t0 0 0            0 0 0           0 0 0        0 0 0\\n\\t\\t\\t\\t\\t\\t\\t0 0 0            0 0 0           0 0 0        K 0 0\\n\\t\\t\\t\\t\\t\\t\\t  (1)             (2)             (3)          (4)\\n\\t\\t\\t\\t   \\t\\tp(0, 0, 0)        p(0, 0, 2)      p(0, 0, 0)    p(0, 2, 0)\\n\\n```\\t  \\n> The last move has four children, hence the in-board posibility would be `p(2, 0, 0) = 4 * (1/8)^2`.\\n> Therefore, all we need to do is to count how many nodes there are in the last level, say `count`. The in-board possibility would be `count * (1 / 8) ^ K`\\n\\n\\nAs shown in the example, the possibility that K-th move remains on board, or p(K, r, c),  can be expressed in two ways:\\n- (DFS) Each in-board child contributes 1 / 8 * p(K-1, next_r, next_c) to the final probability. Hence, the in-board possiblity of tree node (r, c) in step k would be the sum of all on-board children in-board possibility weighted uniformly by 1/8.\\n- (BFS) For each generation of children, or in other words, for all tree nodes in level k, the in-board possibility would be he count of all in-board positions over all the count of all possible positions, including in-board and out-of-board, which would be 8 ^ k.\\n\\n> Note that there will be duplicate positions in each level like node (1) and (3) in the example, it is necessary to track the count of duplicates. For DFS a memo is used to track duplicate subproblems, while for BFS each node has a weight to indicate the count of duplicates.\\n\\n## BFS Solution\\nThe possibility that the knight remains on board on the K-th move can be calculated as:\\n`p = (count of all K-th moves ending up within board) / (8 ^ K)`\\n```python\\ndef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n\\t\"\"\"\\n\\tBFS, use a set to track the nodes in a tree remaining in the board in each step\\n\\tTime: O(8 * N ^ 2 * K)\\n\\tSpace: O(N ^ 2)\\n\\t\"\"\"\\n\\tq = {(r, c): 1}\\n\\tlevel = 0\\n\\tdirections = {(dx, dy) for dx in (-2, -1, 1, 2) for dy in (-2, -1, 1, 2) if abs(dx) + abs(dy) == 3}\\n\\tis_in_board = lambda r, c: 0 <= r < N and 0 <= c < N\\n\\twhile level < K and q:\\n\\t\\tnext_q = collections.defaultdict(int)\\n\\t\\tfor coord, count in q.items():\\n\\t\\t\\tx, y = coord\\n\\t\\t\\tfor dx, dy in directions:\\n\\t\\t\\t\\tif is_in_board(x + dx, y + dy):\\n\\t\\t\\t\\t\\tnext_q[(x + dx, y + dy)] += count\\n\\t\\tq = next_q\\n\\t\\tlevel += 1\\n\\t\\t# print(f\\'Level {level}: {q}\\')\\n\\n\\treturn sum(q.values()) / 8 ** K\\n```\\n## DFS Solution\\n```python \\ndef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n\\t\"\"\"\\n\\tdfs with memo\\n\\tTime: O(K*N^2)\\n\\tSpace: O(K*N^2)\\n\\t\"\"\"\\n\\tis_in_board = lambda r, c: 0 <= r < N and  0 <= c < N\\n\\tdirections = {(dx, dy) for dx in (-2, -1, 1, 2) for dy in (-2, -1, 1, 2) if abs(dx) + abs(dy) == 3}\\n\\tmemo = {}\\n\\tdef dfs(K, r, c):\\n\\t\\tnonlocal memo\\n\\t\\tif K == 0:\\n\\t\\t\\treturn 1\\n\\t\\tif (K, r, c) in memo:\\n\\t\\t\\treturn memo[(K, r, c)]\\n\\n\\t\\tp = 0\\n\\t\\tfor dx, dy in directions:\\n\\t\\t\\tx, y = r + dx, c + dy\\n\\t\\t\\tif is_in_board(x, y):\\n\\t\\t\\t\\tp += dfs(K - 1, x, y) / 8\\n\\t\\tmemo[(K, r, c)] = p\\n\\t\\treturn p\\n\\n\\treturn dfs(K, r, c)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n K = 2, N = 3, r = 0, c = 0\\nStart:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tK 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp(2, 0, 0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n1st Move:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0                               0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 0 0                               0 0 K\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t0 K 0                               0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\tp(1, 2, 1)                           p(1, 1, 2)\\n\\n2nd Move:\\n\\t\\t\\t\\t\\t\\t\\tK 0 0            0 0 K           K 0 0        0 0 0\\n\\t\\t\\t\\t\\t\\t\\t0 0 0            0 0 0           0 0 0        0 0 0\\n\\t\\t\\t\\t\\t\\t\\t0 0 0            0 0 0           0 0 0        K 0 0\\n\\t\\t\\t\\t\\t\\t\\t  (1)             (2)             (3)          (4)\\n\\t\\t\\t\\t   \\t\\tp(0, 0, 0)        p(0, 0, 2)      p(0, 0, 0)    p(0, 2, 0)\\n\\n```\n```python\\ndef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n\\t\"\"\"\\n\\tBFS, use a set to track the nodes in a tree remaining in the board in each step\\n\\tTime: O(8 * N ^ 2 * K)\\n\\tSpace: O(N ^ 2)\\n\\t\"\"\"\\n\\tq = {(r, c): 1}\\n\\tlevel = 0\\n\\tdirections = {(dx, dy) for dx in (-2, -1, 1, 2) for dy in (-2, -1, 1, 2) if abs(dx) + abs(dy) == 3}\\n\\tis_in_board = lambda r, c: 0 <= r < N and 0 <= c < N\\n\\twhile level < K and q:\\n\\t\\tnext_q = collections.defaultdict(int)\\n\\t\\tfor coord, count in q.items():\\n\\t\\t\\tx, y = coord\\n\\t\\t\\tfor dx, dy in directions:\\n\\t\\t\\t\\tif is_in_board(x + dx, y + dy):\\n\\t\\t\\t\\t\\tnext_q[(x + dx, y + dy)] += count\\n\\t\\tq = next_q\\n\\t\\tlevel += 1\\n\\t\\t# print(f\\'Level {level}: {q}\\')\\n\\n\\treturn sum(q.values()) / 8 ** K\\n```\n```python \\ndef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n\\t\"\"\"\\n\\tdfs with memo\\n\\tTime: O(K*N^2)\\n\\tSpace: O(K*N^2)\\n\\t\"\"\"\\n\\tis_in_board = lambda r, c: 0 <= r < N and  0 <= c < N\\n\\tdirections = {(dx, dy) for dx in (-2, -1, 1, 2) for dy in (-2, -1, 1, 2) if abs(dx) + abs(dy) == 3}\\n\\tmemo = {}\\n\\tdef dfs(K, r, c):\\n\\t\\tnonlocal memo\\n\\t\\tif K == 0:\\n\\t\\t\\treturn 1\\n\\t\\tif (K, r, c) in memo:\\n\\t\\t\\treturn memo[(K, r, c)]\\n\\n\\t\\tp = 0\\n\\t\\tfor dx, dy in directions:\\n\\t\\t\\tx, y = r + dx, c + dy\\n\\t\\t\\tif is_in_board(x, y):\\n\\t\\t\\t\\tp += dfs(K - 1, x, y) / 8\\n\\t\\tmemo[(K, r, c)] = p\\n\\t\\treturn p\\n\\n\\treturn dfs(K, r, c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 214232,
                "title": "easy-python-bfs-like-dp-168ms-super-fast-without-tricks-with-detailed-explanation",
                "content": "```\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        # O(K*n^2) worst case, keep adding the probability of getting out of the board.\\n        moves = [(1,2),(-1,2),(1,-2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]\\n        memo, out_board_p = {(r, c): 1}, 0\\n        # for each step we will create a new dict to record the onboard coordinates and their probabilities.\\n        for step in range(K):\\n            next_memo = collections.defaultdict(int)\\n            for (i, j), prob in memo.items():\\n                for d in moves:\\n                    di, dj = i+d[0], j+d[1]\\n                    # if the next step is on the board, we record it for next step\\'s calculation\\n                    if 0<=di<N and 0<=dj<N:\\n                        next_memo[(di,dj)] += prob * 0.125\\n                    # if the next step is not on the board, we sum it to our accumulate probability of out-board.\\n                    else:\\n                        out_board_p += prob * 0.125\\n            memo = next_memo\\n        # the on-board prob = 1 - the accumulate out board prob\\n        return 1-out_board_p\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        # O(K*n^2) worst case, keep adding the probability of getting out of the board.\\n        moves = [(1,2),(-1,2),(1,-2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]\\n        memo, out_board_p = {(r, c): 1}, 0\\n        # for each step we will create a new dict to record the onboard coordinates and their probabilities.\\n        for step in range(K):\\n            next_memo = collections.defaultdict(int)\\n            for (i, j), prob in memo.items():\\n                for d in moves:\\n                    di, dj = i+d[0], j+d[1]\\n                    # if the next step is on the board, we record it for next step\\'s calculation\\n                    if 0<=di<N and 0<=dj<N:\\n                        next_memo[(di,dj)] += prob * 0.125\\n                    # if the next step is not on the board, we sum it to our accumulate probability of out-board.\\n                    else:\\n                        out_board_p += prob * 0.125\\n            memo = next_memo\\n        # the on-board prob = 1 - the accumulate out board prob\\n        return 1-out_board_p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296155,
                "title": "c-solution-with-proper-explaination",
                "content": "**Imp to note :**\\n1. check the given constraints.\\n2. figure out the base  cases.\\n3. when there is no movement i.e. when k is 0 there can be a probabilty of having knight at the chess borad is 1\\n4. At every step the knight has 8 choices to move some can be in the board and some can be out of it\\n5. the ones which are at the out of the board we can simply ignore that or make it a zero.\\n6.   These are choices of Knight :\\n  ( row-2, column -1)\\n                                                 ( row-1, column -2) \\n                                                 ( row+2, column +1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t ( row+1, column +2)\\n                                    ( row-2, column +1)\\n\\t\\t                         \\t( row+2, column -1) \\n                                   ( row-1, column +2)\\n\\t\\t                           ( row+1, column -2)\\n\\n7. Dry run the code.\\n**Please upvote and do comment  if there is any doubt**\\n\\n```\\nclass Solution {\\npublic:\\ndouble dp[26][26][101];\\n    double knight(int n , int k, int row, int column){\\n         //base cases\\n          if(row <0 || column <0|| row>= n ||column >= n){\\n             return 0;\\n             }\\n          if(k ==0) return 1; // if k ie. no. of steps is 0 than the probabilty to have Knight on borad is 1\\n          if(dp[row][column][k]){\\n              return dp[row][column][k];\\n         }\\n          double sum =0; // to find the sum\\n        \\n         sum = knight(n, k-1, row-2, column -1) + knight(n, k-1, row-1, column -2) + \\n            knight(n, k-1, row+2, column +1) + knight(n, k-1, row+1, column +2)+ \\n            knight(n, k-1, row-2, column +1)+ knight(n, k-1, row+2, column -1) +\\n            knight(n, k-1, row-1, column +2) + knight(n, k-1, row+1, column -2);\\n          sum /= 8;\\n          return dp[row][column][k] = sum;\\n                                                            \\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        return knight(n, k, row, column);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ndouble dp[26][26][101];\\n    double knight(int n , int k, int row, int column){\\n         //base cases\\n          if(row <0 || column <0|| row>= n ||column >= n){\\n             return 0;\\n             }\\n          if(k ==0) return 1; // if k ie. no. of steps is 0 than the probabilty to have Knight on borad is 1\\n          if(dp[row][column][k]){\\n              return dp[row][column][k];\\n         }\\n          double sum =0; // to find the sum\\n        \\n         sum = knight(n, k-1, row-2, column -1) + knight(n, k-1, row-1, column -2) + \\n            knight(n, k-1, row+2, column +1) + knight(n, k-1, row+1, column +2)+ \\n            knight(n, k-1, row-2, column +1)+ knight(n, k-1, row+2, column -1) +\\n            knight(n, k-1, row-1, column +2) + knight(n, k-1, row+1, column -2);\\n          sum /= 8;\\n          return dp[row][column][k] = sum;\\n                                                            \\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        return knight(n, k, row, column);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356434,
                "title": "super-simple-recursive-python-solution-beats-98",
                "content": "We set 2 super simple base cases: if we\\'re already outside the grid, the probability of staying inside is 0. If we\\'re inside the grid and have no moves left to make, the probability of staying inside is 1. Otherwise, we make 8 recursive calls and average them. We use Python\\'s built-in lru_cache for memoization.\\n\\nFinal code: \\n\\n```\\ndef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n\\t@functools.lru_cache(None)\\n\\tdef travels(xcurr, ycurr, k):\\n\\t\\tif xcurr < 0 or xcurr >= N or ycurr < 0 or ycurr >= N: \\n\\t\\t\\t# We\\'re already outside the grid, so probability of staying inside is 0\\n\\t\\t\\treturn 0\\n\\t\\telif k == 0:\\n\\t\\t\\t# We\\'re inside the grid and have no more moves to make\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\t# Otherwise, we make one of 8 possible moves and find the probability of staying inside after \\n\\t\\t\\t# k - 1 more moves. Because each move is equally likely, we average all of these probabilities.\\n\\t\\t\\treturn (travels(xcurr + 2, ycurr + 1, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr + 1, ycurr + 2, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 1, ycurr + 2, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 2, ycurr + 1, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 2, ycurr - 1, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 1, ycurr - 2, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr + 1, ycurr - 2, k - 1) +   \\n\\t\\t\\t\\t\\ttravels(xcurr + 2, ycurr - 1, k - 1)) / 8\\n\\n\\treturn travels(r, c, K)\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n\\t@functools.lru_cache(None)\\n\\tdef travels(xcurr, ycurr, k):\\n\\t\\tif xcurr < 0 or xcurr >= N or ycurr < 0 or ycurr >= N: \\n\\t\\t\\t# We\\'re already outside the grid, so probability of staying inside is 0\\n\\t\\t\\treturn 0\\n\\t\\telif k == 0:\\n\\t\\t\\t# We\\'re inside the grid and have no more moves to make\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\t# Otherwise, we make one of 8 possible moves and find the probability of staying inside after \\n\\t\\t\\t# k - 1 more moves. Because each move is equally likely, we average all of these probabilities.\\n\\t\\t\\treturn (travels(xcurr + 2, ycurr + 1, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr + 1, ycurr + 2, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 1, ycurr + 2, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 2, ycurr + 1, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 2, ycurr - 1, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr - 1, ycurr - 2, k - 1) + \\n\\t\\t\\t\\t\\ttravels(xcurr + 1, ycurr - 2, k - 1) +   \\n\\t\\t\\t\\t\\ttravels(xcurr + 2, ycurr - 1, k - 1)) / 8\\n\\n\\treturn travels(r, c, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1520717,
                "title": "knight-probability-in-chessboard-cpp-c-detailed-explanation-with-code",
                "content": "**Explanation**\\nThe idea is, we have a knight and it has to move in 8 directions and it has k moves in  total. Also, in question it is given that, it will continue moving until k becomes 0 or knight moves off the chessboard. And, we need to find the probabilitiy that knight remains on the board after it has stopped moving.\\n\\nNow, If you look at the problem, it generally talks about the path and exploration and stuff like that. Whenever, we talk related to exploring all the path then we should think about resursion.\\n\\nNow, we have decided that we are going to use recursion and we will be exploring all the paths. So, possible path for the knight is going to be given below, when the knight is at (x, y) from there it will move,\\n```\\n(x + 2, y + 1)\\n(x + 1, y + 2)\\n(x \\u2013 1, y + 2)\\n(x \\u2013 2, y + 1)\\n(x \\u2013 2, y \\u2013 1)\\n(x \\u2013 1, y \\u2013 2)\\n(x + 1, y \\u2013 2)\\n(x + 2, y \\u2013 1)\\n```\\nin these many directions.\\nNow, let\\'s talk about the probability, Since knight has to move in 8 directions, for one  move of knight the probability will be 1/8.\\n\\n**Also, let\\'s talk about the base case:**\\n1. Check if the position is valid or not if not return 0.\\n2. Check if k == 0 or not, if k is 0 then there is no movement from knight and Probability of knight on the borad is 1.\\n\\n**Code**\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        return helper(N, K, r, c);\\n    }\\n    \\n    double helper(int N, int K, int row, int col){\\n        \\n        if(row < 0 || col < 0 || row >= N || col >= N) return 0.0;\\n        \\n        if(K == 0) return 1.0;\\n        \\n        double ans = helper(N, K-1, row+2, col+1) + helper(N, K-1, row+1, col+2) + \\n                    helper(N, K-1, row-1, col+2) + helper(N, K-1, row-2, col+1) + \\n                    helper(N, K-1, row-2, col-1) + helper(N, K-1, row-1, col-2) +\\n                  helper(N, K-1, row+1, col-2) + helper(N, K-1, row+2, col-1);\\n        \\n        double result  = ans / 8.0;\\n        return result;\\n    }\\n};\\n```\\n\\n**Recursive + Memoization**\\n***using matrix***\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> memo(N+1, vector<vector<double>>(N+1, vector<double>(K+1, -1)));\\n        return helper(N, K, r, c, memo);\\n    }\\n    \\n    double helper(int N, int K, int row, int col, vector<vector<vector<double>>>& memo){\\n\\n        if(row < 0 || col < 0 || row >= N || col >= N) return 0.0;\\n        \\n        if(K == 0) return 1.0;\\n        \\n        if(memo[row][col][K] != -1) return memo[row][col][K];\\n        \\n        double ans = \\n            helper(N, K-1, row+2, col+1, memo) + helper(N, K-1, row+1, col+2, memo) +       \\n            helper(N, K-1, row-1, col+2, memo) + helper(N, K-1, row-2, col+1, memo) + \\n            helper(N, K-1, row-2, col-1, memo) + helper(N, K-1, row-1, col-2, memo) +\\n            helper(N, K-1, row+1, col-2, memo) + helper(N, K-1, row+2, col-1, memo);\\n        \\n        double result  = ans / 8.0;\\n        memo[row][col][K] = result;\\n        return result;\\n    }\\n};\\n```\\n\\n***using map***\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, double> mp;\\n    double knightProbability(int N, int K, int r, int c) {\\n        mp.clear();\\n        return helper(N, K, r, c);\\n    }\\n    \\n    double helper(int N, int K, int row, int col){\\n\\n        if(row < 0 || col < 0 || row >= N || col >= N) return 0.0;\\n        \\n        if(K == 0) return 1.0;\\n        \\n        string key = to_string(K) + \"#\" + to_string(row) + \"#\" + to_string(col);\\n        if(mp.find(key) != mp.end()) return mp[key];\\n        \\n        double ans = helper(N, K-1, row+2, col+1) + helper(N, K-1, row+1, col+2) + \\n                    helper(N, K-1, row-1, col+2) + helper(N, K-1, row-2, col+1) + \\n                    helper(N, K-1, row-2, col-1) + helper(N, K-1, row-1, col-2) +\\n                  helper(N, K-1, row+1, col-2) + helper(N, K-1, row+2, col-1);\\n        \\n        double result  = ans / 8.0;\\n        mp[key] = result;\\n        return result;\\n    }\\n};\\n```\\nThanks.\\n**Happy Learning.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n(x + 2, y + 1)\\n(x + 1, y + 2)\\n(x \\u2013 1, y + 2)\\n(x \\u2013 2, y + 1)\\n(x \\u2013 2, y \\u2013 1)\\n(x \\u2013 1, y \\u2013 2)\\n(x + 1, y \\u2013 2)\\n(x + 2, y \\u2013 1)\\n```\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        return helper(N, K, r, c);\\n    }\\n    \\n    double helper(int N, int K, int row, int col){\\n        \\n        if(row < 0 || col < 0 || row >= N || col >= N) return 0.0;\\n        \\n        if(K == 0) return 1.0;\\n        \\n        double ans = helper(N, K-1, row+2, col+1) + helper(N, K-1, row+1, col+2) + \\n                    helper(N, K-1, row-1, col+2) + helper(N, K-1, row-2, col+1) + \\n                    helper(N, K-1, row-2, col-1) + helper(N, K-1, row-1, col-2) +\\n                  helper(N, K-1, row+1, col-2) + helper(N, K-1, row+2, col-1);\\n        \\n        double result  = ans / 8.0;\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> memo(N+1, vector<vector<double>>(N+1, vector<double>(K+1, -1)));\\n        return helper(N, K, r, c, memo);\\n    }\\n    \\n    double helper(int N, int K, int row, int col, vector<vector<vector<double>>>& memo){\\n\\n        if(row < 0 || col < 0 || row >= N || col >= N) return 0.0;\\n        \\n        if(K == 0) return 1.0;\\n        \\n        if(memo[row][col][K] != -1) return memo[row][col][K];\\n        \\n        double ans = \\n            helper(N, K-1, row+2, col+1, memo) + helper(N, K-1, row+1, col+2, memo) +       \\n            helper(N, K-1, row-1, col+2, memo) + helper(N, K-1, row-2, col+1, memo) + \\n            helper(N, K-1, row-2, col-1, memo) + helper(N, K-1, row-1, col-2, memo) +\\n            helper(N, K-1, row+1, col-2, memo) + helper(N, K-1, row+2, col-1, memo);\\n        \\n        double result  = ans / 8.0;\\n        memo[row][col][K] = result;\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, double> mp;\\n    double knightProbability(int N, int K, int r, int c) {\\n        mp.clear();\\n        return helper(N, K, r, c);\\n    }\\n    \\n    double helper(int N, int K, int row, int col){\\n\\n        if(row < 0 || col < 0 || row >= N || col >= N) return 0.0;\\n        \\n        if(K == 0) return 1.0;\\n        \\n        string key = to_string(K) + \"#\" + to_string(row) + \"#\" + to_string(col);\\n        if(mp.find(key) != mp.end()) return mp[key];\\n        \\n        double ans = helper(N, K-1, row+2, col+1) + helper(N, K-1, row+1, col+2) + \\n                    helper(N, K-1, row-1, col+2) + helper(N, K-1, row-2, col+1) + \\n                    helper(N, K-1, row-2, col-1) + helper(N, K-1, row-1, col-2) +\\n                  helper(N, K-1, row+1, col-2) + helper(N, K-1, row+2, col-1);\\n        \\n        double result  = ans / 8.0;\\n        mp[key] = result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798766,
                "title": "c-faster-than-90-dfs-3d-dp-concise-code",
                "content": "# PLEASE DO UPVOTE!!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\ndouble dp[30][30][105];\\nint X[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\nint Y[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\ndouble dfs(int i,int j,int k, int n)\\n{\\n    if(i < 0 || j < 0 ||i >= n || j >= n) return 0;\\n    if(k == 0) return 1;\\n    if(dp[i][j][k] != 0) return dp[i][j][k];\\n\\n    double res = 0;\\n\\n    for(int l = 0;l < 8; ++l)\\n    {\\n      int x = i + X[l];\\n      int y = j + Y[l];\\n      res += dfs(x,y,k-1,n);\\n    }\\n    return dp[i][j][k] += (res/8.0);\\n}\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n\\n        memset(dp,0,sizeof(dp));\\n        return dfs(row,column,k,n); \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\ndouble dp[30][30][105];\\nint X[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\nint Y[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\ndouble dfs(int i,int j,int k, int n)\\n{\\n    if(i < 0 || j < 0 ||i >= n || j >= n) return 0;\\n    if(k == 0) return 1;\\n    if(dp[i][j][k] != 0) return dp[i][j][k];\\n\\n    double res = 0;\\n\\n    for(int l = 0;l < 8; ++l)\\n    {\\n      int x = i + X[l];\\n      int y = j + Y[l];\\n      res += dfs(x,y,k-1,n);\\n    }\\n    return dp[i][j][k] += (res/8.0);\\n}\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n\\n        memset(dp,0,sizeof(dp));\\n        return dfs(row,column,k,n); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140286,
                "title": "c-dp-solution-with-explanations-beats-100",
                "content": "We start by creating a matrix with probabilities of knight\\'s survival till the appropriate turn for each cell. On the turn 0 it will contain only 1\\'s as it\\'s not possible for the knight to die without moving.\\n```\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n```\\nWhen a knight makes a turn he can either run out of the board (hence the probability of his survival will be 0) or step on a cell for which we already counted the probability of his survival for the previous turn. We add upp the probabilities of his survival for each direction and divide them by 8 (total amount of directions), receiving the probability of surviving for the specified cell on the current turn.\\n\\nMatrix for turn 1:\\n```\\n0.25 0.375 0.375 0.25 \\n0.375 0.5 0.5 0.375 \\n0.375 0.5 0.5 0.375 \\n0.25 0.375 0.375 0.25 \\n```\\n\\nAs you can see, there is 0.25 chance to survive starting in the corner after making one turn as there are 2 cells ((1, 2) and (2, 1)) with probability of survival equal to 1 and 6 cells out of the borders.\\n\\nIf we want to count a probability for, say, cell (0, 1) for the turn 2 we find all possible places where a knight can step: (2, 0), (2, 2), (1, 3), sum up all probabilities of surviving and divide by 8.\\n(0.375 + 0.5 + 0.375) / 8 = 0.15625\\n\\nLet\\'s see the matrix for the next turn:\\n```\\n0.125 0.15625 0.15625 0.125 \\n0.15625 0.15625 0.15625 0.15625 \\n0.15625 0.15625 0.15625 0.15625 \\n0.125 0.15625 0.15625 0.125 \\n```\\nAs you can see, the approprivate value is 0.15625 as we counted previously. Each time we create a new map for probabilities of current turn and in the end of turn we set the map for previous turn to the one we created recently.\\n\\nAs an optimization for this, we don\\'t need to count every cell each time. It\\'s obvious that probabilities for symmetric cells are the same, i.e. for each corner of the board. So we can count only 1/4 of the cells and then mirror them to the rest of the board. Here are the cells that we are processing each time:\\n```\\n1 1 1 0\\n0 1 0 0\\n0 0 0 0\\n0 0 0 0\\n```\\n\\nFor the 5-size matrix:\\n```\\n1 1 1 1 0\\n0 1 1 0 0\\n0 0 1 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n```\\nAll other cells values are being copied from these.\\n\\nAfter we process the board K times we just take the value from appropriate cell in the array and it will be the probability of the knight\\'s survival.\\n\\nCode:\\n\\n```\\npublic class Solution {\\n    public double KnightProbability(int N, int K, int r, int c) {\\n        var prob = new double[N, N];\\n        for(var i = 0; i < N; i++)\\n            for(var j = 0; j < N; j++)\\n                prob[i, j] = 1d;\\n        \\n        var newprob = new double[N, N];\\n        \\n        var directions = new int[,] {{1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}};\\n        \\n\\t// Change the matrix K times\\n        for(var iterator = 0; iterator < K; iterator++) {\\n            for(var y = 0; y < Math.Ceiling((double) N / 2); y++) {\\n                for(var x = y; x == y || x < N - y - 1; x++) {\\n                    double sum = 0;\\n\\t\\t    // Count probability for each direction\\n                    for(var j = 0; j < directions.GetLength(0); j++)\\n                        sum += Prob(prob, y + directions[j, 0], x + directions[j, 1]);\\n\\n                    sum /= 8;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t            // Mirror probability to 3 other sides of the matrix\\n                    newprob[y, x] = sum;\\n                    newprob[N - x - 1, y] = sum;\\n                    newprob[x, N - y - 1] = sum;\\n                    newprob[N - y - 1, N - x - 1] = sum;\\n                }\\n            }\\n\\n            prob = newprob;\\n            newprob = new double[N, N];\\n        }\\n        \\n        return prob[r, c];\\n    }\\n    \\n    private double Prob(double[,] prob, int y, int x) {\\n        if(y < 0 || x < 0 || y >= prob.GetLength(0) || x >= prob.GetLength(1))\\n            return 0;\\n        \\n        return prob[y, x];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n```\n```\\n0.25 0.375 0.375 0.25 \\n0.375 0.5 0.5 0.375 \\n0.375 0.5 0.5 0.375 \\n0.25 0.375 0.375 0.25 \\n```\n```\\n0.125 0.15625 0.15625 0.125 \\n0.15625 0.15625 0.15625 0.15625 \\n0.15625 0.15625 0.15625 0.15625 \\n0.125 0.15625 0.15625 0.125 \\n```\n```\\n1 1 1 0\\n0 1 0 0\\n0 0 0 0\\n0 0 0 0\\n```\n```\\n1 1 1 1 0\\n0 1 1 0 0\\n0 0 1 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n```\n```\\npublic class Solution {\\n    public double KnightProbability(int N, int K, int r, int c) {\\n        var prob = new double[N, N];\\n        for(var i = 0; i < N; i++)\\n            for(var j = 0; j < N; j++)\\n                prob[i, j] = 1d;\\n        \\n        var newprob = new double[N, N];\\n        \\n        var directions = new int[,] {{1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}};\\n        \\n\\t// Change the matrix K times\\n        for(var iterator = 0; iterator < K; iterator++) {\\n            for(var y = 0; y < Math.Ceiling((double) N / 2); y++) {\\n                for(var x = y; x == y || x < N - y - 1; x++) {\\n                    double sum = 0;\\n\\t\\t    // Count probability for each direction\\n                    for(var j = 0; j < directions.GetLength(0); j++)\\n                        sum += Prob(prob, y + directions[j, 0], x + directions[j, 1]);\\n\\n                    sum /= 8;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t            // Mirror probability to 3 other sides of the matrix\\n                    newprob[y, x] = sum;\\n                    newprob[N - x - 1, y] = sum;\\n                    newprob[x, N - y - 1] = sum;\\n                    newprob[N - y - 1, N - x - 1] = sum;\\n                }\\n            }\\n\\n            prob = newprob;\\n            newprob = new double[N, N];\\n        }\\n        \\n        return prob[r, c];\\n    }\\n    \\n    private double Prob(double[,] prob, int y, int x) {\\n        if(y < 0 || x < 0 || y >= prob.GetLength(0) || x >= prob.GetLength(1))\\n            return 0;\\n        \\n        return prob[y, x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108187,
                "title": "c-java-dp-concise-solution",
                "content": "For this problem, I think memoization is more optimal than direct DP. The reason is that memoization can avoid a lot of unnecessary subproblems. \\nThe runtime is O(KN^2).\\n\\nC++ \\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> dp(K+1, vector<vector<double>>(N, vector<double>(N, -1.0)));\\n        return helper(dp, N, K, r, c)/pow(8, K);\\n    }\\nprivate:\\n    double helper(vector<vector<vector<double>>>& dp, int N, int k, int r, int c) {\\n        // if out of board, return 0.0\\n        if (r < 0 || r >= N || c < 0 || c >= N) return 0.0;\\n        // when k = 0, no more move, so it's 100% safe\\n        if (k == 0) return 1.0;\\n        if (dp[k][r][c] != -1.0) return dp[k][r][c];\\n        dp[k][r][c] = 0.0;\\n        for (int i = -2; i <= 2; i++) {\\n            if (i == 0) continue;\\n            dp[k][r][c] += helper(dp, N, k-1, r+i, c+3-abs(i)) + helper(dp, N, k-1, r+i, c-(3-abs(i)));\\n        }      \\n        return dp[k][r][c];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    int[][] moves = {{1,2},{1,-2},{-1,2},{-1,-2},{2,-1},{2,1},{-2,-1},{-2,1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][][] dp = new double[K+1][N][N];\\n        return helper(dp, N, K, r, c)/Math.pow(8.0, K);\\n    }\\n    private double helper(double[][][] dp, int N, int k, int r, int c) {\\n        if (r < 0 || r >= N || c < 0 || c >= N) return 0.0;\\n        if (k == 0) return 1.0;\\n        if (dp[k][r][c] != 0.0) return dp[k][r][c];\\n        for (int i = 0; i < 8; i++)  \\n            dp[k][r][c] += helper(dp, N, k-1, r+moves[i][0], c+moves[i][1]);\\n        return dp[k][r][c]; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> dp(K+1, vector<vector<double>>(N, vector<double>(N, -1.0)));\\n        return helper(dp, N, K, r, c)/pow(8, K);\\n    }\\nprivate:\\n    double helper(vector<vector<vector<double>>>& dp, int N, int k, int r, int c) {\\n        // if out of board, return 0.0\\n        if (r < 0 || r >= N || c < 0 || c >= N) return 0.0;\\n        // when k = 0, no more move, so it's 100% safe\\n        if (k == 0) return 1.0;\\n        if (dp[k][r][c] != -1.0) return dp[k][r][c];\\n        dp[k][r][c] = 0.0;\\n        for (int i = -2; i <= 2; i++) {\\n            if (i == 0) continue;\\n            dp[k][r][c] += helper(dp, N, k-1, r+i, c+3-abs(i)) + helper(dp, N, k-1, r+i, c-(3-abs(i)));\\n        }      \\n        return dp[k][r][c];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int[][] moves = {{1,2},{1,-2},{-1,2},{-1,-2},{2,-1},{2,1},{-2,-1},{-2,1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][][] dp = new double[K+1][N][N];\\n        return helper(dp, N, K, r, c)/Math.pow(8.0, K);\\n    }\\n    private double helper(double[][][] dp, int N, int k, int r, int c) {\\n        if (r < 0 || r >= N || c < 0 || c >= N) return 0.0;\\n        if (k == 0) return 1.0;\\n        if (dp[k][r][c] != 0.0) return dp[k][r][c];\\n        for (int i = 0; i < 8; i++)  \\n            dp[k][r][c] += helper(dp, N, k-1, r+moves[i][0], c+moves[i][1]);\\n        return dp[k][r][c]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633112,
                "title": "c-dp-solution-memos",
                "content": "**Status**: Accepted (8ms Code & 7.8 MB usage) \\n\\nSimilar problem: [Out of Boundary Path](https://leetcode.com/problems/out-of-boundary-paths)\\n\\nMy solution to the above problem with explaination. You can find it [ here.](https://leetcode.com/problems/out-of-boundary-paths/discuss/632968/hurrah-my-first-dp-accepted-solution-c)\\n\\nUpvote if it helps! Thanks.\\n```\\nclass Solution {\\npublic:\\n    double helperFunction(int N, int K, int r, int c, vector<vector<vector<double>>> & dp){\\n        if(r < 0 || c < 0 || r >= N || c >= N) return 0;\\n        if(K == 0) return 1;\\n        if(dp[r][c][K] != -1) return dp[r][c][K];\\n        double sum = helperFunction(N, K - 1, r - 2, c - 1, dp) +\\n                     helperFunction(N, K - 1, r - 1, c - 2, dp) +\\n                     helperFunction(N, K - 1, r + 1, c - 2, dp) +\\n                     helperFunction(N, K - 1, r + 2, c - 1, dp) +\\n                     helperFunction(N, K - 1, r - 2, c + 1, dp) +\\n                     helperFunction(N, K - 1, r - 1, c + 2, dp) +\\n                     helperFunction(N, K - 1, r + 1, c + 2, dp) +\\n                     helperFunction(N, K - 1, r + 2, c + 1, dp);\\n        sum = sum / 8;\\n        dp[r][c][K] = sum;\\n        return dp[r][c][K];\\n    \\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> dp(N + 1, vector<vector<double>> (N + 1, vector<double>(K + 1, -1)));\\n        return helperFunction(N, K, r, c, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double helperFunction(int N, int K, int r, int c, vector<vector<vector<double>>> & dp){\\n        if(r < 0 || c < 0 || r >= N || c >= N) return 0;\\n        if(K == 0) return 1;\\n        if(dp[r][c][K] != -1) return dp[r][c][K];\\n        double sum = helperFunction(N, K - 1, r - 2, c - 1, dp) +\\n                     helperFunction(N, K - 1, r - 1, c - 2, dp) +\\n                     helperFunction(N, K - 1, r + 1, c - 2, dp) +\\n                     helperFunction(N, K - 1, r + 2, c - 1, dp) +\\n                     helperFunction(N, K - 1, r - 2, c + 1, dp) +\\n                     helperFunction(N, K - 1, r - 1, c + 2, dp) +\\n                     helperFunction(N, K - 1, r + 1, c + 2, dp) +\\n                     helperFunction(N, K - 1, r + 2, c + 1, dp);\\n        sum = sum / 8;\\n        dp[r][c][K] = sum;\\n        return dp[r][c][K];\\n    \\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> dp(N + 1, vector<vector<double>> (N + 1, vector<double>(K + 1, -1)));\\n        return helperFunction(N, K, r, c, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799005,
                "title": "pythonic-solution-video-explanation-dynamic-programming-top-down-dp",
                "content": "# Intuition\\nTo solve this problem efficiently, we can use dynamic programming and memoization to avoid redundant calculations. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Video Description coming soon. Please upvote the post while we work on the video\\uD83D\\uDE4F\\uD83D\\uDE4F**\\n\\n# Time Complexity\\n\\n- The time complexity of the solution depends on the number of recursive calls and the number of unique subproblems encountered during the recursion. \\n\\n- is_valid() function: The is_valid() function is called once for each unique position (x, y) on the chessboard. Since the chessboard has dimensions n x n, the function will be called approximately n^2 times. The time complexity of this function is constant, O(1), as it only involves simple arithmetic operations and comparisons.\\nsolve() function: The solve() function is a recursive function that explores all possible moves from a given position (x, y) and the given number of remaining moves k. For each position, it explores 8 possible moves. As a result, the number of recursive calls grows exponentially with respect to the number of remaining moves k. At each level of recursion, there are 8 recursive calls. Therefore, the number of recursive calls can be roughly approximated as 8^k.\\n\\n- Memoization with @cache: The @cache decorator caches the results of previously encountered subproblems, allowing the function to avoid redundant calculations. This effectively reduces the number of recursive calls to unique subproblems. The caching mechanism ensures that each unique subproblem is solved only once, and the result is directly retrieved from the cache during subsequent encounters. As a result, the total number of unique subproblems encountered will be significantly smaller than 8^k.\\nConsidering these factors, the overall time complexity of the solution can be expressed as follows:\\n\\n# O(n^2 * 8^k)\\n\\n# Space complexity:\\n- The space complexity of the solution is determined by the memory used during the recursive calls and the memoization cache. Let\\'s analyze it step by step:\\n\\n- Stack space: During the recursive calls to the solve() function, the Python call stack keeps track of intermediate function calls and their parameters. Since each recursive call requires a constant amount of memory, the maximum depth of the recursion will be equal to the number of remaining moves k. Therefore, the space complexity due to the call stack is O(k).\\n\\n- Memoization cache: The @cache decorator caches the results of previously encountered subproblems. As a result, it consumes memory to store the cached results. The number of unique subproblems that can be encountered during the recursion is significantly smaller than 8^k, as many subproblems are reused from the cache. Therefore, the space complexity due to the memoization cache can be approximated as O(n^2 * k).\\nCombining these factors, the overall space complexity of the solution can be expressed as:\\n\\n# O(n^2 * k)\\n\\n- Note: As previously mentioned, the space complexity can be reduced to O(n^2) by using an iterative approach without recursion and memoization. However, the recursive solution with memoization is more intuitive and easier to implement for this problem.\\n\\n\\n# Code\\n```\\n\\nfrom functools import cache\\n\\nclass Solution:\\n    def __init__(self):\\n        # Initialize variables to store chessboard size and number of moves\\n        self.n = 0\\n        self.k = 0\\n        # Define the eight possible knight moves as relative coordinates\\n        self.states = [(1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2)]\\n\\n    # Helper function to check if given coordinates (x, y) are within chessboard boundaries\\n    @cache\\n    def is_valid(self, x, y):\\n        if 0 <= x < self.n and 0 <= y < self.n:\\n            return True\\n        return False\\n\\n    # Function to calculate the probability of knight staying on the board after k moves\\n    @cache\\n    def solve(self, x, y, k):\\n        # Base case: If k is 0, knight is guaranteed to stay on the board\\n        if k == 0:\\n            return 1\\n        rate = 0\\n        # Loop through all eight possible knight moves\\n        for dx, dy in self.states:\\n            n_x, n_y = x + dx, y + dy\\n            # Check if the new coordinates are valid (within chessboard boundaries)\\n            if not self.is_valid(n_x, n_y):\\n                continue\\n            # Calculate the probability for the current move and add it to the rate\\n            rate += 0.125 * self.solve(n_x, n_y, k - 1)\\n        return rate\\n\\n    # Main function to solve the knight probability problem\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        # Update the chessboard size and number of moves\\n        self.n = n\\n        self.k = k\\n        # Edge case: If k is 0, simply check if the initial position is valid on the board\\n        if k == 0:\\n            return float(self.is_valid(row, column))\\n        # Otherwise, call the solve function with the starting position and k\\n        return self.solve(row, column, k)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\nfrom functools import cache\\n\\nclass Solution:\\n    def __init__(self):\\n        # Initialize variables to store chessboard size and number of moves\\n        self.n = 0\\n        self.k = 0\\n        # Define the eight possible knight moves as relative coordinates\\n        self.states = [(1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2)]\\n\\n    # Helper function to check if given coordinates (x, y) are within chessboard boundaries\\n    @cache\\n    def is_valid(self, x, y):\\n        if 0 <= x < self.n and 0 <= y < self.n:\\n            return True\\n        return False\\n\\n    # Function to calculate the probability of knight staying on the board after k moves\\n    @cache\\n    def solve(self, x, y, k):\\n        # Base case: If k is 0, knight is guaranteed to stay on the board\\n        if k == 0:\\n            return 1\\n        rate = 0\\n        # Loop through all eight possible knight moves\\n        for dx, dy in self.states:\\n            n_x, n_y = x + dx, y + dy\\n            # Check if the new coordinates are valid (within chessboard boundaries)\\n            if not self.is_valid(n_x, n_y):\\n                continue\\n            # Calculate the probability for the current move and add it to the rate\\n            rate += 0.125 * self.solve(n_x, n_y, k - 1)\\n        return rate\\n\\n    # Main function to solve the knight probability problem\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        # Update the chessboard size and number of moves\\n        self.n = n\\n        self.k = k\\n        # Edge case: If k is 0, simply check if the initial position is valid on the board\\n        if k == 0:\\n            return float(self.is_valid(row, column))\\n        # Otherwise, call the solve function with the starting position and k\\n        return self.solve(row, column, k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108193,
                "title": "python",
                "content": "At the start, the knight is at (r, c) with probability 1 (and anywhere else with probability 0). Then update those probabilities over K moves.\\n\\n    def knightProbability(self, N, K, r, c):\\n        p = {(r, c): 1}\\n        for _ in range(K):\\n            p = {(r, c): sum(p.get((r+i, c+j), 0) + p.get((r+j, c+i), 0) for i in (1, -1) for j in (2, -2)) / 8\\n                 for r in range(N) for c in range(N)}\\n        return sum(p.values())\\n\\nShorter and maybe nicer version, influenced a bit by @flamesofmoon's [solution](https://discuss.leetcode.com/topic/105934/python-with-explanations):\\n\\n    def knightProbability(self, N, K, r, c):\\n        p = {(r, c): 1}\\n        for _ in range(K):\\n            p = {(r, c): sum(p.get((r+i, c+j), 0) for x in (1, 2) for i in (x, -x) for j in (3-x, x-3)) / 8\\n                 for r in range(N) for c in range(N)}\\n        return sum(p.values())",
                "solutionTags": [],
                "code": "At the start, the knight is at (r, c) with probability 1 (and anywhere else with probability 0). Then update those probabilities over K moves.\\n\\n    def knightProbability(self, N, K, r, c):\\n        p = {(r, c): 1}\\n        for _ in range(K):\\n            p = {(r, c): sum(p.get((r+i, c+j), 0) + p.get((r+j, c+i), 0) for i in (1, -1) for j in (2, -2)) / 8\\n                 for r in range(N) for c in range(N)}\\n        return sum(p.values())\\n\\nShorter and maybe nicer version, influenced a bit by @flamesofmoon's [solution](https://discuss.leetcode.com/topic/105934/python-with-explanations):\\n\\n    def knightProbability(self, N, K, r, c):\\n        p = {(r, c): 1}\\n        for _ in range(K):\\n            p = {(r, c): sum(p.get((r+i, c+j), 0) for x in (1, 2) for i in (x, -x) for j in (3-x, x-3)) / 8\\n                 for r in range(N) for c in range(N)}\\n        return sum(p.values())",
                "codeTag": "Python3"
            },
            {
                "id": 3799019,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2 * k)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        if(k==0)\\n        {\\n            return (double)1;\\n        }\\n        double dp[][] = new double[n][n];\\n        dp[row][column]=1;\\n        int val[][] = {{-2,1},{-1,2},{1,2},{2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};\\n        for(int ind=1;ind<=k;ind++)\\n        {\\n            double dp1[][] = new double[n][n];\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(dp[i][j]!=0)\\n                    {\\n                        for(int iterate[] : val)\\n                        {\\n                            int ind_x=i+iterate[0];\\n                            int ind_y=j+iterate[1];\\n                            if(ind_x>=0 && ind_y>=0 && ind_x<n && ind_y<n)\\n                            {\\n                                dp1[ind_x][ind_y]+=dp[i][j]/8.0;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    dp[i][j]=dp1[i][j];\\n                }\\n            }\\n        }\\n        double ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans+=dp[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        if(k==0)\\n        {\\n            return (double)1;\\n        }\\n        double dp[][] = new double[n][n];\\n        dp[row][column]=1;\\n        int val[][] = {{-2,1},{-1,2},{1,2},{2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};\\n        for(int ind=1;ind<=k;ind++)\\n        {\\n            double dp1[][] = new double[n][n];\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(dp[i][j]!=0)\\n                    {\\n                        for(int iterate[] : val)\\n                        {\\n                            int ind_x=i+iterate[0];\\n                            int ind_y=j+iterate[1];\\n                            if(ind_x>=0 && ind_y>=0 && ind_x<n && ind_y<n)\\n                            {\\n                                dp1[ind_x][ind_y]+=dp[i][j]/8.0;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    dp[i][j]=dp1[i][j];\\n                }\\n            }\\n        }\\n        double ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans+=dp[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824236,
                "title": "java-memoization-easy-to-understand",
                "content": "There are total of Math.pow(8,k) moves in available for the knight . We calculate the total moves for which the knight will stay inside the board and then calculate the probability.\\n```\\nclass Solution {\\n   \\n    Map<String,Double> map;\\n\\t\\n    public double knightProbability(int N, int K, int r, int c) {\\n\\t\\n\\t\\tmap = new HashMap();\\n\\t\\t\\n\\t\\t// prob returns the total paths which stayed inside the board and then we divide it with total number of moves .\\n\\t\\t\\n       double result = prob(N,K,r,c) / Math.pow(8,K); \\n        return result;\\n    }\\n    public double prob(int N,int K,int r,int c){\\n\\t// If the path is out of the board return 0 ;\\n        if(r < 0 || r >= N || c < 0 || c >= N){\\n            return 0;\\n        }\\n        String key = K +\"->\"+r+\"->\"+c;\\n\\t\\t\\n\\t\\t//if path is not out of the board and no moves left return 1;\\n        if(K==0){\\n            return 1;\\n        } \\n        if(map.containsKey(key))return map.get(key);\\n        \\n\\t\\t// There are total of 8 possible moves and we are traversing all the possible paths.\\n\\t\\t\\n        double op1 = prob(N,K-1,r+2,c+1);\\n        double op2 = prob(N,K-1,r+2,c-1);\\n        double op3 = prob(N,K-1,r-2,c+1);\\n        double op4 = prob(N,K-1,r-2,c-1);\\n        double op5 = prob(N,K-1,r-1,c+2);\\n        double op6 = prob(N,K-1,r+1,c+2);\\n        double op7 = prob(N,K-1,r+1,c-2);\\n        double op8 = prob(N,K-1,r-1,c-2);\\n        \\n        double result = op1 + op2 + op3 + op4 + op5 + op6 + op7 + op8;\\n        map.put(key , result);\\n        return result;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n   \\n    Map<String,Double> map;\\n\\t\\n    public double knightProbability(int N, int K, int r, int c) {\\n\\t\\n\\t\\tmap = new HashMap();\\n\\t\\t\\n\\t\\t// prob returns the total paths which stayed inside the board and then we divide it with total number of moves .\\n\\t\\t\\n       double result = prob(N,K,r,c) / Math.pow(8,K); \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3799482,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double help(int r,int c,int n,int k,vector<vector<vector<double>>>&dp){\\n        if(r<0 || c<0 || r>=n || c>=n)return 0;\\n        if(k==0)return 1;\\n        if(dp[r][c][k]!=-1)return dp[r][c][k];\\n        int dx[8] = {2,2,-2,-2,1,1,-1,-1};\\n        int dy[8] = {1,-1,1,-1,2,-2,2,-2};\\n        double ans=0;\\n       for(int i=0;i<8;i++){\\n           ans += help(r+dx[i],c+dy[i],n,k-1,dp)/8;\\n        }\\n        return dp[r][c][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int r, int c) {\\n        vector<vector<vector<double>>>dp(n+1,vector<vector<double>>(n+1,vector<double>(k+1,-1)));\\n       return help(r,c,n,k,dp); \\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a0956370-8756-451a-921c-c15188780c5f_1690006892.6314602.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double help(int r,int c,int n,int k,vector<vector<vector<double>>>&dp){\\n        if(r<0 || c<0 || r>=n || c>=n)return 0;\\n        if(k==0)return 1;\\n        if(dp[r][c][k]!=-1)return dp[r][c][k];\\n        int dx[8] = {2,2,-2,-2,1,1,-1,-1};\\n        int dy[8] = {1,-1,1,-1,2,-2,2,-2};\\n        double ans=0;\\n       for(int i=0;i<8;i++){\\n           ans += help(r+dx[i],c+dy[i],n,k-1,dp)/8;\\n        }\\n        return dp[r][c][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int r, int c) {\\n        vector<vector<vector<double>>>dp(n+1,vector<vector<double>>(n+1,vector<double>(k+1,-1)));\\n       return help(r,c,n,k,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288240,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N * K)***\\n\\n* ***Space Complexity :- O(N * N * K)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    double dp[30][30][105];\\n    \\n    // x and y co-ordinates of 8 directions\\n   \\n    vector<int> dx = {-2, -2, -1, 1, 2, 2, 1, -1};\\n    \\n    vector<int> dy = {-1, 1, 2, 2, 1, -1, -2, -2};\\n    \\n    double dfs(int i, int j, int n, int moves)\\n    {\\n        // base case if we have reached out of grid\\n        \\n        if(i < 0 || i >= n || j < 0 || j >= n)\\n            return 0;\\n        \\n        // if no moves are remaining\\n        \\n        if(moves <= 0)\\n            return 1;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][j][moves] != 0)\\n            return dp[i][j][moves];\\n        \\n        // find total possible ways of staying on chess board\\n        \\n        double ans = 0;\\n        \\n        for(int k = 0; k < 8; k++)\\n        {\\n            int new_row = i + dx[k];\\n            \\n            int new_col = j + dy[k];\\n            \\n            ans += dfs(new_row, new_col, n, moves - 1);\\n        }\\n        \\n        // for each cell there are 8 possible moves, so probablity will be no. of successfull moves / 8\\n        \\n        // store the result and return\\n        \\n        return dp[i][j][moves] = ans / 8.0;\\n    }\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        // initialize the dp with 0\\n        \\n        memset(dp, 0, sizeof(dp));\\n       \\n        return dfs(row, column, n, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    double dp[30][30][105];\\n    \\n    // x and y co-ordinates of 8 directions\\n   \\n    vector<int> dx = {-2, -2, -1, 1, 2, 2, 1, -1};\\n    \\n    vector<int> dy = {-1, 1, 2, 2, 1, -1, -2, -2};\\n    \\n    double dfs(int i, int j, int n, int moves)\\n    {\\n        // base case if we have reached out of grid\\n        \\n        if(i < 0 || i >= n || j < 0 || j >= n)\\n            return 0;\\n        \\n        // if no moves are remaining\\n        \\n        if(moves <= 0)\\n            return 1;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][j][moves] != 0)\\n            return dp[i][j][moves];\\n        \\n        // find total possible ways of staying on chess board\\n        \\n        double ans = 0;\\n        \\n        for(int k = 0; k < 8; k++)\\n        {\\n            int new_row = i + dx[k];\\n            \\n            int new_col = j + dy[k];\\n            \\n            ans += dfs(new_row, new_col, n, moves - 1);\\n        }\\n        \\n        // for each cell there are 8 possible moves, so probablity will be no. of successfull moves / 8\\n        \\n        // store the result and return\\n        \\n        return dp[i][j][moves] = ans / 8.0;\\n    }\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        // initialize the dp with 0\\n        \\n        memset(dp, 0, sizeof(dp));\\n       \\n        return dfs(row, column, n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799617,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-and-java",
                "content": "# Intuition\\nCreating two boards and keep current and next probability.\\nThis Python solution beats 92%.\\n\\n![\\u30B9\\u30AF\\u30EA\\u30FC\\u30F3\\u30B7\\u30E7\\u30C3\\u30C8 2023-07-22 15.45.14.png](https://assets.leetcode.com/users/images/417526bc-b03e-4750-847a-0f2b72389d9b_1690008499.6700006.png)\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/e3oSatmeAPo\\n\\n# Subscribe to my channel from here. I have 227 videos as of July 22th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other language might be different a bit.\\n\\n1. Define a list `moves` that contains all possible directions a knight can move to. Each element in `moves` is a tuple representing the relative coordinates for each direction.\\n\\n2. Create two 2D lists `cur_board` and `next_board`, both of size `n x n`, and initialize all elements to 0.0.\\n\\n3. Set the starting position `next_board[row][column]` to 1.0, as the knight is initially at this cell.\\n\\n4. Iterate `k` times, where `k` represents the number of moves the knight can take.\\n\\n5. For each iteration, update `cur_board` with the values from `next_board`, and reset `next_board` to a new 2D list of size `n x n` filled with zeros.\\n\\n6. For each cell `(r, c)` in the `cur_board` (representing the current state of the knight at each position), calculate the probability of reaching the neighboring cells by taking all possible moves (as specified in `moves`).\\n\\n7. If the current cell is not reachable (`cur_board[r][c] == 0.0`), continue to the next cell.\\n\\n8. If the neighboring cell `(next_row, next_col)` is within the chessboard (0 <= next_row < n and 0 <= next_col < n), update the probability of reaching that cell in `next_board` by adding the probability from the current cell divided by 8.0. This is because there are 8 possible moves the knight can take from the current cell.\\n\\n9. Repeat steps 6-8 for all cells in the `cur_board`, updating the `next_board` with the new probabilities.\\n\\n10. After `k` iterations, the `next_board` will contain the probabilities of the knight being at each cell on the chessboard after `k` moves.\\n\\n11. Calculate the total probability of the knight being on the chessboard by summing up all the probabilities in `next_board`.\\n\\n12. Return the total probability as the final result.\\n\\nThe code uses dynamic programming to calculate the probabilities efficiently and stores the intermediate results in `cur_board` and `next_board` for each iteration to avoid redundant calculations.\\n\\n# Complexity\\nThis is based on Python. Other language might be different a bit.\\n\\n- Time complexity: O(k * n^2)\\nThe outer loop runs k times, and the two nested loops run n^2 times each\\n\\n- Space complexity: O(n^2)\\nTwo 2D arrays, cur_board and next_board, are created with dimensions n x n, each occupying n^2 space.\\n\\nk represents the number of moves the knight can take, and n is the size of the chessboard. \\n\\n```python []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\\n\\n        cur_board = [[0.0] * n for _ in range(n)]\\n        next_board = [[0.0] * n for _ in range(n)]\\n        next_board[row][column] = 1.0\\n\\n        for _ in range(k):\\n            cur_board, next_board = next_board, [[0.0] * n for _ in range(n)]\\n\\n            for r in range(n):\\n                for c in range(n):\\n                    if cur_board[r][c] == 0.0:\\n                        continue\\n                    \\n                    for dr, dc in moves:\\n                        next_row, next_col = r + dr, c + dc\\n\\n                        if 0 <= next_row < n and 0 <= next_col < n:\\n                            next_board[next_row][next_col] += cur_board[r][c] / 8.0\\n        \\n        total = 0.0\\n        for r in range(n):\\n            for c in range(n):\\n                total += next_board[r][c]\\n        \\n        return total\\n```\\n``` javascript []\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @param {number} row\\n * @param {number} column\\n * @return {number}\\n */\\nvar knightProbability = function(n, k, row, column) {\\n    const moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\\n\\n    let curBoard = Array.from({ length: n }, () => Array(n).fill(0.0));\\n    let nextBoard = Array.from({ length: n }, () => Array(n).fill(0.0));\\n    nextBoard[row][column] = 1.0;\\n\\n    for (let i = 0; i < k; i++) {\\n        [curBoard, nextBoard] = [nextBoard, Array.from({ length: n }, () => Array(n).fill(0.0))];\\n\\n        for (let r = 0; r < n; r++) {\\n            for (let c = 0; c < n; c++) {\\n                if (curBoard[r][c] === 0.0) {\\n                    continue;\\n                }\\n\\n                for (const [dr, dc] of moves) {\\n                    const nextRow = r + dr;\\n                    const nextCol = c + dc;\\n\\n                    if (nextRow >= 0 && nextRow < n && nextCol >= 0 && nextCol < n) {\\n                        nextBoard[nextRow][nextCol] += curBoard[r][c] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let total = 0.0;\\n    for (let r = 0; r < n; r++) {\\n        for (let c = 0; c < n; c++) {\\n            total += nextBoard[r][c];\\n        }\\n    }\\n\\n    return total;    \\n};\\n```\\n```java []\\nclass Solution {\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n        double [][] curBoard;\\n        double [][] nextBoard = new double[n][n];\\n        nextBoard[row][column] = 1.0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            curBoard = nextBoard;\\n            nextBoard = new double[n][n];\\n            \\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    if (curBoard[r][c] == 0.0)\\n                        continue;\\n                    \\n                    for (int [] dir : moves) {\\n                        int nextRow = r + dir[0];\\n                        int nextCol = c + dir[1];\\n                        \\n                        if (nextRow >= 0 && nextRow < n && nextCol >= 0 && nextCol < n) {\\n                            nextBoard[nextRow][nextCol] += curBoard[r][c] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        double total = 0.0;\\n        for (int r = 0; r < n; r++)\\n            for (int c = 0; c < n; c++)\\n                total += nextBoard[r][c];\\n        \\n        return total;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\\n\\n        cur_board = [[0.0] * n for _ in range(n)]\\n        next_board = [[0.0] * n for _ in range(n)]\\n        next_board[row][column] = 1.0\\n\\n        for _ in range(k):\\n            cur_board, next_board = next_board, [[0.0] * n for _ in range(n)]\\n\\n            for r in range(n):\\n                for c in range(n):\\n                    if cur_board[r][c] == 0.0:\\n                        continue\\n                    \\n                    for dr, dc in moves:\\n                        next_row, next_col = r + dr, c + dc\\n\\n                        if 0 <= next_row < n and 0 <= next_col < n:\\n                            next_board[next_row][next_col] += cur_board[r][c] / 8.0\\n        \\n        total = 0.0\\n        for r in range(n):\\n            for c in range(n):\\n                total += next_board[r][c]\\n        \\n        return total\\n```\n``` javascript []\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @param {number} row\\n * @param {number} column\\n * @return {number}\\n */\\nvar knightProbability = function(n, k, row, column) {\\n    const moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\\n\\n    let curBoard = Array.from({ length: n }, () => Array(n).fill(0.0));\\n    let nextBoard = Array.from({ length: n }, () => Array(n).fill(0.0));\\n    nextBoard[row][column] = 1.0;\\n\\n    for (let i = 0; i < k; i++) {\\n        [curBoard, nextBoard] = [nextBoard, Array.from({ length: n }, () => Array(n).fill(0.0))];\\n\\n        for (let r = 0; r < n; r++) {\\n            for (let c = 0; c < n; c++) {\\n                if (curBoard[r][c] === 0.0) {\\n                    continue;\\n                }\\n\\n                for (const [dr, dc] of moves) {\\n                    const nextRow = r + dr;\\n                    const nextCol = c + dc;\\n\\n                    if (nextRow >= 0 && nextRow < n && nextCol >= 0 && nextCol < n) {\\n                        nextBoard[nextRow][nextCol] += curBoard[r][c] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let total = 0.0;\\n    for (let r = 0; r < n; r++) {\\n        for (let c = 0; c < n; c++) {\\n            total += nextBoard[r][c];\\n        }\\n    }\\n\\n    return total;    \\n};\\n```\n```java []\\nclass Solution {\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n        double [][] curBoard;\\n        double [][] nextBoard = new double[n][n];\\n        nextBoard[row][column] = 1.0;\\n        \\n        for (int i = 0; i < k; i++) {\\n            curBoard = nextBoard;\\n            nextBoard = new double[n][n];\\n            \\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    if (curBoard[r][c] == 0.0)\\n                        continue;\\n                    \\n                    for (int [] dir : moves) {\\n                        int nextRow = r + dir[0];\\n                        int nextCol = c + dir[1];\\n                        \\n                        if (nextRow >= 0 && nextRow < n && nextCol >= 0 && nextCol < n) {\\n                            nextBoard[nextRow][nextCol] += curBoard[r][c] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        double total = 0.0;\\n        for (int r = 0; r < n; r++)\\n            for (int c = 0; c < n; c++)\\n                total += nextBoard[r][c];\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798975,
                "title": "beats-100-2-appproach-java-c-with-explanation-backtracking",
                "content": "# understnading the poroblem : \\nThe problem describes a scenario where a chess knight is placed on an n x n chessboard and attempts to make exactly k moves. The knight has eight possible moves it can make at each step, and it chooses one of these moves uniformly at random.\\n\\nThe chessboard is represented as an n x n grid, where the rows and columns are 0-indexed. The top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\\n\\n##### The eight possible moves of the knight are as follows:\\n\\n- Two cells up and one cell to the right.\\n- 2 Two cells up and one cell to the left.\\n- Two cells down and one cell to the right.\\n- Two cells down and one cell to the left.\\n- Two cells to the right and one cell up.\\n- Two cells to the right and one cell down.\\n- Two cells to the left and one cell up.\\n- Two cells to the left and one cell down.\\n\\nThe goal of the problem is to determine the probability that the knight remains on the chessboard after it has made exactly k moves or has moved off the chessboard.\\n\\nTo solve this problem, we can use dynamic programming. We can create a 3D DP array with dimensions (n x n x k+1). The DP array, denoted as dp[i][j][steps], represents the probability of the knight being at position (i, j) after making \\'steps\\' moves.\\n\\nThe base case for this DP problem is dp[i][j][0] = 1, meaning that the probability of the knight being at position (i, j) after 0 moves is 100%, as it hasn\\'t moved yet.\\n\\nWe can then iterate through the number of steps, from 1 to k, and for each cell (i, j), calculate the probability of reaching that cell after \\'steps\\' moves. To calculate the probability at dp[i][j][steps], we sum up the probabilities from all eight possible moves that lead to cell (i, j) and update the DP array accordingly.\\n\\nAfter completing the DP computation, we can return the sum of all probabilities in the last step dp array that are still within the bounds of the chessboard (i.e., (0 \\u2264 i < n) and (0 \\u2264 j < n)).\\n\\nThe final returned value will be the probability that the knight remains on the board after it has stopped moving exactly k times.\\n\\n\\n### try to reas the abouve part it will help you to understanding the problem !! \\n\\n\\n\\n\\n\\n# Apporach 1\\n\\n#### Dynamic Programming with Memoization:\\n\\n- To solve this problem efficiently, we will use dynamic programming with memoization. The memoization technique allows us to store and reuse already computed results, avoiding redundant calculations.\\n- We\\'ll create a 3D DP array (memo) to store the probabilities of the knight being at a specific cell (i, j) after \\'steps\\' moves.\\n- The DP array will have dimensions of (n x n x k+1), where n is the size of the chessboard and k is the number of moves the knight makes.\\n- We initialize the DP array with -1.0, indicating that the probability for that cell and move count is not yet computed.\\n\\n\\n\\n\\n\\n#### Base Case and Initialization:\\n\\n- The base case for the DP is when k is 0. In this case, the probability of the knight being at any cell (i, j) is 1 because the knight hasn\\'t moved yet.\\n- We initialize dp[i][j][0] = 1 for all valid (i, j) positions.\\n\\n\\n\\n#### Recursive Function:\\n\\n- We will create a recursive function (knightProbabilityDP) that calculates the probability of the knight being at a cell (i, j) after \\'steps\\' moves.\\n- The function will take the current cell (row, col), chessboard size \\'n\\', and the remaining number of moves \\'k\\'.\\n- Before performing any calculations, we will check if the cell (row, col) is out of bounds. If so, we return 0, indicating that the knight cannot be at that cell after \\'steps\\' moves.\\n- If the probability for dp[row][col][k] is already computed (not equal to -1.0), we return the cached result.\\n\\n#### Recursive Calls:\\n\\n- In the recursive function, we use a loop to try all eight possible moves of the knight (two cells in a cardinal direction, then one cell in an orthogonal direction).\\n- For each valid move, we recursively call the knightProbabilityDP function with the updated cell (newRow, newCol) and k - 1 (decrementing the number of moves).\\n- We add up all the probabilities from the recursive calls, representing the probability of reaching cell (row, col) after \\'steps\\' moves.\\n\\n#### Updating DP and Returning Result:\\n\\n- Once we have computed the probability for dp[row][col][k], we store it in the DP array to reuse it later if needed.\\n- The final result we want to calculate is the probability of the knight being on the board after k moves, starting from a given cell (startRow, startCol).\\n- We call the recursive function (knightProbabilityDP) with the initial cell (startRow, startCol) and k, which will return the probability of the knight being at that cell after k moves.\\n- We divide this probability by the total number of possible outcomes, which is 8^k (eight possible moves at each step), to get the final answer.\\n\\n### Output:\\n\\n- - The returned value is the probability that the knight remains on the board after it has stopped moving exactly k times, starting from the given cell (startRow, startCol). The value will be between 0 and 1.\\n![upvote.jpg](https://assets.leetcode.com/users/images/3f575c98-90fb-4946-ab8f-2f550a47bc19_1689995372.261699.jpeg)\\n\\n## more optimsed code is given below !!\\n\\n# code \\n```java []\\npublic class Solution {\\n    double[][][] dp;\\n    int[] xmove = {-2, -2, -1, -1, 1, 1, 2, 2};\\n    int[] ymove = {-1, 1, -2, 2, -2, 2, -1, 1};\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        dp = new double[n][n][k + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1.0);\\n            }\\n        }\\n        double favourableOutcome = solve(row, col, n, k);\\n        double totalOutcome = Math.pow(8, k);\\n        return favourableOutcome / totalOutcome;\\n    }\\n\\n    private double solve(int row, int col, int n, int k) {\\n        if (row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if (k == 0) return 1;\\n        if (dp[row][col][k] != -1.0) return dp[row][col][k];\\n\\n        double ans = 0;\\n\\n        for (int i = 0; i < 8; i++) {\\n            ans += solve(row + xmove[i], col + ymove[i], n, k - 1);\\n        }\\n\\n        return dp[row][col][k] = ans;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\ndouble dp[26][26][102];\\n    int xmove[8] = {-2,-2,-1,-1,1,1,2,2};\\n    int ymove[8] = {-1,1,-2,2,-2,2,-1,1};\\n  double solve(int row,int col,int n,int k){\\n        if(row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[row][col][k] != -1.0) return dp[row][col][k];\\n        \\n       double ans = 0;\\n        \\n        for(int i=0;i<8;i++){\\n            ans += solve(row+xmove[i], col+ymove[i], n, k-1);\\n        }\\n        \\n        return dp[row][col][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                for(int k=0;k<102;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        double favourableoutcome = solve(row,col,n,k);\\n        double totaloutcome = pow(8,k);\\n        return favourableoutcome/totaloutcome;\\n    }\\n};\\n```\\n\\n\\nthe running time of the code below !! \\n![Screenshot 2023-07-22 084626.png](https://assets.leetcode.com/users/images/309de975-6318-4612-933a-997caa21dc26_1689995935.9950595.png)\\n\\n\\n# the more optimised \\n#### java : \\n```\\nclass Solution {\\n    private final int[][] moves = {{2, 1}, {-2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {1, -2}, {-1, -2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] cache = new double[n / 2 + 1][n / 2 + 1][k + 1];\\n        return solver(n, k, row, column, cache);\\n    }\\n    private double solver(int n, int k, int row, int column, double[][][] memo) {\\n        if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\\n        if (k == 0) return 1.0;\\n\\n        row = Math.min(row, n - 1 - row);\\n        column = Math.min(column, n - 1 - column);\\n\\n        if (row < column) return solver(n, k, column, row, memo);\\n        if (memo[row][column][k] != 0.0) return memo[row][column][k];\\n\\n        double probability = 0.0;\\n        for (int[] move : moves) {\\n            probability += solver(n, k - 1, row + move[0], column + move[1], memo) / 8.0;\\n        }\\n        memo[row][column][k] = probability;\\n        return probability;\\n    }\\n}\\n\\n```\\n# Aproach -2 \\n#### Representation of Moves:\\n\\n-Instead of representing the knight\\'s moves using two separate arrays (xMoves and yMoves), the solution directly uses the relative positions for all eight possible moves in the \\'moves\\' array.\\n-Each entry in the \\'moves\\' array represents the relative change in row and column that the knight makes for a particular move.\\n\\n#### Cache and Optimized Search Space:\\n\\n- The solution uses a 3D cache array \\'memo\\' with dimensions [n/2 + 1][n/2 + 1][k+1]. The purpose of this cache is to store previously computed probabilities to avoid redundant calculations.\\n- Additionally, the solution makes use of symmetry in the chessboard. Since the board is symmetrical with respect to the center, it\\'s more efficient to compute probabilities in the top-right quadrant of the chessboard only and then use this symmetry to fill in the other quadrants.\\n\\n#### Row and Column Bounds Adjustment:\\n\\n- Before starting the recursive calls, the solution adjusts the row and column values based on their distance from the center of the board (n/2). This adjustment helps reduce the search space by considering only the top-right quadrant of the chessboard.\\n\\n#### Recursive Function:\\n\\n- The recursive function (solver) takes in the current position (row, column), chessboard size \\'n\\', the remaining number of moves \\'k\\', and the memoization cache.\\n- The base case checks if the knight is out of bounds or has made all the moves (k == 0). If so, it returns the corresponding probability (0.0 or 1.0).\\n- The function calculates the probability of reaching the current cell after \\'k\\' moves by recursively trying all eight possible moves.\\n- Instead of dividing the result by 8.0 in each recursive call, it accumulates the probabilities and divides the final result once before storing it in the cache.\\n\\n#### Using Memoization:\\n\\n- The function checks if the probability for the current cell and move count is already present in the cache (memo). If so, it returns the cached result, avoiding redundant computations.\\n\\n### Output:\\n\\nThe main function initializes the cache, and then calls the recursive function (solver) with the initial cell (row, column) and k.\\nThe returned value is the probability that the knight remains on the board after it has stopped moving exactly k times, starting from the given cell (row, column). The value will be between 0 and 1.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic class Solution {\\n    double[][][] dp;\\n    int[] xmove = {-2, -2, -1, -1, 1, 1, 2, 2};\\n    int[] ymove = {-1, 1, -2, 2, -2, 2, -1, 1};\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        dp = new double[n][n][k + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1.0);\\n            }\\n        }\\n        double favourableOutcome = solve(row, col, n, k);\\n        double totalOutcome = Math.pow(8, k);\\n        return favourableOutcome / totalOutcome;\\n    }\\n\\n    private double solve(int row, int col, int n, int k) {\\n        if (row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if (k == 0) return 1;\\n        if (dp[row][col][k] != -1.0) return dp[row][col][k];\\n\\n        double ans = 0;\\n\\n        for (int i = 0; i < 8; i++) {\\n            ans += solve(row + xmove[i], col + ymove[i], n, k - 1);\\n        }\\n\\n        return dp[row][col][k] = ans;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\ndouble dp[26][26][102];\\n    int xmove[8] = {-2,-2,-1,-1,1,1,2,2};\\n    int ymove[8] = {-1,1,-2,2,-2,2,-1,1};\\n  double solve(int row,int col,int n,int k){\\n        if(row < 0 || col < 0 || row >= n || col >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[row][col][k] != -1.0) return dp[row][col][k];\\n        \\n       double ans = 0;\\n        \\n        for(int i=0;i<8;i++){\\n            ans += solve(row+xmove[i], col+ymove[i], n, k-1);\\n        }\\n        \\n        return dp[row][col][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                for(int k=0;k<102;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n        double favourableoutcome = solve(row,col,n,k);\\n        double totaloutcome = pow(8,k);\\n        return favourableoutcome/totaloutcome;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private final int[][] moves = {{2, 1}, {-2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {1, -2}, {-1, -2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] cache = new double[n / 2 + 1][n / 2 + 1][k + 1];\\n        return solver(n, k, row, column, cache);\\n    }\\n    private double solver(int n, int k, int row, int column, double[][][] memo) {\\n        if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\\n        if (k == 0) return 1.0;\\n\\n        row = Math.min(row, n - 1 - row);\\n        column = Math.min(column, n - 1 - column);\\n\\n        if (row < column) return solver(n, k, column, row, memo);\\n        if (memo[row][column][k] != 0.0) return memo[row][column][k];\\n\\n        double probability = 0.0;\\n        for (int[] move : moves) {\\n            probability += solver(n, k - 1, row + move[0], column + move[1], memo) / 8.0;\\n        }\\n        memo[row][column][k] = probability;\\n        return probability;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193242,
                "title": "python3-dfs-with-dp-beats-99-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe probability of the chance to stay on the board after `k` moves are equal to the number of all desired positions at the end divided by all possible outcomes. \\n\\nAll possible outcomes can be found with the formula `8^k`. Why is that? Because on every step, we always have 8 possible moves (including those that lead out of the board). That means after 2 moves, we can have 8 * 8 possible positions and so on. So the number of positions where we can end up after `k` moves equals the `8^k`. \\n\\nThe number of desirable outcomes (those that keep us on the board) is what we need to calculate iteratively using Depth-First Search. For that, we must precalculate all possible moves from a particular position on the board. And this gives us some kind of adjacency list. \\n\\nSince the number of positions on the next moves grows geometrically, there are high chances for overlapping tasks, i.e. when on the same move, we start from the same place multiple times. Thus we need a cache of the result of the recursive function for DFS traversing.\\n\\nTime: **O(n * n * k)**\\nSpace: **O(n * n * k)**\\n\\nRuntime: 171 ms, faster than **99.87%** of Python3 online submissions for Knight Probability in Chessboard.\\nMemory Usage: 23.6 MB, less than **25.13%** of Python3 online submissions for Knight Probability in Chessboard.\\n\\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row0: int, col0: int) -> float:\\n\\t\\n\\t\\t# precalculate possible moves\\n        adj_list = defaultdict(list)\\n        d = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2))\\n        for row in range(n):\\n            for col in range(n):\\n                for dx, dy in d:\\n                    pos = (row + dx, col + dy)\\n                    if 0 <= pos[0] < n and 0 <= pos[1] < n:\\n                        adj_list[(row, col)].append(pos)\\n\\n        @cache\\n        def get_leafs_num(pos, h):\\n            if h == k:\\n                return 1\\n            \\n            res = 0\\n            for next_pos in adj_list[pos]:\\n                res += get_leafs_num(next_pos, h + 1)\\n                \\n            return res            \\n            \\n        leafs_num = get_leafs_num((row0, col0), 0)\\n\\n        return leafs_num / 8**k\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row0: int, col0: int) -> float:\\n\\t\\n\\t\\t# precalculate possible moves\\n        adj_list = defaultdict(list)\\n        d = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2))\\n        for row in range(n):\\n            for col in range(n):\\n                for dx, dy in d:\\n                    pos = (row + dx, col + dy)\\n                    if 0 <= pos[0] < n and 0 <= pos[1] < n:\\n                        adj_list[(row, col)].append(pos)\\n\\n        @cache\\n        def get_leafs_num(pos, h):\\n            if h == k:\\n                return 1\\n            \\n            res = 0\\n            for next_pos in adj_list[pos]:\\n                res += get_leafs_num(next_pos, h + 1)\\n                \\n            return res            \\n            \\n        leafs_num = get_leafs_num((row0, col0), 0)\\n\\n        return leafs_num / 8**k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895946,
                "title": "dfs-dp-progression-with-explanation-82-6",
                "content": "This problem is asking us to explore all possible combinations of moves the knight can make, and return the percentage of combinations that keeps the knight on the board after `K` turns.  At each step, the knight has an equal probability of moving to one of its eight possible positions.  This leads to the following DFS solution\\n```\\ndef dfs(N, K, r, c):\\n\\tif r < 0 or r >= N or c < 0 or c >= N:    // Out of bounds\\n\\t\\treturn 0\\n\\tif K == 0:   // In bounds after K turns\\n\\t\\treturn 1\\n\\tleft_up = 0.125 * dfs(N, K - 1, r - 1, c - 2)\\n\\tleft_down = 0.125 * dfs(N, K - 1, r + 1, c - 2)\\n\\tdown_left = 0.125 * dfs(N, K - 1, r + 2, c - 1)\\n\\tdown_right = 0.125 * dfs(N, K - 1, r + 2, c + 1)\\n\\tright_down = 0.125 * dfs(N, K - 1, r + 1, c + 2)\\n\\tright_up = 0.125 * dfs(N, K - 1, r - 1, c + 2)\\n\\tup_right = 0.125 * dfs(N, K - 1, r - 2, c + 1)\\n\\tup_left = 0.125 * dfs(N, K - 1, r - 2, c - 1)\\n\\n\\treturn sum([left_up, left_down, down_left, down_right, right_down, right_up, up_right, up_left])\\nreturn dfs(N, K, r, c)\\n```\\nWe can think of each of the recursive calls as a move the knight can make from its current position.  If we draw out the DFS recursion tree, each node will have 8 branches, one for each possible move.  Moving down one branch signifies the knight making that move, and then we repeat the process given the knight\\'s new position.\\n\\nHowever, the DFS solution takes too long and times out.  Why is this?  Again, think of every recursive call as the knight moving to one of its eight possible squares.  From the starting square, one possible path the knight could follow is `left_up -> up_left`.  Also from the starting square, another possible path the knight could follow is `up_left -> left_up`.  Both of these paths put the knight on the same square in the same amount of moves.  If we continue calculating both paths from this new position, we will see they result in the same answer.  Instead of just calculating this once, we have done it twice!  Now imagine how many times this happens if we increase the moves the knight can make, this gets exponentially worse.\\n\\nThis is where the DP solution comes in.  Let\\'s look at the solution, and then I will explain the logic.\\n```\\ndef dp(N, K, r, c):\\n\\tA = [[[0] * N for _ in range(N)] for _ in range(K + 1)]\\n\\tfor i in range(N):\\n\\t\\tfor j in range(N):\\n\\t\\t\\tA[0][i][j] = 1\\n\\tfor k in range(1, K + 1):\\n\\t\\tfor i in range(N):\\n\\t\\t\\tfor j in range(N):\\n\\t\\t\\t\\tif i - 1 >= 0 and j - 2 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 1][j - 2]\\n\\t\\t\\t\\tif i + 1 < N and j - 2 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 1][j - 2]\\n\\t\\t\\t\\tif i + 2 < N and j - 1 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 2][j - 1]\\n\\t\\t\\t\\tif i + 2 < N and j + 1 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 2][j + 1]\\n\\t\\t\\t\\tif i + 1 < N and j + 2 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 1][j + 2]\\n\\t\\t\\t\\tif i - 1 >= 0 and j + 2 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 1][j + 2]\\n\\t\\t\\t\\tif i - 2 >= 0 and j + 1 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 2][j + 1]\\n\\t\\t\\t\\tif i - 2 >= 0 and j - 1 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 2][j - 1]\\n\\n\\treturn A[K][r][c]\\nreturn dp(N, K, r, c)\\n```\\nYes a 3D array is daunting, but let\\'s break it down by first looking at the subproblem we are trying to solve.  \\n```\\nA[k][i][j] = The probability of the knight remaining on the board from position (i, j) with k moves remaining\\n```\\nSo with `k == 0` moves left, every position on the board has a probability of 1 because the knight has no more moves to make.  Visualizing the 3D array, this builds the bottom layer, and now we start to fill the layers out going upwards.  At `K == 1`, notice that this is exactly the same as the DFS solution.  We have 8 possible moves, and for each recursive call that stays on the board we add (0.125 * 1).  For each recursive call that falls out of bounds, we simply don\\'t add it (which is the same as adding 0 as we did in the DFS solution).  Continue doing this until we have filled in `K` slices of the array and we have our solution.\\nSince we built this solution from the ground up, we are avoiding recalculating large portions of paths which is the problem that plagues the DFS solution.  This is why DP is optimal for this type of problem.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(N, K, r, c):\\n\\tif r < 0 or r >= N or c < 0 or c >= N:    // Out of bounds\\n\\t\\treturn 0\\n\\tif K == 0:   // In bounds after K turns\\n\\t\\treturn 1\\n\\tleft_up = 0.125 * dfs(N, K - 1, r - 1, c - 2)\\n\\tleft_down = 0.125 * dfs(N, K - 1, r + 1, c - 2)\\n\\tdown_left = 0.125 * dfs(N, K - 1, r + 2, c - 1)\\n\\tdown_right = 0.125 * dfs(N, K - 1, r + 2, c + 1)\\n\\tright_down = 0.125 * dfs(N, K - 1, r + 1, c + 2)\\n\\tright_up = 0.125 * dfs(N, K - 1, r - 1, c + 2)\\n\\tup_right = 0.125 * dfs(N, K - 1, r - 2, c + 1)\\n\\tup_left = 0.125 * dfs(N, K - 1, r - 2, c - 1)\\n\\n\\treturn sum([left_up, left_down, down_left, down_right, right_down, right_up, up_right, up_left])\\nreturn dfs(N, K, r, c)\\n```\n```\\ndef dp(N, K, r, c):\\n\\tA = [[[0] * N for _ in range(N)] for _ in range(K + 1)]\\n\\tfor i in range(N):\\n\\t\\tfor j in range(N):\\n\\t\\t\\tA[0][i][j] = 1\\n\\tfor k in range(1, K + 1):\\n\\t\\tfor i in range(N):\\n\\t\\t\\tfor j in range(N):\\n\\t\\t\\t\\tif i - 1 >= 0 and j - 2 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 1][j - 2]\\n\\t\\t\\t\\tif i + 1 < N and j - 2 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 1][j - 2]\\n\\t\\t\\t\\tif i + 2 < N and j - 1 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 2][j - 1]\\n\\t\\t\\t\\tif i + 2 < N and j + 1 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 2][j + 1]\\n\\t\\t\\t\\tif i + 1 < N and j + 2 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i + 1][j + 2]\\n\\t\\t\\t\\tif i - 1 >= 0 and j + 2 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 1][j + 2]\\n\\t\\t\\t\\tif i - 2 >= 0 and j + 1 < N:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 2][j + 1]\\n\\t\\t\\t\\tif i - 2 >= 0 and j - 1 >= 0:\\n\\t\\t\\t\\t\\tA[k][i][j] += 0.125 * A[k - 1][i - 2][j - 1]\\n\\n\\treturn A[K][r][c]\\nreturn dp(N, K, r, c)\\n```\n```\\nA[k][i][j] = The probability of the knight remaining on the board from position (i, j) with k moves remaining\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 672381,
                "title": "c-3-solutions",
                "content": "1.Using queue\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        double prob;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({r,c});\\n        int drxn[]={2,1,2,-1,-2,1,-2,-1,2};\\n        vector<vector<double>> dp(N+1,vector<double>(N+1));\\n        dp[r][c]=1.0;\\n        while(K--&&!q.empty())\\n        {\\n            int n=q.size();\\n            int cnt=0;\\n            vector<vector<double>> dp1(N+1,vector<double>(N+1));\\n            for(int i=0;i<n;i++)\\n            {\\n                int row=q.front().first;\\n                int col=q.front().second;\\n                q.pop();\\n                for(int j=0;j<8;j++)\\n                {\\n                    int x=row+drxn[j];\\n                    int y=col+drxn[j+1];\\n                    if(x>=0&&x<N&&y>=0&&y<N)\\n                    {\\n                        if(dp1[x][y]==0)\\n                            q.push({x,y});\\n                        dp1[x][y]+=dp[row][col]/8.0;\\n                    }\\n                }\\n            }\\n            dp=dp1;\\n        }\\n        for(vector<double> ans: dp)\\n        {\\n            for(double x:ans)\\n                prob+=x;\\n        }\\n        return prob;\\n            \\n    }\\n};\\n```\\n2.Recursion+memoization\\n```\\nclass Solution {\\npublic:\\n    double calc(int n,int k,int r,int c,vector<vector<vector<double>>>& dp, vector<int>& drxn)\\n    {\\n        if(k==0)\\n            return dp[r][c][k]=1;\\n        double ans=0;\\n        if(dp[r][c][k]!=0)\\n            return dp[r][c][k];\\n        for(int i=0;i<8;i++)\\n        {\\n            int row=r+drxn[i];\\n            int col=c+drxn[i+1];\\n            if(row>=0&&row<n&&col>=0&&col<n)\\n                ans+=calc(n,k-1,row,col,dp,drxn)/8.0;\\n        }\\n        // cout<<ans<<endl;\\n        return dp[r][c][k]=ans;\\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        double prob=0;\\n        vector<int> drxn{2,1,2,-1,-2,1,-2,-1,2};\\n        // double dp[N+1][N+1][K+1];\\n        // memset(dp,0,sizeof(dp));\\n        // dp[r-1][c-1][K]=1;\\n        vector<vector<vector<double>>> dp(N+1,vector<vector<double>>(N+1,vector<double>(K+1)));\\n        calc(N,K,r,c,dp,drxn);\\n        return dp[r][c][K];\\n    }\\n};\\n```\\n3.DP w/o recursion\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        double prob=0;\\n        \\n        // queue<pair<int,int>> q;\\n        // q.push({r,c});\\n        int drxn[]={2,1,2,-1,-2,1,-2,-1,2};\\n        vector<vector<double>> dp(N,vector<double>(N,0));\\n        dp[r][c]=1;\\n        while(K--)\\n        {\\n            vector<vector<double>> dp2(N,vector<double>(N,0));\\n            // int n=q.size();\\n            double cnt=0;\\n            for(int row=0;row<N;row++)\\n            {\\n                for(int col=0;col<N;col++)\\n                \\n                {   // int row=q.front().first;\\n                    // int col=q.front().second;\\n                    // q.pop();\\n                    for(int j=0;j<8;j++)\\n                    {\\n                        int x=row+drxn[j];\\n                        int y=col+drxn[j+1];\\n                        if(x>=0&&x<N&&y>=0&&y<N)\\n                        {\\n                            // if(dp[x][y]==0)\\n                            //     q.push({x,y});\\n                            dp2[x][y]+=(dp[row][col]/8.0);\\n                        }\\n                    }   \\n                }\\n            }\\n            // prob=cnt;\\n            dp=dp2;\\n        }\\n        for(vector<double> ans:dp)\\n        {\\n            for(double x:ans)\\n                prob+=x;\\n        }\\n        return prob;\\n            \\n    }\\n};\\n```\\nAny suggestions are welcome regarding improvement.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        double prob;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({r,c});\\n        int drxn[]={2,1,2,-1,-2,1,-2,-1,2};\\n        vector<vector<double>> dp(N+1,vector<double>(N+1));\\n        dp[r][c]=1.0;\\n        while(K--&&!q.empty())\\n        {\\n            int n=q.size();\\n            int cnt=0;\\n            vector<vector<double>> dp1(N+1,vector<double>(N+1));\\n            for(int i=0;i<n;i++)\\n            {\\n                int row=q.front().first;\\n                int col=q.front().second;\\n                q.pop();\\n                for(int j=0;j<8;j++)\\n                {\\n                    int x=row+drxn[j];\\n                    int y=col+drxn[j+1];\\n                    if(x>=0&&x<N&&y>=0&&y<N)\\n                    {\\n                        if(dp1[x][y]==0)\\n                            q.push({x,y});\\n                        dp1[x][y]+=dp[row][col]/8.0;\\n                    }\\n                }\\n            }\\n            dp=dp1;\\n        }\\n        for(vector<double> ans: dp)\\n        {\\n            for(double x:ans)\\n                prob+=x;\\n        }\\n        return prob;\\n            \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double calc(int n,int k,int r,int c,vector<vector<vector<double>>>& dp, vector<int>& drxn)\\n    {\\n        if(k==0)\\n            return dp[r][c][k]=1;\\n        double ans=0;\\n        if(dp[r][c][k]!=0)\\n            return dp[r][c][k];\\n        for(int i=0;i<8;i++)\\n        {\\n            int row=r+drxn[i];\\n            int col=c+drxn[i+1];\\n            if(row>=0&&row<n&&col>=0&&col<n)\\n                ans+=calc(n,k-1,row,col,dp,drxn)/8.0;\\n        }\\n        // cout<<ans<<endl;\\n        return dp[r][c][k]=ans;\\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        double prob=0;\\n        vector<int> drxn{2,1,2,-1,-2,1,-2,-1,2};\\n        // double dp[N+1][N+1][K+1];\\n        // memset(dp,0,sizeof(dp));\\n        // dp[r-1][c-1][K]=1;\\n        vector<vector<vector<double>>> dp(N+1,vector<vector<double>>(N+1,vector<double>(K+1)));\\n        calc(N,K,r,c,dp,drxn);\\n        return dp[r][c][K];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        double prob=0;\\n        \\n        // queue<pair<int,int>> q;\\n        // q.push({r,c});\\n        int drxn[]={2,1,2,-1,-2,1,-2,-1,2};\\n        vector<vector<double>> dp(N,vector<double>(N,0));\\n        dp[r][c]=1;\\n        while(K--)\\n        {\\n            vector<vector<double>> dp2(N,vector<double>(N,0));\\n            // int n=q.size();\\n            double cnt=0;\\n            for(int row=0;row<N;row++)\\n            {\\n                for(int col=0;col<N;col++)\\n                \\n                {   // int row=q.front().first;\\n                    // int col=q.front().second;\\n                    // q.pop();\\n                    for(int j=0;j<8;j++)\\n                    {\\n                        int x=row+drxn[j];\\n                        int y=col+drxn[j+1];\\n                        if(x>=0&&x<N&&y>=0&&y<N)\\n                        {\\n                            // if(dp[x][y]==0)\\n                            //     q.push({x,y});\\n                            dp2[x][y]+=(dp[row][col]/8.0);\\n                        }\\n                    }   \\n                }\\n            }\\n            // prob=cnt;\\n            dp=dp2;\\n        }\\n        for(vector<double> ans:dp)\\n        {\\n            for(double x:ans)\\n                prob+=x;\\n        }\\n        return prob;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 751010,
                "title": "javascript-solution-top-down-with-memoization-2-dp-approaches",
                "content": "##### Top Down Approach with Memoization #####\\n<br>\\n\\n```\\nvar knightProbability = function(N, K, r, c) {\\n    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];\\n    const memo = new Map();\\n    \\n    return findProbs(K, r, c);\\n    \\n    function findProbs(k, r, c) {\\n        const key = `${k}#${r}#${c}`;\\n        \\n        // base case\\n        if (isOutOfBound(r, c)) return 0.0; // .0 is for completeness sake. Don\\'t really need it in JavaScript\\n        if (k === 0) return 1.0;\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let prob = 0;\\n        \\n        for (const [dirX, dirY] of dirs) {\\n            prob += 0.125 * findProbs(k - 1, r + dirX, c + dirY);\\n        }\\n        \\n        memo.set(key, prob);\\n        \\n        return prob;\\n        \\n    }\\n    \\n    function isOutOfBound(row, col) {\\n        return row < 0 || col < 0 || row >= N || col >= N;\\n    }\\n};\\n```\\n<br>\\n\\n----\\n\\n<br>\\n\\n##### DP Approach  with O(N^2 * K) Space Complexity #####\\n\\n<br>\\n\\n```\\nvar knightProbability = function(N, K, r, c) {\\n    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];\\n    const probs = constructProbs(K);\\n    \\n    probs[0][r][c] = 1.0;\\n    \\n    for (let k = 1; k <= K; k++) {\\n        for (let i = 0; i < N; i++) {\\n            for (let j = 0; j < N; j++) {\\n                for (const [dirX, dirY] of dirs) {\\n                    const currRank = i + dirX;\\n                    const currFile = j + dirY;\\n                    \\n                    if (withinBound(currRank, currFile)) {\\n                        probs[k][currRank][currFile] += (probs[k - 1][i][j] * 0.125);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    \\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            ans += probs[K][i][j];\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    function constructProbs(K) {\\n        const probs = [];\\n        \\n        for (let k = 0; k <= K; k++) {\\n            probs[k] = [];\\n            \\n            for (let i = 0; i < N; i++) {\\n                probs[k][i] = new Array(N).fill(0);\\n            }\\n        }\\n        \\n        return probs;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < N && col < N;\\n    }\\n};\\n```\\n<br>\\n\\n---\\n\\n<br>\\n\\n##### DP with O(N^2) Spacex Complexity #####\\n\\n<br>\\n\\n```\\nvar knightProbability = function(N, K, r, c) {\\n    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];\\n    let prevProbs = constructProbs(K);\\n    \\n    prevProbs[r][c] = 1;\\n    \\n    for (let k = 1; k <= K; k++) {\\n        const newProbs = constructProbs(K);\\n              \\n        for (let i = 0; i < N; i++) {\\n            for (let j = 0; j < N; j++) {\\n                for (const [dirX, dirY] of dirs) {\\n                    const currRank = i + dirX;\\n                    const currFile = j + dirY;\\n                    \\n                    if (withinBound(currRank, currFile)) {\\n                        newProbs[currRank][currFile] += (prevProbs[i][j] / 8.0);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        prevProbs = newProbs;\\n    }\\n    \\n    let ans = 0;\\n    \\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            ans += prevProbs[i][j];\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    function constructProbs(K) {\\n        const dp = [];\\n            \\n        for (let i = 0; i < N; i++) {\\n            dp[i] = new Array(N).fill(0);\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < N && col < N;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar knightProbability = function(N, K, r, c) {\\n    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];\\n    const memo = new Map();\\n    \\n    return findProbs(K, r, c);\\n    \\n    function findProbs(k, r, c) {\\n        const key = `${k}#${r}#${c}`;\\n        \\n        // base case\\n        if (isOutOfBound(r, c)) return 0.0; // .0 is for completeness sake. Don\\'t really need it in JavaScript\\n        if (k === 0) return 1.0;\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        let prob = 0;\\n        \\n        for (const [dirX, dirY] of dirs) {\\n            prob += 0.125 * findProbs(k - 1, r + dirX, c + dirY);\\n        }\\n        \\n        memo.set(key, prob);\\n        \\n        return prob;\\n        \\n    }\\n    \\n    function isOutOfBound(row, col) {\\n        return row < 0 || col < 0 || row >= N || col >= N;\\n    }\\n};\\n```\n```\\nvar knightProbability = function(N, K, r, c) {\\n    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];\\n    const probs = constructProbs(K);\\n    \\n    probs[0][r][c] = 1.0;\\n    \\n    for (let k = 1; k <= K; k++) {\\n        for (let i = 0; i < N; i++) {\\n            for (let j = 0; j < N; j++) {\\n                for (const [dirX, dirY] of dirs) {\\n                    const currRank = i + dirX;\\n                    const currFile = j + dirY;\\n                    \\n                    if (withinBound(currRank, currFile)) {\\n                        probs[k][currRank][currFile] += (probs[k - 1][i][j] * 0.125);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    \\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            ans += probs[K][i][j];\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    function constructProbs(K) {\\n        const probs = [];\\n        \\n        for (let k = 0; k <= K; k++) {\\n            probs[k] = [];\\n            \\n            for (let i = 0; i < N; i++) {\\n                probs[k][i] = new Array(N).fill(0);\\n            }\\n        }\\n        \\n        return probs;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < N && col < N;\\n    }\\n};\\n```\n```\\nvar knightProbability = function(N, K, r, c) {\\n    const dirs = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];\\n    let prevProbs = constructProbs(K);\\n    \\n    prevProbs[r][c] = 1;\\n    \\n    for (let k = 1; k <= K; k++) {\\n        const newProbs = constructProbs(K);\\n              \\n        for (let i = 0; i < N; i++) {\\n            for (let j = 0; j < N; j++) {\\n                for (const [dirX, dirY] of dirs) {\\n                    const currRank = i + dirX;\\n                    const currFile = j + dirY;\\n                    \\n                    if (withinBound(currRank, currFile)) {\\n                        newProbs[currRank][currFile] += (prevProbs[i][j] / 8.0);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        prevProbs = newProbs;\\n    }\\n    \\n    let ans = 0;\\n    \\n    for (let i = 0; i < N; i++) {\\n        for (let j = 0; j < N; j++) {\\n            ans += prevProbs[i][j];\\n        }\\n    }\\n    \\n    return ans;\\n    \\n    function constructProbs(K) {\\n        const dp = [];\\n            \\n        for (let i = 0; i < N; i++) {\\n            dp[i] = new Array(N).fill(0);\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < N && col < N;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799293,
                "title": "easy-short-optimized-c-solution-with-explaination",
                "content": "# Explaination\\n\\nThe \\'dir\\' array is a 2D array representing the possible moves a knight can make on the chessboard. The knight can move to any of the 8 positions represented by the (row, col) pairs in the \\'dir\\' array.\\n\\nThe \\'dp\\' unordered map is used for memoization. It stores the calculated probabilities for different states (i.e., (k, row, column)) to avoid redundant calculations and improve the efficiency of the solution.\\n\\nThe \\'solve\\' function is a recursive function that calculates the probability of the knight staying within the board after making \\'k\\' moves starting from the given position (row, column). It returns the probability as a double value.\\n\\n- Base Cases:\\n  - If the knight goes out of the board (i.e., row < 0, row >= n, column < 0, column >= n), return 0, as it\\'s not a valid move.\\n  - If \\'k\\' becomes 0, it means the knight has made all the moves, and it will stay within the board. So, return 1.\\n\\n- Memoization:\\n  - Before calculating the probability for a specific state, check if it has already been calculated and stored in the \\'dp\\' map. If yes, return the stored value, avoiding redundant calculations.\\n\\n- Recursive Calculation:\\n  - For each of the 8 possible moves, recursively call the \\'solve\\' function with \\'k-1\\' moves and the new position (row + dir[i][0], column + dir[i][1]).\\n  - Calculate the sum of probabilities from all 8 possible moves.\\n\\n- Final Result:\\n  - The final probability is the sum of probabilities obtained from all 8 possible moves, divided by 8 (since the knight has an equal probability of moving to any of the 8 positions).\\n\\n\\n# Complexity\\n- Time complexity: The time complexity of the \\'solve\\' function is O(k * 8) = O(k) because, for each of the 8 possible moves, it calls itself recursively. In the worst case, the \\'solve\\' function is called for each cell on the chessboard, which gives a total of n^2 calls. Therefore, the overall time complexity of the entire \\'knightProbability\\' function is **O(n^2 * k)**.\\n\\n- Space complexity: The maximum depth of the recursive call stack is equal to \\'k\\'. The \\'dp\\' unordered map stores the probabilities for each state, which has a maximum of O(n^2) unique states So, the space complexity due to the \\'dp\\' map is **O(n^2)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[8][8] = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    unordered_map<string,double> dp;\\n\\n    double solve(int n,int k,int r, int c){\\n        if(r<0  ||  r>=n  ||  c<0  ||  c>=n) return 0;\\n        if(k==0) return 1;\\n\\n        string key= to_string(k)+\"Leet\"+ to_string(r)+ \"Code\"+ to_string(c);\\n        if(dp.count(key)) return dp[key];\\n\\n        double prob=0;\\n        for(int i=0;i<8;i++){\\n            prob+= solve(n,k-1,r+dir[i][0],c+dir[i][1]);\\n        }\\n        return dp[key]=prob/8.0;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        return solve(n,k,row,column);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[8][8] = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    unordered_map<string,double> dp;\\n\\n    double solve(int n,int k,int r, int c){\\n        if(r<0  ||  r>=n  ||  c<0  ||  c>=n) return 0;\\n        if(k==0) return 1;\\n\\n        string key= to_string(k)+\"Leet\"+ to_string(r)+ \"Code\"+ to_string(c);\\n        if(dp.count(key)) return dp[key];\\n\\n        double prob=0;\\n        for(int i=0;i<8;i++){\\n            prob+= solve(n,k-1,r+dir[i][0],c+dir[i][1]);\\n        }\\n        return dp[key]=prob/8.0;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        return solve(n,k,row,column);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798785,
                "title": "c-memoisation-tabulation",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n* Since knight can move in 8 directions, so probability of taking 1 move to reach next {i,j} = 1/8 = 0.125\\n* Proabilties are multiplied along 1 path i.e for k consecutive moves & summed up to give total probability \\n\\n**Memoisation:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    double memo[26][26][101];\\n    int dxy[8][2]={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    \\n    double prob(int n, int k, int r, int c){\\n        if(memo[r][c][k]!=0) return memo[r][c][k];\\n        \\n        if(k==0) return 1; // probability of staying inside chess board after k moves\\n        \\n        double ans=0;\\n        for(int d=0;d<8;d++){\\n            int x=r+dxy[d][0], y=c+dxy[d][1];\\n            \\n            if(x>=0 && y>=0 && x<n && y<n) ans+=0.125*prob(n,k-1,x,y);\\n        }\\n        return memo[r][c][k]=ans;\\n    }\\n    \\n    double knightProbability(int n, int k, int r, int c) {\\n       return prob(n,k,r,c);\\n    }\\n};\\n```\\n\\n**Tabulation:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t int dxy[8][2]={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n\\t \\n    double knightProbability(int n, int k, int r, int c) { \\n        double dp[26][26][101];\\n        dp[r][c][0]=1; // probability of staying inside chess board initially\\n        \\n        for(int steps=1;steps<k+1;steps++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    for(int d=0;d<8;d++){\\n                        int x=i+dxy[d][0];\\n                        int y=j+dxy[d][1];\\n\\n                        if(x>=0 && y>=0 && x<n && y<n){\\n                            dp[i][j][steps]+=0.125*dp[x][y][steps-1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans+=dp[i][j][k];\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps :)**",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double memo[26][26][101];\\n    int dxy[8][2]={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    \\n    double prob(int n, int k, int r, int c){\\n        if(memo[r][c][k]!=0) return memo[r][c][k];\\n        \\n        if(k==0) return 1; // probability of staying inside chess board after k moves\\n        \\n        double ans=0;\\n        for(int d=0;d<8;d++){\\n            int x=r+dxy[d][0], y=c+dxy[d][1];\\n            \\n            if(x>=0 && y>=0 && x<n && y<n) ans+=0.125*prob(n,k-1,x,y);\\n        }\\n        return memo[r][c][k]=ans;\\n    }\\n    \\n    double knightProbability(int n, int k, int r, int c) {\\n       return prob(n,k,r,c);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n\\t int dxy[8][2]={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n\\t \\n    double knightProbability(int n, int k, int r, int c) { \\n        double dp[26][26][101];\\n        dp[r][c][0]=1; // probability of staying inside chess board initially\\n        \\n        for(int steps=1;steps<k+1;steps++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    for(int d=0;d<8;d++){\\n                        int x=i+dxy[d][0];\\n                        int y=j+dxy[d][1];\\n\\n                        if(x>=0 && y>=0 && x<n && y<n){\\n                            dp[i][j][steps]+=0.125*dp[x][y][steps-1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans+=dp[i][j][k];\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798783,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        @lru_cache(None)\\n        def dp(cur_r,cur_c,k):\\n            if k==0:\\n                return 1\\n\\n            else:\\n                ans=0\\n                for r,c in moves:\\n                    now_r=cur_r+r\\n                    now_c=cur_c+c\\n                    if 0<=now_r<=n-1 and 0<=now_c<=n-1:\\n                        ans+=dp(now_r,now_c,k-1)\\n\\n                return ans\\n\\n        if k==0:\\n            return 1\\n\\n        moves=[[1,2],[2,1],[1,-2],[2,-1],[-1,2],[-2,1],[-1,-2],[-2,-1]]\\n        return dp(row,column,k)/8**k            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        @lru_cache(None)\\n        def dp(cur_r,cur_c,k):\\n            if k==0:\\n                return 1\\n\\n            else:\\n                ans=0\\n                for r,c in moves:\\n                    now_r=cur_r+r\\n                    now_c=cur_c+c\\n                    if 0<=now_r<=n-1 and 0<=now_c<=n-1:\\n                        ans+=dp(now_r,now_c,k-1)\\n\\n                return ans\\n\\n        if k==0:\\n            return 1\\n\\n        moves=[[1,2],[2,1],[1,-2],[2,-1],[-1,2],[-2,1],[-1,-2],[-2,-1]]\\n        return dp(row,column,k)/8**k            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058148,
                "title": "easy-soln-well-explained-adobe",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n***#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 3 : Adobe\\nQ6. Knight in a Chessboard***\\n\\n### Complexity\\n- Time complexity: O(n^2*k)\\n- Space complexity: O(n^2k)\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int chessBoardSize, int moves, int currentRow, int currentCol){\\n        // Initialize 3D dp array to store the probability of knight being on a certain square after k moves\\n        vector<vector<vector<double>>> dp(moves + 1, vector<vector<double>> (chessBoardSize, vector<double>(chessBoardSize, -1)));\\n            // Call the helper function to solve the problem\\n    return solve(chessBoardSize, moves, currentRow, currentCol, dp);\\n}\\nprivate:\\n    double solve(int chessBoardSize, int moves, int currentRow, int currentCol, vector<vector<vector<double>>>& dp){\\n    // If the knight is out of the chess board, return 0\\n    if (currentRow < 0 || currentRow >= chessBoardSize || currentCol < 0 || currentCol >= chessBoardSize) return 0;\\n    // If the knight has made k moves, return 1 as it will be on the chess board\\n    if (moves == 0) return 1;\\n        // If the probability for this state is already calculated, return it\\n    if (dp[moves][currentRow][currentCol] != -1)\\n        return dp[moves][currentRow][currentCol];\\n    \\n    // Total probability is the sum of probabilities of all 8 possible moves from the current square\\n    double total = solve(chessBoardSize, moves - 1, currentRow - 2, currentCol + 1, dp) + solve(chessBoardSize, moves - 1, currentRow - 1, currentCol + 2, dp)\\n                + solve(chessBoardSize, moves - 1, currentRow + 1, currentCol + 2, dp) + solve(chessBoardSize, moves - 1, currentRow + 2, currentCol + 1, dp)\\n                + solve(chessBoardSize, moves - 1, currentRow + 2, currentCol - 1, dp) + solve(chessBoardSize, moves - 1, currentRow + 1, currentCol - 2, dp)\\n                + solve(chessBoardSize, moves - 1, currentRow - 1, currentCol - 2, dp) + solve(chessBoardSize, moves - 1, currentRow - 2, currentCol - 1, dp);\\n        \\n    total = total / 8;\\n    return dp[moves][currentRow][currentCol] = total;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int chessBoardSize, int moves, int currentRow, int currentCol){\\n        // Initialize 3D dp array to store the probability of knight being on a certain square after k moves\\n        vector<vector<vector<double>>> dp(moves + 1, vector<vector<double>> (chessBoardSize, vector<double>(chessBoardSize, -1)));\\n            // Call the helper function to solve the problem\\n    return solve(chessBoardSize, moves, currentRow, currentCol, dp);\\n}\\nprivate:\\n    double solve(int chessBoardSize, int moves, int currentRow, int currentCol, vector<vector<vector<double>>>& dp){\\n    // If the knight is out of the chess board, return 0\\n    if (currentRow < 0 || currentRow >= chessBoardSize || currentCol < 0 || currentCol >= chessBoardSize) return 0;\\n    // If the knight has made k moves, return 1 as it will be on the chess board\\n    if (moves == 0) return 1;\\n        // If the probability for this state is already calculated, return it\\n    if (dp[moves][currentRow][currentCol] != -1)\\n        return dp[moves][currentRow][currentCol];\\n    \\n    // Total probability is the sum of probabilities of all 8 possible moves from the current square\\n    double total = solve(chessBoardSize, moves - 1, currentRow - 2, currentCol + 1, dp) + solve(chessBoardSize, moves - 1, currentRow - 1, currentCol + 2, dp)\\n                + solve(chessBoardSize, moves - 1, currentRow + 1, currentCol + 2, dp) + solve(chessBoardSize, moves - 1, currentRow + 2, currentCol + 1, dp)\\n                + solve(chessBoardSize, moves - 1, currentRow + 2, currentCol - 1, dp) + solve(chessBoardSize, moves - 1, currentRow + 1, currentCol - 2, dp)\\n                + solve(chessBoardSize, moves - 1, currentRow - 1, currentCol - 2, dp) + solve(chessBoardSize, moves - 1, currentRow - 2, currentCol - 1, dp);\\n        \\n    total = total / 8;\\n    return dp[moves][currentRow][currentCol] = total;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863865,
                "title": "recursion-and-dp-does-the-job",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef fun(n,k,i,j,memo):\\n    if(i<0 or i>=n or j<0 or j>=n):\\n        return 0\\n    if(k==0):\\n        return 1\\n    if((i,j,k) in memo):\\n        return(memo[(i,j,k)])\\n    a=0\\n    a+=fun(n,k-1,i+2,j+1,memo)\\n    a+=fun(n,k-1,i+2,j-1,memo)\\n    a+=fun(n,k-1,i-2,j+1,memo)\\n    a+=fun(n,k-1,i-2,j-1,memo)\\n    a+=fun(n,k-1,i+1,j+2,memo)\\n    a+=fun(n,k-1,i+1,j-2,memo)\\n    a+=fun(n,k-1,i-1,j+2,memo)\\n    a+=fun(n,k-1,i-1,j-2,memo)\\n    memo[(i,j,k)]=a\\n    return a\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        p=[0]\\n        ng=[0]\\n        x=fun(n,k,column,row,{})\\n        return x/(8**k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fun(n,k,i,j,memo):\\n    if(i<0 or i>=n or j<0 or j>=n):\\n        return 0\\n    if(k==0):\\n        return 1\\n    if((i,j,k) in memo):\\n        return(memo[(i,j,k)])\\n    a=0\\n    a+=fun(n,k-1,i+2,j+1,memo)\\n    a+=fun(n,k-1,i+2,j-1,memo)\\n    a+=fun(n,k-1,i-2,j+1,memo)\\n    a+=fun(n,k-1,i-2,j-1,memo)\\n    a+=fun(n,k-1,i+1,j+2,memo)\\n    a+=fun(n,k-1,i+1,j-2,memo)\\n    a+=fun(n,k-1,i-1,j+2,memo)\\n    a+=fun(n,k-1,i-1,j-2,memo)\\n    memo[(i,j,k)]=a\\n    return a\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        p=[0]\\n        ng=[0]\\n        x=fun(n,k,column,row,{})\\n        return x/(8**k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785215,
                "title": "detailed-thoughts-of-my-final-recursion-memorization-solution",
                "content": "Before I start solving the problem, I noticed that the problem is asking about the probability that the knight remains on the board after it has stopped moving. In other word, the problem is a \"all solution\" problem, where we need to figure out all possible states after K moves. For any all solution problems, all fancy techniques such as dynamic programming, greedy... are all optimazation of brute force solution. Therefore, we can try to generate a brute force solution and try to apply some optimizations on it.\\n\\nWe can defines the problems to be:\\nprobability that the knight remains on the board after it has stopped moving (either out of board or after k moves)\\n\\nfrom the definition, the base case of the problem is clear:\\n\\t1. The knight is out of board. (r and c of knight is not valid.) For this case, the probability of staying in the board is 0.0.\\n\\t2. The knight has already moved k step. For this case, the probability of staying in the board is 1.0.\\n\\nA knight can move 8 different ways in a certain point at the board. Therefore, any result that move 1 step from the current point will contribute 1/8 to the final probability.\\n\\nTherefore, a recursion solution is generated: \\n\\n```\\nclass Solution {\\n    private int[][] nexts = new int[][]{{1, 2}, {2, 1}, {1, -2}, {-2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if (r >= N || r < 0 || c >= N || c < 0) {\\n            return 0.0;\\n        } else if (K == 0) {\\n            return 1.0;\\n        } // two different base case\\n        double result = 0.0;\\n        for (int[] next : nexts) {\\n            result += 0.125 * knightProbability(N, K - 1, r + next[0], c + next[1]); // each prob of result of next move contributes 1/8 to total result\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nOf course, the solutions get TLE, since there are a lot of repeated computation. We expected that the knight will lands to a certain points for multiple of time with exactly k move left. For each time we need to calcutate sub problems again and again.\\n\\nTherefore, we can introduce a memorization to record down those repeated result and reduce our final running time.\\n\\nlet dp[r][c][k] represent the probability of the knight staying on board when the knight is currently at (r, c) with k remaining moves. Finally, a recursion + memorization solution is generated.\\n\\n```\\nclass Solution {\\n    private int[][] nexts = new int[][]{{1, 2}, {2, 1}, {1, -2}, {-2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][][] dp = new double[N][N][K + 1];\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                Arrays.fill(dp[i][j], -1.0);\\n            }\\n        }\\n        return dfs(N, K, r, c, dp);\\n    }\\n    \\n    private double dfs(int N, int K, int r, int c, double[][][] dp) {\\n        if (r >= N || r < 0 || c >= N || c < 0) {\\n            return 0.0;\\n        } else if (K == 0) {\\n            return 1.0;\\n        } else if (dp[r][c][K] >= 0.0) {\\n            return dp[r][c][K];\\n        }\\n        double result = 0.0;\\n        for (int[] next : nexts) {\\n            result += 0.125 * dfs(N, K - 1, r + next[0], c + next[1], dp);\\n        }\\n        dp[r][c][K] = result;\\n        return result;\\n    }\\n}\\n```\\nTime complexity:\\nSince there are at most k levels of recursion, and in each level there are 8 branches, final time complexity will be O(8^k);\\nSpace complexity:\\nSince I am using a 3D dp matrix, space complexity will be O(KN^2).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] nexts = new int[][]{{1, 2}, {2, 1}, {1, -2}, {-2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if (r >= N || r < 0 || c >= N || c < 0) {\\n            return 0.0;\\n        } else if (K == 0) {\\n            return 1.0;\\n        } // two different base case\\n        double result = 0.0;\\n        for (int[] next : nexts) {\\n            result += 0.125 * knightProbability(N, K - 1, r + next[0], c + next[1]); // each prob of result of next move contributes 1/8 to total result\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[][] nexts = new int[][]{{1, 2}, {2, 1}, {1, -2}, {-2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][][] dp = new double[N][N][K + 1];\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                Arrays.fill(dp[i][j], -1.0);\\n            }\\n        }\\n        return dfs(N, K, r, c, dp);\\n    }\\n    \\n    private double dfs(int N, int K, int r, int c, double[][][] dp) {\\n        if (r >= N || r < 0 || c >= N || c < 0) {\\n            return 0.0;\\n        } else if (K == 0) {\\n            return 1.0;\\n        } else if (dp[r][c][K] >= 0.0) {\\n            return dp[r][c][K];\\n        }\\n        double result = 0.0;\\n        for (int[] next : nexts) {\\n            result += 0.125 * dfs(N, K - 1, r + next[0], c + next[1], dp);\\n        }\\n        dp[r][c][K] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415912,
                "title": "clean-javascript-backtracking-and-dynamic-programming-solutions",
                "content": "**Dynamic Programming**\\n\\n```\\nconst knightProbability = (N, K, r, c) => {\\n  const dirs = [[-2, -1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1]];\\n  const dp = [...Array(K + 1)].map(() => [...Array(N)].map(() => Array(N).fill(0)));\\n  dp[0][r][c] = 1;\\n  for (let k = 1; k <= K; k++) {\\n    for (let i = 0; i < N; i++) {\\n      for (let j = 0; j < N; j++) {\\n        for (const [dx, dy] of dirs) {\\n          const x = i + dx;\\n          const y = j + dy;\\n          if (x >= 0 && x < N && y >= 0 && y < N) {\\n            dp[k][i][j] += dp[k - 1][x][y] / 8;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  let res = 0;\\n  for (let i = 0; i < N; i++) {\\n    for (let j = 0; j < N; j++) {\\n      res += dp[K][i][j];\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n**Backtracking**\\n\\n```\\nconst knightProbability = (N, K, r, c) => {\\n  const dirs = [[-2, -1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1]];\\n\\n  const dp = [...Array(K + 1)].map(() => [...Array(N)].map(() => Array(N).fill(0)));\\n  dp[0][r][c] = 1;\\n\\n  for (let k = 1; k <= K; k++) {\\n    for (let i = 0; i < N; i++) {\\n      for (let j = 0; j < N; j++) {\\n        for (const [dx, dy] of dirs) {\\n          const x = i + dx;\\n          const y = j + dy;\\n          if (x >= 0 && x < N && y >= 0 && y < N) {\\n            dp[k][i][j] += dp[k - 1][x][y] / 8;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  let res = 0;\\n  for (let i = 0; i < N; i++) {\\n    for (let j = 0; j < N; j++) {\\n      res += dp[K][i][j];\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nconst knightProbability = (N, K, r, c) => {\\n  const dirs = [[-2, -1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1]];\\n  const dp = [...Array(K + 1)].map(() => [...Array(N)].map(() => Array(N).fill(0)));\\n  dp[0][r][c] = 1;\\n  for (let k = 1; k <= K; k++) {\\n    for (let i = 0; i < N; i++) {\\n      for (let j = 0; j < N; j++) {\\n        for (const [dx, dy] of dirs) {\\n          const x = i + dx;\\n          const y = j + dy;\\n          if (x >= 0 && x < N && y >= 0 && y < N) {\\n            dp[k][i][j] += dp[k - 1][x][y] / 8;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  let res = 0;\\n  for (let i = 0; i < N; i++) {\\n    for (let j = 0; j < N; j++) {\\n      res += dp[K][i][j];\\n    }\\n  }\\n  return res;\\n};\\n```\n```\\nconst knightProbability = (N, K, r, c) => {\\n  const dirs = [[-2, -1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1]];\\n\\n  const dp = [...Array(K + 1)].map(() => [...Array(N)].map(() => Array(N).fill(0)));\\n  dp[0][r][c] = 1;\\n\\n  for (let k = 1; k <= K; k++) {\\n    for (let i = 0; i < N; i++) {\\n      for (let j = 0; j < N; j++) {\\n        for (const [dx, dy] of dirs) {\\n          const x = i + dx;\\n          const y = j + dy;\\n          if (x >= 0 && x < N && y >= 0 && y < N) {\\n            dp[k][i][j] += dp[k - 1][x][y] / 8;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  let res = 0;\\n  for (let i = 0; i < N; i++) {\\n    for (let j = 0; j < N; j++) {\\n      res += dp[K][i][j];\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353792,
                "title": "beats-84-c",
                "content": "class Solution {\\npublic:\\n    \\n   double DP[25][25][101] = {0};\\n   int row[8] = {1,1,-1,-1,2,2,-2,-2};\\n   int col[8] = {2,-2,2,-2,1,-1,1,-1};\\n    \\n    double knightProbability(int N, int K, int r, int c) {\\n        \\n    \\n        if(r<0 || r>=N || c<0 || c>=N)\\n            return 0;\\n        \\n        \\n        if(K==0)\\n            return 1.0;\\n        \\n        if(N<=2)\\n            return 0;\\n        \\n        if(DP[r][c][K])\\n            return DP[r][c][K];\\n            \\n        double ans = 0;    \\n        for(int i=0;i<8;i++)\\n            ans += knightProbability(N,K-1,r+row[i],c+col[i]);\\n        \\n        return DP[r][c][K] = ans/8.0;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n   double DP[25][25][101] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 352143,
                "title": "bfs-solution-with-memorization",
                "content": "The idea is to find the positions where knights will end up after `K` and then how many duplicate it contains.\\nFor instance,\\nN = 3\\nK = 3\\nr = 0\\nc = 0\\nIn the first move, there are two places to go\\n(2, 1), (1, 2) now `map` should be 1s on (2, 1) and (1, 2) since this can be visited once.\\nIn the second move, since (2,1) and (1, 2) can visit (0, 0). `map` at (0, 0) will be 2 and (2, 0) = 1, (0, 2) = 1. Rest of them should be 0.\\nIn the third move, there are (0, 0), (2, 0), (0, 2) in the queue. We know that any move from (0, 0), it adds up 2 instead of 1 because we had duplicate move.\\nNow `map` (2,1) =3 (from (0, 0), (0, 2)), (1, 2) =3 (from (0, 0), (2, 0)), (0,1) = 1, (1, 0) = 1 and rest of array is 0. \\n\\nNote: This is not so fast.\\n```\\nclass Solution {\\n    private final int[][] deltas = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1}, {1, -2}, {1, 2}, {-1, 2}, {-1, -2}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r, c});\\n        double[][] map = new double[N][N];\\n        for (int i = 0; i < N; ++i) {\\n            Arrays.fill(map[i], 1);\\n        }\\n        for (int i = 0; i < K; ++i) {\\n            int size = queue.size();\\n            double[][] tmp = new double[N][N];\\n            for (int j = 0; j < size; ++j) {\\n                int[] move = queue.remove();\\n                for (int[] delta: deltas) {\\n                    int nr = move[0] + delta[0];\\n                    int nc = move[1] + delta[1];\\n                    if (isValid(N, nr, nc)) {\\n                        if (tmp[nr][nc] == 0) {\\n                            queue.add(new int[]{nr, nc});\\n                        }\\n                        tmp[nr][nc] += map[move[0]][move[1]];\\n\\n                    }\\n                }\\n            }\\n            map = tmp;\\n        }\\n        double totalMoves = Math.pow(8, K);\\n        double validMoves = 0;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                validMoves += map[i][j];\\n            }\\n        }\\n        double ret = validMoves / totalMoves;\\n        return ret > 1.0 ? 1.0 : ret;\\n    }\\n    \\n    private boolean isValid(int N, int r, int c) {\\n        return r >= 0 && r < N && c >= 0 && c < N;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final int[][] deltas = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1}, {1, -2}, {1, 2}, {-1, 2}, {-1, -2}};\\n    public double knightProbability(int N, int K, int r, int c) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r, c});\\n        double[][] map = new double[N][N];\\n        for (int i = 0; i < N; ++i) {\\n            Arrays.fill(map[i], 1);\\n        }\\n        for (int i = 0; i < K; ++i) {\\n            int size = queue.size();\\n            double[][] tmp = new double[N][N];\\n            for (int j = 0; j < size; ++j) {\\n                int[] move = queue.remove();\\n                for (int[] delta: deltas) {\\n                    int nr = move[0] + delta[0];\\n                    int nc = move[1] + delta[1];\\n                    if (isValid(N, nr, nc)) {\\n                        if (tmp[nr][nc] == 0) {\\n                            queue.add(new int[]{nr, nc});\\n                        }\\n                        tmp[nr][nc] += map[move[0]][move[1]];\\n\\n                    }\\n                }\\n            }\\n            map = tmp;\\n        }\\n        double totalMoves = Math.pow(8, K);\\n        double validMoves = 0;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                validMoves += map[i][j];\\n            }\\n        }\\n        double ret = validMoves / totalMoves;\\n        return ret > 1.0 ? 1.0 : ret;\\n    }\\n    \\n    private boolean isValid(int N, int r, int c) {\\n        return r >= 0 && r < N && c >= 0 && c < N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207134,
                "title": "java-dfs-memo",
                "content": "```\\nclass Solution {\\n    static int[][] dirs = {{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n\\n    public double knightProbability(int N, int K, int r, int c) { \\n        return dfs(K,r,c,N,new HashMap<>());\\n    }\\n    \\n    double dfs(int K, int i, int j, int N, Map<String,Double> dp){\\n\\n        if(i < 0 || j < 0 || i >= N || j >= N)\\n            return 0.0;\\n        if(K == 0)\\n            return 1.0;\\n        double result = 0.0;\\n        String position = i + \",\" + j +  \",\" + K;\\n        if(dp.get(position) != null)\\n            return dp.get(position);\\n        for(int[] dir : dirs)\\n            result += dfs(K-1, i+dir[0], j+dir[1], N, dp);\\n        \\n        dp.put(position,result * 0.125);\\n        return dp.get(position);\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int[][] dirs = {{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n\\n    public double knightProbability(int N, int K, int r, int c) { \\n        return dfs(K,r,c,N,new HashMap<>());\\n    }\\n    \\n    double dfs(int K, int i, int j, int N, Map<String,Double> dp){\\n\\n        if(i < 0 || j < 0 || i >= N || j >= N)\\n            return 0.0;\\n        if(K == 0)\\n            return 1.0;\\n        double result = 0.0;\\n        String position = i + \",\" + j +  \",\" + K;\\n        if(dp.get(position) != null)\\n            return dp.get(position);\\n        for(int[] dir : dirs)\\n            result += dfs(K-1, i+dir[0], j+dir[1], N, dp);\\n        \\n        dp.put(position,result * 0.125);\\n        return dp.get(position);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800762,
                "title": "very-easy-100-fully-explained-java-c",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves...\\n        double[][][] dp = new double[k + 1][n][n];\\n        // At first, initialize dp[0][row][column] to 1.0, as the knight starts at the specified cell.\\n        dp[0][row][column] = 1.0;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int i = 1; i <= k; i++) {\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int[] d : dir) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + d[0];\\n                        int newCol = c + d[1];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // Initialize the output probability...\\n        double output = 0.0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[k][r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp represents the probability of the knight being at cell (r, c) after m moves...\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        vector<int> dr = {-2, -2, -1, -1, 1, 1, 2, 2};\\n        vector<int> dc = {-1, 1, -2, 2, -2, 2, -1, 1};\\n        // At first, initialize dp[0][row][column] to 1, as the knight starts at the specified cell.\\n        dp[row][column] = 1;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int m = 0; m < k; m++) {\\n            vector<vector<double>> tmp(n, vector<double>(n, 0));\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int i = 0; i < 8; i++) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + dr[i];\\n                        int newCol = c + dc[i];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            tmp[newRow][newCol] += dp[r][c] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        // Initialize the output probability...\\n        double output = 0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves...\\n        double[][][] dp = new double[k + 1][n][n];\\n        // At first, initialize dp[0][row][column] to 1.0, as the knight starts at the specified cell.\\n        dp[0][row][column] = 1.0;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int i = 1; i <= k; i++) {\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int[] d : dir) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + d[0];\\n                        int newCol = c + d[1];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // Initialize the output probability...\\n        double output = 0.0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[k][r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp represents the probability of the knight being at cell (r, c) after m moves...\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        vector<int> dr = {-2, -2, -1, -1, 1, 1, 2, 2};\\n        vector<int> dc = {-1, 1, -2, 2, -2, 2, -1, 1};\\n        // At first, initialize dp[0][row][column] to 1, as the knight starts at the specified cell.\\n        dp[row][column] = 1;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int m = 0; m < k; m++) {\\n            vector<vector<double>> tmp(n, vector<double>(n, 0));\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int i = 0; i < 8; i++) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + dr[i];\\n                        int newCol = c + dc[i];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            tmp[newRow][newCol] += dp[r][c] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        // Initialize the output probability...\\n        double output = 0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800434,
                "title": "c-easy-explained-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Recursion & then memoization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every move probability becomes 1/8th. So go in all possible 8 directions and add in ans. And to memoize it, you can simply use a 3-d array or a hasmap with string as key and double as value (with the separators). If probability has already been calculated, simply return.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n*k*8)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n*k)$$\\n# Code\\n```\\nclass Solution {\\n  public: unordered_map < string, double > mp;\\n  int dir[8][8] = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n\\n  double knightProbability(int n, int k, int row, int column) {\\n    return solve(n, k, row, column);\\n  }\\n\\n  double solve(int n, int moves, int r, int c) {\\n    if (r < 0 || r >= n || c < 0 || c >= n) return 0;\\n    if (moves == 0) return 1;\\n    string key = to_string(r) + \"a\" + to_string(c) + \"k\" + to_string(moves);\\n    if (mp.find(key) != mp.end()) return mp[key];\\n    double ans = 0;\\n    for (int i = 0; i < 8; i++)\\n      ans += solve(n, moves - 1, r + dir[i][0], c + dir[i][1]) / 8.0;\\n    mp[key] = ans;\\n    return mp[key];\\n  }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public: unordered_map < string, double > mp;\\n  int dir[8][8] = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n\\n  double knightProbability(int n, int k, int row, int column) {\\n    return solve(n, k, row, column);\\n  }\\n\\n  double solve(int n, int moves, int r, int c) {\\n    if (r < 0 || r >= n || c < 0 || c >= n) return 0;\\n    if (moves == 0) return 1;\\n    string key = to_string(r) + \"a\" + to_string(c) + \"k\" + to_string(moves);\\n    if (mp.find(key) != mp.end()) return mp[key];\\n    double ans = 0;\\n    for (int i = 0; i < 8; i++)\\n      ans += solve(n, moves - 1, r + dir[i][0], c + dir[i][1]) / 8.0;\\n    mp[key] = ans;\\n    return mp[key];\\n  }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799851,
                "title": "easy-python-solution-using-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def dp(self,x,y,n,visited,k):\\n        if k<0:\\n            return 1\\n        if (x<0 or x>=n) or (y<0 or y>=n):\\n            return 0\\n        if (x,y,k) in visited:\\n            return visited[(x,y,k)]\\n        a=self.dp(x+2,y+1,n,visited,k-1)*1/8\\n        b=self.dp(x+2,y-1,n,visited,k-1)*1/8\\n        c=self.dp(x-2,y+1,n,visited,k-1)*1/8\\n        d=self.dp(x-2,y-1,n,visited,k-1)*1/8\\n        e=self.dp(x+1,y+2,n,visited,k-1)*1/8\\n        f=self.dp(x+1,y-2,n,visited,k-1)*1/8\\n        g=self.dp(x-1,y+2,n,visited,k-1)*1/8\\n        h=self.dp(x-1,y-2,n,visited,k-1)*1/8\\n        visited[(x,y,k)]=a+b+c+d+e+f+g+h\\n        return a+b+c+d+e+f+g+h\\n        \\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        return self.dp(row,column,n,{},k)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self,x,y,n,visited,k):\\n        if k<0:\\n            return 1\\n        if (x<0 or x>=n) or (y<0 or y>=n):\\n            return 0\\n        if (x,y,k) in visited:\\n            return visited[(x,y,k)]\\n        a=self.dp(x+2,y+1,n,visited,k-1)*1/8\\n        b=self.dp(x+2,y-1,n,visited,k-1)*1/8\\n        c=self.dp(x-2,y+1,n,visited,k-1)*1/8\\n        d=self.dp(x-2,y-1,n,visited,k-1)*1/8\\n        e=self.dp(x+1,y+2,n,visited,k-1)*1/8\\n        f=self.dp(x+1,y-2,n,visited,k-1)*1/8\\n        g=self.dp(x-1,y+2,n,visited,k-1)*1/8\\n        h=self.dp(x-1,y-2,n,visited,k-1)*1/8\\n        visited[(x,y,k)]=a+b+c+d+e+f+g+h\\n        return a+b+c+d+e+f+g+h\\n        \\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        return self.dp(row,column,n,{},k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799232,
                "title": "simplest-code-recursion-to-memoization-beginner-friendly-code-and-intuition-c",
                "content": "# Recursion\\n```\\nclass Solution {\\npublic:\\n\\nint dx[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\nint dy[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\ndouble dfs(int i,int j,int k, int n){\\n    if(i < 0 || j < 0 ||i >= n || j >= n) return 0;\\n    if(k == 0) return 1;\\n\\n    double temp = 0;\\n\\n    for(int l = 0;l < 8; l++){\\n      int x = i + dx[l];\\n      int y = j + dy[l];\\n      temp += dfs(x,y,k-1,n);\\n    }\\n    return (temp/8.0);\\n}\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        return dfs(row,column,k,n); \\n    }\\n};\\n```\\n\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n\\ndouble dp[30][30][105];\\nint dx[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\nint dy[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\ndouble dfs(int i,int j,int k, int n){\\n    if(i < 0 || j < 0 ||i >= n || j >= n) return 0;\\n    if(k == 0) return 1;\\n    if(dp[i][j][k] != 0) return dp[i][j][k];\\n\\n    double temp = 0;\\n\\n    for(int l = 0;l < 8; l++){\\n      int x = i + dx[l];\\n      int y = j + dy[l];\\n      temp += dfs(x,y,k-1,n);\\n    }\\n    return dp[i][j][k] += (temp/8.0);\\n}\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        memset(dp,0,sizeof(dp));\\n        return dfs(row,column,k,n); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dx[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\nint dy[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\ndouble dfs(int i,int j,int k, int n){\\n    if(i < 0 || j < 0 ||i >= n || j >= n) return 0;\\n    if(k == 0) return 1;\\n\\n    double temp = 0;\\n\\n    for(int l = 0;l < 8; l++){\\n      int x = i + dx[l];\\n      int y = j + dy[l];\\n      temp += dfs(x,y,k-1,n);\\n    }\\n    return (temp/8.0);\\n}\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        return dfs(row,column,k,n); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\ndouble dp[30][30][105];\\nint dx[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\nint dy[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\ndouble dfs(int i,int j,int k, int n){\\n    if(i < 0 || j < 0 ||i >= n || j >= n) return 0;\\n    if(k == 0) return 1;\\n    if(dp[i][j][k] != 0) return dp[i][j][k];\\n\\n    double temp = 0;\\n\\n    for(int l = 0;l < 8; l++){\\n      int x = i + dx[l];\\n      int y = j + dy[l];\\n      temp += dfs(x,y,k-1,n);\\n    }\\n    return dp[i][j][k] += (temp/8.0);\\n}\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        memset(dp,0,sizeof(dp));\\n        return dfs(row,column,k,n); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799129,
                "title": "basic-and-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do what mentioned in the question. Traverse all the the possiblites and calculate the probability.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Base Cases:**\\n\\n- if (i < 0 || i >= n || j < 0 || j >= n): This condition checks if the current position (i, j) is outside the chessboard. If the knight is outside the board, it returns probability 0 since the knight falls off the board.\\n- if (k == 0) return 1;: This condition checks if the number of moves (k) has reached 0. If so, it means the knight has completed all moves and remains on the board, so it returns probability 1.\\n\\n**Move Calculation:**\\n\\n- The function uses two arrays arr1 and arr2 to represent the relative positions of the knight\\'s moves (using row and column offsets). Each array contains eight elements, representing the eight possible moves a knight can make on a chessboard.\\n- It iterates over all eight possible moves of the knight and recursively calls itself (probab) with the updated position (adji, adjy) and k decremented by 1.\\n- It multiplies the recursive result by 0.125 (1/8) since each move has an equal probability of happening.\\n- It accumulates the results from all eight moves in the ans variable.\\n\\n\\n**The function returns the computed probability ans for the current position (i, j) after making k moves.**\\n****\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double dp[26][26][101];\\n    double probab(int n,int k,int i,int j){\\n        if(i<0 || i>=n || j<0 || j>=n){\\n            return 0;\\n        }\\n        if(k==0)return 1;\\n        if(dp[i][j][k]>-0.9)return dp[i][j][k];\\n        int arr1[]={-2,-1,1,2,2,1,-1,-2};\\n        int arr2[]={-1,-2,-2,-1,1,2,2,1};\\n        double ans=0;\\n        for(int t=0;t<8;t++){\\n            int adji=i+arr1[t];\\n            int adjy=j+arr2[t];\\n            ans+=probab(n,k-1,adji,adjy)*0.125;\\n        }\\n        return dp[i][j][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        memset(dp,-1,sizeof(dp));\\n        return probab(n,k,row,column);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[26][26][101];\\n    double probab(int n,int k,int i,int j){\\n        if(i<0 || i>=n || j<0 || j>=n){\\n            return 0;\\n        }\\n        if(k==0)return 1;\\n        if(dp[i][j][k]>-0.9)return dp[i][j][k];\\n        int arr1[]={-2,-1,1,2,2,1,-1,-2};\\n        int arr2[]={-1,-2,-2,-1,1,2,2,1};\\n        double ans=0;\\n        for(int t=0;t<8;t++){\\n            int adji=i+arr1[t];\\n            int adjy=j+arr2[t];\\n            ans+=probab(n,k-1,adji,adjy)*0.125;\\n        }\\n        return dp[i][j][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        memset(dp,-1,sizeof(dp));\\n        return probab(n,k,row,column);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798902,
                "title": "video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7HaNCeT0nOw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n```\\npublic class Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{1,2},{-1,2},{1,-2},{-1,-2},{2,1},{-2,1},{2,-1},{-2,-1}};\\n\\n        double[][][] dp = new double[k + 1][n][n];\\n        dp[0][row][column] = 1.0;\\n        int prevI;\\n        int prevJ;\\n        for (int m = 1; m <= k; m++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) { \\n                    for (int[] d : dir) {\\n                        prevI = i - d[0];\\n                        prevJ = j - d[1];\\n                        if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\\n                            dp[m][i][j] += dp[m - 1][prevI][prevJ] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        double ans = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans += dp[k][i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<int>> dir = {{1, 2}, {-1, 2}, {1, -2}, {-1, -2}, {2, 1}, {-2, 1}, {2, -1}, {-2, -1}};\\n\\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n, 0.0)));\\n        dp[0][row][column] = 1.0;\\n\\n        int prevI, prevJ;\\n        for (int m = 1; m <= k; m++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    for (const auto& d : dir) {\\n                        prevI = i - d[0];\\n                        prevJ = j - d[1];\\n                        if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\\n                            dp[m][i][j] += dp[m - 1][prevI][prevJ] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        double ans = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans += dp[k][i][j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        dir = [[1, 2], [-1, 2], [1, -2], [-1, -2], [2, 1], [-2, 1], [2, -1], [-2, -1]]\\n\\n        dp = [[[0.0] * n for _ in range(n)] for _ in range(k + 1)]\\n        dp[0][row][column] = 1.0\\n\\n        for m in range(1, k + 1):\\n            for i in range(n):\\n                for j in range(n):\\n                    for d in dir:\\n                        prevI, prevJ = i - d[0], j - d[1]\\n                        if 0 <= prevI < n and 0 <= prevJ < n:\\n                            dp[m][i][j] += dp[m - 1][prevI][prevJ] / 8.0\\n\\n        ans = sum(dp[k][i][j] for i in range(n) for j in range(n))\\n        return ans\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{1,2},{-1,2},{1,-2},{-1,-2},{2,1},{-2,1},{2,-1},{-2,-1}};\\n\\n        double[][][] dp = new double[k + 1][n][n];\\n        dp[0][row][column] = 1.0;\\n        int prevI;\\n        int prevJ;\\n        for (int m = 1; m <= k; m++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) { \\n                    for (int[] d : dir) {\\n                        prevI = i - d[0];\\n                        prevJ = j - d[1];\\n                        if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\\n                            dp[m][i][j] += dp[m - 1][prevI][prevJ] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        double ans = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans += dp[k][i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<int>> dir = {{1, 2}, {-1, 2}, {1, -2}, {-1, -2}, {2, 1}, {-2, 1}, {2, -1}, {-2, -1}};\\n\\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n, 0.0)));\\n        dp[0][row][column] = 1.0;\\n\\n        int prevI, prevJ;\\n        for (int m = 1; m <= k; m++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    for (const auto& d : dir) {\\n                        prevI = i - d[0];\\n                        prevJ = j - d[1];\\n                        if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\\n                            dp[m][i][j] += dp[m - 1][prevI][prevJ] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        double ans = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans += dp[k][i][j];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        dir = [[1, 2], [-1, 2], [1, -2], [-1, -2], [2, 1], [-2, 1], [2, -1], [-2, -1]]\\n\\n        dp = [[[0.0] * n for _ in range(n)] for _ in range(k + 1)]\\n        dp[0][row][column] = 1.0\\n\\n        for m in range(1, k + 1):\\n            for i in range(n):\\n                for j in range(n):\\n                    for d in dir:\\n                        prevI, prevJ = i - d[0], j - d[1]\\n                        if 0 <= prevI < n and 0 <= prevJ < n:\\n                            dp[m][i][j] += dp[m - 1][prevI][prevJ] / 8.0\\n\\n        ans = sum(dp[k][i][j] for i in range(n) for j in range(n))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782626,
                "title": "dp-dfs-easy-to-understand-c",
                "content": "## Please upvote if you like the solution\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> dir = {{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    map<vector<int>,double> mp;\\n\\n    double f(int r, int c, int k, int n){\\n        double ans = 0;\\n        if(k == 0) return 1.0;  // as there are no more steps to take, it\\'s a successful path\\n        vector<int> dp = {r, c, k}; \\n        if(mp.find(dp) != mp.end()) return mp[dp];\\n\\n        for(int i = 0;i < 8;i++){\\n            int nx = r + dir[i][0], ny = c + dir[i][1];\\n            if(nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\\n            ans += f(nx, ny, k-1, n) / 8.0;  // probability of each step as there are 8 possible steps\\n        } \\n        return mp[dp] = ans;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int r, int c) {\\n        return f(r, c, k, n); // no need to divide by total paths as we are calculating the probability in the function f itself\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dir = {{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    map<vector<int>,double> mp;\\n\\n    double f(int r, int c, int k, int n){\\n        double ans = 0;\\n        if(k == 0) return 1.0;  // as there are no more steps to take, it\\'s a successful path\\n        vector<int> dp = {r, c, k}; \\n        if(mp.find(dp) != mp.end()) return mp[dp];\\n\\n        for(int i = 0;i < 8;i++){\\n            int nx = r + dir[i][0], ny = c + dir[i][1];\\n            if(nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\\n            ans += f(nx, ny, k-1, n) / 8.0;  // probability of each step as there are 8 possible steps\\n        } \\n        return mp[dp] = ans;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int r, int c) {\\n        return f(r, c, k, n); // no need to divide by total paths as we are calculating the probability in the function f itself\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313692,
                "title": "c-memoized-with-all-kindness",
                "content": "```\\n\\n\\n\\n\\n  Trying since 4 hours but didn\\'t get the expected output will definitely post the first (Commented ) approach soon   for now its upto memoization working on direction array  \\n  \\n  \\n  \\n\\n\\nclass Solution {\\npublic:\\n    \\n//     bool isValid(int ni,int nj,int n){\\n//         if(ni>=0 && nj>=0 &&ni<n&&nj<n){\\n//             return true;\\n//         }\\n//         else{\\n//             return false;\\n//         }\\n//     }\\n//     double knightProbability(int N, int K, int r, int c) {\\n     \\n//         if(K==0) return 1.0;\\n        \\n//         // parent chess board\\n//         vector<vector<double>> parentBoard(N,vector<double>(N,0.0));\\n        \\n//         // child chess board\\n//         vector<vector<double>> childBoard(N,vector<double>(N,0.0));\\n        \\n//         // row and col offset for generating next move or child positions\\n//         // int rowoffset[] = {-2,-2,-1,-1,2,2,1,1};\\n//         // int coloffset[] = {1,-1,2,-2,1,-1,2,-2};\\n        \\n        \\n        \\n//         // initial position probability 1\\n//         parentBoard[r][c] = 1.0;\\n        \\n//         // Run K steps\\n//         // Each step update the child position probability from parent position \\n//         // After each step assign child as parent board and create new child board\\n//         for(int m=1;m<=K;m++)\\n//         {\\n//             for(int i=0;i<N;i++)\\n//             {\\n//                 for(int j=0;j<N;j++)\\n//                 { \\n//                                         if(parentBoard[i][j]!=0){\\n//                    int ni=i-2;\\n//                    int nj=j+1;\\n//         if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n                    \\n//                       ni=i-1;\\n//                    nj=j+2;\\n//                     if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n                    \\n//                      ni=i+1;\\n//                    nj=j+2;\\n                    \\n//                      if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n                    \\n                    \\n//                      ni=i+2;\\n//                    nj=j-1;\\n                    \\n//                      if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n//                       ni=i-2;\\n//                     nj=j-1;\\n                    \\n//                      if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n//                      ni=i+1;\\n//                     nj=j-2;\\n//                      if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n                    \\n                    \\n//                       ni=i-1;\\n//                     nj=j-2;\\n//                      if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n                    \\n//                       ni=i-2;\\n//                     nj=j-1;\\n//                      if(isValid(ni,nj,N)){\\n//                         childBoard[ni][nj]+=parentBoard[i][j]/8.0;\\n//                     }\\n                                      \\n//                 }}\\n//             }\\n            \\n//             parentBoard = childBoard;\\n//             fill(childBoard.begin(),childBoard.end(),vector<double>(N,0.0));\\n//         }\\n        \\n\\n        \\n//         double knightProb = 0.0;\\n        \\n//         // Loop through parent board after K steps and sum up all probability\\n//         for(int i=0;i<N;i++){\\n//             for(int j=0;j<N;j++){\\n//                    knightProb+=parentBoard[i][j];\\n//             }}\\n//         return knightProb;\\n     \\n    \\n        \\n    \\n   \\n    \\n    \\n  double ego_(int N, int K, int r, int c, vector<vector<vector<double>>> & dp){   \\n     if(r < 0 || c < 0 || r >= N || c >= N) return 0;\\n        if(K == 0) return 1;\\n        if(dp[r][c][K] != -1) return dp[r][c][K];\\n        double sum = ego_(N, K - 1, r - 2, c - 1, dp) +\\n                     ego_(N, K - 1, r - 1, c - 2, dp) +\\n                     ego_(N, K - 1, r + 1, c - 2, dp) +\\n                     ego_(N, K - 1, r + 2, c - 1, dp) +\\n                     ego_(N, K - 1, r - 2, c + 1, dp) +\\n                     ego_(N, K - 1, r - 1, c + 2, dp) +\\n                     ego_(N, K - 1, r + 1, c + 2, dp) +\\n                     ego_(N, K - 1, r + 2, c + 1, dp);\\n        sum = sum / 8;\\n        dp[r][c][K] = sum;\\n        return dp[r][c][K];\\n    \\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> dp(N + 1, vector<vector<double>> (N + 1, vector<double>(K + 1, -1)));\\n        return ego_(N, K, r, c, dp);\\n    }\\n    \\n    \\n    \\n    \\n    \\n      \\n        \\n    \\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n//     bool isValid(int ni,int nj,int n){\\n//         if(ni>=0 && nj>=0 &&ni<n&&nj<n){\\n//             return true;\\n//         }",
                "codeTag": "Java"
            },
            {
                "id": 1231818,
                "title": "c-memoization-solution-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\ndouble dp[26][26][101];\\n    double recurs(int n, int k, int row, int col)\\n    {\\n        if(row<0||row>=n||col<0||col>=n)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n          \\n            return 1;\\n        }\\n        \\n        if(dp[row][col][k])\\n        {\\n            return dp[row][col][k];\\n        }\\n        \\n\\n        double sum=0;\\n        sum=recurs(n,k-1,row-1,col-2)+\\n        recurs(n,k-1,row+1,col-2)+\\n        recurs(n,k-1,row-2,col-1)+\\n        recurs(n,k-1,row+2,col-1)+\\n        recurs(n,k-1,row-2,col+1)+\\n        recurs(n,k-1,row+2,col+1)+\\n        recurs(n,k-1,row-1,col+2)+\\n        recurs(n,k-1,row+1,col+2);\\n        \\n        sum/=8;\\n        return dp[row][col][k]=sum;\\n    }\\n\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n         \\n      return  recurs(n,k,row,column);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\ndouble dp[26][26][101];\\n    double recurs(int n, int k, int row, int col)\\n    {\\n        if(row<0||row>=n||col<0||col>=n)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n          \\n            return 1;\\n        }\\n        \\n        if(dp[row][col][k])\\n        {\\n            return dp[row][col][k];\\n        }\\n        \\n\\n        double sum=0;\\n        sum=recurs(n,k-1,row-1,col-2)+\\n        recurs(n,k-1,row+1,col-2)+\\n        recurs(n,k-1,row-2,col-1)+\\n        recurs(n,k-1,row+2,col-1)+\\n        recurs(n,k-1,row-2,col+1)+\\n        recurs(n,k-1,row+2,col+1)+\\n        recurs(n,k-1,row-1,col+2)+\\n        recurs(n,k-1,row+1,col+2);\\n        \\n        sum/=8;\\n        return dp[row][col][k]=sum;\\n    }\\n\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n         \\n      return  recurs(n,k,row,column);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159235,
                "title": "python3-code-with-100-percentile-dfs-and-memoization",
                "content": "I have used recursive DFS with memoization to find the probabilities. But the idea here is to reduce the amount of repetitive computations. Since we have a square board (duh, like any other chess board), we can bring down the number of recursive calls significantly. Each square is equivalent to at most 7 other squares (For any square ```(r, c)```, the equivalent squares are ```(c, r)```, ```(r, N - 1 - c)```, ```(c, N - 1 - r)```, ```(N - 1 - r, c)```, ```(N - 1 - c, r)```, ```(N - r - 1, N - c - 1)```, ```(N - c - 1, N - r - 1)```). We can use this to our advantage and store the probabability values for such squares for a given K.\\n\\n```\\nclass Solution:\\n    def knightProbability(self, N, K, r, c):        \\n        pr = [[[0] * K for j in range(N)] for i in range(N)]\\n        def probab(N, K, r, c):\\n            if K == 0:\\n                return 1\\n            elif pr[r][c][K - 1] > 0:\\n                return pr[r][c][K - 1]\\n            p = 0\\n            for move in [[1, 2], [2, 1], [-1, 2], [-2, 1], [-1, -2], [-2, -1], [1, -2], [2, -1]]:\\n                rr, cc = r + move[0], c + move[1]\\n                if -1 < rr < N and -1 < cc < N:\\n                    p += 0.125 * probab(N, K - 1, rr, cc)\\n            pr[r][c][K - 1], pr[c][r][K - 1] = p, p\\n            pr[r][N - 1 - c][K - 1], pr[c][N - 1 - r][K - 1] = p, p\\n            pr[N - 1 - r][c][K - 1], pr[N - 1 - c][r][K - 1] = p, p\\n            pr[N - r - 1][N - c - 1][K - 1], pr[N - c - 1][N - r - 1][K - 1] = p, p\\n            return p\\n        p = probab(N, K, r, c)\\n        return p\\n```",
                "solutionTags": [],
                "code": "```(r, c)```\n```(c, r)```\n```(r, N - 1 - c)```\n```(c, N - 1 - r)```\n```(N - 1 - r, c)```\n```(N - 1 - c, r)```\n```(N - r - 1, N - c - 1)```\n```(N - c - 1, N - r - 1)```\n```\\nclass Solution:\\n    def knightProbability(self, N, K, r, c):        \\n        pr = [[[0] * K for j in range(N)] for i in range(N)]\\n        def probab(N, K, r, c):\\n            if K == 0:\\n                return 1\\n            elif pr[r][c][K - 1] > 0:\\n                return pr[r][c][K - 1]\\n            p = 0\\n            for move in [[1, 2], [2, 1], [-1, 2], [-2, 1], [-1, -2], [-2, -1], [1, -2], [2, -1]]:\\n                rr, cc = r + move[0], c + move[1]\\n                if -1 < rr < N and -1 < cc < N:\\n                    p += 0.125 * probab(N, K - 1, rr, cc)\\n            pr[r][c][K - 1], pr[c][r][K - 1] = p, p\\n            pr[r][N - 1 - c][K - 1], pr[c][N - 1 - r][K - 1] = p, p\\n            pr[N - 1 - r][c][K - 1], pr[N - 1 - c][r][K - 1] = p, p\\n            pr[N - r - 1][N - c - 1][K - 1], pr[N - c - 1][N - r - 1][K - 1] = p, p\\n            return p\\n        p = probab(N, K, r, c)\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108209,
                "title": "any-help-with-this-algorithm-please",
                "content": "My idea is as the below code speaks, it passed 11/21 test cases.\\nI couldn't wrack my brain out of this what could be the bug/flaw of this algorithm.\\nAny 2nd eye look would be greatly appreciated!\\n\\n```\\npublic double knightProbability(int N, int K, int r, int c) {\\n            int[][] directions = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.offer(new int[]{r, c});\\n            double prob = 1.0;\\n            while (!queue.isEmpty() && K-- > 0) {\\n                int[] curr = queue.poll();\\n                int[] positive = new int[1];\\n                for (int i = 0; i < directions.length; i++) {\\n                    int[] direction = directions[i];\\n                    int x = curr[0] + direction[0];\\n                    int y = curr[1] + direction[1];\\n                    check(N, queue, positive, x, y);\\n                }\\n                prob *= (double) positive[0] / 8;\\n            }\\n            return prob;\\n        }\\n\\n        private void check(int N, Queue<int[]> queue, int[] positive, int x, int y) {\\n            if (x >= 0 && x < N && y >= 0 && y < N) {\\n                queue.offer(new int[]{x, y});\\n                positive[0]++;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double knightProbability(int N, int K, int r, int c) {\\n            int[][] directions = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.offer(new int[]{r, c});\\n            double prob = 1.0;\\n            while (!queue.isEmpty() && K-- > 0) {\\n                int[] curr = queue.poll();\\n                int[] positive = new int[1];\\n                for (int i = 0; i < directions.length; i++) {\\n                    int[] direction = directions[i];\\n                    int x = curr[0] + direction[0];\\n                    int y = curr[1] + direction[1];\\n                    check(N, queue, positive, x, y);\\n                }\\n                prob *= (double) positive[0] / 8;\\n            }\\n            return prob;\\n        }\\n\\n        private void check(int N, Queue<int[]> queue, int[] positive, int x, int y) {\\n            if (x >= 0 && x < N && y >= 0 && y < N) {\\n                queue.offer(new int[]{x, y});\\n                positive[0]++;\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802914,
                "title": "image-solution-recursion-memoization",
                "content": "# Almost every DP problem can be solved using \"Recursion + Memoization\" technique.\\n\\n# Intuition\\n\\nIn the following image the sign \"\\u2B50\" denotes the knight. Illustrate the first example test case:\\n```\\nInput: n = 3, k = 2, row = 0, column = 0\\nOutput: 0.06250\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/3974ef61-0906-43ff-84fd-ad1864162f90_1690056894.7522848.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^3)$$ for 3D array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    int[][] dirs = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] memo = new double[n][n][k+1];\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                Arrays.fill(memo[i][j], -1.0);\\n            }\\n        }\\n        return dfs(n, k, row, column, memo);\\n    }\\n\\n    double dfs(int n, int k, int r, int c, double[][][] memo) {\\n        if(r < 0 || r >= n || c < 0 || c >= n) {\\n            return 0.0;\\n        }\\n        if(k == 0) {\\n            return 1.0;\\n        }\\n        if(memo[r][c][k]!=-1.0) {\\n            return memo[r][c][k];\\n        }\\n\\n        double probability = 0.0;\\n        double possibleEvents = 8.0;\\n        for(int[] dir : dirs) {\\n            probability += dfs(n, k-1, r+dir[0], c+dir[1], memo); \\n        }\\n\\n        return memo[r][c][k] = probability/possibleEvents;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nInput: n = 3, k = 2, row = 0, column = 0\\nOutput: 0.06250\\n```\n``` Java []\\nclass Solution {\\n    int[][] dirs = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] memo = new double[n][n][k+1];\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                Arrays.fill(memo[i][j], -1.0);\\n            }\\n        }\\n        return dfs(n, k, row, column, memo);\\n    }\\n\\n    double dfs(int n, int k, int r, int c, double[][][] memo) {\\n        if(r < 0 || r >= n || c < 0 || c >= n) {\\n            return 0.0;\\n        }\\n        if(k == 0) {\\n            return 1.0;\\n        }\\n        if(memo[r][c][k]!=-1.0) {\\n            return memo[r][c][k];\\n        }\\n\\n        double probability = 0.0;\\n        double possibleEvents = 8.0;\\n        for(int[] dir : dirs) {\\n            probability += dfs(n, k-1, r+dir[0], c+dir[1], memo); \\n        }\\n\\n        return memo[r][c][k] = probability/possibleEvents;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801086,
                "title": "c-3d-dp",
                "content": "# Approach\\n`dp[x][y][k]` where `x` is the row, `y` is the column and `k` is the number of steps left.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n*k)$$\\n\\n- Space complexity:\\n$$O(n*n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> dirs = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-2,1},{-1,2}};\\n    int kay;\\npublic:\\n    double helper(int x, int y, int n, int k, vector<vector<vector<double>>>& dp){\\n        if(k==0)return (double)pow(0.125,kay);\\n        if(dp[x][y][k]!=-1)return dp[x][y][k];\\n        double ans = 0;\\n        for(auto&i:dirs){\\n            if(x+i[0]>=0&&x+i[0]<n&&y+i[1]>=0&&y+i[1]<n){\\n                ans+=helper(x+i[0],y+i[1],n, k-1,dp);\\n            }\\n        }\\n        return dp[x][y][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        kay=k;\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));\\n        return (helper(row,column,n,k,dp));\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dirs = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-2,1},{-1,2}};\\n    int kay;\\npublic:\\n    double helper(int x, int y, int n, int k, vector<vector<vector<double>>>& dp){\\n        if(k==0)return (double)pow(0.125,kay);\\n        if(dp[x][y][k]!=-1)return dp[x][y][k];\\n        double ans = 0;\\n        for(auto&i:dirs){\\n            if(x+i[0]>=0&&x+i[0]<n&&y+i[1]>=0&&y+i[1]<n){\\n                ans+=helper(x+i[0],y+i[1],n, k-1,dp);\\n            }\\n        }\\n        return dp[x][y][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        kay=k;\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));\\n        return (helper(row,column,n,k,dp));\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800243,
                "title": "java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    private Double dp[][][];\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        dp = new Double[n][n][k + 1];\\n        return getProbability(n, row, column, k);\\n    }\\n\\n    private double getProbability(int n, int row, int col, int k) {\\n        if (row < 0 || col < 0 || row >= n || col >= n) {\\n            return 0;\\n        }\\n\\n        if (dp[row][col][k] != null) {\\n            return dp[row][col][k];\\n        }\\n\\n        if (k == 0) {\\n            return 1;\\n        }\\n\\n        double total = (\\n            getProbability(n, row - 2, col + 1, k - 1) + \\n            getProbability(n, row - 2, col - 1, k - 1) + \\n            getProbability(n, row + 2, col + 1, k - 1) + \\n            getProbability(n, row + 2, col - 1, k - 1) + \\n            getProbability(n, row - 1, col + 2, k - 1) +\\n            getProbability(n, row - 1, col - 2, k - 1) + \\n            getProbability(n, row + 1, col + 2, k - 1) +\\n            getProbability(n, row + 1, col - 2, k - 1)\\n        );\\n\\n        return dp[row][col][k] = total / 8.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private Double dp[][][];\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        dp = new Double[n][n][k + 1];\\n        return getProbability(n, row, column, k);\\n    }\\n\\n    private double getProbability(int n, int row, int col, int k) {\\n        if (row < 0 || col < 0 || row >= n || col >= n) {\\n            return 0;\\n        }\\n\\n        if (dp[row][col][k] != null) {\\n            return dp[row][col][k];\\n        }\\n\\n        if (k == 0) {\\n            return 1;\\n        }\\n\\n        double total = (\\n            getProbability(n, row - 2, col + 1, k - 1) + \\n            getProbability(n, row - 2, col - 1, k - 1) + \\n            getProbability(n, row + 2, col + 1, k - 1) + \\n            getProbability(n, row + 2, col - 1, k - 1) + \\n            getProbability(n, row - 1, col + 2, k - 1) +\\n            getProbability(n, row - 1, col - 2, k - 1) + \\n            getProbability(n, row + 1, col + 2, k - 1) +\\n            getProbability(n, row + 1, col - 2, k - 1)\\n        );\\n\\n        return dp[row][col][k] = total / 8.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799567,
                "title": "easy-solution-c-dfs-3d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n*k)\\n\\n- Space complexity: O(n*n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\\n        if(k==0) return 1.0;\\n\\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\\n        double ans = 0.0;\\n        for(int t=0;t<8;t++){\\n            int nx=i+dx[t],ny=j+dy[t];\\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\\n                ans += f(nx,ny,k-1,n,dp);\\n            }\\n        }\\n\\n        return dp[i][j][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\\n        double ct=f(row,column,k,n,dp);\\n        for(int i=0;i<k;i++){\\n            ct = ct/8;\\n        }\\n\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\\n        if(k==0) return 1.0;\\n\\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\\n        double ans = 0.0;\\n        for(int t=0;t<8;t++){\\n            int nx=i+dx[t],ny=j+dy[t];\\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\\n                ans += f(nx,ny,k-1,n,dp);\\n            }\\n        }\\n\\n        return dp[i][j][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\\n        double ct=f(row,column,k,n,dp);\\n        for(int i=0;i<k;i++){\\n            ct = ct/8;\\n        }\\n\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798779,
                "title": "c-faster-than-90-of-sol-n-dfs-dp-clean-concise-and-well-explained",
                "content": "**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every possible valid place there is an addition of (1/8)th part of that ans.\\nFor example if n = 3, k = 2, row = 0, col = 0\\n-> its go to (1,2) and (2,1) by taking val of (1/8)=0.125 other moves are unvalid\\n-> from (1,2) or (2,1) it can have only 2 valid move which make the ans -> (0.125/2);\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int X[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\n    int Y[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n    double fn(int n,int k,int row,int col,map<vector<int>,double> &mp){\\n        if(k==0) return 1.0;\\n        if(mp.count({row,col,k})) return mp[{row,col,k}];\\n        double ans=0.0;\\n        for(int i=0;i<8;i++){\\n            int x=X[i]+row;\\n            int y=Y[i]+col;\\n            if((x>=0 and x<n) and (y>=0 and y<n)){\\n                ans+=(fn(n,k-1,x,y,mp))/8.0;\\n            }\\n        }\\n        return mp[{row,col,k}]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        map<vector<int>,double> mp;\\n        return fn(n,k,row,col,mp);\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int X[8]={ 2, 1, -1, -2, -2, -1, 1, 2 };\\n    int Y[8]={ 1, 2, 2, 1, -1, -2, -2, -1 };\\n    double fn(int n,int k,int row,int col,map<vector<int>,double> &mp){\\n        if(k==0) return 1.0;\\n        if(mp.count({row,col,k})) return mp[{row,col,k}];\\n        double ans=0.0;\\n        for(int i=0;i<8;i++){\\n            int x=X[i]+row;\\n            int y=Y[i]+col;\\n            if((x>=0 and x<n) and (y>=0 and y<n)){\\n                ans+=(fn(n,k-1,x,y,mp))/8.0;\\n            }\\n        }\\n        return mp[{row,col,k}]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        map<vector<int>,double> mp;\\n        return fn(n,k,row,col,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798755,
                "title": "easy-c-dfs-3d-memo-iterative-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the probability formula\\n$$\\nProb(i, j, move=k) \\\\\\\\=\\\\sum_{(r,s)} Prob(i, j, move=k\\\\Big|_{(r,s)\\\\to(i, j)})Prob((r,s)\\\\to(i, j))\\\\\\\\\\n=\\n\\\\sum_{(r,s)}Prob(r, s, move=k-1)\\\\frac{1}{8}\\n$$\\nto implement recursive DFS with memo, that is DP!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n2nd approach is just a transform of recursion to iterative form. Due to updating  previous DP state array to the new one is proceeded at each move just once, the 3D DP state array can be reduced to 2D array!\\n\\nA list for n=8 dp state array for move=1,..8\\n```\\nmove:1\\n      0.25\\t,     0.375\\t,       0.5\\t,       0.5\\t,       0.5\\t,       0.5\\t,     0.375\\t,      0.25\\t,\\n     0.375\\t,       0.5\\t,      0.75\\t,      0.75\\t,      0.75\\t,      0.75\\t,       0.5\\t,     0.375\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n     0.375\\t,       0.5\\t,      0.75\\t,      0.75\\t,      0.75\\t,      0.75\\t,       0.5\\t,     0.375\\t,\\n      0.25\\t,     0.375\\t,       0.5\\t,       0.5\\t,       0.5\\t,       0.5\\t,     0.375\\t,      0.25\\t,\\n\\n===========\\nmove:2\\n    0.1875\\t,   0.28125\\t,  0.359375\\t,   0.40625\\t,   0.40625\\t,  0.359375\\t,   0.28125\\t,    0.1875\\t,\\n   0.28125\\t,     0.375\\t,       0.5\\t,  0.578125\\t,  0.578125\\t,       0.5\\t,     0.375\\t,   0.28125\\t,\\n  0.359375\\t,       0.5\\t,   0.65625\\t,      0.75\\t,      0.75\\t,   0.65625\\t,       0.5\\t,  0.359375\\t,\\n   0.40625\\t,  0.578125\\t,      0.75\\t,     0.875\\t,     0.875\\t,      0.75\\t,  0.578125\\t,   0.40625\\t,\\n   0.40625\\t,  0.578125\\t,      0.75\\t,     0.875\\t,     0.875\\t,      0.75\\t,  0.578125\\t,   0.40625\\t,\\n  0.359375\\t,       0.5\\t,   0.65625\\t,      0.75\\t,      0.75\\t,   0.65625\\t,       0.5\\t,  0.359375\\t,\\n   0.28125\\t,     0.375\\t,       0.5\\t,  0.578125\\t,  0.578125\\t,       0.5\\t,     0.375\\t,   0.28125\\t,\\n    0.1875\\t,   0.28125\\t,  0.359375\\t,   0.40625\\t,   0.40625\\t,  0.359375\\t,   0.28125\\t,    0.1875\\t,\\n\\n===========\\nmove:3\\n     0.125\\t,  0.199219\\t,  0.263672\\t,  0.285156\\t,  0.285156\\t,  0.263672\\t,  0.199219\\t,     0.125\\t,\\n  0.199219\\t,  0.289062\\t,  0.394531\\t,  0.427734\\t,  0.427734\\t,  0.394531\\t,  0.289062\\t,  0.199219\\t,\\n  0.263672\\t,  0.394531\\t,  0.535156\\t,  0.574219\\t,  0.574219\\t,  0.535156\\t,  0.394531\\t,  0.263672\\t,\\n  0.285156\\t,  0.427734\\t,  0.574219\\t,  0.621094\\t,  0.621094\\t,  0.574219\\t,  0.427734\\t,  0.285156\\t,\\n  0.285156\\t,  0.427734\\t,  0.574219\\t,  0.621094\\t,  0.621094\\t,  0.574219\\t,  0.427734\\t,  0.285156\\t,\\n  0.263672\\t,  0.394531\\t,  0.535156\\t,  0.574219\\t,  0.574219\\t,  0.535156\\t,  0.394531\\t,  0.263672\\t,\\n  0.199219\\t,  0.289062\\t,  0.394531\\t,  0.427734\\t,  0.427734\\t,  0.394531\\t,  0.289062\\t,  0.199219\\t,\\n     0.125\\t,  0.199219\\t,  0.263672\\t,  0.285156\\t,  0.285156\\t,  0.263672\\t,  0.199219\\t,     0.125\\t,\\n\\n===========\\nmove:4\\n 0.0986328\\t,   0.15332\\t,  0.199463\\t,  0.224121\\t,  0.224121\\t,  0.199463\\t,   0.15332\\t, 0.0986328\\t,\\n   0.15332\\t,  0.214844\\t,  0.287109\\t,  0.323486\\t,  0.323486\\t,  0.287109\\t,  0.214844\\t,   0.15332\\t,\\n  0.199463\\t,  0.287109\\t,  0.383301\\t,  0.428711\\t,  0.428711\\t,  0.383301\\t,  0.287109\\t,  0.199463\\t,\\n  0.224121\\t,  0.323486\\t,  0.428711\\t,   0.48291\\t,   0.48291\\t,  0.428711\\t,  0.323486\\t,  0.224121\\t,\\n  0.224121\\t,  0.323486\\t,  0.428711\\t,   0.48291\\t,   0.48291\\t,  0.428711\\t,  0.323486\\t,  0.224121\\t,\\n  0.199463\\t,  0.287109\\t,  0.383301\\t,  0.428711\\t,  0.428711\\t,  0.383301\\t,  0.287109\\t,  0.199463\\t,\\n   0.15332\\t,  0.214844\\t,  0.287109\\t,  0.323486\\t,  0.323486\\t,  0.287109\\t,  0.214844\\t,   0.15332\\t,\\n 0.0986328\\t,   0.15332\\t,  0.199463\\t,  0.224121\\t,  0.224121\\t,  0.199463\\t,   0.15332\\t, 0.0986328\\t,\\n\\n===========\\nmove:5\\n 0.0717773\\t,  0.113281\\t,  0.149078\\t,  0.164246\\t,  0.164246\\t,  0.149078\\t,  0.113281\\t, 0.0717773\\t,\\n  0.113281\\t,  0.163208\\t,  0.219666\\t,  0.241852\\t,  0.241852\\t,  0.219666\\t,  0.163208\\t,  0.113281\\t,\\n  0.149078\\t,  0.219666\\t,  0.295959\\t,  0.323669\\t,  0.323669\\t,  0.295959\\t,  0.219666\\t,  0.149078\\t,\\n  0.164246\\t,  0.241852\\t,  0.323669\\t,  0.355652\\t,  0.355652\\t,  0.323669\\t,  0.241852\\t,  0.164246\\t,\\n  0.164246\\t,  0.241852\\t,  0.323669\\t,  0.355652\\t,  0.355652\\t,  0.323669\\t,  0.241852\\t,  0.164246\\t,\\n  0.149078\\t,  0.219666\\t,  0.295959\\t,  0.323669\\t,  0.323669\\t,  0.295959\\t,  0.219666\\t,  0.149078\\t,\\n  0.113281\\t,  0.163208\\t,  0.219666\\t,  0.241852\\t,  0.241852\\t,  0.219666\\t,  0.163208\\t,  0.113281\\t,\\n 0.0717773\\t,  0.113281\\t,  0.149078\\t,  0.164246\\t,  0.164246\\t,  0.149078\\t,  0.113281\\t, 0.0717773\\t,\\n\\n===========\\nmove:6\\n 0.0549164\\t, 0.0858612\\t,  0.112309\\t,  0.125313\\t,  0.125313\\t,  0.112309\\t, 0.0858612\\t, 0.0549164\\t,\\n 0.0858612\\t,  0.121979\\t,  0.163284\\t,  0.182163\\t,  0.182163\\t,  0.163284\\t,  0.121979\\t, 0.0858612\\t,\\n  0.112309\\t,  0.163284\\t,  0.218758\\t,   0.24263\\t,   0.24263\\t,  0.218758\\t,  0.163284\\t,  0.112309\\t,\\n  0.125313\\t,  0.182163\\t,   0.24263\\t,  0.270287\\t,  0.270287\\t,   0.24263\\t,  0.182163\\t,  0.125313\\t,\\n  0.125313\\t,  0.182163\\t,   0.24263\\t,  0.270287\\t,  0.270287\\t,   0.24263\\t,  0.182163\\t,  0.125313\\t,\\n  0.112309\\t,  0.163284\\t,  0.218758\\t,   0.24263\\t,   0.24263\\t,  0.218758\\t,  0.163284\\t,  0.112309\\t,\\n 0.0858612\\t,  0.121979\\t,  0.163284\\t,  0.182163\\t,  0.182163\\t,  0.163284\\t,  0.121979\\t, 0.0858612\\t,\\n 0.0549164\\t, 0.0858612\\t,  0.112309\\t,  0.125313\\t,  0.125313\\t,  0.112309\\t, 0.0858612\\t, 0.0549164\\t,\\n\\n===========\\nmove:7\\n 0.0408211\\t, 0.0641537\\t, 0.0842423\\t, 0.0933313\\t, 0.0933313\\t, 0.0842423\\t, 0.0641537\\t, 0.0408211\\t,\\n 0.0641537\\t, 0.0919857\\t,  0.123452\\t,  0.136641\\t,  0.136641\\t,  0.123452\\t, 0.0919857\\t, 0.0641537\\t,\\n 0.0842423\\t,  0.123452\\t,  0.165906\\t,  0.182574\\t,  0.182574\\t,  0.165906\\t,  0.123452\\t, 0.0842423\\t,\\n 0.0933313\\t,  0.136641\\t,  0.182574\\t,  0.201709\\t,  0.201709\\t,  0.182574\\t,  0.136641\\t, 0.0933313\\t,\\n 0.0933313\\t,  0.136641\\t,  0.182574\\t,  0.201709\\t,  0.201709\\t,  0.182574\\t,  0.136641\\t, 0.0933313\\t,\\n 0.0842423\\t,  0.123452\\t,  0.165906\\t,  0.182574\\t,  0.182574\\t,  0.165906\\t,  0.123452\\t, 0.0842423\\t,\\n 0.0641537\\t, 0.0919857\\t,  0.123452\\t,  0.136641\\t,  0.136641\\t,  0.123452\\t, 0.0919857\\t, 0.0641537\\t,\\n 0.0408211\\t, 0.0641537\\t, 0.0842423\\t, 0.0933313\\t, 0.0933313\\t, 0.0842423\\t, 0.0641537\\t, 0.0408211\\t,\\n\\n===========\\nmove:8\\n  0.030863\\t, 0.0483487\\t, 0.0633526\\t, 0.0704898\\t, 0.0704898\\t, 0.0633526\\t, 0.0483487\\t,  0.030863\\t,\\n 0.0483487\\t, 0.0689764\\t, 0.0924149\\t,  0.102755\\t,  0.102755\\t, 0.0924149\\t, 0.0689764\\t, 0.0483487\\t,\\n 0.0633526\\t, 0.0924149\\t,  0.123959\\t,  0.137064\\t,  0.137064\\t,  0.123959\\t, 0.0924149\\t, 0.0633526\\t,\\n 0.0704898\\t,  0.102755\\t,  0.137064\\t,  0.152143\\t,  0.152143\\t,  0.137064\\t,  0.102755\\t, 0.0704898\\t,\\n 0.0704898\\t,  0.102755\\t,  0.137064\\t,  0.152143\\t,  0.152143\\t,  0.137064\\t,  0.102755\\t, 0.0704898\\t,\\n 0.0633526\\t, 0.0924149\\t,  0.123959\\t,  0.137064\\t,  0.137064\\t,  0.123959\\t, 0.0924149\\t, 0.0633526\\t,\\n 0.0483487\\t, 0.0689764\\t, 0.0924149\\t,  0.102755\\t,  0.102755\\t, 0.0924149\\t, 0.0689764\\t, 0.0483487\\t,\\n  0.030863\\t, 0.0483487\\t, 0.0633526\\t, 0.0704898\\t, 0.0704898\\t, 0.0633526\\t, 0.0483487\\t,  0.030863\\t,\\n\\n===========\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2k)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2k)$$\\n# Code\\n```\\nusing int2=pair<int,int>;\\nvector<int2> moves={{1,2},{2, 1},{-1,2},{-2, 1},{1,-2},{2, -1},{-1,-2},{-2, -1}};\\nclass Solution {\\npublic:\\n    vector<vector<vector<double>>> dp;\\n    double knight(int n, int k, int i, int j){\\n        if (i<0 || i>=n || j<0 || j>=n) return 0;\\n        if (k==0) return dp[0][i][j]=1;\\n        if (dp[k][i][j]!=-1) return dp[k][i][j];\\n        double prob=0;\\n        for (auto [a,b]: moves){\\n            int r=i+a, s=j+b;\\n            prob+=1.0/8*knight(n, k-1, r, s);\\n        }\\n        return dp[k][i][j]=prob;\\n    }\\n   \\n    double knightProbability(int n, int k, int row, int column) {\\n        dp.assign(k+1, vector(n, vector<double>(n, -1.0)));\\n        return knight(n, k, row, column);\\n    }\\n};\\n```\\n# iterative Code\\n```\\nusing int2=pair<int,int>;\\nvector<int2> moves={{1,2},{2, 1},{-1,2},{-2, 1},{1,-2},{2, -1},{-1,-2},{-2, -1}};\\nclass Solution {\\npublic:\\n    vector<vector<double>> dp;\\n    \\n    double knight_loop(int n, int k, int r, int c) {\\n        if (k == 0) return 1;\\n        for (int move = 1; move <= k; move++) { \\n            vector<vector<double>> new_dp(n, vector<double>(n)); // Initialize a new dp table for each iteration\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    double prob = 0;\\n                    for (auto [a, b] : moves) {\\n                        int r1 = i + a, c1 = j + b;\\n                        if (r1 >= 0 && r1 < n && c1 >= 0 && c1 < n) {\\n                            prob += 0.125 * dp[r1][c1];\\n                        }\\n                    }\\n                    new_dp[i][j] = prob;\\n                }\\n            }\\n            dp = new_dp; // Update dp table for the next iteration\\n        }\\n        return dp[r][c];\\n    }\\n   \\n    double knightProbability(int n, int k, int row, int column) {\\n        dp.assign(n, vector<double>(n, 1));\\n        return knight_loop(n, k, row, column);\\n    }\\n};\\n```\\n\\n![DALL\\xB7E 2023-07-22 09.12.02 - Near the dog there are big chess knights in a realistic style.png](https://assets.leetcode.com/users/images/d5d0c5c7-4452-408b-9920-aa5d05dd229f_1689988372.6570885.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nmove:1\\n      0.25\\t,     0.375\\t,       0.5\\t,       0.5\\t,       0.5\\t,       0.5\\t,     0.375\\t,      0.25\\t,\\n     0.375\\t,       0.5\\t,      0.75\\t,      0.75\\t,      0.75\\t,      0.75\\t,       0.5\\t,     0.375\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n       0.5\\t,      0.75\\t,         1\\t,         1\\t,         1\\t,         1\\t,      0.75\\t,       0.5\\t,\\n     0.375\\t,       0.5\\t,      0.75\\t,      0.75\\t,      0.75\\t,      0.75\\t,       0.5\\t,     0.375\\t,\\n      0.25\\t,     0.375\\t,       0.5\\t,       0.5\\t,       0.5\\t,       0.5\\t,     0.375\\t,      0.25\\t,\\n\\n===========\\nmove:2\\n    0.1875\\t,   0.28125\\t,  0.359375\\t,   0.40625\\t,   0.40625\\t,  0.359375\\t,   0.28125\\t,    0.1875\\t,\\n   0.28125\\t,     0.375\\t,       0.5\\t,  0.578125\\t,  0.578125\\t,       0.5\\t,     0.375\\t,   0.28125\\t,\\n  0.359375\\t,       0.5\\t,   0.65625\\t,      0.75\\t,      0.75\\t,   0.65625\\t,       0.5\\t,  0.359375\\t,\\n   0.40625\\t,  0.578125\\t,      0.75\\t,     0.875\\t,     0.875\\t,      0.75\\t,  0.578125\\t,   0.40625\\t,\\n   0.40625\\t,  0.578125\\t,      0.75\\t,     0.875\\t,     0.875\\t,      0.75\\t,  0.578125\\t,   0.40625\\t,\\n  0.359375\\t,       0.5\\t,   0.65625\\t,      0.75\\t,      0.75\\t,   0.65625\\t,       0.5\\t,  0.359375\\t,\\n   0.28125\\t,     0.375\\t,       0.5\\t,  0.578125\\t,  0.578125\\t,       0.5\\t,     0.375\\t,   0.28125\\t,\\n    0.1875\\t,   0.28125\\t,  0.359375\\t,   0.40625\\t,   0.40625\\t,  0.359375\\t,   0.28125\\t,    0.1875\\t,\\n\\n===========\\nmove:3\\n     0.125\\t,  0.199219\\t,  0.263672\\t,  0.285156\\t,  0.285156\\t,  0.263672\\t,  0.199219\\t,     0.125\\t,\\n  0.199219\\t,  0.289062\\t,  0.394531\\t,  0.427734\\t,  0.427734\\t,  0.394531\\t,  0.289062\\t,  0.199219\\t,\\n  0.263672\\t,  0.394531\\t,  0.535156\\t,  0.574219\\t,  0.574219\\t,  0.535156\\t,  0.394531\\t,  0.263672\\t,\\n  0.285156\\t,  0.427734\\t,  0.574219\\t,  0.621094\\t,  0.621094\\t,  0.574219\\t,  0.427734\\t,  0.285156\\t,\\n  0.285156\\t,  0.427734\\t,  0.574219\\t,  0.621094\\t,  0.621094\\t,  0.574219\\t,  0.427734\\t,  0.285156\\t,\\n  0.263672\\t,  0.394531\\t,  0.535156\\t,  0.574219\\t,  0.574219\\t,  0.535156\\t,  0.394531\\t,  0.263672\\t,\\n  0.199219\\t,  0.289062\\t,  0.394531\\t,  0.427734\\t,  0.427734\\t,  0.394531\\t,  0.289062\\t,  0.199219\\t,\\n     0.125\\t,  0.199219\\t,  0.263672\\t,  0.285156\\t,  0.285156\\t,  0.263672\\t,  0.199219\\t,     0.125\\t,\\n\\n===========\\nmove:4\\n 0.0986328\\t,   0.15332\\t,  0.199463\\t,  0.224121\\t,  0.224121\\t,  0.199463\\t,   0.15332\\t, 0.0986328\\t,\\n   0.15332\\t,  0.214844\\t,  0.287109\\t,  0.323486\\t,  0.323486\\t,  0.287109\\t,  0.214844\\t,   0.15332\\t,\\n  0.199463\\t,  0.287109\\t,  0.383301\\t,  0.428711\\t,  0.428711\\t,  0.383301\\t,  0.287109\\t,  0.199463\\t,\\n  0.224121\\t,  0.323486\\t,  0.428711\\t,   0.48291\\t,   0.48291\\t,  0.428711\\t,  0.323486\\t,  0.224121\\t,\\n  0.224121\\t,  0.323486\\t,  0.428711\\t,   0.48291\\t,   0.48291\\t,  0.428711\\t,  0.323486\\t,  0.224121\\t,\\n  0.199463\\t,  0.287109\\t,  0.383301\\t,  0.428711\\t,  0.428711\\t,  0.383301\\t,  0.287109\\t,  0.199463\\t,\\n   0.15332\\t,  0.214844\\t,  0.287109\\t,  0.323486\\t,  0.323486\\t,  0.287109\\t,  0.214844\\t,   0.15332\\t,\\n 0.0986328\\t,   0.15332\\t,  0.199463\\t,  0.224121\\t,  0.224121\\t,  0.199463\\t,   0.15332\\t, 0.0986328\\t,\\n\\n===========\\nmove:5\\n 0.0717773\\t,  0.113281\\t,  0.149078\\t,  0.164246\\t,  0.164246\\t,  0.149078\\t,  0.113281\\t, 0.0717773\\t,\\n  0.113281\\t,  0.163208\\t,  0.219666\\t,  0.241852\\t,  0.241852\\t,  0.219666\\t,  0.163208\\t,  0.113281\\t,\\n  0.149078\\t,  0.219666\\t,  0.295959\\t,  0.323669\\t,  0.323669\\t,  0.295959\\t,  0.219666\\t,  0.149078\\t,\\n  0.164246\\t,  0.241852\\t,  0.323669\\t,  0.355652\\t,  0.355652\\t,  0.323669\\t,  0.241852\\t,  0.164246\\t,\\n  0.164246\\t,  0.241852\\t,  0.323669\\t,  0.355652\\t,  0.355652\\t,  0.323669\\t,  0.241852\\t,  0.164246\\t,\\n  0.149078\\t,  0.219666\\t,  0.295959\\t,  0.323669\\t,  0.323669\\t,  0.295959\\t,  0.219666\\t,  0.149078\\t,\\n  0.113281\\t,  0.163208\\t,  0.219666\\t,  0.241852\\t,  0.241852\\t,  0.219666\\t,  0.163208\\t,  0.113281\\t,\\n 0.0717773\\t,  0.113281\\t,  0.149078\\t,  0.164246\\t,  0.164246\\t,  0.149078\\t,  0.113281\\t, 0.0717773\\t,\\n\\n===========\\nmove:6\\n 0.0549164\\t, 0.0858612\\t,  0.112309\\t,  0.125313\\t,  0.125313\\t,  0.112309\\t, 0.0858612\\t, 0.0549164\\t,\\n 0.0858612\\t,  0.121979\\t,  0.163284\\t,  0.182163\\t,  0.182163\\t,  0.163284\\t,  0.121979\\t, 0.0858612\\t,\\n  0.112309\\t,  0.163284\\t,  0.218758\\t,   0.24263\\t,   0.24263\\t,  0.218758\\t,  0.163284\\t,  0.112309\\t,\\n  0.125313\\t,  0.182163\\t,   0.24263\\t,  0.270287\\t,  0.270287\\t,   0.24263\\t,  0.182163\\t,  0.125313\\t,\\n  0.125313\\t,  0.182163\\t,   0.24263\\t,  0.270287\\t,  0.270287\\t,   0.24263\\t,  0.182163\\t,  0.125313\\t,\\n  0.112309\\t,  0.163284\\t,  0.218758\\t,   0.24263\\t,   0.24263\\t,  0.218758\\t,  0.163284\\t,  0.112309\\t,\\n 0.0858612\\t,  0.121979\\t,  0.163284\\t,  0.182163\\t,  0.182163\\t,  0.163284\\t,  0.121979\\t, 0.0858612\\t,\\n 0.0549164\\t, 0.0858612\\t,  0.112309\\t,  0.125313\\t,  0.125313\\t,  0.112309\\t, 0.0858612\\t, 0.0549164\\t,\\n\\n===========\\nmove:7\\n 0.0408211\\t, 0.0641537\\t, 0.0842423\\t, 0.0933313\\t, 0.0933313\\t, 0.0842423\\t, 0.0641537\\t, 0.0408211\\t,\\n 0.0641537\\t, 0.0919857\\t,  0.123452\\t,  0.136641\\t,  0.136641\\t,  0.123452\\t, 0.0919857\\t, 0.0641537\\t,\\n 0.0842423\\t,  0.123452\\t,  0.165906\\t,  0.182574\\t,  0.182574\\t,  0.165906\\t,  0.123452\\t, 0.0842423\\t,\\n 0.0933313\\t,  0.136641\\t,  0.182574\\t,  0.201709\\t,  0.201709\\t,  0.182574\\t,  0.136641\\t, 0.0933313\\t,\\n 0.0933313\\t,  0.136641\\t,  0.182574\\t,  0.201709\\t,  0.201709\\t,  0.182574\\t,  0.136641\\t, 0.0933313\\t,\\n 0.0842423\\t,  0.123452\\t,  0.165906\\t,  0.182574\\t,  0.182574\\t,  0.165906\\t,  0.123452\\t, 0.0842423\\t,\\n 0.0641537\\t, 0.0919857\\t,  0.123452\\t,  0.136641\\t,  0.136641\\t,  0.123452\\t, 0.0919857\\t, 0.0641537\\t,\\n 0.0408211\\t, 0.0641537\\t, 0.0842423\\t, 0.0933313\\t, 0.0933313\\t, 0.0842423\\t, 0.0641537\\t, 0.0408211\\t,\\n\\n===========\\nmove:8\\n  0.030863\\t, 0.0483487\\t, 0.0633526\\t, 0.0704898\\t, 0.0704898\\t, 0.0633526\\t, 0.0483487\\t,  0.030863\\t,\\n 0.0483487\\t, 0.0689764\\t, 0.0924149\\t,  0.102755\\t,  0.102755\\t, 0.0924149\\t, 0.0689764\\t, 0.0483487\\t,\\n 0.0633526\\t, 0.0924149\\t,  0.123959\\t,  0.137064\\t,  0.137064\\t,  0.123959\\t, 0.0924149\\t, 0.0633526\\t,\\n 0.0704898\\t,  0.102755\\t,  0.137064\\t,  0.152143\\t,  0.152143\\t,  0.137064\\t,  0.102755\\t, 0.0704898\\t,\\n 0.0704898\\t,  0.102755\\t,  0.137064\\t,  0.152143\\t,  0.152143\\t,  0.137064\\t,  0.102755\\t, 0.0704898\\t,\\n 0.0633526\\t, 0.0924149\\t,  0.123959\\t,  0.137064\\t,  0.137064\\t,  0.123959\\t, 0.0924149\\t, 0.0633526\\t,\\n 0.0483487\\t, 0.0689764\\t, 0.0924149\\t,  0.102755\\t,  0.102755\\t, 0.0924149\\t, 0.0689764\\t, 0.0483487\\t,\\n  0.030863\\t, 0.0483487\\t, 0.0633526\\t, 0.0704898\\t, 0.0704898\\t, 0.0633526\\t, 0.0483487\\t,  0.030863\\t,\\n\\n===========\\n```\n```\\nusing int2=pair<int,int>;\\nvector<int2> moves={{1,2},{2, 1},{-1,2},{-2, 1},{1,-2},{2, -1},{-1,-2},{-2, -1}};\\nclass Solution {\\npublic:\\n    vector<vector<vector<double>>> dp;\\n    double knight(int n, int k, int i, int j){\\n        if (i<0 || i>=n || j<0 || j>=n) return 0;\\n        if (k==0) return dp[0][i][j]=1;\\n        if (dp[k][i][j]!=-1) return dp[k][i][j];\\n        double prob=0;\\n        for (auto [a,b]: moves){\\n            int r=i+a, s=j+b;\\n            prob+=1.0/8*knight(n, k-1, r, s);\\n        }\\n        return dp[k][i][j]=prob;\\n    }\\n   \\n    double knightProbability(int n, int k, int row, int column) {\\n        dp.assign(k+1, vector(n, vector<double>(n, -1.0)));\\n        return knight(n, k, row, column);\\n    }\\n};\\n```\n```\\nusing int2=pair<int,int>;\\nvector<int2> moves={{1,2},{2, 1},{-1,2},{-2, 1},{1,-2},{2, -1},{-1,-2},{-2, -1}};\\nclass Solution {\\npublic:\\n    vector<vector<double>> dp;\\n    \\n    double knight_loop(int n, int k, int r, int c) {\\n        if (k == 0) return 1;\\n        for (int move = 1; move <= k; move++) { \\n            vector<vector<double>> new_dp(n, vector<double>(n)); // Initialize a new dp table for each iteration\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    double prob = 0;\\n                    for (auto [a, b] : moves) {\\n                        int r1 = i + a, c1 = j + b;\\n                        if (r1 >= 0 && r1 < n && c1 >= 0 && c1 < n) {\\n                            prob += 0.125 * dp[r1][c1];\\n                        }\\n                    }\\n                    new_dp[i][j] = prob;\\n                }\\n            }\\n            dp = new_dp; // Update dp table for the next iteration\\n        }\\n        return dp[r][c];\\n    }\\n   \\n    double knightProbability(int n, int k, int row, int column) {\\n        dp.assign(n, vector<double>(n, 1));\\n        return knight_loop(n, k, row, column);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525431,
                "title": "c-solution-memoization",
                "content": "```\\ndouble dp[26][26][101];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n    int dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\n    double solve(int i, int j, int n, int k) {\\n        // out of boundary\\n        if(i < 0 || i >= n || j < 0 || j >= n) return 0;\\n        \\n        if(k == 0) return 1;\\n        \\n        if(dp[i][j][k]) return dp[i][j][k];\\n        \\n        double sum = 0;\\n        \\n        for(int x=0;x<8;x++) {\\n            sum += solve(i+dx[x], j+dy[x], n, k-1);\\n        }\\n        \\n        return dp[i][j][k] = sum/8;\\n    }\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        return solve(row, column, n, k);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndouble dp[26][26][101];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n    int dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\n    double solve(int i, int j, int n, int k) {\\n        // out of boundary\\n        if(i < 0 || i >= n || j < 0 || j >= n) return 0;\\n        \\n        if(k == 0) return 1;\\n        \\n        if(dp[i][j][k]) return dp[i][j][k];\\n        \\n        double sum = 0;\\n        \\n        for(int x=0;x<8;x++) {\\n            sum += solve(i+dx[x], j+dy[x], n, k-1);\\n        }\\n        \\n        return dp[i][j][k] = sum/8;\\n    }\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        return solve(row, column, n, k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088036,
                "title": "clean-and-concise-memorization-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int iarr[8] = {-2,-2,-1,-1,1,1,2,2};\\n    int jarr[8] = {-1,1,-2,2,-2,2,-1,1};\\n    double solve(int row,int col,int n,int k,vector<vector<vector<double>>> &dp){\\n        if(row < 0 or col < 0 or row >= n or col >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[row][col][k] != -1) return dp[row][col][k];\\n        \\n        double ans = 0.0;\\n        \\n        for(int i=0;i<8;i++){\\n            ans += solve(row+iarr[i], col+jarr[i], n, k-1, dp);\\n        }\\n        \\n        return dp[row][col][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<vector<double>>> dp(n+1,vector<vector<double>> (n+1,vector<double> (k+1,-1)));\\n        double fav = solve(row,col,n,k,dp);\\n        double total = pow(8,k);\\n        return fav/total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int iarr[8] = {-2,-2,-1,-1,1,1,2,2};\\n    int jarr[8] = {-1,1,-2,2,-2,2,-1,1};\\n    double solve(int row,int col,int n,int k,vector<vector<vector<double>>> &dp){\\n        if(row < 0 or col < 0 or row >= n or col >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[row][col][k] != -1) return dp[row][col][k];\\n        \\n        double ans = 0.0;\\n        \\n        for(int i=0;i<8;i++){\\n            ans += solve(row+iarr[i], col+jarr[i], n, k-1, dp);\\n        }\\n        \\n        return dp[row][col][k] = ans;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<vector<double>>> dp(n+1,vector<vector<double>> (n+1,vector<double> (k+1,-1)));\\n        double fav = solve(row,col,n,k,dp);\\n        double total = pow(8,k);\\n        return fav/total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000200,
                "title": "c-simple-bfs-solution",
                "content": "class Solution {\\npublic:\\n \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        vector<int> dx = {-2,-1,1,2,2,1,-1,-2};\\n        vector<int> dy = {1,2,2,1,-1,-2,-2,-1};\\n        \\n        vector<vector<double>> curr(n,vector<double>(n,0.0));\\n        \\n        curr[row][column] = 1.0;\\n        \\n        for(int m =0;m<k;m++){\\n            vector<vector<double>> next(n,vector<double>(n,0.0));\\n            \\n            for(int i = 0;i<n;i++){\\n                for(int j = 0;j<n;j++){\\n                    if(curr[i][j] != 0.0){\\n                        \\n                        for(int z = 0;z<8;z++){\\n                            int newx = i+dx[z];\\n                            int newy = j+dy[z];\\n                            \\n                            if(newx >= 0 && newx <n && newy >= 0 && newy <n){\\n                                next[newx][newy] += curr[i][j]/8.0;\\n                            }\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            curr = next;       \\n        }\\n        \\n        double ans = 0.0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                ans += curr[i][j];\\n            }\\n        }       \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        vector<int> dx = {-2,-1,1,2,2,1,-1,-2}",
                "codeTag": "Java"
            },
            {
                "id": 1198319,
                "title": "python-solution-with-comments-easy-to-understand-runtime-200-ms-memory-14-2-mb",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        # Define two states, current and next\\n        current = [[0 for _ in range(n)] for _ in range(n)]\\n        next1 = [[0 for _ in range(n)] for _ in range(n)]\\n        current[row][column] = 1\\n        \\n        # Mark all possible moves of a knight in chessboard\\n        all_pos = [(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2),(2,-1),(1,-2)]\\n        \\n        for _ in range(k): # K moves\\n            for i in range(n): # board of size n * n\\n                for j in range(n): # start from cell [0,0] and check if current value is non-zero\\n                    if current[i][j] != 0:\\n                        for pos in all_pos: # For each valid moves from all_pos, add values to next steps\\n                            temp_x = i + pos[0]\\n                            temp_y = j + pos[1]\\n                            if 0 <= temp_x < n and 0 <= temp_y < n: # If the knight is inside the board, then add current value divide by 8. \\n                                next1[temp_x][temp_y] += (current[i][j] / 8) # We divided it by 8 as there are total 8 possibilities\\n            current, next1 = next1, [[0 for _ in range(n)] for _ in range(n)] # Assign next as current and redefine next as empty array. Now, we\\'ll again fill this next array with values of current\\n        \\n\\t\\t# Find total probability of the last state. That\\'ll be current as we just swapped current & next!!\\n        total_sum = 0\\n        for item in current:\\n            total_sum += sum(item)\\n        return total_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        # Define two states, current and next\\n        current = [[0 for _ in range(n)] for _ in range(n)]\\n        next1 = [[0 for _ in range(n)] for _ in range(n)]\\n        current[row][column] = 1\\n        \\n        # Mark all possible moves of a knight in chessboard\\n        all_pos = [(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2),(2,-1),(1,-2)]\\n        \\n        for _ in range(k): # K moves\\n            for i in range(n): # board of size n * n\\n                for j in range(n): # start from cell [0,0] and check if current value is non-zero\\n                    if current[i][j] != 0:\\n                        for pos in all_pos: # For each valid moves from all_pos, add values to next steps\\n                            temp_x = i + pos[0]\\n                            temp_y = j + pos[1]\\n                            if 0 <= temp_x < n and 0 <= temp_y < n: # If the knight is inside the board, then add current value divide by 8. \\n                                next1[temp_x][temp_y] += (current[i][j] / 8) # We divided it by 8 as there are total 8 possibilities\\n            current, next1 = next1, [[0 for _ in range(n)] for _ in range(n)] # Assign next as current and redefine next as empty array. Now, we\\'ll again fill this next array with values of current\\n        \\n\\t\\t# Find total probability of the last state. That\\'ll be current as we just swapped current & next!!\\n        total_sum = 0\\n        for item in current:\\n            total_sum += sum(item)\\n        return total_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168402,
                "title": "simple-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<double>> curr(N,vector<double>(N,0.0));\\n        curr[r][c] = 1.0;\\n        int dirx[] = {-2,-1,1,2,2,1,-1,-2};\\n        int diry[] = {1,2,2,1,-1,-2,-2,-1};\\n        for(int k=0;k<K;k++)\\n        {\\n            vector<vector<double>> next(N,vector<double>(N,0.0));\\n            for(int i = 0;i<N;i++)\\n            {\\n                for(int j = 0;j<N;j++)\\n                {\\n                    if(curr[i][j]!=0)\\n                    {\\n                        for(int a = 0;a<8;a++)\\n                        {\\n                            int cr = i+dirx[a];\\n                            int cc = j+diry[a];\\n                            if ( cr>=0 && cr < N &&  cc>=0 && cc < N) \\n                                next[cr][cc]+=curr[i][j] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            curr=next;\\n        }\\n        double ans = 0.0;\\n        for(int i = 0;i<N;i++)\\n        {\\n            for(int j = 0;j<N;j++)\\n            {\\n                ans+=curr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<double>> curr(N,vector<double>(N,0.0));\\n        curr[r][c] = 1.0;\\n        int dirx[] = {-2,-1,1,2,2,1,-1,-2};\\n        int diry[] = {1,2,2,1,-1,-2,-2,-1};\\n        for(int k=0;k<K;k++)\\n        {\\n            vector<vector<double>> next(N,vector<double>(N,0.0));\\n            for(int i = 0;i<N;i++)\\n            {\\n                for(int j = 0;j<N;j++)\\n                {\\n                    if(curr[i][j]!=0)\\n                    {\\n                        for(int a = 0;a<8;a++)\\n                        {\\n                            int cr = i+dirx[a];\\n                            int cc = j+diry[a];\\n                            if ( cr>=0 && cr < N &&  cc>=0 && cc < N) \\n                                next[cr][cc]+=curr[i][j] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            curr=next;\\n        }\\n        double ans = 0.0;\\n        for(int i = 0;i<N;i++)\\n        {\\n            for(int j = 0;j<N;j++)\\n            {\\n                ans+=curr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110131,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        // DP: define dp[N][N] where dp[i][j] is the probability of staying on the board by K moves.\\n        // We cannot get the probability of K moves immediately, so compute from K == 0 where dp[i][j] = 1.\\n        //\\n        // Then for each k <= K, we have the following formula:\\n        // 1) Get the probabilities of all 8 moves from (i, j), aka dp[i][j].\\n        // 2) Sum them up, and divide the result by 8 because of randomness.\\n        // 3) The probability of new_dp[i][j] = (sum in #2) / 8.\\n        //\\n        // Finally return the ultimate dp[r][c] after K iterations.\\n        vector<vector<double>> dp(N, vector<double>(N, 1));\\n        for (int k = 1; k <= K; ++k)\\n        {\\n            vector<vector<double>> newDP(N, vector<double>(N));\\n            for (int i = 0; i < N; ++i)\\n            {\\n                for (int j = 0; j < N; ++j)\\n                {\\n                    double total = 0;\\n                    total += i >= 2 && j >= 1 ? dp[i - 2][j - 1] : 0;\\n                    total += i >= 2 && j + 1 < N ? dp[i - 2][j + 1] : 0;\\n                    total += i >= 1 && j >= 2 ? dp[i - 1][j - 2] : 0;\\n                    total += i >= 1 && j + 2 < N ? dp[i - 1][j + 2] : 0;\\n                    total += i + 1 < N && j >= 2 ? dp[i + 1][j - 2] : 0;\\n                    total += i + 1 < N && j + 2 < N ? dp[i + 1][j + 2] : 0;\\n                    total += i + 2 < N && j >= 1 ? dp[i + 2][j - 1] : 0;\\n                    total += i + 2 < N && j + 1 < N ? dp[i + 2][j + 1] : 0;\\n                    \\n                    newDP[i][j] = total / 8;\\n                }\\n            }\\n            \\n            dp = newDP;\\n        }\\n        \\n        return dp[r][c];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        // DP: define dp[N][N] where dp[i][j] is the probability of staying on the board by K moves.\\n        // We cannot get the probability of K moves immediately, so compute from K == 0 where dp[i][j] = 1.\\n        //\\n        // Then for each k <= K, we have the following formula:\\n        // 1) Get the probabilities of all 8 moves from (i, j), aka dp[i][j].\\n        // 2) Sum them up, and divide the result by 8 because of randomness.\\n        // 3) The probability of new_dp[i][j] = (sum in #2) / 8.\\n        //\\n        // Finally return the ultimate dp[r][c] after K iterations.\\n        vector<vector<double>> dp(N, vector<double>(N, 1));\\n        for (int k = 1; k <= K; ++k)\\n        {\\n            vector<vector<double>> newDP(N, vector<double>(N));\\n            for (int i = 0; i < N; ++i)\\n            {\\n                for (int j = 0; j < N; ++j)\\n                {\\n                    double total = 0;\\n                    total += i >= 2 && j >= 1 ? dp[i - 2][j - 1] : 0;\\n                    total += i >= 2 && j + 1 < N ? dp[i - 2][j + 1] : 0;\\n                    total += i >= 1 && j >= 2 ? dp[i - 1][j - 2] : 0;\\n                    total += i >= 1 && j + 2 < N ? dp[i - 1][j + 2] : 0;\\n                    total += i + 1 < N && j >= 2 ? dp[i + 1][j - 2] : 0;\\n                    total += i + 1 < N && j + 2 < N ? dp[i + 1][j + 2] : 0;\\n                    total += i + 2 < N && j >= 1 ? dp[i + 2][j - 1] : 0;\\n                    total += i + 2 < N && j + 1 < N ? dp[i + 2][j + 1] : 0;\\n                    \\n                    newDP[i][j] = total / 8;\\n                }\\n            }\\n            \\n            dp = newDP;\\n        }\\n        \\n        return dp[r][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912580,
                "title": "java-short-and-crisp-dfs-with-memorization",
                "content": "```\\nclass Solution {\\n    final int[] rows={2,2,1,1,-2,-2,-1,-1};\\n    final int[] cols={1,-1,2,-2,1,-1,2,-2};\\n    int size;\\n    HashMap<String,Double> memo;\\n    private boolean isValid(int r,int c){\\n        return r>=0 && r<size && c>=0 && c<size;\\n    }\\n    public double knightProbability(int N, int K, int r, int c) {\\n        size=N;\\n        memo=new HashMap();\\n        return dfs(r,c,K);\\n    }\\n    private double dfs(int r,int c,int K){\\n        if(K==0) return 1;\\n        String key=r+\" \"+c+\" \"+K;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        double res=0;\\n        for(int i=0;i<8;i++){\\n            int nr=r+rows[i];\\n            int nc=c+cols[i];\\n            if(isValid(nr,nc)) res+=(dfs(nr,nc,K-1)/8);\\n        }\\n        memo.put(key,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int[] rows={2,2,1,1,-2,-2,-1,-1};\\n    final int[] cols={1,-1,2,-2,1,-1,2,-2};\\n    int size;\\n    HashMap<String,Double> memo;\\n    private boolean isValid(int r,int c){\\n        return r>=0 && r<size && c>=0 && c<size;\\n    }\\n    public double knightProbability(int N, int K, int r, int c) {\\n        size=N;\\n        memo=new HashMap();\\n        return dfs(r,c,K);\\n    }\\n    private double dfs(int r,int c,int K){\\n        if(K==0) return 1;\\n        String key=r+\" \"+c+\" \"+K;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        double res=0;\\n        for(int i=0;i<8;i++){\\n            int nr=r+rows[i];\\n            int nc=c+cols[i];\\n            if(isValid(nr,nc)) res+=(dfs(nr,nc,K-1)/8);\\n        }\\n        memo.put(key,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881372,
                "title": "c-dp-2-methods-bottom-up-and-top-down-easy-to-understand-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    // Bottom-up\\n    // Time: O(N^2 * k)\\n    // Space: O(N^2 * k)\\n    double knightProbability(int N, int K, int r, int c) {\\n        unordered_map<string, double> dp;\\n        for (int i = 0; i <= K; i++) {\\n            for (int j = 0; j < N; j++) {\\n                for (int k = 0; k < N; k++) {\\n                    for (auto dir : dirs) {\\n                        int new_j = j + dir[0];\\n                        int new_k = k + dir[1];\\n                        string key = to_string(i) + \"#\" + to_string(j) + \"#\" + to_string(k);\\n                        string key2 = to_string(i - 1) + \"#\" + to_string(new_j) + \"#\" + to_string(new_k);\\n                        if (i == 0) dp[key] = 1.0;\\n                        else if (new_j >= 0 && new_j < N && new_k >= 0 && new_k < N)\\n                            dp[key] += (1 / 8.0) * dp[key2];\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        string key = to_string(K) + \"#\" + to_string(r) + \"#\" + to_string(c);\\n        return dp[key];\\n    }\\nprivate:    \\n    vector<vector<int>> dirs =\\n        {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n};\\n\\n\\nclass Solution2 {\\npublic:\\n    // Top-down\\n    // Time: O(N^2 * k)\\n    // Space: O(N^2 * k)\\n    double knightProbability(int N, int K, int r, int c) {\\n        return helper(N, K, r, c);\\n    }\\n    double helper(int N, int K, int r, int c) {\\n        if (r >= N || r < 0 || c >= N || c < 0) return 0.0;\\n        if (K == 0) return 1.0;\\n        string key = to_string(K) + \"#\" + to_string(r) + \"#\" + to_string(c);\\n        if (dp.count(key)) return dp[key];\\n        double res = 0;\\n        for (auto dir : dirs) {\\n            int new_r = r + dir[0];\\n            int new_c = c + dir[1];\\n            res += (1 / 8.0) * helper(N, K - 1, new_r, new_c);\\n        }\\n        dp[key] = res;\\n        return res;\\n    }\\nprivate:\\n    unordered_map<string, double> dp;\\n    vector<vector<int>> dirs =\\n        {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Bottom-up\\n    // Time: O(N^2 * k)\\n    // Space: O(N^2 * k)\\n    double knightProbability(int N, int K, int r, int c) {\\n        unordered_map<string, double> dp;\\n        for (int i = 0; i <= K; i++) {\\n            for (int j = 0; j < N; j++) {\\n                for (int k = 0; k < N; k++) {\\n                    for (auto dir : dirs) {\\n                        int new_j = j + dir[0];\\n                        int new_k = k + dir[1];\\n                        string key = to_string(i) + \"#\" + to_string(j) + \"#\" + to_string(k);\\n                        string key2 = to_string(i - 1) + \"#\" + to_string(new_j) + \"#\" + to_string(new_k);\\n                        if (i == 0) dp[key] = 1.0;\\n                        else if (new_j >= 0 && new_j < N && new_k >= 0 && new_k < N)\\n                            dp[key] += (1 / 8.0) * dp[key2];\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        string key = to_string(K) + \"#\" + to_string(r) + \"#\" + to_string(c);\\n        return dp[key];\\n    }\\nprivate:    \\n    vector<vector<int>> dirs =\\n        {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n};\\n\\n\\nclass Solution2 {\\npublic:\\n    // Top-down\\n    // Time: O(N^2 * k)\\n    // Space: O(N^2 * k)\\n    double knightProbability(int N, int K, int r, int c) {\\n        return helper(N, K, r, c);\\n    }\\n    double helper(int N, int K, int r, int c) {\\n        if (r >= N || r < 0 || c >= N || c < 0) return 0.0;\\n        if (K == 0) return 1.0;\\n        string key = to_string(K) + \"#\" + to_string(r) + \"#\" + to_string(c);\\n        if (dp.count(key)) return dp[key];\\n        double res = 0;\\n        for (auto dir : dirs) {\\n            int new_r = r + dir[0];\\n            int new_c = c + dir[1];\\n            res += (1 / 8.0) * helper(N, K - 1, new_r, new_c);\\n        }\\n        dp[key] = res;\\n        return res;\\n    }\\nprivate:\\n    unordered_map<string, double> dp;\\n    vector<vector<int>> dirs =\\n        {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717563,
                "title": "dfs-memoization-with-full-explanation",
                "content": "**Idea:**\\n* Base condition: If k == 0, return `1.0` because the night will remain on board for sure without any movement.\\n* Now, make one movement to a valid position, so, the probability for the knight to stay on board is `1.0 / 8.0`.\\n* From this new position, calculate the probability to remain on board with `k-1` movements remaining. Hence, we need to go in recursion. Multiply this answer with `1 / 8` because the events are linked. \\n* Iterate over all \"valid\" new positions and calculate `(1 / 8) * probabilityWithK-1MovesFromNewPos`, and sum it up. Here we are adding the results rather than multiplying because the events are \"mutually exclusive\" from other valid positions. \\n* Introduce the memoization. Because we may end up coming the same position with same number of moves remaining. if that\\'s the case, return the cached result.\\n\\n```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        Map<String, Double> cache = new HashMap<>();\\n        int[][] dirs = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n        return helper(N, K, r, c, dirs, cache);\\n        \\n    }\\n\\n    private double helper(int n, int k, int r, int c, int[][] dirs, Map<String, Double> cache) {\\n        if (k == 0) {\\n            return 1.0;\\n        }\\n        \\n        String key = r + \",\" + c + \",\" + k;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        double p = 0.0;\\n        for (int[] dir : dirs) {\\n            int nextR = r + dir[0],\\n                nextC = c + dir[1];\\n            \\n            if (isValid(n, nextR, nextC)) {\\n                p += (1.0 / 8.0) * helper(n, k-1, nextR, nextC, dirs, cache);\\n            }\\n        }\\n        \\n        cache.put(key, p);\\n        return p;\\n    }\\n    \\n    private boolean isValid(int n, int x, int y) {\\n        return x >= 0  && x < n && y >= 0 && y < n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        Map<String, Double> cache = new HashMap<>();\\n        int[][] dirs = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n        return helper(N, K, r, c, dirs, cache);\\n        \\n    }\\n\\n    private double helper(int n, int k, int r, int c, int[][] dirs, Map<String, Double> cache) {\\n        if (k == 0) {\\n            return 1.0;\\n        }\\n        \\n        String key = r + \",\" + c + \",\" + k;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        double p = 0.0;\\n        for (int[] dir : dirs) {\\n            int nextR = r + dir[0],\\n                nextC = c + dir[1];\\n            \\n            if (isValid(n, nextR, nextC)) {\\n                p += (1.0 / 8.0) * helper(n, k-1, nextR, nextC, dirs, cache);\\n            }\\n        }\\n        \\n        cache.put(key, p);\\n        return p;\\n    }\\n    \\n    private boolean isValid(int n, int x, int y) {\\n        return x >= 0  && x < n && y >= 0 && y < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617603,
                "title": "python-4-solutions-with-dfs-bfs-dp-and-space-optimized-dp",
                "content": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        # DFS\\n        mem = [[[-1] * N for _ in range(N)] for _ in range(K + 1)]\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        \\n        def helper(i, j, k):\\n            if k == 0:\\n                mem[k][i][j] = 1\\n                return mem[k][i][j]\\n            if mem[k][i][j] != -1:\\n                return mem[k][i][j]\\n            \\n            rst = 0\\n            for off in range(8):\\n                next_i, next_j = i + offsets[off][0], j + offsets[off][1]\\n                if 0 <= next_i < N and 0 <= next_j < N:\\n                    rst += 0.125 * helper(next_i, next_j, k - 1)\\n            mem[k][i][j] = rst\\n            return mem[k][i][j]\\n            \\n        return helper(r, c, K)\\n        \\n        # BFS\\n        if K == 0:\\n            return 1\\n        \\n        dp = [[[0] * N for _ in range(N)] for _ in range(K + 1)]\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        dp[0][r][c], k, q = 1, 1, deque([(r, c)]) \\n        \\n        while q and k <= K:\\n            rst, seen = 0, set()\\n            for _ in range(len(q)):\\n                i, j = q.popleft()\\n                prev_prob = dp[k - 1][i][j]\\n                for off in range(8):\\n                    cur_i, cur_j = i + offsets[off][0], j + offsets[off][1]\\n                    if 0 <= cur_i < N and 0 <= cur_j < N:\\n                        dp[k][cur_i][cur_j] +=  prev_prob * 0.125\\n                        rst += prev_prob * 0.125\\n                        if cur_i * N + cur_j not in seen:\\n                            q.append((cur_i, cur_j))\\n                            seen.add(cur_i * N + cur_j)\\n            k += 1\\n        return rst                        \\n        \\n        # DP\\n        dp = [[[0] * N for _ in range(N)] for _ in range(K + 1)]\\n        dp[0][r][c] = 1\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        \\n        for k in range(1, K + 1):\\n            for i in range(N):\\n                for j in range(N):\\n                    for off in range(8):\\n                        prev_i, prev_j = i + offsets[off][0], j + offsets[off][1]\\n                        if 0 <= prev_i < N and 0 <= prev_j < N:\\n                            dp[k][i][j] += 0.125 * dp[k - 1][prev_i][prev_j]\\n        return sum([sum(row) for row in dp[K]])\\n```\\n\\nOptimized the DP space from `O(K * N * N)` to `O(2 * N * N)`:\\n```\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        # dp[k][i][j]: at step k, probability of cell[i][j] being visited\\n        dp = [[[0] * N for __ in xrange(N)] for _ in xrange(2)]\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        dp[0][r][c] = 1\\n        for k in xrange(1, K + 1):\\n            dp[k % 2] = [[0] * N for _ in xrange(N)]\\n            for i in xrange(N):\\n                for j in xrange(N):\\n                    if dp[(k - 1) % 2][i][j] != 0:\\n                        for off in offsets:\\n                            if 0 <= i + off[0] < N and 0 <= j + off[1] < N:\\n                                dp[k % 2][i + off[0]][j + off[1]] += dp[(k - 1) % 2][i][j] / 8.0\\n        return sum([sum(row) for row in dp[K % 2]])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        # DFS\\n        mem = [[[-1] * N for _ in range(N)] for _ in range(K + 1)]\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        \\n        def helper(i, j, k):\\n            if k == 0:\\n                mem[k][i][j] = 1\\n                return mem[k][i][j]\\n            if mem[k][i][j] != -1:\\n                return mem[k][i][j]\\n            \\n            rst = 0\\n            for off in range(8):\\n                next_i, next_j = i + offsets[off][0], j + offsets[off][1]\\n                if 0 <= next_i < N and 0 <= next_j < N:\\n                    rst += 0.125 * helper(next_i, next_j, k - 1)\\n            mem[k][i][j] = rst\\n            return mem[k][i][j]\\n            \\n        return helper(r, c, K)\\n        \\n        # BFS\\n        if K == 0:\\n            return 1\\n        \\n        dp = [[[0] * N for _ in range(N)] for _ in range(K + 1)]\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        dp[0][r][c], k, q = 1, 1, deque([(r, c)]) \\n        \\n        while q and k <= K:\\n            rst, seen = 0, set()\\n            for _ in range(len(q)):\\n                i, j = q.popleft()\\n                prev_prob = dp[k - 1][i][j]\\n                for off in range(8):\\n                    cur_i, cur_j = i + offsets[off][0], j + offsets[off][1]\\n                    if 0 <= cur_i < N and 0 <= cur_j < N:\\n                        dp[k][cur_i][cur_j] +=  prev_prob * 0.125\\n                        rst += prev_prob * 0.125\\n                        if cur_i * N + cur_j not in seen:\\n                            q.append((cur_i, cur_j))\\n                            seen.add(cur_i * N + cur_j)\\n            k += 1\\n        return rst                        \\n        \\n        # DP\\n        dp = [[[0] * N for _ in range(N)] for _ in range(K + 1)]\\n        dp[0][r][c] = 1\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        \\n        for k in range(1, K + 1):\\n            for i in range(N):\\n                for j in range(N):\\n                    for off in range(8):\\n                        prev_i, prev_j = i + offsets[off][0], j + offsets[off][1]\\n                        if 0 <= prev_i < N and 0 <= prev_j < N:\\n                            dp[k][i][j] += 0.125 * dp[k - 1][prev_i][prev_j]\\n        return sum([sum(row) for row in dp[K]])\\n```\n```\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        # dp[k][i][j]: at step k, probability of cell[i][j] being visited\\n        dp = [[[0] * N for __ in xrange(N)] for _ in xrange(2)]\\n        offsets = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]]\\n        dp[0][r][c] = 1\\n        for k in xrange(1, K + 1):\\n            dp[k % 2] = [[0] * N for _ in xrange(N)]\\n            for i in xrange(N):\\n                for j in xrange(N):\\n                    if dp[(k - 1) % 2][i][j] != 0:\\n                        for off in offsets:\\n                            if 0 <= i + off[0] < N and 0 <= j + off[1] < N:\\n                                dp[k % 2][i + off[0]][j + off[1]] += dp[(k - 1) % 2][i][j] / 8.0\\n        return sum([sum(row) for row in dp[K % 2]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599887,
                "title": "java-bfs-solution",
                "content": "Although mang DP solutions are posted, I\\'d like to post my BFS solution here.\\n```java\\npublic class Solution {\\n\\n    private int[][]dir = new int[][]{{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n\\n    class Pair {\\n        public int x;\\n        public int y;\\n\\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Pair pair = (Pair) o;\\n            return x == pair.x && y == pair.y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n\\n    }\\n\\n    public double knightProbability(int N, int K, int r, int c) {\\n        Map<Pair, Double> cur = new HashMap<>(), next = new HashMap<>();\\n        cur.put(new Pair(r, c), 1.0);\\n        int t = K;\\n        while (t-- > 0) {\\n            for (Map.Entry<Pair, Double> point : cur.entrySet()) {\\n                int x = point.getKey().x, y = point.getKey().y;\\n                double value = point.getValue();\\n                for (int[] d : dir) {\\n                    int i = x + d[0];\\n                    int j = y + d[1];\\n                    if (i < 0 || i > N - 1 || j < 0 || j > N - 1) {\\n                        continue;\\n                    }\\n                    Pair tmp = new Pair(i, j);\\n                    next.put(tmp, next.getOrDefault(tmp, 0.0) + value);\\n                }\\n            }\\n            Map<Pair, Double> map = cur;\\n            cur = next;\\n            next = map;\\n            next.clear();\\n        }\\n        double count = 0;\\n        for (Double v : cur.values()) {\\n            count += v;\\n        }\\n        return count / Math.pow(8, K);\\n    }\\n}",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\n    private int[][]dir = new int[][]{{-2,-1}",
                "codeTag": "Java"
            },
            {
                "id": 571626,
                "title": "c-accumulate-probabilities",
                "content": "```cpp\\nvector<pair<int, int>> jumps = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\ndouble knightProbability(int N, int K, int r, int c) {\\n    vector<vector<double>> b(N, vector<double>(N, 1));\\n    while (--K >= 0) {\\n        vector<vector<double>> b1(N, vector<double>(N));\\n        for (auto i = 0; i < N; ++i)\\n            for (auto j = 0; j < N; ++j) {\\n                if (b[i][j] == 0)\\n                    continue;\\n                auto p = b[i][j] / 8;\\n                for (auto [di, dj] : jumps)\\n                    if (i + di >= 0 && j + dj >= 0 && i + di < N && j + dj < N)\\n                        b1[i + di][j + dj] += p;\\n            }\\n        swap(b, b1);\\n    }\\n    return b[r][c];\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * n * k)\\n- Memory: O(n * n)",
                "solutionTags": [],
                "code": "```cpp\\nvector<pair<int, int>> jumps = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\ndouble knightProbability(int N, int K, int r, int c) {\\n    vector<vector<double>> b(N, vector<double>(N, 1));\\n    while (--K >= 0) {\\n        vector<vector<double>> b1(N, vector<double>(N));\\n        for (auto i = 0; i < N; ++i)\\n            for (auto j = 0; j < N; ++j) {\\n                if (b[i][j] == 0)\\n                    continue;\\n                auto p = b[i][j] / 8;\\n                for (auto [di, dj] : jumps)\\n                    if (i + di >= 0 && j + dj >= 0 && i + di < N && j + dj < N)\\n                        b1[i + di][j + dj] += p;\\n            }\\n        swap(b, b1);\\n    }\\n    return b[r][c];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451058,
                "title": "python-recursive-dp-solution-with-explanation",
                "content": "Define `dp(r, c, k)` as the probability that the knight on `(r, c)` remains on the board after `k` moves.\\nWe\\'ll get the recursion below:\\n`dp(r, c, k) = sum_for_allowed_moves(dp(r_new, c_new, k - 1)) / 8`\\n\\n```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        @lru_cache(None)\\n        def dp(r, c, k):\\n            if r < 0 or r >= N or c < 0 or c >= N:\\n                return 0\\n            elif k <= 0:\\n                return 1\\n            res = 0\\n            for a, b in [(2, 1), (-2, -1), (2, -1), (-2, 1)]:\\n                res += dp(r + a, c + b, k - 1)\\n                res += dp(r + b, c + a, k - 1)\\n            return res / 8\\n        \\n        return dp(r, c, K)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        @lru_cache(None)\\n        def dp(r, c, k):\\n            if r < 0 or r >= N or c < 0 or c >= N:\\n                return 0\\n            elif k <= 0:\\n                return 1\\n            res = 0\\n            for a, b in [(2, 1), (-2, -1), (2, -1), (-2, 1)]:\\n                res += dp(r + a, c + b, k - 1)\\n                res += dp(r + b, c + a, k - 1)\\n            return res / 8\\n        \\n        return dp(r, c, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199003,
                "title": "javascript-dp",
                "content": "```\\nvar knightProbability = function(N, K, r, c) {\\n    \\n    const dp = new Array(N);\\n    const movesR = [2,2,-2,-2,1,1,-1,-1];\\n    const movesC = [1,-1,1,-1,2,-2,2,-2]; \\n    \\n    for(let col = 0; col < dp.length; col++) {\\n        dp[col] = new Array(N);\\n        for(let k = 0; k < dp[col].length; k++) {\\n            dp[col][k] = [1]; // 0 move has 100% of staying on the board\\n        }\\n    }\\n    \\n    for(let s = 1; s < K + 1; s++) {\\n        for(let i = 0; i < N; i++) {\\n            for(let j = 0; j < N; j++) {\\n                let probability = 0.0;\\n                for(let m = 0; m < 8; m++) {\\n                    const nextRow = i + movesR[m];\\n                    const nextCol = j + movesC[m];\\n                    if(nextRow >= 0 && nextRow < N && nextCol >= 0 && nextCol < N) {\\n                        probability += dp[nextRow][nextCol][s-1]/8.0; // % of chance out of 8 moves\\n                    }\\n                }\\n                dp[i][j][s] = probability;\\n            }\\n        }\\n    }\\n    \\n    return dp[r][c][K];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar knightProbability = function(N, K, r, c) {\\n    \\n    const dp = new Array(N);\\n    const movesR = [2,2,-2,-2,1,1,-1,-1];\\n    const movesC = [1,-1,1,-1,2,-2,2,-2]; \\n    \\n    for(let col = 0; col < dp.length; col++) {\\n        dp[col] = new Array(N);\\n        for(let k = 0; k < dp[col].length; k++) {\\n            dp[col][k] = [1]; // 0 move has 100% of staying on the board\\n        }\\n    }\\n    \\n    for(let s = 1; s < K + 1; s++) {\\n        for(let i = 0; i < N; i++) {\\n            for(let j = 0; j < N; j++) {\\n                let probability = 0.0;\\n                for(let m = 0; m < 8; m++) {\\n                    const nextRow = i + movesR[m];\\n                    const nextCol = j + movesC[m];\\n                    if(nextRow >= 0 && nextRow < N && nextCol >= 0 && nextCol < N) {\\n                        probability += dp[nextRow][nextCol][s-1]/8.0; // % of chance out of 8 moves\\n                    }\\n                }\\n                dp[i][j][s] = probability;\\n            }\\n        }\\n    }\\n    \\n    return dp[r][c][K];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 198646,
                "title": "javascript-dfs-with-memoization",
                "content": "```\\nvar knightProbability = function(N, K, r, c) {\\n    \\n    const memo = {};\\n    \\n    function dfs(row, col, moves) {\\n        \\n        const key = `${moves}:${row}:${col}`;\\n        \\n        if(memo[key]) {\\n            return memo[key];\\n        }\\n        \\n        if(row < 0 ||\\n           row >= N ||\\n           col < 0 ||\\n           col >= N\\n        ) {\\n            return 0;\\n        }\\n        \\n        if(moves === 0) {\\n            return 1;\\n        }\\n        \\n        let inbound = 0;\\n        \\n        inbound += dfs(row-2, col-1, moves-1);\\n        inbound += dfs(row-1, col-2, moves-1);\\n        inbound += dfs(row+1, col-2, moves-1);\\n        inbound += dfs(row+2, col-1, moves-1);\\n        \\n        inbound += dfs(row-2, col+1, moves-1);\\n        inbound += dfs(row-1, col+2, moves-1);\\n        inbound += dfs(row+1, col+2, moves-1);\\n        inbound += dfs(row+2, col+1, moves-1);\\n        \\n        memo[key] = inbound;\\n        \\n        return inbound;\\n        \\n    } \\n    \\n    let onboard = dfs(r, c, K);\\n    return onboard/Math.pow(8,K);\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar knightProbability = function(N, K, r, c) {\\n    \\n    const memo = {};\\n    \\n    function dfs(row, col, moves) {\\n        \\n        const key = `${moves}:${row}:${col}`;\\n        \\n        if(memo[key]) {\\n            return memo[key];\\n        }\\n        \\n        if(row < 0 ||\\n           row >= N ||\\n           col < 0 ||\\n           col >= N\\n        ) {\\n            return 0;\\n        }\\n        \\n        if(moves === 0) {\\n            return 1;\\n        }\\n        \\n        let inbound = 0;\\n        \\n        inbound += dfs(row-2, col-1, moves-1);\\n        inbound += dfs(row-1, col-2, moves-1);\\n        inbound += dfs(row+1, col-2, moves-1);\\n        inbound += dfs(row+2, col-1, moves-1);\\n        \\n        inbound += dfs(row-2, col+1, moves-1);\\n        inbound += dfs(row-1, col+2, moves-1);\\n        inbound += dfs(row+1, col+2, moves-1);\\n        inbound += dfs(row+2, col+1, moves-1);\\n        \\n        memo[key] = inbound;\\n        \\n        return inbound;\\n        \\n    } \\n    \\n    let onboard = dfs(r, c, K);\\n    return onboard/Math.pow(8,K);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184957,
                "title": "python3-fastest-solution-88ms-beats-100-o-kn-2-time-o-n-2-space-with-explanation",
                "content": "It\\'s not quite as pretty/elegant as I\\'d like it to be, but it beats the fastest visible solution (currently 96ms) in the submissions histogram; maybe someone better at Python can make it prettier and still retain the speed:\\n```python\\ndef knightProbability(self, N, K, r, c): # 88ms, beats 100%\\n    if not K: return 1.\\n    def helper(i, j):\\n        if not 0 <= i < N or not 0 <= j < N: return 0\\n        if N - 1 < 2 * i: i = N - 1 - i\\n        if N - 1 < 2 * j: j = N - 1 - j\\n        if j < i: i, j = j, i\\n        return back[i][j]\\n    moves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n    half = N + 1 >> 1\\n    back = [[1 for j in range(half)] for i in range(half)]\\n    front = [[0 for j in range(half)] for i in range(half)]\\n    for k in range(K - 1):\\n        for i in range(half):\\n            for j in range(i, half):\\n                front[i][j] = sum(helper(i + di, j + dj) for di, dj in moves) / 8\\n        front, back = back, front\\n    return sum(helper(r + di, c + dj) for di, dj in moves) / 8\\n```\\n---\\n\\n### Explanation\\n\\nMy original solution:\\n```python\\ndef knightProbability(self, N, K, r, c): # 144ms, beats 99%\\n    def helper(i, j):\\n        if not 0 <= i < N or not 0 <= j < N: return 0\\n        i, j = sorted((min(i, N - 1 - i), min(j, N - 1 - j)))\\n        return back[i][j]\\n    moves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n    half = N + 1 >> 1\\n    back = [[1 for j in range(half)] for i in range(half)]\\n    front = [[0 for j in range(half)] for i in range(half)]\\n    for k in range(K):\\n        for i in range(half):\\n            for j in range(i, half):\\n                front[i][j] = sum(helper(i + di, j + dj) for di, dj in moves) / 8\\n        front, back = back, front\\n    return helper(r, c)\\n```\\nThere\\'s no real deep insight, honestly. The first optimization is just to exploit the symmetry of the board to cut the work down by a factor of approximately 8. Example: For `N = 6`, we don\\'t actually need to figure out the probabilities for all 36 spots on the board; it suffices to figure out the probabilities in this little triangle, which is approximately 1/8 the size of the entire board:\\n```abc\\n+---+---+---+---+---+---+\\n| x | x | x |   |   |   |\\n+---+---+---+---+---+---+\\n|   | x | x |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   | x |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   |   |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   |   |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   |   |   |   |   |\\n+---+---+---+---+---+---+\\n```\\nOnce we figure out the probabilites for the spots marked `x` above, the probabilities for the rest of the board can be deduced from symmetry:\\n```abc\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n| A | B | C |   |   |   |      | A | B | C | C | B | A |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   | D | E |   |   |   |      | B | D | E | E | D | B |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   |   | F |   |   |   |      | C | E | F | F | E | C |\\n+---+---+---+---+---+---+  =>  +---+---+---+---+---+---+\\n|   |   |   |   |   |   |      | C | E | F | F | E | C |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   |   |   |   |   |   |      | B | D | E | E | D | B |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   |   |   |   |   |   |      | A | B | C | C | B | A |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n```\\n`helper`\\'s job is to take an arbitrary `(i, j)` coordinate on the board, normalize it to one of the coordinates in the little triangle, then return its probability.\\n\\nThe second optimization is a pretty common trick: Use double-buffering (`front`, `back`) to reduce space usage from O(KN^2) to O(N^2).\\n\\nThe third micro-optimization (used only in the 88ms code) is that we don\\'t have to compute the probabilities for all slots on the board for the `K`th step. We only need the probability for the `(r, c)` slot, so we terminate our main loop after `K - 1` steps, then compute the probability for just the `(r, c)` slot for the `K`th step.",
                "solutionTags": [],
                "code": "```python\\ndef knightProbability(self, N, K, r, c): # 88ms, beats 100%\\n    if not K: return 1.\\n    def helper(i, j):\\n        if not 0 <= i < N or not 0 <= j < N: return 0\\n        if N - 1 < 2 * i: i = N - 1 - i\\n        if N - 1 < 2 * j: j = N - 1 - j\\n        if j < i: i, j = j, i\\n        return back[i][j]\\n    moves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n    half = N + 1 >> 1\\n    back = [[1 for j in range(half)] for i in range(half)]\\n    front = [[0 for j in range(half)] for i in range(half)]\\n    for k in range(K - 1):\\n        for i in range(half):\\n            for j in range(i, half):\\n                front[i][j] = sum(helper(i + di, j + dj) for di, dj in moves) / 8\\n        front, back = back, front\\n    return sum(helper(r + di, c + dj) for di, dj in moves) / 8\\n```\n```python\\ndef knightProbability(self, N, K, r, c): # 144ms, beats 99%\\n    def helper(i, j):\\n        if not 0 <= i < N or not 0 <= j < N: return 0\\n        i, j = sorted((min(i, N - 1 - i), min(j, N - 1 - j)))\\n        return back[i][j]\\n    moves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n    half = N + 1 >> 1\\n    back = [[1 for j in range(half)] for i in range(half)]\\n    front = [[0 for j in range(half)] for i in range(half)]\\n    for k in range(K):\\n        for i in range(half):\\n            for j in range(i, half):\\n                front[i][j] = sum(helper(i + di, j + dj) for di, dj in moves) / 8\\n        front, back = back, front\\n    return helper(r, c)\\n```\n```abc\\n+---+---+---+---+---+---+\\n| x | x | x |   |   |   |\\n+---+---+---+---+---+---+\\n|   | x | x |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   | x |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   |   |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   |   |   |   |   |\\n+---+---+---+---+---+---+\\n|   |   |   |   |   |   |\\n+---+---+---+---+---+---+\\n```\n```abc\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n| A | B | C |   |   |   |      | A | B | C | C | B | A |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   | D | E |   |   |   |      | B | D | E | E | D | B |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   |   | F |   |   |   |      | C | E | F | F | E | C |\\n+---+---+---+---+---+---+  =>  +---+---+---+---+---+---+\\n|   |   |   |   |   |   |      | C | E | F | F | E | C |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   |   |   |   |   |   |      | B | D | E | E | D | B |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n|   |   |   |   |   |   |      | A | B | C | C | B | A |\\n+---+---+---+---+---+---+      +---+---+---+---+---+---+\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 164622,
                "title": "java-ac-dp-solution",
                "content": "```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][] dp = new double[N][N];\\n        double[][] dp2 = new double[N][N];\\n        double constaProb = 0.125;\\n        int[][] moves = {{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n        dp[r][c] = 1.0;\\n        double totProb = 1.0;\\n        for (int k = 1; k <= K; k++) {\\n            totProb = 0.0;\\n            dp2 = new double[N][N];\\n            for (int i = 0; i < N; i++) {\\n                for (int j = 0; j < N; j++) {\\n                    for (int move = 0; move < moves.length; move++) {\\n                        int pr = i + moves[move][0];\\n                        int pc = j + moves[move][1];\\n                        if (pr < 0 || pc < 0 || pr >= N || pc >= N) {\\n                            continue;\\n                        }\\n                        dp2[i][j] += constaProb * dp[pr][pc];\\n                    }\\n                    totProb += dp2[i][j];\\n                }\\n            }\\n            dp = dp2;\\n        }\\n        return totProb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double[][] dp = new double[N][N];\\n        double[][] dp2 = new double[N][N];\\n        double constaProb = 0.125;\\n        int[][] moves = {{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}};\\n        dp[r][c] = 1.0;\\n        double totProb = 1.0;\\n        for (int k = 1; k <= K; k++) {\\n            totProb = 0.0;\\n            dp2 = new double[N][N];\\n            for (int i = 0; i < N; i++) {\\n                for (int j = 0; j < N; j++) {\\n                    for (int move = 0; move < moves.length; move++) {\\n                        int pr = i + moves[move][0];\\n                        int pc = j + moves[move][1];\\n                        if (pr < 0 || pc < 0 || pr >= N || pc >= N) {\\n                            continue;\\n                        }\\n                        dp2[i][j] += constaProb * dp[pr][pc];\\n                    }\\n                    totProb += dp2[i][j];\\n                }\\n            }\\n            dp = dp2;\\n        }\\n        return totProb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804672,
                "title": "beginner-friendly-code-explanation-for-each-line-is-given-in-the-editor-peace-at-the-end",
                "content": "# Support\\nIf you liked my approach and explanation, kindly upvote, or comment your views. Happy Learning! Peace!\\n# Intuition\\nSimply add the probability(value) of moves for eack \\'k\\' in a 2D Array, finally sum the values up, you will find the answer. Array updation is important for each \\'k\\' moves\\n# Requirements\\nPlease use \"Debugger\" or \"Pen and Paper\" for better understanding of work-flow.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n\\n        //CREATING DOUBLE TYPE 2D ARRAYS TO STORE THE PROBABILITY VALUES IN DOUBLE. THESE ARRAYS WILL HAVE THE PROBABILITY VALUES OF FUTURE MOVES OF KNIGHT.\\n        double [][] curr = new double[n][n];\\n        double [][] next = new double[n][n];\\n        curr[row][column] = 1;  //INITIALLY, THE PLACE WHERE THE KNIGHT IS PRESENT (i.e. AT r, c position) will be marked as \\'1\\' - denotes success.\\n\\n        for (int t = 0; t < k; t++) { //LOOP UNTIL \\'k\\' TIMES (k MOVES)\\n            \\n            //NOW CHECK IF THE VALUE IN curr ARRAY IS NOT EQUAL TO \\'0.0\\'. (note: by default, all the values will be 0.0 in both arrays.\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (curr[i][j] != 0) \\n                    {\\n                        //THE BELOW 8 BLOCKS ARE JUST TO EVALUATE THE VALID MOVES OF KNIGHT FROM THE PLACE IT IS PRESENT.\\n                        //ni and nj are the variables that contains the possible moves.\\n                        // isValid() WILL EVALUATE IF ni AND nj ARE PRESENT INSIDE THE CHESS BOARD RANGE AND ARE NON-NEGATIVE. IF THEY ARE NEGATIVE OR GREATER THAN \\'n\\' VALUE, THEN THE KNIGHT WOULD BE OUTSIDE THE CHESS-BOARD.\\n                        \\n                        int ni = i - 2;\\n                        int nj = j - 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0; //DIVIDE BY 8, BECAUSE NUMBER OF POSSIBLE SUCCESSFUL EVENTS FOR KNIGHT ARE 8.\\n                            //(NOTE: LOOK AT THIS COMMENT WHEN k = 2 OR GREATER). WHEN K =2, WE ADD THE VALUE TO next ARRAY AS ((1/8.0)/8.0). THIS IS BECAUSE, WHEN k = 1, THE POSSIBLE MOVES WERE MARKED AS (1/8.0), WHEN k = 2 OR MORE, THE DIVISION WITH 1/8.0 KEEPS ON GOING.\\n                            //THIS IS BECAUSE, THE KNIGHT HAS 7 OTHER POSSIBLE WAYS, IT WOULD HAVE CHOSEN ANY OF THOSE PATHWAYS. TO CONCLUDE THAT IT WILL CHOOSE ONLY ONE PATHWAY, THE PROBABILITY OF SUCCESS MOVES DECREASES FURTHER, AS WE CONSIDER A SINGLE PATH.\\n\\n\\n                        }\\n                         ni = i - 1;\\n                         nj = j - 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 1;\\n                         nj = j - 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 2;\\n                         nj = j - 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i - 2;\\n                         nj = j + 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i - 1;\\n                         nj = j + 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 1;\\n                         nj = j + 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 2;\\n                         nj = j + 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            //IMAGINE THIS LIKE, IF THE VALUES AT \"curr\" ARRAY ARE GREATER THAN 0, THEN IT IS OBVIOUS THAT \\'KNIGHT\\' IS PRESENT IN THAT POSITION. TAKING THIS POSITION AS REFERENCE, WE MARK THE POSSIBLE MOVES IN \"next\" ARRAY.\\n            \\n            curr = next;\\n            //\"curr\" ARRAY ACTUALLY CONTAINS THE FINAL PROBABILITY ARRAY AT k MOVES.\\n            next = new double[n][n];\\n        }\\n\\n        double sum = 0;\\n        //FINALYY ADD THE VALUES AND RETURN THEM.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sum += curr[i][j];\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n\\n    static boolean isValid(int ni, int nj, int n) {\\n        if (ni >= 0 && nj >= 0 && ni < n && nj < n) return true;\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n\\n        //CREATING DOUBLE TYPE 2D ARRAYS TO STORE THE PROBABILITY VALUES IN DOUBLE. THESE ARRAYS WILL HAVE THE PROBABILITY VALUES OF FUTURE MOVES OF KNIGHT.\\n        double [][] curr = new double[n][n];\\n        double [][] next = new double[n][n];\\n        curr[row][column] = 1;  //INITIALLY, THE PLACE WHERE THE KNIGHT IS PRESENT (i.e. AT r, c position) will be marked as \\'1\\' - denotes success.\\n\\n        for (int t = 0; t < k; t++) { //LOOP UNTIL \\'k\\' TIMES (k MOVES)\\n            \\n            //NOW CHECK IF THE VALUE IN curr ARRAY IS NOT EQUAL TO \\'0.0\\'. (note: by default, all the values will be 0.0 in both arrays.\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (curr[i][j] != 0) \\n                    {\\n                        //THE BELOW 8 BLOCKS ARE JUST TO EVALUATE THE VALID MOVES OF KNIGHT FROM THE PLACE IT IS PRESENT.\\n                        //ni and nj are the variables that contains the possible moves.\\n                        // isValid() WILL EVALUATE IF ni AND nj ARE PRESENT INSIDE THE CHESS BOARD RANGE AND ARE NON-NEGATIVE. IF THEY ARE NEGATIVE OR GREATER THAN \\'n\\' VALUE, THEN THE KNIGHT WOULD BE OUTSIDE THE CHESS-BOARD.\\n                        \\n                        int ni = i - 2;\\n                        int nj = j - 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0; //DIVIDE BY 8, BECAUSE NUMBER OF POSSIBLE SUCCESSFUL EVENTS FOR KNIGHT ARE 8.\\n                            //(NOTE: LOOK AT THIS COMMENT WHEN k = 2 OR GREATER). WHEN K =2, WE ADD THE VALUE TO next ARRAY AS ((1/8.0)/8.0). THIS IS BECAUSE, WHEN k = 1, THE POSSIBLE MOVES WERE MARKED AS (1/8.0), WHEN k = 2 OR MORE, THE DIVISION WITH 1/8.0 KEEPS ON GOING.\\n                            //THIS IS BECAUSE, THE KNIGHT HAS 7 OTHER POSSIBLE WAYS, IT WOULD HAVE CHOSEN ANY OF THOSE PATHWAYS. TO CONCLUDE THAT IT WILL CHOOSE ONLY ONE PATHWAY, THE PROBABILITY OF SUCCESS MOVES DECREASES FURTHER, AS WE CONSIDER A SINGLE PATH.\\n\\n\\n                        }\\n                         ni = i - 1;\\n                         nj = j - 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 1;\\n                         nj = j - 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 2;\\n                         nj = j - 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i - 2;\\n                         nj = j + 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i - 1;\\n                         nj = j + 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 1;\\n                         nj = j + 2;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                         ni = i + 2;\\n                         nj = j + 1;\\n                        if (isValid(ni,nj,n)){\\n                            next[ni][nj] += curr[i][j] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            //IMAGINE THIS LIKE, IF THE VALUES AT \"curr\" ARRAY ARE GREATER THAN 0, THEN IT IS OBVIOUS THAT \\'KNIGHT\\' IS PRESENT IN THAT POSITION. TAKING THIS POSITION AS REFERENCE, WE MARK THE POSSIBLE MOVES IN \"next\" ARRAY.\\n            \\n            curr = next;\\n            //\"curr\" ARRAY ACTUALLY CONTAINS THE FINAL PROBABILITY ARRAY AT k MOVES.\\n            next = new double[n][n];\\n        }\\n\\n        double sum = 0;\\n        //FINALYY ADD THE VALUES AND RETURN THEM.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sum += curr[i][j];\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n\\n    static boolean isValid(int ni, int nj, int n) {\\n        if (ni >= 0 && nj >= 0 && ni < n && nj < n) return true;\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800371,
                "title": "tabulation-and-memo-solutions-explained",
                "content": "# Intuition: \\ncheck which moves are going outside, take them as base case and return 1. and every time we have 8 ways to move so store the no. of 1s divide by 8.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nTake a 3d dp and write a function containing base condition which return 1 when it is inside of chess board and return 0 when it is outside of chess board, then calculate total ways from 8 ways which return 1, then divide by 8.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: see the solution\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: see the solution\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Memoization \\nTime complexity: O(n*n*k)\\nSpace complexity: O(n*n*k) + O(n*k)\\n\\nclass Solution {\\npublic:\\n    \\n    vector<pair<int, int>>moves={{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-1, -2}, {-2, -1}, {2, -1}, {1, -2}};\\n    double solve(int row, int col, int n, int k,  vector<vector<vector<double>>> &dp){\\n         if(row<0 || col<0 || row>=n || col>=n) return 0.0;\\n    if(k==0) {\\n     return 1.0;\\n    }\\n    if(dp[k][row][col]!=-1) return dp[k][row][col];\\n    double ans=0;\\n    for(auto it:moves){\\n        int nrow=row+it.first;\\n        int ncol=col+it.second;\\n        ans=ans+solve(nrow, ncol, n, k-1, dp);\\n    }\\n    return dp[k][row][col]=ans/8;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>>dp(k+1, vector<vector<double>>(n, vector<double>(n, -1)));\\n        return solve(row, column, n, k, dp);\\n    }\\n};\\n\\n//Tabulation approach \\nTime complexity: O(n*n*k)\\nSpace complexity: O(n*n*k)\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> moves = {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-1, -2}, {-2, -1}, {2, -1}, {1, -2}};\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n, 0.0)));\\n    \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                dp[0][i][j] = 1.0;\\n            }\\n        }\\n        \\n        for (int m = 1; m <= k; ++m) { \\n            for (int i = 0; i < n; ++i) { \\n                for (int j = 0; j < n; ++j) { \\n                    double ans = 0.0;\\n                    for (auto it : moves) {\\n                        int nrow = i + it.first;\\n                        int ncol = j + it.second;\\n                        if (nrow >= 0 && ncol >= 0 && nrow < n && ncol < n) {\\n                            ans += dp[m - 1][nrow][ncol];\\n                        }\\n                    }\\n                    dp[m][i][j] = ans / 8.0;\\n                }\\n            }\\n        }\\n        \\n        return dp[k][row][column];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Memoization \\nTime complexity: O(n*n*k)\\nSpace complexity: O(n*n*k) + O(n*k)\\n\\nclass Solution {\\npublic:\\n    \\n    vector<pair<int, int>>moves={{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-1, -2}, {-2, -1}, {2, -1}, {1, -2}};\\n    double solve(int row, int col, int n, int k,  vector<vector<vector<double>>> &dp){\\n         if(row<0 || col<0 || row>=n || col>=n) return 0.0;\\n    if(k==0) {\\n     return 1.0;\\n    }\\n    if(dp[k][row][col]!=-1) return dp[k][row][col];\\n    double ans=0;\\n    for(auto it:moves){\\n        int nrow=row+it.first;\\n        int ncol=col+it.second;\\n        ans=ans+solve(nrow, ncol, n, k-1, dp);\\n    }\\n    return dp[k][row][col]=ans/8;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>>dp(k+1, vector<vector<double>>(n, vector<double>(n, -1)));\\n        return solve(row, column, n, k, dp);\\n    }\\n};\\n\\n//Tabulation approach \\nTime complexity: O(n*n*k)\\nSpace complexity: O(n*n*k)\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> moves = {{2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-1, -2}, {-2, -1}, {2, -1}, {1, -2}};\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n, 0.0)));\\n    \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                dp[0][i][j] = 1.0;\\n            }\\n        }\\n        \\n        for (int m = 1; m <= k; ++m) { \\n            for (int i = 0; i < n; ++i) { \\n                for (int j = 0; j < n; ++j) { \\n                    double ans = 0.0;\\n                    for (auto it : moves) {\\n                        int nrow = i + it.first;\\n                        int ncol = j + it.second;\\n                        if (nrow >= 0 && ncol >= 0 && nrow < n && ncol < n) {\\n                            ans += dp[m - 1][nrow][ncol];\\n                        }\\n                    }\\n                    dp[m][i][j] = ans / 8.0;\\n                }\\n            }\\n        }\\n        \\n        return dp[k][row][column];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799679,
                "title": "variety-of-solutions-space-optimized-at-end-c",
                "content": "The 2D vector dp is used to store the probability of the knight being at each cell after m moves, where m is from 0 to k. Initially, dp[row][col] is set to 1.0, as the knight starts at this cell with a probability of 1.\\n\\nWe then loop from m = 1 to k. In each iteration, we create a new 2D vector new_dp, which will be used to store the updated probabilities for m moves. We calculate the probabilities for each cell (x, y) based on the probabilities from the previous iteration.\\n\\nFor each cell (x, y) in the chessboard, we check all eight possible moves of the knight (using the dx and dy arrays). If the next move (nx, ny) is within the bounds of the chessboard (i.e., 0 <= nx < n and 0 <= ny < n), we update the probability in new_dp[nx][ny] by adding dp[x][y] / 8.0. This is because each move has an equal probability of occurring, and there are 8 possible moves in total.\\n\\nAfter updating all the probabilities for m moves, we assign dp to new_dp using dp = move(new_dp). This effectively updates the probabilities for m moves in the original dp vector, and we can proceed to the next iteration.\\n\\nOnce we finish all iterations from m = 1 to k, we have the final probabilities of the knight being at each cell after making k moves.\\n\\nFinally, we calculate the sum of all probabilities in dp, which represents the total probability that the knight remains on the board after making exactly k moves. This value is stored in the variable ans, which is returned as the result.\\n\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     int dy[8] = {1, -1, 2, -2, 1, -1, 2, -2};\\n//     int dx[8] = {2, 2, 1, 1, -2, -2, -1, -1};\\n\\n//     bool isValid(int x, int y, int n) {\\n//         if (x >= 0 && x < n && y >= 0 && y < n) {\\n//             return true;\\n//         }\\n//         return false;\\n//     }\\n\\n//     double memo[26][101][101]; // Adjust size based on the given constraints\\n\\n//     double solve(int n, int k, int x, int y, double prob) {\\n//         if (k == 0) {\\n//             return 1;\\n//         }\\n\\n//         if (memo[n][x][y] != 0) {\\n//             return memo[n][x][y];\\n//         }\\n\\n//         double res = 0;\\n//         for (int i = 0; i < 8; i++) {\\n//             int nx = x + dx[i];\\n//             int ny = y + dy[i];\\n\\n//             if (isValid(nx, ny, n)) {\\n//                 res += (solve(n, k - 1, nx, ny, prob / 8.0)) / 8.0;\\n//             }\\n//         }\\n\\n//         memo[n][x][y] = res;\\n//         return res;\\n//     }\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         if (k == 0) {\\n//             return 1.0;\\n//         }\\n\\n//         // Initialize the memoization table with 0\\n//         memset(memo, 0, sizeof(memo));\\n\\n//         double ans = solve(n, k, row, col, 1.0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n// class Solution {\\n// public:\\n//     int dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\\n//     int dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n,vector<double>(n, 0.0)));\\n//         dp[0][row][col] = 1.0;\\n//         for (int m = 1; m <= k; m++) {\\n//             for (int x = 0; x < n; x++) {\\n//                 for (int y = 0; y < n; y++) {\\n//                     for (int i = 0; i < 8; i++) {\\n//                         int nx = x + dx[i];\\n//                         int ny = y + dy[i];\\n\\n//                         if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\\n//                             dp[m][nx][ny] += dp[m - 1][x][y] / 8.0;\\n//                         }\\n//                     }\\n//                 }\\n//             }\\n//         }\\n\\n//         double ans = 0.0;\\n//         for (int x = 0; x < n; x++) {\\n//             for (int y = 0; y < n; y++) {\\n//                 ans += dp[k][x][y];\\n//             }\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n\\n// class Solution {\\n// public:\\n//     int dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\\n//     int dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         vector<vector<double>> dp1(n, vector<double>(n, 0.0));\\n//         vector<vector<double>> dp2(n, vector<double>(n, 0.0));\\n\\n//         dp1[row][col] = 1.0;\\n\\n//         for (int m = 1; m <= k; m++) {\\n//             for (int x = 0; x < n; x++) {\\n//                 for (int y = 0; y < n; y++) {\\n//                     for (int i = 0; i < 8; i++) {\\n//                         int nx = x + dx[i];\\n//                         int ny = y + dy[i];\\n\\n//                         if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\\n//                             dp2[nx][ny] += dp1[x][y] / 8.0;\\n//                         }\\n//                     }\\n//                 }\\n//             }\\n//             dp1 = dp2;\\n//             dp2 = vector<vector<double>>(n,vector<double>(n, 0.0));\\n//         }\\n\\n//         double ans = 0.0;\\n//         for (int x = 0; x < n; x++) {\\n//             for (int y = 0; y < n; y++) {\\n//                 ans += dp1[x][y];\\n//             }\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n// class Solution {\\n// public:\\n//     int dy[8] = {1, -1, 2, -2, 1, -1, 2, -2};\\n//     int dx[8] = {2, 2, 1, 1, -2, -2, -1, -1};\\n\\n//     bool isValid(int x, int y, int n) {\\n//         if (x >= 0 && x < n && y >= 0 && y < n) {\\n//             return true;\\n//         }\\n//         return false;\\n//     }\\n\\n//     double dp[101][101][101]; // Adjust size based on the given constraints\\n\\n//     double solve(int n, int k, int x, int y, double prob) {\\n//         if (k == 0) {\\n//             return 1;\\n//         }\\n\\n//         if (dp[k][x][y] != 0) {\\n//             return dp[k][x][y];\\n//         }\\n\\n//         double res = 0;\\n//         for (int i = 0; i < 8; i++) {\\n//             int nx = x + dx[i];\\n//             int ny = y + dy[i];\\n\\n//             if (isValid(nx, ny, n)) {\\n//                 res += (solve(n, k - 1, nx, ny, prob / 8.0)) / 8.0;\\n//             }\\n//         }\\n\\n//         dp[k][x][y] = res;\\n//         return res;\\n//     }\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         if (k == 0) {\\n//             return 1.0;\\n//         }\\n\\n//         // Initialize the memoization table with 0\\n//         memset(dp, 0, sizeof(dp));\\n\\n//         double ans = solve(n, k, row, col, 1.0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\\n    int dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\\n\\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0.0));\\n\\n        dp[row][col] = 1.0;\\n\\n        for (int m = 1; m <= k; m++) {\\n            vector<vector<double>> new_dp(n,vector<double>(n, 0.0));\\n            for (int x = 0; x < n; x++) {\\n                for (int y = 0; y < n; y++) {\\n                    for (int i = 0; i < 8; i++) {\\n                        int nx = x + dx[i];\\n                        int ny = y + dy[i];\\n\\n                        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\\n                            new_dp[nx][ny] += dp[x][y] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = move(new_dp);\\n        }\\n\\n        double ans = 0.0;\\n        for (int x = 0; x < n; x++) {\\n            for (int y = 0; y < n; y++) {\\n                ans += dp[x][y];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     int dy[8] = {1, -1, 2, -2, 1, -1, 2, -2};\\n//     int dx[8] = {2, 2, 1, 1, -2, -2, -1, -1};\\n\\n//     bool isValid(int x, int y, int n) {\\n//         if (x >= 0 && x < n && y >= 0 && y < n) {\\n//             return true;\\n//         }\\n//         return false;\\n//     }\\n\\n//     double memo[26][101][101]; // Adjust size based on the given constraints\\n\\n//     double solve(int n, int k, int x, int y, double prob) {\\n//         if (k == 0) {\\n//             return 1;\\n//         }\\n\\n//         if (memo[n][x][y] != 0) {\\n//             return memo[n][x][y];\\n//         }\\n\\n//         double res = 0;\\n//         for (int i = 0; i < 8; i++) {\\n//             int nx = x + dx[i];\\n//             int ny = y + dy[i];\\n\\n//             if (isValid(nx, ny, n)) {\\n//                 res += (solve(n, k - 1, nx, ny, prob / 8.0)) / 8.0;\\n//             }\\n//         }\\n\\n//         memo[n][x][y] = res;\\n//         return res;\\n//     }\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         if (k == 0) {\\n//             return 1.0;\\n//         }\\n\\n//         // Initialize the memoization table with 0\\n//         memset(memo, 0, sizeof(memo));\\n\\n//         double ans = solve(n, k, row, col, 1.0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n// class Solution {\\n// public:\\n//     int dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\\n//     int dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n,vector<double>(n, 0.0)));\\n//         dp[0][row][col] = 1.0;\\n//         for (int m = 1; m <= k; m++) {\\n//             for (int x = 0; x < n; x++) {\\n//                 for (int y = 0; y < n; y++) {\\n//                     for (int i = 0; i < 8; i++) {\\n//                         int nx = x + dx[i];\\n//                         int ny = y + dy[i];\\n\\n//                         if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\\n//                             dp[m][nx][ny] += dp[m - 1][x][y] / 8.0;\\n//                         }\\n//                     }\\n//                 }\\n//             }\\n//         }\\n\\n//         double ans = 0.0;\\n//         for (int x = 0; x < n; x++) {\\n//             for (int y = 0; y < n; y++) {\\n//                 ans += dp[k][x][y];\\n//             }\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n\\n// class Solution {\\n// public:\\n//     int dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\\n//     int dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         vector<vector<double>> dp1(n, vector<double>(n, 0.0));\\n//         vector<vector<double>> dp2(n, vector<double>(n, 0.0));\\n\\n//         dp1[row][col] = 1.0;\\n\\n//         for (int m = 1; m <= k; m++) {\\n//             for (int x = 0; x < n; x++) {\\n//                 for (int y = 0; y < n; y++) {\\n//                     for (int i = 0; i < 8; i++) {\\n//                         int nx = x + dx[i];\\n//                         int ny = y + dy[i];\\n\\n//                         if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\\n//                             dp2[nx][ny] += dp1[x][y] / 8.0;\\n//                         }\\n//                     }\\n//                 }\\n//             }\\n//             dp1 = dp2;\\n//             dp2 = vector<vector<double>>(n,vector<double>(n, 0.0));\\n//         }\\n\\n//         double ans = 0.0;\\n//         for (int x = 0; x < n; x++) {\\n//             for (int y = 0; y < n; y++) {\\n//                 ans += dp1[x][y];\\n//             }\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n// class Solution {\\n// public:\\n//     int dy[8] = {1, -1, 2, -2, 1, -1, 2, -2};\\n//     int dx[8] = {2, 2, 1, 1, -2, -2, -1, -1};\\n\\n//     bool isValid(int x, int y, int n) {\\n//         if (x >= 0 && x < n && y >= 0 && y < n) {\\n//             return true;\\n//         }\\n//         return false;\\n//     }\\n\\n//     double dp[101][101][101]; // Adjust size based on the given constraints\\n\\n//     double solve(int n, int k, int x, int y, double prob) {\\n//         if (k == 0) {\\n//             return 1;\\n//         }\\n\\n//         if (dp[k][x][y] != 0) {\\n//             return dp[k][x][y];\\n//         }\\n\\n//         double res = 0;\\n//         for (int i = 0; i < 8; i++) {\\n//             int nx = x + dx[i];\\n//             int ny = y + dy[i];\\n\\n//             if (isValid(nx, ny, n)) {\\n//                 res += (solve(n, k - 1, nx, ny, prob / 8.0)) / 8.0;\\n//             }\\n//         }\\n\\n//         dp[k][x][y] = res;\\n//         return res;\\n//     }\\n\\n//     double knightProbability(int n, int k, int row, int col) {\\n//         if (k == 0) {\\n//             return 1.0;\\n//         }\\n\\n//         // Initialize the memoization table with 0\\n//         memset(dp, 0, sizeof(dp));\\n\\n//         double ans = solve(n, k, row, col, 1.0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int dx[8] = {1, 1, 2, 2, -1, -1, -2, -2};\\n    int dy[8] = {2, -2, 1, -1, 2, -2, 1, -1};\\n\\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0.0));\\n\\n        dp[row][col] = 1.0;\\n\\n        for (int m = 1; m <= k; m++) {\\n            vector<vector<double>> new_dp(n,vector<double>(n, 0.0));\\n            for (int x = 0; x < n; x++) {\\n                for (int y = 0; y < n; y++) {\\n                    for (int i = 0; i < 8; i++) {\\n                        int nx = x + dx[i];\\n                        int ny = y + dy[i];\\n\\n                        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\\n                            new_dp[nx][ny] += dp[x][y] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = move(new_dp);\\n        }\\n\\n        double ans = 0.0;\\n        for (int x = 0; x < n; x++) {\\n            for (int y = 0; y < n; y++) {\\n                ans += dp[x][y];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799491,
                "title": "c-solution-for-knight-probability-in-chess-board-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using dynamic programming. We need to find the probability that the knight remains on the board after exactly k moves starting from the given position. To do this, we can calculate the probabilities for all possible cells on the board after each move and keep updating the probabilities based on the previous positions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a 3D array dp[n][n][k+1] to store the probabilities. dp[i][j][s] represents the probability of the knight being on cell (i,j) after s moves.\\n- Initialize the base case: dp[row][column][0] = 1, since the knight hasn\\'t moved yet.\\n- Use a directions array to store all possible knight moves (8 in total).\\n- For each s from 1 to k, and each cell (i,j) on the board:\\n1. Calculate the probability of reaching cell (i,j) after s moves by summing up the probabilities from all possible previous positions in the last move.\\n1. Update dp[i][j][s] by dividing the sum by 8 (since there are 8 possible moves for the knight).\\n- Finally, sum up the probabilities for all cells on the board after k moves to get the total probability that the knight remains on the board.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^2 * k), where n is the size of the chessboard and k is the number of moves. The nested loops iterate over all cells on the board and for each cell, the algorithm performs a constant number of operations.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n^2 * k) as well, due to the 3D dp array used to store the probabilities for each cell and each move.\\n\\n# Code\\n```\\npublic class Solution {\\n    public double KnightProbability(int n, int k, int row, int column) {\\n        int[][] directions = new int[][] {\\n        new int[] { 2, 1 },\\n        new int[] { 1, 2 },\\n        new int[] { -1, 2 },\\n        new int[] { -2, 1 },\\n        new int[] { -2, -1 },\\n        new int[] { -1, -2 },\\n        new int[] { 1, -2 },\\n        new int[] { 2, -1 }\\n    };\\n    \\n    double[,,] dp = new double[n, n, k + 1];\\n    dp[row, column, 0] = 1;\\n    \\n    for (int s = 1; s <= k; s++) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                foreach (var dir in directions) {\\n                    int prevRow = i + dir[0];\\n                    int prevCol = j + dir[1];\\n                    \\n                    if (prevRow >= 0 && prevRow < n && prevCol >= 0 && prevCol < n) {\\n                        dp[i, j, s] += dp[prevRow, prevCol, s - 1] / 8;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    double totalProbability = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            totalProbability += dp[i, j, k];\\n        }\\n    }\\n    \\n    return totalProbability;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double KnightProbability(int n, int k, int row, int column) {\\n        int[][] directions = new int[][] {\\n        new int[] { 2, 1 },\\n        new int[] { 1, 2 },\\n        new int[] { -1, 2 },\\n        new int[] { -2, 1 },\\n        new int[] { -2, -1 },\\n        new int[] { -1, -2 },\\n        new int[] { 1, -2 },\\n        new int[] { 2, -1 }\\n    };\\n    \\n    double[,,] dp = new double[n, n, k + 1];\\n    dp[row, column, 0] = 1;\\n    \\n    for (int s = 1; s <= k; s++) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                foreach (var dir in directions) {\\n                    int prevRow = i + dir[0];\\n                    int prevCol = j + dir[1];\\n                    \\n                    if (prevRow >= 0 && prevRow < n && prevCol >= 0 && prevCol < n) {\\n                        dp[i, j, s] += dp[prevRow, prevCol, s - 1] / 8;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    double totalProbability = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            totalProbability += dp[i, j, k];\\n        }\\n    }\\n    \\n    return totalProbability;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799351,
                "title": "c-beats-99-easy-solution-with-explanation-3d-dp-memoization",
                "content": "# Intuition\\nThe problem can be solved using a recursive approach with memoization. We can start with the given position of the knight and simulate all possible moves it can make while keeping track of the probability of staying on the board at each step. The knight has eight possible moves it can make, and at each move, it has an equal probability of choosing any of those moves.\\n\\n# Approach\\n\\nCreate a 3D array `dp` to memoize the calculated probabilities for each position and remaining moves.\\n\\nDefine the `dirs` array to store the eight possible moves a knight can make.\\n\\nLet\\'s define the recursive function `find(row, col, move)` as the probability of the knight staying on the board after making `move` moves starting from position `(row, col)`.\\n\\n\\nThe recursive formula for `find(row, col, move)` is as follows:\\n\\n- If the knight is already off the board, return probability 0:\\n`if (row < 0 or row >= n or col < 0 or col >= n) return 0`\\n\\n- If no more moves are left (move == 0), return probability 1, as the knight is already on the board:\\n`if (move == 0) return 1`\\n\\n- If the probability for the current position and remaining moves is already calculated, return the precalculated value to avoid redundant computations:\\n`if (dp[row][col][move]) return dp[row][col][move]`\\n\\n- Otherwise, calculate the total probability `prob` for the current position:\\n````\\ndouble prob = 0.0;\\nfor(int i=0; i<8; i++) {\\n    prob += find(row + dirs[i][0], col + dirs[i][1], n, move - 1) / 8.0;\\n}\\n````\\n\\n- The probability calculation code iterates over all eight possible moves that a knight can make. For each move, it calls the recursive function `find` with the new position `(row + dirs[i][0], col + dirs[i][1])` and decrements the remaining moves by one `(move - 1)`.\\n\\n- The `find` function returns the probability of staying on the board after making the given number of moves from the new position. The probabilities returned from all eight possible moves are added together and divided by 8.0 to calculate the average probability. This average probability represents the probability of staying on the board after making one move from the current position.\\n\\n\\n- Store the probability of current position with remaining moves in `dp` and return the `prob`\\n\\n# Complexity\\n- Time complexity: $$O(n*n*k)$$\\n- Space complexity: $$O(n*n*k) + O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dirs[8][2] = {{2,-1}, {2, 1}, {-2,-1}, {-2, 1}, {1, -2}, {1, 2}, {-1, -2}, {-1, 2}}; \\n    double dp[30][30][105];\\n\\n    double find(int row, int col, int n, int move) {\\n        if(row < 0 || row >= n || col < 0 || col >= n) return 0;\\n        if(move == 0) return 1;\\n\\n        if(dp[row][col][move]) return dp[row][col][move];\\n\\n        double prob = 0.0;\\n        for(int i=0; i<8; i++) {\\n            prob += find(row + dirs[i][0], col + dirs[i][1], n, move - 1) / 8.0;\\n        }\\n        return dp[row][col][move] = prob;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        memset(dp, 0, sizeof(dp));\\n        return find(row, col, n, k);\\n    }\\n};\\n```\\n\\n# Reminder\\n\\nIf you like this solution, please upvote and share with your friends.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "````\\ndouble prob = 0.0;\\nfor(int i=0; i<8; i++) {\\n    prob += find(row + dirs[i][0], col + dirs[i][1], n, move - 1) / 8.0;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dirs[8][2] = {{2,-1}, {2, 1}, {-2,-1}, {-2, 1}, {1, -2}, {1, 2}, {-1, -2}, {-1, 2}}; \\n    double dp[30][30][105];\\n\\n    double find(int row, int col, int n, int move) {\\n        if(row < 0 || row >= n || col < 0 || col >= n) return 0;\\n        if(move == 0) return 1;\\n\\n        if(dp[row][col][move]) return dp[row][col][move];\\n\\n        double prob = 0.0;\\n        for(int i=0; i<8; i++) {\\n            prob += find(row + dirs[i][0], col + dirs[i][1], n, move - 1) / 8.0;\\n        }\\n        return dp[row][col][move] = prob;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        memset(dp, 0, sizeof(dp));\\n        return find(row, col, n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799058,
                "title": "c-faster-than-90-very-easy-to-understand",
                "content": "# Intuition\\n\\nThe problem is to find the probability of a knight staying on the chessboard after making \\'k\\' moves starting from a given position (row, col). We can use dynamic programming with memoization to efficiently calculate the probability.\\n\\n\\n\\n# Approach\\n1. We will use dynamic programming with memoization to store the results of subproblems.\\n2. The recursive function \\'solve\\' calculates the probability of the knight staying on the chessboard after making \\'k\\' moves starting from the given position (row, col).\\n3. For each move of the knight, we consider all 8 possible moves and calculate their respective probabilities.The probability for each move is 0.125 (1/8) since there are 8 possible moves in total.\\n4. We sum up the probabilities for all 8 moves to get the final probability for the current position and remaining moves (k-1).\\n5. The base cases of the recursion are when the knight moves out of the chessboard or when no more moves are left (k=0).\\n6. The function returns 1 when no more moves are left (k=0) since the knight is guaranteed to stay on the board after making 0 moves.\\n\\n# Complexity\\n- Time complexity:\\nLet \\'n\\' be the size of the chessboard (n x n).\\nThe function \\'solve\\' is called for each cell in the chessboard (n x n) with \\'k\\' remaining moves.\\nFor each cell, we explore 8 possible moves.\\nTherefore, the time complexity is O(n^2 * k).\\n\\n- Space complexity:\\nWe are using a 3D DP array of size n x n x (k + 1) to store the results of subproblems.\\nThe space complexity is O(n^2 * k) for the DP array.\\nAdditionally, there is a recursive call stack that can go up to \\'k\\'.\\nSo, the overall space complexity is O(n^2 * k).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to calculate the probability of a knight staying on the chessboard after \\'k\\' moves.\\n    double knightProbability(int n, int k, int row, int col) {\\n        // Create a 3D DP array to store the results of subproblems.\\n        // dp[row][col][moves] will store the probability of the knight staying at position (row, col) after \\'moves\\' moves.\\n        vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k + 1, -1)));\\n        return solve(n, row, col, k, dp);\\n    }\\n\\n    // Recursive function to calculate the probability of a knight staying on the chessboard.\\n    double solve(int n, int row, int col, int k, vector<vector<vector<double>>>& dp) {\\n        // Base case 1: If the knight moves out of the chessboard, return 0.\\n        if (row < 0 || row >= n || col < 0 || col >= n || k < 0) {\\n            return 0;\\n        }\\n        // Base case 2: If no more moves are left (k=0), return 1. The knight is guaranteed to stay on the board after making 0 moves.\\n        if (k == 0) {\\n            return 1;\\n        }\\n        // If the probability for this position and \\'k\\' moves is already calculated, return it from the DP array.\\n        if (dp[row][col][k] != -1) {\\n            return dp[row][col][k];\\n        }\\n\\n        // Array representing possible changes in row and column positions for a knight\\'s move.\\n        int delrow[8] = { -2, -2, -1, +1, +2, +2, +1, -1 };\\n        int delcol[8] = { -1, +1, +2, +2, +1, -1, -2, -2 };\\n\\n        double ans = 0;\\n        // Calculate the probability of the knight staying on the chessboard after \\'k-1\\' moves from all 8 possible moves.\\n        for (int i = 0; i < 8; i++) {\\n            int nrow = delrow[i] + row; // New row position after the move.\\n            int ncol = delcol[i] + col; // New column position after the move.\\n            ans += (0.125 * solve(n, nrow, ncol, k - 1, dp)); // Each move has a probability of 0.125 (1/8).\\n        }\\n\\n        // Memoize the result and return the probability for this position and \\'k\\' moves.\\n        return dp[row][col][k] = ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to calculate the probability of a knight staying on the chessboard after \\'k\\' moves.\\n    double knightProbability(int n, int k, int row, int col) {\\n        // Create a 3D DP array to store the results of subproblems.\\n        // dp[row][col][moves] will store the probability of the knight staying at position (row, col) after \\'moves\\' moves.\\n        vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k + 1, -1)));\\n        return solve(n, row, col, k, dp);\\n    }\\n\\n    // Recursive function to calculate the probability of a knight staying on the chessboard.\\n    double solve(int n, int row, int col, int k, vector<vector<vector<double>>>& dp) {\\n        // Base case 1: If the knight moves out of the chessboard, return 0.\\n        if (row < 0 || row >= n || col < 0 || col >= n || k < 0) {\\n            return 0;\\n        }\\n        // Base case 2: If no more moves are left (k=0), return 1. The knight is guaranteed to stay on the board after making 0 moves.\\n        if (k == 0) {\\n            return 1;\\n        }\\n        // If the probability for this position and \\'k\\' moves is already calculated, return it from the DP array.\\n        if (dp[row][col][k] != -1) {\\n            return dp[row][col][k];\\n        }\\n\\n        // Array representing possible changes in row and column positions for a knight\\'s move.\\n        int delrow[8] = { -2, -2, -1, +1, +2, +2, +1, -1 };\\n        int delcol[8] = { -1, +1, +2, +2, +1, -1, -2, -2 };\\n\\n        double ans = 0;\\n        // Calculate the probability of the knight staying on the chessboard after \\'k-1\\' moves from all 8 possible moves.\\n        for (int i = 0; i < 8; i++) {\\n            int nrow = delrow[i] + row; // New row position after the move.\\n            int ncol = delcol[i] + col; // New column position after the move.\\n            ans += (0.125 * solve(n, nrow, ncol, k - 1, dp)); // Each move has a probability of 0.125 (1/8).\\n        }\\n\\n        // Memoize the result and return the probability for this position and \\'k\\' moves.\\n        return dp[row][col][k] = ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798976,
                "title": "simple-memoization-solution-c-o-n-n-k",
                "content": "Just make a dp array that will store the probability of being inside board after ```rem moves starting from (row, col)```.\\nIn each move we go to 8 possible next positions and the answer is ```(addition of all their possiblities)/8```.\\nDivide by 8 is done everytime as after each move we can go to 8 different positions and that make 8*more scenarios after each move, so divide by 8 each time to calculate the probability. If rem is 0 and knight is inside board probability returned is 1. (As being inside board with 0 moves remaining will always satisfy the condition)\\nIf it is outside board at any point, return 0.\\n(Actually the question is a bit poorly phrased)\\n\\nAnd like this we store probabilities and reuse from dp array if required, and reach to our answer. Easy.\\n```\\nclass Solution {\\npublic:\\n    double dfs(int n, int row, int col, int rem, vector<vector<vector<double>>>& dp){\\n        if(row<0 || row>=n || col<0 || col>=n) return 0;\\n        if(rem==0) return 1;\\n        if(dp[row][col][rem]!=-1) return dp[row][col][rem];\\n\\n        double a = dfs(n,row-1,col-2,rem-1,dp);\\n        double b = dfs(n,row-1,col+2,rem-1,dp);\\n        double c = dfs(n,row+1,col-2,rem-1,dp);\\n        double d = dfs(n,row+1,col+2,rem-1,dp);\\n        double e = dfs(n,row-2,col+1,rem-1,dp);\\n        double f = dfs(n,row-2,col-1,rem-1,dp);\\n        double g = dfs(n,row+2,col+1,rem-1,dp);\\n        double h = dfs(n,row+2,col-1,rem-1,dp);\\n        dp[row][col][rem] = (a + b + c + d + e + f + g + h)/8;\\n        return dp[row][col][rem];\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));\\n        return dfs(n,row,column,k,dp);\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O((n^2)*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O((n^2)*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please upvote for your continuous support \\uD83D\\uDE0A. If you have any doubt, feel free to comment down below, I will try my best to reply and explain. Thank you for reading my answer.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```rem moves starting from (row, col)```\n```(addition of all their possiblities)/8```\n```\\nclass Solution {\\npublic:\\n    double dfs(int n, int row, int col, int rem, vector<vector<vector<double>>>& dp){\\n        if(row<0 || row>=n || col<0 || col>=n) return 0;\\n        if(rem==0) return 1;\\n        if(dp[row][col][rem]!=-1) return dp[row][col][rem];\\n\\n        double a = dfs(n,row-1,col-2,rem-1,dp);\\n        double b = dfs(n,row-1,col+2,rem-1,dp);\\n        double c = dfs(n,row+1,col-2,rem-1,dp);\\n        double d = dfs(n,row+1,col+2,rem-1,dp);\\n        double e = dfs(n,row-2,col+1,rem-1,dp);\\n        double f = dfs(n,row-2,col-1,rem-1,dp);\\n        double g = dfs(n,row+2,col+1,rem-1,dp);\\n        double h = dfs(n,row+2,col-1,rem-1,dp);\\n        dp[row][col][rem] = (a + b + c + d + e + f + g + h)/8;\\n        return dp[row][col][rem];\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));\\n        return dfs(n,row,column,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798746,
                "title": "video-conquer-the-chess-knight-challenge-with-python-and-dynamic-programming",
                "content": "# Intuition\\nWhen first approaching this problem, I thought of the knight\\'s eight possible moves on a chessboard and how some of these moves can cause it to fall off the board. I recognized the probability aspect of the problem and the fact that each move the knight makes is independent of the others. This made me think about using dynamic programming to solve this problem as it involves computing the probabilities of independent events and has overlapping sub-problems, which are characteristics that dynamic programming excels at.\\n\\nhttps://youtu.be/tp5UqIarBGQ\\n\\n# Approach\\nI used a dynamic programming approach to solve this problem. The idea is to use a 3D array to keep track of the probability of the knight being on each cell after a certain number of moves. The dp[i][j][k] cell in this array represents the probability of the knight being in cell (j, k) after i moves. For each cell, I calculate its probability by averaging the probabilities of the knight reaching that cell from each of its possible previous positions. The base case is that the knight is on the board (with a probability of 1) if it starts on the board. Finally, I sum up the probabilities in all cells after k moves to get the total probability of the knight remaining on the board.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is $$O(n^2 * k)$$ where n is the size of the board and k is the number of moves. This is because for each move, I iterate over all cells in the n by n board, and for each cell, I calculate its probability based on the probabilities of its previous positions.\\n  \\n- Space complexity: The space complexity of this solution is $$O(n^2 * k)$$ due to the 3D dp array used to store the probabilities of the knight being on each cell after a certain number of moves.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        moves = [(1, 2), (2, 1), (-1, 2), (2, -1), (-1, -2), (-2, -1), (1, -2), (-2, 1)] \\n        dp = [[0 for _ in range(n)] for _ in range(n)]\\n        dp_prev = [[0 for _ in range(n)] for _ in range(n)]\\n        dp_prev[row][column] = 1\\n\\n        for step in range(k):\\n            for r in range(n):\\n                for c in range(n):\\n                    dp[r][c] = 0\\n                    for dr, dc in moves:\\n                        prev_r, prev_c = r - dr, c - dc\\n                        if 0 <= prev_r < n and 0 <= prev_c < n:\\n                            dp[r][c] += dp_prev[prev_r][prev_c] / 8.0\\n            dp, dp_prev = dp_prev, dp \\n\\n        total_probability = sum(sum(dp_prev[r][c] for c in range(n)) for r in range(n))\\n        return total_probability\\n```\\n``` JavaScript []\\nvar knightProbability = function(n, k, r, c) {\\n    const moves = [[1,2], [2,1], [-1,2], [2,-1], [-1,-2], [-2,-1], [1,-2], [-2,1]];\\n    let dp = Array.from({length: n}, () => new Array(n).fill(0));\\n    let dpPrev = Array.from({length: n}, () => new Array(n).fill(0));\\n    dpPrev[r][c] = 1;\\n\\n    for(let step = 0; step < k; step++) {\\n        for(let i = 0; i < n; i++) {\\n            for(let j = 0; j < n; j++) {\\n                dp[i][j] = 0;\\n                for(let [dr, dc] of moves) {\\n                    let prevR = i - dr;\\n                    let prevC = j - dc;\\n                    if(prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                        dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n        [dp, dpPrev] = [dpPrev, dp];\\n    }\\n\\n    let totalProbability = 0;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < n; j++) {\\n            totalProbability += dpPrev[i][j];\\n        }\\n    }\\n\\n    return totalProbability;\\n};\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<int>> moves = {{1, 2}, {2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}, {1, -2}, {-2, 1}};\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        vector<vector<double>> dpPrev(n, vector<double>(n, 0));\\n        dpPrev[row][column] = 1;\\n        \\n        for (int step = 0; step < k; step++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = 0;\\n                    for (auto& move : moves) {\\n                        int prevR = i - move[0];\\n                        int prevC = j - move[1];\\n                        if (prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                            dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp, dpPrev);\\n        }\\n        \\n        double totalProbability = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                totalProbability += dpPrev[i][j];\\n            }\\n        }\\n        \\n        return totalProbability;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public double knightProbability(int n, int k, int r, int c) {\\n        int[][] moves = {{1, 2}, {2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}, {1, -2}, {-2, 1}};\\n        double[][] dp = new double[n][n];\\n        double[][] dpPrev = new double[n][n];\\n        dpPrev[r][c] = 1;\\n        \\n        for (int step = 0; step < k; step++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = 0;\\n                    for (int[] move : moves) {\\n                        int prevR = i - move[0];\\n                        int prevC = j - move[1];\\n                        if (prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                            dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            double[][] temp = dp;\\n            dp = dpPrev;\\n            dpPrev = temp;\\n        }\\n        \\n        double totalProbability = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                totalProbability += dpPrev[i][j];\\n            }\\n        }\\n        \\n        return totalProbability;\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn knight_probability(n: i32, k: i32, r: i32, c: i32) -> f64 {\\n        let moves = [(1, 2), (2, 1), (-1, 2), (2, -1), (-1, -2), (-2, -1), (1, -2), (-2, 1)];\\n        let mut dp = vec![vec![0.0; n as usize]; n as usize];\\n        let mut dp_prev = vec![vec![0.0; n as usize]; n as usize];\\n        dp_prev[r as usize][c as usize] = 1.0;\\n\\n        for _step in 0..k {\\n            for i in 0..n {\\n                for j in 0..n {\\n                    dp[i as usize][j as usize] = 0.0;\\n                    for &(dr, dc) in &moves {\\n                        let prev_r = i - dr;\\n                        let prev_c = j - dc;\\n                        if prev_r >= 0 && prev_r < n && prev_c >= 0 && prev_c < n {\\n                            dp[i as usize][j as usize] += dp_prev[prev_r as usize][prev_c as usize] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut dp, &mut dp_prev);\\n        }\\n\\n        let mut total_probability = 0.0;\\n        for i in 0..n {\\n            for j in 0..n {\\n                total_probability += dp_prev[i as usize][j as usize];\\n            }\\n        }\\n        total_probability\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Rust"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        moves = [(1, 2), (2, 1), (-1, 2), (2, -1), (-1, -2), (-2, -1), (1, -2), (-2, 1)] \\n        dp = [[0 for _ in range(n)] for _ in range(n)]\\n        dp_prev = [[0 for _ in range(n)] for _ in range(n)]\\n        dp_prev[row][column] = 1\\n\\n        for step in range(k):\\n            for r in range(n):\\n                for c in range(n):\\n                    dp[r][c] = 0\\n                    for dr, dc in moves:\\n                        prev_r, prev_c = r - dr, c - dc\\n                        if 0 <= prev_r < n and 0 <= prev_c < n:\\n                            dp[r][c] += dp_prev[prev_r][prev_c] / 8.0\\n            dp, dp_prev = dp_prev, dp \\n\\n        total_probability = sum(sum(dp_prev[r][c] for c in range(n)) for r in range(n))\\n        return total_probability\\n```\n``` JavaScript []\\nvar knightProbability = function(n, k, r, c) {\\n    const moves = [[1,2], [2,1], [-1,2], [2,-1], [-1,-2], [-2,-1], [1,-2], [-2,1]];\\n    let dp = Array.from({length: n}, () => new Array(n).fill(0));\\n    let dpPrev = Array.from({length: n}, () => new Array(n).fill(0));\\n    dpPrev[r][c] = 1;\\n\\n    for(let step = 0; step < k; step++) {\\n        for(let i = 0; i < n; i++) {\\n            for(let j = 0; j < n; j++) {\\n                dp[i][j] = 0;\\n                for(let [dr, dc] of moves) {\\n                    let prevR = i - dr;\\n                    let prevC = j - dc;\\n                    if(prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                        dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                    }\\n                }\\n            }\\n        }\\n        [dp, dpPrev] = [dpPrev, dp];\\n    }\\n\\n    let totalProbability = 0;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < n; j++) {\\n            totalProbability += dpPrev[i][j];\\n        }\\n    }\\n\\n    return totalProbability;\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<int>> moves = {{1, 2}, {2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}, {1, -2}, {-2, 1}};\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        vector<vector<double>> dpPrev(n, vector<double>(n, 0));\\n        dpPrev[row][column] = 1;\\n        \\n        for (int step = 0; step < k; step++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = 0;\\n                    for (auto& move : moves) {\\n                        int prevR = i - move[0];\\n                        int prevC = j - move[1];\\n                        if (prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                            dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp, dpPrev);\\n        }\\n        \\n        double totalProbability = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                totalProbability += dpPrev[i][j];\\n            }\\n        }\\n        \\n        return totalProbability;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public double knightProbability(int n, int k, int r, int c) {\\n        int[][] moves = {{1, 2}, {2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}, {1, -2}, {-2, 1}};\\n        double[][] dp = new double[n][n];\\n        double[][] dpPrev = new double[n][n];\\n        dpPrev[r][c] = 1;\\n        \\n        for (int step = 0; step < k; step++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = 0;\\n                    for (int[] move : moves) {\\n                        int prevR = i - move[0];\\n                        int prevC = j - move[1];\\n                        if (prevR >= 0 && prevR < n && prevC >= 0 && prevC < n) {\\n                            dp[i][j] += dpPrev[prevR][prevC] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            double[][] temp = dp;\\n            dp = dpPrev;\\n            dpPrev = temp;\\n        }\\n        \\n        double totalProbability = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                totalProbability += dpPrev[i][j];\\n            }\\n        }\\n        \\n        return totalProbability;\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn knight_probability(n: i32, k: i32, r: i32, c: i32) -> f64 {\\n        let moves = [(1, 2), (2, 1), (-1, 2), (2, -1), (-1, -2), (-2, -1), (1, -2), (-2, 1)];\\n        let mut dp = vec![vec![0.0; n as usize]; n as usize];\\n        let mut dp_prev = vec![vec![0.0; n as usize]; n as usize];\\n        dp_prev[r as usize][c as usize] = 1.0;\\n\\n        for _step in 0..k {\\n            for i in 0..n {\\n                for j in 0..n {\\n                    dp[i as usize][j as usize] = 0.0;\\n                    for &(dr, dc) in &moves {\\n                        let prev_r = i - dr;\\n                        let prev_c = j - dc;\\n                        if prev_r >= 0 && prev_r < n && prev_c >= 0 && prev_c < n {\\n                            dp[i as usize][j as usize] += dp_prev[prev_r as usize][prev_c as usize] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut dp, &mut dp_prev);\\n        }\\n\\n        let mut total_probability = 0.0;\\n        for i in 0..n {\\n            for j in 0..n {\\n                total_probability += dp_prev[i as usize][j as usize];\\n            }\\n        }\\n        total_probability\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764894,
                "title": "easy-3-d-approach-to-solve-this-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        if (k == 0 || n == 0) {\\n            return 1.0;\\n        }\\n        double[][][] dp = new double[n][n][k + 1];\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 0; j < dp[0].length; j++) {\\n                for (int l = 0; l <= k; l++) {\\n                    dp[i][j][l] = -1.0;\\n                }\\n            }\\n        }\\n        return probabilityCalculator(n, k, row, column, 0, dp);\\n    }\\n\\n    public double probabilityCalculator(int n, int k, int row, int column, int currentMove, double[][][] dp) {\\n        if (currentMove == k) {\\n            return 1.0;\\n        }\\n        if (dp[row][column][currentMove] != -1) {\\n            return dp[row][column][currentMove];\\n        }\\n        int[] xMove = {-2, -2, -1, -1, 1, 1, 2, 2};\\n        int[] yMove = {1, -1, 2, -2, 2, -2, 1, -1};\\n        double probability = 0;\\n        for (int i = 0; i < 8; i++) {\\n            int newRow = row + xMove[i];\\n            int newColumn = column + yMove[i];\\n            if (newRow >= 0 && newColumn >= 0 && newRow < n && newColumn < n) {\\n                probability += 0.125 * probabilityCalculator(n, k, newRow, newColumn, currentMove + 1, dp);\\n            }\\n        }\\n        dp[row][column][currentMove] = probability;\\n        return probability;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        if (k == 0 || n == 0) {\\n            return 1.0;\\n        }\\n        double[][][] dp = new double[n][n][k + 1];\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 0; j < dp[0].length; j++) {\\n                for (int l = 0; l <= k; l++) {\\n                    dp[i][j][l] = -1.0;\\n                }\\n            }\\n        }\\n        return probabilityCalculator(n, k, row, column, 0, dp);\\n    }\\n\\n    public double probabilityCalculator(int n, int k, int row, int column, int currentMove, double[][][] dp) {\\n        if (currentMove == k) {\\n            return 1.0;\\n        }\\n        if (dp[row][column][currentMove] != -1) {\\n            return dp[row][column][currentMove];\\n        }\\n        int[] xMove = {-2, -2, -1, -1, 1, 1, 2, 2};\\n        int[] yMove = {1, -1, 2, -2, 2, -2, 1, -1};\\n        double probability = 0;\\n        for (int i = 0; i < 8; i++) {\\n            int newRow = row + xMove[i];\\n            int newColumn = column + yMove[i];\\n            if (newRow >= 0 && newColumn >= 0 && newRow < n && newColumn < n) {\\n                probability += 0.125 * probabilityCalculator(n, k, newRow, newColumn, currentMove + 1, dp);\\n            }\\n        }\\n        dp[row][column][currentMove] = probability;\\n        return probability;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754014,
                "title": "easiest-way-to-approach-a-dp-problem-in-cpp",
                "content": "# Approach\\nfirst find all the possible ways that are stored in vector of pair in my code. Then use recursion for find probability of all that recursive calls then return the ans that is divided by total steps;\\n\\nTo avoid TLE : use 3d vector to store all the recursive call\\'s probabilities.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> v{{1, -2}, {1, 2}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}};\\n    double solve(int n, int k, int row, int col, vector<vector<vector<double>>>& dp){\\n        if((row<0 || row>=n) || (col<0 || col>=n))\\n            return 0;\\n\\n        if(k==0)\\n            return 1;\\n\\n        if(dp[row][col][k] !=0)\\n            return dp[row][col][k];\\n\\n        double main = 0;\\n        for(auto i : v){\\n            int nr = row+i.first;\\n            int nc = col+i.second;\\n            main += solve(n, k-1, nr, nc, dp);\\n        }\\n\\n        return dp[row][col][k] = main/8;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1)));\\n        double poss = solve(n, k, row, column, dp);\\n        return poss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> v{{1, -2}, {1, 2}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}};\\n    double solve(int n, int k, int row, int col, vector<vector<vector<double>>>& dp){\\n        if((row<0 || row>=n) || (col<0 || col>=n))\\n            return 0;\\n\\n        if(k==0)\\n            return 1;\\n\\n        if(dp[row][col][k] !=0)\\n            return dp[row][col][k];\\n\\n        double main = 0;\\n        for(auto i : v){\\n            int nr = row+i.first;\\n            int nc = col+i.second;\\n            main += solve(n, k-1, nr, nc, dp);\\n        }\\n\\n        return dp[row][col][k] = main/8;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1)));\\n        double poss = solve(n, k, row, column, dp);\\n        return poss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566070,
                "title": "ruby-solution-with-memoization",
                "content": "# Intuition\\nUse memoization -- there\\'s a limited number of possibilities.\\n\\n# Approach\\n1. Create a memo and store n as a class variable.\\n2. Create an array of dirs corresponding the the knight\\'s possible moves.\\n3. Find the probability with a helper function\\n\\nHelper function:\\n1. Return 0 if it\\'s off the board, 1 if it\\'s on the board and out of moves, and the memoized value if it exists\\n2. Look at the 8 possibile knight moves and find the probability of each, then add those together.\\n3. Divide the answer by 8.0 (there are eight knight moves, and 8.0 makes it a float), memoize, and return.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2 * k)$$\\n\\n- Space complexity:\\n$$O(n^2 * k)$$\\n\\n# Code\\n```\\ndef knight_probability(n, k, row, column)\\n    @memo = {}\\n    @n = n\\n    @dirs = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]]\\n    prob(row,column,k)\\nend\\n\\ndef prob(i,j,k)\\n    return 0 unless (0...@n).cover?(i) && (0...@n).cover?(j)\\n    return 1 if k == 0\\n    return @memo[[i,j,k]] if @memo[[i,j,k]]\\n\\n    total = 0\\n    @dirs.each { |dir| total += prob(i+dir[0],j+dir[1],k-1) }\\n\\n    @memo[[i,j,k]] = total / 8.0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef knight_probability(n, k, row, column)\\n    @memo = {}\\n    @n = n\\n    @dirs = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]]\\n    prob(row,column,k)\\nend\\n\\ndef prob(i,j,k)\\n    return 0 unless (0...@n).cover?(i) && (0...@n).cover?(j)\\n    return 1 if k == 0\\n    return @memo[[i,j,k]] if @memo[[i,j,k]]\\n\\n    total = 0\\n    @dirs.each { |dir| total += prob(i+dir[0],j+dir[1],k-1) }\\n\\n    @memo[[i,j,k]] = total / 8.0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3434747,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        dp[row][column] = 1;\\n        double temp;\\n        int outside = 0;\\n        for(int t= 0; t<k; t++){\\n            vector<vector<double>> dp2(n, vector<double>(n,0));\\n            for(int i = 0; i <n; i++){\\n                for(int j = 0; j<n; j++){\\n                    temp = dp[i][j];\\n                    if(temp != 0){\\n                        if(i-2 < 0){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(j-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-2][j-1]+=temp/8.0;\\n                            }\\n                            if(j+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-2][j+1]+=temp/8.0;\\n                            }\\n                        }\\n                        if(j-2 < 0){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(i-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-1][j-2]+=temp/8.0;\\n                            }\\n                            if(i+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+1][j-2]+=temp/8.0;\\n                            }\\n                        }\\n                        if(j+2 >= n){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(i-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-1][j+2]+=temp/8.0;\\n                            }\\n                            if(i+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+1][j+2]+=temp/8.0;\\n                            }\\n                        }\\n                        if(i+2 >= n){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(j-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+2][j-1]+=temp/8.0;\\n                            }\\n                            if(j+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+2][j+1]+=temp/8.0;\\n                            }\\n                        }\\n                    }           \\n                }\\n            }\\n            dp = dp2;\\n        }\\n        double ans = 0.0;\\n        for(int i = 0; i <n; i++){\\n            for(int j = 0; j<n; j++){\\n                ans += double(dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        def next_pos(i, j):\\n            dxdy = [(2, 1), (2, -1), (-2, 1), (-2, -1)]\\n            dxdy.extend([(y,x) for x,y in dxdy])\\n            res = [(i+dx, j+dy) for dx,dy in dxdy if i+dx >= 0 and j+dy >=0 and i+dx < n and j+dy < n]\\n            return res\\n        map_next = [[next_pos(i, j) for j in range(n)] for i in range(n)]\\n        prob = [[0 for j in range(n)] for i in range(n)]\\n        prob[row][column] = 1\\n        for count in range(k):\\n            prob2 = [[0 for j in range(n)] for i in range(n)]\\n            for i in range(n):\\n                for j in range(n):\\n                    if prob[i][j] == 0:\\n                        continue\\n                    for i2, j2 in map_next[i][j]:\\n                        prob2[i2][j2] += prob[i][j]/8\\n            prob = prob2\\n        return sum([sum(l) for l in prob])\\n```\\n\\n```Java []\\nclass Solution {\\n    private final int[][] moves = {{2, 1}, {-2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {1, -2}, {-1, -2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] cache = new double[n / 2 + 1][n / 2 + 1][k + 1];\\n        return solver(n, k, row, column, cache);\\n    }\\n    private double solver(int n, int k, int row, int column, double[][][] memo) {\\n        if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\\n        if (k == 0) return 1.0;\\n\\n        row = Math.min(row, n - 1 - row);\\n        column = Math.min(column, n - 1 - column);\\n\\n        if (row < column) return solver(n, k, column, row, memo);\\n        if (memo[row][column][k] != 0.0) return memo[row][column][k];\\n\\n        double probability = 0.0;\\n        for (int[] move : moves) {\\n            probability += solver(n, k - 1, row + move[0], column + move[1], memo) / 8.0;\\n        }\\n        memo[row][column][k] = probability;\\n        return probability;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        dp[row][column] = 1;\\n        double temp;\\n        int outside = 0;\\n        for(int t= 0; t<k; t++){\\n            vector<vector<double>> dp2(n, vector<double>(n,0));\\n            for(int i = 0; i <n; i++){\\n                for(int j = 0; j<n; j++){\\n                    temp = dp[i][j];\\n                    if(temp != 0){\\n                        if(i-2 < 0){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(j-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-2][j-1]+=temp/8.0;\\n                            }\\n                            if(j+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-2][j+1]+=temp/8.0;\\n                            }\\n                        }\\n                        if(j-2 < 0){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(i-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-1][j-2]+=temp/8.0;\\n                            }\\n                            if(i+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+1][j-2]+=temp/8.0;\\n                            }\\n                        }\\n                        if(j+2 >= n){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(i-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i-1][j+2]+=temp/8.0;\\n                            }\\n                            if(i+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+1][j+2]+=temp/8.0;\\n                            }\\n                        }\\n                        if(i+2 >= n){\\n                            outside+=2*temp;\\n                        }\\n                        else{\\n                            if(j-1 < 0){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+2][j-1]+=temp/8.0;\\n                            }\\n                            if(j+1 >= n){\\n                                outside+=temp;\\n                            }\\n                            else{\\n                                dp2[i+2][j+1]+=temp/8.0;\\n                            }\\n                        }\\n                    }           \\n                }\\n            }\\n            dp = dp2;\\n        }\\n        double ans = 0.0;\\n        for(int i = 0; i <n; i++){\\n            for(int j = 0; j<n; j++){\\n                ans += double(dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        def next_pos(i, j):\\n            dxdy = [(2, 1), (2, -1), (-2, 1), (-2, -1)]\\n            dxdy.extend([(y,x) for x,y in dxdy])\\n            res = [(i+dx, j+dy) for dx,dy in dxdy if i+dx >= 0 and j+dy >=0 and i+dx < n and j+dy < n]\\n            return res\\n        map_next = [[next_pos(i, j) for j in range(n)] for i in range(n)]\\n        prob = [[0 for j in range(n)] for i in range(n)]\\n        prob[row][column] = 1\\n        for count in range(k):\\n            prob2 = [[0 for j in range(n)] for i in range(n)]\\n            for i in range(n):\\n                for j in range(n):\\n                    if prob[i][j] == 0:\\n                        continue\\n                    for i2, j2 in map_next[i][j]:\\n                        prob2[i2][j2] += prob[i][j]/8\\n            prob = prob2\\n        return sum([sum(l) for l in prob])\\n```\n```Java []\\nclass Solution {\\n    private final int[][] moves = {{2, 1}, {-2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {1, -2}, {-1, -2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] cache = new double[n / 2 + 1][n / 2 + 1][k + 1];\\n        return solver(n, k, row, column, cache);\\n    }\\n    private double solver(int n, int k, int row, int column, double[][][] memo) {\\n        if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\\n        if (k == 0) return 1.0;\\n\\n        row = Math.min(row, n - 1 - row);\\n        column = Math.min(column, n - 1 - column);\\n\\n        if (row < column) return solver(n, k, column, row, memo);\\n        if (memo[row][column][k] != 0.0) return memo[row][column][k];\\n\\n        double probability = 0.0;\\n        for (int[] move : moves) {\\n            probability += solver(n, k - 1, row + move[0], column + move[1], memo) / 8.0;\\n        }\\n        memo[row][column][k] = probability;\\n        return probability;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389281,
                "title": "python-elegant-short-top-down-dp-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2}*k)$$\\n- Space complexity: $$O(n^{2}*k)$$\\n\\n# Code\\n```\\nclass Solution:\\n    MOVES = (\\n        (1, 2), (1, -2),\\n        (2, 1), (2, -1),\\n        (-1, 2), (-1, -2),\\n        (-2, 1), (-2, -1),\\n    )\\n\\n    def knightProbability(self, n: int, moves: int, start_row: int, start_col: int) -> float:\\n        @cache\\n        def dp(i: int, j: int, k: int) -> float:\\n            if not (0 <= i < n) or not (0 <= j < n):\\n                return 0.0\\n            if k <= 0:\\n                return (1 / len(self.MOVES)) ** moves\\n            return sum(dp(i + di, j + dj, k - 1) for di, dj in self.MOVES)\\n\\n        return dp(start_col, start_row, moves)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    MOVES = (\\n        (1, 2), (1, -2),\\n        (2, 1), (2, -1),\\n        (-1, 2), (-1, -2),\\n        (-2, 1), (-2, -1),\\n    )\\n\\n    def knightProbability(self, n: int, moves: int, start_row: int, start_col: int) -> float:\\n        @cache\\n        def dp(i: int, j: int, k: int) -> float:\\n            if not (0 <= i < n) or not (0 <= j < n):\\n                return 0.0\\n            if k <= 0:\\n                return (1 / len(self.MOVES)) ** moves\\n            return sum(dp(i + di, j + dj, k - 1) for di, dj in self.MOVES)\\n\\n        return dp(start_col, start_row, moves)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079971,
                "title": "dp-does-magic",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int>row={-2,-2,-1,-1,1,1,2,2},col={-1,1,-2,2,-2,2,1,-1};\\n\\n    double func(int n,int k,int r,int c,vector<vector<vector<double>>>&dp){\\n        if(r>=n || c>=n || r<0 || c<0)return 0;\\n        if(k==0)return 1;\\n\\n        if(dp[r][c][k]!=-1)return dp[r][c][k];\\n\\n        double ans=0;\\n        for(int i=0;i<8;i++){\\n            int ri=r+row[i],cj=c+col[i];\\n\\n            ans+=func(n,k-1,ri,cj,dp);\\n        }\\n\\n        ans/=8;\\n\\n        return dp[r][c][k]=ans;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>>dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));\\n\\n        return func(n,k,row,column,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int>row={-2,-2,-1,-1,1,1,2,2},col={-1,1,-2,2,-2,2,1,-1};\\n\\n    double func(int n,int k,int r,int c,vector<vector<vector<double>>>&dp){\\n        if(r>=n || c>=n || r<0 || c<0)return 0;\\n        if(k==0)return 1;\\n\\n        if(dp[r][c][k]!=-1)return dp[r][c][k];\\n\\n        double ans=0;\\n        for(int i=0;i<8;i++){\\n            int ri=r+row[i],cj=c+col[i];\\n\\n            ans+=func(n,k-1,ri,cj,dp);\\n        }\\n\\n        ans/=8;\\n\\n        return dp[r][c][k]=ans;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>>dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));\\n\\n        return func(n,k,row,column,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494544,
                "title": "naive-recursive-python-solution",
                "content": "Fairly self explanatory. Once we go off the board, we return probability 0. Once k is 0 and we\\'re not off the board, we return probability 1. Otherwise, we sum up the probabilities after each move, and divide by the total number of moves, which is 8. \\n\\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        \\n        @functools.cache\\n        def p(k: int, r: int, c: int) -> float:\\n            if r >= n or c >= n or r < 0 or c < 0:\\n                return 0.\\n            if k == 0:\\n                return 1.\\n            \\n            total = 0\\n            \\n            for sign1 in [-1, 1]:\\n                for sign2 in [-1, 1]:\\n                    for x in [1, 2]:\\n                        y = 2 if x == 1 else 1\\n                        x *= sign1\\n                        y *= sign2\\n                        total += p(k - 1, r + x, c + y)\\n            \\n            return float(total / 8.)\\n        \\n        return p(k, row, column)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        \\n        @functools.cache\\n        def p(k: int, r: int, c: int) -> float:\\n            if r >= n or c >= n or r < 0 or c < 0:\\n                return 0.\\n            if k == 0:\\n                return 1.\\n            \\n            total = 0\\n            \\n            for sign1 in [-1, 1]:\\n                for sign2 in [-1, 1]:\\n                    for x in [1, 2]:\\n                        y = 2 if x == 1 else 1\\n                        x *= sign1\\n                        y *= sign2\\n                        total += p(k - 1, r + x, c + y)\\n            \\n            return float(total / 8.)\\n        \\n        return p(k, row, column)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326020,
                "title": "felt-like-dfs-with-memoization",
                "content": "get the probability of knight being outside and substract it by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    double kp(int &n, int k, int r, int c,vector<vector<vector<double>>> &cache)\\n    {\\n        \\n        \\n        if(r>=n || c>=n || c<0 || r<0)\\n            return 1;\\n        if(k<=0)\\n            return 0;\\n        \\n        if(cache[k][r][c]!=-1)\\n            return cache[k][r][c];\\n        \\n        double l = kp(n,k-1,r+1,c+2,cache);\\n        double m = kp(n,k-1,r-1,c+2,cache);\\n        double t = kp(n,k-1,r+1,c-2,cache);\\n        double o = kp(n,k-1,r-1,c-2,cache);\\n        \\n        double p = kp(n,k-1,r+2,c+1,cache);\\n        double q = kp(n,k-1,r-2,c+1,cache);\\n        double u = kp(n,k-1,r+2,c-1,cache);\\n        double s = kp(n,k-1,r-2,c-1,cache);\\n\\n        return cache[k][r][c]=((l+m+t+o+p+q+u+s)/8.0);\\n    }\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        vector<vector<double>> t(n+1,vector<double>(n+1,-1));\\n        vector<vector<vector<double>>> cache(k+1,t);\\n        return (1-kp(n,k,row,column,cache));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double kp(int &n, int k, int r, int c,vector<vector<vector<double>>> &cache)\\n    {\\n        \\n        \\n        if(r>=n || c>=n || c<0 || r<0)\\n            return 1;\\n        if(k<=0)\\n            return 0;\\n        \\n        if(cache[k][r][c]!=-1)\\n            return cache[k][r][c];\\n        \\n        double l = kp(n,k-1,r+1,c+2,cache);\\n        double m = kp(n,k-1,r-1,c+2,cache);\\n        double t = kp(n,k-1,r+1,c-2,cache);\\n        double o = kp(n,k-1,r-1,c-2,cache);\\n        \\n        double p = kp(n,k-1,r+2,c+1,cache);\\n        double q = kp(n,k-1,r-2,c+1,cache);\\n        double u = kp(n,k-1,r+2,c-1,cache);\\n        double s = kp(n,k-1,r-2,c-1,cache);\\n\\n        return cache[k][r][c]=((l+m+t+o+p+q+u+s)/8.0);\\n    }\\n    \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        vector<vector<double>> t(n+1,vector<double>(n+1,-1));\\n        vector<vector<vector<double>>> cache(k+1,t);\\n        return (1-kp(n,k,row,column,cache));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289162,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int col) \\n    {\\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>> (n, vector<double>(n, -1)));\\n        return solve(n, k, row, col, dp);\\n    }\\n    \\nprivate:\\n    double solve(int n, int k, int row, int col, vector<vector<vector<double>>>& dp)\\n    {\\n        if (row < 0 || row >= n || col < 0 || col >= n) return 0;\\n        if (k == 0) return 1;\\n        \\n        if (dp[k][row][col] != -1)\\n            return dp[k][row][col];\\n        \\n        double total = solve(n, k - 1, row - 2, col + 1, dp) + solve(n, k - 1, row - 1, col + 2, dp)\\n                    + solve(n, k - 1, row + 1, col + 2, dp) + solve(n, k - 1, row + 2, col + 1, dp)\\n                    + solve(n, k - 1, row + 2, col - 1, dp) + solve(n, k - 1, row + 1, col - 2, dp)\\n                    + solve(n, k - 1, row - 1, col - 2, dp) + solve(n, k - 1, row - 2, col - 1, dp);\\n            \\n        total = total / 8;\\n        return dp[k][row][col] = total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int col) \\n    {\\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>> (n, vector<double>(n, -1)));\\n        return solve(n, k, row, col, dp);\\n    }\\n    \\nprivate:\\n    double solve(int n, int k, int row, int col, vector<vector<vector<double>>>& dp)\\n    {\\n        if (row < 0 || row >= n || col < 0 || col >= n) return 0;\\n        if (k == 0) return 1;\\n        \\n        if (dp[k][row][col] != -1)\\n            return dp[k][row][col];\\n        \\n        double total = solve(n, k - 1, row - 2, col + 1, dp) + solve(n, k - 1, row - 1, col + 2, dp)\\n                    + solve(n, k - 1, row + 1, col + 2, dp) + solve(n, k - 1, row + 2, col + 1, dp)\\n                    + solve(n, k - 1, row + 2, col - 1, dp) + solve(n, k - 1, row + 1, col - 2, dp)\\n                    + solve(n, k - 1, row - 1, col - 2, dp) + solve(n, k - 1, row - 2, col - 1, dp);\\n            \\n        total = total / 8;\\n        return dp[k][row][col] = total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282805,
                "title": "knight-probability-in-chessboard-java-dp",
                "content": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double [][]curr=new double[n][n];\\n        double [][]next=new double[n][n];\\n        \\n        curr[row][column]=1;\\n        \\n        int [][]dir={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n        for(int p=1;p<=k;p++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(curr[i][j]!=0){\\n                        \\n                        for(int d=0;d<8;d++){\\n                            int ni=i+dir[d][0];\\n                            int nj=j+dir[d][1];\\n                            \\n                            if(ni<0 || nj<0 || ni>=n || nj>=n){\\n                                continue;\\n                            }\\n                            \\n                            next[ni][nj]+=curr[i][j]/8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            curr=next;\\n            next=new double[n][n];\\n        }\\n        \\n        double sum=0.0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum+=curr[i][j];\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double [][]curr=new double[n][n];\\n        double [][]next=new double[n][n];\\n        \\n        curr[row][column]=1;\\n        \\n        int [][]dir={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n        for(int p=1;p<=k;p++){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<n;j++){\\n                    if(curr[i][j]!=0){\\n                        \\n                        for(int d=0;d<8;d++){\\n                            int ni=i+dir[d][0];\\n                            int nj=j+dir[d][1];\\n                            \\n                            if(ni<0 || nj<0 || ni>=n || nj>=n){\\n                                continue;\\n                            }\\n                            \\n                            next[ni][nj]+=curr[i][j]/8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            curr=next;\\n            next=new double[n][n];\\n        }\\n        \\n        double sum=0.0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum+=curr[i][j];\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158742,
                "title": "python-dfs-solution-with-optimization-beats-98",
                "content": "A small modification of dfs.\\nIf you look more closely at the board and the knight\\'s moves, you can see the symmetry of x, y and diagonals with same probability.\\nK is king, 1 is possible moves.\\nK 0 0\\n0 0 1\\n0 1 0\\nMirror x:\\n0 1 0\\n0 0 1\\nK 0 0\\nMirror y:\\n0 0 K\\n1 0 0\\n0 1 0\\nMirror diagonal:\\n0 1 0\\n1 0 0\\n0 0 K\\n\\nLet\\'s add this to our cache.\\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        directions = [(-2, -1), (-1, -2), (1, -2), (2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1)]\\n        memo = {}\\n        def dfs(i, j, k):\\n            if k == 0:\\n                return 1\\n            \\n            if (i, j, k) in memo:\\n                return memo[(i, j, k)]\\n            \\n            p = 0\\n            for di, dj in directions:\\n                x = i + di\\n                y = j + dj\\n                if x >= 0 and x < n and y >= 0 and y < n:\\n                    p += dfs(x, y, k - 1) / 8\\n            \\n            memo[(i, j, k)] = p\\n            memo[(n - 1 - i, j, k)] = p\\n            memo[(i, n - 1 - j, k)] = p\\n            memo[(n - 1 - i, n - 1 - j, k)] = p\\n            \\n            return p\\n        \\n       returndfs(row, column, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        directions = [(-2, -1), (-1, -2), (1, -2), (2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1)]\\n        memo = {}\\n        def dfs(i, j, k):\\n            if k == 0:\\n                return 1\\n            \\n            if (i, j, k) in memo:\\n                return memo[(i, j, k)]\\n            \\n            p = 0\\n            for di, dj in directions:\\n                x = i + di\\n                y = j + dj\\n                if x >= 0 and x < n and y >= 0 and y < n:\\n                    p += dfs(x, y, k - 1) / 8\\n            \\n            memo[(i, j, k)] = p\\n            memo[(n - 1 - i, j, k)] = p\\n            memo[(i, n - 1 - j, k)] = p\\n            memo[(n - 1 - i, n - 1 - j, k)] = p\\n            \\n            return p\\n        \\n       returndfs(row, column, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121106,
                "title": "c-short-and-concise-code-easily-understandable-code",
                "content": "```\\nclass Solution {\\npublic:\\n     int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 },dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    double dp[26][26][101];\\n    \\n     bool isValid(int i,int j,int n)\\n    {\\n          return (i>=0 && i<n && j>=0 && j<n )? true:false;\\n    }\\n   double solve(int n,int k,int i,int j)\\n    {\\n        if(k==0) return 1.0;\\n        if(dp[i][j][k]>0) return dp[i][j][k];\\n        double cnt=0;\\n        for(int l=0;l<8;l++)\\n        {\\n            int i1=i+dx[l],j1=j+dy[l];\\n               if(isValid(i1,j1,n))\\n               cnt+=((double)1.0/(double)8.0)*solve(n,k-1,i1,j1);\\n        }\\n        return dp[i][j][k]=cnt;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        double ans=solve(n,k,row,column);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 },dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    double dp[26][26][101];\\n    \\n     bool isValid(int i,int j,int n)\\n    {\\n          return (i>=0 && i<n && j>=0 && j<n )? true:false;\\n    }\\n   double solve(int n,int k,int i,int j)\\n    {\\n        if(k==0) return 1.0;\\n        if(dp[i][j][k]>0) return dp[i][j][k];\\n        double cnt=0;\\n        for(int l=0;l<8;l++)\\n        {\\n            int i1=i+dx[l],j1=j+dy[l];\\n               if(isValid(i1,j1,n))\\n               cnt+=((double)1.0/(double)8.0)*solve(n,k-1,i1,j1);\\n        }\\n        return dp[i][j][k]=cnt;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        double ans=solve(n,k,row,column);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830034,
                "title": "python-recursion-dp-memorization",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        directions = [[-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, 2], [2, 1], [2, -1], [1, -2]]\\n        cache = {}  # map (r, c, j) to prob. memorization, avoid repeated calculations\\n        def dfs(row, col, j): # j: remaining steps\\n            if (row, col, j) in cache: return cache[(row, col, j)]\\n            if not (0 <= row < n and 0 <= col < n): # base case 1\\n                return 0\\n            if j == 0:  # base case 2\\n                return 1\\n            else:\\n                prob = 0\\n                for dr, dc in directions:\\n                     # in each step, there are 8 choices\\n                    prob += (1/8 * (dfs(row+dr, col+dc, j - 1)))\\n                cache[(row, col, j)] = prob \\n                return prob\\n                \\n        return dfs(row, column, k)\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        directions = [[-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, 2], [2, 1], [2, -1], [1, -2]]\\n        cache = {}  # map (r, c, j) to prob. memorization, avoid repeated calculations\\n        def dfs(row, col, j): # j: remaining steps\\n            if (row, col, j) in cache: return cache[(row, col, j)]\\n            if not (0 <= row < n and 0 <= col < n): # base case 1\\n                return 0\\n            if j == 0:  # base case 2\\n                return 1\\n            else:\\n                prob = 0\\n                for dr, dc in directions:\\n                     # in each step, there are 8 choices\\n                    prob += (1/8 * (dfs(row+dr, col+dc, j - 1)))\\n                cache[(row, col, j)] = prob \\n                return prob\\n                \\n        return dfs(row, column, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828841,
                "title": "c-99-fast-memoization-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[26][26][101];\\n    double solve(int n, int k, int i, int j){\\n        if(i >= n || j >= n || i < 0 || j < 0 || k < 0) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] != 0) return dp[i][j][k];\\n        \\n          double total = solve(n, k - 1, i - 2, j + 1) +\\n      \\n            solve(n, k - 1, i - 2, j - 1)  +\\n        \\n            solve(n, k - 1, i - 1, j + 2)  +\\n        \\n            solve(n, k - 1, i - 1, j - 2)  +\\n       \\n            solve(n, k - 1, i + 2, j + 1)  +\\n       \\n            solve(n, k - 1, i + 1, j + 2)  +\\n      \\n            solve(n, k - 1, i + 2, j - 1)  +\\n       \\n            solve(n, k - 1, i + 1, j - 2);\\n        \\n         return dp[i][j][k] = total / 8.0;\\n                \\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n         memset(dp, 0.0, sizeof(dp));\\n         return solve(n, k,  row, column);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    double dp[26][26][101];\\n    double solve(int n, int k, int i, int j){\\n        if(i >= n || j >= n || i < 0 || j < 0 || k < 0) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] != 0) return dp[i][j][k];\\n        \\n          double total = solve(n, k - 1, i - 2, j + 1) +\\n      \\n            solve(n, k - 1, i - 2, j - 1)  +\\n        \\n            solve(n, k - 1, i - 1, j + 2)  +\\n        \\n            solve(n, k - 1, i - 1, j - 2)  +\\n       \\n            solve(n, k - 1, i + 2, j + 1)  +\\n       \\n            solve(n, k - 1, i + 1, j + 2)  +\\n      \\n            solve(n, k - 1, i + 2, j - 1)  +\\n       \\n            solve(n, k - 1, i + 1, j - 2);\\n        \\n         return dp[i][j][k] = total / 8.0;\\n                \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1752136,
                "title": "simple-8-line-code-python-solution-recursion",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        if row < 0 or row >= n or column < 0 or column >= n:\\n            return 0\\n        if k == 0:\\n            return 1\\n        p=0\\n        for i, j in [[-2,-1], [-1,-2], [2,-1],[2,1],[-1,2],[-2,1],[1,-2],[1,2]]:\\n            p += self.knightProbability(n,k-1,row+i,column+j)\\n        return p/8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        if row < 0 or row >= n or column < 0 or column >= n:\\n            return 0\\n        if k == 0:\\n            return 1\\n        p=0\\n        for i, j in [[-2,-1], [-1,-2], [2,-1],[2,1],[-1,2],[-2,1],[1,-2],[1,2]]:\\n            p += self.knightProbability(n,k-1,row+i,column+j)\\n        return p/8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738411,
                "title": "c-dp-approach-3-d-memoization-table-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    double dp[26][26][101];\\n    int dirs[8][2]={{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    double knightProbability(int n, int k, int row, int column) {\\n        return dfs(n,k,row,column);\\n    }\\n    double dfs(int n,int k,int r, int c)\\n    {\\n        if(r<0||r>=n||c<0||c>=n)\\n            return 0.0;\\n        if(k==0)\\n            return 1.0;\\n        if(dp[r][c][k]>0.0)\\n            return dp[r][c][k];\\n        double probability=0.0;\\n        for(int i=0;i<8;i++)\\n        {\\n            probability+=dfs(n,k-1,r+dirs[i][0],c+dirs[i][1])/8.0;\\n        }\\n        return dp[r][c][k]=probability;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dp[26][26][101];\\n    int dirs[8][2]={{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    double knightProbability(int n, int k, int row, int column) {\\n        return dfs(n,k,row,column);\\n    }\\n    double dfs(int n,int k,int r, int c)\\n    {\\n        if(r<0||r>=n||c<0||c>=n)\\n            return 0.0;\\n        if(k==0)\\n            return 1.0;\\n        if(dp[r][c][k]>0.0)\\n            return dp[r][c][k];\\n        double probability=0.0;\\n        for(int i=0;i<8;i++)\\n        {\\n            probability+=dfs(n,k-1,r+dirs[i][0],c+dirs[i][1])/8.0;\\n        }\\n        return dp[r][c][k]=probability;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719072,
                "title": "3d-memo-approach-evolve-from-recursion",
                "content": "class Solution {\\n    public:\\n    double dp[26][26][101];\\n    double knightProbability(int n, int k, int row, int col) {\\n        \\n        \\n        if(row<0 || col<0 || row>=n || col>=n) return 0;\\n        \\n        if(k==0) return 1;\\n        \\n        \\n        if(dp[row][col][k]!=0)\\n            return dp[row][col][k];\\n        \\n        double a=knightProbability(n,k-1,row-2,col+1);\\n        double b=knightProbability(n,k-1,row-1,col+2);\\n        double c=knightProbability(n,k-1,row+2,col+1);\\n        double d=knightProbability(n,k-1,row+1,col+2);\\n        double e=knightProbability(n,k-1,row+2,col-1);\\n        double f=knightProbability(n,k-1,row+1,col-2);\\n        double g=knightProbability(n,k-1,row-1,col-2);\\n        double h=knightProbability(n,k-1,row-2,col-1);\\n        \\n        return dp[row][col][k]=(a+b+c+d+e+f+g+h)/8;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public:\\n    double dp[26][26][101];\\n    double knightProbability(int n, int k, int row, int col) {\\n        \\n        \\n        if(row<0 || col<0 || row>=n || col>=n) return 0;\\n        \\n        if(k==0) return 1;\\n        \\n        \\n        if(dp[row][col][k]!=0)\\n            return dp[row][col][k];\\n        \\n        double a=knightProbability(n,k-1,row-2,col+1);\\n        double b=knightProbability(n,k-1,row-1,col+2);\\n        double c=knightProbability(n,k-1,row+2,col+1);\\n        double d=knightProbability(n,k-1,row+1,col+2);\\n        double e=knightProbability(n,k-1,row+2,col-1);\\n        double f=knightProbability(n,k-1,row+1,col-2);\\n        double g=knightProbability(n,k-1,row-1,col-2);\\n        double h=knightProbability(n,k-1,row-2,col-1);\\n        \\n        return dp[row][col][k]=(a+b+c+d+e+f+g+h)/8;\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1389676,
                "title": "c-dfs-memoization",
                "content": "```\\npublic class Solution {\\n    private int [] Xs = {-2, -1, 1, 2, -2, -1, 1, 2};\\n    private int [] Ys = {-1, -2, -2, -1, 1, 2, 2, 1};\\n\\n    public double KnightProbability(int n, int k, int row, int column) {\\n        var cache = new double[n,n,k + 1];\\n        \\n        return KnightProbability(n, k, row, column, cache);;\\n    }\\n    \\n    public double KnightProbability(int n, int k, int row, int column, double[,,] cache) {\\n        if(k == 0)\\n        {\\n            return 1;\\n        }\\n        \\n        if(cache[row, column, k] != 0.0)\\n        {\\n            return cache[row, column, k];\\n        }\\n        \\n        var neighbours = BuildNeighbours(row, column, n);\\n        var prob = 0.0;\\n        \\n        foreach(var neighbour in neighbours)\\n        {\\n            prob += KnightProbability(n, k - 1, neighbour[0], neighbour[1], cache);  \\n        }\\n        \\n        cache[row, column, k] = prob / 8.0;\\n        \\n        return cache[row, column, k];\\n    }\\n    \\n    private IList<int[]> BuildNeighbours(int row, int col, int n)\\n    {\\n        var neighbours = new List<int[]>();\\n        \\n        for(int index = 0; index < Xs.Length; index++)\\n        {\\n            var newRow = row + Ys[index];\\n            var newCol = col + Xs[index];\\n            \\n            if(newRow >= 0 && newRow < n &&\\n              newCol >= 0 && newCol < n)\\n            {\\n                neighbours.Add(new int[] {newRow, newCol});\\n            }\\n        }\\n        \\n        return neighbours;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int [] Xs = {-2, -1, 1, 2, -2, -1, 1, 2};\\n    private int [] Ys = {-1, -2, -2, -1, 1, 2, 2, 1};\\n\\n    public double KnightProbability(int n, int k, int row, int column) {\\n        var cache = new double[n,n,k + 1];\\n        \\n        return KnightProbability(n, k, row, column, cache);;\\n    }\\n    \\n    public double KnightProbability(int n, int k, int row, int column, double[,,] cache) {\\n        if(k == 0)\\n        {\\n            return 1;\\n        }\\n        \\n        if(cache[row, column, k] != 0.0)\\n        {\\n            return cache[row, column, k];\\n        }\\n        \\n        var neighbours = BuildNeighbours(row, column, n);\\n        var prob = 0.0;\\n        \\n        foreach(var neighbour in neighbours)\\n        {\\n            prob += KnightProbability(n, k - 1, neighbour[0], neighbour[1], cache);  \\n        }\\n        \\n        cache[row, column, k] = prob / 8.0;\\n        \\n        return cache[row, column, k];\\n    }\\n    \\n    private IList<int[]> BuildNeighbours(int row, int col, int n)\\n    {\\n        var neighbours = new List<int[]>();\\n        \\n        for(int index = 0; index < Xs.Length; index++)\\n        {\\n            var newRow = row + Ys[index];\\n            var newCol = col + Xs[index];\\n            \\n            if(newRow >= 0 && newRow < n &&\\n              newCol >= 0 && newCol < n)\\n            {\\n                neighbours.Add(new int[] {newRow, newCol});\\n            }\\n        }\\n        \\n        return neighbours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367432,
                "title": "dp-bottom-up",
                "content": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int knightRow, int knightCol) {\\n        double[][] curr = new double[n][n];\\n        double[][] next = new double[n][n];\\n        int knightMoves[][] = {{-2, 1}, {-1, 2},{1,2},{2, 1},{2, -1},{1, -2}, {-1, -2},{-2,-1}};\\n        curr[knightRow][knightCol] = 1;\\n        while (k-- > 0) {\\n            for (int row = 0; row < n; row++) {\\n                for (int col = 0; col < n; col++) {\\n                    if(curr[row][col] != 0) {\\n                        for (int direction[] : knightMoves) {\\n                            int newRow = row + direction[0];\\n                            int newCol = col + direction[1];\\n                            if (0 <= newRow && newRow < n && 0 <= newCol && newCol < n){\\n                                next[newRow][newCol] += curr[row][col] / 8;\\n                            }\\n                        }   \\n                    }\\n                }\\n            }\\n            curr = next; \\n            next = new double[n][n];\\n        }\\n        double probability = 0.00;\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                probability += curr[row][col];\\n            }\\n        }\\n        return probability;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public double knightProbability(int n, int k, int knightRow, int knightCol) {\\n        double[][] curr = new double[n][n];\\n        double[][] next = new double[n][n];\\n        int knightMoves[][] = {{-2, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1114360,
                "title": "c-simple-3d-dp-faster-than-87-64",
                "content": "From a position horse can take 8 possible steps with 1/8 probability.\\nAll the possible ways are stored in  **2D way vector**.\\n\\n* **STATE** : chess[i][j][k] this DP state indicates probability of horse to be in the chess board after k steps from i,j position;\\n* **CHOICES** : horse can come to this i,j index from 8 possible positions. with 1/8 th probability.\\n\\nSo, chess[i][j][k] = 1/8*(sum of all possible ways to get here probabilities) \\n\\n\\n**UPVOTE** if its helpful !!\\n```\\nclass Solution {\\npublic:\\n    int sz;\\n    bool isValid(int i,int j)\\n    {\\n        return i<0||j<0||i>sz-1||j>sz-1?0:1;\\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        sz=N;\\n        vector<vector<int>> ways={{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{-1,2},{1,-2},{-1,-2}};\\n        double chess [N][N][K+1];\\n        //on 0 step lets assume all we have filled all boxes with 1\\'s to caluculate probabities for 1st step.\\n        for(int i=0;i<N;i++)\\n            for(int j=0;j<N;++j)\\n                chess[i][j][0]=1;\\n        \\n        for(int k=1;k<K+1;++k)\\n            for(int i=0;i<N;++i)\\n                for(int j=0;j<N;++j)\\n                {\\n                    double s=0;\\n                    for(auto &v : ways)\\n                    {\\n                        int ni=i+v[0],nj=j+v[1];\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//sum of all valid possibilities. \\n\\t\\t\\t\\t\\t\\t// k-1 means that we are caluculating from the last step taken.\\n                        if(isValid(ni,nj)) s+=chess[ni][nj][k-1];\\n                    }\\n\\t\\t\\t\\t\\t// 1/8 probability to get to i,j from all possible boxes.\\n                    chess[i][j][k]=s/8;                    \\n                }\\n        return chess[r][c][K];        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int sz;\\n    bool isValid(int i,int j)\\n    {\\n        return i<0||j<0||i>sz-1||j>sz-1?0:1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1079199,
                "title": "java-memoization-solution-with-approach-explained",
                "content": "\\t// recursive solution\\n\\t/*\\n\\t  approach : here probability of cell i,j means the probability that the knight will still remains inside grid if it moves from cell i,j\\n\\t\\t--> if we are out of grid,then probability is 0\\n\\t\\t--> if k==0 , then we are out of moves while we are still inside grid hence probability is 1\\n\\t\\t-->instead of finding probability of current step from previous step , we will do reverse of it I.e. we will find current probability from next probability.\\n\\t\\t--> suppose when k reaches 0 and still we are inside grid at cell i,j , then probability of all 8 cells from which we reaches cell i,j is 1/8 and so on.\\n\\t\\t--> as we have 8 possibilites to go from current cell to next cell, then the current probability += next probability/8\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic double knightProbability(int N, int K, int r, int c) {\\n\\t\\t\\treturn recursiveHelper(r,c,N,K);\\n\\t\\t}\\n\\t\\tprivate double recursiveHelper(int x,int y,int n,int k){\\n\\t\\t\\tif(x<0 || y<0 || x>=n || y>=n)\\n\\t\\t\\t\\treturn 0d;\\n\\t\\t\\tif(k==0)\\n\\t\\t\\t\\treturn 1d;\\n\\t\\t\\tdouble in = 0d;\\n\\t\\t\\tint[] dx = {2,2,-2,-2,1,1,-1,-1};\\n\\t\\t\\tint[] dy = {-1,1,-1,1,2,-2,2,-2};\\n\\t\\t\\tfor(int i=0;i<8;i++){\\n\\t\\t\\t\\tdouble next = recursiveHelper(x+dx[i],y+dy[i],n,k-1);\\n\\t\\t\\t\\tin+= next/8.0;\\n\\t\\t\\t}\\n\\t\\t\\treturn in;\\n\\t\\t}\\n\\t}\\n\\n\\t// memoization of above recursive solution with time and space complexity : O(n*n*k)\\n\\tclass Solution {\\n\\t\\tpublic double knightProbability(int N, int K, int r, int c) {\\n\\t\\t\\tdouble[][][] dp = new double[N][N][K+1];\\n\\t\\t\\tfor(int i=0;i<N;i++)\\n\\t\\t\\t\\tfor(int j=0;j<N;j++)\\n\\t\\t\\t\\t\\tArrays.fill(dp[i][j],-1);\\n\\t\\t\\treturn memoHelper(r,c,N,K,dp);\\n\\t\\t}\\n\\t\\tprivate double memoHelper(int x,int y,int n,int k,double[][][] dp){\\n\\t\\t\\tif(x<0 || y<0 || x>=n || y>=n)\\n\\t\\t\\t\\treturn 0d;\\n\\t\\t\\tif(k==0)\\n\\t\\t\\t\\treturn 1d;\\n\\t\\t\\tif(dp[x][y][k]!=-1)return dp[x][y][k];\\n\\t\\t\\tdouble in = 0d;\\n\\t\\t\\tint[] dx = {2,2,-2,-2,1,1,-1,-1};\\n\\t\\t\\tint[] dy = {-1,1,-1,1,2,-2,2,-2};\\n\\t\\t\\tfor(int i=0;i<8;i++){\\n\\t\\t\\t\\tdouble next = memoHelper(x+dx[i],y+dy[i],n,k-1,dp);\\n\\t\\t\\t\\tin+= next/8.0;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[x][y][k] = in;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic double knightProbability(int N, int K, int r, int c) {\\n\\t\\t\\treturn recursiveHelper(r,c,N,K);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1062139,
                "title": "java-recursion-memo-easy-to-understand",
                "content": "```\\n    HashMap<String, Double> cache = new HashMap<>();\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if(K == 0) return 1;\\n        String key = K + \" \" + r + \" \" + c;\\n        if(cache.containsKey(key)) return cache.get(key);\\n\\n        double res = 0;\\n        int[][] dir = new int[][]{{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {-1, 2}, {1, -2}, {-1, -2}};\\n        for(int i = 0; i < 8; i++) {\\n\\t\\t    //get all 8 directions\\n            int x = c + dir[i][0];\\n            int y = r + dir[i][1];\\n\\t\\t\\t//fliter steps which are out of chessboard\\n            if(x < 0 || x >= N) continue;\\n            if(y < 0 || y >= N) continue;\\n\\t\\t\\t//recursion\\n            res +=  knightProbability(N, K - 1, y, x);\\n        }\\n        \\n        cache.put(key, res / 8);\\n        return cache.get(key);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    HashMap<String, Double> cache = new HashMap<>();\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if(K == 0) return 1;\\n        String key = K + \" \" + r + \" \" + c;\\n        if(cache.containsKey(key)) return cache.get(key);\\n\\n        double res = 0;\\n        int[][] dir = new int[][]{{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {-1, 2}, {1, -2}, {-1, -2}};\\n        for(int i = 0; i < 8; i++) {\\n\\t\\t    //get all 8 directions\\n            int x = c + dir[i][0];\\n            int y = r + dir[i][1];\\n\\t\\t\\t//fliter steps which are out of chessboard\\n            if(x < 0 || x >= N) continue;\\n            if(y < 0 || y >= N) continue;\\n\\t\\t\\t//recursion\\n            res +=  knightProbability(N, K - 1, y, x);\\n        }\\n        \\n        cache.put(key, res / 8);\\n        return cache.get(key);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015683,
                "title": "simple-python-recursive-dp-solution-beats-99-12-of-solutions",
                "content": "def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        \\n        \"\"\"\\n        Probability =  total amount of moves that are on the board / total amount of moves\\n        total amount of moves = 8^K\\n        This is because for each of the 8 possible moves, there are also 8 for each of those.\\n        This could easily be a dp problem with memoization as well saving the amount of possible moves\\n        per coordinate.\\n        \"\"\"\\n        @functools.lru_cache(maxsize=None)\\n        def recur(x,y,k,memo={}):\\n            #Check for bounds\\n            if x < 0 or x > N - 1:\\n                return 0\\n            if y < 0 or y > N - 1:\\n                return 0\\n            \\n\\t\\t\\t#If we reached the last possible move and it isn\\'t out of bounds, return 1\\n            if k == 0:\\n                return 1\\n            \\n\\t\\t\\t#Add up all of the possible moves which are in bounds for each of the 8 directions\\n            total_sum = recur(x+2,y-1,k-1) + recur(x+2,y+1,k-1)+ recur(x-2,y-1,k-1)+ recur(x-2,y+1,k-1)+ recur(x-1,y+2,k-1)+ recur(x-1,y-2,k-1)+ recur(x+1,y+2,k-1)+ recur(x+1,y-2,k-1)\\n            \\n            return total_sum\\n        \\n        return recur(c,r,K)/(8**K)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        \\n        \"\"\"\\n        Probability =  total amount of moves that are on the board / total amount of moves\\n        total amount of moves = 8^K\\n        This is because for each of the 8 possible moves, there are also 8 for each of those.\\n        This could easily be a dp problem with memoization as well saving the amount of possible moves\\n        per coordinate.\\n        \"\"\"\\n        @functools.lru_cache(maxsize=None)\\n        def recur(x,y,k,memo={}):\\n            #Check for bounds\\n            if x < 0 or x > N - 1:\\n                return 0\\n            if y < 0 or y > N - 1:\\n                return 0\\n            \\n\\t\\t\\t#If we reached the last possible move and it isn\\'t out of bounds, return 1\\n            if k == 0:\\n                return 1\\n            \\n\\t\\t\\t#Add up all of the possible moves which are in bounds for each of the 8 directions\\n            total_sum = recur(x+2,y-1,k-1) + recur(x+2,y+1,k-1)+ recur(x-2,y-1,k-1)+ recur(x-2,y+1,k-1)+ recur(x-1,y+2,k-1)+ recur(x-1,y-2,k-1)+ recur(x+1,y+2,k-1)+ recur(x+1,y-2,k-1)\\n            \\n            return total_sum\\n        \\n        return recur(c,r,K)/(8**K)",
                "codeTag": "Python3"
            },
            {
                "id": 912694,
                "title": "c-faster-than-99",
                "content": "class Solution {\\n    \\npublic:\\n         int  dx[8]= { -2, -1, 1, 2, -2, -1, 1, 2 };\\n         int  dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n        double memo[100][26][26];  \\n        Solution()\\n        {\\n          for(int i=0;i<100;i++)\\n             for(int j=0;j<26;j++)\\n                for(int k=0;k<26;k++)\\n                  memo[i][j][k]=-1;\\n        }\\n \\n\\n     double knightProbability(int N, int K, int r, int c) {\\n         \\n          if(r<0 || r>=N || c<0 || c>=N)\\n              return 0;\\n        \\n         if(memo[K][r][c]!=-1) return memo[K][r][c];   \\n        \\n          double ans=0;\\n         if(K==0)\\n         {\\n             return 1.0;\\n         }\\n       \\n       \\n        for(int i=0;i<8;i++)\\n        { \\n          \\n            ans += knightProbability(N, K-1, r+dx[i], c+dy[i])*0.125;\\n          \\n        }\\n        return  memo[K][r][c]=ans;\\n     \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\npublic:\\n         int  dx[8]= { -2, -1, 1, 2, -2, -1, 1, 2 }",
                "codeTag": "Java"
            },
            {
                "id": 902373,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        \\n        @lru_cache(None)\\n        def fn(k, i, j): \\n            \"\"\"Return probability in chessboard at (i, j) with k moves left.\"\"\"\\n            if not (0 <= i < N and 0 <= j < N): return 0\\n            if k == 0: return 1 \\n            return 1/8*sum(fn(k-1, i+ii, j+jj) for ii, jj in ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)))\\n            \\n        return fn(K, r, c)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        \\n        @lru_cache(None)\\n        def fn(k, i, j): \\n            \"\"\"Return probability in chessboard at (i, j) with k moves left.\"\"\"\\n            if not (0 <= i < N and 0 <= j < N): return 0\\n            if k == 0: return 1 \\n            return 1/8*sum(fn(k-1, i+ii, j+jj) for ii, jj in ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)))\\n            \\n        return fn(K, r, c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886745,
                "title": "why-am-i-getting-tle-for-a-recursive-memoized-solution",
                "content": "Hi all, apologies if this has already been answered, but I was wondering if someone could tell me why this solution is getting Time Limit Exceeded?\\n\\n```\\nclass Solution(object):\\n    def knightProbability(self, N, k, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        if k == 0:\\n            return 1\\n        return self.helper(N, k, r, c, {})\\n    \\n    # Recursion + memoization\\n    def helper(self, N, k, r, c, seen):\\n        if (r,c) in seen:\\n            valid_moves = seen[(r,c)]\\n        else:  \\n            valid_moves = self.valid_moves(N, r, c)\\n            seen[(r,c)] = valid_moves\\n        if k == 1:\\n            return 0.125 * len(valid_moves)\\n        prob = 0\\n        for mr, mc in valid_moves:\\n            prob += 0.125 * self.helper(N, k-1, mr, mc, seen)\\n        return prob\\n        \\n        \\n    # Check the validity of moves\\n    def valid_moves(self, N, r, c):\\n        valid = set()\\n        if r+2 < N:\\n            if c-1 >= 0:\\n                valid.add((r+2, c-1))\\n            if c+1 < N:\\n                valid.add((r+2, c+1))\\n        if r-2 >= 0:\\n            if c-1 >= 0:\\n                valid.add((r-2, c-1))\\n            if c+1 < N:\\n                valid.add((r-2, c+1))\\n        if r+1 < N:\\n            if c-2 >= 0:\\n                valid.add((r+1, c-2))\\n            if c+2 < N:\\n                valid.add((r+1, c+2))\\n        if r-1 >= 0:\\n            if c-2 >= 0:\\n                valid.add((r-1, c-2))\\n            if c+2 < N:\\n                valid.add((r-1, c+2))\\n        return valid\\n```\\n\\nThanks!",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def knightProbability(self, N, k, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        if k == 0:\\n            return 1\\n        return self.helper(N, k, r, c, {})\\n    \\n    # Recursion + memoization\\n    def helper(self, N, k, r, c, seen):\\n        if (r,c) in seen:\\n            valid_moves = seen[(r,c)]\\n        else:  \\n            valid_moves = self.valid_moves(N, r, c)\\n            seen[(r,c)] = valid_moves\\n        if k == 1:\\n            return 0.125 * len(valid_moves)\\n        prob = 0\\n        for mr, mc in valid_moves:\\n            prob += 0.125 * self.helper(N, k-1, mr, mc, seen)\\n        return prob\\n        \\n        \\n    # Check the validity of moves\\n    def valid_moves(self, N, r, c):\\n        valid = set()\\n        if r+2 < N:\\n            if c-1 >= 0:\\n                valid.add((r+2, c-1))\\n            if c+1 < N:\\n                valid.add((r+2, c+1))\\n        if r-2 >= 0:\\n            if c-1 >= 0:\\n                valid.add((r-2, c-1))\\n            if c+1 < N:\\n                valid.add((r-2, c+1))\\n        if r+1 < N:\\n            if c-2 >= 0:\\n                valid.add((r+1, c-2))\\n            if c+2 < N:\\n                valid.add((r+1, c+2))\\n        if r-1 >= 0:\\n            if c-2 >= 0:\\n                valid.add((r-1, c-2))\\n            if c+2 < N:\\n                valid.add((r-1, c+2))\\n        return valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821104,
                "title": "c-dp-using-bfs",
                "content": "```\\n    double knightProbability(int N, int K, int r, int c) {\\n        if (K == 0) return 1.0;\\n        int dirs[8][2] = {{-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};\\n        int step = 0;\\n        vector<vector<double>> cur(N, vector<double>(N, 0)), next(N, vector<double>(N, 0));\\n        queue<pair<int,int>> Q;\\n        double prob = (double)(1)/(double)(8);\\n        \\n        cur[r][c] = 1;\\n        Q.push({r,c});\\n        \\n        while (!Q.empty()) {\\n            for (int cnt = Q.size(); cnt > 0; cnt--) {\\n                pair<int,int> P = Q.front(); Q.pop();\\n                for (int i = 0; i < 8; i++) {\\n                    int nr = P.first + dirs[i][0], nc = P.second + dirs[i][1];\\n                    if (nr < 0 || nr >= N || nc < 0 || nc >= N) continue;\\n                    if (cur[P.first][P.second] * prob > 0)\\n                        next[nr][nc] += (cur[P.first][P.second]);\\n                }\\n            }\\n            if (++step == K) break;\\n            prob /= 8;\\n            for (int r = 0; r < N; r++) {\\n                for (int c = 0; c < N; c++) {\\n                    if (next[r][c] > 0) Q.push({r,c});\\n                    cur[r][c] = 0;\\n                }\\n            }\\n            swap(cur, next);\\n        }\\n        \\n        double res = 0;\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                if (next[r][c] > 0) res += next[r][c];\\n            }\\n        }\\n        return res*prob;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double knightProbability(int N, int K, int r, int c) {\\n        if (K == 0) return 1.0;\\n        int dirs[8][2] = {{-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};\\n        int step = 0;\\n        vector<vector<double>> cur(N, vector<double>(N, 0)), next(N, vector<double>(N, 0));\\n        queue<pair<int,int>> Q;\\n        double prob = (double)(1)/(double)(8);\\n        \\n        cur[r][c] = 1;\\n        Q.push({r,c});\\n        \\n        while (!Q.empty()) {\\n            for (int cnt = Q.size(); cnt > 0; cnt--) {\\n                pair<int,int> P = Q.front(); Q.pop();\\n                for (int i = 0; i < 8; i++) {\\n                    int nr = P.first + dirs[i][0], nc = P.second + dirs[i][1];\\n                    if (nr < 0 || nr >= N || nc < 0 || nc >= N) continue;\\n                    if (cur[P.first][P.second] * prob > 0)\\n                        next[nr][nc] += (cur[P.first][P.second]);\\n                }\\n            }\\n            if (++step == K) break;\\n            prob /= 8;\\n            for (int r = 0; r < N; r++) {\\n                for (int c = 0; c < N; c++) {\\n                    if (next[r][c] > 0) Q.push({r,c});\\n                    cur[r][c] = 0;\\n                }\\n            }\\n            swap(cur, next);\\n        }\\n        \\n        double res = 0;\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                if (next[r][c] > 0) res += next[r][c];\\n            }\\n        }\\n        return res*prob;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804600,
                "title": "java-recursive-memoized-solution",
                "content": "```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double dp[][][]=new double[N+1][N+1][K+1];\\n        for(double ar[][]:dp){\\n            for(double br[]:ar){\\n                Arrays.fill(br,-1);\\n            }\\n        }\\n        return helper(N,K,r,c,dp);\\n    }\\n    double helper(int N,int K,int r,int c,double dp[][][]){\\n        if(r>=N||r<0||c>=N||c<0){\\n            return 0;\\n        }\\n        if(K==0){\\n            return 1;\\n        }\\n        if(dp[r][c][K]!=-1){\\n            return dp[r][c][K];\\n        }\\n        double a=\\n        helper(N,K-1,r+2,c+1,dp)+\\n        helper(N,K-1,r-2,c+1,dp)+\\n        helper(N,K-1,r+2,c-1,dp)+\\n        helper(N,K-1,r-2,c-1,dp)+\\n        helper(N,K-1,r+1,c+2,dp)+\\n        helper(N,K-1,r-1,c+2,dp)+\\n        helper(N,K-1,r+1,c-2,dp)+\\n        helper(N,K-1,r-1,c-2,dp);\\n        dp[r][c][K]= a/8;\\n        return dp[r][c][K];\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double dp[][][]=new double[N+1][N+1][K+1];\\n        for(double ar[][]:dp){\\n            for(double br[]:ar){\\n                Arrays.fill(br,-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 799552,
                "title": "python-based-memoization-solution",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        @functools.lru_cache(None)\\n        def solve(N,K,r,c):\\n            if(r < 0 or r > N - 1 or c < 0 or c > N - 1):\\n                return 0\\n            if K==0:\\n                return 1\\n            rate=0\\n            for i in dir:\\n                rate+=0.125 * solve(N,K-1,r+i[0],c+i[-1])\\n            return rate\\n        dir=[[-2,-1],[-1,-2],[1,-2],[2,-1],[2,1],[1,2],[-1,2],[-2,1]]\\n        return solve(N,K,r,c)\\n        \\n```\\n\\nReasons:\\n1. Why 0.125 ? as there are 8 possible ways for knight to move => probability =1/8==>0.125\\n2. What dir is ? is a list which store the possible paths for knight to move\\n3. Why k==0 returns 1? Because k==0 means were are the start i.e. (0,0) so we need not move, the probability for this path is 1\\nRefer : https://www.youtube.com/watch?v=OrS7PaJ-5ck for visual explanition of probabilites.",
                "solutionTags": [
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        @functools.lru_cache(None)\\n        def solve(N,K,r,c):\\n            if(r < 0 or r > N - 1 or c < 0 or c > N - 1):\\n                return 0\\n            if K==0:\\n                return 1\\n            rate=0\\n            for i in dir:\\n                rate+=0.125 * solve(N,K-1,r+i[0],c+i[-1])\\n            return rate\\n        dir=[[-2,-1],[-1,-2],[1,-2],[2,-1],[2,1],[1,2],[-1,2],[-2,1]]\\n        return solve(N,K,r,c)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 765455,
                "title": "python-easy-to-understand-memo",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        self.n = N\\n        self.memo = {}\\n        \\n        def calc_probability(r, c, k):\\n            if k == 0:\\n                return 1\\n            \\n            if (r, c, k) in self.memo:\\n                return self.memo[(r, c, k)]\\n            \\n            res = 0\\n            \\n            moves = ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2))\\n            for i, j in moves:\\n                new_i, new_j = r + i, j + c\\n                if 0 <= new_i < self.n and 0 <= new_j < self.n:\\n                    res += (1/8) * calc_probability(new_i, new_j, k - 1)\\n                  \\n            self.memo[(r, c, k)] = res\\n            return res\\n        \\n        return calc_probability(r, c, K)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        self.n = N\\n        self.memo = {}\\n        \\n        def calc_probability(r, c, k):\\n            if k == 0:\\n                return 1\\n            \\n            if (r, c, k) in self.memo:\\n                return self.memo[(r, c, k)]\\n            \\n            res = 0\\n            \\n            moves = ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2))\\n            for i, j in moves:\\n                new_i, new_j = r + i, j + c\\n                if 0 <= new_i < self.n and 0 <= new_j < self.n:\\n                    res += (1/8) * calc_probability(new_i, new_j, k - 1)\\n                  \\n            self.memo[(r, c, k)] = res\\n            return res\\n        \\n        return calc_probability(r, c, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730664,
                "title": "recursion-memoization-top-down-approach",
                "content": "```\\ndouble dp[26][26][101];\\nclass Solution {\\npublic:\\n    double countSteps(int N,int K,int r,int c,vector<int> rows,vector<int> cols){\\n        \\n        if(r<0 || r>=N || c<0 || c>=N)\\n            return 0;\\n        if(K==0)\\n            return 1;\\n        if(dp[r][c][K]!=0)\\n            return dp[r][c][K];\\n        double validPos = 0;\\n        for(int i=0;i<8;i++){\\n           \\n             validPos+=countSteps(N,K-1,r+rows[i],c+cols[i],rows,cols);\\n        }\\n        return dp[r][c][K] = validPos/8;\\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        \\n        double prob;\\n        memset(dp,0.0,sizeof(dp));\\n        vector<int> rows = {1,1,2,2,-1,-1,-2,-2};\\n        vector<int> cols = {2,-2,1,-1,2,-2,-1,1};\\n        prob = countSteps(N,K,r,c,rows,cols);\\n        return prob;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndouble dp[26][26][101];\\nclass Solution {\\npublic:\\n    double countSteps(int N,int K,int r,int c,vector<int> rows,vector<int> cols){\\n        \\n        if(r<0 || r>=N || c<0 || c>=N)\\n            return 0;\\n        if(K==0)\\n            return 1;\\n        if(dp[r][c][K]!=0)\\n            return dp[r][c][K];\\n        double validPos = 0;\\n        for(int i=0;i<8;i++){\\n           \\n             validPos+=countSteps(N,K-1,r+rows[i],c+cols[i],rows,cols);\\n        }\\n        return dp[r][c][K] = validPos/8;\\n    }\\n    double knightProbability(int N, int K, int r, int c) {\\n        \\n        double prob;\\n        memset(dp,0.0,sizeof(dp));\\n        vector<int> rows = {1,1,2,2,-1,-1,-2,-2};\\n        vector<int> cols = {2,-2,1,-1,2,-2,-1,1};\\n        prob = countSteps(N,K,r,c,rows,cols);\\n        return prob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679678,
                "title": "very-straightforward-c-solution-three-variations-compared",
                "content": "```\\nclass Solution {\\npublic:\\n    //268 ms\\n    //method 3, dynamic programming (with alternating array), the trick is the turn the problem into a counting problem\\n    //the difference between method 2 and 3 is that method 3 uses a 2D array for the dp array, whereas method 2 uses 3D array\\n    //this is because we only need kth and k-1th status for the computation\\n    //1. the total possible # of outcomes for moving a knight k times is 8^k, because a knight can move in 8 directions every time\\n    //2. count # of possible paths leading to a spot on the baord at the kth move\\n    \\n    //let dp[k][i][j] be # of ways to be on the board at the kth move\\n    //base case:\\n    //    dp[0][i][j] = 1, only one way to be on the board when k == 0, that is no move and i,j are valid board coordinates\\n    //general case:\\n    //    dp[k][i][j] = sum(dp[k-1][x][y]), where x,y are all the locations on the board that can lead to i,j by the knight move\\n    \\n    //T(n) = O(K*N*N), basically the dimension of the dp array\\n    //S(n) = O(N*N)\\n    double knightProbability(int N, int K, int r, int c) {\\n\\n        vector<vector<double>> dp0(N+1, vector<double>(N+1,0));\\n        dp0[r][c] = 1;//this is for the base case where dp[0][i][j] == 1\\n        static vector<vector<int>> directions = {{1,2},{-1,-2},{-1,2},{1,-2},{2,1},{-2,-1},{-2,1},{2,-1}};\\n        for(int k = 1; k <= K; k++){\\n            vector<vector<double>> dp1(N+1, vector<double>(N+1,0));\\n            for(int i = 0; i < N; i++){\\n                for(int j = 0; j < N; j++){\\n                    for(auto d : directions){\\n                        int x = i + d[0];\\n                        int y = j + d[1];\\n                        if(x>=0 && x<N && y>=0 && y<N){\\n                            dp1[i][j] += dp0[x][y];\\n                        }\\n                    }\\n                }\\n            }\\n            swap(dp0,dp1);\\n        }\\n        ///compute the total # of ways that the knight could lead to be on the board at kth move\\n        double sum = 0;\\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                sum += dp0[i][j];\\n            }\\n        }\\n        return sum/pow(8,K);\\n    }\\n    \\n};\\n/*\\nclass Solution {\\npublic:\\n    //520 ms\\n    //method 2, dynamic programming (without alternating array), the trick is the turn the problem into a counting problem\\n    //1. the total possible # of outcomes for moving a knight k times is 8^k, because a knight can move in 8 directions every time\\n    //2. count # of possible paths leading to a spot on the baord at the kth move\\n    \\n    //let dp[k][i][j] be # of ways to be on the board at the kth move\\n    //base case:\\n    //    dp[0][i][j] = 1, only one way to be on the board when k == 0, that is no move and i,j are valid board coordinates\\n    //general case:\\n    //    dp[k][i][j] = sum(dp[k-1][x][y]), where x,y are all the locations on the board that can lead to i,j by the knight move\\n    \\n    //T(n) = O(K*N*N), basically the dimension of the dp array\\n    //S(n) = O(K*N*N)\\n    double knightProbability(int N, int K, int r, int c) {\\n\\n        vector<vector<vector<double>>> dp(K+1, vector<vector<double>>(N+1, vector<double>(N+1,0)));\\n        dp[0][r][c] = 1;//this is for the base case where dp[0][i][j] == 1\\n        static vector<vector<int>> directions = {{1,2},{-1,-2},{-1,2},{1,-2},{2,1},{-2,-1},{-2,1},{2,-1}};\\n        for(int k = 1; k <= K; k++){\\n            for(int i = 0; i < N; i++){\\n                for(int j = 0; j < N; j++){\\n                    for(auto d : directions){\\n                        int x = i + d[0];\\n                        int y = j + d[1];\\n                        if(x>=0 && x<N && y>=0 && y<N){\\n                            dp[k][i][j] += dp[k-1][x][y];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ///compute the total # of ways that the knight could lead to be on the board at kth move\\n        double sum = 0;\\n        for(int i = 0; i < N; i++){\\n            for(int j = 0; j < N; j++){\\n                sum += dp[K][i][j];\\n            }\\n        }\\n        return sum/pow(8,K);\\n    }\\n    \\n};\\n*/\\n    \\n/*\\nclass Solution {\\npublic:\\n    //time spent: 20ms\\n    //method 1, dfs, the trick is the turn the problem into a counting problem\\n    //1. the total possible # of outcomes for moving a knight k times is 8^k, because a knight can move in 8 directions every time\\n    //2. using dfs for counting # of outcomes where a knight moved k times and landed on the board\\n    //T(n) = O(K*N*N), basically the dimension of the dp array\\n    //S(n) = O(K*N*N)\\n    \\n    double knightProbability(int N, int K, int r, int c) {\\n        vector<vector<vector<double>>> dp(K+1, vector<vector<double>>(N+1, vector<double>(N+1,-9999)));\\n        return count(N, K, r, c, dp)/pow(8,K);\\n    }\\n    \\nprivate:    \\n    double count(int N, int K, int r, int c, vector<vector<vector<double>>>& dp){\\n        if(!(r<N && r>=0 && c<N && c>=0)){\\n            return 0;\\n        }\\n        if(K == 0){\\n            return static_cast<double>(1);//K == 0 indicates the last try is finished, and we should return 1 if it is on the board\\n        }\\n        if(dp[K][r][c] != -9999){\\n            return dp[K][r][c];\\n        }\\n        static vector<vector<int>> directions = {{1,2},{-1,-2},{-1,2},{1,-2},{2,1},{-2,-1},{-2,1},{2,-1}};\\n        \\n        double res = 0;\\n        for(auto& d : directions){\\n            int x = r + d[0];\\n            int y = c + d[1];\\n            res += count(N, K-1, x, y, dp);\\n        }\\n        dp[K][r][c] = res;\\n        return res;\\n    }\\n    \\n};\\n\\n*/",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    //268 ms\\n    //method 3, dynamic programming (with alternating array), the trick is the turn the problem into a counting problem\\n    //the difference between method 2 and 3 is that method 3 uses a 2D array for the dp array, whereas method 2 uses 3D array\\n    //this is because we only need kth and k-1th status for the computation\\n    //1. the total possible # of outcomes for moving a knight k times is 8^k, because a knight can move in 8 directions every time\\n    //2. count # of possible paths leading to a spot on the baord at the kth move\\n    \\n    //let dp[k][i][j] be # of ways to be on the board at the kth move\\n    //base case:\\n    //    dp[0][i][j] = 1, only one way to be on the board when k == 0, that is no move and i,j are valid board coordinates\\n    //general case:\\n    //    dp[k][i][j] = sum(dp[k-1][x][y]), where x,y are all the locations on the board that can lead to i,j by the knight move\\n    \\n    //T(n) = O(K*N*N), basically the dimension of the dp array\\n    //S(n) = O(N*N)\\n    double knightProbability(int N, int K, int r, int c) {\\n\\n        vector<vector<double>> dp0(N+1, vector<double>(N+1,0));\\n        dp0[r][c] = 1;//this is for the base case where dp[0][i][j] == 1\\n        static vector<vector<int>> directions = {{1,2}",
                "codeTag": "Java"
            },
            {
                "id": 641121,
                "title": "python-dp-solution-with-dictionary",
                "content": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        \\n        # Generates all 8 moves\\n        total_moves = {(i, j) for i in {-2, -1, 1, 2} for j in {-2, -1, 1, 2} - {i} - {-i}}\\n              \\n        # A dictionary to store (K, r, c) for DP\\n        mmap = {}\\n        \\n        def dp(K, r, c, cur_prob = 1):\\n            if K == 0:\\n                # If there are no more moves left, then store the probability landing on that \\n                # square, then return the value\\n                mmap[(K, r, c)] = cur_prob\\n                return cur_prob\\n            else:\\n                # Generates all possible moves originating from the current square\\n                pos_moves = {(r + dr, c + dc) for dr, dc in total_moves \\\\\\n                                                    if 0 <= r + dr < N and 0 <= c + dc < N}\\n                res = 0\\n                for dr, dc in pos_moves:\\n                    if (K - 1, dr, dc) in mmap:\\n                        # If the dict already has the probability for that square, \\n                        # then we don\\'t need to recurse\\n                        res += mmap[(K - 1, dr, dc)]\\n                    else:\\n                        # If we had NOT calculated the probability, we recurse into \\n                        # next possible moves, with each move being 1/8th as probable\\n                        res += dp(K - 1, dr, dc, cur_prob / 8)\\n                    \\n                mmap[(K, r, c)] = res\\n                return res\\n            \\n        return dp(K, r, c)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        \\n        # Generates all 8 moves\\n        total_moves = {(i, j) for i in {-2, -1, 1, 2} for j in {-2, -1, 1, 2} - {i} - {-i}}\\n              \\n        # A dictionary to store (K, r, c) for DP\\n        mmap = {}\\n        \\n        def dp(K, r, c, cur_prob = 1):\\n            if K == 0:\\n                # If there are no more moves left, then store the probability landing on that \\n                # square, then return the value\\n                mmap[(K, r, c)] = cur_prob\\n                return cur_prob\\n            else:\\n                # Generates all possible moves originating from the current square\\n                pos_moves = {(r + dr, c + dc) for dr, dc in total_moves \\\\\\n                                                    if 0 <= r + dr < N and 0 <= c + dc < N}\\n                res = 0\\n                for dr, dc in pos_moves:\\n                    if (K - 1, dr, dc) in mmap:\\n                        # If the dict already has the probability for that square, \\n                        # then we don\\'t need to recurse\\n                        res += mmap[(K - 1, dr, dc)]\\n                    else:\\n                        # If we had NOT calculated the probability, we recurse into \\n                        # next possible moves, with each move being 1/8th as probable\\n                        res += dp(K - 1, dr, dc, cur_prob / 8)\\n                    \\n                mmap[(K, r, c)] = res\\n                return res\\n            \\n        return dp(K, r, c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640591,
                "title": "c-dp-solution-memoization",
                "content": "```\\nclass Solution {\\n    double dfs(int N, int K, int r, int c,  vector<vector<vector<double>>>& dp) {\\n        if (r < 0 || c < 0 || r >= N || c >= N)\\n            return 0;\\n        if (K == 0) return 1;\\n        if (dp[K][r][c] != -1) \\n            return dp[K][r][c];\\n        \\n        double moves =  dfs(N, K-1, r-2, c-1, dp) +\\n                        dfs(N, K-1, r-1, c-2, dp) +\\n                        dfs(N, K-1, r+1, c-2, dp) +\\n                        dfs(N, K-1, r+2, c-1, dp) +\\n                        dfs(N, K-1, r-2, c+1, dp) +\\n                        dfs(N, K-1, r-1, c+2, dp) +\\n                        dfs(N, K-1, r+2, c+1, dp) +\\n                        dfs(N, K-1, r+1, c+2, dp);\\n        \\n        moves /= 8;\\n        dp[K][r][c] = moves;\\n        return dp[K][r][c];\\n    }\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        \\n        vector<vector<vector<double>>>dp(K+1, vector<vector<double>>(N+1, vector<double>(N+1, -1)));\\n        return dfs(N, K, r, c, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double dfs(int N, int K, int r, int c,  vector<vector<vector<double>>>& dp) {\\n        if (r < 0 || c < 0 || r >= N || c >= N)\\n            return 0;\\n        if (K == 0) return 1;\\n        if (dp[K][r][c] != -1) \\n            return dp[K][r][c];\\n        \\n        double moves =  dfs(N, K-1, r-2, c-1, dp) +\\n                        dfs(N, K-1, r-1, c-2, dp) +\\n                        dfs(N, K-1, r+1, c-2, dp) +\\n                        dfs(N, K-1, r+2, c-1, dp) +\\n                        dfs(N, K-1, r-2, c+1, dp) +\\n                        dfs(N, K-1, r-1, c+2, dp) +\\n                        dfs(N, K-1, r+2, c+1, dp) +\\n                        dfs(N, K-1, r+1, c+2, dp);\\n        \\n        moves /= 8;\\n        dp[K][r][c] = moves;\\n        return dp[K][r][c];\\n    }\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        \\n        vector<vector<vector<double>>>dp(K+1, vector<vector<double>>(N+1, vector<double>(N+1, -1)));\\n        return dfs(N, K, r, c, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519399,
                "title": "java-solution-clear-explanation-of-complexity",
                "content": "Full explaination: https://link.medium.com/iGvEA46il4\\n\\nSteps:\\nIterate below steps for required k iterations\\n1. Declare a destination matrix with the same size as giving matrix\\n2. Iterate all cells of the source matrix\\ntest the 8 directions, if it is still on board. add the original probability of source cell x 0.125 to the destination cell\\nassign destination matrix to source matrix\\n\\nPerformance:\\n- time complexity: O(nk), n is total no. of cells of the board & k is no. of iterations. In every iteration, the time spent on declaring a new destination matrix with O(n) time complexity. Also, iterate all cell on the source matrix need O(n) time\\n- space complexity: O(n), as it is not doing in place, the size of the destination matrix is O(n), n is total no. of cells of the board\\n\\n```\\nclass Solution {\\n\\n    public static final int[] DIRC_X = {-1, -2, -2, -1, 1, 2, 2, 1};\\n    public static final int[] DIRC_Y = {-2, -1, 1, 2, 2, 1, -1, -2};\\n\\n    public double knightProbability(int n, int k, int r, int c) {\\n        double[][] g = new double[n][n];\\n        g[r][c] = 1;\\n        for (int i = 0; i < k; i++) {\\n            double[][] ng = new double[n][n];\\n            for (int x = 0; x < n; x++) {\\n                for (int y = 0; y < n; y++) {\\n                    if (g[x][y] == 0) continue;\\n                    for (int j = 0; j < 8; j++) {\\n                        int nx = x + DIRC_X[j];\\n                        int ny = y + DIRC_Y[j];\\n                        if(nx<0||nx>=n||ny<0||ny>=n) continue;\\n                        ng[nx][ny] += g[x][y] /8.0;\\n                    }\\n                }\\n            }\\n            g = ng;\\n        }\\n        \\n        double p = 0.0;\\n        for (int x = 0; x < n; x++) {\\n            for (int y = 0; y < n; y++) {\\n                p+=g[x][y];\\n            }\\n        }\\n        return p;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static final int[] DIRC_X = {-1, -2, -2, -1, 1, 2, 2, 1};\\n    public static final int[] DIRC_Y = {-2, -1, 1, 2, 2, 1, -1, -2};\\n\\n    public double knightProbability(int n, int k, int r, int c) {\\n        double[][] g = new double[n][n];\\n        g[r][c] = 1;\\n        for (int i = 0; i < k; i++) {\\n            double[][] ng = new double[n][n];\\n            for (int x = 0; x < n; x++) {\\n                for (int y = 0; y < n; y++) {\\n                    if (g[x][y] == 0) continue;\\n                    for (int j = 0; j < 8; j++) {\\n                        int nx = x + DIRC_X[j];\\n                        int ny = y + DIRC_Y[j];\\n                        if(nx<0||nx>=n||ny<0||ny>=n) continue;\\n                        ng[nx][ny] += g[x][y] /8.0;\\n                    }\\n                }\\n            }\\n            g = ng;\\n        }\\n        \\n        double p = 0.0;\\n        for (int x = 0; x < n; x++) {\\n            for (int y = 0; y < n; y++) {\\n                p+=g[x][y];\\n            }\\n        }\\n        return p;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493175,
                "title": "how-i-get-dp-solution-and-beat-most-for-those-who-struggling-just-like-me-ever",
                "content": "recursion solution get TLE, but easy to understand and write. \\n```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if(r<0 || r>=N || c<0 || c>=N) {\\n            return 0.0;\\n        } \\n        if(K==0) return 1.0;\\n        \\n        int dirs[][] = new int[][]{{-2,1},{-2,-1},{2,1},{2,-1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n        double acc = 0.0;\\n        for(int i=0; i<dirs.length; i++) {\\n            int nr = r+dirs[i][0], nc = c + dirs[i][1];\\n            acc += knightProbability(N, K-1, nr, nc);\\n        }\\n        return acc / dirs.length;\\n    }\\n}\\n```\\nfor DP, we really cares about how to define state, value of state and state transfer. By observing the parameter list in the recursion solution, we noticed that `N` is something doesn\\'t change, but `K`, `r` and `c` will going to change on each recurring calls. So it\\'s a good idea to have them in state, \\n* we should have the dp array like dp[k][r][c] and k could range from 0 to K, r,c range from 0 to N (exclusive)\\n* the value of dp[k][r][c] could be the possibility rate we care about\\n* before we have the state transfer function, we can try to define the value for init state dp[k=0][r][c], when r,c in range it means the Knight stands within Chessboard, this could be value 1.0\\n* with upper init value in mind, when we from k-1 move to k move, our transfer function could be dp[k][r][c] = sum(dp[k-1][r\\'][c\\']), where r\\',c\\' are valid moves from position (r,c)\\n* to reduce memory usage, we can actually iterate K times and keep old dp array.\\n\\nTime complexity is O(K*N*N)\\n```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double dp[][] = new double[N][N], oldDp[][] = new double[N][N], t[][];\\n\\n        for(int row=0; row<N; row++) Arrays.fill(oldDp[row], 1.0);\\n\\n        int dirs[][] = new int[][]{{-2,1},{-2,-1},{2,1},{2,-1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n        \\n        for(int k=0; k<=K; k++) {\\n            for(int row=0; row<N; row++) {\\n                for(int col=0; col<N; col++) {\\n                    dp[row][col] = 0.0;\\n                    for(int i=0; i<dirs.length; i++) {\\n                        int nr = row + dirs[i][0], nc = col + dirs[i][1];\\n                        if(nr < 0 || nr >= N || nc < 0 || nc >= N) continue;\\n                        dp[row][col] += oldDp[nr][nc];\\n                    }\\n                    dp[row][col] /= dirs.length;\\n                }\\n            }\\n            t = oldDp; oldDp = dp; dp = t; \\n        }\\n\\n        return dp[r][c];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        if(r<0 || r>=N || c<0 || c>=N) {\\n            return 0.0;\\n        } \\n        if(K==0) return 1.0;\\n        \\n        int dirs[][] = new int[][]{{-2,1},{-2,-1},{2,1},{2,-1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n        double acc = 0.0;\\n        for(int i=0; i<dirs.length; i++) {\\n            int nr = r+dirs[i][0], nc = c + dirs[i][1];\\n            acc += knightProbability(N, K-1, nr, nc);\\n        }\\n        return acc / dirs.length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double knightProbability(int N, int K, int r, int c) {\\n        double dp[][] = new double[N][N], oldDp[][] = new double[N][N], t[][];\\n\\n        for(int row=0; row<N; row++) Arrays.fill(oldDp[row], 1.0);\\n\\n        int dirs[][] = new int[][]{{-2,1},{-2,-1},{2,1},{2,-1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n        \\n        for(int k=0; k<=K; k++) {\\n            for(int row=0; row<N; row++) {\\n                for(int col=0; col<N; col++) {\\n                    dp[row][col] = 0.0;\\n                    for(int i=0; i<dirs.length; i++) {\\n                        int nr = row + dirs[i][0], nc = col + dirs[i][1];\\n                        if(nr < 0 || nr >= N || nc < 0 || nc >= N) continue;\\n                        dp[row][col] += oldDp[nr][nc];\\n                    }\\n                    dp[row][col] /= dirs.length;\\n                }\\n            }\\n            t = oldDp; oldDp = dp; dp = t; \\n        }\\n\\n        return dp[r][c];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423085,
                "title": "simple-c-dp",
                "content": "```\\n    public class Solution\\n    {\\n        private static (int, int)[] _dirs = { (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1) };\\n\\n        private double Helper(double?[,,] dp, int x, int y, int limit)\\n        {\\n            if (dp[x, y, limit].HasValue)\\n            {\\n                return dp[x, y, limit].Value;\\n            }\\n\\n            if (limit == 0)\\n            {\\n                dp[x, y, limit] = 1;\\n                return dp[x, y, limit].Value;\\n            }\\n\\n            double res = 0;\\n            int nextLimit = limit - 1;\\n\\n            foreach (var dir in _dirs)\\n            {\\n                int nextX = x + dir.Item1;\\n                int nextY = y + dir.Item2;\\n\\n                if (nextX >= 0 && nextX < dp.GetLength(0) && nextY >= 0 && nextY < dp.GetLength(1))\\n                {\\n                    double inner = Helper(dp, nextX, nextY, nextLimit);\\n                    res = res + inner;\\n                }\\n            }\\n\\n            dp[x, y, limit] = res / _dirs.Length;\\n            return dp[x, y, limit].Value;\\n        }\\n\\n\\n        public double KnightProbability(int n, int limit, int startX, int startY)\\n        {\\n            if(limit == 0)\\n            {\\n                return 1;\\n            }\\n\\n            double?[,,] dp = new double?[n, n, limit + 1];\\n            return Helper(dp, startX, startY, limit);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private static (int, int)[] _dirs = { (1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1) };\\n\\n        private double Helper(double?[,,] dp, int x, int y, int limit)\\n        {\\n            if (dp[x, y, limit].HasValue)\\n            {\\n                return dp[x, y, limit].Value;\\n            }\\n\\n            if (limit == 0)\\n            {\\n                dp[x, y, limit] = 1;\\n                return dp[x, y, limit].Value;\\n            }\\n\\n            double res = 0;\\n            int nextLimit = limit - 1;\\n\\n            foreach (var dir in _dirs)\\n            {\\n                int nextX = x + dir.Item1;\\n                int nextY = y + dir.Item2;\\n\\n                if (nextX >= 0 && nextX < dp.GetLength(0) && nextY >= 0 && nextY < dp.GetLength(1))\\n                {\\n                    double inner = Helper(dp, nextX, nextY, nextLimit);\\n                    res = res + inner;\\n                }\\n            }\\n\\n            dp[x, y, limit] = res / _dirs.Length;\\n            return dp[x, y, limit].Value;\\n        }\\n\\n\\n        public double KnightProbability(int n, int limit, int startX, int startY)\\n        {\\n            if(limit == 0)\\n            {\\n                return 1;\\n            }\\n\\n            double?[,,] dp = new double?[n, n, limit + 1];\\n            return Helper(dp, startX, startY, limit);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371964,
                "title": "easy-peasy-python-dp-solution",
                "content": "\\tdef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\\n        self.N = N\\n        dp1 = [[1]*N for _ in range(N)] # K = 0\\n        for i in range(K):\\n            dp2 = [[0]*N for _ in range(N)]\\n            for rw, row in enumerate(dp2):\\n                for co, value in enumerate(row):\\n                    for (a, b) in moves:\\n                        new_r, new_c = rw + a, co + b\\n                        if self.isValid(new_r, new_c):\\n                            dp2[new_r][new_c] += dp1[rw][co]/8\\n            dp1 = dp2\\n        return dp1[r][c]\\n   \\n    \\n    def isValid(self, r, c):\\n        return r >= 0 and r < self.N and c >= 0 and c < self.N",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tdef knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\\n        self.N = N\\n        dp1 = [[1]*N for _ in range(N)] # K = 0\\n        for i in range(K):\\n            dp2 = [[0]*N for _ in range(N)]\\n            for rw, row in enumerate(dp2):\\n                for co, value in enumerate(row):\\n                    for (a, b) in moves:\\n                        new_r, new_c = rw + a, co + b\\n                        if self.isValid(new_r, new_c):\\n                            dp2[new_r][new_c] += dp1[rw][co]/8\\n            dp1 = dp2\\n        return dp1[r][c]\\n   \\n    \\n    def isValid(self, r, c):\\n        return r >= 0 and r < self.N and c >= 0 and c < self.N",
                "codeTag": "Python3"
            },
            {
                "id": 345186,
                "title": "is-there-anyway-to-do-this-problem-with-bfs-and-not-time-out",
                "content": "I tried to implement the solution with BFS but I get TLE on 11th test case.\\n```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        def check(x,y):\\n            if 0<=x<N and 0<=y<N:\\n                return True\\n            return False\\n        if K == 0:\\n            if check(r,c):\\n                return 1\\n            else:\\n                return 0\\n        moves = [(-1,2),(1,2),(2,1),(2,-1),(1,-2),(-2,-1),(-1,-2),(-2,1)]\\n        \\n        \\n        frontier = [(r,c)]\\n        level = 0\\n        \\n        discount = 1\\n        while K > 0 and frontier:\\n            new = []\\n            good = 0\\n            total = 0\\n            totalprob = 0\\n            for r,c in frontier:\\n                for dr,dc in moves:\\n                    if check(r+dr,c+dc):\\n                        good += 1\\n                        total += 1\\n                        \\n                        new.append((r+dr,c+dc))\\n                    else:\\n                        total += 1\\n                          \\n                p = (good/total) * discount\\n                totalprob += p\\n            K -= 1\\n            frontier = new\\n            discount *= (1/8)\\n        \\n        return totalprob\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\\n        def check(x,y):\\n            if 0<=x<N and 0<=y<N:\\n                return True\\n            return False\\n        if K == 0:\\n            if check(r,c):\\n                return 1\\n            else:\\n                return 0\\n        moves = [(-1,2),(1,2),(2,1),(2,-1),(1,-2),(-2,-1),(-1,-2),(-2,1)]\\n        \\n        \\n        frontier = [(r,c)]\\n        level = 0\\n        \\n        discount = 1\\n        while K > 0 and frontier:\\n            new = []\\n            good = 0\\n            total = 0\\n            totalprob = 0\\n            for r,c in frontier:\\n                for dr,dc in moves:\\n                    if check(r+dr,c+dc):\\n                        good += 1\\n                        total += 1\\n                        \\n                        new.append((r+dr,c+dc))\\n                    else:\\n                        total += 1\\n                          \\n                p = (good/total) * discount\\n                totalprob += p\\n            K -= 1\\n            frontier = new\\n            discount *= (1/8)\\n        \\n        return totalprob\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337415,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        if K<=0:\\n            return 1 if 0<=r<=N-1 and 0<=c<=N-1 else 0\\n        self.mem = dict()\\n        self.N = N\\n        return self.DFS(r,c,K)\\n    \\n    def DFS(self,r,c,k):\\n        if k==0:\\n            return 1\\n        if tuple([r,c,k]) in self.mem:\\n            return self.mem[tuple([r,c,k])]\\n        prob = 0\\n        for nr,nc in self.neighbors(r,c):\\n            prob += 0.125*self.DFS(nr,nc,k-1)\\n        self.mem[tuple([r,c,k])] = prob\\n        return prob\\n            \\n        \\n    def neighbors(self,r,c):\\n        m = [2,-2,2,-2,1,-1,-1,1]\\n        for i,j in zip(m,m[::-1]):\\n            new_r = r+i\\n            new_c = c+j\\n            if 0<=new_r<=self.N-1 and 0<=new_c<=self.N-1:\\n                yield (new_r,new_c)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def knightProbability(self, N, K, r, c):\\n        \"\"\"\\n        :type N: int\\n        :type K: int\\n        :type r: int\\n        :type c: int\\n        :rtype: float\\n        \"\"\"\\n        if K<=0:\\n            return 1 if 0<=r<=N-1 and 0<=c<=N-1 else 0\\n        self.mem = dict()\\n        self.N = N\\n        return self.DFS(r,c,K)\\n    \\n    def DFS(self,r,c,k):\\n        if k==0:\\n            return 1\\n        if tuple([r,c,k]) in self.mem:\\n            return self.mem[tuple([r,c,k])]\\n        prob = 0\\n        for nr,nc in self.neighbors(r,c):\\n            prob += 0.125*self.DFS(nr,nc,k-1)\\n        self.mem[tuple([r,c,k])] = prob\\n        return prob\\n            \\n        \\n    def neighbors(self,r,c):\\n        m = [2,-2,2,-2,1,-1,-1,1]\\n        for i,j in zip(m,m[::-1]):\\n            new_r = r+i\\n            new_c = c+j\\n            if 0<=new_r<=self.N-1 and 0<=new_c<=self.N-1:\\n                yield (new_r,new_c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113955,
                "title": "solution-with-dp-and-memoization",
                "content": "```\\nclass Solution {\\n\\tdouble[][][] mem;\\n\\n\\tpublic double knightProbability(int N, int K, int r, int c) {\\n\\t\\tmem = new double[N][N][K+1];\\n\\t\\treturn knightProbabilityRecur(N, K, r, c) / Math.pow(8, K);\\n\\t}\\n\\n\\tpublic double knightProbabilityRecur(int N, int K, int r, int c) {\\n\\t\\tint[] dr = new int[] { 2, 2, 1, 1, -1, -1, -2, -2 };\\n\\t\\tint[] dc = new int[] { 1, -1, 2, -2, 2, -2, 1, -1 };\\n\\t\\tdouble prob = 0.0;\\t\\t\\n\\t\\tif (K == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < 8; i++) {\\n\\t\\t\\tint cx = r + dr[i];\\n\\t\\t\\tint cy = c + dc[i];\\n\\t\\t\\tif (cx >= 0 && cx < N && cy >= 0 && cy < N) {\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif (mem[cx][cy][K] == 0) {\\n\\t\\t\\t\\t\\tmem[cx][cy][K] = knightProbabilityRecur(N, K - 1, cx, cy);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprob += mem[cx][cy][K];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn prob;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tdouble[][][] mem;\\n\\n\\tpublic double knightProbability(int N, int K, int r, int c) {\\n\\t\\tmem = new double[N][N][K+1];\\n\\t\\treturn knightProbabilityRecur(N, K, r, c) / Math.pow(8, K);\\n\\t}\\n\\n\\tpublic double knightProbabilityRecur(int N, int K, int r, int c) {\\n\\t\\tint[] dr = new int[] { 2, 2, 1, 1, -1, -1, -2, -2 };\\n\\t\\tint[] dc = new int[] { 1, -1, 2, -2, 2, -2, 1, -1 };\\n\\t\\tdouble prob = 0.0;\\t\\t\\n\\t\\tif (K == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < 8; i++) {\\n\\t\\t\\tint cx = r + dr[i];\\n\\t\\t\\tint cy = c + dc[i];\\n\\t\\t\\tif (cx >= 0 && cx < N && cy >= 0 && cy < N) {\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif (mem[cx][cy][K] == 0) {\\n\\t\\t\\t\\t\\tmem[cx][cy][K] = knightProbabilityRecur(N, K - 1, cx, cy);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprob += mem[cx][cy][K];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn prob;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108189,
                "title": "c-dp-solution-o-n-n-k-time-complexity-and-explanation",
                "content": "DP definition:\\n\\ndp[i][j][k]:  in position (i, j), the probability that the knight remains on the board after k moves. we can get the following recurrence formula:\\n\\nk=0: dp[i][j][k]=1.0  (0<=i<N and 0<=j<N)\\n\\nk>0:  dp[i][j][k]=dp[i][j][k]+0.125*dp[x][y][k-1] (where (x, y) is the next move position of (i, j))\\n\\n```\\nint dir[8][2]={-2, -1, -2, 1, -1, 2, 1, 2, 2, 1, 2, -1, 1, -2, -1, -2};\\ndouble dp[26][26][101];\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        for(int k=0; k<=K; ++k)\\n        {\\n            for(int i=0; i<N; ++i)\\n            {\\n                for(int j=0; j<N; ++j)\\n                {\\n                    dp[i][j][k]=0.0;\\n                    if(k==0)\\n                    {\\n                        dp[i][j][0]=1.0;\\n                    }\\n                    else \\n                    {\\n                        for(int d=0; d<8; ++d)\\n                        {\\n                            int x=i+dir[d][0], y=j+dir[d][1];\\n                            if(x>=0 && x<N && y>=0 && y<N)\\n                            {\\n                                dp[i][j][k]+=0.125*dp[x][y][k-1];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[r][c][K];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dir[8][2]={-2, -1, -2, 1, -1, 2, 1, 2, 2, 1, 2, -1, 1, -2, -1, -2};\\ndouble dp[26][26][101];\\nclass Solution {\\npublic:\\n    double knightProbability(int N, int K, int r, int c) {\\n        for(int k=0; k<=K; ++k)\\n        {\\n            for(int i=0; i<N; ++i)\\n            {\\n                for(int j=0; j<N; ++j)\\n                {\\n                    dp[i][j][k]=0.0;\\n                    if(k==0)\\n                    {\\n                        dp[i][j][0]=1.0;\\n                    }\\n                    else \\n                    {\\n                        for(int d=0; d<8; ++d)\\n                        {\\n                            int x=i+dir[d][0], y=j+dir[d][1];\\n                            if(x>=0 && x<N && y>=0 && y<N)\\n                            {\\n                                dp[i][j][k]+=0.125*dp[x][y][k-1];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[r][c][K];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108199,
                "title": "c-dp-dfs-memo-sols",
                "content": "DFS+memorization sol ------\\nspace O(K*N^2)\\ntime O(K*N^2)\\n\\n```\\nclass Solution {\\npublic:\\n    //DFS with memorization\\n    double knightProbability(int N, int K, int r, int c) {\\n        dirs={{2,1},{2,-1},{1,2},{1,-2},{-2,1},{-2,-1},{-1,2},{-1,-2}};\\n        result=vector<vector<vector<double>>>(K+1,vector<vector<double>>(N,vector<double>(N,-1.)));\\n        return dfs(N,K,r,c);\\n    }\\nprivate:\\n    double dfs(int N, int K, int r, int c) {\\n        if(r<0 || c<0 || r>=N || c>=N) return 0;\\n        if(K==0) return 1;\\n        if(result[K][r][c]!=-1) return result[K][r][c];\\n        double prob=0;\\n        for(const auto& dir:dirs) {\\n            int rr=r+dir[0], cc=c+dir[1];\\n            prob+=(1/8.*dfs(N,K-1,rr,cc));\\n        }\\n        return result[K][r][c]=prob;\\n    }\\n    vector<vector<int>> dirs;\\n    vector<vector<vector<double>>> result;\\n};\\n```\\n\\nDP sol ------\\nspace O(N^2)\\ntime O(K*N^2)\\n\\n```\\nclass Solution {\\npublic:\\n    //DP\\n    double knightProbability(int N, int K, int r, int c) {\\n        if(r<0 || r>=N || c<0 || c>=N) return 0;\\n        \\n        vector<vector<int>>dirs({{2,1},{2,-1},{1,2},{1,-2},{-2,1},{-2,-1},{-1,2},{-1,-2}});\\n        vector<vector<double>> oldP(vector<vector<double>>(N,vector<double>(N,1.)));\\n        vector<vector<double>> newP(vector<vector<double>>(N,vector<double>(N,0.)));\\n        for(int l=1; l<=K; l++) {\\n            for(int i=0; i<N; i++) {\\n                for(int j=0; j<N; j++) {\\n                    newP[i][j]=0;\\n                    for(const auto& dir:dirs) {\\n                        int rr=i+dir[0], cc=j+dir[1];\\n                        if(rr<0 || rr>=N || cc<0 || cc>=N) continue;\\n                        newP[i][j]+=0.125*oldP[rr][cc];\\n                    }\\n                }\\n            }\\n            oldP=newP;\\n        }\\n        return oldP[r][c];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //DFS with memorization\\n    double knightProbability(int N, int K, int r, int c) {\\n        dirs={{2,1},{2,-1},{1,2},{1,-2},{-2,1},{-2,-1},{-1,2},{-1,-2}};\\n        result=vector<vector<vector<double>>>(K+1,vector<vector<double>>(N,vector<double>(N,-1.)));\\n        return dfs(N,K,r,c);\\n    }\\nprivate:\\n    double dfs(int N, int K, int r, int c) {\\n        if(r<0 || c<0 || r>=N || c>=N) return 0;\\n        if(K==0) return 1;\\n        if(result[K][r][c]!=-1) return result[K][r][c];\\n        double prob=0;\\n        for(const auto& dir:dirs) {\\n            int rr=r+dir[0], cc=c+dir[1];\\n            prob+=(1/8.*dfs(N,K-1,rr,cc));\\n        }\\n        return result[K][r][c]=prob;\\n    }\\n    vector<vector<int>> dirs;\\n    vector<vector<vector<double>>> result;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //DP\\n    double knightProbability(int N, int K, int r, int c) {\\n        if(r<0 || r>=N || c<0 || c>=N) return 0;\\n        \\n        vector<vector<int>>dirs({{2,1},{2,-1},{1,2},{1,-2},{-2,1},{-2,-1},{-1,2},{-1,-2}});\\n        vector<vector<double>> oldP(vector<vector<double>>(N,vector<double>(N,1.)));\\n        vector<vector<double>> newP(vector<vector<double>>(N,vector<double>(N,0.)));\\n        for(int l=1; l<=K; l++) {\\n            for(int i=0; i<N; i++) {\\n                for(int j=0; j<N; j++) {\\n                    newP[i][j]=0;\\n                    for(const auto& dir:dirs) {\\n                        int rr=i+dir[0], cc=j+dir[1];\\n                        if(rr<0 || rr>=N || cc<0 || cc>=N) continue;\\n                        newP[i][j]+=0.125*oldP[rr][cc];\\n                    }\\n                }\\n            }\\n            oldP=newP;\\n        }\\n        return oldP[r][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807856,
                "title": "using-dp-on-grids-and-basic-probability-two-methods",
                "content": "so we all know the very famous\\n\\n```\\nprobability =            desired outcomes\\n                         --------------\\n                         total outcomes\\n```\\n\\nso here, we will add the probability that each node reaches the starting row and column using the moves a knight can go.\\n\\nhere the total outcomes for a cell is 8.0\\nand the desired outcome would be to look in all the previous directions, add them , and then get the probability\\n\\nit should be pretty easy now.\\n \\n\\n# Code\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return util2(n,k,row,column);\\n    }\\n    // all the directions that the knight can go in..\\n    int xdir[] = { -2, -1, 2, 1, 1, 2, -1, -2 };\\n    int ydir[] = { 1, 2, 1, 2, -2, -1, -2, -1 };\\n\\n    public double util2(int n, int k, int row, int column) {\\n        double[][][] dp = new double[k + 1][n][n];\\n        dp[0][row][column] = 1.0;\\n        for (int moves = 1; moves <= k; moves++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    double favourable = 0.0;\\n                    for (int a = 0; a < xdir.length; a++) {\\n                        int prevX = i + xdir[a];\\n                        int prevY = j + ydir[a];\\n                        if (prevX >= 0 && prevY >= 0 && prevX < n && prevY < n) {\\n                            favourable += dp[moves - 1][prevX][prevY];\\n                        }\\n                    }\\n                    dp[moves][i][j] = favourable / 8.0;\\n                }\\n            }\\n        }\\n        double total = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                total += dp[k][i][j];\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\\n\\nhere basically using the same concept, but using the more traditional dfs\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return util3(n,k,row,column);\\n    }\\n    // all the directions that the knight can go in..\\n    int xdir[] = { -2, -1, 2, 1, 1, 2, -1, -2 };\\n    int ydir[] = { 1, 2, 1, 2, -2, -1, -2, -1 };\\n\\n    public double helper2(int n, int moves, double[][][] dp, int currR, int currC, int targetR, int targetC){\\n        if(moves == 0){\\n            if(currC == targetC && currR == targetR){\\n                return 1.0;\\n            }else{\\n                return 0.0;\\n            }\\n        }\\n        if(dp[moves][currR][currC] != -1){\\n            return dp[moves][currR][currC];\\n        }\\n        double desiredOutcomes = 0.0;\\n        double totalOutcomes = 8.0;\\n        for(int a = 0;a<xdir.length;a++){\\n            int x = currR+xdir[a];\\n            int y = currC+ydir[a];\\n            if(x>=0 && x<n && y>=0 && y<n){\\n                desiredOutcomes+=helper2(n,moves-1,dp,x,y,targetR,targetC);\\n            }\\n        }\\n        return dp[moves][currR][currC] = desiredOutcomes/totalOutcomes; \\n    }\\n\\n    public double util3(int n, int k, int row, int column){\\n        double dp [][][] = new double[k+1][n][n];\\n        for(int i = 0;i<dp.length;i++){\\n            for(int j = 0;j<dp[0].length;j++){\\n                for(int l = 0;l<dp[0][0].length;l++){\\n                    dp[i][j][l] = -1;\\n                }\\n            }\\n        }\\n        double ans = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                ans+=helper2(n,k,dp,i,j,row,column);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nprobability =            desired outcomes\\n                         --------------\\n                         total outcomes\\n```\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return util2(n,k,row,column);\\n    }\\n    // all the directions that the knight can go in..\\n    int xdir[] = { -2, -1, 2, 1, 1, 2, -1, -2 };\\n    int ydir[] = { 1, 2, 1, 2, -2, -1, -2, -1 };\\n\\n    public double util2(int n, int k, int row, int column) {\\n        double[][][] dp = new double[k + 1][n][n];\\n        dp[0][row][column] = 1.0;\\n        for (int moves = 1; moves <= k; moves++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    double favourable = 0.0;\\n                    for (int a = 0; a < xdir.length; a++) {\\n                        int prevX = i + xdir[a];\\n                        int prevY = j + ydir[a];\\n                        if (prevX >= 0 && prevY >= 0 && prevX < n && prevY < n) {\\n                            favourable += dp[moves - 1][prevX][prevY];\\n                        }\\n                    }\\n                    dp[moves][i][j] = favourable / 8.0;\\n                }\\n            }\\n        }\\n        double total = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                total += dp[k][i][j];\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return util3(n,k,row,column);\\n    }\\n    // all the directions that the knight can go in..\\n    int xdir[] = { -2, -1, 2, 1, 1, 2, -1, -2 };\\n    int ydir[] = { 1, 2, 1, 2, -2, -1, -2, -1 };\\n\\n    public double helper2(int n, int moves, double[][][] dp, int currR, int currC, int targetR, int targetC){\\n        if(moves == 0){\\n            if(currC == targetC && currR == targetR){\\n                return 1.0;\\n            }else{\\n                return 0.0;\\n            }\\n        }\\n        if(dp[moves][currR][currC] != -1){\\n            return dp[moves][currR][currC];\\n        }\\n        double desiredOutcomes = 0.0;\\n        double totalOutcomes = 8.0;\\n        for(int a = 0;a<xdir.length;a++){\\n            int x = currR+xdir[a];\\n            int y = currC+ydir[a];\\n            if(x>=0 && x<n && y>=0 && y<n){\\n                desiredOutcomes+=helper2(n,moves-1,dp,x,y,targetR,targetC);\\n            }\\n        }\\n        return dp[moves][currR][currC] = desiredOutcomes/totalOutcomes; \\n    }\\n\\n    public double util3(int n, int k, int row, int column){\\n        double dp [][][] = new double[k+1][n][n];\\n        for(int i = 0;i<dp.length;i++){\\n            for(int j = 0;j<dp[0].length;j++){\\n                for(int l = 0;l<dp[0][0].length;l++){\\n                    dp[i][j][l] = -1;\\n                }\\n            }\\n        }\\n        double ans = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                ans+=helper2(n,k,dp,i,j,row,column);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805148,
                "title": "recursion-memoization-tabulation",
                "content": "________________________________\\n**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n________________________________\\n\\n# Recursion *TLE*\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n      if(row>=n || column>=n || row<0 || column<0){\\n        return 0.0;\\n      }\\n      if(k==0){\\n        return 1.0;\\n      }\\n      double totalMoves=0.0;\\n      double totalPossibleMoves=8.0;\\n      totalMoves+=knightProbability(n,k-1,row+2,column+1);\\n      totalMoves+=knightProbability(n,k-1,row+2,column-1);\\n      totalMoves+=knightProbability(n,k-1,row-2,column+1);\\n      totalMoves+=knightProbability(n,k-1,row-2,column-1);\\n      totalMoves+=knightProbability(n,k-1,row+1,column+2);\\n      totalMoves+=knightProbability(n,k-1,row-1,column+2);\\n      totalMoves+=knightProbability(n,k-1,row+1,column-2);\\n      totalMoves+=knightProbability(n,k-1,row-1,column-2);\\n      return totalMoves/totalPossibleMoves;\\n    }\\n}\\n```\\n________________________________\\n\\n# Memoization\\n```\\nclass Solution {\\n    Double[][][] memo;\\n    public double knightProbability(int n, int k, int row, int column) {\\n      memo=new Double[k+1][n][n];\\n      return helper(n,k,row,column);\\n    }\\n    public double helper(int n, int k, int row, int col) {\\n      if(row>=n || col>=n || row<0 || col<0){\\n        return 0.0;\\n      }\\n      if(k==0){\\n        return 1.0;\\n      }\\n      if(memo[k][row][col]!=null){\\n        return memo[k][row][col];\\n      }\\n      double totalMoves=0.0;\\n      double totalPossibleMoves=8.0;\\n      totalMoves+=helper(n,k-1,row+2,col+1);\\n      totalMoves+=helper(n,k-1,row+2,col-1);\\n      totalMoves+=helper(n,k-1,row-2,col+1);\\n      totalMoves+=helper(n,k-1,row-2,col-1);\\n      totalMoves+=helper(n,k-1,row+1,col+2);\\n      totalMoves+=helper(n,k-1,row-1,col+2);\\n      totalMoves+=helper(n,k-1,row+1,col-2);\\n      totalMoves+=helper(n,k-1,row-1,col-2);\\n      return memo[k][row][col] = totalMoves/totalPossibleMoves;\\n    }\\n}\\n```\\n______________________________\\n# Tabulation\\n```\\nclass Solution {\\n    public boolean isValid(int row, int col, int length){\\n        if(row>=0 && col>=0 && row<length && col<length){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double curr[][]=new double[n][n];\\n        double next[][]=new double[n][n];\\n        curr[row][column]=1;\\n        for(int move=1; move<=k ; move++){\\n            for(int i=0; i<n; i++){\\n               for(int j=0; j<n ; j++){\\n                    if(curr[i][j]!=0){\\n                       int row1=row;\\n                       int col=column;\\n\\n                       row1=i-2;\\n                       col=j+1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i-1;\\n                       col=j+2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+1;\\n                       col=j+2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+2;\\n                       col=j+1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+2;\\n                       col=j-1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+1;\\n                       col=j-2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i-1;\\n                       col=j-2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i-2;\\n                       col=j-1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col] += curr[i][j] / 8.0;\\n                       }\\n                    }\\n                }\\n            }\\n            curr=next;\\n            next=new double[n][n];\\n        }\\n        double probab = 0.0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n ; j++){\\n                probab+=curr[i][j];\\n            }\\n        }\\n        return probab;\\n    }\\n}\\n```\\n_______________________________\\n**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n________________________________",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n      if(row>=n || column>=n || row<0 || column<0){\\n        return 0.0;\\n      }\\n      if(k==0){\\n        return 1.0;\\n      }\\n      double totalMoves=0.0;\\n      double totalPossibleMoves=8.0;\\n      totalMoves+=knightProbability(n,k-1,row+2,column+1);\\n      totalMoves+=knightProbability(n,k-1,row+2,column-1);\\n      totalMoves+=knightProbability(n,k-1,row-2,column+1);\\n      totalMoves+=knightProbability(n,k-1,row-2,column-1);\\n      totalMoves+=knightProbability(n,k-1,row+1,column+2);\\n      totalMoves+=knightProbability(n,k-1,row-1,column+2);\\n      totalMoves+=knightProbability(n,k-1,row+1,column-2);\\n      totalMoves+=knightProbability(n,k-1,row-1,column-2);\\n      return totalMoves/totalPossibleMoves;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Double[][][] memo;\\n    public double knightProbability(int n, int k, int row, int column) {\\n      memo=new Double[k+1][n][n];\\n      return helper(n,k,row,column);\\n    }\\n    public double helper(int n, int k, int row, int col) {\\n      if(row>=n || col>=n || row<0 || col<0){\\n        return 0.0;\\n      }\\n      if(k==0){\\n        return 1.0;\\n      }\\n      if(memo[k][row][col]!=null){\\n        return memo[k][row][col];\\n      }\\n      double totalMoves=0.0;\\n      double totalPossibleMoves=8.0;\\n      totalMoves+=helper(n,k-1,row+2,col+1);\\n      totalMoves+=helper(n,k-1,row+2,col-1);\\n      totalMoves+=helper(n,k-1,row-2,col+1);\\n      totalMoves+=helper(n,k-1,row-2,col-1);\\n      totalMoves+=helper(n,k-1,row+1,col+2);\\n      totalMoves+=helper(n,k-1,row-1,col+2);\\n      totalMoves+=helper(n,k-1,row+1,col-2);\\n      totalMoves+=helper(n,k-1,row-1,col-2);\\n      return memo[k][row][col] = totalMoves/totalPossibleMoves;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValid(int row, int col, int length){\\n        if(row>=0 && col>=0 && row<length && col<length){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double curr[][]=new double[n][n];\\n        double next[][]=new double[n][n];\\n        curr[row][column]=1;\\n        for(int move=1; move<=k ; move++){\\n            for(int i=0; i<n; i++){\\n               for(int j=0; j<n ; j++){\\n                    if(curr[i][j]!=0){\\n                       int row1=row;\\n                       int col=column;\\n\\n                       row1=i-2;\\n                       col=j+1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i-1;\\n                       col=j+2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+1;\\n                       col=j+2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+2;\\n                       col=j+1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+2;\\n                       col=j-1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i+1;\\n                       col=j-2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i-1;\\n                       col=j-2;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col]+=curr[i][j]/8.0;\\n                       }\\n\\n                       row1=i-2;\\n                       col=j-1;\\n                       if(isValid(row1,col,n)){\\n                         next[row1][col] += curr[i][j] / 8.0;\\n                       }\\n                    }\\n                }\\n            }\\n            curr=next;\\n            next=new double[n][n];\\n        }\\n        double probab = 0.0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n ; j++){\\n                probab+=curr[i][j];\\n            }\\n        }\\n        return probab;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805084,
                "title": "java-1ms-100-dfs-with-memorization-maps-of-valid-moves",
                "content": "The fast DFS algorithm in the code, is not my algorithm.  My own iterative algorithm only ran as fast as fast as 5ms.  I got the code from the fastest bar on the runtime graph, which ran in 2ms.  Then I modified and optimized that code to run in 1ms.  The biggest modification was to create maps of all valid moves for any board square.  With a map of all valid moves for each square, the code does not have to repeatedly try all possible moves for a knight, while checking if a move goes off the board\\'s boundaries.  With that map, ONLY valid moves will be made.\\n\\nThis code uses the fact that the board has 3-fold reflective symmetry (horz centerline, vert centerline, and main diagonal), to reduce the memorization and recursive row,column values to the top left quadrant of the board below the main diagonal.  This reduces the size of the memorization arrays, and the maps of valid moves.  Because all moves are reflected into 1/8th of the board, the memorization has 8 times more chances to find a previously memorized value.  The three reflections used are:\\n```\\n//    +-------------------------+\\n//    |                         |  If row on top half: row\\n//    |                   ^     |\\n//    |------------------ | ----|\\n//    | If row on bottom  |     |  If row on bottom half: n - 1 - row\\n//    | then reflect up.        |\\n//    +-------------------------+\\n//    \\n//    +------------+------------+\\n//    |            | If column  |  If column on left half: column\\n//    |         <----- on right |\\n//    |            |reflect left|  If column on right half: n - 1 - column\\n//    |############|############|\\n//    |############|############|\\n//    +------------+------------+\\n//    \\n//    +------------+------------+\\n//    |  \\\\  / If above diag ####|\\n//    |    / \\\\ reflect across ##|  If row,column below diagonal: row,column\\n//    |   V      \\\\ diagonal ####|\\n//    |############|############|  If row,column above diagonal: swap to column,row\\n//    |############|############|\\n//    +------------+------------+\\n//    \\n//    +------------+------------+\\n//    |  #######################|\\n//    |       ##################|  Only use this 1/8th of the board.\\n//    |           ##############|\\n//    |############|############|\\n//    |############|############|\\n//    +------------+------------+\\n```\\nThe modified code below runs in 1ms in July 2023.\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    private static final int[] knightDir = \\n                    {1,2, 1,-2, -1,2, -1,-2, 2,1, 2,-1, -2,1, -2,-1};\\n    private static int [][][][] savedMoveMaps = new int[25 + 1][][][];\\n    private int[][][] moveMap;\\n    private int boardDim = 0;\\n\\n    \\n    public double knightProbability(int n, int k, int row, int column) {\\n        if (k == 0)  return 1.0;\\n        if (n <= 2)  return 0.0;\\n        boardDim = n / 2 + 1;\\n        if (savedMoveMaps[n] != null)\\n            moveMap = savedMoveMaps[n];\\n        else {\\n            moveMap = new int[boardDim][boardDim][];\\n            fillMoveMap(moveMap, n, boardDim);\\n            savedMoveMaps[n] = moveMap;\\n        }\\n\\n        double[] memo = new double[boardDim * boardDim * (k + 1)];\\n        return solver(n - 1, k, row, column, memo);\\n    }\\n    \\n    \\n    private double solver(int nM1, int k, int row, int column, double[] memo) {\\n        if (k == 0) return 1.0;\\n\\n        // Reflect and swap the row and column until only using top left \\n        // quadrant at and below the diagonal.  This takes advantage of three \\n        // of the board\\'s reflective axes (horz, vert, main diagonal), to increase \\n        // by 8x, the chance of encountering a previously memorized value.  \\n        // Fewer calculations because of hitting more memorized values, result \\n        // in faster runtimes.\\n        row = Math.min(row, nM1 - row);\\n        column = Math.min(column, nM1 - column);\\n        if (row < column) {\\n            int temp = row;\\n            row = column;\\n            column = temp;\\n        }\\n        if (0.0 != memo[(k * boardDim + row) * boardDim + column])  \\n            return memo[(k * boardDim + row) * boardDim + column];\\n\\n        // Use a preset map of the valid moves we can make from the current \\n        // row and column, so we don\\'t have to waste time checking for moves \\n        // that go off the board.\\n        double probability = 0.0;\\n        int[] map = moveMap[row][column];\\n        int mapIdx = 0;\\n        while (map[mapIdx] >= 0) \\n            probability += solver(nM1, k - 1, map[mapIdx++], map[mapIdx++], memo);\\n        return memo[(k * boardDim + row) * boardDim + column] = probability / 8.0;\\n    }\\n\\n\\n    // Create a map of all VALID moves for each square of the board.  \\n    // This saves on repeatedly calculating the moves for each square, \\n    // and checking which of those moves are still on the board.\\n    private void fillMoveMap(int[][][] moveMap, int n, int boardDim) {\\n        int awayFromEnd = n - 3;\\n        for (int r = 0; r < boardDim; r++) {\\n            for (int c = 0; c <= r; c++) {\\n                if (r >= 2 && c >= 2 && r <= awayFromEnd && c <= awayFromEnd) {\\n                    moveMap[r][c] = new int[]{r+1,c+2, r+1,c-2, r-1,c+2, r-1,c-2, \\n                                              r+2,c+1, r+2,c-1, r-2,c+1, r-2,c-1, -1};\\n                } else {\\n                    int[] map = moveMap[r][c] = new int[8 * 2 + 1];\\n                    int dirIdx = 0;\\n                    int mapIdx = 0;\\n                    for (int i = 8; i > 0; i--) {\\n                        int movedR = r + knightDir[dirIdx++];\\n                        int movedC = c + knightDir[dirIdx++];\\n                        if (movedR >= 0 && movedC >= 0 && movedR < n && movedC < n) {\\n                            map[mapIdx++] = movedR;\\n                            map[mapIdx++] = movedC;\\n                        }\\n                    }\\n                    map[mapIdx++] = -1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n**------ Original unmodified code from 2ms on the runtime graph ------**\\n```\\nclass Solution {\\n    private final int[][] moves = {{2, 1}, {-2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {1, -2}, {-1, -2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] cache = new double[n / 2 + 1][n / 2 + 1][k + 1];\\n        return solver(n, k, row, column, cache);\\n    }\\n    private double solver(int n, int k, int row, int column, double[][][] memo) {\\n        if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\\n        if (k == 0) return 1.0;\\n\\n        row = Math.min(row, n - 1 - row);\\n        column = Math.min(column, n - 1 - column);\\n\\n        if (row < column) return solver(n, k, column, row, memo);\\n        if (memo[row][column][k] != 0.0) return memo[row][column][k];\\n\\n        double probability = 0.0;\\n        for (int[] move : moves) {\\n            probability += solver(n, k - 1, row + move[0], column + move[1], memo) / 8.0;\\n        }\\n        memo[row][column][k] = probability;\\n        return probability;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//    +-------------------------+\\n//    |                         |  If row on top half: row\\n//    |                   ^     |\\n//    |------------------ | ----|\\n//    | If row on bottom  |     |  If row on bottom half: n - 1 - row\\n//    | then reflect up.        |\\n//    +-------------------------+\\n//    \\n//    +------------+------------+\\n//    |            | If column  |  If column on left half: column\\n//    |         <----- on right |\\n//    |            |reflect left|  If column on right half: n - 1 - column\\n//    |############|############|\\n//    |############|############|\\n//    +------------+------------+\\n//    \\n//    +------------+------------+\\n//    |  \\\\  / If above diag ####|\\n//    |    / \\\\ reflect across ##|  If row,column below diagonal: row,column\\n//    |   V      \\\\ diagonal ####|\\n//    |############|############|  If row,column above diagonal: swap to column,row\\n//    |############|############|\\n//    +------------+------------+\\n//    \\n//    +------------+------------+\\n//    |  #######################|\\n//    |       ##################|  Only use this 1/8th of the board.\\n//    |           ##############|\\n//    |############|############|\\n//    |############|############|\\n//    +------------+------------+\\n```\n```\\nclass Solution {\\n    private static final int[] knightDir = \\n                    {1,2, 1,-2, -1,2, -1,-2, 2,1, 2,-1, -2,1, -2,-1};\\n    private static int [][][][] savedMoveMaps = new int[25 + 1][][][];\\n    private int[][][] moveMap;\\n    private int boardDim = 0;\\n\\n    \\n    public double knightProbability(int n, int k, int row, int column) {\\n        if (k == 0)  return 1.0;\\n        if (n <= 2)  return 0.0;\\n        boardDim = n / 2 + 1;\\n        if (savedMoveMaps[n] != null)\\n            moveMap = savedMoveMaps[n];\\n        else {\\n            moveMap = new int[boardDim][boardDim][];\\n            fillMoveMap(moveMap, n, boardDim);\\n            savedMoveMaps[n] = moveMap;\\n        }\\n\\n        double[] memo = new double[boardDim * boardDim * (k + 1)];\\n        return solver(n - 1, k, row, column, memo);\\n    }\\n    \\n    \\n    private double solver(int nM1, int k, int row, int column, double[] memo) {\\n        if (k == 0) return 1.0;\\n\\n        // Reflect and swap the row and column until only using top left \\n        // quadrant at and below the diagonal.  This takes advantage of three \\n        // of the board\\'s reflective axes (horz, vert, main diagonal), to increase \\n        // by 8x, the chance of encountering a previously memorized value.  \\n        // Fewer calculations because of hitting more memorized values, result \\n        // in faster runtimes.\\n        row = Math.min(row, nM1 - row);\\n        column = Math.min(column, nM1 - column);\\n        if (row < column) {\\n            int temp = row;\\n            row = column;\\n            column = temp;\\n        }\\n        if (0.0 != memo[(k * boardDim + row) * boardDim + column])  \\n            return memo[(k * boardDim + row) * boardDim + column];\\n\\n        // Use a preset map of the valid moves we can make from the current \\n        // row and column, so we don\\'t have to waste time checking for moves \\n        // that go off the board.\\n        double probability = 0.0;\\n        int[] map = moveMap[row][column];\\n        int mapIdx = 0;\\n        while (map[mapIdx] >= 0) \\n            probability += solver(nM1, k - 1, map[mapIdx++], map[mapIdx++], memo);\\n        return memo[(k * boardDim + row) * boardDim + column] = probability / 8.0;\\n    }\\n\\n\\n    // Create a map of all VALID moves for each square of the board.  \\n    // This saves on repeatedly calculating the moves for each square, \\n    // and checking which of those moves are still on the board.\\n    private void fillMoveMap(int[][][] moveMap, int n, int boardDim) {\\n        int awayFromEnd = n - 3;\\n        for (int r = 0; r < boardDim; r++) {\\n            for (int c = 0; c <= r; c++) {\\n                if (r >= 2 && c >= 2 && r <= awayFromEnd && c <= awayFromEnd) {\\n                    moveMap[r][c] = new int[]{r+1,c+2, r+1,c-2, r-1,c+2, r-1,c-2, \\n                                              r+2,c+1, r+2,c-1, r-2,c+1, r-2,c-1, -1};\\n                } else {\\n                    int[] map = moveMap[r][c] = new int[8 * 2 + 1];\\n                    int dirIdx = 0;\\n                    int mapIdx = 0;\\n                    for (int i = 8; i > 0; i--) {\\n                        int movedR = r + knightDir[dirIdx++];\\n                        int movedC = c + knightDir[dirIdx++];\\n                        if (movedR >= 0 && movedC >= 0 && movedR < n && movedC < n) {\\n                            map[mapIdx++] = movedR;\\n                            map[mapIdx++] = movedC;\\n                        }\\n                    }\\n                    map[mapIdx++] = -1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private final int[][] moves = {{2, 1}, {-2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-2, -1}, {1, -2}, {-1, -2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][][] cache = new double[n / 2 + 1][n / 2 + 1][k + 1];\\n        return solver(n, k, row, column, cache);\\n    }\\n    private double solver(int n, int k, int row, int column, double[][][] memo) {\\n        if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\\n        if (k == 0) return 1.0;\\n\\n        row = Math.min(row, n - 1 - row);\\n        column = Math.min(column, n - 1 - column);\\n\\n        if (row < column) return solver(n, k, column, row, memo);\\n        if (memo[row][column][k] != 0.0) return memo[row][column][k];\\n\\n        double probability = 0.0;\\n        for (int[] move : moves) {\\n            probability += solver(n, k - 1, row + move[0], column + move[1], memo) / 8.0;\\n        }\\n        memo[row][column][k] = probability;\\n        return probability;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803220,
                "title": "easy-c-solution-top-down-memoization-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n*k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n*k)\\n# Code\\n```\\nclass Solution {\\npublic:\\nunordered_map<string,double> mp;\\n     double topDown(int n,int k,int row,int col,vector<vector<int>> &arr){\\n         if(row<0||row>=n||col<0||col>=n)\\n            return 0;\\n        if(k==0)\\n            return 1;\\n        string key=to_string(row)+\"v\"+to_string(col)+\"v\"+to_string(k);\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        double prob=0;\\n        for(int i=0;i<8;i++){\\n            prob+=topDown(n,k-1,row+arr[i][0],col+arr[i][1],arr)/8.0;\\n        }\\n        mp[key]=prob;\\n        return mp[key];\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<int>> arr={{1,2},{-1,2},{1,-2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};\\n        return topDown(n,k,row,column,arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_map<string,double> mp;\\n     double topDown(int n,int k,int row,int col,vector<vector<int>> &arr){\\n         if(row<0||row>=n||col<0||col>=n)\\n            return 0;\\n        if(k==0)\\n            return 1;\\n        string key=to_string(row)+\"v\"+to_string(col)+\"v\"+to_string(k);\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        double prob=0;\\n        for(int i=0;i<8;i++){\\n            prob+=topDown(n,k-1,row+arr[i][0],col+arr[i][1],arr)/8.0;\\n        }\\n        mp[key]=prob;\\n        return mp[key];\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<int>> arr={{1,2},{-1,2},{1,-2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};\\n        return topDown(n,k,row,column,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802943,
                "title": "c-memoised-dp-vs-tabulation-dp-100-time-0ms-99-space-5-97mb",
                "content": "Pretty clear DP problem here:\\n* we have a base case (for `k == 0` we are going nowhere, so we clearly stay on the board with absolutely probability of `1.0`);\\n* we have a general case (for any other value of `k`, we will sum all the `8` the possibilities of going elsewhere or falling off the board);\\n* the general problem will repeat itself time and time again, so we can store the previously computed results in order to optimise performance.\\n\\nAt instance level, we will declare two variables:\\n* `side` will store how big is the side of our chessboard;\\n* `dp` will store the precomputed results.\\n\\nIn our main function, we will first of all set `side` to be `n`, then populate all the cells in `dp` to be `-1` with `memset`, which will mean all of them are initially `-nan`, then we will `return` the result of our helper function `dfs` invoked with `col`, `row` and `k`.\\n\\nThis function will take the aforementioned three parameters (the first two being rename `x` and `y` for convenience) and, knowing that `x` and `y` are always going to be valid board coordinates:\\n* check if we reached the end of the line (ie: `k == 0`), in which case we `return` `1` (ie: it is certain that we are on the board in this case);\\n* check if we were here before (ie: `dp[k][x][y] != -1`, we will `return` the precomputed value;\\n* now, for the general case, we will:\\n    * declare:\\n        * `res`, our usual accumulator variable set to `0`;\\n        * `cx` with initial value `x + 1`;\\n        * `cy` with initial value `y + 2`;\\n    * check each of the `8` possible cells we can reach from `x` and `y` and, if they are still on the board, increase `res` by the value of `dfs(x, y, k)`;\\n    * store the computed result `res` in `dp[k][x][y]`;\\n    * return `res`.\\n\\nTo clarify on how we inspect the reachable cells is this (`k` being the starting point):\\n\\n```cpp\\n  8 1\\n7     2\\n   k\\n6     3\\n  5 4\\n```\\n\\nDoing so is rather convenient, since the pairs of nodes in the same quadrant (`NE` for `1` and `2`, `SE` for `3` and `4`, `SW` for `5` and `6`, `NW` for `7` and `8`) share the same validation logic, so it is easier to handle them :)\\n\\n# Complexity\\n- Time complexity: $$O(k * n^2)$$\\n- Space complexity:. $$O(k * n^2)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\n    int side;\\n    double dp[101][25][25];\\n    double dfs(int x, int y, int k) {\\n        // base case: done looping\\n        if (!k) return 1;\\n        // base case: been here before\\n        if (!isnan(dp[k][x][y])) return dp[k][x][y];\\n        // general case\\n        double res = 0;\\n        int cx = x + 1, cy = y - 2;\\n        // exploring all the adjacent cells\\n        k--;\\n        // NE\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        cx += 1, cy += 1;\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        // SE\\n        cy += 2;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        cx -= 1, cy += 1;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        // SW\\n        cx -= 2;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        cx -= 1, cy -= 1;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        // NW\\n        cy -= 2;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        cx += 1, cy -= 1;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        return dp[k][x][y] = res;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int col) {\\n        // populating instance variables\\n        side = n;\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(col, row, k);\\n    }\\n};\\n```\\n\\nMicro-optimisation to use one less slot in `dp` for `k` (and thus `25 * 25 * sizeof(double)` less bytes) and avoid doing `k + 1` at the end - we decrease `k` immediately in the first `if` statement and then just use the updated value for the rest of `dfs`.\\n\\nAlso, minor optimisation to use `dpCell` as a refernce to `dp[k][x][y]` and we can divide `res` by `8.0` only once at the end:\\n\\n```cpp\\nclass Solution {\\n    int side;\\n    double dp[100][25][25];\\n    double dfs(int x, int y, int k) {\\n        // base case: done looping\\n        if (!k--) return 1;\\n        double &dpCell = dp[k][x][y];\\n        // base case: been here before\\n        if (!isnan(dpCell)) return dpCell;\\n        // general case\\n        double res = 0;\\n        int cx = x + 1, cy = y - 2;\\n        // exploring all the adjacent cells\\n        // NE\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k);\\n        cx += 1, cy += 1;\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k);\\n        // SE\\n        cy += 2;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k);\\n        cx -= 1, cy += 1;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k);\\n        // SW\\n        cx -= 2;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k);\\n        cx -= 1, cy -= 1;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k);\\n        // NW\\n        cy -= 2;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k);\\n        cx += 1, cy -= 1;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k);\\n        return dpCell = res / 8.0;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int col) {\\n        // populating instance variables\\n        side = n;\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(col, row, k);\\n    }\\n};\\n```\\n\\nFinal solution, similar logic to find the neighbours, but using a SOLE 2D array `dp`, initially with all the cell to `0` other than the `dp[row][col]`, set to `1.0`.\\n\\nI realised we do not need two different arrays in this case, since a knight will always move alternating white and black cells, so we can compute the value of the reachable cells in place, then reset the current cell `curr` to `0` after we are done doing that and so on - we just need to alternate a boolean value `isOdd` initially computed as `(row + col) & 1` to be sure to only parse the correct cells for the current turn.\\n\\n# Complexity\\n- Time complexity: $$O(k * n^2)$$\\n- Space complexity:. $$O(n^2)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int col) {\\n        // support variables\\n        double dp[n][n], curr, res = 0;\\n        bool isOdd = (row + col) & 1;\\n        // presetting dp\\n        memset(dp, 0, n * n * sizeof(double));\\n        dp[row][col] = 1.0;\\n        // doing k iterations\\n        while (k--) {\\n            for (int y = 0, cx, cy; y < n; y++) {\\n                for (int x = (isOdd + y) & 1; x < n; x += 2) {\\n                    curr = dp[y][x];\\n                    cx = x + 1, cy = y - 2;\\n                    // exploring all the adjacent cells\\n                    // NE\\n                    if (cx < n && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    cx += 1, cy += 1;\\n                    if (cx < n && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    // SE\\n                    cy += 2;\\n                    if (cx < n && cy < n) dp[cy][cx] += curr / 8.0;\\n                    cx -= 1, cy += 1;\\n                    if (cx < n && cy < n) dp[cy][cx] += curr / 8.0;\\n                    // SW\\n                    cx -= 2;\\n                    if (cx >= 0 && cy < n) dp[cy][cx] += curr / 8.0;\\n                    cx -= 1, cy -= 1;\\n                    if (cx >= 0 && cy < n) dp[cy][cx] += curr / 8.0;\\n                    // NW\\n                    cy -= 2;\\n                    if (cx >= 0 && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    cx += 1, cy -= 1;\\n                    if (cx >= 0 && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    // resetting the cell for the next loop\\n                    dp[y][x] = 0.0;\\n                }\\n            }\\n            // preparing for the next round, if any\\n            isOdd = !isOdd;\\n        }\\n        // computing res\\n        for (auto row: dp) {\\n            res += accumulate(row, row + n, 0.0);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Brag\\n![image.png](https://assets.leetcode.com/users/images/d6b81379-2734-4398-bdd0-c66e5e7cc78f_1690058039.423417.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\n  8 1\\n7     2\\n   k\\n6     3\\n  5 4\\n```\n```cpp\\nclass Solution {\\n    int side;\\n    double dp[101][25][25];\\n    double dfs(int x, int y, int k) {\\n        // base case: done looping\\n        if (!k) return 1;\\n        // base case: been here before\\n        if (!isnan(dp[k][x][y])) return dp[k][x][y];\\n        // general case\\n        double res = 0;\\n        int cx = x + 1, cy = y - 2;\\n        // exploring all the adjacent cells\\n        k--;\\n        // NE\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        cx += 1, cy += 1;\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        // SE\\n        cy += 2;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        cx -= 1, cy += 1;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        // SW\\n        cx -= 2;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        cx -= 1, cy -= 1;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k) / 8.0;\\n        // NW\\n        cy -= 2;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        cx += 1, cy -= 1;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k) / 8.0;\\n        return dp[k][x][y] = res;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int col) {\\n        // populating instance variables\\n        side = n;\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(col, row, k);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int side;\\n    double dp[100][25][25];\\n    double dfs(int x, int y, int k) {\\n        // base case: done looping\\n        if (!k--) return 1;\\n        double &dpCell = dp[k][x][y];\\n        // base case: been here before\\n        if (!isnan(dpCell)) return dpCell;\\n        // general case\\n        double res = 0;\\n        int cx = x + 1, cy = y - 2;\\n        // exploring all the adjacent cells\\n        // NE\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k);\\n        cx += 1, cy += 1;\\n        if (cx < side && cy >= 0) res += dfs(cx, cy, k);\\n        // SE\\n        cy += 2;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k);\\n        cx -= 1, cy += 1;\\n        if (cx < side && cy < side) res += dfs(cx, cy, k);\\n        // SW\\n        cx -= 2;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k);\\n        cx -= 1, cy -= 1;\\n        if (cx >= 0 && cy < side) res += dfs(cx, cy, k);\\n        // NW\\n        cy -= 2;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k);\\n        cx += 1, cy -= 1;\\n        if (cx >= 0 && cy >= 0) res += dfs(cx, cy, k);\\n        return dpCell = res / 8.0;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int col) {\\n        // populating instance variables\\n        side = n;\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(col, row, k);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int col) {\\n        // support variables\\n        double dp[n][n], curr, res = 0;\\n        bool isOdd = (row + col) & 1;\\n        // presetting dp\\n        memset(dp, 0, n * n * sizeof(double));\\n        dp[row][col] = 1.0;\\n        // doing k iterations\\n        while (k--) {\\n            for (int y = 0, cx, cy; y < n; y++) {\\n                for (int x = (isOdd + y) & 1; x < n; x += 2) {\\n                    curr = dp[y][x];\\n                    cx = x + 1, cy = y - 2;\\n                    // exploring all the adjacent cells\\n                    // NE\\n                    if (cx < n && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    cx += 1, cy += 1;\\n                    if (cx < n && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    // SE\\n                    cy += 2;\\n                    if (cx < n && cy < n) dp[cy][cx] += curr / 8.0;\\n                    cx -= 1, cy += 1;\\n                    if (cx < n && cy < n) dp[cy][cx] += curr / 8.0;\\n                    // SW\\n                    cx -= 2;\\n                    if (cx >= 0 && cy < n) dp[cy][cx] += curr / 8.0;\\n                    cx -= 1, cy -= 1;\\n                    if (cx >= 0 && cy < n) dp[cy][cx] += curr / 8.0;\\n                    // NW\\n                    cy -= 2;\\n                    if (cx >= 0 && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    cx += 1, cy -= 1;\\n                    if (cx >= 0 && cy >= 0) dp[cy][cx] += curr / 8.0;\\n                    // resetting the cell for the next loop\\n                    dp[y][x] = 0.0;\\n                }\\n            }\\n            // preparing for the next round, if any\\n            isOdd = !isOdd;\\n        }\\n        // computing res\\n        for (auto row: dp) {\\n            res += accumulate(row, row + n, 0.0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802933,
                "title": "tabulation-easy-approach-c-like-striver-3-d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*N*k*8)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*N*K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<vector<double>>>dp;\\n    double m=((double)1/(double)8);\\n   \\n    double knightProbability(int n, int k, int row, int column) {\\n        dp.resize(n+1,vector<vector<double>>(n+1,vector<double>(k+1,0)));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j][0]=(double)1;\\n            }\\n        }\\n        int delrow[8]={-2,-2,-1,1,2,2,1,-1};\\n        int delcol[8]={-1,1,2,2,1,-1,-2,-2};\\n        for(int i=1;i<=k;i++){\\n            for(int j=0;j<n;j++){\\n                for(int l=0;l<n;l++){\\n                    for(int p=0;p<8;p++ ){\\n                        int nrow=j+delrow[p];\\n                        int ncol=l+delcol[p];\\n                        if(nrow>=0&&nrow<n&&ncol>=0&&ncol<n){\\n                            dp[j][l][i]+=m*dp[nrow][ncol][i-1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[row][column][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<vector<double>>>dp;\\n    double m=((double)1/(double)8);\\n   \\n    double knightProbability(int n, int k, int row, int column) {\\n        dp.resize(n+1,vector<vector<double>>(n+1,vector<double>(k+1,0)));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j][0]=(double)1;\\n            }\\n        }\\n        int delrow[8]={-2,-2,-1,1,2,2,1,-1};\\n        int delcol[8]={-1,1,2,2,1,-1,-2,-2};\\n        for(int i=1;i<=k;i++){\\n            for(int j=0;j<n;j++){\\n                for(int l=0;l<n;l++){\\n                    for(int p=0;p<8;p++ ){\\n                        int nrow=j+delrow[p];\\n                        int ncol=l+delcol[p];\\n                        if(nrow>=0&&nrow<n&&ncol>=0&&ncol<n){\\n                            dp[j][l][i]+=m*dp[nrow][ncol][i-1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[row][column][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802860,
                "title": "simplest-solution-ever-using-recursion",
                "content": "Easy to understand memoized code\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    double dp[26][26][101];\\n  \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        return find(n, k, row, column);\\n    }\\n\\n    double find(int n, int k, int row, int col)\\n    {\\n        if(row < 0 || row > n-1 || col < 0 || col > n-1)\\n        return 0;\\n        if(k == 0)\\n        return 1;\\n\\n        if(dp[row][col][k] != 0)\\n        return dp[row][col][k];\\n\\n        double rate = 0.0;\\n        for(int i = 0; i < 8; i++)\\n        {\\n            rate += 0.125 * find(n , k-1, row+dir[i][0], col+dir[i][1]);\\n        }\\n        return dp[row][col][k] = rate;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-2,-1},{-1,-2},{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1}};\\n    double dp[26][26][101];\\n  \\n    double knightProbability(int n, int k, int row, int column) {\\n        \\n        return find(n, k, row, column);\\n    }\\n\\n    double find(int n, int k, int row, int col)\\n    {\\n        if(row < 0 || row > n-1 || col < 0 || col > n-1)\\n        return 0;\\n        if(k == 0)\\n        return 1;\\n\\n        if(dp[row][col][k] != 0)\\n        return dp[row][col][k];\\n\\n        double rate = 0.0;\\n        for(int i = 0; i < 8; i++)\\n        {\\n            rate += 0.125 * find(n , k-1, row+dir[i][0], col+dir[i][1]);\\n        }\\n        return dp[row][col][k] = rate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802555,
                "title": "c-clean-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double solve(int n,int k,int row,int col,int r[],int c[],       vector<vector<vector<double>>> &dp){\\n        if(row<0||col<0||row>=n||col>=n) return 0;\\n        if(k==0) return 1; \\n        if(dp[row][col][k]!=-1) return dp[row][col][k];\\n        double sum=0;\\n        for(int i=0;i<8;i++){\\n            int nr=row+r[i];\\n            int nc=col+c[i];\\n            sum+=solve(n,k-1,nr,nc,r,c,dp);\\n        }\\n        sum/=8;\\n        return dp[row][col][k]=sum;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<vector<double>>> dp(n+2,vector<vector<double>>(n+2,vector<double>(k+2,-1)));\\n        int r[]={-2,-2,-1,-1,1,1,2,2},c[]={-1,1,-2,2,-2,2,1,-1};\\n        return solve(n,k,row,col,r,c,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double solve(int n,int k,int row,int col,int r[],int c[],       vector<vector<vector<double>>> &dp){\\n        if(row<0||col<0||row>=n||col>=n) return 0;\\n        if(k==0) return 1; \\n        if(dp[row][col][k]!=-1) return dp[row][col][k];\\n        double sum=0;\\n        for(int i=0;i<8;i++){\\n            int nr=row+r[i];\\n            int nc=col+c[i];\\n            sum+=solve(n,k-1,nr,nc,r,c,dp);\\n        }\\n        sum/=8;\\n        return dp[row][col][k]=sum;\\n    }\\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<vector<double>>> dp(n+2,vector<vector<double>>(n+2,vector<double>(k+2,-1)));\\n        int r[]={-2,-2,-1,-1,1,1,2,2},c[]={-1,1,-2,2,-2,2,1,-1};\\n        return solve(n,k,row,col,r,c,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802024,
                "title": "c-recursive-dfs-with-memoization",
                "content": "# Code\\n```\\npublic class Solution {\\n    public double KnightProbability(int n, int k, int row, int column) {\\n        cache = new double[n,n,k+1];\\n        return DFS(n,k,row,column);\\n    }\\n\\n    private double[,,] cache;\\n    private List<(int x, int y)> directions = new()\\n    {\\n        (2,1),\\n        (1,2),\\n        (-2,1),\\n        (-1,2),\\n        (2,-1),\\n        (1,-2),\\n        (-2,-1),\\n        (-1,-2)\\n    };\\n\\n    private double DFS(int n, int k, int i, int j)\\n    {\\n        if(k == 0)\\n            return 1;\\n\\n        if(cache[i,j,k] != 0)\\n            return cache[i,j,k];\\n        \\n        foreach(var direction in directions)\\n        {\\n            int p = i + direction.x;\\n            int q = j + direction.y;\\n            if(p >= 0 && p < n && q >= 0 && q < n)\\n            {\\n                cache[i,j,k] += (DFS(n,k-1,p,q))/8.0;\\n            }\\n        }\\n        return cache[i,j,k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double KnightProbability(int n, int k, int row, int column) {\\n        cache = new double[n,n,k+1];\\n        return DFS(n,k,row,column);\\n    }\\n\\n    private double[,,] cache;\\n    private List<(int x, int y)> directions = new()\\n    {\\n        (2,1),\\n        (1,2),\\n        (-2,1),\\n        (-1,2),\\n        (2,-1),\\n        (1,-2),\\n        (-2,-1),\\n        (-1,-2)\\n    };\\n\\n    private double DFS(int n, int k, int i, int j)\\n    {\\n        if(k == 0)\\n            return 1;\\n\\n        if(cache[i,j,k] != 0)\\n            return cache[i,j,k];\\n        \\n        foreach(var direction in directions)\\n        {\\n            int p = i + direction.x;\\n            int q = j + direction.y;\\n            if(p >= 0 && p < n && q >= 0 && q < n)\\n            {\\n                cache[i,j,k] += (DFS(n,k-1,p,q))/8.0;\\n            }\\n        }\\n        return cache[i,j,k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801287,
                "title": "solution-for-knight-probability-in-chessboard-leetcode-problem-688",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is implementing a solution to the \"Knights Probability in Chessboard\" problem using dynamic programming. The goal is to calculate the probability that a knight starting at a given position (row, column) on an n x n chessboard will remain on the board after exactly k moves.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code initializes a 2D array curr of size n x n to store the current probabilities of the knight being at each cell after making m moves (initially set to 0 for all cells).\\nIt sets the probability of the knight being at the starting position (row, column) to 1 in the curr array, as the knight starts there.\\nThen, it initializes another 2D array next of size n x n to store the updated probabilities after each move.\\nFor each move from 1 to k, the code iterates through the curr array, and for each cell with a non-zero probability, it calculates the probabilities for all possible moves the knight can make. It updates the next array accordingly.\\nAfter completing all k moves, the final probabilities of the knight being at each cell are stored in the curr array.\\nFinally, the code calculates the sum of probabilities of the knight being at all cells in the curr array and returns the total probability.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given solution is O(n^2 * k). It involves a triple nested loop, where the outer loop runs k times (for each move), and the inner two loops iterate through the n x n chessboard. The innermost loop involves checking the validity of the knight\\'s possible moves, which takes constant time.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the given solution is O(n^2). It uses two 2D arrays curr and next, each of size n x n, to store the probabilities of the knight being at each cell. Additionally, there\\'s a constant-sized 2D array dir used to represent the possible moves of the knight. The space used by these arrays does not depend on the value of k. Hence, the overall space complexity is determined by the size of the chessboard, which is n x n.\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dir = {{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    public boolean isValid(int i, int j, int n){\\n    if(i>=0 && j>=0 && i<n && j<n){\\n        return true;\\n    }\\n    return false;\\n    }\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][] curr = new double[n][n];\\n        curr[row][column] = 1;\\n        double[][] next = new double[n][n];\\n        for(int m = 1; m<=k; m++){\\n            for(int i = 0; i<n; i++){\\n                for(int j = 0; j<n; j++){\\n                    if(curr[i][j]!=0){\\n                        for(int[] d : dir){\\n                            int ni = i + d[0];\\n                            int nj = j + d[1];\\n                            if(isValid(ni,nj,n)){\\n                                next[ni][nj] += curr[i][j]/8.0;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            curr = next;\\n            next = new double[n][n];\\n        }\\n        \\n        double sum = 0.0; \\n        for(int i = 0; i<n ;i++){\\n            for(int j = 0; j<n; j++){\\n                    sum += curr[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/3fc44a76-dad9-4d65-9a7b-5ede60ed2595_1690036878.9690084.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    public boolean isValid(int i, int j, int n){\\n    if(i>=0 && j>=0 && i<n && j<n){\\n        return true;\\n    }\\n    return false;\\n    }\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double[][] curr = new double[n][n];\\n        curr[row][column] = 1;\\n        double[][] next = new double[n][n];\\n        for(int m = 1; m<=k; m++){\\n            for(int i = 0; i<n; i++){\\n                for(int j = 0; j<n; j++){\\n                    if(curr[i][j]!=0){\\n                        for(int[] d : dir){\\n                            int ni = i + d[0];\\n                            int nj = j + d[1];\\n                            if(isValid(ni,nj,n)){\\n                                next[ni][nj] += curr[i][j]/8.0;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            curr = next;\\n            next = new double[n][n];\\n        }\\n        \\n        double sum = 0.0; \\n        for(int i = 0; i<n ;i++){\\n            for(int j = 0; j<n; j++){\\n                    sum += curr[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801204,
                "title": "c-dp-memoization-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double f(int n , int k , int nr , int nc , vector<vector<vector<double>>>& dp)\\n    {\\n        if(nc<0 || nr<0 || nc>=n || nr>=n) return 0;\\n        if(k==0) return 1;\\n        if(dp[nr][nc][k]!=-1) return dp[nr][nc][k];\\n        int r[]={-2,-2,-1,1,2,2,1,-1};\\n        int c[]={-1,1,2,2,1,-1,-2,-2};\\n        double prob = 0;\\n        for(int i=0;i<8;i++)\\n        {\\n            prob += f(n,k-1,nr+r[i] , nc+c[i],dp)/8.0;\\n        }\\n        return dp[nr][nc][k]=prob;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int col) {\\n        if(k==0) return 1;\\n        vector<vector<vector<double>>> dp(n , vector<vector<double>>(n,vector<double>(k+1,-1)));\\n         return f(n , k , row , col , dp);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double f(int n , int k , int nr , int nc , vector<vector<vector<double>>>& dp)\\n    {\\n        if(nc<0 || nr<0 || nc>=n || nr>=n) return 0;\\n        if(k==0) return 1;\\n        if(dp[nr][nc][k]!=-1) return dp[nr][nc][k];\\n        int r[]={-2,-2,-1,1,2,2,1,-1};\\n        int c[]={-1,1,2,2,1,-1,-2,-2};\\n        double prob = 0;\\n        for(int i=0;i<8;i++)\\n        {\\n            prob += f(n,k-1,nr+r[i] , nc+c[i],dp)/8.0;\\n        }\\n        return dp[nr][nc][k]=prob;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int col) {\\n        if(k==0) return 1;\\n        vector<vector<vector<double>>> dp(n , vector<vector<double>>(n,vector<double>(k+1,-1)));\\n         return f(n , k , row , col , dp);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801197,
                "title": "easy-c-solution-memoization-clean-efficient-code",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<pair<short,short>> dir={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    double solve(int n,int k,int i,int j,vector<vector<vector<double>>> &dp){\\n        if(i<0 || j<0 || j>=n || i>=n)\\n            return 0;\\n        if(k==0)\\n            return 1;\\n        if(dp[k][i][j]!=-1)\\n            return dp[k][i][j];\\n        double ans=0;\\n        for(short p=0;p<8;p++){\\n            ans+=solve(n,k-1,i+dir[p].first,j+dir[p].second,dp);\\n        }\\n        return dp[k][i][j]=ans;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(k+1,vector<vector<double>>(n+1,vector<double> (n+1,-1)));\\n        return solve(n,k,row,column,dp)/pow(8,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<pair<short,short>> dir={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};\\n    double solve(int n,int k,int i,int j,vector<vector<vector<double>>> &dp){\\n        if(i<0 || j<0 || j>=n || i>=n)\\n            return 0;\\n        if(k==0)\\n            return 1;\\n        if(dp[k][i][j]!=-1)\\n            return dp[k][i][j];\\n        double ans=0;\\n        for(short p=0;p<8;p++){\\n            ans+=solve(n,k-1,i+dir[p].first,j+dir[p].second,dp);\\n        }\\n        return dp[k][i][j]=ans;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(k+1,vector<vector<double>>(n+1,vector<double> (n+1,-1)));\\n        return solve(n,k,row,column,dp)/pow(8,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800931,
                "title": "688-knight-probability-in-chessboard-java",
                "content": "```\\nclass Solution {\\n        int[] dr={-2,-2,-1,1,2,2,1,-1};\\n        int[] dc={-1,1,2,2,1,-1,-2,-2};\\n    public double solve(int row, int col, int k,int n,double[][][] dp){\\n        \\n        if(row<0 || row>=n || col<0 || col>=n) \\n            return 0;\\n        if(k==0) \\n            return 1;\\n        \\n        if(dp[k][row][col]!=0) \\n            return dp[k][row][col];\\n        \\n        double result=0;\\n        for(int i=0;i<8;i++) \\n            result+=solve(row+dr[i],col+dc[i],k-1,n,dp);\\n        \\n        return dp[k][row][col]=result/8.0;  \\n        \\n    }\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double dp[][][]=new double[k+1][n][n];\\n        return solve(row,column,k,n,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n        int[] dr={-2,-2,-1,1,2,2,1,-1};\\n        int[] dc={-1,1,2,2,1,-1,-2,-2};\\n    public double solve(int row, int col, int k,int n,double[][][] dp){\\n        \\n        if(row<0 || row>=n || col<0 || col>=n) \\n            return 0;\\n        if(k==0) \\n            return 1;\\n        \\n        if(dp[k][row][col]!=0) \\n            return dp[k][row][col];\\n        \\n        double result=0;\\n        for(int i=0;i<8;i++) \\n            result+=solve(row+dr[i],col+dc[i],k-1,n,dp);\\n        \\n        return dp[k][row][col]=result/8.0;  \\n        \\n    }\\n    public double knightProbability(int n, int k, int row, int column) {\\n        double dp[][][]=new double[k+1][n][n];\\n        return solve(row,column,k,n,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800877,
                "title": "easy-cpp-solution-probability-dp-siple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(8^k + k * n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> direction = {{1, 2}, {2, 1}, {-1, -2}, {-2, -1}, {1, -2}, {2, -1}, {-2, 1}, {-1, 2}};\\n    vector<vector<vector<double>>> memo;\\n\\n    double solve(int n, int k, int row, int col) {\\n        if (row < 0 || col < 0 || row >= n || col >= n)\\n            return 0;\\n\\n        if (k == 0) return 1;\\n        \\n        if (memo[k][row][col] != -1)\\n            return memo[k][row][col];\\n        \\n        double ans = 0;\\n\\n        for (auto i : direction) \\n            ans += solve(n, k - 1, col + i.first, row + i.second);\\n        \\n        return memo[k][row][col] = ans;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        memo.resize(k + 1, vector<vector<double>>(n, vector<double>(n, -1)));\\n\\n        double ans = solve(n, k, row, column);\\n\\n        double totalMoves = pow(8, k);\\n\\n        return double(ans) / totalMoves;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> direction = {{1, 2}, {2, 1}, {-1, -2}, {-2, -1}, {1, -2}, {2, -1}, {-2, 1}, {-1, 2}};\\n    vector<vector<vector<double>>> memo;\\n\\n    double solve(int n, int k, int row, int col) {\\n        if (row < 0 || col < 0 || row >= n || col >= n)\\n            return 0;\\n\\n        if (k == 0) return 1;\\n        \\n        if (memo[k][row][col] != -1)\\n            return memo[k][row][col];\\n        \\n        double ans = 0;\\n\\n        for (auto i : direction) \\n            ans += solve(n, k - 1, col + i.first, row + i.second);\\n        \\n        return memo[k][row][col] = ans;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        memo.resize(k + 1, vector<vector<double>>(n, vector<double>(n, -1)));\\n\\n        double ans = solve(n, k, row, column);\\n\\n        double totalMoves = pow(8, k);\\n\\n        return double(ans) / totalMoves;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800729,
                "title": "python-short-and-clean-multiple-solutions-functional-programming",
                "content": "# Approach 1:\\n###### Top-Down, Recursive, Functional DP\\nGiven a board `n * n`. Let `on_board_prob` be a function which returns the probability of knight to stay on the board after `k` steps, starting from row `i` and column `j`. (Exactly what the problem asks)\\n\\nIf `k > 0`, i.e some moves are left: Try out the `8` equivi-probable `moves` from `i, j` that are `on_board` and add `1/8 th` of the probabilities from each of them.\\n\\nIf `k == 0`, return `prob = 1 if (i, j) is on_board else 0`\\n\\nMake sure to memoize `on_board_prob` to exploit overlapping subproblems and optimal substructure of the problem.\\n\\nNote: The first 3 lines defining `on_board`, `moves`, `next_positions` are copy pasted in all solutions.\\n\\n# Complexity\\n- Time complexity: $$O(k \\\\cdot n^2)$$\\n\\n- Space complexity: $$O(k \\\\cdot n^2)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        @cache\\n        def on_board_prob(k: int, i: int, j: int) -> float:\\n            return sum(on_board_prob(k - 1, ni, nj) for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8 if k else on_board(i, j)\\n        \\n        return on_board_prob(k, row, column)\\n\\n\\n```\\n\\n---\\n\\n# Approach 2:\\n###### Bottom-Up, Imperative DP\\nUse explicit `probs` 3-dimensional `k * n * n` DP array to replace `on_board_prob(k, i, j)` function above.\\n\\n# Complexity\\n- Time complexity: $$O(k \\\\cdot n^2)$$\\n\\n- Space complexity: $$O(k \\\\cdot n^2)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        probs = [[[1] * n for _ in range(n)] for _ in range(k + 1)]\\n        for k, i, j in product(range(1, k + 1), range(n), range(n)):\\n            probs[k][i][j] = sum(probs[k - 1][ni][nj] for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8\\n        \\n        return probs[k][row][column]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3:\\n###### Bottom-Up, Imperative, Space optimized DP\\nNotice, we only ever use `probs[k - 1][..][..]` to calculate `probs[k][..][..]`.\\nReduce `probs` to 2-dimensional `n * n` DP array by keeping only the previous values of first dimension.\\n\\n# Complexity\\n- Time complexity: $$O(k \\\\cdot n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        probs = [[1] * n for _ in range(n)]\\n        for k in range(1, k + 1):\\n            probs = [[sum(probs[ni][nj] for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8 for j in range(n)] for i in range(n)]\\n        \\n        return probs[row][column]\\n\\n\\n```\\n\\n---\\n\\n# Approach 4:\\n###### Bottom-Up, Declarative, Functional, Space optimized DP\\nUse `functools.reduce` to eliminate imperative coding in the above solution.\\n\\nNote: At this point, the code is purely functional and can technically also be written as a 1-liner, albeit a very long one!\\n\\n# Complexity\\n- Time complexity: $$O(k \\\\cdot n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        next_probs = lambda prob, k: [[sum(prob[ni][nj] for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8 for j in range(n)] for i in range(n)]\\n        probs = reduce(next_probs, range(1, k + 1), [[1] * n for _ in range(n)])\\n        return probs[row][column]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        @cache\\n        def on_board_prob(k: int, i: int, j: int) -> float:\\n            return sum(on_board_prob(k - 1, ni, nj) for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8 if k else on_board(i, j)\\n        \\n        return on_board_prob(k, row, column)\\n\\n\\n```\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        probs = [[[1] * n for _ in range(n)] for _ in range(k + 1)]\\n        for k, i, j in product(range(1, k + 1), range(n), range(n)):\\n            probs[k][i][j] = sum(probs[k - 1][ni][nj] for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8\\n        \\n        return probs[k][row][column]\\n\\n\\n```\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        probs = [[1] * n for _ in range(n)]\\n        for k in range(1, k + 1):\\n            probs = [[sum(probs[ni][nj] for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8 for j in range(n)] for i in range(n)]\\n        \\n        return probs[row][column]\\n\\n\\n```\n```python\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        on_board = lambda i, j: 0 <= i < n and 0 <= j < n\\n        moves = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\\n        next_positions = lambda i, j: ((i + di, j + dj) for di, dj in moves)\\n\\n        next_probs = lambda prob, k: [[sum(prob[ni][nj] for ni, nj in next_positions(i, j) if on_board(ni, nj)) / 8 for j in range(n)] for i in range(n)]\\n        probs = reduce(next_probs, range(1, k + 1), [[1] * n for _ in range(n)])\\n        return probs[row][column]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800660,
                "title": "easiest-solution-recursion-memoization-3d-dekh-to-sahi",
                "content": "// we know there are 8 possible direction so each valid position will contribute 1/8=0.125 to the probabity \\n\\n// I have stored all the possible moves in 8 direction vector which will help us to move in all possible coordinates from a position\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> directions = {{2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}, {1, -2}, {-2, 1}};\\n    \\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<vector<double>>> memo(k + 1, vector<vector<double>>(n, vector<double>(n, -1.0)));\\n        return backtrack(n, k, row, col, memo);\\n    }\\n    \\n    double backtrack(int n, int k, int row, int col, vector<vector<vector<double>>>& memo) {\\n        if (row < 0 || row >= n || col < 0 || col >= n)\\n            return 0.0;\\n        \\n        if (k == 0)\\n            return 1.0;\\n        \\n        if (memo[k][row][col] != -1.0)\\n            return memo[k][row][col];\\n        \\n        double probability = 0.0;\\n        for (const auto& dir : directions) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            probability += 0.125 * backtrack(n, k - 1, newRow, newCol, memo);\\n        }\\n        \\n        memo[k][row][col] = probability;\\n        return probability;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> directions = {{2, 1}, {1, 2}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}, {1, -2}, {-2, 1}};\\n    \\n    double knightProbability(int n, int k, int row, int col) {\\n        vector<vector<vector<double>>> memo(k + 1, vector<vector<double>>(n, vector<double>(n, -1.0)));\\n        return backtrack(n, k, row, col, memo);\\n    }\\n    \\n    double backtrack(int n, int k, int row, int col, vector<vector<vector<double>>>& memo) {\\n        if (row < 0 || row >= n || col < 0 || col >= n)\\n            return 0.0;\\n        \\n        if (k == 0)\\n            return 1.0;\\n        \\n        if (memo[k][row][col] != -1.0)\\n            return memo[k][row][col];\\n        \\n        double probability = 0.0;\\n        for (const auto& dir : directions) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            probability += 0.125 * backtrack(n, k - 1, newRow, newCol, memo);\\n        }\\n        \\n        memo[k][row][col] = probability;\\n        return probability;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800544,
                "title": "10-lines-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS and sum the probabilities of in each step.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DFS and cache to accelerate.\\n\\n# Complexity\\n- Time complexity: $$O(n^2k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```=python3\\nfrom functools import cache\\n\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        moves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n\\n        @cache\\n        def helper(k, i, j):\\n            if i < 0 or i >= n or j < 0 or j >= n:\\n                return 0.0\\n            if k == 0:\\n                return 1.0\\n            return sum(helper(k - 1, i + _i, j + _j) for _i, _j in moves) / 8\\n        \\n        return helper(k, row, column)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```=python3\\nfrom functools import cache\\n\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        moves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n\\n        @cache\\n        def helper(k, i, j):\\n            if i < 0 or i >= n or j < 0 or j >= n:\\n                return 0.0\\n            if k == 0:\\n                return 1.0\\n            return sum(helper(k - 1, i + _i, j + _j) for _i, _j in moves) / 8\\n        \\n        return helper(k, row, column)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800249,
                "title": "c-easy-to-understand-recursion-memoization",
                "content": "# Approach\\nTo solve this problem, we use a 3D DP (Dynamic Programming) approach to store the probabilities of different states of the knight. The three changing states are k (the number of moves left), row (the current row of the knight), and col (the current column of the knight).\\n\\nThe base cases of the recursion are as follows:\\n\\nIf the knight goes outside the chessboard (row < 0 || col < 0 || row >= n || col >= n), the probability is 0.0, as it\\'s impossible to stay on the board from there.\\nIf the knight has made all k moves, the probability is 1.0, as there is no more chance to move.\\nFor each state (k, row, col), we recursively explore all possible moves of the knight. We keep track of the probabilities of reaching different states and store them in the DP table to avoid redundant calculations. This way, we efficiently compute the probability of the knight staying on the board after making exactly k moves.\\n\\nAfter calculating the probabilities, we divide the final result by 8^k (as there are 8 possible moves at each step) to get the exact probability of the knight remaining on the board. \\n\\n\\nI hope your knight will successfully explore all possibilities and remain on the chessboard with a high probability! \\uD83D\\uDE04\\n\\n# Complexity\\n- Time complexity: $$O(k * n^2)$$\\n\\n- Space complexity: $$O(k * n^2)$$\\n\\n# Code\\n```\\n// Optimization with DP\\n// As there are 3 changing states we will use 3D Dp\\nclass Solution {\\nprivate:\\n    double solve(int n, int k, int row, int col, vector<vector<int>>&directions, vector<vector<vector<double>>>& dp){\\n        if(row < 0 || col < 0 || row >= n || col >= n){\\n            return 0.0;\\n        }\\n        if(k == 0){\\n            return 1.0;\\n        }\\n        if(dp[k][row][col] != -1.0) return dp[k][row][col];\\n\\n        double ans = 0;\\n        for(auto i: directions){\\n            ans += solve(n, k-1, row+i[0], col + i[1], directions, dp);\\n        }\\n        return dp[k][row][col] =  ans;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>>dp(k+1, vector<vector<double>>(n+1, vector<double>(n+1, -1.0)));\\n        vector<vector<int>>directions = {\\n            {1, 2}, {2,1}, {1, -2}, {2, -1},\\n            {-1, -2}, {-2,-1}, {-1, 2}, {-2, 1},\\n        };\\n        double ans = solve(n, k, row, column, directions, dp);\\n        double deno = pow(8,k);\\n        double res = ans / deno;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Optimization with DP\\n// As there are 3 changing states we will use 3D Dp\\nclass Solution {\\nprivate:\\n    double solve(int n, int k, int row, int col, vector<vector<int>>&directions, vector<vector<vector<double>>>& dp){\\n        if(row < 0 || col < 0 || row >= n || col >= n){\\n            return 0.0;\\n        }\\n        if(k == 0){\\n            return 1.0;\\n        }\\n        if(dp[k][row][col] != -1.0) return dp[k][row][col];\\n\\n        double ans = 0;\\n        for(auto i: directions){\\n            ans += solve(n, k-1, row+i[0], col + i[1], directions, dp);\\n        }\\n        return dp[k][row][col] =  ans;\\n    }\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>>dp(k+1, vector<vector<double>>(n+1, vector<double>(n+1, -1.0)));\\n        vector<vector<int>>directions = {\\n            {1, 2}, {2,1}, {1, -2}, {2, -1},\\n            {-1, -2}, {-2,-1}, {-1, 2}, {-2, 1},\\n        };\\n        double ans = solve(n, k, row, column, directions, dp);\\n        double deno = pow(8,k);\\n        double res = ans / deno;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800241,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    \\n    int[] dr = { -2, -2, -1, 1, 2, 2, 1, -1 };\\n    int[] dc = { -1, 1, 2, 2, 1, -1, -2, -2 };\\n    \\n    double[][][] dp;\\n    \\n    public double solve(int n, int k, int row, int col){\\n        if(row < 0 || row >= n || col >= n || col < 0)\\n            return 0;\\n        if( k == 0)\\n            return 1;\\n        \\n        if(dp[row][col][k] != -1)\\n            return dp[row][col][k];\\n        \\n        double prob = 0;\\n        for(int i = 0; i < 8;i++){\\n            double add = ((solve(n, k - 1 , row + dr[i], col + dc[i] )) /8.0);\\n            prob+=add;\\n        }\\n        return dp[row][col][k] = prob;\\n    }\\n    \\n    public double knightProbability(int n, int k, int row, int column) {\\n        double ans = 1;\\n        dp = new double[n+2][n+2][k+2];\\n        for(double[][] mat : dp)\\n            for(double[] ar : mat)\\n                Arrays.fill(ar,-1);\\n        return solve(n,k,row,column);\\n        // return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] dr = { -2, -2, -1, 1, 2, 2, 1, -1 };\\n    int[] dc = { -1, 1, 2, 2, 1, -1, -2, -2 };\\n    \\n    double[][][] dp;\\n    \\n    public double solve(int n, int k, int row, int col){\\n        if(row < 0 || row >= n || col >= n || col < 0)\\n            return 0;\\n        if( k == 0)\\n            return 1;\\n        \\n        if(dp[row][col][k] != -1)\\n            return dp[row][col][k];\\n        \\n        double prob = 0;\\n        for(int i = 0; i < 8;i++){\\n            double add = ((solve(n, k - 1 , row + dr[i], col + dc[i] )) /8.0);\\n            prob+=add;\\n        }\\n        return dp[row][col][k] = prob;\\n    }\\n    \\n    public double knightProbability(int n, int k, int row, int column) {\\n        double ans = 1;\\n        dp = new double[n+2][n+2][k+2];\\n        for(double[][] mat : dp)\\n            for(double[] ar : mat)\\n                Arrays.fill(ar,-1);\\n        return solve(n,k,row,column);\\n        // return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800022,
                "title": "python-3-bfs-in-a-linearised-grid-very-efficient",
                "content": "![Capture d\\u2019\\xE9cran 2023-07-22 100709.png](https://assets.leetcode.com/users/images/80bd843f-0daf-49e7-a022-6ca63e535f4f_1690014865.0514002.png)\\n\\n## Intuition\\nWe use a linearised grid for fast access and low memory use.\\nValue in the graph is probability to attend the case.\\nWhen a knight move from a white case, it attends a black case. One only grid can be used. It\\'s not possible to overwrite a probability in an inappropriate case.\\n\\n## Complexity\\n- Time complexity:\\n$O(k\\u22C5n\\xB2)$\\n\\n- Space complexity:\\n$O(n\\xB2)$\\n\\n## Code\\n```\\nclass Solution:\\n\\n    def knightProbability(self, n, k, row, column):\\n        # We make a linearised grid\\n        lin_grid = []\\n        BOUNDARY = -1\\n        for i in range(n):\\n            lin_grid.extend([0] * n + [BOUNDARY] * 2)\\n        n += 2\\n        lin_grid.extend([BOUNDARY] * 2 * n)\\n        START = row * n + column\\n        lin_grid[START] = 1\\n        \\n        # Moves in this grid\\n        moves = (-n - 2, -n + 2, -2 * n - 1, -2 * n + 1, n - 2, n + 2, 2 * n - 1, 2 * n + 1)\\n        \\n        # BFS\\n        to_process = deque([START])\\n        for _ in range(k):\\n            for __ in range(len(to_process)):\\n                i = to_process.popleft()\\n                p = lin_grid[i] / 8\\n                lin_grid[i] = 0\\n                for m in moves:\\n                    ni = i + m\\n                    if lin_grid[ni] != BOUNDARY:\\n                        # Add ni only once in the queue\\n                        if lin_grid[ni] == 0:\\n                            to_process.append(ni)\\n                        lin_grid[ni] += p\\n        return sum(p for p in lin_grid if p > 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n\\n    def knightProbability(self, n, k, row, column):\\n        # We make a linearised grid\\n        lin_grid = []\\n        BOUNDARY = -1\\n        for i in range(n):\\n            lin_grid.extend([0] * n + [BOUNDARY] * 2)\\n        n += 2\\n        lin_grid.extend([BOUNDARY] * 2 * n)\\n        START = row * n + column\\n        lin_grid[START] = 1\\n        \\n        # Moves in this grid\\n        moves = (-n - 2, -n + 2, -2 * n - 1, -2 * n + 1, n - 2, n + 2, 2 * n - 1, 2 * n + 1)\\n        \\n        # BFS\\n        to_process = deque([START])\\n        for _ in range(k):\\n            for __ in range(len(to_process)):\\n                i = to_process.popleft()\\n                p = lin_grid[i] / 8\\n                lin_grid[i] = 0\\n                for m in moves:\\n                    ni = i + m\\n                    if lin_grid[ni] != BOUNDARY:\\n                        # Add ni only once in the queue\\n                        if lin_grid[ni] == 0:\\n                            to_process.append(ni)\\n                        lin_grid[ni] += p\\n        return sum(p for p in lin_grid if p > 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799938,
                "title": "c-dynamic-programming-easy-to-understand-13ms-688-knight-probability-in-chessboard",
                "content": "# C++ | Dynamic Programming | Easy to Understand | <13ms | Medium Problem | 688. Knight Probability in Chessboard\\n```\\nclass Solution {\\ndouble dp[26][26][101];\\ndouble f(int n,int k,int i,int j){\\n    if(k==0) return 1;\\n    if(dp[i][j][k]>=0) return dp[i][j][k];\\n    int dx[8] = {2,2,1,1,-1,-1,-2,-2};\\n    int dy[8] = {1,-1,2,-2,2,-2,-1,+1};\\n    double cnt = 0;\\n    for(int p=0;p<8;p++){\\n        int ni = dx[p] + i;\\n        int nj = dy[p] + j;\\n        if(ni>=0 && ni<n && nj<n && nj>=0){\\n            cnt+=f(n,k-1,ni,nj);\\n        }\\n    }\\n    return dp[i][j][k] =  cnt;\\n}\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(n,k,row,column)/pow(8,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ndouble dp[26][26][101];\\ndouble f(int n,int k,int i,int j){\\n    if(k==0) return 1;\\n    if(dp[i][j][k]>=0) return dp[i][j][k];\\n    int dx[8] = {2,2,1,1,-1,-1,-2,-2};\\n    int dy[8] = {1,-1,2,-2,2,-2,-1,+1};\\n    double cnt = 0;\\n    for(int p=0;p<8;p++){\\n        int ni = dx[p] + i;\\n        int nj = dy[p] + j;\\n        if(ni>=0 && ni<n && nj<n && nj>=0){\\n            cnt+=f(n,k-1,ni,nj);\\n        }\\n    }\\n    return dp[i][j][k] =  cnt;\\n}\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(n,k,row,column)/pow(8,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799928,
                "title": "easy-c-memoisation-beginner-friendly",
                "content": "# Intuition\\nFrom the overview of the problem, it is hinting towards using recursion and trying all possible ways.\\n\\n# Approach\\nThus, a simple function is implemented utilising all the 8 directions the knight can move, and since, these are independant events, the probability of events can be calculated and added to the answer separately.\\nIt is furthur optimised by using 3D dp vector as shown.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double ways(int n, int k, int x, int y, vector <int> &u, vector<int> &v, vector<vector<vector<double>>> &dp){\\n        if(dp[k][x][y] != -1) return dp[k][x][y];\\n        if(k == 0) return 1;\\n        double ans = 0;\\n        for(int i=0; i<8; i++){\\n            int nr = x + u[i];\\n            int nc = y + v[i];\\n\\n            if(!(nr < 0 || nc < 0 || nr >= n || nc >= n))\\n                ans += ways(n, k-1, nr, nc, u, v, dp)/8;\\n        }\\n        return dp[k][x][y] = ans;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(k+1, vector<vector<double>> (n, vector<double> (n, -1)));\\n        vector<int> u = {2, 2, 1, 1, -2, -2, -1, -1};\\n        vector<int> v = {1, -1, 2, -2, 1, -1, 2, -2};\\n        return ways(n, k, row, column, u, v, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double ways(int n, int k, int x, int y, vector <int> &u, vector<int> &v, vector<vector<vector<double>>> &dp){\\n        if(dp[k][x][y] != -1) return dp[k][x][y];\\n        if(k == 0) return 1;\\n        double ans = 0;\\n        for(int i=0; i<8; i++){\\n            int nr = x + u[i];\\n            int nc = y + v[i];\\n\\n            if(!(nr < 0 || nc < 0 || nr >= n || nc >= n))\\n                ans += ways(n, k-1, nr, nc, u, v, dp)/8;\\n        }\\n        return dp[k][x][y] = ans;\\n    }\\n\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(k+1, vector<vector<double>> (n, vector<double> (n, -1)));\\n        vector<int> u = {2, 2, 1, 1, -2, -2, -1, -1};\\n        vector<int> v = {1, -1, 2, -2, 1, -1, 2, -2};\\n        return ways(n, k, row, column, u, v, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799926,
                "title": "python-dfs-easy-to-understand-optimal-solution-688-knight-probability-in-chessboard",
                "content": "# Python | DFS | Easy to Understand | Optimal Solution | Medium Problem | 688. Knight Probability in Chessboard\\n```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        if k == 0:\\n            return 1\\n\\n        @cache\\n        def dfs(r: int, c: int, cur_moves: int) -> int:\\n            if r < 0 or r >= n or c < 0 or c >= n:\\n                return 0\\n            if cur_moves == k:\\n                return 1\\n            on_board = 0\\n            for rd, cd in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (2, -1), (2, 1), (1, -2), (1, 2)]:\\n                on_board += dfs(r + rd, c + cd, cur_moves + 1)\\n            return on_board\\n        \\n        on_board = dfs(row, column, 0)\\n        return on_board / pow(8, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        if k == 0:\\n            return 1\\n\\n        @cache\\n        def dfs(r: int, c: int, cur_moves: int) -> int:\\n            if r < 0 or r >= n or c < 0 or c >= n:\\n                return 0\\n            if cur_moves == k:\\n                return 1\\n            on_board = 0\\n            for rd, cd in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (2, -1), (2, 1), (1, -2), (1, 2)]:\\n                on_board += dfs(r + rd, c + cd, cur_moves + 1)\\n            return on_board\\n        \\n        on_board = dfs(row, column, 0)\\n        return on_board / pow(8, k)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564786,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1565029,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1572314,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980771,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980638,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980508,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980507,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1570061,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1572979,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980526,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1564786,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1565029,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1572314,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980771,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980638,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980508,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980507,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1570061,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1572979,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980526,
                "content": [
                    {
                        "username": "bjwu",
                        "content": "Input: 3, 2, 0, 0\\nOutput: 0.0625\\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\\nFrom each of those positions, there are also two moves that will keep the knight on the board.\\nThe total probability the knight stays on the board is 0.0625.\\n\\nSo here is how I compute the prob:\\nAs in the explanation, there are in total 4 chances that the knight stays on the board after stop moving. \\nIn addition, there are in total 22 (18 + 4) paths after 2 moves.\\nThen the prob is 4 / 22.\\n\\nI do not understand how 0.0625 comes.... What does it mean \"stops moving\"? In the question, it says the knight stops moving when exhausting K moves or move out of the board. So the prob that I understand is 1 - ( # of positions that are out of the board / # of ways that the knight stops). Could someone please help point out which part I am wrong? Thx.\\n"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@88therisingsun](/88therisingsun) No that we can\\'t consider, once the knight goes out of bound, we can\\'t proceed further and have to stop then and there!"
                    },
                    {
                        "username": "88therisingsun",
                        "content": "[@bparanj](/bparanj) can\\'t the knight move out of the board then move back? for example start at (0,0) move to (1,-2) then move back to (0,0)?"
                    },
                    {
                        "username": "abhiram542",
                        "content": "[@bparanj](/bparanj) that is one of the way (actually it is the standard definition) at last, favourable choices are 4(no of ways knight never left the board which is actually dependent on path ). total possibilities are 8*8=64(even if knight goes out of the board,it continues 8 directional moves until it gets exhausted(k==0). so ans is 4/64=0.0625 which is also equal to 2/8*2/8 . the point is we have to carefull when counting the total possibilities in the second method. the method which you mentioned isthe better one and the one which comes to help in coding problems"
                    },
                    {
                        "username": "hiidracula",
                        "content": "[@bparanj](/bparanj) doubt in step 2, as from (1,2) it has 2 potential so 2/8 and from (2,1) it has 2/8 so total 4/8, effective probability is (2/8)*(4/8).\\nCorrect me, if i have made some mistake, Thank You"
                    },
                    {
                        "username": "bparanj",
                        "content": "I understand where your confusion is coming from, and it\\'s rooted in the nature of how probabilities are calculated. In this problem, the probability isn\\'t calculated based on the final number of positions, but rather on the transitions from one step to the next.\\n\\nWhen the problem states \"the knight stops moving when exhausting K moves\", it means that we consider the positions of the knight after it has made exactly K moves, and it has stayed on the board for all of these moves.\\n\\nTo clarify the computation, let\\'s break down the steps:\\n\\n1. **Step 0:** The knight starts at position (0,0).\\n\\n2. **Step 1:** From (0,0), the knight has 2 valid moves (to positions (1,2) and (2,1)), out of the total 8 potential moves a knight can make. So, the probability of the knight staying on the board after 1 move is 2/8 = 0.25.\\n\\n3. **Step 2:** From either (1,2) or (2,1), the knight again has 2 valid moves, out of the total 8 potential moves. So, the probability of the knight staying on the board after 2 moves is (2/8) * (2/8) = 0.0625. We multiply probabilities here because we\\'re dealing with independent events - the outcome of the second move doesn\\'t depend on the outcome of the first move.\\n\\nThe key point here is that we\\'re not counting the number of final positions, but rather calculating the probability of making K moves in a row, all of which keep the knight on the board. The total number of final positions doesn\\'t factor into this probability calculation. Instead, we consider the probabilities at each step."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@PratikPramanik](/PratikPramanik) yeah even i was confused. how it is 4/22. every move has 8 outcomes but for k times it will be 8 power 2. thnx for clarification"
                    },
                    {
                        "username": "ssdora456",
                        "content": "[@brian-xu](/brian-xu)  this comment is the best explanation, should be at the top"
                    },
                    {
                        "username": "brian-xu",
                        "content": "The key difference is that the 22 paths are not all equally likely. 6 of them end after the first move, while the other 16 end on the second move, which only has a 1/4 probability of happening."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "it\\'s  4/64  instead of 4/22 . I know the sentence phrased as \"stop moving\" after moving out . but you have to take those \"The ones which moved out and their individual 8 directions \" . So each move will give 8 more moves . Basically 8^2=64. Total number of cases . I was also confused during the computation of the probability."
                    },
                    {
                        "username": "Niteesh1729",
                        "content": "in the chessboard of dimension of (n X n) if a knight is on (x, y), then what is the probability of the knight that after kth steps the knight will be in the chessboard by moving in random direction (total 8 directions) at each step, basically we will brute force this problem and we will find that after that many steps by moving in random direction how many times the knight was in the chessboard that\\'s what problem wants you to find out."
                    },
                    {
                        "username": "seafmch",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\"\\n\\nIncorrect. It should be:\\n\\n\"Return the probability that the knight has never stepped off the board after K moves.\"\\n\\nThe problem statement provided by Leetcode allows for stepping off the board and then back on, which is not intended."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "It might have been updated, but the problem says: The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "helloShen",
                        "content": "The following figure show the probability that knight stay in chessboard (8*8) with just 1 move from each bucket.\\n\\n![image](https://assets.leetcode.com/users/helloshen/image_1544060347.png)\\n\\nAnd we can calculate another probability matrix that knight stay in chessboard after 2 moves based on this table."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "#### The magical rundown\\n\\n```\\nStep \\u2080 - The High Noon Duel \\uD83E\\uDD20\\uD83C\\uDFB5\\uD83C\\uDF35:\\n\\uD83C\\uDFB6 The town clock strikes twelve, and the high noon chess duel commences. A \\nlone knight \\uD83D\\uDC0E trots onto the scorching, sun-bleached chessboard, casting a long \\nshadow on the sandy squares.\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe Sheriff \\uD83E\\uDD20, ever the statistician, watches keenly. \"For now, the odds are \\nall in your favor, Knight,\" he says, unveiling the initial probability \\uD835\\uDCF9\\u2080 = 1.\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     1     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2081 - The Dusty Trail \\uD83C\\uDF04\\uD83C\\uDFB5\\uD83D\\uDC34:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E leaps into action, stirring up a cloud of dust. He lands in two \\ndifferent squares, each with a calculated 1/8 chance. The Sheriff \\uD83E\\uDD20 nods \\napprovingly. \"Bold moves, Knight. The probability after this is \\uD835\\uDCF9\\u2081 = 1/8 + 1/8 = 1/4.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nHe reveals the new odds:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502    \\xB9/\\u2088   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502   \\xB9/\\u2088   \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2082 - The Sun-Baked Crossroads \\u2600\\uFE0F\\uD83C\\uDFB5\\uD83C\\uDF2A\\uFE0F:\\n\\uD83C\\uDFB6 The knight \\uD83D\\uDC0E continues his daring maneuvers, hopping onto a few critical \\nspots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. \\nAdding these up, the Sheriff \\uD83E\\uDD20 declares, \"The stakes have risen, Knight. The \\ntotal is \\uD835\\uDCF9\\u2082 = 1/64 + 1/64 + 2/64 = 1/16.\"\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551    \\u2551   \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551   \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nThe updated odds take shape:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502    \\xB2/\\u2086\\u2084   \\u2502    0    \\u2502   \\xB9/\\u2086\\u2084   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502    0    \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    \\xB9/\\u2086\\u2084   \\u2502    0    \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\nStep \\u2083 - The Outlaw\\'s Hideout \\uD83C\\uDFDA\\uFE0F\\uD83C\\uDFB5\\uD83D\\uDC0D:\\n\\uD83C\\uDFB6 As the sun sets, the knight \\uD83D\\uDC0E lands in a few hidden spots with various \\nprobabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. \\nThe Sheriff \\uD83E\\uDD20 raises an eyebrow. \"Well played, Knight. Your total now is \\uD835\\uDCF9\\u2083 = \\n1/512 + 1/512 + 3/512 + 3/512.\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2557\\n\\u2551   \\u2551 \\uD83D\\uDC0E \\u2551    \\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551 \\uD83D\\uDC0E \\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551\\n\\u2560\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u2563\\n\\u2551   \\u2551\\uD83D\\uDC0E\\uD83D\\uDC0E\\uD83D\\uDC0E\\u2551  \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\uD83C\\uDF35\\u2550\\u2550\\u2550\\u255D\\n\\nBeneath the twinkling stars, the Sheriff \\uD83E\\uDD20 surveys the evolving game. \"You\\'re \\nnot an easy one to beat, Knight,\" he admits, revealing the updated stakes:\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502     0     \\u2502  \\xB9/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502   \\xB9/\\u2085\\u2081\\u2082   \\u2502    0    \\u2502   \\xB3/\\u2085\\u2081\\u2082  \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502     0     \\u2502  \\xB3/\\u2085\\u2081\\u2082  \\u2502     0    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\uD83D\\uDCB0\\u2500\\u2500\\u2500\\u2500\\u2518\\n\\n\\uD83C\\uDFB6 So, under the twinkling stars and to the tune of the whistling wind, our \\nknight\\'s adventure continues into the night. The stakes are high, the moves \\nunpredictable, but one thing\\'s certain: this wild chess duel is far from over! \\uD83C\\uDF35\\uD83D\\uDC0E\\uD83C\\uDF0C\\uD83C\\uDFB5\\n\\n```"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "Description must have more examples and explicitly mention how those probabilities are calculated"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Yea it is unclear."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Alone seeing this chess knight , I like it. Let's spend time on solving this question! One more hint\nFollow the probability formula\n$$\nProb(i, j, move=k)=(1/8)\\sum_{(r,s)}Prob(r, s, move=k-1)\n$$\nA list for n=8 dp state array for move=1,..,8 based on my submitted code\n```\nmove:1\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n       0.5\t,      0.75\t,         1\t,         1\t,         1\t,         1\t,      0.75\t,       0.5\t,\n     0.375\t,       0.5\t,      0.75\t,      0.75\t,      0.75\t,      0.75\t,       0.5\t,     0.375\t,\n      0.25\t,     0.375\t,       0.5\t,       0.5\t,       0.5\t,       0.5\t,     0.375\t,      0.25\t,\n\n===========\nmove:2\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n   0.40625\t,  0.578125\t,      0.75\t,     0.875\t,     0.875\t,      0.75\t,  0.578125\t,   0.40625\t,\n  0.359375\t,       0.5\t,   0.65625\t,      0.75\t,      0.75\t,   0.65625\t,       0.5\t,  0.359375\t,\n   0.28125\t,     0.375\t,       0.5\t,  0.578125\t,  0.578125\t,       0.5\t,     0.375\t,   0.28125\t,\n    0.1875\t,   0.28125\t,  0.359375\t,   0.40625\t,   0.40625\t,  0.359375\t,   0.28125\t,    0.1875\t,\n\n===========\nmove:3\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.285156\t,  0.427734\t,  0.574219\t,  0.621094\t,  0.621094\t,  0.574219\t,  0.427734\t,  0.285156\t,\n  0.263672\t,  0.394531\t,  0.535156\t,  0.574219\t,  0.574219\t,  0.535156\t,  0.394531\t,  0.263672\t,\n  0.199219\t,  0.289062\t,  0.394531\t,  0.427734\t,  0.427734\t,  0.394531\t,  0.289062\t,  0.199219\t,\n     0.125\t,  0.199219\t,  0.263672\t,  0.285156\t,  0.285156\t,  0.263672\t,  0.199219\t,     0.125\t,\n\n===========\nmove:4\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.224121\t,  0.323486\t,  0.428711\t,   0.48291\t,   0.48291\t,  0.428711\t,  0.323486\t,  0.224121\t,\n  0.199463\t,  0.287109\t,  0.383301\t,  0.428711\t,  0.428711\t,  0.383301\t,  0.287109\t,  0.199463\t,\n   0.15332\t,  0.214844\t,  0.287109\t,  0.323486\t,  0.323486\t,  0.287109\t,  0.214844\t,   0.15332\t,\n 0.0986328\t,   0.15332\t,  0.199463\t,  0.224121\t,  0.224121\t,  0.199463\t,   0.15332\t, 0.0986328\t,\n\n===========\nmove:5\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.164246\t,  0.241852\t,  0.323669\t,  0.355652\t,  0.355652\t,  0.323669\t,  0.241852\t,  0.164246\t,\n  0.149078\t,  0.219666\t,  0.295959\t,  0.323669\t,  0.323669\t,  0.295959\t,  0.219666\t,  0.149078\t,\n  0.113281\t,  0.163208\t,  0.219666\t,  0.241852\t,  0.241852\t,  0.219666\t,  0.163208\t,  0.113281\t,\n 0.0717773\t,  0.113281\t,  0.149078\t,  0.164246\t,  0.164246\t,  0.149078\t,  0.113281\t, 0.0717773\t,\n\n===========\nmove:6\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.125313\t,  0.182163\t,   0.24263\t,  0.270287\t,  0.270287\t,   0.24263\t,  0.182163\t,  0.125313\t,\n  0.112309\t,  0.163284\t,  0.218758\t,   0.24263\t,   0.24263\t,  0.218758\t,  0.163284\t,  0.112309\t,\n 0.0858612\t,  0.121979\t,  0.163284\t,  0.182163\t,  0.182163\t,  0.163284\t,  0.121979\t, 0.0858612\t,\n 0.0549164\t, 0.0858612\t,  0.112309\t,  0.125313\t,  0.125313\t,  0.112309\t, 0.0858612\t, 0.0549164\t,\n\n===========\nmove:7\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0933313\t,  0.136641\t,  0.182574\t,  0.201709\t,  0.201709\t,  0.182574\t,  0.136641\t, 0.0933313\t,\n 0.0842423\t,  0.123452\t,  0.165906\t,  0.182574\t,  0.182574\t,  0.165906\t,  0.123452\t, 0.0842423\t,\n 0.0641537\t, 0.0919857\t,  0.123452\t,  0.136641\t,  0.136641\t,  0.123452\t, 0.0919857\t, 0.0641537\t,\n 0.0408211\t, 0.0641537\t, 0.0842423\t, 0.0933313\t, 0.0933313\t, 0.0842423\t, 0.0641537\t, 0.0408211\t,\n\n===========\nmove:8\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0704898\t,  0.102755\t,  0.137064\t,  0.152143\t,  0.152143\t,  0.137064\t,  0.102755\t, 0.0704898\t,\n 0.0633526\t, 0.0924149\t,  0.123959\t,  0.137064\t,  0.137064\t,  0.123959\t, 0.0924149\t, 0.0633526\t,\n 0.0483487\t, 0.0689764\t, 0.0924149\t,  0.102755\t,  0.102755\t, 0.0924149\t, 0.0689764\t, 0.0483487\t,\n  0.030863\t, 0.0483487\t, 0.0633526\t, 0.0704898\t, 0.0704898\t, 0.0633526\t, 0.0483487\t,  0.030863\t,\n\n==========="
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Holy shit bro.  Thnx for this. learned something new"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Come on LC! The probability of the knight remaining on the board also depends on the opponents pieces. That\\'s no \"Walk in the park\"."
                    },
                    {
                        "username": "kunal768",
                        "content": "If we use BFS to check all the valid possibilities and count the number of safe positions and count/8 will be the probability and we keep doing that until we do K moves ? .\\nI just want to know why is this thinking wrong"
                    },
                    {
                        "username": "f-blan",
                        "content": "[@aehl](/aehl) same in python it gives TLE. However I changed it slightly and used memoization and it now beats 92%"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs way is correct but it may give memory/time exceeded.  i tried with k=100 and n = 25 in custom test case and had a bad time (c++) - the relatively small n actually is what allows for the k * n^2 solution of checking n * n blocks k times."
                    },
                    {
                        "username": "mrinaaldogra19",
                        "content": "I used a BFS based approach to solve this problem and it works. Traversed each step from current positions in single iteration and updated probabilities in a 2D matrix. After k-steps, summed up the probabilities in the said 2D matrix."
                    },
                    {
                        "username": "aehl",
                        "content": "I think the approach is right, I tried implementing it but it is giving TLE as when the k is high because the time complexity increases. Because there will be n * n vertices and each vertices is connected in 8 directions which means n * n * 8 edges."
                    },
                    {
                        "username": "metacoder",
                        "content": "I think the probability calculation of this question is wrong:\\n\\nProbability = Number of desired outcomes/ total number of outcomes\\n\\nHere that would be:\\n\\nProbability of Knight on board after stopped moving = Number of moves where knight is on board at the last move/ Total number of moves (until either K moves or until knight is off board)\\n\\nIn the given example [Input: 3, 2, 0, 0] :\\n\\nNumber of moves where knight is on board at the last move = 4\\nTotal number of moves = \\n6 moves that end in first round as they go off board \\n+ 6 moves from (1,2) that go off board + 2 moves where the knight is on board and K moves are complete\\n+ 6 moves from (2,1) that go off board + 2 moves where the knight is on board and K moved are complete\\n= 6 + 6 +2 + 6 + 2\\n= 22\\n\\nSo probability = 4/22 =  0.181818   (not 0.0625)\\n\\nAm I missing something here?\\nThanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding of the general concept of probability is correct. However, the context of this problem changes things a bit.\\n\\nIn the problem, we\\'re asked to calculate the probability that the knight remains on the board after making K moves, *assuming* that the knight always makes a move if it can. So, the denominator isn\\'t just the total number of moves after K steps. Rather, it\\'s the total number of all possible sequences of K moves.\\n\\nA key point here is that the knight has 8 possible moves at each step, not just the ones that keep it on the board. For each starting point, there are 8 possible moves, and for each of those, another 8, and so on for K steps. That\\'s why the total number of sequences of K moves is 8^K, which is the denominator in our probability calculation.\\n\\nAs for the numerator, we\\'re only counting sequences of K moves that keep the knight on the board for all K steps. So, we\\'re summing up the probabilities of landing on each valid (i.e., on-board) square after K steps. That\\'s what we\\'re calculating with our dynamic programming algorithm.\\n\\nIn the given example, the algorithm calculates the total probability as 0.0625, meaning that there\\'s a 6.25% chance that the knight will remain on the board after making 2 moves from position (0,0), given that it always makes a move if possible. This is consistent with the problem statement."
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "For k = 1, you will have 8 outcomes. For k = 2, you will have 64 outcomes. Because for every outcome when k = 1, there will be 8 outcomes from that position. So, the probability will be the number of positions on the board / total number of positions = 4 / 8 * 8 = 4 / 64 = 0.0625"
                    },
                    {
                        "username": "brian-xu",
                        "content": "This problem can also be reframed as \"What is the probability the knight can make K moves without stepping off the board?\", which was a useful intuition for me."
                    },
                    {
                        "username": "vnk01",
                        "content": "this definitely make more sense"
                    }
                ]
            },
            {
                "id": 1980828,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1575013,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1980646,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1980645,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1981202,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1573161,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1981381,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1980872,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1980806,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1980731,
                "content": [
                    {
                        "username": "moraalejandro94",
                        "content": "Seems way harder than average medium "
                    },
                    {
                        "username": "psionl0",
                        "content": "Should be easy. :D"
                    },
                    {
                        "username": "avataro",
                        "content": "(r,c) = (0,0)\\n\\nN=2, K=1\\nP(2,1) = 0 valid out of 8 total = 0/8 = 0\\n\\nN=3, K=1\\nP(3,1) = 2 valid out of 8 total = 2/8 = 0.25\\n\\nN=3, K=2\\nCase K=1: 2 valid out of 8 total = 2/8 = 0.25\\nCase K=2: 2 valid out of 8 total = 2/8 = 0.25\\nP(3,2) = 0.25*0.25 = 0.0625\\n\\nN=3, K=3\\nP(3,3) = 0.0625*0.25 = 0.01563\\n\\nN=3, K=4\\nP(3,4) = 0.01563*0.25 = 0.00391\\n\\nN=4, K=1\\nP(4,1) = 2 valid out of 8 tot = 2/8 = 0.25\\n\\nN=4, K=2\\nCase K=1: 2 valid out of 8 tot = 2/8 = 0.25\\nCase K=2: 4 valid out of 8 tot = 4/8 = 0.5\\nP(4,2) = 0.25*0.5 = 0.125\\n\\nand so on...\\n\\n"
                    },
                    {
                        "username": "ankitthakur9052",
                        "content": "in case K=2 there would be 4/16 in place of 4/8"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Time to learn Chess! I will be back in an hour."
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Why is the total number of possible outcomes == 8 ** k?\\n\\nShouldn\\'t the 8 possible moves be denied when the Knight has moved off the chessboard?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@jfitzg7](/jfitzg7) I doubt that any wording of this problem would satisfy everybody (the most common complaint in any problem seems to be how the description was worded). I find that I get more out of the problem by studying the expected answers than by reading the description."
                    },
                    {
                        "username": "jfitzg7",
                        "content": "[@psionl0](/psionl0) I feel like the problem statement should explicitly state something like \"Any k-move path that involves the knight moving off the board at some point is invalid/illegal, but should still be included in the probability calculation\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you did that then the probability that the knight remains on the board after k moves is 1.0 since any move that took it outside the board would be illegal."
                    },
                    {
                        "username": "SG-C",
                        "content": "Its difficult to solve this problem even if you are Magnus Carlsen\\n "
                    },
                    {
                        "username": "pthread",
                        "content": "Can the knight keep on moving once it goes off the board, but still hasn\\'t completed K moves?!?!\\nCan the knight return to a cell it has already been in??!!?!?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "No, it should stop moving as question says...\\n`The knight continues moving until it has made exactly k moves or has moved off the chessboard.`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here\\'s how the output is computed from the given input:\\n\\n1. **Initialize**: We start with a 3x3 chessboard (n=3), a knight at position (0,0), and we need to make exactly 2 moves (k=2). The knight has eight possible moves it can make, but since we are on the edge of the board, only two of these are valid: moving to (2,1) and moving to (1,2).\\n\\n2. **First Move**: We make our first move. For each of the two possible positions, there are also two possible moves that the knight can make to remain on the board. This means that for each starting move, there are two more valid moves the knight can make. \\n\\n3. **Probability Calculation**: Since the knight chooses one of eight possible moves uniformly at random, the probability for each move is 1/8. The total probability of the knight staying on the board after the first move is 2/8 = 0.25, since there are two valid moves.\\n\\n4. **Second Move**: For the second move, from each of the two positions reached after the first move, there are also two moves that will keep the knight on the board. The total probability for this move is also 0.25.\\n\\n5. **Final Probability**: The final probability is the product of the probabilities of the first and second move, i.e., 0.25 * 0.25 = 0.0625.\\n\\n6. **Output**: Therefore, after 2 moves, the knight has a 0.0625 probability of remaining on the board.\\n\\nThis process can be visualized as a tree with branches representing the knight\\'s moves. Each level of the tree represents a move, and the valid moves form the branches to the next level. The probability of each path (from root to a leaf) is the product of the probabilities of the moves (branches) in the path. The final probability is the sum of the probabilities of all paths that keep the knight on the board.\\n\\nLet\\'s imagine the visualization as a decision tree. For clarity, let\\'s refer to the positions the knight can move to as P1, P2, etc. and remember that the knight has only 2 valid moves from the starting position (0,0) on a 3x3 chessboard.\\n\\n```\\n    Start\\n    /   \\\\\\n  P1     P2 \\n / \\\\     / \\\\\\nP3  P4  P5  P6\\n```\\n\\nAt the start, the knight is at (0,0). \\n\\n- It has 2 options: move to Position 1 (P1 which is (2,1)) or Position 2 (P2 which is (1,2)). \\n- From P1, it can further move to two positions: P3 and P4. \\n- Similarly, from P2, it can move to two positions: P5 and P6. \\n\\nRemember, each level in this tree represents a move by the knight, and each node represents a position on the chessboard.\\n\\nThe probability of each move is 1/8, and the total probability after each move is the sum of the probabilities of the valid moves. After 2 moves (i.e., reaching the second level in the tree), the total probability of the knight remaining on the board is (1/8 * 2) * (1/8 * 2) = 0.0625. This is represented by the total number of end-nodes (leaf nodes) in the tree that represent valid positions on the chessboard, divided by the total number of end-nodes the tree could have had if all moves were valid.\\n\\nThis tree structure is a simplified visualization. In practice, the tree would be much larger, considering all possible moves (valid and invalid) at each step."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Please consider the statement term: \"Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\" this means with each probability u also need to consider the chances of its selection.\\n\\nfor example if k = 2 and row = 0 , column = 0 , n = 3\\n\\nInitially k = 0 : \\n\\n1 1 1\\n1 1 1\\n1 1 1\\n\\nAs no move is made all the cells on board are having probability = 1 , because no move is made.\\n\\nk = 1 :\\n\\nnow if the move is made from i th cell consider form (0,0) possible values are ( 1,2 ) & (2,1) and each are having a probability 1 as they are inside the board so value = 1 + 1 and the changes to select any of cell is 1/8 so the value at (0,0) = 2 * 1/8 = 2/8. Similarly, calculations are made for each value considering the Martix of k  = 0\\n\\n2/8 2/8 2/8 \\n2/8  0   2/8\\n2/8 2/8 2/8\\n\\nNow this matrix contains values for each cell if one move is made from it, more specifically the probability that if we make 1 move from the cell ( i , j ) then what is the probability that it will be inside the board. \\n\\nk = 2 : \\n\\nNow we will use the matrix at k = 1 to see the probability for each cell if 2 moves are made from the cell. As k = 1 already knows the probability of one move being made from that cell, then we will use it and make one more move from each cell k = 1.\\nFor example ofr (0,0) = 1/8 [ 2/8 + 2/8 ] = 1/16.\\n\\n1/16 1/16 1/16 \\n1/16  0   1/16\\n1/16 1/16 1/16\\n\\nThis is the approach we need to use. Hope it helps !"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "I better go and Sacrifice the ROOOOKKKKKKK..... before solving the problem"
                    },
                    {
                        "username": "Aadil42",
                        "content": "3d DPs are not medium!! But it wasn\\'t that bad after you come with memoizing the computed results with recursion."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    }
                ]
            },
            {
                "id": 1918148,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1980634,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1986314,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1980515,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 2017021,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1991783,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1983168,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1982969,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1981884,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1981882,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Return the probability that the knight remains on the board after it has stopped moving.\" should be rephrased as \"what will be the probability of knight never getting stepped off the board\"."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "PROBABILITY IS SIMPLE NUMBER OF FAVORABLE OUTCOME / TOTAL OUTCOME\\nFAVORABLE OUTCOME = NUMBER OF MOVES AFTER K STEPS AUCH THAT KNIGHT NEVER STEPED OF THE BOARD\\nTOTAL OUTCOME = pow(8, K);  \\n WILL NOT WORK FOR K >= 11 (integer overflow)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "3d DP ain\\'t medium. LC should mark it hard."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I disagree really, I don\\u2019t think the dimensions of the DP determine the difficulty, rather the difficulty in identifying the recurrence relationship. In this case the recurrence relationship is basically given to us. This problem takes <5 minutes to solve if you\\u2019re practiced at DP and backtracking"
                    },
                    {
                        "username": "urd00m",
                        "content": "This problem is very poorly thought out. The probability calculation is very weird and the problem is too ambiguous  "
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "really great question, backtracking and DP are my two favorite types of problems so this was an extremely fun question!"
                    },
                    {
                        "username": "kaxuna",
                        "content": "TLE solution ALERT\\n\\nHi my k * n * n solution goes on TLE, can anybody confirm my tc evaluation?\\n\\n\\n\\n`class Solution {\\n    int[][] positions = new int[][]{{-2, -1}, {-2, 1}, {2, 1}, {2, -1},{1, -2}, {1, 2},{-1, -2}, {-1, 2}};\\n\\n    public double knightProbability(int n, int k, int row, int column) {\\n        return rec(n, k, row, column, new Double[k + 1][n][n]);\\n    }\\n\\n    private double rec(int n, int k, int row, int column, Double[][][] dp) {\\n        if(row < 0 || row >= n || column < 0 || column >= n) return 0;\\n        if(k == 0) return 1;\\n        if(dp[k][row][column] != null) return dp[k][row][column];\\n\\n        double chance = 0;\\n        for(int[] pos : positions) {\\n            chance += knightProbability(n, k - 1, row + pos[0], column + pos[1]);\\n        } \\n\\n        dp[k][row][column] = chance / 8.0;\\n        return dp[k][row][column];\\n    }\\n}`"
                    },
                    {
                        "username": "Rutvik0512",
                        "content": "Can anybody tell me where am I doing wrong?\\nInput test case: 3,3,0,0\\nExpected Output: 0.01562\\nActual Output: 0.01953\\n\\nclass Solution {\\n\\n    int dx[] = {-1,-2,1,2,-1,-2,1,2};\\n    int dy[] = {-2,-1,-2,-1,2,1,2,1};\\n\\n    public static boolean isSafe(int n,int row,int col){\\n        if(row<0 || col<0 || row>=n || col>=n) return false;\\n        return true;\\n    }\\n\\n    public void helper(int n,int k,int currK,int x,int y,double probability[][][]){\\n        if(k==currK) return;\\n        for(int i=0;i<8;i++){\\n            int nx = x+dx[i];\\n            int ny = y+dy[i];\\n            if(isSafe(n,nx,ny)){\\n                // System.out.println(nx+\" \"+ny+\" \"+k+\" \"+currK);\\n                probability[nx][ny][currK+1] += probability[x][y][currK] * 0.125;\\n                helper(n,k,currK+1,nx,ny,probability);\\n            }\\n        }\\n    }\\n\\n    public double knightProbability(int n, int k, int row, int col) {\\n        double probability[][][] = new double[n][n][k+1];\\n        probability[row][col][0] = 1;\\n        helper(n,k,0,row,col,probability);\\n        double sum = 0.0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                sum += probability[i][j][k];\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "CalCreate",
                        "content": "really cool multidimensional DP... are there any other similar problems to this? "
                    },
                    {
                        "username": "bahaeddinebenothmane",
                        "content": "the example is wrong and also the test , becasue ou didn\\'t consider the fisrt move been out of the borad then going back to the board ex :(-2,-1) then (2,1) , so either change the description and say \"if the knight get out of the bord then it stop moving\" , ot change example and the test off course"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "The knight continues moving until it has made exactly k moves or has moved off the chessboard."
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is very easy with basic knowledge of probabilities (Law of total probability) "
                    },
                    {
                        "username": "ymjoshi",
                        "content": "Here is a very simple code using Top Down Dynamic Programming https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3803045/very-simple-top-down-dp-solution/ Please upvote if it helped!"
                    }
                ]
            },
            {
                "id": 1981862,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1981785,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1981226,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1981196,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1981154,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1981142,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1981030,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1980973,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1980820,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            },
            {
                "id": 1980755,
                "content": [
                    {
                        "username": "vk2028",
                        "content": "Alright, maybe my solution isn\\'t the best in terms of memory, but here\\'s what I did:\\n\\n1) we got a n x n board, in which a knight can jump around or hits a wall, but what if, instead, we \"allow\" a knight to jump off the board? if that\\'s the case, a knight on index (0, 0) can jump to \"(-2, -1),\" or \"(-1, -2).\" So instead of initializing a n x n board, I initialized a (n + 4) x (n + 4) board, because we need to expand 2 rows or columns on each side\\n\\n2) I then initialized the actual board, which is from row 2 to row n + 3, inclusive, and col 2 to col n + 3, also inclusive, with the value of 1. This board is the original board in which, if the knight takes 0 jumps, the probability of landing inside the board. The default outside the board is, of course, 0;\\n\\n3) then with each iterations, I update only the actual board such that the updated board takes account of the success probability of each of its possible landing square (including the imaginary part of the board) and multiply by 1/8. Since the imaginary parts of the board aren\\'t updated, they remain at 0, meaning that if the knight jumps to an empty square, it has 0 probability of success, which is consistent with what the problem said. For this step, you loop through row 2 to row n + 3, and col 2 to col n + 3 again, sum up all the \"possible\" square\\'s success of the original board, and multiply by 1/8. After which you update the new board to the original board. Obviously you need k iterations for this. (in case you didn\\'t realize, I used 3 for loops haha so I am not sure if this is the most efficient way. The complexity is o(n^2*k)\\n\\n4) after the final update, you get a board, each square is the prob of the knight staying in the board after k moves. You just need to return board[row + 2][column + 2]. The +2 is because of the imaginary 2 rows/col prior to the actual board."
                    },
                    {
                        "username": "Showboo",
                        "content": "If you have ever played chess before, the problem statement here is kind of dumb because it allows for making an illegal move as being a possible move (moving off the board).\\nIn real chess, this move would never be allowed, this considering this as a \"possible move\" for probability purposes is invalid."
                    },
                    {
                        "username": "psionl0",
                        "content": "Analogies are never exact. It helps to remember that illegal and impossible are not synonymous."
                    },
                    {
                        "username": "DeadliestDemon",
                        "content": "If somebody is having wrong answer though your tabulation code is correct please use this above your code -->\\n\\ndouble dp[26][26][101];\\n         // probability of staying inside chess board initially\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n            {\\n                for(int k=0; k<101; k++)\\n                {\\n                    dp[i][j][k] = 0;\\n                }\\n            }\\n        }\\n\\n\\n\\n// Initialize all 0 by yourself.\\n"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "My Rust u128 variable overflows with the possible stay-on-board moves number. Directly DP with f64 don\\'t have enough precision. Now my program and I panicked."
                    },
                    {
                        "username": "psionl0",
                        "content": "I have posted a solution with details that might help those who have difficulty with adding memoization to a solution. It also explains how a recursive solution can be derived.\\nhttps://leetcode.com/problems/knight-probability-in-chessboard/solutions/3800901/c-solution-using-recursion-and-memoization-full-explanation/"
                    },
                    {
                        "username": "jfitzg7",
                        "content": "Something is not right with the wording of this question.\\n\\n>The knight continues moving until it has made exactly k moves or has moved off the chessboard.\\n\\n>Return the probability that the knight remains on the board after it has stopped moving.\\n\\nIf one of the base cases is to stop moving once the knight is off the board, then the knight will essentially \"always\" be on the board. If you think of the problem like a tree structure, then the leaf nodes are when k = 0 (no moves left) or the knight is off the board. Intuitively, you would count up all the leaf nodes which would be the divisor, and then the total number of leaf nodes which were on the board when k = 0 (no moves left) is the dividend. However, the problem expects you to use this same process and count the dividend the same way, but the divisor is expected to be 8^k. It would make sense for the divisor to be 8^k if you could move off the board, keep moving around off the board, and then potentially move back onto the board... but the question doesn\\'t allow you to do that, it expects all paths that move off the board to be pruned (but not really since the divisor is expected to be 8^k)."
                    },
                    {
                        "username": "0x6B0",
                        "content": "First time for a real stack overflow error :)"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "for the case [3,1,0,0] \nWhen I RUN this test case, it does accept the solution and output the desired result.\nBut when I try to SUBMIT the solution, it gives wrong answer for the same test case.\nAnyone facing the same issue, or maybe some other test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Anomalies like these suggest that you are using global variables or failing to initialize some variables."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can anyone find the error in my code !? \\n\\nI have used recursion --> \\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // No moves \\n        if(k == 0){\\n            return 1;\\n        }\\n\\n        // Out of bounds\\n        if(row<0 || row>=n || column<0 || column>=n){\\n            return 0;\\n        }\\n\\n        double fav = 0;\\n        // favourable outcomes \\n        fav = knightProbability(n, k-1, row-2, column-1)+\\n              knightProbability(n, k-1, row-1, column-2)+\\n              knightProbability(n, k-1, row-2, column+1)+\\n              knightProbability(n, k-1, row-1, column+2)+\\n              knightProbability(n, k-1, row+1, column-2)+\\n              knightProbability(n, k-1, row+2, column-1)+\\n              knightProbability(n, k-1, row+1, column+2)+\\n              knightProbability(n, k-1, row+2, column+1);\\n        \\n        // Total outcomes == 8\\n        double prob = (double)fav/(8.00);\\n        return prob;\\n    }\\n};"
                    },
                    {
                        "username": "rupnkrdas",
                        "content": "I won\\'t disclose the exact solution, but I encourage you to review and double-check your base cases! Good luck!"
                    },
                    {
                        "username": "Atatsuki",
                        "content": "This prob definitely needs more explanation :("
                    }
                ]
            }
        ]
    }
]