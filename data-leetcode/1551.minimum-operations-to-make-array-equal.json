[
    {
        "title": "Longest String Chain",
        "question_content": "You are given an array of words where each word consists of lowercase English letters.\nwordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\n\n\tFor example, \"abc\" is a predecessor of \"abac\", while \"cba\" is not a predecessor of \"bcad\".\n\nA word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.\nReturn the length of the longest possible word chain with words chosen from the given list of words.\n&nbsp;\nExample 1:\n\nInput: words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: One of the longest word chains is [\"a\",\"ba\",\"bda\",\"bdca\"].\n\nExample 2:\n\nInput: words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\nOutput: 5\nExplanation: All the words can be put in a word chain [\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].\n\nExample 3:\n\nInput: words = [\"abcd\",\"dbqca\"]\nOutput: 1\nExplanation: The trivial word chain [\"abcd\"] is one of the longest word chains.\n[\"abcd\",\"dbqca\"] is not a valid word chain because the ordering of the letters is changed.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 16\n\twords[i] only consists of lowercase English letters.",
        "solutions": [
            {
                "id": 294890,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\nSort the `words` by word\\'s length. (also can apply bucket sort)\\nFor each word, loop on all possible previous word with 1 letter missing.\\nIf we have seen this previous word, update the longest chain for the current word.\\nFinally return the longest word chain.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)` for sorting,\\nTime  `O(NSS)` for the `for` loop, where the second `S` refers to the string generation and `S <= 16`.\\nSpace `O(NS)`\\n<br>\\n\\n**Python:**\\n```python\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in xrange(len(w)))\\n        return max(dp.values())\\n```\\n\\n**C++**\\n```cpp\\n    static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        int res = 0;\\n        for (string w : words) {\\n            for (int i = 0; i < w.length(); i++) {\\n                string pre = w.substr(0, i) + w.substr(i + 1);\\n                dp[w] = max(dp[w], dp.find(pre) == dp.end() ? 1 : dp[pre] + 1);\\n            }\\n            res = max(res, dp[w]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java**\\nSuggested by @noname_minion and @jenniferwang\\n```java\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> dp = new HashMap<>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        int res = 0;\\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                String prev = word.substring(0, i) + word.substring(i + 1);\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            res = Math.max(res, best);\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in xrange(len(w)))\\n        return max(dp.values())\\n```\n```cpp\\n    static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        int res = 0;\\n        for (string w : words) {\\n            for (int i = 0; i < w.length(); i++) {\\n                string pre = w.substr(0, i) + w.substr(i + 1);\\n                dp[w] = max(dp[w], dp.find(pre) == dp.end() ? 1 : dp[pre] + 1);\\n            }\\n            res = max(res, dp[w]);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> dp = new HashMap<>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        int res = 0;\\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                String prev = word.substring(0, i) + word.substring(i + 1);\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            res = Math.max(res, best);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2153007,
                "title": "c-python-simple-solution-w-explanation-dp",
                "content": "Given an array of `words`, we need to find the length of the ***longest possible word chain***. I will use some terms whose definitions are given in the problem statement without explaining them here.\\n\\nHow should we approach this problem? \\uD83E\\uDD14\\nThe first thing which comes into mind is **DP**. There are a few reasons for this thought.\\n\\n- It asks for **longest** possible word chain, so it is an optimization problem.\\n- The chain is extended by adding a new word which only depends on the last word of the chain. So, it can be broken down into subproblems.\\n\\n___\\n\\u2705 **Solution I: Bottom-Up DP [Accepted]**\\n\\nGenerally, we need to think of a recursive relation in a DP problem and then optimize it. But here, it wasn\\'t required. Can we start with the shortest word and try to build a chain starting with it? Let\\'s think in this direction. We then need to find the next shortest word and so on. It could be expensive, so *sorting* the entire array based on length will help.\\n\\nLet `prev` be the predecessor of a word. Building a successor from `prev` will be more expensive than building a predecessor from that word. The following example will make it clear:\\n\\n```text\\nprev = \"chain\"\\nTo build all possible successors, we need to add a letter anywhere in the word.\\n_ c _ h _ a _ i _ n _\\nWe have 6 possible spaces and 26 possible letters, so a total of 6 * 26 possibilities.\\n\\nNow, getting a predecessor from a word is a lot easier. Just remove a letter.\\nword = \"chains\"\\npred = {\"hains\", \"cains\", \"chins\", \"chans\", \"chais\", \"chain\"}\\n```\\n\\nSo, for each word, we\\'ll look for a predecessor. Wouldn\\'t it be great if can have a *data structure* with the following two properties: \\n\\n- Can tell which of these predecessors are present in the array efficiently.\\n- Store size of the chain ending with that predecessor.\\n\\nTurns out that we already have one. It is `unordered_map` in `C++` and `dictionary` in python.\\n**Example:**\\n\\n```text\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\n1. word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2. word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3. word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\n\\tHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4. word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5. word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6. word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4.\\n```\\n\\nNow with these ideas in mind, we are ready to code!\\n\\n<iframe src=\"https://leetcode.com/playground/WheZr2K3/shared\" frameBorder=\"0\" width=\"1080\" height=\"380\"></iframe>\\n\\n- **Time Complexity:** `O(nlog(n) + nll)`\\n  - `O(nlog(n))` for sorting\\n  - `O(nll)`: `n` for each loop, `l` for inner loop and `l` for string concatenation.\\n- **Space Complexity:** `O(ns)`\\n  - `O(n)` for both sorting and storing in dictionary.\\n  - `O(ns)`: `s` for creating space for `prev`, `n` times. \\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```text\\nprev = \"chain\"\\nTo build all possible successors, we need to add a letter anywhere in the word.\\n_ c _ h _ a _ i _ n _\\nWe have 6 possible spaces and 26 possible letters, so a total of 6 * 26 possibilities.\\n\\nNow, getting a predecessor from a word is a lot easier. Just remove a letter.\\nword = \"chains\"\\npred = {\"hains\", \"cains\", \"chins\", \"chans\", \"chais\", \"chain\"}\\n```\n```text\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\n1. word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2. word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3. word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\n\\tHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4. word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5. word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6. word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458069,
                "title": "java-easy-solution-with-explanation-must-read",
                "content": "```\\npublic int longestStrChain(String[] words) {\\n        \\n\\tif(words == null || words.length == 0) return 0;\\n\\tint res = 0;\\n\\tArrays.sort(words, (a,b)-> a.length()-b.length());  // Sort the words based on their lengths\\n\\tHashMap<String, Integer> map = new HashMap();       //Stores each word and length of its max chain.\\n\\n\\tfor(String w : words) {                             //From shortest word to longest word\\n\\t\\tmap.put(w, 1);                                  //Each word is atleast 1 chain long\\n\\t\\tfor(int i=0; i<w.length(); i++) {               //Form next word removing 1 char each time for each w\\n\\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t\\t\\tString next = sb.deleteCharAt(i).toString();\\n\\t\\t\\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t\\tmap.put(w, map.get(next)+1);            //If the new chain is longer, update the map\\n\\t\\t}\\n\\t\\tres = Math.max(res, map.get(w));                //Store max length of all chains\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**Edit History:**\\n1. In agreement to @Krizzt comment below, I removed `if(map.containsKey(w)) continue;` since it was not necessary",
                "solutionTags": [],
                "code": "```\\npublic int longestStrChain(String[] words) {\\n        \\n\\tif(words == null || words.length == 0) return 0;\\n\\tint res = 0;\\n\\tArrays.sort(words, (a,b)-> a.length()-b.length());  // Sort the words based on their lengths\\n\\tHashMap<String, Integer> map = new HashMap();       //Stores each word and length of its max chain.\\n\\n\\tfor(String w : words) {                             //From shortest word to longest word\\n\\t\\tmap.put(w, 1);                                  //Each word is atleast 1 chain long\\n\\t\\tfor(int i=0; i<w.length(); i++) {               //Form next word removing 1 char each time for each w\\n\\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t\\t\\tString next = sb.deleteCharAt(i).toString();\\n\\t\\t\\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t\\tmap.put(w, map.get(next)+1);            //If the new chain is longer, update the map\\n\\t\\t}\\n\\t\\tres = Math.max(res, map.get(w));                //Store max length of all chains\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213876,
                "title": "python-3-solutions-lis-dp-top-down-dp-bottom-up-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Longest Increasing Subsequence Idea**\\n- Firstly, we sort words in increasing order by their length, to ensure length of the previous word no longer than length of the current word, it means `len(words[j]) <= len(word[i])`, where `j < i`.\\n- Let `dp[i]` be the longest increasing subsequence which ends at `words[i]`.\\n- To check if `word1` is a predecessor of `word2`, we need to check\\n\\t- `len(word1) + 1` must equal to `len(word2)`.\\n\\t- `word1` must be a subsequence of `word2`.\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def isPredecessor(word1, word2):\\n            if len(word1) + 1 != len(word2): return False\\n            i = 0\\n            for c in word2:\\n                if i == len(word1): return True\\n                if word1[i] == c:\\n                    i += 1\\n            return i == len(word1)\\n        \\n        words.sort(key=len)\\n        n = len(words)\\n        dp = [1] * n\\n        ans = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if isPredecessor(words[j], words[i]) and dp[i] < dp[j] + 1:\\n                    dp[i] = dp[j] + 1\\n            ans = max(ans, dp[i])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N^2 * L)`, where `N <= 1000` is number of words, `L <= 16` is length of each word.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top-Down DP**\\n- Let `dp(word)` be the length of the **longest possible word chain** end at word `word`.\\n- To calculate `dp(word)`, we try all predecessors of word `word` and get the maximum length among them.\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        wordSet = set(words)\\n\\n        @lru_cache(None)\\n        def dp(word):\\n            ans = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i + 1:]\\n                if predecessor in wordSet:\\n                    ans = max(ans, dp(predecessor) + 1)\\n            return ans\\n\\n        return max(dp(w) for w in words)\\n```\\n**Complexity**\\n- Time: `O(N * L * L)`, where `N <= 1000` is number of words, `L <= 16` is length of a word\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom-Up DP**\\n- Firstly, we sort words in increasing order by their length, to ensure length of the previous word no longer than length of the current word, it means `len(words[j]) <= len(word[i])`, where `j < i`.\\n- Let `dp(word)` be the length of the **longest possible word chain** end at word `word`.\\n- To calculate `dp(word)`, we try all predecessors of word `word` and get the maximum length among them.\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)  # sort words by its length\\n        ans = 0\\n        dp = defaultdict(int)\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i+1:]\\n                if predecessor in dp and dp[word] < dp[predecessor] + 1:\\n                    dp[word] = dp[predecessor] + 1\\n            ans = max(ans, dp[word])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(NlogN + N*L*L)`, where `N <= 1000` is number of words, `L <= 16` is length of a word\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def isPredecessor(word1, word2):\\n            if len(word1) + 1 != len(word2): return False\\n            i = 0\\n            for c in word2:\\n                if i == len(word1): return True\\n                if word1[i] == c:\\n                    i += 1\\n            return i == len(word1)\\n        \\n        words.sort(key=len)\\n        n = len(words)\\n        dp = [1] * n\\n        ans = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if isPredecessor(words[j], words[i]) and dp[i] < dp[j] + 1:\\n                    dp[i] = dp[j] + 1\\n            ans = max(ans, dp[i])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        wordSet = set(words)\\n\\n        @lru_cache(None)\\n        def dp(word):\\n            ans = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i + 1:]\\n                if predecessor in wordSet:\\n                    ans = max(ans, dp(predecessor) + 1)\\n            return ans\\n\\n        return max(dp(w) for w in words)\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)  # sort words by its length\\n        ans = 0\\n        dp = defaultdict(int)\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i+1:]\\n                if predecessor in dp and dp[word] < dp[predecessor] + 1:\\n                    dp[word] = dp[predecessor] + 1\\n            ans = max(ans, dp[word])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153004,
                "title": "explaining-three-approaches-java",
                "content": "### Intuition:\\nThere are quite a few ways to solve this problem. Below are some ways I\\'ve compiled together and I\\'ll try my best to explain how they work and how you might transition from an intuitive thought process to code. Let\\'s get started! \\n\\nThe fundamental logic behind all three solutions remains the same: \\n![image](https://assets.leetcode.com/users/images/02391de9-bfa7-46b6-8515-88f445f406e5_1655259685.068525.png)\\n\\nBelow are the three main approaches I\\'ll go through that follow the above template:\\n1. **DFS + Memoization:** <ins>Increasing the length of the word in each call</ins>.\\n2. **DFS + Memoization:** <ins>Decreasing the length of the word in each call</ins>.\\n3. **DP:** <ins>Decreasing the length of the word in each iteration</ins>.\\n___\\n### DFS + Memoization:\\nWhen you\\'re first thinking of a memoization solution to this question, you\\'ve probably thought of starting  from any word and then finding all the valid \"next words\" that follow after. This makes the most sense intuitively since this is quite literally what the question is asking.\\n\\n**Approach 1: Increase Word Length:**\\n\\n![image](https://assets.leetcode.com/users/images/8259517c-db06-43cc-8fb1-48a134200c4b_1655256779.452725.png)\\nAs you can see from the above illustration, we\\'re computing the results for some strings multiple times. If we already know how deep a path can go from any given string, why calculate it again? We don\\'t have to; we can just store the result of that string in a memo cache and never have to recalculate for that string ever again. This concept is known as <ins>memoization</ins>. \\n\\n<ins>How do we implement this in code?</ins>\\nTurns out that all the valid words that follow the current word are guaranteed to be exactly one letter longer. Therefore, we can just store all the words with their associated lengths in a hashmap. E.g. Words with length 1: \"a\" and \"b\" would be stored with key `1`. Therefore, we can just get the list of words with a certain length, loop through them and see if any of them are valid words to continue the chain. \\nTo compare two words, we\\'ll use a custom function as you\\'ll see in the code. \\n___\\n**Approach 2: Decrease Word Length:**\\nThe slightly less intuitive idea here is to go in reverse; removing a letter from each word as the \"next\" step. This is a good example of the \"reframing the question\" strategy I\\'ve discussed in previous posts! This approach has the same time complexity as the previous approach but it\\'s a good example of how you can approach a question from multiple angles. Let\\'s see how this would work:\\n![image](https://assets.leetcode.com/users/images/d3811d30-0b83-4214-86b9-54528e328721_1655256829.9690504.png)\\nAgain, memoization is applied to avoid recomputation.\\n\\n<ins>How do we implement this in code?</ins>\\nThe way we find the next (or in this case, the previous) words is a bit different to how we did it in the previous approach despite following the same general structure. Since we\\'re decreasing a letter each time, we can simply chop off a letter from the current word, see if it exists in `words[]`, and add the letter back afterwards before continuing to the next letter. \\nFor constant time look-up, we\\'ll convert our `words[]` array to a hash set. \\n___\\n### Dynamic Programming:\\nThis is just your usual memoization to DP conversion. Nothing special! It\\'s basically an iterative version of the corresponding memoization algorithm. We can choose either of the above methods to convert to but I\\'ve chosen the second approach. As an exercise for yourself, try converting approach 1 from memoization to DP :)\\n\\n**Approach 3: Decrease Word Length using DP:**\\n![image](https://assets.leetcode.com/users/images/6ab94500-c156-478b-984d-a4b82dde6636_1655258399.1031818.png)\\n\\n<ins>How do we implement this in code?</ins>\\nThe most important adjustment here is that we need to sort our input array by length since at each word, we add to it the max length from each previous string in the chain. So, we would like all shorter strings to be computed before longer ones. If you chose to convert approach 1 to DP, you\\'d have to sort the array in reverse order. Remember, the fundamental approach hasn\\'t changed, but our execution has altered slightly since we\\'re replacing our memo table with a DP table,\\n\\nThat\\'s it! Now we\\'re ready to code something up.\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, please feel free to let me know. Thanks for reading!\\nFor the below complexity analyses, assume that `n` is the length of the array and `m` is the max word length.\\n\\n**DFS + Memoization | Increasing Word Length:**\\n> Time complexity: `O(n*m^2)`: In dfs(), we look at `n` word at most one time due to memoization. At each dfs(), we compare all nextWords which takes at most `O(m^2)` \\n> Space complexity: `O(n)` due to the call stack\\n```java\\nprivate Map<Integer, List<String>> wordLengthMap;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\t// store each word with its corresponding length\\n\\twordLengthMap = new HashMap<>();\\n\\tfor (String word: words) {\\n\\t\\twordLengthMap.putIfAbsent(word.length(), new ArrayList<>());\\n\\t\\twordLengthMap.get(word.length()).add(word);\\n\\t}\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (!wordLengthMap.containsKey(word.length() + 1)) return 1; // if there are no words of the next length, we\\'re done with this path.\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tint maxPath = 0;\\n\\t// for each word, find all words which are 1 letter longer and see if they are valid successors.\\n\\tList<String> nextWords = wordLengthMap.get(word.length() + 1);\\n\\tfor (String nextWord: nextWords) \\n\\t\\tif (isOneOff(word, nextWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(nextWord));\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store our result\\n\\treturn memo.get(word);\\n}\\n\\n// returns true if two strings differ by no more than 1 letter\\nprivate boolean isOneOff(String a, String b) {\\n\\tint count = 0;\\n\\tfor (int i=0, j=0; i<b.length() && j<a.length() && count <= 1; i++) {\\n\\t\\tif (a.charAt(j) != b.charAt(i)) count++;\\n\\t\\telse j++;\\n\\t}\\n\\treturn count <= 1;\\n}\\n```\\n\\n**DFS + Memoization | Decreasing Word Length:**\\n> Time complexity: `O(n*m^2)`: In dfs(), we look at \\'n\\' words at most one time due to memoization. At each dfs(), we loop through `m` characters and use `remove()` and `insert()` which each cost `O(m)`.\\n> Space complexity: `O(n)` due to the call stack.\\n```java\\nprivate Set<String> wordDict;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\twordDict = new HashSet<>();\\n\\tCollections.addAll(wordDict, words); // adding all words to a set for constant look-up\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tStringBuilder sb = new StringBuilder(word);\\n\\tint maxPath = 0;\\n\\t// delete each character, check if that\\'s a valid word in the set, add the character back and continue\\n\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\tsb.deleteCharAt(i);\\n\\t\\tString prevWord = sb.toString();\\n\\t\\tif (wordDict.contains(prevWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(prevWord));\\n\\t\\tsb.insert(i, word.charAt(i));\\n\\t}\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store the result\\n\\treturn memo.get(word);\\n}\\n```\\n\\n**DP | Decreasing Word Length:**\\n> Time complexity: `O(nlogn + n*m^2)`: sorting + same reasons as above.\\n> Space complexity: `O(n)` for the dp map.\\n```java\\npublic int longestStrChain(String[] words) {\\n\\tArrays.sort(words, (String a, String b) -> a.length() - b.length()); // sort by length\\n\\tMap<String, Integer> dp = new HashMap<>();\\n\\n\\tint maxPath = 1;\\n\\t// same idea behind the previous approach but performed iteratively.\\n\\tfor (String word: words) {\\n\\t\\tint currLength = 1;\\n\\t\\tStringBuilder sb = new StringBuilder(word);\\n\\t\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\t\\tsb.deleteCharAt(i);\\n\\t\\t\\tString prevWord = sb.toString();\\n\\t\\t\\tcurrLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1); \\n\\t\\t\\tsb.insert(i, word.charAt(i));\\n\\t\\t}\\n\\t\\tdp.put(word, currLength);\\n\\t\\tmaxPath = Math.max(maxPath, currLength);\\n\\t}\\n\\n\\treturn maxPath;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java\\nprivate Map<Integer, List<String>> wordLengthMap;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\t// store each word with its corresponding length\\n\\twordLengthMap = new HashMap<>();\\n\\tfor (String word: words) {\\n\\t\\twordLengthMap.putIfAbsent(word.length(), new ArrayList<>());\\n\\t\\twordLengthMap.get(word.length()).add(word);\\n\\t}\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (!wordLengthMap.containsKey(word.length() + 1)) return 1; // if there are no words of the next length, we\\'re done with this path.\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tint maxPath = 0;\\n\\t// for each word, find all words which are 1 letter longer and see if they are valid successors.\\n\\tList<String> nextWords = wordLengthMap.get(word.length() + 1);\\n\\tfor (String nextWord: nextWords) \\n\\t\\tif (isOneOff(word, nextWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(nextWord));\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store our result\\n\\treturn memo.get(word);\\n}\\n\\n// returns true if two strings differ by no more than 1 letter\\nprivate boolean isOneOff(String a, String b) {\\n\\tint count = 0;\\n\\tfor (int i=0, j=0; i<b.length() && j<a.length() && count <= 1; i++) {\\n\\t\\tif (a.charAt(j) != b.charAt(i)) count++;\\n\\t\\telse j++;\\n\\t}\\n\\treturn count <= 1;\\n}\\n```\n```java\\nprivate Set<String> wordDict;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\twordDict = new HashSet<>();\\n\\tCollections.addAll(wordDict, words); // adding all words to a set for constant look-up\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tStringBuilder sb = new StringBuilder(word);\\n\\tint maxPath = 0;\\n\\t// delete each character, check if that\\'s a valid word in the set, add the character back and continue\\n\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\tsb.deleteCharAt(i);\\n\\t\\tString prevWord = sb.toString();\\n\\t\\tif (wordDict.contains(prevWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(prevWord));\\n\\t\\tsb.insert(i, word.charAt(i));\\n\\t}\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store the result\\n\\treturn memo.get(word);\\n}\\n```\n```java\\npublic int longestStrChain(String[] words) {\\n\\tArrays.sort(words, (String a, String b) -> a.length() - b.length()); // sort by length\\n\\tMap<String, Integer> dp = new HashMap<>();\\n\\n\\tint maxPath = 1;\\n\\t// same idea behind the previous approach but performed iteratively.\\n\\tfor (String word: words) {\\n\\t\\tint currLength = 1;\\n\\t\\tStringBuilder sb = new StringBuilder(word);\\n\\t\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\t\\tsb.deleteCharAt(i);\\n\\t\\t\\tString prevWord = sb.toString();\\n\\t\\t\\tcurrLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1); \\n\\t\\t\\tsb.insert(i, word.charAt(i));\\n\\t\\t}\\n\\t\\tdp.put(word, currLength);\\n\\t\\tmaxPath = Math.max(maxPath, currLength);\\n\\t}\\n\\n\\treturn maxPath;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078579,
                "title": "95-46-dp-memo",
                "content": "# Interview Guide: \"Longest String Chain\" Problem\\n\\n## Problem Understanding\\n\\nThe \"Longest String Chain\" problem presents you with an array of words. The objective is to identify the lengthiest chain of words where every word in the chain acts as a predecessor to the subsequent word. A word, say `A`, stands as a predecessor to another word, `B`, if you can inject just a single letter at any position in `A`, without altering the sequence of its other characters, to match it to `B`.\\n\\n### Key Points to Ponder:\\n\\n1. **Grasp the Boundaries**\\n   Start by thoroughly comprehending the constraints of the problem. Words in the array can be as few as 1 or as many as 1000. Each word\\'s length can range between 1 to 16 characters. Understanding these limits can guide your solution\\'s design and efficiency.\\n\\n2. **Diverse Pathways**\\n   Multiple avenues can be explored to crack this problem, such as:\\n   - Dynamic Programming\\n   - Depth-First Search (DFS) with Memoization\\n\\n   Every approach carries its own time and space complexity. Thus, select wisely, keeping the constraints in mind.\\n\\n3. **Be Wary of Edge Cases**\\n   If you notice words that don\\'t adhere to the lowercase English letters rule or exceed the mentioned lengths, they can be potential edge cases to consider.\\n\\n4. **Narrate Your Thought Journey**\\n   As you unravel the problem, always articulate your thought process and the rationale behind picking a certain methodology. Shed light on any trade-offs you\\'re contemplating in terms of computational time and space.\\n\\n5. **Test and Validate**\\n   Once you\\'ve drafted a solution, validate it with different test cases, especially edge cases, to ensure its robustness.\\n\\n### Conclusion\\n\\nThe \"Longest String Chain\" problem is a classic example of challenges that examine your string manipulation and optimization skills. Being adept at various solution techniques and understanding the nuances can not only help you solve the problem efficiently but also make a strong impression in technical discussions or interviews. Your ability to understand, analyze, and optimize will set you apart.\\n\\n---\\n\\n# Strategy to Solve the Problem:\\n\\n## Live Coding Special\\nhttps://youtu.be/EiQpUgUghzY?si=leq4DHTH6WC7iiSB\\n\\n## Approach: Dynamic Programming\\n\\nTackling the \"Longest String Chain\" puzzle requires a blend of systematic organization and methodical computation. Our primary weapon of choice for this challenge is Dynamic Programming, a strategy that breaks problems down into smaller, more manageable sub-problems. The beauty of this approach lies in its ability to remember past results, which significantly speeds up computing the final solution.\\n\\n### Key Data Structures:\\n\\n- `dp`: A dictionary, acting like our memory vault, that remembers the longest chain length we can achieve for each word.\\n\\n### Detailed Breakdown:\\n\\n1. **Setting the Stage - Organizing Words**:\\n   - Imagine you\\'re arranging dominoes; the smallest pieces first, growing to the largest. Similarly, we start by sorting our words from shortest to longest. This ensures that when we\\'re looking at a word, any potential \\'parent\\' word (a word it could have evolved from) has already been evaluated.\\n\\n2. **Constructing Chains**:\\n   - For every word, we assume it to be a unique entity and assign a chain length of 1. This is our base scenario, the minimal chain.\\n   - Now, we dive deep into each word. By omitting one character at a time, we attempt to form a predecessor word. If this predecessor exists in our `dp` (our memory vault), it means our current word could have evolved from it. Using the transition function, we then update our current word\\'s chain length based on the predecessor\\'s length.\\n\\n**Why the Transition Function?**  \\nIn dynamic programming, transition functions act like bridges, connecting sub-problems to construct the bigger picture. Here, it helps us decide if the chain length of the current word should be updated based on its predecessor. It\\'s the heart of our solution, ensuring we always have the longest chain possible.\\n\\n### Complexity Commentary:\\n\\n**Time Complexity**: \\n- Our method involves scanning through our sorted list of words. For each word, it evaluates all possible words it could have evolved from. This double traversal gives rise to a time complexity of $$ O(n \\\\times m) $$, where $$ n $$ denotes the total number of words and $$ m $$ signifies the average word length.\\n\\n**Space Complexity**: \\n- Our `dp` dictionary occupies space based on the number of words, giving us a space complexity of $$ O(n) $$.\\n\\n\\n# Code Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        dp = {}\\n        max_chain = 0\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                prev_word = word[:i] + word[i+1:]\\n                if prev_word in dp:\\n                    dp[word] = max(dp[word], dp[prev_word] + 1)\\n            max_chain = max(max_chain, dp[word])\\n        return max_chain\\n```\\n``` Go []\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(i, j int) bool {\\n        return len(words[i]) < len(words[j])\\n    })\\n    dp := make(map[string]int)\\n    max_chain := 0\\n    for _, word := range words {\\n        dp[word] = 1\\n        for i := 0; i < len(word); i++ {\\n            prev_word := word[:i] + word[i+1:]\\n            if val, exists := dp[prev_word]; exists {\\n                dp[word] = max(dp[word], val + 1)\\n            }\\n        }\\n        max_chain = max(max_chain, dp[word])\\n    }\\n    return max_chain\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_key(|a| a.len());\\n        let mut dp: HashMap<String, i32> = HashMap::new();\\n        let mut max_chain = 0;\\n        for word in &words {\\n            dp.insert(word.clone(), 1);\\n            for i in 0..word.len() {\\n                let prev_word = format!(\"{}{}\", &word[..i], &word[i+1..]);\\n                if let Some(val) = dp.get(&prev_word) {\\n                    dp.insert(word.clone(), std::cmp::max(dp[word], val + 1));\\n                }\\n            }\\n            max_chain = std::cmp::max(max_chain, dp[word]);\\n        }\\n        max_chain\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(std::vector<std::string>& words) {\\n        std::sort(words.begin(), words.end(), [](const std::string& a, const std::string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        std::unordered_map<std::string, int> dp;\\n        int max_chain = 0;\\n        for (const auto& word : words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.size(); ++i) {\\n                std::string prev_word = word.substr(0, i) + word.substr(i + 1);\\n                if (dp.find(prev_word) != dp.end()) {\\n                    dp[word] = std::max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = std::max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n        int max_chain = 0;\\n        for (String word : words) {\\n            dp.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                String prev_word = word.substring(0, i) + word.substring(i + 1);\\n                if (dp.containsKey(prev_word)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev_word) + 1));\\n                }\\n            }\\n            max_chain = Math.max(max_chain, dp.get(word));\\n        }\\n        return max_chain;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function longestStrChain($words) {\\n        usort($words, function($a, $b) {\\n            return strlen($a) - strlen($b);\\n        });\\n        $dp = [];\\n        $max_chain = 0;\\n        foreach ($words as $word) {\\n            $dp[$word] = 1;\\n            for ($i = 0; $i < strlen($word); $i++) {\\n                $prev_word = substr($word, 0, $i) . substr($word, $i + 1);\\n                if (isset($dp[$prev_word])) {\\n                    $dp[$word] = max($dp[$word], $dp[$prev_word] + 1);\\n                }\\n            }\\n            $max_chain = max($max_chain, $dp[$word]);\\n        }\\n        return $max_chain;\\n    }\\n}\\n```\\n``` JavaScritp []\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    const dp = {};\\n    let max_chain = 0;\\n    for (const word of words) {\\n        dp[word] = 1;\\n        for (let i = 0; i < word.length; i++) {\\n            const prev_word = word.slice(0, i) + word.slice(i + 1);\\n            if (prev_word in dp) {\\n                dp[word] = Math.max(dp[word], dp[prev_word] + 1);\\n            }\\n        }\\n        max_chain = Math.max(max_chain, dp[word]);\\n    }\\n    return max_chain;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        Array.Sort(words, (a, b) => a.Length.CompareTo(b.Length));\\n        Dictionary<string, int> dp = new Dictionary<string, int>();\\n        int max_chain = 0;\\n        foreach (var word in words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.Length; i++) {\\n                string prev_word = word.Remove(i, 1);\\n                if (dp.ContainsKey(prev_word)) {\\n                    dp[word] = Math.Max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = Math.Max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n}\\n```\\n\\n---\\n\\n## Memoization with DFS Approach:\\n\\nThis approach uses DFS to explore the potential chains starting from each word. To optimize the solution, the results of expensive recursive calls are cached using memoization.\\n\\n### Key Data Structures:\\n\\n- `memo`: A dictionary to cache the results of DFS calls for each word.\\n\\n### Enhanced Breakdown:\\n\\n1. **DFS Exploration**:\\n   - For each word, recursively explore its potential predecessors by removing one character at a time.\\n   - Cache the result of the DFS exploration for each word to avoid redundant calculations.\\n\\n2. **Check Maximum Chain Length**:\\n   - After exploring all potential chains starting from a word, store the maximum chain length found in the `memo` dictionary.\\n\\n### Complexity Analysis:\\n\\n**Time Complexity**: \\n- The algorithm explores each word once and, for each word, checks all its potential predecessors. Due to memoization, repeated calculations are avoided. The time complexity is $$ O(n \\\\times m) $$.\\n\\n**Space Complexity**: \\n- The space complexity is $$ O(n) $$ due to the storage requirements of the `memo` dictionary and the `word_set`.\\n\\n\\n## Code Memoization with DFS\\n``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        word_set = set(words)\\n        memo = {}\\n\\n        def dfs(word):\\n            if word not in word_set:\\n                return 0\\n\\n            if word in memo:\\n                return memo[word]\\n\\n            max_chain = 1\\n            for i in range(len(word)):\\n                next_word = word[:i] + word[i+1:]\\n                max_chain = max(max_chain, 1 + dfs(next_word))\\n\\n            memo[word] = max_chain\\n            return max_chain\\n\\n        return max(dfs(word) for word in words)\\n```\\n\\n## Performance\\n\\n| Language    | Time (ms) | Memory (MB) | Solution Technique    |\\n|-------------|----------:|------------:|-----------------------|\\n| Go          | 21        | 6.8         | DP                    |\\n| Rust        | 28        | 2.5         | DP                    |\\n| Java        | 39        | 44.5        | DP                    |\\n| PHP         | 42        | 19.3        | DP                    |\\n| C++         | 58        | 17.0        | DP                    |\\n| C#          | 96        | 56.8        | DP                    |\\n| Python3     | 112       | 16.7        | DP                    |\\n| Python3     | 147       | 20.2        | Memoization with DFS  |\\n| JavaScript  | 167       | 63.4        | DP                    |\\n\\n![plot2.png](https://assets.leetcode.com/users/images/8240584c-22d3-47ba-9123-ab459b86a6a8_1695429079.3058512.png)\\n\\n\\n## Summary\\n\\nAll strategies provided above tackle the problem effectively. The dynamic programming approach offers a systematic way of computing the chain lengths, making it intuitive and efficient. On the other hand, the DFS with memoization approach provides a depth-first exploration of the problem, optimized by caching results. Depending on the nature of the input and specific use cases, one can choose the appropriate strategy to solve the problem.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        dp = {}\\n        max_chain = 0\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                prev_word = word[:i] + word[i+1:]\\n                if prev_word in dp:\\n                    dp[word] = max(dp[word], dp[prev_word] + 1)\\n            max_chain = max(max_chain, dp[word])\\n        return max_chain\\n```\n``` Go []\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(i, j int) bool {\\n        return len(words[i]) < len(words[j])\\n    })\\n    dp := make(map[string]int)\\n    max_chain := 0\\n    for _, word := range words {\\n        dp[word] = 1\\n        for i := 0; i < len(word); i++ {\\n            prev_word := word[:i] + word[i+1:]\\n            if val, exists := dp[prev_word]; exists {\\n                dp[word] = max(dp[word], val + 1)\\n            }\\n        }\\n        max_chain = max(max_chain, dp[word])\\n    }\\n    return max_chain\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_key(|a| a.len());\\n        let mut dp: HashMap<String, i32> = HashMap::new();\\n        let mut max_chain = 0;\\n        for word in &words {\\n            dp.insert(word.clone(), 1);\\n            for i in 0..word.len() {\\n                let prev_word = format!(\"{}{}\", &word[..i], &word[i+1..]);\\n                if let Some(val) = dp.get(&prev_word) {\\n                    dp.insert(word.clone(), std::cmp::max(dp[word], val + 1));\\n                }\\n            }\\n            max_chain = std::cmp::max(max_chain, dp[word]);\\n        }\\n        max_chain\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(std::vector<std::string>& words) {\\n        std::sort(words.begin(), words.end(), [](const std::string& a, const std::string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        std::unordered_map<std::string, int> dp;\\n        int max_chain = 0;\\n        for (const auto& word : words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.size(); ++i) {\\n                std::string prev_word = word.substr(0, i) + word.substr(i + 1);\\n                if (dp.find(prev_word) != dp.end()) {\\n                    dp[word] = std::max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = std::max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n        int max_chain = 0;\\n        for (String word : words) {\\n            dp.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                String prev_word = word.substring(0, i) + word.substring(i + 1);\\n                if (dp.containsKey(prev_word)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev_word) + 1));\\n                }\\n            }\\n            max_chain = Math.max(max_chain, dp.get(word));\\n        }\\n        return max_chain;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function longestStrChain($words) {\\n        usort($words, function($a, $b) {\\n            return strlen($a) - strlen($b);\\n        });\\n        $dp = [];\\n        $max_chain = 0;\\n        foreach ($words as $word) {\\n            $dp[$word] = 1;\\n            for ($i = 0; $i < strlen($word); $i++) {\\n                $prev_word = substr($word, 0, $i) . substr($word, $i + 1);\\n                if (isset($dp[$prev_word])) {\\n                    $dp[$word] = max($dp[$word], $dp[$prev_word] + 1);\\n                }\\n            }\\n            $max_chain = max($max_chain, $dp[$word]);\\n        }\\n        return $max_chain;\\n    }\\n}\\n```\n``` JavaScritp []\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    const dp = {};\\n    let max_chain = 0;\\n    for (const word of words) {\\n        dp[word] = 1;\\n        for (let i = 0; i < word.length; i++) {\\n            const prev_word = word.slice(0, i) + word.slice(i + 1);\\n            if (prev_word in dp) {\\n                dp[word] = Math.max(dp[word], dp[prev_word] + 1);\\n            }\\n        }\\n        max_chain = Math.max(max_chain, dp[word]);\\n    }\\n    return max_chain;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        Array.Sort(words, (a, b) => a.Length.CompareTo(b.Length));\\n        Dictionary<string, int> dp = new Dictionary<string, int>();\\n        int max_chain = 0;\\n        foreach (var word in words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.Length; i++) {\\n                string prev_word = word.Remove(i, 1);\\n                if (dp.ContainsKey(prev_word)) {\\n                    dp[word] = Math.Max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = Math.Max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        word_set = set(words)\\n        memo = {}\\n\\n        def dfs(word):\\n            if word not in word_set:\\n                return 0\\n\\n            if word in memo:\\n                return memo[word]\\n\\n            max_chain = 1\\n            for i in range(len(word)):\\n                next_word = word[:i] + word[i+1:]\\n                max_chain = max(max_chain, 1 + dfs(next_word))\\n\\n            memo[word] = max_chain\\n            return max_chain\\n\\n        return max(dfs(word) for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213855,
                "title": "js-python-java-c-fast-set-dp-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nA naive approach would be to check every word against every other word looking for predecessors, but that would lead to a **TLE** result. The first important realization that we should be able to make is that while a **word** may have many **26 * (word.length + 1)** possible successors, it can only have **word.length** predecessors.\\n\\nSo rather than iterating from small to large words and checking every combination for a link, we can store the words in a **set** and only check the few possible predecessors while iterating from large to small. To aid in that, we can actually separate words into an array of sets (**W**) indexed by word length, so that we can directly access batches of words by their length.\\n\\n_(**Note**: As we iterate backward through **W**, if we find that **W[i-1]** is empty, we don\\'t need to process the words in **W[i]**, since there cannot possibly be a predecessor match.)_\\n\\nThen we can use a **dynamic programming** (**DP**) approach to eliminate some common subproblems. We can define a **hashmap** (**dp**) where **dp[word]** is the length of the longest chain ending at **word** found so far.\\n\\nSo at each **word**, we\\'ll iterate through each of its predecessors (**pred**) and check the appropriate set in **W** for a match. If we find a match, we can update **dp[pred]** if **dp[word] + 1** is better, increasing the chain by one. We should also separately keep track of the **best** chain length we\\'ve seen, so that once we reach the end, we can just **return best**.\\n\\n - _**Time Complexity: O(N*M)** where **N** is the length of **words** and **M** is the average length of the words in **words**._\\n - _**Space Complexity: O(N + P)** where **P** is the number of predecessors found and stored in **dp**._\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 45.8MB** (beats 100% / 75%).\\n```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **84ms / 14.5MB** (beats 100% / 90%).\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **20ms / 38.8MB** (beats 92% / 91%).\\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **52ms / 31.2MB** (beats 91% / 27%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485951,
                "title": "python-correct-dp-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        d = dict()\\n        for word in words:\\n            d[word] = 1\\n        longest = 1\\n        for word in sorted(words, key=len):\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i + 1:]\\n                if prev in d:\\n                    d[word] = max(d[word], d[prev] + 1)\\n            longest = max(longest, d[word])\\n        return longest\\n```\\nInitially, each word\\'s longest chain is set to 1. Then, we loop the list of words to find out whether it has a predecessor in the list. If there is a predecessor, we know current word\\'s longest chain could be predecessor\\'s longest chain plus one.\\n\\nThere are two main points for this solution:\\n1.  Sort the word list `words` by each length of the word.\\nAs mentioned above, current word\\'s longest chain is formed by predecessor\\'s longest chain plus one. Therefore, we must calculate the predecessor\\'s longest chain first, otherwise the answer would be incorrect.\\n\\n2. Comparing the current word\\'s chain with all its predecessor\\'s longest chain plus one to find out the current word\\'s longest chain. \\nThis is because the current word\\'s chain could possibly be formed in many different ways, so we need to compare them to find out the longest one.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        d = dict()\\n        for word in words:\\n            d[word] = 1\\n        longest = 1\\n        for word in sorted(words, key=len):\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i + 1:]\\n                if prev in d:\\n                    d[word] = max(d[word], d[prev] + 1)\\n            longest = max(longest, d[word])\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295025,
                "title": "java-concise-dp-solution",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        \\n        Map<String, Integer> dp = new HashMap<>();\\n        for (String word : words) {\\n            dp.put(word, 1);\\n        }\\n    \\n        int max = 0;\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); ++i) {   // delete one char from current word to find the previous string\\n                String prev = word.substring(0, i) + word.substring(i+1);\\n                if (dp.containsKey(prev)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev) + 1));\\n                }\\n            }\\n            max = Math.max(max, dp.get(word));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        \\n        Map<String, Integer> dp = new HashMap<>();\\n        for (String word : words) {\\n            dp.put(word, 1);\\n        }\\n    \\n        int max = 0;\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); ++i) {   // delete one char from current word to find the previous string\\n                String prev = word.substring(0, i) + word.substring(i+1);\\n                if (dp.containsKey(prev)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev) + 1));\\n                }\\n            }\\n            max = Math.max(max, dp.get(word));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294918,
                "title": "dp-with-hashmap-in-java",
                "content": "1. Sort the strings by their lengths\\n2. Start from shorter words (bottom up DP)\\n2. During the loop: for each word, iterate through its length and each time delete 1 char. Update the longest string chain length in the hashmap for the current word. \\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if (words == null || words.length == 0) return 0;\\n        int res = 0;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String str1, String str2) {\\n                return str1.length() - str2.length();\\n            }\\n        });\\n        HashMap<String, Integer> map = new HashMap();\\n        for (String word : words) {\\n            if (map.containsKey(word)) continue;\\n            map.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.deleteCharAt(i);\\n                String next = sb.toString();\\n                if (map.containsKey(next) && map.get(next) + 1 > map.get(word)) {\\n                    map.put(word, map.get(next) + 1);\\n                }\\n            }\\n            if (map.get(word) > res) res = map.get(word);\\n        }\\n        return res;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if (words == null || words.length == 0) return 0;\\n        int res = 0;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String str1, String str2) {\\n                return str1.length() - str2.length();\\n            }\\n        });\\n        HashMap<String, Integer> map = new HashMap();\\n        for (String word : words) {\\n            if (map.containsKey(word)) continue;\\n            map.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.deleteCharAt(i);\\n                String next = sb.toString();\\n                if (map.containsKey(next) && map.get(next) + 1 > map.get(word)) {\\n                    map.put(word, map.get(next) + 1);\\n                }\\n            }\\n            if (map.get(word) > res) res = map.get(word);\\n        }\\n        return res;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309808,
                "title": "python-graph-intuitive",
                "content": "I found the official solutions insanely unintuitive and difficult to reason about. Here\\'s a simple, straightforward graph-theory-based solution for this problem.\\n\\n#### Graph Theory\\n - `words` form a Directed Acyclic Graph (DAG)\\n - the problem is to find the *longest path* in the DAG\\n - normally longest path is NP-hard, but for a DAG, it can be done much faster\\n - we want to first topologically sort the nodes, in this case, that means sorting by word length\\n - next, we need to build our graph. We could either compare each word to every other word O(n^2) or build a dictionary of each previous word to the next word O(n * L) where L is the average length of a word in words. Because `n <= 1000` and `L <= 16`, we want O(n * L)\\n - we initialize a `dists` array where `dists[i]` is initially `1`\\n - finally we iterate over each `u, v` pair in topologically sorted order and we offer to set `dists[v]` to `dists[u] + 1` and then offer to set `ans` to `dists[v]`\\n\\n##### One quick catch:\\n`graph[word]` is a `set`, not a `list` because a word with duplicate adjacent letters would be added twice (ie `hello`). This isn\\'t technically a problem because we can offer to set `dists[v]` twice and you could view the graph as having two parallel edges. I just prefer to do it this way.\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n = len(words)\\n        words.sort(key=lambda w: len(w))\\n        graph = defaultdict(set)\\n        for i in range(n):\\n            word = words[i]\\n            for j in range(len(word)):\\n                graph[word[:j]+word[j+1:]].add(i)\\n        dists = [1] * n\\n        ans = 1\\n        for u in range(n):\\n            for v in graph[words[u]]:\\n                dists[v] = max(dists[v], dists[u]+1)\\n                ans = max(ans, dists[v])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n = len(words)\\n        words.sort(key=lambda w: len(w))\\n        graph = defaultdict(set)\\n        for i in range(n):\\n            word = words[i]\\n            for j in range(len(word)):\\n                graph[word[:j]+word[j+1:]].add(i)\\n        dists = [1] * n\\n        ans = 1\\n        for u in range(n):\\n            for v in graph[words[u]]:\\n                dists[v] = max(dists[v], dists[u]+1)\\n                ans = max(ans, dists[v])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152874,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nFIrstly ```sort``` the given array on basis of length of words. Such that for a word **i** we would be checking words having length smaller than **i**\\n\\nCreate a ```dictionary``` or ```mapping``` to store the chain length till that words.\\nWhen chain of bigger word is to be found , it will be -> ``` 1 + smaller_length_of_chain```.\\n\\nInitialize the chain length of each word to be ***1***.\\n\\nAs ```word.length <= 16```, it is easy to create all combinations by taking out one character.\\n\\nForm different words ```successor``` by deleting a letter and check if that word has a larger chain length.\\n\\nKeep updating and select maximum chain length from ```mapping``` / ```dictionary```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        \\n        map<string,int> m;\\n        int res = 0;\\n        \\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            \\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c36e9897-0d0f-4077-8457-784cfe87aaf9_1655253023.3773618.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sort```\n```dictionary```\n```mapping```\n``` 1 + smaller_length_of_chain```\n```word.length <= 16```\n```successor```\n```mapping```\n```dictionary```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        \\n        map<string,int> m;\\n        int res = 0;\\n        \\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            \\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152864,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nFIrstly ```sort``` the given array on basis of length of words. Such that for a word **i** we would be checking words having length smaller than **i**\\n\\nCreate a ```dictionary``` or ```mapping``` to store the chain length till that words.\\nWhen chain of bigger word is to be found , it will be -> ``` 1 + smaller_length_of_chain```.\\n\\nInitialize the chain length of each word to be ***1***.\\n\\nAs ```word.length <= 16```, it is easy to create all combinations by taking out one character.\\n\\nForm different words ```successor``` by deleting a letter and check if that word has a larger chain length.\\n\\nKeep updating and select maximum chain length from ```mapping``` / ```dictionary```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key=len)\\n        dic = {}\\n        \\n        for i in words:\\n            dic[ i ] = 1\\n            \\n            for j in range(len(i)):\\n                \\n                # creating words by deleting a letter\\n                successor = i[:j] + i[j+1:]\\n                if successor in dic:\\n                    dic[ i ] = max (dic[i], 1 + dic[successor])\\n        \\n        res = max(dic.values())\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/77cb1004-ff4a-4800-a861-1ed09b1cb8e9_1655252348.3756516.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sort```\n```dictionary```\n```mapping```\n``` 1 + smaller_length_of_chain```\n```word.length <= 16```\n```successor```\n```mapping```\n```dictionary```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key=len)\\n        dic = {}\\n        \\n        for i in words:\\n            dic[ i ] = 1\\n            \\n            for j in range(len(i)):\\n                \\n                # creating words by deleting a letter\\n                successor = i[:j] + i[j+1:]\\n                if successor in dic:\\n                    dic[ i ] = max (dic[i], 1 + dic[successor])\\n        \\n        res = max(dic.values())\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295182,
                "title": "c-bottom-up-dp-solution-with-explanation",
                "content": "**Steps Involed :**\\n1. Divide the words list into different levels according to their length, (atmost 17 as given in the contraint).\\n2. Initialize each word with chain value 1, using a map. i.e. each word in the list is itself a chain of length 1.\\n3. Now we loop through all the levels, since words of length 1 cannot can have predecessor and there is any word of length 1, it\\'s value has been already mapped to 1, we start with words of length 2. \\n4. Now, we find possible predecessor of all words of length, using method **findAllWords** . eg - say for word ac, predecessor would be a or c. For word abcd it would be bcd, acd, abd.\\n5. For each predecessory word, we check if it already exists using our map, if yes, we add\\n1 to its value, since now we have word chain of length 1 more than the predecessory. It may happen that a predecessory has a value greater than other predecessor, so we need to take the maximum of them. \\n6. We maintain our ans by taking maximum of all the word chains we have till now.\\n\\n**If you have any doubt regarding my solution, feel free to ask.**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> findAllWords(string &a)\\n    {\\n        vector<string> vec;\\n        for (int i=0; i<a.size(); ++i)\\n        {\\n            vec.push_back(a.substr(0, i) + a.substr(i+1, a.size()-i-1));\\n        }\\n        return vec;\\n    }\\n    \\n    int longestStrChain(vector<string>& words)\\n    {\\n        // Divides given word in 17 levels, according to their word length.\\n        vector<vector<string>> levels(17);\\n        for (auto &word : words)    levels[word.size()].push_back(word);\\n        \\n        unordered_map<string, int> mp;\\n        for (auto word: words)  mp[word] = 1;\\n        \\n        int ans = 1;\\n        for (int i=2; i<=16; ++i)\\n        {\\n            for (int j=0; j<levels[i].size(); ++j)\\n            {\\n                vector<string> diffWords = findAllWords(levels[i][j]);\\n                \\n                for (auto word: diffWords)\\n                {\\n                    if (mp.find(word) != mp.end())  mp[levels[i][j]] = max(mp[word] + 1, mp[levels[i][j]]);\\n                }\\n                \\n                ans = max (ans, mp[levels[i][j]]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> findAllWords(string &a)\\n    {\\n        vector<string> vec;\\n        for (int i=0; i<a.size(); ++i)\\n        {\\n            vec.push_back(a.substr(0, i) + a.substr(i+1, a.size()-i-1));\\n        }\\n        return vec;\\n    }\\n    \\n    int longestStrChain(vector<string>& words)\\n    {\\n        // Divides given word in 17 levels, according to their word length.\\n        vector<vector<string>> levels(17);\\n        for (auto &word : words)    levels[word.size()].push_back(word);\\n        \\n        unordered_map<string, int> mp;\\n        for (auto word: words)  mp[word] = 1;\\n        \\n        int ans = 1;\\n        for (int i=2; i<=16; ++i)\\n        {\\n            for (int j=0; j<levels[i].size(); ++j)\\n            {\\n                vector<string> diffWords = findAllWords(levels[i][j]);\\n                \\n                for (auto word: diffWords)\\n                {\\n                    if (mp.find(word) != mp.end())  mp[levels[i][j]] = max(mp[word] + 1, mp[levels[i][j]]);\\n                }\\n                \\n                ans = max (ans, mp[levels[i][j]]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334384,
                "title": "no-sort-easy-and-short-to-understand-solution-90",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        ans = 0\\n        words_set = set(words)\\n        dp = {}\\n        def dfs(word):\\n            if word in dp: return dp[word]\\n            ans = 1\\n            for i in range(len(word)):\\n                next_word = word[:i] + word[i + 1:]\\n                if next_word in words_set:\\n                    ans = max(1 + dfs(next_word), ans)\\n            dp[word] = ans\\n            return ans\\n                \\n        for word in words:\\n            ans = max(ans, dfs(word))\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        ans = 0\\n        words_set = set(words)\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 298884,
                "title": "python-using-dictionary",
                "content": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words = sorted(words, key=lambda word:len(word))\\n        word_dict = {}\\n        \\n        for word in words:\\n            word_dict[word] = 1\\n        \\n        longest = 1\\n        for word in words:\\n            for i in xrange(len(word)):\\n                if word[:i] + word[i + 1:] in word_dict:\\n\\t\\t\\t\\t\\tword_dict[word]=max(word_dict[word[:i]+word[i+1:]]+1, word_dict[word])\\n                    longest = max(longest, word_dict[word])\\n        \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words = sorted(words, key=lambda word:len(word))\\n        word_dict = {}\\n        \\n        for word in words:\\n            word_dict[word] = 1\\n        \\n        longest = 1\\n        for word in words:\\n            for i in xrange(len(word)):\\n                if word[:i] + word[i + 1:] in word_dict:\\n\\t\\t\\t\\t\\tword_dict[word]=max(word_dict[word[:i]+word[i+1:]]+1, word_dict[word])\\n                    longest = max(longest, word_dict[word])\\n        \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080044,
                "title": "video-how-we-think-about-a-solution-beats-97-49-python-javascript-java-c",
                "content": "This artcle starts with \"How we think about a solution\". In other words, that is my thought process to solve the question. This article explains how I get to my solution instead of just posting solution codes or out of blue algorithms. I hope this aricle is helpful for someone.\\n\\n# Intuition\\nSort all words by length of the words\\n\\n---\\n\\n# Solution Video\\n\\nIn the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/NJzV2nE8KjI\\n\\n\\u25A0 Timeline\\n`0:00` Read the question of Longest String Chain\\n`0:57` How we think about a solution\\n`4:01` Explain how to solve Longest String Chain with a concrete example\\n`7:19` Coding\\n`11:20` Time Complexity and Space Complexity\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,446\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## How we think about a solution\\nAccording to the description, we can create another word `wordB` from `wordA` by adding one letter anywhere in `wordA`, so seems like it\\'s easy for us to solve the question with `sorting` because the differece between `wordA` and `wordB` is just one letter. I thought `sorting` might make the question easy to compare words.\\n\\nQuestion is that what do you sort all input data by? each character in all words? My answer is `to sort by length of input words`. \\n\\nI have 3 reasons.\\n\\n1. **Increased Potential for Efficient Solutions**:\\n   Sorting the words by their length allows us to process the words starting from the shortest, potentially leading to more efficient algorithms as we can prioritize shorter words first.\\n\\n2. **Enables Preprocessing**:\\n    Since we are sure that `wordB` is +1 longer than `wordA` and `wordB` has one different letter from `wordA`, if we take off one letter from `wordB` one by one, we can create all predecessors of `wordB` which are all possible `wordA`.  For example,\\n\\n```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\\n\\nSo we have 3 possible predecessor candidates.\\n\\nOne more important thing why we should sort by length is that now we check `abc` which is `length of 3`. That means we already finished checking `the max chain length unitl length of 2` because we sorted by length of input words. In other words, We should have the results for all possible words until length of 2. `all possible words` means all words coming from input list `words`. That is the third reason to sort by length of words.\\n\\nIn this case, we need to keep all the previous results. What strategy do you use to keep the results?\\n\\nMy answer is `Dynamic Programming`. More precisely use `HashMap`.\\n\\nWe can only use words from input list `words`, so keys of `Hashmap` should be words from input list `words`. Each value stands for max chain length for each word.\\n\\nLet\\'s see what I said with \\n```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\\nCurrent `wordB` is `abc` and we have 3 possible predecessor candidates. Let\\'s say we have the results until length of 2 like this\\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2}\\n```\\nIn this case, we check `bc`, `ac`, `ab` one by one.\\n\\nFirst of all, we should add `abc` with `1` because word `abc` itself is at least one chain.\\n\\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2, \\'abc\\': 1}\\n```\\n\\nThen check `bc`. We have the result of `bc` which is 1, so compare like this\\n```\\nhash[wordB] = max(hash[wordB], hash[\"bc\"] + 1)\\n```\\n`hash[wordB]` is current result so far and `hash[\"bc\"]` is the previous result `1`, `+1` is for adding some character. This time, a chain should be `+1` longer than from previous word. Now `hash[wordB] = 2`\\n\\nNext, check `ac` but we don\\'t have the result for `ac` which means `ac` is not listed in input list `words`.\\n\\nAt last, check `ab` and we have the result of `ab` which is `2`, so\\n\\n```\\nNow, hash[wordB] = 2\\n\\nhash[wordB] = max(hash[wordB], hash[\"ab\"] + 1)\\n\\u2193\\nhash[wordB] = max(2, 2 + 1)\\n\\u2193\\nhash[wordB] = 3\\n```\\n\\nIn the end, `hash` has the max chain length for each valid word. So all we have to do is just take max of chains from `hash`.\\n\\nSeems like `sorting` and `dynamic programming` strategy works. Let\\'s see a real algorithm.\\n\\n## Algorithm Overview\\n1. Create a dictionary `chains` to store the maximum chain length for each word.\\n2. Sort the words in the input list by their lengths.\\n3. Iterate through the sorted words and calculate the maximum chain length for each word.\\n4. Return the maximum chain length found.\\n\\n## Detailed Explanation\\n1. Initialize an empty dictionary `chains` to store the maximum chain length for each word.\\n\\n2. Sort the words in the input list (`words`) by their lengths using the `sorted` function and assign the result to `sorted_words`.\\n\\n3. Iterate through each word in the sorted list (`sorted_words`):\\n\\n   a. For each word, initialize the chain length for that word in the `chains` dictionary to 1, representing the chain with just the word itself.\\n   \\n   b. For each index `i` in the range of the length of the current word:\\n   \\n    i. Generate the predecessor of the current word by removing the character at index `i` using slicing (`word[:i] + word[i+1:]`), and assign it to `pred`.\\n      \\n      ii. Check if the predecessor `pred` is already in the `chains` dictionary:\\n      \\n    - If it is, update the chain length for the current word (`chains[word]`) to the maximum of its current chain length and the chain length of the predecessor incremented by 1 (`chains[pred] + 1`).\\n          \\n    - If it\\'s not, continue to the next iteration.\\n   \\n4. Return the maximum chain length found by taking the maximum value from the values in the `chains` dictionary using the `max` function. This represents the longest string chain.\\n\\n5. The function returns the maximum chain length.\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log n + len(words) * 16) \\u2192 `O(n log n)`\\n    - the first part of `O(n log n)` comes from `sorting`, where `n` is the number of words (which can be at most 1000)\\n\\n    - `len(words) * 16` comes from for loop. `len(words)` is `n` and `16` comes from one of constraints and can be removed, so part of `len(words) * 16` should be `n`.\\n    - Since `O(n log n)` dominates time, overall time complexity is `O(n log n)`\\n\\n- Space complexity: O(n)\\n`n` is the number of words\\n\\n\\n```python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        chains = {}  # Stores the max chain length for each word\\n        sorted_words = sorted(words, key=len) # Sort words by length\\n\\n        for word in sorted_words:\\n            chains[word] = 1  # Initialize the chain length for the current word\\n            \\n            for i in range(len(word)):\\n                # word = abc, i = 0, word[:i] = \"\" + word[i+1:] = \"bc\" = \"bc\"\\n                # word = abc, i = 1, word[:i] = \"a\" + word[i+1:] = \"c\" = \"ac\"\\n                # word = abc, i = 2, word[:i] = \"ab\" + word[i+1:] = \"\" = \"ab\"\\n                pred = word[:i] + word[i+1:]  # Generate predecessor by removing one character\\n                if pred in chains:\\n                    chains[word] = max(chains[word], chains[pred] + 1)\\n\\n        return max(chains.values())\\n```\\n```javascript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    const chains = new Map();  // Stores the max chain length for each word\\n    const sortedWords = words.slice().sort((a, b) => a.length - b.length);  // Sort words by length\\n\\n    for (const word of sortedWords) {\\n        chains.set(word, 1);  // Initialize the chain length for the current word\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const pred = word.slice(0, i) + word.slice(i + 1);  // Generate predecessor by removing one character\\n            if (chains.has(pred)) {\\n                chains.set(word, Math.max(chains.get(word) || 0, chains.get(pred) + 1));\\n            }\\n        }\\n    }\\n\\n    return Math.max(...Array.from(chains.values()));  // Return the maximum chain length    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> chains = new HashMap<>();  // Stores the max chain length for each word\\n        String[] sortedWords = Arrays.copyOf(words, words.length);\\n        Arrays.sort(sortedWords, (a, b) -> a.length() - b.length());  // Sort words by length\\n\\n        for (String word : sortedWords) {\\n            chains.put(word, 1);  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                String pred = word.substring(0, i) + word.substring(i + 1);  // Generate predecessor by removing one character\\n                if (chains.containsKey(pred)) {\\n                    chains.put(word, Math.max(chains.getOrDefault(word, 0), chains.get(pred) + 1));\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = chains.values().stream().mapToInt(Integer::intValue).max().orElse(0);\\n        return maxChainLength;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        std::unordered_map<std::string, int> chains;  // Stores the max chain length for each word\\n        std::vector<std::string> sortedWords = words;\\n        std::sort(sortedWords.begin(), sortedWords.end(), [](const std::string& a, const std::string& b) {\\n            return a.length() < b.length();  // Sort words by length\\n        });\\n\\n        for (const std::string& word : sortedWords) {\\n            chains[word] = 1;  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                std::string pred = word.substr(0, i) + word.substr(i + 1);  // Generate predecessor by removing one character\\n                if (chains.find(pred) != chains.end()) {\\n                    chains[word] = std::max(chains[word], chains[pred] + 1);\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = 0;\\n        for (const auto& entry : chains) {\\n            maxChainLength = std::max(maxChainLength, entry.second);\\n        }\\n\\n        return maxChainLength;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\nThank you for reading such a long post. Please upvote it and don\\'t forget to subscribe to my channel!\\n\\nMy next post for daily coding challenge on Sep 24th, 2023\\nhttps://leetcode.com/problems/champagne-tower/solutions/4082622/video-how-we-think-about-a-solution-dp-solution-with-1d-and-2d-python-javascript-java-and-c/\\n\\nHave a nice day!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\n```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2}\\n```\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2, \\'abc\\': 1}\\n```\n```\\nhash[wordB] = max(hash[wordB], hash[\"bc\"] + 1)\\n```\n```\\nNow, hash[wordB] = 2\\n\\nhash[wordB] = max(hash[wordB], hash[\"ab\"] + 1)\\n\\u2193\\nhash[wordB] = max(2, 2 + 1)\\n\\u2193\\nhash[wordB] = 3\\n```\n```python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        chains = {}  # Stores the max chain length for each word\\n        sorted_words = sorted(words, key=len) # Sort words by length\\n\\n        for word in sorted_words:\\n            chains[word] = 1  # Initialize the chain length for the current word\\n            \\n            for i in range(len(word)):\\n                # word = abc, i = 0, word[:i] = \"\" + word[i+1:] = \"bc\" = \"bc\"\\n                # word = abc, i = 1, word[:i] = \"a\" + word[i+1:] = \"c\" = \"ac\"\\n                # word = abc, i = 2, word[:i] = \"ab\" + word[i+1:] = \"\" = \"ab\"\\n                pred = word[:i] + word[i+1:]  # Generate predecessor by removing one character\\n                if pred in chains:\\n                    chains[word] = max(chains[word], chains[pred] + 1)\\n\\n        return max(chains.values())\\n```\n```javascript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    const chains = new Map();  // Stores the max chain length for each word\\n    const sortedWords = words.slice().sort((a, b) => a.length - b.length);  // Sort words by length\\n\\n    for (const word of sortedWords) {\\n        chains.set(word, 1);  // Initialize the chain length for the current word\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const pred = word.slice(0, i) + word.slice(i + 1);  // Generate predecessor by removing one character\\n            if (chains.has(pred)) {\\n                chains.set(word, Math.max(chains.get(word) || 0, chains.get(pred) + 1));\\n            }\\n        }\\n    }\\n\\n    return Math.max(...Array.from(chains.values()));  // Return the maximum chain length    \\n};\\n```\n```java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> chains = new HashMap<>();  // Stores the max chain length for each word\\n        String[] sortedWords = Arrays.copyOf(words, words.length);\\n        Arrays.sort(sortedWords, (a, b) -> a.length() - b.length());  // Sort words by length\\n\\n        for (String word : sortedWords) {\\n            chains.put(word, 1);  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                String pred = word.substring(0, i) + word.substring(i + 1);  // Generate predecessor by removing one character\\n                if (chains.containsKey(pred)) {\\n                    chains.put(word, Math.max(chains.getOrDefault(word, 0), chains.get(pred) + 1));\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = chains.values().stream().mapToInt(Integer::intValue).max().orElse(0);\\n        return maxChainLength;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        std::unordered_map<std::string, int> chains;  // Stores the max chain length for each word\\n        std::vector<std::string> sortedWords = words;\\n        std::sort(sortedWords.begin(), sortedWords.end(), [](const std::string& a, const std::string& b) {\\n            return a.length() < b.length();  // Sort words by length\\n        });\\n\\n        for (const std::string& word : sortedWords) {\\n            chains[word] = 1;  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                std::string pred = word.substr(0, i) + word.substr(i + 1);  // Generate predecessor by removing one character\\n                if (chains.find(pred) != chains.end()) {\\n                    chains[word] = std::max(chains[word], chains[pred] + 1);\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = 0;\\n        for (const auto& entry : chains) {\\n            maxChainLength = std::max(maxChainLength, entry.second);\\n        }\\n\\n        return maxChainLength;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079040,
                "title": "97-50-dp-recursive-iterative-commented-code",
                "content": "# Problem Description\\nGiven an **array** of words, each composed of **lowercase** English letters.\\n\\nA word `wordA` is considered a **predecessor** of another word `wordB` if and only if we can **insert** exactly **one** letter anywhere in `wordA`, **without changing** the **order** of the other characters, to make it equal to `wordB`.\\n\\nFor instance, `abc` is a **predecessor** of `abac` since we can insert `a` after the `b` in `abc` to get `abac`. However, `cba` is **not** a **predecessor** of `bcad` as **rearrangement** is needed.\\n\\nA word **chain** is defined as a **sequence** of words `[word1, word2, ..., wordk]` where `k` is **greater** than or **equal** to `1`, and each word in the sequence is a **predecessor** of the next word.\\n\\nThe task is to **determine** the length of the **longest** possible word chain that can be formed using words chosen from the given list of words.\\n\\n---\\n\\n# Dynamic Programming\\n![leet_dp.jpg](https://assets.leetcode.com/users/images/91848a67-bd6d-4faf-8027-b74bf5f068e4_1694307086.8311543.jpeg)\\n\\n\\n**Dynamic Programming** is a powerful technique that involves **caching** pre-computed results, thereby **eliminating** the need for redundant computations and significantly **optimizing** time complexity.\\nThere are **two primary approaches** to Dynamic Programming:\\n\\n## Recursive Approach (Top-Down)\\nWe can think of Recursive Approach as **breaking** hard bricks into **small** rocks. but, how this apply to our problem ?\\nWe can **break** our **complex problem** into **easier** ones. for each word search for all of its possible predecessors. If one exist, then seach also for its all possible predecessors until we reach a base case. \\n\\n## Iterative Approach (Bottom-Up)\\nWe can think of Iterative Approach as **building** high building from small bricks. but, how this also apply to our problem ?\\nWe can **solve** our **complex problem** by solving **easier** ones first and build until we reach our complex problem. We can start by words of length `1` and search for their predecessors and then words of length `2` then `3` so on.\\n\\n---\\n# Intuition\\nHello There\\uD83D\\uDE00\\nLet\\'s take a look on our today\\'s interesting problem\\uD83D\\uDE80\\n\\n- In our today\\'s problem we have **two** important requirements:\\n    - A chain if consist of **multiple** words each one is a predecessor for the one before it.\\n    - We want to find the **longest** chain.\\n\\n- If we sat a little and thought about this problem we can conclude some points.\\uD83D\\uDE33\\n    - For each word, we want to try each **possible** **predecessor** of it.\\n    - See if the predecessor **exists** in our words list then try also each predecessor of it and so on.\\n\\nLet\\'s see an example:\\uD83D\\uDE80\\nWith words list = `[\"a\", \"d\", \"b\",\"aa\", \"ab\", \"da\", \"aba\", \"ada\"]`\\nLet\\'s see what can we do for word `ada`\\n![image.png](https://assets.leetcode.com/users/images/0f7e07cc-b946-4870-9a47-55545925da0c_1695450256.1034126.png)\\nwe can see that `2` out of `3` predecessor exist in our words list which are `da` and `aa` so we will continue our chain to look for furthur predecessor. and we can see that the longest chain if we make `ada` is the last word in it is `3`.\\uD83E\\uDD2F\\n\\nNow, let\\'s see what can we do for word `aba`\\n![image.png](https://assets.leetcode.com/users/images/fc9b41d3-2bcf-4d5c-89c8-5e920595143c_1695450481.2220874.png)\\nwe can see that `2` out of `3` predecessor exist in our words list which are `ab` and `aa` so we will continue our chain to look for furthur predecessor. and we can see that the longest chain if we make `aba` is the last word in it is `3`.\\uD83E\\uDD2F\\n\\nInteresting, I think we are catching something.\\uD83E\\uDD29\\nYes, Our approach is the right one but we will have to **repeat** many steps like we saw in the two examples each of them need to calculate the largest chain for word `aa`.\\uD83D\\uDE14\\n\\nHere comes the **hero** of the day **Dynamic Programming**.\\uD83D\\uDC31\\u200D\\uD83C\\uDFCD\\uD83D\\uDC31\\u200D\\uD83C\\uDFCD\\nWhat will we do is once we calculated the largest chain for any string we will **cache** it in a `hashmap` for that string so we don\\'t have to recalculate it again.\\n\\nThis will **reduce** the time needed to solve our problem. and the two approached of Dynamic Programming are the same the main difference that one is starting from the larger word and search for all of its predecessors (Top-Down) and the other builds our `hashmap` from the shorter words (Bottom-Up).\\n\\nAnd this is the solution for our today problem I hope that you understood it\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n---\\n\\n\\n# Proposed Solutions\\n## 1. Recursive Approach (Top-Down)\\n### Approach\\n1. Create two empty dictionaries: `chain_lengths` to store chain lengths (DP) and `word_set` to track word existence.\\n2. Calculate Chain Length:\\n    - If the word is **not** in `word_set`, return `0` (word doesn\\'t exist in the set).\\n    - If the chain length for the word is already **calculated**, return the stored chain length (DP).\\n    - **Iterate** through each character in the word:\\n        - Create a new word by **removing** the current character.\\n        - Recur and calculate chain length for the **new** word.\\n        - Update chain_length.\\n    - Return the final chain_length.\\n3. Longest Word Chain:\\n    - Add the word to the `word_set` and mark it as existing.\\n    - Initialize `max_chain_length` to `-1` (no chain found yet).\\n    - Iterate through each word in the input list:\\n        - **Calculate** the chain length for the current word.\\n        - Update `max_chain_length`.\\n    - Return the final `max_chain_length`.\\n\\n### Complexity\\n- **Time complexity:** $$O(N * M)$$\\nSince we are iterating over all the `N` words and in each word we try all possible predecessor by removing one character a time then the time complexity is `O(N * M)`.\\nWhere `N` is the **number** of words in our array and `M` is the **length** of the word.\\nremember that we eleminated redundant calls by using `DP`.\\n- **Space complexity:** $$O(N)$$\\nWe store two `HashMaps` each of size `N` then the space we are storing is `2 * N` then the space complexity it `O(N)`.\\n\\n---\\n\\n\\n## 2. Iterative Approach (Bottom-Up)\\n### Approach\\n1. **Sort** the words in the input vector based on their **lengths** in ascending order.\\n2. Initialize a map called `longestChainLength` to store the **longest** chain length for each word.\\n3. Initialize a variable `maxChainLength` to -1 to (no chain found yet).\\n4. Iterate through **each word** in the sorted list of words:\\n    - Initialize the **chain length** for the current word as `1` (The word itself).\\n6. remove **one character** at a time and check if the resulting word exists.\\n7. If the resulted word **exists** in the map:\\n    - **Update** the chain length.\\n    - **Update** the maximum chain length seen so far.\\n8. **Return** Maximum Chain Length.\\n\\n### Complexity\\n- **Time complexity:** $$O(N * (log(N) + M))$$\\nSince we are sorting the array of words then iterating over all the `N` words and in each word we try all possible predecessor by removing one character a time then the time complexity is `O(N * log(N) + N * M)`.\\nWhere `N` is the **number** of words in our array and `M` is the **length** of the word.\\nremember that we eleminated redundant calls by using `DP`;`\\n- **Space complexity:** $$O(N)$$\\nWe store one `HashMaps` of size `N` then the space we are storing is `N` then the space complexity it `O(N)`.\\n\\n---\\n\\n\\n# Code\\n## 1. Recursive Approach (Top-Down)\\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> chain_lengths;\\n    unordered_map<string, bool> word_set;\\n\\n    int calculateChainLength(const string &word) {\\n        // If the word doesn\\'t exist in the set\\n        if (word_set.find(word) == word_set.end())\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chain_lengths.find(word) != chain_lengths.end())\\n            return chain_lengths[word];\\n\\n        int chain_length = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.size(); i++) {\\n            string new_word = word.substr(0, i) + word.substr(i + 1);\\n            chain_length = max(chain_length, 1 + calculateChainLength(new_word));\\n        }\\n\\n        chain_lengths[word] = chain_length;\\n        return chain_length;\\n    }\\n\\npublic:\\n    int longestStrChain(vector<string> &words) {\\n        for (const auto &word : words) {\\n            word_set[word] = true;\\n        }\\n\\n        int max_chain_length = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (const auto &word : words) {\\n            max_chain_length = max(max_chain_length, calculateChainLength(word));\\n        }\\n\\n        return max_chain_length;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Map<String, Integer> chainLengths = new HashMap<>();\\n    private Map<String, Boolean> wordSet = new HashMap<>();\\n\\n    private int calculateChainLength(String word) {\\n        // If the word doesn\\'t exist in the set\\n        if (!wordSet.containsKey(word) || !wordSet.get(word))\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chainLengths.containsKey(word))\\n            return chainLengths.get(word);\\n\\n        int chainLength = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.length(); i++) {\\n            String newWord = word.substring(0, i) + word.substring(i + 1);\\n            chainLength = Math.max(chainLength, 1 + calculateChainLength(newWord));\\n        }\\n\\n        chainLengths.put(word, chainLength);\\n        return chainLength;\\n    }\\n\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            wordSet.put(word, true);\\n        }\\n\\n        int maxChainLength = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (String word : words) {\\n            maxChainLength = Math.max(maxChainLength, calculateChainLength(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.chain_lengths = {}\\n        self.word_set = {}\\n\\n    def calculate_chain_length(self, word) -> int:\\n        # If the word doesn\\'t exist in the set\\n        if word not in self.word_set or not self.word_set[word]:\\n            return 0\\n\\n        # If chain length for the word is already calculated\\n        if word in self.chain_lengths:\\n            return self.chain_lengths[word]\\n\\n        chain_length = 1\\n\\n        # Try removing one character at a time from the word and calculate chain length\\n        for i in range(len(word)):\\n            new_word = word[:i] + word[i + 1:]\\n            chain_length = max(chain_length, 1 + self.calculate_chain_length(new_word))\\n\\n        self.chain_lengths[word] = chain_length\\n        return chain_length\\n\\n    def longestStrChain(self, words) -> int:\\n        for word in words:\\n            self.word_set[word] = True\\n\\n        max_chain_length = -1\\n\\n        # Calculate the maximum chain length for each word\\n        for word in words:\\n            max_chain_length = max(max_chain_length, self.calculate_chain_length(word))\\n\\n        return max_chain_length\\n```\\n\\n## 2. Iterative Approach (Bottom-Up) \\n```C++ []\\nclass Solution {\\npublic:\\n\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their lengths\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.length() < b.length();\\n        });\\n\\n        // Map to store the longest chain length for each word\\n        unordered_map<string, int> longestChainLength;\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for(auto &word: words){\\n            // Initialize the chain length for the current word\\n            longestChainLength[word] = 1;\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for(int i = 0 ; i < word.size() ; i++){\\n                string reducedWord = word.substr(0, i) + word.substr(i + 1) ;\\n\\n                // If the reduced word exists in the map\\n                if(longestChainLength.find(reducedWord) != longestChainLength.end())\\n                    // Update the chain length for the current word\\n                    longestChainLength[word] = max(longestChainLength[word], longestChainLength[reducedWord] + 1) ;\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = max(maxChainLength, longestChainLength[word]) ;\\n        }\\n\\n        return maxChainLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Sort the words by their lengths\\n        Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));\\n\\n        // Map to store the longest chain length for each word\\n        Map<String, Integer> longestChainLength = new HashMap<>();\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for (String word : words) {\\n            // Initialize the chain length for the current word\\n            longestChainLength.put(word, 1);\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for (int i = 0; i < word.length(); i++) {\\n                String reducedWord = word.substring(0, i) + word.substring(i + 1);\\n\\n                // If the reduced word exists in the map\\n                if (longestChainLength.containsKey(reducedWord))\\n                    // Update the chain length for the current word\\n                    longestChainLength.put(word, Math.max(longestChainLength.get(word), longestChainLength.get(reducedWord) + 1));\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = Math.max(maxChainLength, longestChainLength.get(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestStrChain(self, words) -> int:\\n        # Sort the words by their lengths\\n        words.sort(key=len)\\n\\n        # Dictionary to store the longest chain length for each word\\n        longest_chain_length = {}\\n\\n        # Initialize the answer\\n        max_chain_length = -1\\n\\n        for word in words:\\n            # Initialize the chain length for the current word\\n            longest_chain_length[word] = 1\\n\\n            # Try removing one character at a time from the word and check if the resulting word exists\\n            for i in range(len(word)):\\n                reduced_word = word[:i] + word[i + 1:]\\n\\n                # If the reduced word exists in the dictionary\\n                if reduced_word in longest_chain_length:\\n                    # Update the chain length for the current word\\n                    longest_chain_length[word] = max(longest_chain_length[word], longest_chain_length[reduced_word] + 1)\\n\\n            # Update the maximum chain length seen so far\\n            max_chain_length = max(max_chain_length, longest_chain_length[word])\\n\\n        return max_chain_length\\n```\\n\\n\\n---\\n\\n\\n\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/5f6aee89-454b-47ff-93c9-7030eb5d3673_1694227000.9068315.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> chain_lengths;\\n    unordered_map<string, bool> word_set;\\n\\n    int calculateChainLength(const string &word) {\\n        // If the word doesn\\'t exist in the set\\n        if (word_set.find(word) == word_set.end())\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chain_lengths.find(word) != chain_lengths.end())\\n            return chain_lengths[word];\\n\\n        int chain_length = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.size(); i++) {\\n            string new_word = word.substr(0, i) + word.substr(i + 1);\\n            chain_length = max(chain_length, 1 + calculateChainLength(new_word));\\n        }\\n\\n        chain_lengths[word] = chain_length;\\n        return chain_length;\\n    }\\n\\npublic:\\n    int longestStrChain(vector<string> &words) {\\n        for (const auto &word : words) {\\n            word_set[word] = true;\\n        }\\n\\n        int max_chain_length = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (const auto &word : words) {\\n            max_chain_length = max(max_chain_length, calculateChainLength(word));\\n        }\\n\\n        return max_chain_length;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Map<String, Integer> chainLengths = new HashMap<>();\\n    private Map<String, Boolean> wordSet = new HashMap<>();\\n\\n    private int calculateChainLength(String word) {\\n        // If the word doesn\\'t exist in the set\\n        if (!wordSet.containsKey(word) || !wordSet.get(word))\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chainLengths.containsKey(word))\\n            return chainLengths.get(word);\\n\\n        int chainLength = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.length(); i++) {\\n            String newWord = word.substring(0, i) + word.substring(i + 1);\\n            chainLength = Math.max(chainLength, 1 + calculateChainLength(newWord));\\n        }\\n\\n        chainLengths.put(word, chainLength);\\n        return chainLength;\\n    }\\n\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            wordSet.put(word, true);\\n        }\\n\\n        int maxChainLength = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (String word : words) {\\n            maxChainLength = Math.max(maxChainLength, calculateChainLength(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.chain_lengths = {}\\n        self.word_set = {}\\n\\n    def calculate_chain_length(self, word) -> int:\\n        # If the word doesn\\'t exist in the set\\n        if word not in self.word_set or not self.word_set[word]:\\n            return 0\\n\\n        # If chain length for the word is already calculated\\n        if word in self.chain_lengths:\\n            return self.chain_lengths[word]\\n\\n        chain_length = 1\\n\\n        # Try removing one character at a time from the word and calculate chain length\\n        for i in range(len(word)):\\n            new_word = word[:i] + word[i + 1:]\\n            chain_length = max(chain_length, 1 + self.calculate_chain_length(new_word))\\n\\n        self.chain_lengths[word] = chain_length\\n        return chain_length\\n\\n    def longestStrChain(self, words) -> int:\\n        for word in words:\\n            self.word_set[word] = True\\n\\n        max_chain_length = -1\\n\\n        # Calculate the maximum chain length for each word\\n        for word in words:\\n            max_chain_length = max(max_chain_length, self.calculate_chain_length(word))\\n\\n        return max_chain_length\\n```\n```C++ []\\nclass Solution {\\npublic:\\n\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their lengths\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.length() < b.length();\\n        });\\n\\n        // Map to store the longest chain length for each word\\n        unordered_map<string, int> longestChainLength;\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for(auto &word: words){\\n            // Initialize the chain length for the current word\\n            longestChainLength[word] = 1;\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for(int i = 0 ; i < word.size() ; i++){\\n                string reducedWord = word.substr(0, i) + word.substr(i + 1) ;\\n\\n                // If the reduced word exists in the map\\n                if(longestChainLength.find(reducedWord) != longestChainLength.end())\\n                    // Update the chain length for the current word\\n                    longestChainLength[word] = max(longestChainLength[word], longestChainLength[reducedWord] + 1) ;\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = max(maxChainLength, longestChainLength[word]) ;\\n        }\\n\\n        return maxChainLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Sort the words by their lengths\\n        Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));\\n\\n        // Map to store the longest chain length for each word\\n        Map<String, Integer> longestChainLength = new HashMap<>();\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for (String word : words) {\\n            // Initialize the chain length for the current word\\n            longestChainLength.put(word, 1);\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for (int i = 0; i < word.length(); i++) {\\n                String reducedWord = word.substring(0, i) + word.substring(i + 1);\\n\\n                // If the reduced word exists in the map\\n                if (longestChainLength.containsKey(reducedWord))\\n                    // Update the chain length for the current word\\n                    longestChainLength.put(word, Math.max(longestChainLength.get(word), longestChainLength.get(reducedWord) + 1));\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = Math.max(maxChainLength, longestChainLength.get(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestStrChain(self, words) -> int:\\n        # Sort the words by their lengths\\n        words.sort(key=len)\\n\\n        # Dictionary to store the longest chain length for each word\\n        longest_chain_length = {}\\n\\n        # Initialize the answer\\n        max_chain_length = -1\\n\\n        for word in words:\\n            # Initialize the chain length for the current word\\n            longest_chain_length[word] = 1\\n\\n            # Try removing one character at a time from the word and check if the resulting word exists\\n            for i in range(len(word)):\\n                reduced_word = word[:i] + word[i + 1:]\\n\\n                # If the reduced word exists in the dictionary\\n                if reduced_word in longest_chain_length:\\n                    # Update the chain length for the current word\\n                    longest_chain_length[word] = max(longest_chain_length[word], longest_chain_length[reduced_word] + 1)\\n\\n            # Update the maximum chain length seen so far\\n            max_chain_length = max(max_chain_length, longest_chain_length[word])\\n\\n        return max_chain_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213767,
                "title": "python-short-dp-explained",
                "content": "The idea in this problem is to start from the longest word and find an answer for this word using the answers for smaller words. For example if we have word `apple`, then we need to check if we have words `pple, aple, appe, appl` in our list of words. To make it work fast we need to put all words into set: `set_words = set(words)`. Then all we need to do is to check all words with one letter removed.\\n\\n#### Complexity\\nTime complexity is `O(n*L*L)`, where `n` is number of words and `L` is the biggest length of the word: for word of length `L` we need to check `L-1` candidates, all of them with length `L-1`. Space complexity is `L(n*L*L)`, because we actually keep a lot of neighbors of our words in lru cache.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        set_words = set(words)\\n        \\n        @lru_cache(None)\\n        def dp(word):\\n            if word not in set_words: return 0\\n            return max(dp(word[:i] + word[i+1:]) for i in range(len(word))) + 1\\n           \\n        return max(dp(word) for word in words)\\n```\\n\\n#### Update\\nThere is update from @rkmd with `O(n*L)` space complexity\\n\\n```python\\ndef dp(word):\\n    return max((dp(test) for i in range(len(word)) if (test := word[:i] + word[i+1:]) in set_words), default=0) + 1\\n```\\n\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        set_words = set(words)\\n        \\n        @lru_cache(None)\\n        def dp(word):\\n            if word not in set_words: return 0\\n            return max(dp(word[:i] + word[i+1:]) for i in range(len(word))) + 1\\n           \\n        return max(dp(word) for word in words)\\n```\n```python\\ndef dp(word):\\n    return max((dp(test) for i in range(len(word)) if (test := word[:i] + word[i+1:]) in set_words), default=0) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756217,
                "title": "lcs-lis-sorting-easiest-to-understand-among-all-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int lcs( string X,string Y)  \\n{  \\n    int m = X.length();\\n    int n = Y.length();  \\n    int L[m + 1][n + 1];  \\n    int i, j;  \\n    for (i = 0; i <= m; i++)  \\n    {  \\n        for (j = 0; j <= n; j++)  \\n        {  \\n        if (i == 0 || j == 0)  \\n            L[i][j] = 0;  \\n      \\n        else if (X[i - 1] == Y[j - 1])  \\n            L[i][j] = L[i - 1][j - 1] + 1;  \\n      \\n        else\\n            L[i][j] = max(L[i - 1][j], L[i][j - 1]);  \\n        }  \\n    }  \\n    return L[m][n];  \\n}  \\n    \\n     static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> dp(n,1);\\n        sort(words.begin(),words.end(),compare);\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(words[i].length()-words[j].length()==1 && lcs(words[i],words[j])==words[j].length() && dp[i]<dp[j]+1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs( string X,string Y)  \\n{  \\n    int m = X.length();\\n    int n = Y.length();  \\n    int L[m + 1][n + 1];  \\n    int i, j;  \\n    for (i = 0; i <= m; i++)  \\n    {  \\n        for (j = 0; j <= n; j++)  \\n        {  \\n        if (i == 0 || j == 0)  \\n            L[i][j] = 0;  \\n      \\n        else if (X[i - 1] == Y[j - 1])  \\n            L[i][j] = L[i - 1][j - 1] + 1;  \\n      \\n        else\\n            L[i][j] = max(L[i - 1][j], L[i][j - 1]);  \\n        }  \\n    }  \\n    return L[m][n];  \\n}  \\n    \\n     static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> dp(n,1);\\n        sort(words.begin(),words.end(),compare);\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(words[i].length()-words[j].length()==1 && lcs(words[i],words[j])==words[j].length() && dp[i]<dp[j]+1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152870,
                "title": "java-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nFIrstly ```sort``` the given array on basis of length of words. Such that for a word **i** we would be checking words having length smaller than **i**\\n\\nCreate a ```dictionary``` or ```mapping``` to store the chain length till that words.\\nWhen chain of bigger word is to be found , it will be -> ``` 1 + smaller_length_of_chain```.\\n\\nInitialize the chain length of each word to be ***1***.\\n\\nAs ```word.length <= 16```, it is easy to create all combinations by taking out one character.\\n\\nForm different words ```successor``` by deleting a letter and check if that word has a larger chain length.\\n\\nKeep updating and select maximum chain length from ```mapping``` / ```dictionary```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n\\t    if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n\\t\\n        int res = 0;\\n\\t\\n        Arrays.sort(words, (a,b)-> a.length()-b.length());\\n\\t    HashMap<String, Integer> map = new HashMap(); \\n\\t    \\n        for(String w : words) {                            \\n\\t\\t    map.put(w, 1);                                  \\n\\t\\t\\n            for(int i=0; i<w.length(); i++) {  \\n                \\n    \\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t    \\t\\tString next = sb.deleteCharAt(i).toString();\\n                \\n\\t\\t    \\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t    \\tmap.put(w, map.get(next)+1);       \\n        \\t\\t}\\n\\t\\t    res = Math.max(res, map.get(w));          \\n\\t    }\\n\\t    return res;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/28742883-9ee2-483c-9c37-fde403ac4580_1655252708.6167986.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sort```\n```dictionary```\n```mapping```\n``` 1 + smaller_length_of_chain```\n```word.length <= 16```\n```successor```\n```mapping```\n```dictionary```\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n\\t    if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n\\t\\n        int res = 0;\\n\\t\\n        Arrays.sort(words, (a,b)-> a.length()-b.length());\\n\\t    HashMap<String, Integer> map = new HashMap(); \\n\\t    \\n        for(String w : words) {                            \\n\\t\\t    map.put(w, 1);                                  \\n\\t\\t\\n            for(int i=0; i<w.length(); i++) {  \\n                \\n    \\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t    \\t\\tString next = sb.deleteCharAt(i).toString();\\n                \\n\\t\\t    \\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t    \\tmap.put(w, map.get(next)+1);       \\n        \\t\\t}\\n\\t\\t    res = Math.max(res, map.get(w));          \\n\\t    }\\n\\t    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154190,
                "title": "graph-topological-sort",
                "content": "* We can consider each string in array to be a node. \\n* And create a directed edge to its successor. \\n* This will create a **DAG** (directed acylic graph) and from this we need to find the node with most number of predecessors \\n* This is prefect for topological sort. (Finding a node with most number of prerequisites) \\n\\n\\n\\n\\nExample 1 from question --> <img src=\"https://assets.leetcode.com/users/images/237d4480-9bce-44a5-80e1-773230d859dc_1655281779.3950415.jpeg\" alt=\"drawing\" width=\"200\"/>\\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<HashSet<String>> mapOfWords = new ArrayList<>();\\n        Map<String,Integer> inDegree = new HashMap<>();\\n        for(int i=0;i<=16;i++) mapOfWords.add(new HashSet<>());\\n        for(String word: words){\\n            mapOfWords.get(word.length()).add(word);\\n            inDegree.put(word,0);\\n        }\\n        Map<String,List<String>> graph = new HashMap<>();\\n        for(int i=1;i<16;i++) {\\n            HashSet<String> setOfNextWords = mapOfWords.get(i+1);\\n            for(String word: mapOfWords.get(i)){\\n                graph.put(word,new ArrayList<>());\\n                for(String nextWord: setOfNextWords){\\n                    if(isPredecessor(word,nextWord)) {\\n                        List<String> list = graph.get(word);\\n                        list.add(nextWord);\\n                        graph.put(word,list);\\n                        inDegree.put(nextWord,inDegree.get(nextWord)+1);\\n                    }\\n                }\\n            }\\n        }\\n        for(String longestWord: mapOfWords.get(16)) graph.put(longestWord,new ArrayList<>());\\n        Queue<String> queue = new ArrayDeque<>();\\n        for(String string: inDegree.keySet()){\\n            if(inDegree.get(string)==0) queue.offer(string);\\n        }\\n        int depth = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int s=0;s<size;s++){\\n                String cur = queue.remove();\\n                List<String> successorList = graph.get(cur);\\n                for(String successor: successorList){\\n                    inDegree.put(successor,inDegree.get(successor)-1);\\n                    if(inDegree.get(successor) == 0) queue.offer(successor);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth-1;\\n    }\\n    private boolean isPredecessor(String pre, String target){\\n        for(int i=0;i<target.length();i++) if((target.substring(0,i)+target.substring(i+1)).equals(pre)) return true;\\n        return false;\\n    }\\n\\n}\\n\\n```\\nMaking nodes from string is not that fast as compared to integers. As instead of array we have to use maps.. \\nBut still this solution is giving around 400ms as input size is not that big\\n\\nIf you like this approach than please upvote",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<HashSet<String>> mapOfWords = new ArrayList<>();\\n        Map<String,Integer> inDegree = new HashMap<>();\\n        for(int i=0;i<=16;i++) mapOfWords.add(new HashSet<>());\\n        for(String word: words){\\n            mapOfWords.get(word.length()).add(word);\\n            inDegree.put(word,0);\\n        }\\n        Map<String,List<String>> graph = new HashMap<>();\\n        for(int i=1;i<16;i++) {\\n            HashSet<String> setOfNextWords = mapOfWords.get(i+1);\\n            for(String word: mapOfWords.get(i)){\\n                graph.put(word,new ArrayList<>());\\n                for(String nextWord: setOfNextWords){\\n                    if(isPredecessor(word,nextWord)) {\\n                        List<String> list = graph.get(word);\\n                        list.add(nextWord);\\n                        graph.put(word,list);\\n                        inDegree.put(nextWord,inDegree.get(nextWord)+1);\\n                    }\\n                }\\n            }\\n        }\\n        for(String longestWord: mapOfWords.get(16)) graph.put(longestWord,new ArrayList<>());\\n        Queue<String> queue = new ArrayDeque<>();\\n        for(String string: inDegree.keySet()){\\n            if(inDegree.get(string)==0) queue.offer(string);\\n        }\\n        int depth = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int s=0;s<size;s++){\\n                String cur = queue.remove();\\n                List<String> successorList = graph.get(cur);\\n                for(String successor: successorList){\\n                    inDegree.put(successor,inDegree.get(successor)-1);\\n                    if(inDegree.get(successor) == 0) queue.offer(successor);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth-1;\\n    }\\n    private boolean isPredecessor(String pre, String target){\\n        for(int i=0;i<target.length();i++) if((target.substring(0,i)+target.substring(i+1)).equals(pre)) return true;\\n        return false;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154053,
                "title": "c-use-sorting-dp-efficient-solution-with-explanation-dlc-june-day-15",
                "content": "**Approach:** Use hashmap for storing string and length of word chain. Let\\'s take Example-1 and understand it more clearly.\\n\\n**Example-1:**\\n\\n\\twords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\t\\n\\tBefore any step we need to sort vector \\'words\\' on the basis of the size of a string.\\n\\tNow we cover we word in the vector one-by-one.\\n\\n\\t1) word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n\\t2) word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n\\t3) word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\n\\tHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n\\t4) word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n\\t5) word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n\\t6) word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4 which is the answer.\\n\\t\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        unordered_map<string, int> dp; //it stores predecessor word and chain size\\n        \\n        //sort(words.begin(), words.end(), [](const string &s1, const string &s2){ return s1.length()<s2.length();});\\n        sort(words.begin(), words.end(), compare);\\n        \\n        int len = 1; \\n        for(auto word:words) \\n        {\\n            dp[word]=1; \\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = max(dp[word], dp[pred]+1); \\n                    len = max(len, dp[word]);\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```\\n\\n**Time Complexity:** O(Nlog(N) + NMM)\\nO(Nlog(N)) for sorting\\nO(NMM): N for 1st loop, M for inner loop and M for string concatenation.\\n\\n**Space Complexity:** O(N) for both storing strings in hashmap.\\n\\n**Please upvote if it helps \\uD83D\\uDE0A\\u2764\\uFE0F**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        unordered_map<string, int> dp; //it stores predecessor word and chain size\\n        \\n        //sort(words.begin(), words.end(), [](const string &s1, const string &s2){ return s1.length()<s2.length();});\\n        sort(words.begin(), words.end(), compare);\\n        \\n        int len = 1; \\n        for(auto word:words) \\n        {\\n            dp[word]=1; \\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = max(dp[word], dp[pred]+1); \\n                    len = max(len, dp[word]);\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153914,
                "title": "c-sort-dp-daily-leetcoding-challenge-june-day-15",
                "content": "* Sort vector in increasing order of string lengths.\\n* At each index `i`, find maximum possible predecessor chain for `words[i]`. This can be done by forming all possible predecessors for `words[i]`.\\n* Predecessors for `words[i]` can be found by deleting character at each index of the string.\\n* If a predecessor exists, find the length of longest string chain which end at index `i`.\\n* **TC :O(NlogN + N*M^2) | SC : O(N)**\\n\\n```\\nclass Solution {\\n    static bool compare(string &s1, string &s2){\\n        return s1.length() < s2.length();\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n        int ans = 1;\\n        int n = words.size();\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            dp[words[i]] = 1;\\n            int maxPosSubChain = 0;\\n            for(int j = 0 ; j < words[i].length(); j++){\\n                string predecessor  = words[i].substr(0, j) + words[i].substr(j+1);\\n                if(dp.find(predecessor)!=dp.end()){\\n                    maxPosSubChain = max(maxPosSubChain, dp[predecessor]);\\n                }\\n            }\\n            dp[words[i]] += maxPosSubChain;\\n            ans = max(ans, dp[words[i]]);\\n        }        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool compare(string &s1, string &s2){\\n        return s1.length() < s2.length();\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n        int ans = 1;\\n        int n = words.size();\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            dp[words[i]] = 1;\\n            int maxPosSubChain = 0;\\n            for(int j = 0 ; j < words[i].length(); j++){\\n                string predecessor  = words[i].substr(0, j) + words[i].substr(j+1);\\n                if(dp.find(predecessor)!=dp.end()){\\n                    maxPosSubChain = max(maxPosSubChain, dp[predecessor]);\\n                }\\n            }\\n            dp[words[i]] += maxPosSubChain;\\n            ans = max(ans, dp[words[i]]);\\n        }        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294919,
                "title": "c-brute-force-dfs",
                "content": "I thought I needed memoisation, but the solution below was accepted. We first group the words by length, and then run DFS.\\n```\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```\\nHere is the same solution with the memoisation added. The runtime went down from 120 ms to 48 ms.\\n\\n> Update: this is not actually a memoisation. We just track visited \"nodes\" (words) in a set.\\n\\n```\\nunordered_set<string> s;\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  if (!s.insert(pr).second) return 0;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```\\n**Complexity Analysis**\\nTime: O(n), where *n* is the number of words. We process each word only once, and then mark it as \"visited\".\\nMemory: O(n), to store words by groups.",
                "solutionTags": [],
                "code": "```\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```\n```\\nunordered_set<string> s;\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  if (!s.insert(pr).second) return 0;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213856,
                "title": "longest-string-chain-js-python-java-fast-set-dp-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nA naive approach would be to check every word against every other word looking for predecessors, but that would lead to a **TLE** result. The first important realization that we should be able to make is that while a **word** may have many **26 * (word.length + 1)** possible successors, it can only have **word.length** predecessors.\\n\\nSo rather than iterating from small to large words and checking every combination for a link, we can store the words in a **set** and only check the few possible predecessors while iterating from large to small. To aid in that, we can actually separate words into an array of sets (**W**) indexed by word length, so that we can directly access batches of words by their length.\\n\\n_(**Note**: As we iterate backward through **W**, if we find that **W[i-1]** is empty, we don\\'t need to process the words in **W[i]**, since there cannot possibly be a predecessor match.)_\\n\\nThen we can use a **dynamic programming** (**DP**) approach to eliminate some common subproblems. We can define a **hashmap** (**dp**) where **dp[word]** is the length of the longest chain ending at **word** found so far.\\n\\nSo at each **word**, we\\'ll iterate through each of its predecessors (**pred**) and check the appropriate set in **W** for a match. If we find a match, we can update **dp[pred]** if **dp[word] + 1** is better, increasing the chain by one. We should also separately keep track of the **best** chain length we\\'ve seen, so that once we reach the end, we can just **return best**.\\n\\n - _**Time Complexity: O(N*M)** where **N** is the length of **words** and **M** is the average length of the words in **words**._\\n - _**Space Complexity: O(N + P)** where **P** is the number of predecessors found and stored in **dp**._\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 45.8MB** (beats 100% / 75%).\\n```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **84ms / 14.5MB** (beats 100% / 90%).\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **20ms / 38.8MB** (beats 92% / 91%).\\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **52ms / 31.2MB** (beats 91% / 27%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213820,
                "title": "c-3-approaches-why-it-looks-like-lis-pattern-easy-comments-memoized-dp-best-solution",
                "content": "Just to let you know, this was asked by Google\\nBefore you see the solution below, you need to understand how one can come up with the idea that this question can be solved with the concept of LIS(Longest increasing subsequence) ?\\nLook for the keywords in the question. (comparison below)\\n```\\n\\t\\t(This qn)                                         (LIS)\\n-You have to find the longest chain            -Longest length of subsequence\\n-nums[prev] < nums[curr]                       -words[prev] is predecessor of words[curr]\\n\\nI think these two points are enough to give LIS a chance. That\\'s how it clicked me atleast.\\nIf you have any other explanation, please feel free to share. I am looking for multiple solutions/explanations to a question.\\n```\\n\\n```\\nBut, why I have sorted the input (in solutions below)?\\nBecause in LIS, we needed the longest subsequence.\\nBut here in this question, we need the longest chain no matter which word you put where (i.e. order doens\\'t matter).\\nSo, the best solution will come (longest) when you sort the input in ascending order of length. This will ensure you get the longest chain.\\n```\\n\\n```\\n//Approach-1 (Recusrion + Memoized)\\nclass Solution {\\npublic:\\n    int t[1001][1001];\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n\\t//This is nothing but \"Longest Increasing Subsequence\"\\n    int modifiedLIS(vector<string>& words, int prev, int curr) {\\n        if(curr ==  words.size())\\n            return 0;\\n        if(t[prev+1][curr] != -1)\\n            return t[prev+1][curr];\\n        int taken = 0;\\n\\t\\t/*\\n\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\tnums[prev] < nums[curr]. But here just condition is\\n\\t\\t\\tchanged as per the question\\n\\t\\t*/\\n\\t\\t\\n        if(prev < 0 || predecessor(words[prev], words[curr])) {\\n            taken = 1 + modifiedLIS(words, curr, curr+1);\\n        }\\n        \\n        int not_taken = modifiedLIS(words, prev, curr+1);\\n        \\n        return t[prev+1][curr] = max(taken, not_taken);\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        int n = words.size();\\n        int prev = -1;\\n        int curr = 0;\\n        memset(t, -1, sizeof(t));\\n        return modifiedLIS(words, prev, curr);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 - (DP version of above) [ Time : O(N^2 * L) ]\\nclass Solution {\\npublic:\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n    int modifiedLIS(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> t(n, 1);\\n        //t[i] = LIS ending at index i\\n        int result = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\t\\t\\tnums[j] < nums[i]. But here just condition is\\n\\t\\t\\t\\t\\tchanged as per the question\\n\\t\\t\\t\\t*/\\n                if(predecessor(words[j], words[i])) {\\n                    t[i] = max(t[i], 1 + t[j]);\\n                    result = max(result, t[i]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    static bool myFunction(string& s1, string& s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        \\n        return modifiedLIS(words);\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 Using HashMap [Time : O(NlogN+(N*L^2)) ]\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t//lambda function for sorting\\n        auto myFunction = [&](string& s1, string& s2) {\\n            return s1.length() < s2.length();\\n        };\\n        \\n        sort(begin(words), end(words), myFunction);  //O(N*logN)\\n        \\n        int maxChain = 0;\\n        for(string &word:words) { O(N)\\n            int chain_word = 1;\\n            \\n            for(int i = 0; i < (int) word.length(); i++) {  // O(L)\\n                /*\\n\\t\\t\\t\\t\\tFind all possible predecessors of word by removing one character\\n\\t\\t\\t\\t\\tI you see that we have that predecessor, then we add +1 to the \\n\\t\\t\\t\\t\\tpredecessor chain to reach to current word.\\n\\t\\t\\t\\t\\tSimilarly, for all possible predecessors, find the maximum chain to reach\\n\\t\\t\\t\\t\\tcurrent word.\\n\\t\\t\\t\\t*/\\n                string s = word.substr(0, i) + word.substr(i+1);  // O(L)\\n                auto it = mp.find(s);\\n            \\n                if(it != mp.end()) {\\n                    //find best predecessor\\n                    chain_word = max(chain_word, mp[s]+1);\\n                }\\n            }\\n            \\n            mp[word] = chain_word; //select the maximum chain for word\\n\\t\\t\\t//And at last find the maximum for all the words\\n            maxChain = max(maxChain, chain_word); //update the maximum chain obtained\\n        }\\n        \\n        return maxChain;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t(This qn)                                         (LIS)\\n-You have to find the longest chain            -Longest length of subsequence\\n-nums[prev] < nums[curr]                       -words[prev] is predecessor of words[curr]\\n\\nI think these two points are enough to give LIS a chance. That\\'s how it clicked me atleast.\\nIf you have any other explanation, please feel free to share. I am looking for multiple solutions/explanations to a question.\\n```\n```\\nBut, why I have sorted the input (in solutions below)?\\nBecause in LIS, we needed the longest subsequence.\\nBut here in this question, we need the longest chain no matter which word you put where (i.e. order doens\\'t matter).\\nSo, the best solution will come (longest) when you sort the input in ascending order of length. This will ensure you get the longest chain.\\n```\n```\\n//Approach-1 (Recusrion + Memoized)\\nclass Solution {\\npublic:\\n    int t[1001][1001];\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n\\t//This is nothing but \"Longest Increasing Subsequence\"\\n    int modifiedLIS(vector<string>& words, int prev, int curr) {\\n        if(curr ==  words.size())\\n            return 0;\\n        if(t[prev+1][curr] != -1)\\n            return t[prev+1][curr];\\n        int taken = 0;\\n\\t\\t/*\\n\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\tnums[prev] < nums[curr]. But here just condition is\\n\\t\\t\\tchanged as per the question\\n\\t\\t*/\\n\\t\\t\\n        if(prev < 0 || predecessor(words[prev], words[curr])) {\\n            taken = 1 + modifiedLIS(words, curr, curr+1);\\n        }\\n        \\n        int not_taken = modifiedLIS(words, prev, curr+1);\\n        \\n        return t[prev+1][curr] = max(taken, not_taken);\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        int n = words.size();\\n        int prev = -1;\\n        int curr = 0;\\n        memset(t, -1, sizeof(t));\\n        return modifiedLIS(words, prev, curr);\\n    }\\n};\\n```\n```\\n//Approach-2 - (DP version of above) [ Time : O(N^2 * L) ]\\nclass Solution {\\npublic:\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n    int modifiedLIS(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> t(n, 1);\\n        //t[i] = LIS ending at index i\\n        int result = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\t\\t\\tnums[j] < nums[i]. But here just condition is\\n\\t\\t\\t\\t\\tchanged as per the question\\n\\t\\t\\t\\t*/\\n                if(predecessor(words[j], words[i])) {\\n                    t[i] = max(t[i], 1 + t[j]);\\n                    result = max(result, t[i]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    static bool myFunction(string& s1, string& s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        \\n        return modifiedLIS(words);\\n    }\\n};\\n```\n```\\n//Approach-3 Using HashMap [Time : O(NlogN+(N*L^2)) ]\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t//lambda function for sorting\\n        auto myFunction = [&](string& s1, string& s2) {\\n            return s1.length() < s2.length();\\n        };\\n        \\n        sort(begin(words), end(words), myFunction);  //O(N*logN)\\n        \\n        int maxChain = 0;\\n        for(string &word:words) { O(N)\\n            int chain_word = 1;\\n            \\n            for(int i = 0; i < (int) word.length(); i++) {  // O(L)\\n                /*\\n\\t\\t\\t\\t\\tFind all possible predecessors of word by removing one character\\n\\t\\t\\t\\t\\tI you see that we have that predecessor, then we add +1 to the \\n\\t\\t\\t\\t\\tpredecessor chain to reach to current word.\\n\\t\\t\\t\\t\\tSimilarly, for all possible predecessors, find the maximum chain to reach\\n\\t\\t\\t\\t\\tcurrent word.\\n\\t\\t\\t\\t*/\\n                string s = word.substr(0, i) + word.substr(i+1);  // O(L)\\n                auto it = mp.find(s);\\n            \\n                if(it != mp.end()) {\\n                    //find best predecessor\\n                    chain_word = max(chain_word, mp[s]+1);\\n                }\\n            }\\n            \\n            mp[word] = chain_word; //select the maximum chain for word\\n\\t\\t\\t//And at last find the maximum for all the words\\n            maxChain = max(maxChain, chain_word); //update the maximum chain obtained\\n        }\\n        \\n        return maxChain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505507,
                "title": "javascript-dp-solution-javascript",
                "content": "FYI I\\'m writing this as a mental note for myself. I will come back later and refine the explanation. \\n\\n1. sort the words by length, shortst to longest, `array.sort((a,b) => a.length - b.length))`\\n2. For every word, we check if the predecesor that makes up this word exists. If no, we set the chain value for this word to 1, if yes, we\\'ll increase it by one. \\n\\nFor example, with the array of words `[\\'a\\', \\'b\\', \\'ba\\', \\'bca\\', \\'bda\\', \\'bdca\\']`, for the first word `a`, since it\\'s length is only 1, there is no predecor that can make this current word, hence we set in our memory `a:1`, same with b. \\n\\nNow when we get to `ba`, we remove `b` from `ba`, and we can imagine the word as no `_ a`, we ask ourselves, does `a` exist in memory? \\nyes it does, which means, we have a letter in memory that could complete the full word `ba` (It might look like we are trying to fill in the blank for the letter `b`, but we are actually saying, \\'okay, if we have the value b already, does `a` exist in memory?\\' \\n\\nsince it does, our chain value for `ba` is 2, because `a` --> `ba`\\n```\\nvar longestStrChain = function(words) {\\n   var memory = {}; \\n    words.sort((a,b) => a.length - b.length)\\n    for (var word of words){\\n        var longest = 0; \\n        for (var i =0; i<word.length; i++){\\n            var pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (memory[pre] || 0)+1)\\n        }\\n        memory[word] = longest\\n    }\\n    return Math.max(...Object.values(memory));\\n};\\n```\\n\\nSome of my own questions that occured to me while looking at other people\\'s solutions: \\n1. What\\'s the difference between `string.slice()` and `string.substring()` : https://stackoverflow.com/questions/2243824/what-is-the-difference-between-string-slice-and-string-substring",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar longestStrChain = function(words) {\\n   var memory = {}; \\n    words.sort((a,b) => a.length - b.length)\\n    for (var word of words){\\n        var longest = 0; \\n        for (var i =0; i<word.length; i++){\\n            var pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (memory[pre] || 0)+1)\\n        }\\n        memory[word] = longest\\n    }\\n    return Math.max(...Object.values(memory));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483103,
                "title": "python-8-lines-dfs-with-memoization",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(word):\\n            if word not in dp:\\n                return 0\\n            if not dp[word]:\\n                dp[word] = max([dfs(word[:i]+word[i+1:]) + 1 for i in range(len(word))])\\n            return dp[word]\\n\\t\\t\\t\\n        dp = {word: None for word in words}\\n        return max([dfs(word) for word in dp if not dp[word]])\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(word):\\n            if word not in dp:\\n                return 0\\n            if not dp[word]:\\n                dp[word] = max([dfs(word[:i]+word[i+1:]) + 1 for i in range(len(word))])\\n            return dp[word]\\n\\t\\t\\t\\n        dp = {word: None for word in words}\\n        return max([dfs(word) for word in dp if not dp[word]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442231,
                "title": "java-dfs-memo-solution",
                "content": "[updated with `fuxian` \\'s StringBuilder usage suggestion]\\n```\\nclass Solution {\\n    \\n    public int dfs(HashSet<String> words, HashMap<String, Integer> cache, String s) {\\n        \\n        if(cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i = 0; i<s.length(); i++) {\\n\\t\\t\\t// creating all possible strings with one character taken out\\n            sb.deleteCharAt(i);\\n            String ns = sb.toString();\\n            if(words.contains(ns)){\\n                max = Math.max(max, dfs(words, cache, ns));\\n            }\\n\\t\\t\\t// insertng it back for next iteration\\n            sb.insert(i, s.charAt(i));\\n        }\\n        cache.put(s, ++max);\\n        \\n        return max;\\n    }\\n    \\n    public int longestStrChain(String[] words) {\\n        HashMap<String, Integer> cache = new HashMap<>();\\n        \\n        HashSet<String> wordSet = new HashSet<>();\\n        for(String s: words) wordSet.add(s);\\n        \\n        int max = 0; \\n        for(String w: words) {\\n            max = Math.max(max, dfs(wordSet, cache, w));\\n            //System.out.println(w+ \" - \"+max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int dfs(HashSet<String> words, HashMap<String, Integer> cache, String s) {\\n        \\n        if(cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i = 0; i<s.length(); i++) {\\n\\t\\t\\t// creating all possible strings with one character taken out\\n            sb.deleteCharAt(i);\\n            String ns = sb.toString();\\n            if(words.contains(ns)){\\n                max = Math.max(max, dfs(words, cache, ns));\\n            }\\n\\t\\t\\t// insertng it back for next iteration\\n            sb.insert(i, s.charAt(i));\\n        }\\n        cache.put(s, ++max);\\n        \\n        return max;\\n    }\\n    \\n    public int longestStrChain(String[] words) {\\n        HashMap<String, Integer> cache = new HashMap<>();\\n        \\n        HashSet<String> wordSet = new HashSet<>();\\n        for(String s: words) wordSet.add(s);\\n        \\n        int max = 0; \\n        for(String w: words) {\\n            max = Math.max(max, dfs(wordSet, cache, w));\\n            //System.out.println(w+ \" - \"+max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153013,
                "title": "c-dp-solution-full-explanation-step-by-step",
                "content": "***Upvote if helpful***\\n\\nTime Complexity : O(n*n), Space Complexity : O(n)\\n\\n1. At first  the array is `sorted according to length of the words`, so that another word after a word can not be its predecessor.\\n\\n2. A `dp array is declared` for storing the maximum number of predecessor present in the array for a word in the array words.\\n\\n3. An iterative dp is run for each element (`curr`). In it for each curr a loop is run from start of the array to the curr element (`prev`) where it `checks if prev is the predecessor of curr`  using function predecessor() and stores the `maximun of dp[curr] and 1+dp[prev`]. Max is stored because there can be `multiple predecessor of curr` before it.\\n\\n4. The ans is updated as `max of ans and dp[curr]` after each loop so that it store the longest word chain of predecessor and is returned at the end.\\n\\n```\\nclass Solution {\\npublic:\\n\\tbool predecessor(string &prev, string &curr) {\\n\\t\\tint n = prev.size(), m = curr.size();\\n        \\n        // as only 1 character can be added to prev to get curr\\n\\t\\tif (n+1 != m) {\\n            return false;\\n        }\\n\\n        int i=0, j=0;\\n\\t\\twhile (j < m) {\\n\\t\\t\\tif (prev[i] == curr[j]) {\\n\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t}\\n\\t\\t\\telse j++;\\n\\t\\t}\\n\\n        // if the prev doesn\\'t reach its end then its not predecessor\\n\\t\\treturn i==n;\\n\\t}\\n    \\n    //compare function for sorting\\n    static bool compare (string& first, string& second) {\\n        return first.size() < second.size();\\n    }\\n    \\n\\tint longestStrChain(vector<string>& words) {\\n        \\n        //1. sorting according to length.\\n\\t\\tsort(words.begin(), words.end(), compare);\\n        \\n        //2. Declaration of dp\\n        //Min value of ans and dp element is 1(the word itself).\\n\\t\\tvector<int> dp(words.size(), 1);\\n\\t\\tint ans = 1; \\n        \\n\\t\\t//3. Iterative dp\\n\\t\\tfor (int curr = 0; curr < words.size(); curr++) {\\n\\t\\t\\tfor (int prev = 0; prev < curr; prev++) {\\n\\t\\t\\t\\tif (predecessor(words[prev], words[curr])) {\\n                    dp[curr] = max(dp[curr], dp[prev]+1);\\n                }\\n\\t\\t\\t}\\n\\t\\t\\t//4. Updating ans\\n\\t\\t\\tans = max(ans, dp[curr]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool predecessor(string &prev, string &curr) {\\n\\t\\tint n = prev.size(), m = curr.size();\\n        \\n        // as only 1 character can be added to prev to get curr\\n\\t\\tif (n+1 != m) {\\n            return false;\\n        }\\n\\n        int i=0, j=0;\\n\\t\\twhile (j < m) {\\n\\t\\t\\tif (prev[i] == curr[j]) {\\n\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t}\\n\\t\\t\\telse j++;\\n\\t\\t}\\n\\n        // if the prev doesn\\'t reach its end then its not predecessor\\n\\t\\treturn i==n;\\n\\t}\\n    \\n    //compare function for sorting\\n    static bool compare (string& first, string& second) {\\n        return first.size() < second.size();\\n    }\\n    \\n\\tint longestStrChain(vector<string>& words) {\\n        \\n        //1. sorting according to length.\\n\\t\\tsort(words.begin(), words.end(), compare);\\n        \\n        //2. Declaration of dp\\n        //Min value of ans and dp element is 1(the word itself).\\n\\t\\tvector<int> dp(words.size(), 1);\\n\\t\\tint ans = 1; \\n        \\n\\t\\t//3. Iterative dp\\n\\t\\tfor (int curr = 0; curr < words.size(); curr++) {\\n\\t\\t\\tfor (int prev = 0; prev < curr; prev++) {\\n\\t\\t\\t\\tif (predecessor(words[prev], words[curr])) {\\n                    dp[curr] = max(dp[curr], dp[prev]+1);\\n                }\\n\\t\\t\\t}\\n\\t\\t\\t//4. Updating ans\\n\\t\\t\\tans = max(ans, dp[curr]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079115,
                "title": "c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\nExplanation Eg.\\n\\nDyanamic Programming Approach\\nTime Complexity:\\n\\nTime Complexity: O(N*M) .\\nSpace Complexity: O(N + P) .\\n\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\n![image](https://assets.leetcode.com/users/images/3fb38049-4e31-4427-a9ae-3695b80f4d12_1695446837.1962926.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\nExplanation Eg.\\n\\nDyanamic Programming Approach\\nTime Complexity:\\n\\nTime Complexity: O(N*M) .\\nSpace Complexity: O(N + P) .\\n\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\n![image](https://assets.leetcode.com/users/images/3fb38049-4e31-4427-a9ae-3695b80f4d12_1695446837.1962926.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1112878,
                "title": "c-using-hash-map-easy-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n\\t//sort the vector on the basis of the length of each word\\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        map<string,int> m;\\n        int res = 0;\\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n\\t//sort the vector on the basis of the length of each word\\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        map<string,int> m;\\n        int res = 0;\\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747138,
                "title": "easy-java-solution-with-description",
                "content": "**Overview: \\n###### Create a map with the count of each occurence of the substring present in word array as we proceed through the word array. We sort it because we need increasing order of each word length for this algorithm to work. We identify single letter words as parents and find what children we have or what children have these single letters as parents. Also, we keep a track of the maximum we see everytime to return it ultimately.\\n\\n**Example walkthrough: \\n###### For the first example, we have words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]. Let\\'s identify this with first letter \"a\" (let\\'s call it parent). Now I need to check what is the next one, \"b\" (call it parent, as it is a single letter). Add both to the HashMap. Now, next we have \"ba\". We check if we have a parent, either \"b\" or \"a\" and if yes, we call it child and store it by adding 1. Similarly we traverse through all and we will have in our HashMap this structure.\\n\\n###### map after all traversals  **{a=1, bca=3, b=1, bda=3, bdca=4, ba=2}**\\n###### As you can see, we have identified which child is what level to the parent, i.e. single letter. Also, everytime, we do this, let\\'s keep a count of the max level of child we have seen through the loop and ultimately return that.\\n\\n**Code: \\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        Map<String, Integer> map = new HashMap();\\n        int max = 0;\\n        for(String word: words) {\\n            int longestSubstring = 0;\\n            for(int i = 0; i < word.length(); i++) {\\n                String subWord = word.substring(0, i) + word.substring(i+1);\\n                longestSubstring = Math.max(longestSubstring, map.getOrDefault(subWord, 0) + 1);\\n            }\\n            map.put(word, longestSubstring);\\n            max = Math.max(max, longestSubstring);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        Map<String, Integer> map = new HashMap();\\n        int max = 0;\\n        for(String word: words) {\\n            int longestSubstring = 0;\\n            for(int i = 0; i < word.length(); i++) {\\n                String subWord = word.substring(0, i) + word.substring(i+1);\\n                longestSubstring = Math.max(longestSubstring, map.getOrDefault(subWord, 0) + 1);\\n            }\\n            map.put(word, longestSubstring);\\n            max = Math.max(max, longestSubstring);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152972,
                "title": "c-lis-easy-to-understand-explanation-greater-than-93-88-ms-tc-o-n-m-sc-n-p",
                "content": "1. We have to sort the words by word\\'s length. ( apply bucket sort)\\n2. For each word, loop on all possible previous word with 1 letter missing.\\n3. If we have seen this previous word, update the longest chain for the current word.\\n4. Then finally return the longest word chain.\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n         vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\nIF YOU LIKED THIS SOLUTION, PLEASE PLEASE PLEASE UPVOTE IT!!!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n         vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152903,
                "title": "python-dp-2-approaches-using-dp",
                "content": "The problem can be solved using **DP** as it\\'s asking to find the longest string chain which means we have to go through all the possible paths to find the optimial solutions. We also need a way to define the overlapping subproblems and cache it. \\n\\n\\n## \\u2714\\uFE0F*Solution I - Memoization - Top Down*\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n=len(words)\\n        words_set={w:idx for idx, w in enumerate(words)}\\n        \\n        @cache\\n        def dp(i):                 \\n            curr=words[i]\\n            max_length=0\\n            for idx in range(len(curr)):\\n                new_wc = curr[:idx] + curr[idx+1:]\\n                if new_wc in words_set:\\n                    max_length=max(max_length, 1 + dp(words_set[new_wc]))\\n        \\n            return max_length\\n        \\n        return max(dp(i)+1 for i in range(n))\\n```\\nA more concise variation shared by [atorre](https://leetcode.com/atorre/)\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        w_set = set(words)\\n        @cache\\n        def dp(w:str) -> int:\\n            return 1 + max((dp(s) for i in range(len(w)) if (s:=w[:i]+w[i+1:]) in w_set), default=0)\\n        return max(dp(w) for w in words)\\n```\\n\\nif `N` is length of `words` and `L` is the max length of a word in `words`,\\n\\n**Time - O(N * L * L )** - first `L` is for the loop to find new words by deleting one character and the second `L` is to generate the new word. \\n**Space - O(N * L)** - space required for `words_set`.\\n\\n\\n---\\n\\n## \\u2714\\uFE0F*Solution I I - Tabulation - Bottom Up*\\nA more concise version only possible because it\\'s python :)\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:                \\n        words.sort(key=len)\\n        dp={}\\n        for w in words:\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```\\n\\nif `N` is length of `words` and `L` is the max length of a word in `words`,\\n\\n**Time - O(NlogN + N * L * L )** - first `L` is for the loop to find new words by deleting one character and the second `L` is to generate the new word. \\n**Space - O(N * L)** - space required for `dp`.\\n\\n---\\n\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n=len(words)\\n        words_set={w:idx for idx, w in enumerate(words)}\\n        \\n        @cache\\n        def dp(i):                 \\n            curr=words[i]\\n            max_length=0\\n            for idx in range(len(curr)):\\n                new_wc = curr[:idx] + curr[idx+1:]\\n                if new_wc in words_set:\\n                    max_length=max(max_length, 1 + dp(words_set[new_wc]))\\n        \\n            return max_length\\n        \\n        return max(dp(i)+1 for i in range(n))\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        w_set = set(words)\\n        @cache\\n        def dp(w:str) -> int:\\n            return 1 + max((dp(s) for i in range(len(w)) if (s:=w[:i]+w[i+1:]) in w_set), default=0)\\n        return max(dp(w) for w in words)\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:                \\n        words.sort(key=len)\\n        dp={}\\n        for w in words:\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168211,
                "title": "javascript-solution",
                "content": "```\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    \\n    const map = new Map();\\n    \\n    let res = 1;\\n    \\n    for (const word of words) {\\n        const n = word.length;\\n        let max = 1;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const front = word.substring(0, i);\\n            const back = word.substring(i + 1);\\n            \\n            const removed = front + back;\\n            \\n            if (map.has(removed)) {\\n                max = Math.max(max, map.get(removed) + 1);\\n            }\\n        }\\n        \\n        map.set(word, max);\\n        \\n        res = Math.max(res, max);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    \\n    const map = new Map();\\n    \\n    let res = 1;\\n    \\n    for (const word of words) {\\n        const n = word.length;\\n        let max = 1;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const front = word.substring(0, i);\\n            const back = word.substring(i + 1);\\n            \\n            const removed = front + back;\\n            \\n            if (map.has(removed)) {\\n                max = Math.max(max, map.get(removed) + 1);\\n            }\\n        }\\n        \\n        map.set(word, max);\\n        \\n        res = Math.max(res, max);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 522827,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            tmp = [0]\\n            for i in range(len(w)):\\n                if w[:i] + w[i+1:] in dp:\\n                    tmp.append(dp[w[:i] + w[i+1:]])\\n                dp[w] = max(tmp) + 1\\n        return max(dp.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            tmp = [0]\\n            for i in range(len(w)):\\n                if w[:i] + w[i+1:] in dp:\\n                    tmp.append(dp[w[:i] + w[i+1:]])\\n                dp[w] = max(tmp) + 1\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479539,
                "title": "python3-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution:\\n\\tdef longestStrChain(self, words: List[str]) -> int:\\n\\t\\twords.sort(key=len)\\n\\t\\tdp = {}\\n\\t\\tfor word in words:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\tif word not in dp:\\n\\t\\t\\t\\t\\tdp[word]=dp.get(word[:i]+word[i+1:],0)+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[word]=max(dp.get(word[:i]+word[i+1:],0)+1,dp[word])\\n\\t\\treturn max(dp.values())\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\tdef longestStrChain(self, words: List[str]) -> int:\\n\\t\\twords.sort(key=len)\\n\\t\\tdp = {}\\n\\t\\tfor word in words:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\tif word not in dp:\\n\\t\\t\\t\\t\\tdp[word]=dp.get(word[:i]+word[i+1:],0)+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[word]=max(dp.get(word[:i]+word[i+1:],0)+1,dp[word])\\n\\t\\treturn max(dp.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566658,
                "title": "java-simple-recursion-memoization-solution-with-explanation",
                "content": "Firstly, we add all the words to Hashmap for quick checking.\\nThen we start from a word and start deleting the letters to form a word with 1 less character and continue our recursion if we find the new word in our hashmap.\\n\\n```\\nclass Solution {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    HashMap<String, Integer> memo = new HashMap<>();\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            map.put(word, 1);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (String word : words) {\\n            res = Math.max(res, 1 + dfs(word));\\n        }\\n        return res;\\n    }\\n    \\n    public int dfs(String sb) {\\n        if (sb.length() == 0) {\\n            return 0;\\n        }\\n        if (memo.containsKey(sb)) return memo.get(sb);\\n        int max = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            StringBuilder tmp = new StringBuilder(sb);\\n            tmp.deleteCharAt(i);\\n            int res = 0;\\n            if (map.containsKey(tmp.toString())) {\\n                res += 1 + dfs(tmp.toString());\\n            }\\n            max = Math.max(max, res);\\n        }\\n        memo.put(sb, max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    HashMap<String, Integer> memo = new HashMap<>();\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            map.put(word, 1);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (String word : words) {\\n            res = Math.max(res, 1 + dfs(word));\\n        }\\n        return res;\\n    }\\n    \\n    public int dfs(String sb) {\\n        if (sb.length() == 0) {\\n            return 0;\\n        }\\n        if (memo.containsKey(sb)) return memo.get(sb);\\n        int max = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            StringBuilder tmp = new StringBuilder(sb);\\n            tmp.deleteCharAt(i);\\n            int res = 0;\\n            if (map.containsKey(tmp.toString())) {\\n                res += 1 + dfs(tmp.toString());\\n            }\\n            max = Math.max(max, res);\\n        }\\n        memo.put(sb, max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456015,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Use DP (Bottom Up) tabulation, gradually build our results from the shortest string to the longest\\n2. The DP table saves the maximum chains for a given word\\n3. For every word, we try to remove each character and find the maximum predecessor chain + 1\\n``` javascript\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    let dp = {};\\n    words = words.sort((a,b)=>a.length - b.length);\\n    for (let word of words) {\\n        let longest = 0;\\n        for (let i=0;i<word.length;i++) {\\n            let pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (dp[pre]||0) + 1);\\n        }\\n        dp[word] = longest;\\n    }\\n    return Math.max(...Object.values(dp));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    let dp = {};\\n    words = words.sort((a,b)=>a.length - b.length);\\n    for (let word of words) {\\n        let longest = 0;\\n        for (let i=0;i<word.length;i++) {\\n            let pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (dp[pre]||0) + 1);\\n        }\\n        dp[word] = longest;\\n    }\\n    return Math.max(...Object.values(dp));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155234,
                "title": "python-solution-intuitive-and-suggestions-for-better-approach",
                "content": "# For code, scroll down\\nSo, guys, if you approach it in the recursive way,  (Top-down) you would most likely get an memorey limit exceeded error, So, here i\\'ll explain my intuition behind the logic as well as how i converted it to bottom up and a suggestion foor an even optimised solution.\\n\\nSo practically we need words in increasing order of their length,, that indicates we can sort our words list,\\nafter sorting it\\nbasically problem breaks down to two major conditions\\nyou wanna include this current word, or you dont\\n\\nso if you dont want to include the current word, simply  explore for the word in next index\\nthen, in case your current word meets the criteria of string chain, i.e 1 letter would be extra than its immediate preious, and rest all are letters match(in same order), then you can proceed by including this element and moving on to next index,\\nnow you canuse your dp to store the maximum of either including or not including, and thus return.\\n\\n\\nnow due to the limits in recursive call, you would probably get an error, so in the bottom up way :\\nprev acts as row, so from lastword to the beginning iterate\\ncurr acts as column take it from last word to word just behind after prev\\nrest the logic remains same\\n\\nYou could further optimise it by taking 2 1d dps\\nIf our dp depends on current row and just the previous row, we can use 2 dps, one for curr iteration and 1 storing values of previous iteration, here just make the row iterations as curr and column iterations as previous and just make changes accordingly.\\n\\nIf you feel something can be added on , I\\'m open to suggestions.\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        \\n        dp = {}\\n        @lru_cache(None)\\n        def iSvalidInclusion(word1,word2):\\n            if not (len(word2)==len(word1)+1):   \\n                return False\\n            i =0\\n            count =1\\n            \\n            while i<len(word1):\\n                \\n                if count==1:\\n                    if word2[i]==word1[i]:\\n                        i+=1\\n                    else:\\n                        count=0\\n                elif count==0:\\n                    if word2[i+1] ==  word1[i]:\\n                        i+=1\\n                    else: return False\\n            return True\\n\\'\\'\\'            \\n    RECURSIVE \\n\\n        def formChain(prev,curr):\\n            \\n            if curr >= len(words)+1:\\n                return 0\\n            \\n            if (prev,curr) in dp:\\n                return dp[(prev,curr)]\\n            \\n             basically im not including that word\\n            ans = formChain(prev,curr+1)\\n             im either starting go form chain or im including the word\\n            if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                ans = max(ans,1+formChain(curr,curr+1))\\n            dp[(prev,curr)] = ans\\n            return ans\\n        return formChain(0,1)\\n        \\n\\'\\'\\'\\n        dp = [[0]*(len(words)+2) for i in range(len(words)+2)]\\n        \\n        for prev in range(len(words),-1,-1):\\n            for curr in range(len(words)+1,prev,-1):\\n                if curr >= len(words)+1:\\n                    dp[prev][curr] = 0\\n                    continue\\n                ans = dp[prev][curr+1]\\n#             im either starting go form chain or im including the word\\n                if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                    ans = max(ans,1+dp[curr][curr+1])\\n                dp[prev][curr] = ans\\n        return dp[0][1]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        \\n        dp = {}\\n        @lru_cache(None)\\n        def iSvalidInclusion(word1,word2):\\n            if not (len(word2)==len(word1)+1):   \\n                return False\\n            i =0\\n            count =1\\n            \\n            while i<len(word1):\\n                \\n                if count==1:\\n                    if word2[i]==word1[i]:\\n                        i+=1\\n                    else:\\n                        count=0\\n                elif count==0:\\n                    if word2[i+1] ==  word1[i]:\\n                        i+=1\\n                    else: return False\\n            return True\\n\\'\\'\\'            \\n    RECURSIVE \\n\\n        def formChain(prev,curr):\\n            \\n            if curr >= len(words)+1:\\n                return 0\\n            \\n            if (prev,curr) in dp:\\n                return dp[(prev,curr)]\\n            \\n             basically im not including that word\\n            ans = formChain(prev,curr+1)\\n             im either starting go form chain or im including the word\\n            if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                ans = max(ans,1+formChain(curr,curr+1))\\n            dp[(prev,curr)] = ans\\n            return ans\\n        return formChain(0,1)\\n        \\n\\'\\'\\'\\n        dp = [[0]*(len(words)+2) for i in range(len(words)+2)]\\n        \\n        for prev in range(len(words),-1,-1):\\n            for curr in range(len(words)+1,prev,-1):\\n                if curr >= len(words)+1:\\n                    dp[prev][curr] = 0\\n                    continue\\n                ans = dp[prev][curr+1]\\n#             im either starting go form chain or im including the word\\n                if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                    ans = max(ans,1+dp[curr][curr+1])\\n                dp[prev][curr] = ans\\n        return dp[0][1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153589,
                "title": "dp-recurrence-memoization-cpp-well-commented",
                "content": "**Recurrence**\\n```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp){ \\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n        \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp));\\n      \\n        return maxi;\\n    }\\n```\\n\\n**Memoization**\\n\\n```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp, vector<int> &dp){ \\n      // if dp contains the ans return\\n      if(dp[i]!=-1) return dp[i];\\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp, dp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return dp[i]= len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n      \\n        // initialize dp vector\\n        vector<int> dp(n, -1);\\n      \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp, dp));\\n      \\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp){ \\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n        \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp));\\n      \\n        return maxi;\\n    }\\n```\n```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp, vector<int> &dp){ \\n      // if dp contains the ans return\\n      if(dp[i]!=-1) return dp[i];\\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp, dp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return dp[i]= len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n      \\n        // initialize dp vector\\n        vector<int> dp(n, -1);\\n      \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp, dp));\\n      \\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152401,
                "title": "c-easy-solution-longest-increasing-subsequence-type-dp",
                "content": "**C++ Code:\\nTime Complexity : O(n*n length)**\\n**Space Complexity : O(n)**\\n\\n```\\nbool check(string &s1, string &s2)\\n{\\n    if(s1.length()-s2.length()!=1) return false;\\n    int i=0,j=0;\\n    while(i<s1.length())\\n    {\\n        if(s1[i]==s2[j])\\n        {\\n            i++;j++;\\n        }\\n        else\\n            i++;\\n    }\\n    if(i==s1.length() && j== s2.length()) return true;\\n    else return false;\\n}\\nstatic bool comp(string &s1,string &s2)\\n{\\n    if(s1.length()<s2.length()) return true;\\n    else return false;\\n}\\n    int longestStrChain(vector<string>& words) {\\n    int n = words.size();\\n    sort(words.begin(),words.end(),comp);\\n    vector<int>dp(n,1);\\n    int maxi = 0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int prev=0;prev<i;prev++)\\n        {\\n            if(check(words[i],words[prev]) && dp[i]<dp[prev]+1)\\n            {\\n                dp[i] =1+dp[prev];\\n            }\\n        }\\n       maxi = max(maxi,dp[i]); \\n    }\\n    return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool check(string &s1, string &s2)\\n{\\n    if(s1.length()-s2.length()!=1) return false;\\n    int i=0,j=0;\\n    while(i<s1.length())\\n    {\\n        if(s1[i]==s2[j])\\n        {\\n            i++;j++;\\n        }\\n        else\\n            i++;\\n    }\\n    if(i==s1.length() && j== s2.length()) return true;\\n    else return false;\\n}\\nstatic bool comp(string &s1,string &s2)\\n{\\n    if(s1.length()<s2.length()) return true;\\n    else return false;\\n}\\n    int longestStrChain(vector<string>& words) {\\n    int n = words.size();\\n    sort(words.begin(),words.end(),comp);\\n    vector<int>dp(n,1);\\n    int maxi = 0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int prev=0;prev<i;prev++)\\n        {\\n            if(check(words[i],words[prev]) && dp[i]<dp[prev]+1)\\n            {\\n                dp[i] =1+dp[prev];\\n            }\\n        }\\n       maxi = max(maxi,dp[i]); \\n    }\\n    return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964329,
                "title": "c-easy-lis-based",
                "content": "```\\nclass Solution {\\n    bool compare(string &s1, string &s2) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = s1.size(), n2 = s2.size();\\n        if(n2 - 1 != n1) return false;\\n        while(j < n2) {\\n            if(s1[i] == s2[j])\\n                i++, j++;\\n            else \\n                j++;\\n        }\\n        \\n        if(i == n1 and j == n2)\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    static bool comp(string &s1, string &s2) {\\n        return s1.size() < s2.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), comp);\\n      \\n        int maxi = 1;\\n        int n = words.size();\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n\\n                if(compare(words[j], words[i]) and dp[i] < dp[j] + 1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n            maxi = max(maxi, dp[i]);\\n\\n\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    bool compare(string &s1, string &s2) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = s1.size(), n2 = s2.size();\\n        if(n2 - 1 != n1) return false;\\n        while(j < n2) {\\n            if(s1[i] == s2[j])\\n                i++, j++;\\n            else \\n                j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 972707,
                "title": "python-dp-solution-and-dfs-solution-explained",
                "content": "```\\nfrom collections import defaultdict\\nfrom functools import lru_cache as cache\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        \\'\\'\\'\\n        DFS Solution\\n        \\n        Build a graph.\\n            Turn words into a set for fast lookups.\\n            For each word, generate every possible previous word by removing each letter.\\n                If the previous word is in the set, do graph[prev].add(word)\\n        \\n        DFS the graph and keep track of longest path. \\n        We need to DFS from every word, to handle the case of unconnected components of the graph.\\n        If we cache response from the DFS function, we save significant runtime.\\n        \\n        Analysis:\\n        Time:\\n            - Building the graph: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to build the graph.\\n            - Traversing the graph: O(n) since we visit each node in the graph once and use a cache afterwards.\\n        Space:\\n            - Building the graph: O(n^2) since the worst case could have every word be a neighbor with every word.\\n            - Traversing the graph: O(n) recursion stack if the graph was just one long line.\\n        \\'\\'\\'\\n        \\n#         graph = defaultdict(set)\\n#         words = set(words)\\n        \\n#         for word in words:\\n#             if len(word) > 1: # one-letter words have no predecessors\\n#                 for i in range(len(word)):\\n#                     prev = word[:i] + word[i+1:]\\n#                     if prev in words:\\n#                         graph[prev].add(word)\\n        \\n#         @cache(None)\\n#         def dfs(word):\\n            \\n#             # if the word has no neighbors, it is a sequence of a length 1, and we can never have a sequence of length 0.\\n#             answer = 1 \\n            \\n#             for nei in graph[word]:\\n#                 answer = max(answer, 1 + dfs(nei))\\n                \\n#             return answer\\n        \\n#         return max(dfs(word) for word in words)\\n\\n        \\'\\'\\'\\n        DP Solution\\n        \\n        d[word] is the longest chain ending at word.\\n        We sort the words by length, iterate through them, and generate all predecessors by removing letters.\\n        If a predecessor p is in d, d[word] = max(1 + d[p], d[word])\\n        We can track the max value along the way as well.\\n        \\n        Analysis\\n        Time:\\n            - Building the DP dictionary: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to calculate predecessors.\\n                Lookups and updates to the dict are O(1), so our total time is O(n * k).\\n        Space:\\n            - Building the DP dictionary: O(n), since we have 1 entry for each word. O(n) overall.\\n        \\'\\'\\'\\n    \\n        words.sort(key=lambda word: len(word))\\n        d = {word: 1 for word in words}\\n        answer = 1 # Impossible to have a sequence of length 0.\\n        \\n        for word in words:\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i+1:]\\n                if prev in d:\\n                    d[word] = max(1 + d[prev], d[word])\\n                    answer = max(answer, d[word])\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import lru_cache as cache\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        \\'\\'\\'\\n        DFS Solution\\n        \\n        Build a graph.\\n            Turn words into a set for fast lookups.\\n            For each word, generate every possible previous word by removing each letter.\\n                If the previous word is in the set, do graph[prev].add(word)\\n        \\n        DFS the graph and keep track of longest path. \\n        We need to DFS from every word, to handle the case of unconnected components of the graph.\\n        If we cache response from the DFS function, we save significant runtime.\\n        \\n        Analysis:\\n        Time:\\n            - Building the graph: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to build the graph.\\n            - Traversing the graph: O(n) since we visit each node in the graph once and use a cache afterwards.\\n        Space:\\n            - Building the graph: O(n^2) since the worst case could have every word be a neighbor with every word.\\n            - Traversing the graph: O(n) recursion stack if the graph was just one long line.\\n        \\'\\'\\'\\n        \\n#         graph = defaultdict(set)\\n#         words = set(words)\\n        \\n#         for word in words:\\n#             if len(word) > 1: # one-letter words have no predecessors\\n#                 for i in range(len(word)):\\n#                     prev = word[:i] + word[i+1:]\\n#                     if prev in words:\\n#                         graph[prev].add(word)\\n        \\n#         @cache(None)\\n#         def dfs(word):\\n            \\n#             # if the word has no neighbors, it is a sequence of a length 1, and we can never have a sequence of length 0.\\n#             answer = 1 \\n            \\n#             for nei in graph[word]:\\n#                 answer = max(answer, 1 + dfs(nei))\\n                \\n#             return answer\\n        \\n#         return max(dfs(word) for word in words)\\n\\n        \\'\\'\\'\\n        DP Solution\\n        \\n        d[word] is the longest chain ending at word.\\n        We sort the words by length, iterate through them, and generate all predecessors by removing letters.\\n        If a predecessor p is in d, d[word] = max(1 + d[p], d[word])\\n        We can track the max value along the way as well.\\n        \\n        Analysis\\n        Time:\\n            - Building the DP dictionary: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to calculate predecessors.\\n                Lookups and updates to the dict are O(1), so our total time is O(n * k).\\n        Space:\\n            - Building the DP dictionary: O(n), since we have 1 entry for each word. O(n) overall.\\n        \\'\\'\\'\\n    \\n        words.sort(key=lambda word: len(word))\\n        d = {word: 1 for word in words}\\n        answer = 1 # Impossible to have a sequence of length 0.\\n        \\n        for word in words:\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i+1:]\\n                if prev in d:\\n                    d[word] = max(1 + d[prev], d[word])\\n                    answer = max(answer, d[word])\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785733,
                "title": "well-explained-solution-o-n-3-c-solution-using-the-lis-algo",
                "content": "This solution uses the idea of LIS and instead of using LCS with LIS which would make the complexity of the solution O(N^4), a simple check function is implemented which would make the solution better with time complexity O(N^3). I found that the initial time taken with O(N^4) solution(LCS + LIS) was ~1800ms, but with O(N^3) the solution became 9 times faster resulting in ~220-240ms.\\n\\nIDEA : It is same as LIS, which can be easily understood, let me explain the use of check function. The check function would take the 2 strings and as mentioned in the question, the successive string only differs by 1 character. This modification allows the idea of O(N) complexity of helper/check function. The check function would simply count the difference in number of characters of the two strings. If the difference is 1, then it returns true and the condition holds true, and returns false otherwise.\\n\\n```\\n// using the idea of LIS\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    \\n    int check(string s, string t){\\n        int m = s.length(), n = t.length(), i = 0, j = 0, missing = 0;\\n        if(n != m+1) return false;\\n        for(int i=0; i<n; i++){\\n            if(t[i] == s[j]) j++;\\n            else{\\n\\t\\t\\t// if no character is missing, continue to check\\n\\t\\t\\t// if we found a missing character, update the variable\\n                if(!missing) missing = 1;\\n\\t\\t\\t\\t// if number of missing character is >=2 return false\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    static bool cmp(const string& s, const string t){\\n        return s.length() < t.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& v) {\\n        if(v.empty()) return 0;\\n        sort(v.begin(), v.end(), cmp);\\n        vector<int> dp(v.size(), 1);\\n        int ans = 0;\\n        for(int i=1; i<v.size(); i++){\\n            for(int j=0; j<i; j++){\\n                int x = v[i].length(), y = v[j].length();\\n                if(y+1 == x && check(v[j], v[i]) && dp[i] < dp[j]+1) dp[i] = dp[j]+1;\\n                ans = max(ans, dp[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// using the idea of LIS\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    \\n    int check(string s, string t){\\n        int m = s.length(), n = t.length(), i = 0, j = 0, missing = 0;\\n        if(n != m+1) return false;\\n        for(int i=0; i<n; i++){\\n            if(t[i] == s[j]) j++;\\n            else{\\n\\t\\t\\t// if no character is missing, continue to check\\n\\t\\t\\t// if we found a missing character, update the variable\\n                if(!missing) missing = 1;\\n\\t\\t\\t\\t// if number of missing character is >=2 return false\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    static bool cmp(const string& s, const string t){\\n        return s.length() < t.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& v) {\\n        if(v.empty()) return 0;\\n        sort(v.begin(), v.end(), cmp);\\n        vector<int> dp(v.size(), 1);\\n        int ans = 0;\\n        for(int i=1; i<v.size(); i++){\\n            for(int j=0; j<i; j++){\\n                int x = v[i].length(), y = v[j].length();\\n                if(y+1 == x && check(v[j], v[i]) && dp[i] < dp[j]+1) dp[i] = dp[j]+1;\\n                ans = max(ans, dp[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 516417,
                "title": "go-golang-clean-solution",
                "content": "```go\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(a, b int) bool { return len(words[a]) < len(words[b]) })\\n    mem, res := make(map[string]int), 0\\n    for _, v := range words {\\n        for i := 0; i < len(v); i++ {\\n            pre := v[:i] + v[i + 1:]\\n            mem[v] = max(mem[v], mem[pre] + 1)\\n        }\\n        res = max(res, mem[v])\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(a, b int) bool { return len(words[a]) < len(words[b]) })\\n    mem, res := make(map[string]int), 0\\n    for _, v := range words {\\n        for i := 0; i < len(v); i++ {\\n            pre := v[:i] + v[i + 1:]\\n            mem[v] = max(mem[v], mem[pre] + 1)\\n        }\\n        res = max(res, mem[v])\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868312,
                "title": "python3-dp-lis",
                "content": "Does this look familiar to longest increasing subsequence? \\nThe first thing to notice is, we need to sort the words according to their length. Then, we could use the similar thought process as LIS to solve this problem.\\nThe dp[i] = longest sequence ending with words[i]. For each word, we check all possible subsequences of it, and if we could find one, then chek that subsequence is in dp. This part is equivalent to the process when we check if we cound find a number that is smaller than current number in the dict as in the LIS problem.\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = {word: 1 for word in words}\\n        for i in range(len(words)):\\n            word = words[i]\\n            for j in range(len(word)):\\n                tmp = word[: j] + word[j + 1:]\\n                if tmp in dp:\\n                    dp[word] = max(dp[tmp] + 1, dp[word])\\n\\n        return max(dp.values())\\n```\\nPlease upvote if you find it helpful. Thanks!",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = {word: 1 for word in words}\\n        for i in range(len(words)):\\n            word = words[i]\\n            for j in range(len(word)):\\n                tmp = word[: j] + word[j + 1:]\\n                if tmp in dp:\\n                    dp[word] = max(dp[tmp] + 1, dp[word])\\n\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592889,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),[](string a, string b){return a.size() < b.size();});\\n        map<string, int> dp;\\n        int res = 0;\\n        for(string s : words){\\n            for(int i = 0; i<s.size(); i++ ){\\n                dp[s] = max(dp[s.substr(0,i) + s.substr(i+1)] + 1, dp[s]);\\n            }\\n            res = max(res, dp[s]);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),[](string a, string b){return a.size() < b.size();}",
                "codeTag": "Java"
            },
            {
                "id": 380056,
                "title": "java-dynamic-programming-map-explained",
                "content": "Solution is based on DP. \\nIf we sort the array then sequence can only increase if we go from 0 to len(array). Also if we checked this word previously then we can re-use it\\'s sequence score if this word can be formed from longer word. \\n\\nThese are key ideas, now build the solution. Sort words by length, then start iterating on word\\'s array. For every word we met store it\\'s best scoe in the map <word>-<score>. For every word remove it chars one by one and check if met this new word before, if so - for current word the score will be score<shorter_word> + 1. Otherwise this word starts the new sequence so the score is 1. In Java we can remove one char effectively using StringBuilder. \\n\\nWe keep the overall best score and check for every word from array if it can give us better one.\\n\\nComplexity - O(nlgn) for sorting, O(n x avg_len) for checking every char in every word, so the main factor will be O(n x avg_len). We need O(n x avg_len) memory to store scores for every sub-word.\\n\\n```\\n    public int longestStrChain(String[] words) {\\n        //sort words by length\\n        Arrays.sort(words,  new Comparator<String>(){\\n            public int compare(String s0, String s1) {\\n                return s0.length() - s1.length();\\n            }\\n        });\\n        //map is required to store the best sequence length for each word\\n        Map<String, Integer> map = new HashMap();\\n        //final result\\n        int res = 0;\\n        //iterate over words, because they are sorted we may assume that at each next word\\n        //can only increase the sequence\\n        for (String word : words) {\\n            int cur = 1;\\n            //try to remove every char in word one by one, check in the map for every removed char\\n            StringBuilder sb = new StringBuilder(word);\\n            int N = word.length();\\n            for (int i = 0; i < N; i++) {\\n                char ch = sb.charAt(i);\\n                sb.deleteCharAt(i);\\n                //this is our word without char at position i-th\\n                String possible = sb.toString();\\n                //if we met this word before - get it\\'s sequence count from map, otherwise it\\'s 1\\n                if (map.containsKey(possible)) {\\n                    cur = Math.max(cur, map.get(possible) + 1);\\n                }\\n                //this is to restore deleted char for next iteration\\n                if (i < N - 1)\\n                    sb.insert(i, ch);\\n            }\\n            //store the best sequence score for this word\\n            map.put(word, cur);\\n            //update overall result if needed\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int longestStrChain(String[] words) {\\n        //sort words by length\\n        Arrays.sort(words,  new Comparator<String>(){\\n            public int compare(String s0, String s1) {\\n                return s0.length() - s1.length();\\n            }\\n        });\\n        //map is required to store the best sequence length for each word\\n        Map<String, Integer> map = new HashMap();\\n        //final result\\n        int res = 0;\\n        //iterate over words, because they are sorted we may assume that at each next word\\n        //can only increase the sequence\\n        for (String word : words) {\\n            int cur = 1;\\n            //try to remove every char in word one by one, check in the map for every removed char\\n            StringBuilder sb = new StringBuilder(word);\\n            int N = word.length();\\n            for (int i = 0; i < N; i++) {\\n                char ch = sb.charAt(i);\\n                sb.deleteCharAt(i);\\n                //this is our word without char at position i-th\\n                String possible = sb.toString();\\n                //if we met this word before - get it\\'s sequence count from map, otherwise it\\'s 1\\n                if (map.containsKey(possible)) {\\n                    cur = Math.max(cur, map.get(possible) + 1);\\n                }\\n                //this is to restore deleted char for next iteration\\n                if (i < N - 1)\\n                    sb.insert(i, ch);\\n            }\\n            //store the best sequence score for this word\\n            map.put(word, cur);\\n            //update overall result if needed\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078748,
                "title": "c-dp-using-unordered-map-array-beats-97-50",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook at the constraint ```1 <= words[i].length <= 16```. There are many ways of DP.\\n\\nVarying the ```words[i]``` is easier and quicker! In fact there are len(words[i]) substrings with length=len(words[i])-1 \\n\\nUse an array over ```unordered_set<string, int> mp```\\n\\nThe index for ```mp[i]``` denote the length of string.\\n# Why not just unordered_set<string, int>?\\nAlthough the C++ unodered_map is in average O(1) for inserting & updating an element, but in worst case it is a linear time O(k) where k=size of the container. So breaking it into an array of smaller unordered sets may save time! \\n\\nThe array for unordered_maps may be changed into array for maps when n is small, and it might make code for small n more efficient.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. ```vector<unordered_map<string, int>>``` is a declaration that defines a vector containing elements of type ```unordered_map<string, int>```. Each element in the vector is an unordered map that associates strings with integer values.\\n2. ```mp``` is the name of the vector of unordered maps.\\n3. Vector ```mp``` is initialized with 17 elements (length of 0~16). Each element represents a different word length.\\n4. if ```mp[5][\"apple\"]``` is 3, it means that the longest chain that can be formed using words of length 5 includes \"apple\" and two other words.\\n5. ```vector<unordered_map<string, int>> mp(17);```is used to maintain a data structure that organizes words by their lengths and keeps track of the longest chain that can be formed for each word length. It\\'s a crucial part of the dynamic programming approach used to solve the problem of finding the longest string chain.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(len(word)*16+n\\\\log n)=O(n\\\\log n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(len(word))\\n# Code runtime 54ms\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        vector<unordered_map<string, int>> mp(17);\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# Code with Explanation in Comments\\n```\\n// Define a class Solution, typically used for solving a problem.\\n\\nclass Solution {\\npublic:\\n    // Define the function longestStrChain, which takes a vector of strings as input.\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(); // Get the number of words in the input vector.\\n\\n        // If there is only one word in the input, return 1 as the result.\\n        if (n == 1) return 1;\\n\\n        // Sort the words in the input vector in ascending order of their lengths.\\n        // A lambda function is used for the comparison, ensuring shorter words come first.\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n\\n        // Create a vector of unordered_maps with a size of 17, each for words of a specific length.\\n        vector<unordered_map<string, int>> mp(17);\\n\\n        // Populate the maps with words from the input, associating each word with a count of 1.\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0; // Initialize a variable to store the maximum chain length.\\n\\n        // Iterate through each word in the input.\\n        for (auto& w : words) {\\n            int sz = w.size(); // Get the length of the current word.\\n\\n            // If the word has a length of 1, skip it as it cannot be part of a chain.\\n            if (sz == 1) continue;\\n\\n            // Iterate through all possible substrings of the current word by removing one character at a time.\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); // Create a new word by removing one character.\\n\\n                // Check if the previous length (sz-1) contains the newly created word (w2).\\n                // If it does, update the current length\\'s map with the maximum chain length.\\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n\\n            // Update the maximum chain length based on the current word\\'s chain length.\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        // Return the maximum chain length found in the input vector of words.\\n        return ans;\\n    }\\n};\\n\\n```\\n# Code using map<string, int> mp[17] runtime 76ms\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        map<string, int> mp[17];\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2]+1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```1 <= words[i].length <= 16```\n```words[i]```\n```unordered_set<string, int> mp```\n```mp[i]```\n```vector<unordered_map<string, int>>```\n```unordered_map<string, int>```\n```mp```\n```mp```\n```mp[5][\"apple\"]```\n```vector<unordered_map<string, int>> mp(17);```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        vector<unordered_map<string, int>> mp(17);\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\n```\\n// Define a class Solution, typically used for solving a problem.\\n\\nclass Solution {\\npublic:\\n    // Define the function longestStrChain, which takes a vector of strings as input.\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(); // Get the number of words in the input vector.\\n\\n        // If there is only one word in the input, return 1 as the result.\\n        if (n == 1) return 1;\\n\\n        // Sort the words in the input vector in ascending order of their lengths.\\n        // A lambda function is used for the comparison, ensuring shorter words come first.\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n\\n        // Create a vector of unordered_maps with a size of 17, each for words of a specific length.\\n        vector<unordered_map<string, int>> mp(17);\\n\\n        // Populate the maps with words from the input, associating each word with a count of 1.\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0; // Initialize a variable to store the maximum chain length.\\n\\n        // Iterate through each word in the input.\\n        for (auto& w : words) {\\n            int sz = w.size(); // Get the length of the current word.\\n\\n            // If the word has a length of 1, skip it as it cannot be part of a chain.\\n            if (sz == 1) continue;\\n\\n            // Iterate through all possible substrings of the current word by removing one character at a time.\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); // Create a new word by removing one character.\\n\\n                // Check if the previous length (sz-1) contains the newly created word (w2).\\n                // If it does, update the current length\\'s map with the maximum chain length.\\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n\\n            // Update the maximum chain length based on the current word\\'s chain length.\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        // Return the maximum chain length found in the input vector of words.\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        map<string, int> mp[17];\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2]+1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078608,
                "title": "python-3-8-lines-w-comments-t-s-97-94",
                "content": "\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        d = defaultdict(int)                # The keys for d are words. The values    \\n                                            # are the # of predecessors of that word\\n        for word in sorted(words,key = len):\\n            n, d[word] = len(word), 1\\n\\n            for i in range(n):              # Check which larger words are predecessors\\n                w = word[:i] + word[i+1:]   # and determine the max length path\\n\\n                if w in d:\\n                    d[word] = max(d[word], d[w] + 1)\\n\\n        return max(d.values())   \\n```\\n[https://leetcode.com/problems/longest-string-chain/submissions/1056706538/?envType=daily-question&envId=2023-09-23](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*), in which *N* ~ `len(words)` *M* ~ maximum length of elements in`words`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        d = defaultdict(int)                # The keys for d are words. The values    \\n                                            # are the # of predecessors of that word\\n        for word in sorted(words,key = len):\\n            n, d[word] = len(word), 1\\n\\n            for i in range(n):              # Check which larger words are predecessors\\n                w = word[:i] + word[i+1:]   # and determine the max length path\\n\\n                if w in d:\\n                    d[word] = max(d[word], d[w] + 1)\\n\\n        return max(d.values())   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153172,
                "title": "easiest-solution-with-dp-bottom-up-two-pointer-c",
                "content": "**First of all I suggest to observe the constraints clearly **\\n**Constraints:\\n1 <= words.length <= 1000\\n1 <= words[i].length <= 16\\nwords[i] only consists of lowercase English letters.**\\n\\nmaximum length of string words[i] can be 16 so we use this to solve this problem, and we also know that the answer **(string chain)** of 15 lenght words[i] came from the answer **(string chain)** of length 14 length of words[i].\\n**So make vector<pair<string,int>> V[17] where string part contain the words[i] and int part contain answer(longest string chain till that string) and vector is of only size 17 because max length of words[i] can be 16.** \\n\\n\\nclass Solution {\\n    \\n    bool Match(string s1, string s2)\\n    { \\n\\t    // This function check wheter string s1 is predecessor of s2 or not using two pointer approach.\\n        int val=0;\\n        int n=s1.size(),m=s2.size();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s1[i]!=s2[j] && val>0)\\n            {\\n                return false;                // if more than one charcter are different not predecessor so return false.\\n            }\\n            else if(s1[i]!=s2[j] && val==0)\\n            {\\n                i++;\\n                val++;                    //  if only one charcter is differ then allowed.\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return true;    // s1 is predecessor of s2.\\n    }\\n    \\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n        int  n=words.size();\\n        vector<pair<string,int>> V[17];    //  store <word[i] , ans-till-that-string> .\\n        for(int i=0;i<n;i++)\\n        {\\n            int size=words[i].size();\\n            V[size].push_back({words[i],1});    //  find size of word[i] and push at V[size] with initiall answer 1.\\n        }\\n        \\n        int ans=1;           //   maintaining the longest string chain.\\n        \\n        for(int i=2;i<=16;i++)       \\n        {   // trying to compute answer of i length string from i-1 length string.\\n            for(int j=0;j<V[i].size();j++)   // iterate over i length string.\\n            {\\n                for(int k=0;k<V[i-1].size();k++)   // iterate over i-1 length string.\\n                {\\n                    bool isMatch=Match(V[i][j].first,V[i-1][k].first);   // check if i length string is predecessor of i-1 length string or not.\\n                    if(isMatch==true)         // if yess then,\\n                    {\\n                        int val=1+V[i-1][k].second;\\n                        V[i][j].second=max(V[i][j].second,val);     //Computed answer from i-1 string  put in second part(int part) of V[i][j].\\n                        ans=max(ans,V[i][j].second);     // maintaining the max ot longest string chain.\\n                    }\\n                    else        // if No then maintianing the answer only.\\n                    {\\n                        ans=max(ans,V[i][j].second);   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;       //  return the longest string chain.\\n        \\n    }\\n};\\n\\n\\n**Time Complexity = O(N^2)**\\n**Space Complexity = O(N), Where N is length of  vector word.**\\n\\n**IF FIND IT HELPFULL PLEASE SHARE IT AND UPVOTE.**",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\n    \\n    bool Match(string s1, string s2)\\n    { \\n\\t    // This function check wheter string s1 is predecessor of s2 or not using two pointer approach.\\n        int val=0;\\n        int n=s1.size(),m=s2.size();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s1[i]!=s2[j] && val>0)\\n            {\\n                return false;                // if more than one charcter are different not predecessor so return false.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1215980,
                "title": "c-top-down-dp-with-memo-bonus-tle-bfs-solution",
                "content": "**Top Down DP Solution**\\nTime Complexity: O(N * S)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int longestChainLen = 1;\\n        sort(begin(words), end(words), [] (string &a, string &b) { return a.size() < b.size(); });\\n        int memo[1001];\\n        memset(memo, -1, sizeof(memo));\\n        // For all words, start dfs\\n        for (int i = 0; i < words.size(); i++) {\\n            longestChainLen = max(dfs(i, words, memo), longestChainLen);\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    int dfs(int prev, vector<string> &words, int memo[]) {\\n        if (memo[prev] != -1) {\\n            return memo[prev];\\n        }\\n        int answer = 1;\\n        for (int i = prev + 1; i < words.size(); i++) {\\n            if (words[i].size() - words[prev].size() > 1) {\\n                break;\\n            }\\n            if ((words[prev].size() + 1) == words[i].size() && isBPredecessorOfA(words[prev], words[i])) {\\n                answer = max(1 + dfs(i, words, memo), answer);\\n            }\\n        }\\n        // memoize the result\\n        memo[prev] = answer;\\n        return answer;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**BFS Solution GOT TLE**\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<vector<string>> map(17);\\n        int longestChainLen = 1;\\n        queue<pair<string, int>> todo;\\n        for (string &word : words) {\\n            map[word.size()].push_back(word);\\n            todo.push({word, 1});\\n        }\\n        while (!todo.empty()) {\\n            pair<string, int> cur = todo.front();\\n            todo.pop();\\n            longestChainLen = max(longestChainLen, cur.second);\\n            if (cur.first.size() + 1 < map.size()) {\\n                for (string &possiblePredecessor : map[cur.first.size() + 1]) {\\n                    if (isBPredecessorOfA(cur.first, possiblePredecessor)) {\\n                        todo.push({possiblePredecessor, cur.second + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int longestChainLen = 1;\\n        sort(begin(words), end(words), [] (string &a, string &b) { return a.size() < b.size(); });\\n        int memo[1001];\\n        memset(memo, -1, sizeof(memo));\\n        // For all words, start dfs\\n        for (int i = 0; i < words.size(); i++) {\\n            longestChainLen = max(dfs(i, words, memo), longestChainLen);\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    int dfs(int prev, vector<string> &words, int memo[]) {\\n        if (memo[prev] != -1) {\\n            return memo[prev];\\n        }\\n        int answer = 1;\\n        for (int i = prev + 1; i < words.size(); i++) {\\n            if (words[i].size() - words[prev].size() > 1) {\\n                break;\\n            }\\n            if ((words[prev].size() + 1) == words[i].size() && isBPredecessorOfA(words[prev], words[i])) {\\n                answer = max(1 + dfs(i, words, memo), answer);\\n            }\\n        }\\n        // memoize the result\\n        memo[prev] = answer;\\n        return answer;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<vector<string>> map(17);\\n        int longestChainLen = 1;\\n        queue<pair<string, int>> todo;\\n        for (string &word : words) {\\n            map[word.size()].push_back(word);\\n            todo.push({word, 1});\\n        }\\n        while (!todo.empty()) {\\n            pair<string, int> cur = todo.front();\\n            todo.pop();\\n            longestChainLen = max(longestChainLen, cur.second);\\n            if (cur.first.size() + 1 < map.size()) {\\n                for (string &possiblePredecessor : map[cur.first.size() + 1]) {\\n                    if (isBPredecessorOfA(cur.first, possiblePredecessor)) {\\n                        todo.push({possiblePredecessor, cur.second + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213689,
                "title": "rust-dp-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_cached_key(String::len);\\n        let mut hm = HashMap::new();\\n        let mut answer = 0;\\n        for word in &words {\\n            let max = (0..word.len())\\n                .filter_map(|i| hm.get(&(String::new() + &word[0..i] + &word[i + 1..])))\\n                .max()\\n                .unwrap_or(&0)\\n                + 1;\\n            hm.insert(word, max);\\n            answer = answer.max(max);\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_cached_key(String::len);\\n        let mut hm = HashMap::new();\\n        let mut answer = 0;\\n        for word in &words {\\n            let max = (0..word.len())\\n                .filter_map(|i| hm.get(&(String::new() + &word[0..i] + &word[i + 1..])))\\n                .max()\\n                .unwrap_or(&0)\\n                + 1;\\n            hm.insert(word, max);\\n            answer = answer.max(max);\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876260,
                "title": "explained-solution-using-graph-dfs-and-memoization",
                "content": "**Approach**\\n\\n1. Build a dictionary for words of same length (Idea is a word can be a predecessor if the len of the word is  greater than the previous word). Dictionary helps in faster access\\n2. Function to check if the words is a predecessor\\n3. Using the above function build a graph. Use the length dictionary to get only words one greater than current word\\n4. Finally apply dfs with memoization to get the longest path\\n\\nGraph for the example [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n{u\\'a\\': [u\\'ba\\'], u\\'b\\': [u\\'ba\\'], u\\'bda\\': [u\\'bdca\\'], u\\'ba\\': [u\\'bca\\', u\\'bda\\'], u\\'bca\\': [u\\'bdca\\']})\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        len_dict = defaultdict(list)\\n        for word in words:\\n            len_dict[len(word)].append(word)\\n        \\n        graph = defaultdict(list)\\n        \\n        \\n        def is_pre(word1, word2):\\n            i, j = 0, 0\\n            found = False\\n            while i < len(word1) and j < len(word2):\\n                if word1[i] != word2[j]:\\n                    if found:\\n                        return False\\n                    else:\\n                        found = True\\n                        j += 1\\n                        continue\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        for word in words:\\n            for word1 in len_dict[len(word) + 1]:\\n                if is_pre(word, word1):\\n                    graph[word].append(word1)\\n        \\n        self.hash_map = {}\\n        def dfs(word):\\n            count = 0\\n            if word in self.hash_map:\\n                return self.hash_map[word]\\n            for word1 in graph[word]:\\n                count = max(count, 1 + dfs(word1))\\n            \\n            self.hash_map[word] = count\\n            return count\\n        ans = 0\\n        for word in words:\\n            ans = max(ans, 1 + dfs(word))\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Graph",
                    "Memoization"
                ],
                "code": "class Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        len_dict = defaultdict(list)\\n        for word in words:\\n            len_dict[len(word)].append(word)\\n        \\n        graph = defaultdict(list)\\n        \\n        \\n        def is_pre(word1, word2):\\n            i, j = 0, 0\\n            found = False\\n            while i < len(word1) and j < len(word2):\\n                if word1[i] != word2[j]:\\n                    if found:\\n                        return False\\n                    else:\\n                        found = True\\n                        j += 1\\n                        continue\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        for word in words:\\n            for word1 in len_dict[len(word) + 1]:\\n                if is_pre(word, word1):\\n                    graph[word].append(word1)\\n        \\n        self.hash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 799977,
                "title": "clean-java-solutions-faster-than-90",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int longest = 1;\\n        HashMap<String, Integer> word_max = new HashMap<String, Integer>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        for(int i = 0;i < words.length;++i) {\\n            String word = words[i];\\n            int longer = 1;\\n            for(int j = 0;j < word.length();++j) {\\n                String last = new StringBuilder(word).deleteCharAt(j).toString();\\n                longer = Math.max(longer, word_max.getOrDefault(last, 0) + 1);\\n            }\\n            word_max.put(word, longer);\\n            longest = Math.max(longest, longer);\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int longest = 1;\\n        HashMap<String, Integer> word_max = new HashMap<String, Integer>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        for(int i = 0;i < words.length;++i) {\\n            String word = words[i];\\n            int longer = 1;\\n            for(int j = 0;j < word.length();++j) {\\n                String last = new StringBuilder(word).deleteCharAt(j).toString();\\n                longer = Math.max(longer, word_max.getOrDefault(last, 0) + 1);\\n            }\\n            word_max.put(word, longer);\\n            longest = Math.max(longest, longer);\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600656,
                "title": "optimal-python-solution-in-11-lines-thought-process",
                "content": "The key idea here is that we can think of all the words we have, as a **directed graph, where each node represents a word, and each node points to all nodes that are just one deletion away.**\\n\\nSo in the first test case we\\'ll have \"bdca\" pointing to both [bca,bda] because we can reach both strings by removing one character from \"bdca\".\\n\\nWe can then think of the problem as trying to find the longest path in the graph. This can be achieved by doing N dfs-s starting from each node, and taking the max path from each source node.\\n\\nThe problem with this approach is that we\\'re repeating so much work. If we visited \"ba\" for instance in the dfs starting from \"bca\", and then visited it again in the dfs starting from \"bda\", we\\'ll be repeating the same work for \"ba\". \\n\\nThis brings up the idea of using memoization. Why not build a memo with longest path starting from each node. We can even build on this idea and argue that we don\\'t need to build a graph at all. We can just simply simulate a DFS without building a graph.\\n\\n**The overall time complexity will be O(NLL) where L is the length of the longest string.**\\nWe\\'re basically filling up the memo for N words using recursive calls, and each call does O(L^2) work to generate the potential child words.\\n\\nSpace complexity is just O(NL) as we\\'re basically storing all words.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo={}\\n        words=set(words)\\n        def longestChain(word):\\n            if not word in memo:\\n                memo[word]=1\\n                for i in range(len(word)):\\n                    child=word[:i]+word[i+1:]\\n                    if child in words:\\n                        memo[word]=max(memo[word],longestChain(child)+1)\\n            return memo[word]\\n        return max(longestChain(word) for word in words) #start DFS from each word\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo={}\\n        words=set(words)\\n        def longestChain(word):\\n            if not word in memo:\\n                memo[word]=1\\n                for i in range(len(word)):\\n                    child=word[:i]+word[i+1:]\\n                    if child in words:\\n                        memo[word]=max(memo[word],longestChain(child)+1)\\n            return memo[word]\\n        return max(longestChain(word) for word in words) #start DFS from each word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434604,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## DP,   TC: O(n*k) k is the lenght of each word.    SC: O(n)\\n        if not words:\\n            return 0\\n        \\n        words = sorted(words, key=len)\\n  \\n        dic = {}\\n        n = len(words)\\n        dp = [0] * n\\n        for i in range(n):\\n            cur = words[i]\\n            l = len(cur)\\n           \\n            cnt = float(\\'-inf\\')\\n            for j in range(l):\\n                tmp = cur[:j]+cur[j+1:]\\n               \\n                if tmp in dic:\\n                    cnt = max(cnt, dic[tmp]+1)\\n            if cnt == float(\\'-inf\\'):\\n                cnt = 1\\n            dp[i] = cnt\\n            dic[cur] = cnt\\n        \\n        return max(dp)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## DP,   TC: O(n*k) k is the lenght of each word.    SC: O(n)\\n        if not words:\\n            return 0\\n        \\n        words = sorted(words, key=len)\\n  \\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 413348,
                "title": "easiest-solution-available-on-internet-dfs-memo",
                "content": "It is always easy to think in terms of recursion then write pseudo code of it, whenever there is an optimal substructure just use some extra space to avoid recomputation.\\nHere the approach is to find the largest length possible starting with any word and maintain a global ans.\\nSo, we start with every word with initial length 1, one by one remove every character at ith location (one at a time) and if the new word is present in the dictionary we recur with this new word to find max length possible with this word and add 1 to the existing word\\'s ans, also taking max for every recursion.\\n\\n->function and DS used\\nmemo is used to find longest length starting with any word;\\nm is used to memorize {string, length} for every string;\\nunordered_set s is used to ans query for new string in O(1) time.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> m;\\n    unordered_set<string> s;\\n    \\n    int memo(string a){\\n        if(m.count(a)) return m[a];\\n        int ans=1;\\n        for(int i=0;i<a.length();i++){\\n            string tmp=a;\\n            tmp.erase(i,1);\\n            if(s.count(tmp))\\n                ans = max(ans,1+memo(tmp));\\n        }\\n        m[a]=ans;\\n        return m[a];\\n    }\\n    \\n    int longestStrChain(vector<string>& w) {\\n        m.clear(); s.clear();int ans = 0;\\n        for(int i=0;i<w.size();i++) s.insert(w[i]);\\n        for(int i=0;i<w.size();i++) ans = max(memo(w[i]), ans);            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> m;\\n    unordered_set<string> s;\\n    \\n    int memo(string a){\\n        if(m.count(a)) return m[a];\\n        int ans=1;\\n        for(int i=0;i<a.length();i++){\\n            string tmp=a;\\n            tmp.erase(i,1);\\n            if(s.count(tmp))\\n                ans = max(ans,1+memo(tmp));\\n        }\\n        m[a]=ans;\\n        return m[a];\\n    }\\n    \\n    int longestStrChain(vector<string>& w) {\\n        m.clear(); s.clear();int ans = 0;\\n        for(int i=0;i<w.size();i++) s.insert(w[i]);\\n        for(int i=0;i<w.size();i++) ans = max(memo(w[i]), ans);            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407071,
                "title": "java-trie-solution-47ms",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> b.length()-a.length());\\n        int max = 0;\\n        Trie t = new Trie();\\n\\n        for (String w : words) {\\n            int cur = 1 + t.find(w, 0, false);\\n            t.addWord(w, 0, cur);\\n            max = Math.max(max, cur);\\n        }\\n\\n        return max;\\n    }\\n\\n    class Trie {\\n        Trie[] next = new Trie[26];\\n        boolean end = false;\\n        int chain = 0;\\n\\n        void addWord(String w, int pos, int chain) {\\n            if (pos == w.length()) {\\n                end = true;\\n                this.chain = chain;\\n                return;\\n            }\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] == null) next[c - \\'a\\'] = new Trie();\\n            next[c - \\'a\\'].addWord(w, pos+1, chain);\\n        }\\n\\n        int find(String w, int pos, boolean added) {\\n            if (pos == w.length() && added) return chain;\\n\\n            int max = 0;\\n            for (int i = 0; i < 26 && !added; i++) {\\n                if (next[i] == null) continue;\\n                max = Math.max(max, next[i].find(w, pos, true));\\n            }\\n\\n            if (pos == w.length()) return max;\\n\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] != null) max = Math.max(max, next[c - \\'a\\'].find(w, pos+1, added));\\n            return max;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> b.length()-a.length());\\n        int max = 0;\\n        Trie t = new Trie();\\n\\n        for (String w : words) {\\n            int cur = 1 + t.find(w, 0, false);\\n            t.addWord(w, 0, cur);\\n            max = Math.max(max, cur);\\n        }\\n\\n        return max;\\n    }\\n\\n    class Trie {\\n        Trie[] next = new Trie[26];\\n        boolean end = false;\\n        int chain = 0;\\n\\n        void addWord(String w, int pos, int chain) {\\n            if (pos == w.length()) {\\n                end = true;\\n                this.chain = chain;\\n                return;\\n            }\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] == null) next[c - \\'a\\'] = new Trie();\\n            next[c - \\'a\\'].addWord(w, pos+1, chain);\\n        }\\n\\n        int find(String w, int pos, boolean added) {\\n            if (pos == w.length() && added) return chain;\\n\\n            int max = 0;\\n            for (int i = 0; i < 26 && !added; i++) {\\n                if (next[i] == null) continue;\\n                max = Math.max(max, next[i].find(w, pos, true));\\n            }\\n\\n            if (pos == w.length()) return max;\\n\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] != null) max = Math.max(max, next[c - \\'a\\'].find(w, pos+1, added));\\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088978,
                "title": "simple-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int longestStrChain(String[] words)\\n    {\\n       Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n\\n        int maxChain = 1;\\n        \\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                StringBuilder temp = new StringBuilder(word);\\n                String prev = temp.deleteCharAt(i).toString();\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            maxChain = Math.max(maxChain, best);\\n        }\\n        \\n        return maxChain;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/4ae9f82f-a6fa-435e-8971-5104f3e398d7_1695651227.4338148.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public static int longestStrChain(String[] words)\\n    {\\n       Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n\\n        int maxChain = 1;\\n        \\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                StringBuilder temp = new StringBuilder(word);\\n                String prev = temp.deleteCharAt(i).toString();\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            maxChain = Math.max(maxChain, best);\\n        }\\n        \\n        return maxChain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152918,
                "title": "python-dp-o-16-2-n",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = defaultdict(int)\\n        for w in sorted(words,key=len):\\n            dp[w] = max( dp[w[:i]+w[i+1:]] + 1 for i in range(len(w)))\\n        return max(dp.values())",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = defaultdict(int)\\n        for w in sorted(words,key=len):\\n            dp[w] = max( dp[w[:i]+w[i+1:]] + 1 for i in range(len(w)))\\n        return max(dp.values())",
                "codeTag": "Java"
            },
            {
                "id": 1213800,
                "title": "longest-string-chain-c-commented",
                "content": "**CODE:**\\n```\\nclass Solution {\\npublic:\\n    bool isSubseq(string &s1, string &s2){\\n        // to check whether s1 is subsequence of s2\\n        int i=0,j=0;\\n        while(i<s1.length() and j<s2.length())\\n        {\\n            if(s1[i]==s2[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        return (i==s1.length());\\n    }\\n    \\n    // written a function to sort the words vector according to the length\\n    static bool bylength(string &s1, string &s2){\\n        return s1.length()<s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        sort(words.begin(), words.end(), bylength);\\n        \\n        int res=1; // since every word will form a chain of itself so when no chain forms answer would be 1\\n        int longestBeforeHere[n];  // array to store the longest chain formed before the ith point (and including it) at index i\\n        longestBeforeHere[0] = 1;  // every word forms 1 length chain\\n    \\n        for(int i=1;i<words.size();i++){\\n            int curr=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(words[i].length()==words[j].length()+1 and isSubseq(words[j],words[i])) // condition to increase chain size\\n                    curr=max(curr,longestBeforeHere[j]+1); // update the length of longest chain starting with i and before it\\n            }\\n            longestBeforeHere[i]=curr; // we store the value of curr at ith index for future use\\n            res=max(res,curr); // every time we update res by finding the final maximum value\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubseq(string &s1, string &s2){\\n        // to check whether s1 is subsequence of s2\\n        int i=0,j=0;\\n        while(i<s1.length() and j<s2.length())\\n        {\\n            if(s1[i]==s2[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        return (i==s1.length());\\n    }\\n    \\n    // written a function to sort the words vector according to the length\\n    static bool bylength(string &s1, string &s2){\\n        return s1.length()<s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        sort(words.begin(), words.end(), bylength);\\n        \\n        int res=1; // since every word will form a chain of itself so when no chain forms answer would be 1\\n        int longestBeforeHere[n];  // array to store the longest chain formed before the ith point (and including it) at index i\\n        longestBeforeHere[0] = 1;  // every word forms 1 length chain\\n    \\n        for(int i=1;i<words.size();i++){\\n            int curr=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(words[i].length()==words[j].length()+1 and isSubseq(words[j],words[i])) // condition to increase chain size\\n                    curr=max(curr,longestBeforeHere[j]+1); // update the length of longest chain starting with i and before it\\n            }\\n            longestBeforeHere[i]=curr; // we store the value of curr at ith index for future use\\n            res=max(res,curr); // every time we update res by finding the final maximum value\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428354,
                "title": "python-2-approaches-dfs-memo-dp-with-complexity-analysis",
                "content": "**1. DFS + Memo**\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def helper(memo, set, w):\\n            if w in memo: return memo[w]\\n            count = 0\\n            for i in range(len(w)):\\n                pre = w[:i] + w[i+1:]\\n                if pre in s:\\n                    count = max(count, helper(memo, s, pre))\\n            memo[w] = 1 + count\\n            return 1 + count\\n\\n        ans = 0\\n        memo = {}\\n        s = set()\\n        for w in words: s.add(w)\\n        for w in words:\\n            ans = max(ans, helper(memo, s, w))\\n        return ans\\n```\\n* Time: O(N + N * M^2), where N is length of `words` and M is the average length of each word.\\n* Space: O(N)\\n\\n**2. DP**\\n\\n**Algorithm:**\\n\\n*define a dictionary: `d = {word: longest length of its string chain}`\\n* sort the input array `words` by length\\n* For each word\\n\\t* generating its all possible predecessor (a shorter word with exactly one letter missing)\\n\\t* if one of the predecessor already exsit in the dp array, which means we already calculated the longest string chain for its precessor, we add the current word to the word chain by increament the length of the longest string chain by 1. \\n\\t* We do this for all the predecessor of the current word. i.e. we update the longest string chain of each branch (each predecessor) for the current word by adding the current word. \\n\\t*The longest string chain for current word is the maximum of the longest string chains of all branches. \\n\\n* we can find the word with the longest string chain by calling dp[-1], no, just kidding, by finding the largest value in this dictionary, which is the longest string chain existing in `words`.\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key = len):\\n            maxLen = 0\\n            for i in range(len(w)):\\n                predecessor = w[:i] + w[i+1:]\\n                maxLen = max(maxLen, dp.get(predecessor, 0) + 1)\\n            dp[w] = maxLen\\n        return max(dp.values())\\n```\\n**Complexity (Updated) :**\\n* Time: O(N log N + N * M^2 ): **<--- Correct**\\n\\t* O(NlogN) for sorting `words`.  (just sorted once and we\\'re done)\\n\\t* O(N) for looping throught the sorted array\\n\\t\\t* for each word, for all possible position `i` in this word (O(M))\\n\\t\\t\\t* forming all possible predecessor by using string slicing function [i:] and [i+1:], either of them has time cost of O(L) where L is the length of the slice, and together they cost O(M)\\n\\t* ==> O(NlogN) + O(N * M * M)  ==> O(N log N + N * M^2)\\n* Time: O(N log N * M): **<--- Incorrect**\\n\\t  O(NlogN) for sorting `words`. \\n\\t  O(M) for forming all possible predecessor for each word. \\n\\t  \\n* Space: O(N * M) sorted() function returns a newly created list which has N words in it and each word has an average length of M.\\n\\n**Takeaways:**\\n* find optimal subproblems first. \\n\\t* Find my previous word\\'s longest string chain length, the current longest string chain length of my predecessor if I was added to the chain is my predecessor\\'s longest string chain length plus 1. \\n\\t* How many predescessors do I have?  My longest string chain length is the maximum among all of my predescessors\\u2019 longest longest string chain lengths.\\n\\n* think about when to use dp array, when to use dp diction\\n\\t* dp array: \\n\\t\\t* 1D for liner data structure or optimized matrix problem\\n\\t\\t* 2D for sub-optimal matrix problem\\n\\t* dp dictionary:\\n\\t\\t* rememer when you first learn the word `whose`? Use dp array when the meaning of `whose` appied to the problem. For example, you have a element and its attributes and you want to find the optimal solution of this attribute by first finding the optimal solution of a(or many) sub-problem(s) of this element, i.e. the optimal (longest string chain) length(s) for all of its predecessor(s)\\n\\n------------\\n**Longest Increasing Subsequence:** \\n\\nIntuitively similar to other DP problems (longest increasing subsequence, etc). \\nhttps://leetcode.com/problems/longest-increasing-subsequence/discuss/429079/Python-4-Approaches%3A-Recursion-Recur-%2B-Memo-DP-DP-%2B-Binary-Search\\n\\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        dp = {}\\n        for i, num in enumerate(nums):\\n            maxLongest = 1\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    curLongest = dp.get(nums[j], 0) + 1\\n                    maxLongest = max(maxLongest, curLongest)\\n            dp[num] = maxLongest\\n        return max(dp.values())\\n```\\n* Time: O(N^2)\\n* Space: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def helper(memo, set, w):\\n            if w in memo: return memo[w]\\n            count = 0\\n            for i in range(len(w)):\\n                pre = w[:i] + w[i+1:]\\n                if pre in s:\\n                    count = max(count, helper(memo, s, pre))\\n            memo[w] = 1 + count\\n            return 1 + count\\n\\n        ans = 0\\n        memo = {}\\n        s = set()\\n        for w in words: s.add(w)\\n        for w in words:\\n            ans = max(ans, helper(memo, s, w))\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key = len):\\n            maxLen = 0\\n            for i in range(len(w)):\\n                predecessor = w[:i] + w[i+1:]\\n                maxLen = max(maxLen, dp.get(predecessor, 0) + 1)\\n            dp[w] = maxLen\\n        return max(dp.values())\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        dp = {}\\n        for i, num in enumerate(nums):\\n            maxLongest = 1\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    curLongest = dp.get(nums[j], 0) + 1\\n                    maxLongest = max(maxLongest, curLongest)\\n            dp[num] = maxLongest\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384701,
                "title": "1048-longest-string-chain-javascript-lee215-80ms",
                "content": "```js\\nvar longestStrChain = function(words) {\\n    let map = new Map();\\n    let res = 0;\\n    words.sort((a, b) => a.length - b.length);\\n\\n    for(let word of words){\\n        let level = 1;\\n        for(let i = 0; i < word.length; i++){\\n            let prev = word.slice(0, i) + word.slice(i + 1);\\n            if(map.has(prev)){\\n                level = map.get(prev) + 1;\\n                break;\\n            } \\n        }\\n        map.set(word, level);\\n        res = Math.max(res, level);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nvar longestStrChain = function(words) {\\n    let map = new Map();\\n    let res = 0;\\n    words.sort((a, b) => a.length - b.length);\\n\\n    for(let word of words){\\n        let level = 1;\\n        for(let i = 0; i < word.length; i++){\\n            let prev = word.slice(0, i) + word.slice(i + 1);\\n            if(map.has(prev)){\\n                level = map.get(prev) + 1;\\n                break;\\n            } \\n        }\\n        map.set(word, level);\\n        res = Math.max(res, level);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294900,
                "title": "another-kind-of-lis-problem",
                "content": "The method of processing strings is inspired by [word ladder](https://leetcode.com/problems/word-ladder/)\\nfirst we sort the words by length, then it becomes a LIS problem.\\n\\nfor example, s = \\'bca\\'\\nwe can add one letter to make it be the form of `_bca, b_ca, bc_a, bca_` (`_` represents the added letter)\\n\\nfor s = \\'bca\\', we can find last element by the form of `_ca, b_a, _ca`\\n\\n```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        words.sort(key=lambda x:len(x))\\n        d = collections.defaultdict(list)\\n        for index, word in enumerate(words):\\n            for i in range(len(word)+1):\\n                s = word[:i] + \\'_\\' + word[i:]\\n                d[s].append(index)\\n        \\n        n = len(words)\\n        dp = [1] * n\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                s = word[:j] + \\'_\\' + word[j+1:]\\n                if s in d:\\n                    for index in d[s]:\\n                        if index >= i: break\\n                        dp[i] = max(dp[i], dp[index]+1)\\n        return max(dp)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        words.sort(key=lambda x:len(x))\\n        d = collections.defaultdict(list)\\n        for index, word in enumerate(words):\\n            for i in range(len(word)+1):\\n                s = word[:i] + \\'_\\' + word[i:]\\n                d[s].append(index)\\n        \\n        n = len(words)\\n        dp = [1] * n\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                s = word[:j] + \\'_\\' + word[j+1:]\\n                if s in d:\\n                    for index in d[s]:\\n                        if index >= i: break\\n                        dp[i] = max(dp[i], dp[index]+1)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078898,
                "title": "java-dynamic-programming-explanation-time-o-n-k-space-o-n-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The longest word chain problem can be solved efficiently using dynamic programming.\\n- We can sort the words by their lengths, ensuring that shorter words are processed before longer ones.\\n- For each word, we iterate through its characters and try to build word chains by removing one character at a time.\\n- We maintain a HashMap (`dp`) to store the longest chain length for each word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the `words` array by length, ensuring shorter words come first.\\n2. Initialize a HashMap `dp` to store word-to-length relationships.\\n3. Initialize `maxPath` to 1, representing the maximum chain length.\\n4. Iterate through each word in the sorted array.\\n5. For each word, iterate through its characters and create potential predecessor words by removing characters.\\n6. Calculate the current word\\'s chain length (`currLength`) by comparing it with its predecessor\\'s chain length.\\n7. Update currLength using `Math.max` to find the maximum chain length for the current word.\\n8. Store the current word and its chain length in the `dp` HashMap\\n9. Update `maxPath` if `currLength` is greater than the `current maxPath`.\\n10. After processing all words, return `maxPath` as the length of the longest word chain.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Sorting the words array takes `O(n log n)`, where n is the number of words.\\n- Iterating through the words and characters takes `O(n * k)`, where k is the average word length.\\n- Overall, the time complexity is `O(n * k + n log n)`, which simplifies to `O(n * k)`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is `O(n)` for the dp HashMap, where `n` is the number of words.\\n- Additional space is used for variables like `maxPath`.\\n- Overall, the space complexity is `O(n)`.\\n\\n***Youtube Solution Link:***\\n\\n[https://youtu.be/HnePYVbw9Jo]()\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Step 1: Sort the words array by length.\\n        Arrays.sort(words, (String a, String b) -> a.length() - b.length());\\n\\n        // Step 2: Create a HashMap to store word-to-length relationships.\\n        Map<String, Integer> dp = new HashMap<>();\\n\\n        // Initialize the maximum path length to 1 (a single word).\\n        int maxPath = 1;\\n\\n        // Step 3: Iterate through the words.\\n        for (String word : words) {\\n            int currLength = 1; // Initialize the current word length to 1.\\n            StringBuilder sb = new StringBuilder(word);\\n\\n            // Step 4: Iterate through each character of the current word.\\n            for (int i = 0; i < word.length(); i++) {\\n                sb.deleteCharAt(i); // Remove the current character.\\n                String prevWord = sb.toString(); // Get the predecessor word.\\n\\n                // Update the current word length using dynamic programming.\\n                currLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1);\\n\\n                // Restore the original word for the next iteration.\\n                sb.insert(i, word.charAt(i));\\n            }\\n\\n            // Step 5: Store the current word and its calculated length in the map.\\n            dp.put(word, currLength);\\n\\n            // Update the maximum path length if necessary.\\n            maxPath = Math.max(maxPath, currLength);\\n        }\\n\\n        // Step 6: Return the maximum path length.\\n        return maxPath;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Step 1: Sort the words array by length.\\n        Arrays.sort(words, (String a, String b) -> a.length() - b.length());\\n\\n        // Step 2: Create a HashMap to store word-to-length relationships.\\n        Map<String, Integer> dp = new HashMap<>();\\n\\n        // Initialize the maximum path length to 1 (a single word).\\n        int maxPath = 1;\\n\\n        // Step 3: Iterate through the words.\\n        for (String word : words) {\\n            int currLength = 1; // Initialize the current word length to 1.\\n            StringBuilder sb = new StringBuilder(word);\\n\\n            // Step 4: Iterate through each character of the current word.\\n            for (int i = 0; i < word.length(); i++) {\\n                sb.deleteCharAt(i); // Remove the current character.\\n                String prevWord = sb.toString(); // Get the predecessor word.\\n\\n                // Update the current word length using dynamic programming.\\n                currLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1);\\n\\n                // Restore the original word for the next iteration.\\n                sb.insert(i, word.charAt(i));\\n            }\\n\\n            // Step 5: Store the current word and its calculated length in the map.\\n            dp.put(word, currLength);\\n\\n            // Update the maximum path length if necessary.\\n            maxPath = Math.max(maxPath, currLength);\\n        }\\n\\n        // Step 6: Return the maximum path length.\\n        return maxPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078838,
                "title": "easy-to-understand-memoization-solution-beginner-friendly-explanation",
                "content": "![Screenshot 2023-09-23 085712.png](https://assets.leetcode.com/users/images/980754f8-f5fa-4fe8-ba39-1a7a80353b8b_1695439652.8564568.png)\\n# Intuition\\nInstead of Additive approach (i.e., add characters one by one), we will try to do Subtractive approach (take the larger word and remove one)\\n\\n# Approach\\nIt explores word chains by removing one character at a time, checking if the resulting word is in the list, and stores computed results to avoid redundant calculations.\\n\\n# Complexity\\n- Time complexity:\\nWorst Case : $$O(n*m^2)$$\\nBest Case : $$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int length(string word, unordered_set<string>& s, unordered_map<string, int>& mp) {\\n        if (word.length() == 0) // checking if the word is \"\" i.e., empty string\\n            return 0;\\n        if (mp.find(word) != mp.end()) //Memoization using Map\\n            return mp[word];\\n        int answer = 0;\\n\\n        //Removing all characters of the word one by one\\n        for (int i = 0; i < word.length(); i++) {\\n            string aux = word.substr(0, i) + word.substr(i + 1);\\n            //Removing character\\n            //ex - abcd --> aux =  abcd.substr(0, 0)+abcd.substr(1) -- \"\" + \"bcd\" = \"bcd\"\\n            if (s.find(aux) != s.end())\\n                answer = max(answer, 1 + length(aux, s, mp)); // Calling the function with the word with Removed character\\n        }\\n        mp[word] = answer;\\n        return answer;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        unordered_set<string> s;\\n        for (string x : words)\\n            s.insert(x);\\n        int ans = 0;\\n\\n        unordered_map<string, int> mp;\\n        // Checking for each word, taking it as last word.\\n        for (int i = 0; i < words.size(); i++) {\\n            string w = words[i];\\n            ans = max(ans, length(w, s, mp));\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(string word, unordered_set<string>& s, unordered_map<string, int>& mp) {\\n        if (word.length() == 0) // checking if the word is \"\" i.e., empty string\\n            return 0;\\n        if (mp.find(word) != mp.end()) //Memoization using Map\\n            return mp[word];\\n        int answer = 0;\\n\\n        //Removing all characters of the word one by one\\n        for (int i = 0; i < word.length(); i++) {\\n            string aux = word.substr(0, i) + word.substr(i + 1);\\n            //Removing character\\n            //ex - abcd --> aux =  abcd.substr(0, 0)+abcd.substr(1) -- \"\" + \"bcd\" = \"bcd\"\\n            if (s.find(aux) != s.end())\\n                answer = max(answer, 1 + length(aux, s, mp)); // Calling the function with the word with Removed character\\n        }\\n        mp[word] = answer;\\n        return answer;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        unordered_set<string> s;\\n        for (string x : words)\\n            s.insert(x);\\n        int ans = 0;\\n\\n        unordered_map<string, int> mp;\\n        // Checking for each word, taking it as last word.\\n        for (int i = 0; i < words.size(); i++) {\\n            string w = words[i];\\n            ans = max(ans, length(w, s, mp));\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276413,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//by dp and memorization\\n//tc=o(n*n) n=size of words\\n//sc=o(n*n)+o(n) n=stack space \\nint dp[1001][1001];\\n   \\n    bool cheak(string &s1,string &s2)\\n    {\\n        if(s1.size()==s2.size())  return false;\\n        if(s1.size()>s2.size()+1) return false;\\n         int i=0;\\n         int j=0;\\n        while(i<s1.size())\\n            if(j<s2.size() && s1[i]==s2[j])\\n                i++,j++;\\n            else\\n                i++;\\n        if(i==s1.size() && j==s2.size())\\n            return true;\\n        else\\n            return false;\\n    }\\n    int find(int i,int pre,vector<string>& words){\\n        if(i==-1){\\n            return 0;\\n        }\\n        if(dp[i][pre+1]!=-1){\\n            return dp[i][pre+1];\\n        }\\n        //take\\n        int take=0,not_take=0;\\n        if(pre==-1 || cheak(words[pre],words[i])==true){\\n            take=1+find(i-1,i,words);\\n        }\\n        //not take\\n        not_take=find(i-1,pre,words);\\n        return dp[i][pre+1]=max(take,not_take);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        memset(dp,-1,sizeof(dp));\\n        sort(words.begin(),words.end(),com);\\n        return find(n-1,-1,words);\\n    }\\n    private:\\n    static bool com(string& a,string& b){\\n        return a.size()<b.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//by dp and memorization\\n//tc=o(n*n) n=size of words\\n//sc=o(n*n)+o(n) n=stack space \\nint dp[1001][1001];\\n   \\n    bool cheak(string &s1,string &s2)\\n    {\\n        if(s1.size()==s2.size())  return false;\\n        if(s1.size()>s2.size()+1) return false;\\n         int i=0;\\n         int j=0;\\n        while(i<s1.size())\\n            if(j<s2.size() && s1[i]==s2[j])\\n                i++,j++;\\n            else\\n                i++;\\n        if(i==s1.size() && j==s2.size())\\n            return true;\\n        else\\n            return false;\\n    }\\n    int find(int i,int pre,vector<string>& words){\\n        if(i==-1){\\n            return 0;\\n        }\\n        if(dp[i][pre+1]!=-1){\\n            return dp[i][pre+1];\\n        }\\n        //take\\n        int take=0,not_take=0;\\n        if(pre==-1 || cheak(words[pre],words[i])==true){\\n            take=1+find(i-1,i,words);\\n        }\\n        //not take\\n        not_take=find(i-1,pre,words);\\n        return dp[i][pre+1]=max(take,not_take);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        memset(dp,-1,sizeof(dp));\\n        sort(words.begin(),words.end(),com);\\n        return find(n-1,-1,words);\\n    }\\n    private:\\n    static bool com(string& a,string& b){\\n        return a.size()<b.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661012,
                "title": "python-99-faster-88-less-memory",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        def one():\\n            return 1\\n        \\n        d = defaultdict(set)\\n        for w in words:\\n            d[len(w)].add(w)\\n        mi, ma = min(d.keys()), max(d.keys())\\n        m = defaultdict(one)\\n    \\n        for i in range(mi,ma):\\n            for nw in d[i+1]:\\n                for j in range(len(nw)):\\n                    w = nw[:j]+nw[j+1:]\\n                    if w in d[i]:\\n                        m[nw]  = max(m[nw], m[w]+1)\\n        return 1 if len(m) == 0 else max(m.values())\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        def one():\\n            return 1\\n        \\n        d = defaultdict(set)\\n        for w in words:\\n            d[len(w)].add(w)\\n        mi, ma = min(d.keys()), max(d.keys())\\n        m = defaultdict(one)\\n    \\n        for i in range(mi,ma):\\n            for nw in d[i+1]:\\n                for j in range(len(nw)):\\n                    w = nw[:j]+nw[j+1:]\\n                    if w in d[i]:\\n                        m[nw]  = max(m[nw], m[w]+1)\\n        return 1 if len(m) == 0 else max(m.values())\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2299864,
                "title": "java-solution-dp-based-on-longest-increasing-subsequence",
                "content": "The solution is same as Longest Increasing Subsequence Problem.\\nThe only change is in \\'if\\' statement\\n```\\nclass SortbyLen implements Comparator<String> { \\n    public int compare(String a, String b) \\n    { \\n        return a.length() - b.length(); \\n    } \\n} \\n\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr, new SortbyLen()); \\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int maxi = 1;\\n        Arrays.fill(dp , 1);\\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < i ; j++){\\n                if(compare(arr[i] , arr[j]) && dp[j] + 1 > dp[i])\\n                    dp[i] = dp[j] + 1;\\n            }\\n            if(dp[i] > maxi)\\n                maxi = dp[i];\\n        }\\n        return maxi;  \\n    }\\n    \\n    boolean compare(String s1 , String s2){\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        \\n        if(l1 != l2+1)\\n            return false;\\n        \\n        int f = 0;\\n        int s = 0;\\n        while(f < l1)\\n        {\\n            if(s < l2 && s1.charAt(f) == s2.charAt(s)){\\n                f = f+1;\\n                s = s+1;\\n            }\\n            else\\n                f = f+1;\\n        }\\n        \\n        if(f == l1 && s == l2)\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```\\nIf you like the solution,  then please UPVOTE :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass SortbyLen implements Comparator<String> { \\n    public int compare(String a, String b) \\n    { \\n        return a.length() - b.length(); \\n    } \\n} \\n\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr, new SortbyLen()); \\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int maxi = 1;\\n        Arrays.fill(dp , 1);\\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < i ; j++){\\n                if(compare(arr[i] , arr[j]) && dp[j] + 1 > dp[i])\\n                    dp[i] = dp[j] + 1;\\n            }\\n            if(dp[i] > maxi)\\n                maxi = dp[i];\\n        }\\n        return maxi;  \\n    }\\n    \\n    boolean compare(String s1 , String s2){\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        \\n        if(l1 != l2+1)\\n            return false;\\n        \\n        int f = 0;\\n        int s = 0;\\n        while(f < l1)\\n        {\\n            if(s < l2 && s1.charAt(f) == s2.charAt(s)){\\n                f = f+1;\\n                s = s+1;\\n            }\\n            else\\n                f = f+1;\\n        }\\n        \\n        if(f == l1 && s == l2)\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154197,
                "title": "c-easy-to-understand-well-explained-dp-daily-leetcoding-challenge-june-day-15",
                "content": "**Please Upvote If It Helps \\uD83D\\uDE0A\\u2764\\uFE0F**\\n\\n**Example-1:**\\n\\n```\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\nBefore any step we need to sort vector \\'words\\' on the basis of size of the string.\\nNow we cover we word in the vector one-by-one.\\n\\n1) word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2) word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3) word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\nHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4) word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5) word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6) word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4 which is the answer.\\n```\\n\\n```\\nclass Solution {\\npublic:  \\n    // do compariosn based on size\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        //it will store predecessor word and their chain size\\n        unordered_map<string, int> dp; \\n        \\n        //sort(words.begin(), words.end() based of the word size\\n        sort(words.begin(), words.end(), compare);\\n        \\n        // initially word chain size will be 1\\n        int len = 1; \\n        \\n        for(auto word:words)           // iterate over the given words \\n        {\\n            dp[word]=1;\\n            \\n            // check for the characters of current word\\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                // if it is available in dp then take that max len and go for next\\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = dp[pred]+1;                // updated\\n                    len = max(len, dp[word]);             // storing max one\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```\\n\\n\\n**Time Complexity:** O(Nlog(N) + NMM)\\nO(Nlog(N)) for **sorting**\\nO(NMM): N for 1st loop, M for inner loop and M for string concatenation.\\n\\n**Space Complexity:** O(N) for both storing strings in hashmap.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\nBefore any step we need to sort vector \\'words\\' on the basis of size of the string.\\nNow we cover we word in the vector one-by-one.\\n\\n1) word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2) word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3) word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\nHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4) word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5) word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6) word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4 which is the answer.\\n```\n```\\nclass Solution {\\npublic:  \\n    // do compariosn based on size\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        //it will store predecessor word and their chain size\\n        unordered_map<string, int> dp; \\n        \\n        //sort(words.begin(), words.end() based of the word size\\n        sort(words.begin(), words.end(), compare);\\n        \\n        // initially word chain size will be 1\\n        int len = 1; \\n        \\n        for(auto word:words)           // iterate over the given words \\n        {\\n            dp[word]=1;\\n            \\n            // check for the characters of current word\\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                // if it is available in dp then take that max len and go for next\\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = dp[pred]+1;                // updated\\n                    len = max(len, dp[word]);             // storing max one\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153514,
                "title": "c-clean-top-down-linq",
                "content": "```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n        {\\n            int longestChain = 0;\\n            for (int index = 0; index < word.Length; index++)\\n            {\\n                string predecessor = word[..index] + word[(index + 1)..];\\n                if (wordsAsHashSet.Contains(predecessor) is false) continue;\\n\\n                int chain = dp.ContainsKey(predecessor)\\n                    ? dp[predecessor]\\n                    : dp[predecessor] = GetLongestChain(predecessor);\\n\\n                if (chain > longestChain) longestChain = chain;\\n            }\\n\\n            return 1 + longestChain;\\n        }\\n    }\\n}\\n```\\n\\nWith LINQ\\n```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n            => 1 + Enumerable.Range(0, word.Length)\\n                    .Select(index => word[..index] + word[(index + 1)..])\\n                    .Where(predecessor => wordsAsHashSet.Contains(predecessor))\\n                    .Select(predecessor => dp.ContainsKey(predecessor) ? dp[predecessor] : dp[predecessor] = GetLongestChain(predecessor))\\n                    .Append(0)\\n                    .Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n        {\\n            int longestChain = 0;\\n            for (int index = 0; index < word.Length; index++)\\n            {\\n                string predecessor = word[..index] + word[(index + 1)..];\\n                if (wordsAsHashSet.Contains(predecessor) is false) continue;\\n\\n                int chain = dp.ContainsKey(predecessor)\\n                    ? dp[predecessor]\\n                    : dp[predecessor] = GetLongestChain(predecessor);\\n\\n                if (chain > longestChain) longestChain = chain;\\n            }\\n\\n            return 1 + longestChain;\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n            => 1 + Enumerable.Range(0, word.Length)\\n                    .Select(index => word[..index] + word[(index + 1)..])\\n                    .Where(predecessor => wordsAsHashSet.Contains(predecessor))\\n                    .Select(predecessor => dp.ContainsKey(predecessor) ? dp[predecessor] : dp[predecessor] = GetLongestChain(predecessor))\\n                    .Append(0)\\n                    .Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666395,
                "title": "python3",
                "content": "class Solution:\\n\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=lambda x: len(x))\\n        result=0\\n        mem={}\\n        for word in words:\\n            mem[word]=1\\n            for i in range(len(word)):\\n                trunc=word[:i]+word[i+1:]\\n                if trunc in mem:\\n                    mem[word]=max(mem[word],1+mem[trunc])\\n            result=max(result,mem[word])\\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=lambda x: len(x))\\n        result=0\\n        mem={}",
                "codeTag": "Java"
            },
            {
                "id": 1645553,
                "title": "java-dp-2-approaches-lis-memoization",
                "content": "**Solution 1 : Using Tabulation (LIS)**\\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        // Sort the words in the ascending order of their length\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());        \\n        int n = words.length;\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int max = 1;\\n        \\n        // Perform LIS\\n        for(int i=1; i < n; i++){\\n            dp[i] = 1;\\n            String currWord = words[i];\\n            for(int j=0; j < i; j++){\\n                String prevWord = words[j];\\n                // If curr word is of 1 length greater than prev word &&\\n                // LCS between curr and prev words is having length same as prev word\\n                // then we have a string chain of prev and curr word\\n                if((currWord.length() - prevWord.length() == 1) && \\n                   (prevWord.length() == lcs(prevWord, currWord)))\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n\\n    int lcs(String prev, String curr){\\n        int p = prev.length();\\n        int c = curr.length();\\n        int i=0, j=0;\\n        while(i < p && j < c){\\n            if(prev.charAt(i) == curr.charAt(j))\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }    \\n}\\n```\\n\\n<br/>\\n\\n**Solution 2: Using memoization**\\n\\n```\\nclass Solution {\\n    \\n    Map<Integer, List<String>> wordsListMap = new HashMap<>();\\n    \\n    public int longestStrChain(String[] words) {\\n        // Sort words[] by length\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        \\n\\t\\t// Keep track of all words on a particular length\\n        Map<String,Integer> map = new HashMap<>();\\n        for(String word : words){\\n            int len = word.length();\\n            wordsListMap.putIfAbsent(len, new ArrayList<>());\\n            wordsListMap.get(len).add(word);\\n        }\\n        \\n        int globalMax = 1;\\n\\t\\t\\n\\t\\t// Consider each word as the starting word of the longest sequence and find the max possible sequence for each.\\n\\t\\t// At the end update the globalMax, if the current longest sequence is greater than globalMax\\n        for(String word : words)\\n            globalMax = Math.max(globalMax, longest(word, map));\\n        return globalMax;\\n    }\\n    \\n    int longest(String word, Map<String,Integer> dp){\\n\\t\\t// If there are no words of length greater than current word length, \\n\\t\\t// then the maximum possible sequence for the current word is the current word itself, hence it is returning 1\\n        if(!wordsListMap.containsKey(word.length() + 1)) \\n            return 1;\\n        \\n        if(dp.containsKey(word))\\n            return dp.get(word);\\n        \\n\\t\\t// Fetch all words that are greater than 1 character and check if it is a successor then explore further\\n        List<String> words = wordsListMap.get(word.length() + 1);\\n        int max = 0;\\n        for(String curr : words){\\n            if(isSuccessor(word, curr))\\n                max = Math.max(max, longest(curr, dp));\\n        }\\n        \\n        dp.put(word, max + 1);\\n        return dp.get(word);\\n    }\\n    \\n    boolean isSuccessor(String word1, String word2){\\n        boolean firstTime = true;\\n        for(int i=0, j=0; i < word1.length() && j < word2.length(); j++){\\n            if(word1.charAt(i) != word2.charAt(j)) {\\n                if(firstTime){\\n                    firstTime = false;\\n                    continue;\\n                } else\\n                    return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        // Sort the words in the ascending order of their length\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());        \\n        int n = words.length;\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int max = 1;\\n        \\n        // Perform LIS\\n        for(int i=1; i < n; i++){\\n            dp[i] = 1;\\n            String currWord = words[i];\\n            for(int j=0; j < i; j++){\\n                String prevWord = words[j];\\n                // If curr word is of 1 length greater than prev word &&\\n                // LCS between curr and prev words is having length same as prev word\\n                // then we have a string chain of prev and curr word\\n                if((currWord.length() - prevWord.length() == 1) && \\n                   (prevWord.length() == lcs(prevWord, currWord)))\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n\\n    int lcs(String prev, String curr){\\n        int p = prev.length();\\n        int c = curr.length();\\n        int i=0, j=0;\\n        while(i < p && j < c){\\n            if(prev.charAt(i) == curr.charAt(j))\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }    \\n}\\n```\n```\\nclass Solution {\\n    \\n    Map<Integer, List<String>> wordsListMap = new HashMap<>();\\n    \\n    public int longestStrChain(String[] words) {\\n        // Sort words[] by length\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        \\n\\t\\t// Keep track of all words on a particular length\\n        Map<String,Integer> map = new HashMap<>();\\n        for(String word : words){\\n            int len = word.length();\\n            wordsListMap.putIfAbsent(len, new ArrayList<>());\\n            wordsListMap.get(len).add(word);\\n        }\\n        \\n        int globalMax = 1;\\n\\t\\t\\n\\t\\t// Consider each word as the starting word of the longest sequence and find the max possible sequence for each.\\n\\t\\t// At the end update the globalMax, if the current longest sequence is greater than globalMax\\n        for(String word : words)\\n            globalMax = Math.max(globalMax, longest(word, map));\\n        return globalMax;\\n    }\\n    \\n    int longest(String word, Map<String,Integer> dp){\\n\\t\\t// If there are no words of length greater than current word length, \\n\\t\\t// then the maximum possible sequence for the current word is the current word itself, hence it is returning 1\\n        if(!wordsListMap.containsKey(word.length() + 1)) \\n            return 1;\\n        \\n        if(dp.containsKey(word))\\n            return dp.get(word);\\n        \\n\\t\\t// Fetch all words that are greater than 1 character and check if it is a successor then explore further\\n        List<String> words = wordsListMap.get(word.length() + 1);\\n        int max = 0;\\n        for(String curr : words){\\n            if(isSuccessor(word, curr))\\n                max = Math.max(max, longest(curr, dp));\\n        }\\n        \\n        dp.put(word, max + 1);\\n        return dp.get(word);\\n    }\\n    \\n    boolean isSuccessor(String word1, String word2){\\n        boolean firstTime = true;\\n        for(int i=0, j=0; i < word1.length() && j < word2.length(); j++){\\n            if(word1.charAt(i) != word2.charAt(j)) {\\n                if(firstTime){\\n                    firstTime = false;\\n                    continue;\\n                } else\\n                    return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540030,
                "title": "c-dfs-dp-explained-with-diagrams",
                "content": "Created a map of length and corrosponding strings then iterated over all the strings and for **i**`th`  string tries to find its correct successor in the map of **length**  for `size = string.size() + 1`\\nand then it does a dfs repeating above step and ofc memoizes the sub problem while doing DFS \\n![image](https://assets.leetcode.com/users/images/a8b228d4-2cd4-4d2f-85b4-41a3b72037c8_1635165375.3149137.png)\\n![image](https://assets.leetcode.com/users/images/1e1f565a-2eff-42fe-8557-dc7343774cfe_1635166371.457233.png)![image](https://assets.leetcode.com/users/images/9c23c0f5-93f2-497b-bf68-8e23a21fa493_1635166774.0857623.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string , int> dp;\\n    unordered_map<int , vector<string>> length;\\n    int maxi = INT_MIN;\\n    \\n    bool check(string curr , string tocheck){\\n        int error=0,i=0,j=0;\\n        while(i < curr.length() && j < tocheck.length()){\\n            while(i < curr.length() && j < tocheck.length() &&curr[i] != tocheck[j]){\\n                error++;\\n                j++;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if(error == 1  || error == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(string curr , int tofind){\\n        \\n        int val=0;\\n         if(length.find(tofind) != length.end()){\\n            for(auto x : length[tofind]){\\n                if(check(curr , x)){\\n                    if(dp[x] > 1){\\n                    return dp[curr] += dp[x];\\n                   }\\n                    val = max(dfs(x , x.size()+1) , val);\\n                }\\n            }\\n         }\\n        return  dp[curr] += val;\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        sort(words.begin(), words.end(), [](const string &x, const string &y) {\\n            return x.size() < y.size();  \\n        });\\n        \\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            length[words[i].length()].push_back(words[i]);\\n            if(dp[words[i]] == 0){\\n                dp[words[i]] = 1;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(dp[words[i]] == 1){\\n                dfs(words[i] , words[i].size() + 1);\\n                maxi = max(dp[words[i]] , maxi);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string , int> dp;\\n    unordered_map<int , vector<string>> length;\\n    int maxi = INT_MIN;\\n    \\n    bool check(string curr , string tocheck){\\n        int error=0,i=0,j=0;\\n        while(i < curr.length() && j < tocheck.length()){\\n            while(i < curr.length() && j < tocheck.length() &&curr[i] != tocheck[j]){\\n                error++;\\n                j++;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if(error == 1  || error == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(string curr , int tofind){\\n        \\n        int val=0;\\n         if(length.find(tofind) != length.end()){\\n            for(auto x : length[tofind]){\\n                if(check(curr , x)){\\n                    if(dp[x] > 1){\\n                    return dp[curr] += dp[x];\\n                   }\\n                    val = max(dfs(x , x.size()+1) , val);\\n                }\\n            }\\n         }\\n        return  dp[curr] += val;\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        sort(words.begin(), words.end(), [](const string &x, const string &y) {\\n            return x.size() < y.size();  \\n        });\\n        \\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            length[words[i].length()].push_back(words[i]);\\n            if(dp[words[i]] == 0){\\n                dp[words[i]] = 1;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(dp[words[i]] == 1){\\n                dfs(words[i] , words[i].size() + 1);\\n                maxi = max(dp[words[i]] , maxi);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214748,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        \\n        if(words == null || words.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(words, (w1, w2) => w1.Length - w2.Length);\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        int maxLen = 0;\\n        foreach(var word in words)\\n        {     \\n            if(!dic.ContainsKey(word))\\n            {\\n                int currLen = 1;\\n                for(int i = 0; i < word.Length; i++)\\n                {\\n                    StringBuilder sb = new StringBuilder(word); \\n                    sb.Remove(i,1);\\n                    string modifiedWord = sb.ToString();\\n                    int modifiedLen = dic.ContainsKey(modifiedWord)? dic[modifiedWord] + 1 : 1;\\n                    currLen = Math.Max(currLen, modifiedLen);\\n                }\\n\\n                dic.Add(word,currLen);\\n                maxLen = Math.Max(maxLen, currLen);\\n            }     \\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        \\n        if(words == null || words.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(words, (w1, w2) => w1.Length - w2.Length);\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        int maxLen = 0;\\n        foreach(var word in words)\\n        {     \\n            if(!dic.ContainsKey(word))\\n            {\\n                int currLen = 1;\\n                for(int i = 0; i < word.Length; i++)\\n                {\\n                    StringBuilder sb = new StringBuilder(word); \\n                    sb.Remove(i,1);\\n                    string modifiedWord = sb.ToString();\\n                    int modifiedLen = dic.ContainsKey(modifiedWord)? dic[modifiedWord] + 1 : 1;\\n                    currLen = Math.Max(currLen, modifiedLen);\\n                }\\n\\n                dic.Add(word,currLen);\\n                maxLen = Math.Max(maxLen, currLen);\\n            }     \\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213783,
                "title": "longest-string-chain-c-explanation-with-pictures",
                "content": "**Explanation:**\\n\\n***Intuition:***\\nFirst thing that comes to our mind is to take every string and try to place character (\\'a\\' to \\'z\\') in the string at different position and check if the string formed by concatenating one character is present in given array or not.\\nIf its present then we can say we have found chain of 2 strings.\\n\\nBut the above approach takes more time and also we are unnecessarily generating redundant strings in between.\\n\\nLet us look at two things:\\n1) Can we optimise above approach.\\n2) How to have relationship between two different strings(How to know whether two strings are part of chain or not).\\n\\n***Thinking in terms of graph***\\nAs of now, we are sure that there should be some linking between two strings if they are part of chain, right!!\\nNext step is to identify how we can link two strings.\\n\\nLet us take an example:\\n[\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\nconsider string \"bca\"\\nNow try to remove only one character at each step :\\n1) delete b from bca then bca ----> ca (check if ca is present in the given array? NO)\\n2) delete c from bca then bca ----> ba (check is ba is present in the given array? YES)\\n\\tif it is present then link bca--->ba or ba-->bca (it doesn\\'t matter)\\nsimilarly we can link different string with each other.\\nlet us see in below image all the relationship between different strings.\\n\\n![image](https://assets.leetcode.com/users/images/15d6221f-8521-49f0-aee5-11b208686c20_1621245658.2108808.jpeg)\\n\\nAs we can clearly see, it is graph of strings where string is vertex.\\n\\nNow the main step is to identify how far we can go from each Vertex.(That we can easily do using DFS).\\n\\n**Note:** Single Vertex will be considered as chain of 1 string.\\n\\n\\n**Code: C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<int> maxChain;\\n    \\n    int getMaxChain(int src)\\n    {\\n        if(maxChain[src]>0)\\n            return maxChain[src];\\n        maxChain[src]=1;\\n        for(auto child:graph[src])\\n        {\\n            maxChain[src]=max(maxChain[src],1+getMaxChain(child));\\n        }\\n        return maxChain[src];\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]=i;\\n        }\\n        graph.clear();\\n        maxChain.clear();\\n        graph.resize(n);\\n        maxChain.resize(n);\\n        \\n        for(int i=0;i<size(words);i++)\\n        {\\n            string currentString=words[i];\\n            for(int j=0;j<size(currentString);j++)\\n            {\\n                string removeOneCharacter = currentString.substr(0,j)+currentString.substr(j+1);\\n                if(!mp.count(removeOneCharacter))\\n                {\\n                    continue;\\n                }\\n                graph[i].push_back(mp[removeOneCharacter]);\\n            }\\n        }\\n        int maximumChain = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maximumChain = max(maximumChain,getMaxChain(i));\\n        }\\n        return maximumChain;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<int> maxChain;\\n    \\n    int getMaxChain(int src)\\n    {\\n        if(maxChain[src]>0)\\n            return maxChain[src];\\n        maxChain[src]=1;\\n        for(auto child:graph[src])\\n        {\\n            maxChain[src]=max(maxChain[src],1+getMaxChain(child));\\n        }\\n        return maxChain[src];\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]=i;\\n        }\\n        graph.clear();\\n        maxChain.clear();\\n        graph.resize(n);\\n        maxChain.resize(n);\\n        \\n        for(int i=0;i<size(words);i++)\\n        {\\n            string currentString=words[i];\\n            for(int j=0;j<size(currentString);j++)\\n            {\\n                string removeOneCharacter = currentString.substr(0,j)+currentString.substr(j+1);\\n                if(!mp.count(removeOneCharacter))\\n                {\\n                    continue;\\n                }\\n                graph[i].push_back(mp[removeOneCharacter]);\\n            }\\n        }\\n        int maximumChain = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maximumChain = max(maximumChain,getMaxChain(i));\\n        }\\n        return maximumChain;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013746,
                "title": "python3-dp",
                "content": "**Algo**\\nScan through `words` and for each word, remove a letter to get a `key` and check if it has been seen before. If so, 1 + its length becomes a candidate of the string chain ending at the current word. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        seen = {}\\n        for word in sorted(words, key=len): \\n            seen[word] = 1\\n            for i in range(len(word)): \\n                key = word[:i] + word[i+1:]\\n                if key in seen: \\n                    seen[word] = max(seen[word], 1 + seen[key])\\n        return max(seen.values())\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        seen = {}\\n        for word in sorted(words, key=len): \\n            seen[word] = 1\\n            for i in range(len(word)): \\n                key = word[:i] + word[i+1:]\\n                if key in seen: \\n                    seen[word] = max(seen[word], 1 + seen[key])\\n        return max(seen.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558552,
                "title": "dynamic-programming-solution-without-sorting",
                "content": "### Solution\\nHave two maps \\n1. Map of string size and set of string of that size\\n2. Map of each string and the longest chain formed till that string\\n\\nStart loop from the size = lowestWordSize+1. \\nFor every word is current size, check if the setOfStrings with size-1 has a chain word\\nIf yes, update lenTillCurrentWord = 1 + lenTillClippedWord\\n\\nReturn max of lenTillCurrentWord\\n\\n##### Time Complexity = O(N*S*S)\\n##### Space Complexity = O(N*S)\\n\\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int maxChainSize = 1;\\n        int startSize = Integer.MAX_VALUE;\\n        Map<Integer, Set<String>> sizeMap = new HashMap<>();\\n        Map<String, Integer> sizeTillStringMap = new HashMap<>();\\n        \\n        for (String word: words){\\n            int size = word.length();\\n            startSize = Math.min(startSize, size);\\n            \\n            Set<String> setOfStrings = sizeMap.getOrDefault(size, new HashSet<>());\\n            setOfStrings.add(word);\\n            sizeMap.put(size, setOfStrings);\\n        }\\n        \\n        while(sizeMap.containsKey(++startSize)){\\n            Set<String> prevListOfStrings = sizeMap.get(startSize-1);\\n            for (String word: sizeMap.get(startSize)){\\n                int maxLen = 1;\\n                for (int i=0; i<word.length(); i++){\\n                    String clippedWord = word.substring(0, i) + word.substring(i+1, word.length());\\n                    if (prevListOfStrings.contains(clippedWord)){\\n                        maxLen = Math.max(maxLen, sizeTillStringMap.getOrDefault(clippedWord,1) + 1);\\n                    }\\n                }\\n                sizeTillStringMap.put(word, maxLen);\\n                maxChainSize = Math.max(maxChainSize, maxLen);\\n            }\\n        }\\n        \\n        return maxChainSize;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int maxChainSize = 1;\\n        int startSize = Integer.MAX_VALUE;\\n        Map<Integer, Set<String>> sizeMap = new HashMap<>();\\n        Map<String, Integer> sizeTillStringMap = new HashMap<>();\\n        \\n        for (String word: words){\\n            int size = word.length();\\n            startSize = Math.min(startSize, size);\\n            \\n            Set<String> setOfStrings = sizeMap.getOrDefault(size, new HashSet<>());\\n            setOfStrings.add(word);\\n            sizeMap.put(size, setOfStrings);\\n        }\\n        \\n        while(sizeMap.containsKey(++startSize)){\\n            Set<String> prevListOfStrings = sizeMap.get(startSize-1);\\n            for (String word: sizeMap.get(startSize)){\\n                int maxLen = 1;\\n                for (int i=0; i<word.length(); i++){\\n                    String clippedWord = word.substring(0, i) + word.substring(i+1, word.length());\\n                    if (prevListOfStrings.contains(clippedWord)){\\n                        maxLen = Math.max(maxLen, sizeTillStringMap.getOrDefault(clippedWord,1) + 1);\\n                    }\\n                }\\n                sizeTillStringMap.put(word, maxLen);\\n                maxChainSize = Math.max(maxChainSize, maxLen);\\n            }\\n        }\\n        \\n        return maxChainSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533530,
                "title": "simple-solution-with-explanation-o-n-log-n-n-w-time-and-space-python",
                "content": "The problem asks us to find the longest chain of strings.  A chain is formed if each element has an extra letter than the preceding one.\\n\\nWhenever I see this kind of problems, I think about:\\n* [tries](https://leetcode.com/tag/trie/): it helps with string prefix, but doesn\\'t help here, as the letter can be applied anywhere in the string\\n* [backtracking](https://leetcode.com/tag/backtracking/): I\\'ve noticed it helps with problems that require a full exploration of the space (e.g., find all possible chains). It would be an overkill here.\\n* [dp](https://leetcode.com/tag/dynamic-programming/): it helps with problems that are incremental in nature (e.g., find a short chain, see which ones can be used towards building the longer chain). (TIP: look at the post [Dynamic Programming Patterns](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns).\\n\\nSo picking DP as the main approach, I made the observation that it would be simpler to build the chain from shortest to longest word  -- doing the opposite is possible, but finding the next word is more expensive.\\n\\n```\\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n\\t\\twords.sort(key=len)                 # Put shortest words first. Equivalent to words.sort(key=lambda x: len(x))\\n        \\n        dp = {}                             # Map(word, length of chain that ends with word)\\n        longest = 0                         # Longest chain found\\n        \\n        for w in words:\\n            parent = 0\\n            for i in range(len(w)):         # Find potential preceeding words, by removing 1 letter at a time\\n                pw = w[:i] + w[i+1:]\\n                if pw in dp:\\n                    parent = max(parent, dp[pw])  # See if this is the longest parent we can have\\n\\n            dp[w] = 1 + parent              # The chain that ends here is as long as the parent, plus us\\n\\n            longest = max(longest, dp[w])   # Keep track of longest chaing\\n\\n        return longest\\n```\\n\\nAs we can see from the code above, the function has 2 tasks: sort the input array, and compute the *dp* array. Sorting is `O(N log N)`. Computing the *dp* array has 2 loops: the first one depending on `N` (number of words), and the inner one depending on `W` (length of the word). \\n\\nThus the complexity in time is `O( N log N + W*N )`. We can argue the complexity on space (hash map/dictionary) is the same.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n\\t\\twords.sort(key=len)                 # Put shortest words first. Equivalent to words.sort(key=lambda x: len(x))\\n        \\n        dp = {}                             # Map(word, length of chain that ends with word)\\n        longest = 0                         # Longest chain found\\n        \\n        for w in words:\\n            parent = 0\\n            for i in range(len(w)):         # Find potential preceeding words, by removing 1 letter at a time\\n                pw = w[:i] + w[i+1:]\\n                if pw in dp:\\n                    parent = max(parent, dp[pw])  # See if this is the longest parent we can have\\n\\n            dp[w] = 1 + parent              # The chain that ends here is as long as the parent, plus us\\n\\n            longest = max(longest, dp[w])   # Keep track of longest chaing\\n\\n        return longest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 465848,
                "title": "python-easy-to-read-dp-solution",
                "content": "```\\nfrom collections import *\\n\\nclass Solution:\\n    \\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n        words.sort(key=len)\\n        word_dict = defaultdict(int)\\n        \\n        total_max = 0\\n        \\n        for w in words:\\n            for i in range(len(w)):\\n                wc = w[:i] + w[i+1:]\\n                word_dict[w] = max(word_dict[wc] + 1, word_dict[w])\\n            total_max = max(total_max, word_dict[w])\\n    \\n        return total_max\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import *\\n\\nclass Solution:\\n    \\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n        words.sort(key=len)\\n        word_dict = defaultdict(int)\\n        \\n        total_max = 0\\n        \\n        for w in words:\\n            for i in range(len(w)):\\n                wc = w[:i] + w[i+1:]\\n                word_dict[w] = max(word_dict[wc] + 1, word_dict[w])\\n            total_max = max(total_max, word_dict[w])\\n    \\n        return total_max\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295186,
                "title": "java-topological-sort-bfs",
                "content": "The problem can be reduced to finding the length of the longest path in a DAG. It can be done by using [Kahn\\'s algorithm](https://en.wikipedia.org/wiki/Topological_sorting#Kahn\\'s_algorithm). A directed edge exists between a node and its predecessor.\\n```\\npublic int longestStrChain(String[] words) {\\n    int[] indegree = new int[words.length];\\n    List<Integer>[] graph = buildDigraph(words, indegree);\\n    return bfs(graph, indegree);\\n}\\n\\nprivate int bfs(List<Integer>[] graph, int[] indegree) {\\n    Queue<Integer> q = new ArrayDeque<>();\\n    for (int i = 0; i < graph.length; i++) {\\n        if (indegree[i] == 0) {\\n            q.add(i);\\n        }\\n    }\\n\\n    int len = 0;\\n    for (; !q.isEmpty(); len++) {\\n        for (int sz = q.size(); sz > 0; sz--) {\\n            for (int adj : graph[q.poll()]) {\\n                indegree[adj]--;\\n                if (indegree[adj] == 0) {\\n                    q.add(adj);\\n                }\\n            }\\n        }\\n    }\\n    return len;\\n}\\n\\nprivate List<Integer>[] buildDigraph(String[] words, int[] indegree) {\\n    Arrays.sort(words, new StringByLengthComparator());\\n\\n    List<Integer>[] graph = new List[words.length];\\n    for (int i = 0; i < words.length; i++) {\\n        graph[i] = new ArrayList<>();\\n    }\\n\\n    for (int i = 0; i < words.length; i++) {\\n        for (int j = i + 1; j < words.length && words[j].length() - words[i].length() <= 1; j++) {\\n            if (isPredecessor(words[i], words[j])) {\\n                graph[i].add(j);\\n                indegree[j]++;   \\n            }\\n        }\\n    }\\n\\n    return graph;\\n}\\n\\n private boolean isPredecessor(String s1, String s2) {\\n    if (s2.length() == s1.length()) return false;\\n    int diff = 0;\\n    for (int i = 0, j = 0; i < s1.length(); ) {\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            i++;\\n            j++;\\n        } else {\\n            diff++;\\n            if (diff > 1) return false;\\n            j++;\\n        }\\n    }\\n    return true;\\n}\\n\\nprivate static class StringByLengthComparator implements Comparator<String> {\\n    public int compare(String s1, String s2) {\\n        return Integer.compare(s1.length(), s2.length());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestStrChain(String[] words) {\\n    int[] indegree = new int[words.length];\\n    List<Integer>[] graph = buildDigraph(words, indegree);\\n    return bfs(graph, indegree);\\n}\\n\\nprivate int bfs(List<Integer>[] graph, int[] indegree) {\\n    Queue<Integer> q = new ArrayDeque<>();\\n    for (int i = 0; i < graph.length; i++) {\\n        if (indegree[i] == 0) {\\n            q.add(i);\\n        }\\n    }\\n\\n    int len = 0;\\n    for (; !q.isEmpty(); len++) {\\n        for (int sz = q.size(); sz > 0; sz--) {\\n            for (int adj : graph[q.poll()]) {\\n                indegree[adj]--;\\n                if (indegree[adj] == 0) {\\n                    q.add(adj);\\n                }\\n            }\\n        }\\n    }\\n    return len;\\n}\\n\\nprivate List<Integer>[] buildDigraph(String[] words, int[] indegree) {\\n    Arrays.sort(words, new StringByLengthComparator());\\n\\n    List<Integer>[] graph = new List[words.length];\\n    for (int i = 0; i < words.length; i++) {\\n        graph[i] = new ArrayList<>();\\n    }\\n\\n    for (int i = 0; i < words.length; i++) {\\n        for (int j = i + 1; j < words.length && words[j].length() - words[i].length() <= 1; j++) {\\n            if (isPredecessor(words[i], words[j])) {\\n                graph[i].add(j);\\n                indegree[j]++;   \\n            }\\n        }\\n    }\\n\\n    return graph;\\n}\\n\\n private boolean isPredecessor(String s1, String s2) {\\n    if (s2.length() == s1.length()) return false;\\n    int diff = 0;\\n    for (int i = 0, j = 0; i < s1.length(); ) {\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            i++;\\n            j++;\\n        } else {\\n            diff++;\\n            if (diff > 1) return false;\\n            j++;\\n        }\\n    }\\n    return true;\\n}\\n\\nprivate static class StringByLengthComparator implements Comparator<String> {\\n    public int compare(String s1, String s2) {\\n        return Integer.compare(s1.length(), s2.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295062,
                "title": "step-by-step-dfs-memoization-c-beat-100",
                "content": "My explannation and might be a little wordy, but I will try my best.\\n**Step1 (simple) : Is one string the predecessor of another?**\\nWe create the function isProd(s1, s2), to determine whether s1 is the pred of s2.\\n```\\n    bool isProd(string& s1, string& s2) {\\n        int i = 0;\\n        int j = 0;\\n        if (s2.length() != s1.length() + 1) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        int diff = 0;\\n        while (i < m && j < n) {\\n            if (s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            else {\\n                j++;\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n**Step2 (simple) : For all the strings in the list, we need to determine the pred relation** of one and another (for all of them), using the function in Step1. Store them in the matrix called *dp*.\\n```\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<vector<int>> dp(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == j) continue;\\n                if (isProd(words[i], words[j])) dp[i].push_back(j);\\n            }\\n        }\\n\\t\\t// -------------- Above code for Step2 ------------------\\n        vector<int> mem(n, 0);\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res = max(1 + maxPath(dp, mem, i), res);\\n        }\\n        return res;\\n    }\\n```\\n**Step3: The maxPath() function above that has not beed implemented.**\\nWith the relation matrix dp, we need to come up with the maxPath with DFS. Also, for the sake of efficiency we need a *mem* vector to store values that has already been computed.\\n```\\n    int maxPath(vector<vector<int>>& dp, vector<int>& mem, int start) {\\n        if (mem[start] != 0) return mem[start];\\n        int res = 0;\\n        for (int i = 0; i < dp[start].size(); ++i) {\\n            int temp = maxPath(dp, mem, dp[start][i]);\\n            res = max(res, 1 + temp);\\n        }\\n        mem[start] = res;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isProd(string& s1, string& s2) {\\n        int i = 0;\\n        int j = 0;\\n        if (s2.length() != s1.length() + 1) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        int diff = 0;\\n        while (i < m && j < n) {\\n            if (s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            else {\\n                j++;\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<vector<int>> dp(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == j) continue;\\n                if (isProd(words[i], words[j])) dp[i].push_back(j);\\n            }\\n        }\\n\\t\\t// -------------- Above code for Step2 ------------------\\n        vector<int> mem(n, 0);\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res = max(1 + maxPath(dp, mem, i), res);\\n        }\\n        return res;\\n    }\\n```\n```\\n    int maxPath(vector<vector<int>>& dp, vector<int>& mem, int start) {\\n        if (mem[start] != 0) return mem[start];\\n        int res = 0;\\n        for (int i = 0; i < dp[start].size(); ++i) {\\n            int temp = maxPath(dp, mem, dp[start][i]);\\n            res = max(res, 1 + temp);\\n        }\\n        mem[start] = res;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294927,
                "title": "c-dp-similar-to-word-break-logic-dfs",
                "content": "\\tclass Solution {\\n\\t\\tstatic bool compare(string s1 , string s2) {\\n\\t\\t\\treturn s1.length() < s2.length();\\n\\t\\t}\\n\\n\\t\\tbool isPredecessor(string &s1, string &s2) {\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tbool flag = false;\\n\\n\\t\\t\\twhile(i < s1.length() and j < s2.length()) {\\n\\t\\t\\t\\tif(s1[i] != s2[j]) {\\n\\t\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn (flag and i == s1.length() and j == s2.length()) or (!flag and i == (s1.length() - 1) and j == s2.length());\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tvector<int> mem(words.size(), 1);\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tsort(words.begin(), words.end(), compare);\\n\\t\\t\\tfor(int i = 1; i < words.size(); i++) {\\n\\t\\t\\t\\tint len = words[i].length();\\n\\t\\t\\t\\tfor(int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\tif((len - words[j].length()) > 1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tif(isPredecessor(words[i], words[j]))\\n\\t\\t\\t\\t\\t\\tmem[i] = max(mem[i], mem[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = max(res, mem[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tstatic bool compare(string s1 , string s2) {\\n\\t\\t\\treturn s1.length() < s2.length();\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4083621,
                "title": "easy-dp-solution",
                "content": "# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# **Approach**\\n`longestStrChain `function that takes a vector of strings words as input and returns the length of the longest string chain. A string chain is a sequence of words where each word differs from the previous word by exactly one character insertion.\\n\\nHere\\'s a breakdown of the code:\\n\\n- `comparee`is a static member function that compares two strings based on their lengths. It is used as a custom comparison function for sorting the words in ascending order of length.\\n\\n- check is a member function that checks if s1 is a valid successor of s2 in a string chain. It returns true if s1 has a length one greater than s2 and can be obtained by adding one character to s2. It uses two pointers (first and second) to compare characters in both strings.\\n\\n- In the `longestStrChain `function:\\n\\n1. The words vector is sorted in ascending order of length using the `comparee`function as the custom comparator. This ensures that shorter words come before longer words.\\n2. An array dp is initialized with the same size as the input vector words. Each element in dp represents the length of the longest chain ending with the word at the corresponding index in words. Initially, each word is considered a chain of length 1.\\n3. The variable `maxi` is used to keep track of the `maxi`mum chain length found so far.\\n4. Two nested loops iterate over the words in the words vector. For each word at index i, an inner loop iterates over all previous words (at indices prev) to check if words[i] can be a successor of words[prev]. If it can, and extending the chain by adding words[i] results in a longer chain than what was previously stored in dp[i], the chain length is updated.\\n5. Finally, the `maxi`mum chain length (`maxi`) is returned as the result.\\nOverall, this code efficiently computes the length of the longest string chain using dynamic programming and custom sorting to optimize the process.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**$O(N^2)$**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:***0(N)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     static bool comparee(const string& s1, const string& s2) {\\n        return s1.size() < s2.size();\\n    }\\n\\n    bool check(string &s1, string &s2) {\\n        if (s1.size() != s2.size() + 1) {\\n            return false;\\n        }\\n        int first = 0;\\n        int second = 0;\\n        while (first < s1.size()) {\\n            if (s1[first] == s2[second]) {\\n                first++;\\n                second++;\\n            } else {\\n                first++;\\n            }\\n        }\\n        if (first == s1.size() && second == s2.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), comparee);\\n\\n        int n = words.size();\\n        vector<int> dp(n, 1); // Initialize dp array with 1 for each word\\n        int maxi = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int prev = 0; prev < i; prev++) {\\n                if (check(words[i], words[prev]) && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     static bool comparee(const string& s1, const string& s2) {\\n        return s1.size() < s2.size();\\n    }\\n\\n    bool check(string &s1, string &s2) {\\n        if (s1.size() != s2.size() + 1) {\\n            return false;\\n        }\\n        int first = 0;\\n        int second = 0;\\n        while (first < s1.size()) {\\n            if (s1[first] == s2[second]) {\\n                first++;\\n                second++;\\n            } else {\\n                first++;\\n            }\\n        }\\n        if (first == s1.size() && second == s2.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), comparee);\\n\\n        int n = words.size();\\n        vector<int> dp(n, 1); // Initialize dp array with 1 for each word\\n        int maxi = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int prev = 0; prev < i; prev++) {\\n                if (check(words[i], words[prev]) && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081321,
                "title": "c-solution-for-longest-string-chain-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind this solution is to use dynamic programming to find the longest word chain for each word. We start by sorting the words by their length to ensure we process shorter words before longer ones. For each word, we try to find its predecessors (words that can be formed by inserting a single character) and calculate the longest chain ending at the current word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tSort the words based on their length to process shorter words first.\\n2.\\tInitialize a dictionary (wordChainLengths) to store the longest chain for each word.\\n3.\\tIterate through each word:\\n    a. For each word, generate its possible predecessors by removing one character at a time.\\n    b. Check if the predecessor exists in the dictionary and update the longest chain for the current word accordingly.\\n    c. Update the longest chain length overall.\\n4.\\tReturn the longest chain length found.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the total number of words and k be the average length of the words.\\n\\n\\u2022\\tSorting the words takes O(n log n) time.\\n\\u2022\\tThe main loop iterates through each word and, for each word, can generate up to O(k) predecessors, and we do a constant-time operation for each predecessor.\\n\\u2022\\tOverall, the time complexity is O(n * k^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tThe space complexity is O(n) for the wordChainLengths dictionary, where n is the number of words.\\n\\u2022\\tAdditional space is used for variables and temporary storage, which is O(1).\\n\\u2022\\tTherefore, the overall space complexity is O(n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        // Sort the words based on their length\\n        Array.Sort(words, (a, b) => a.Length - b.Length);\\n\\n        Dictionary<string, int> wordChainLengths = new Dictionary<string, int>();\\n        int longestChain = 1;\\n\\n        foreach (var word in words) {\\n            wordChainLengths[word] = 1; // Default chain length for each word is 1\\n\\n            // Find predecessors of the current word\\n            for (int i = 0; i < word.Length; i++) {\\n                StringBuilder pred = new StringBuilder(word);\\n                pred.Remove(i, 1);\\n                string predecessor = pred.ToString();\\n\\n                // Check if the predecessor exists in the dictionary\\n                if (wordChainLengths.ContainsKey(predecessor)) {\\n                    wordChainLengths[word] = Math.Max(wordChainLengths[word], wordChainLengths[predecessor] + 1);\\n                    longestChain = Math.Max(longestChain, wordChainLengths[word]);\\n                }\\n            }\\n        }\\n\\n        return longestChain;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        // Sort the words based on their length\\n        Array.Sort(words, (a, b) => a.Length - b.Length);\\n\\n        Dictionary<string, int> wordChainLengths = new Dictionary<string, int>();\\n        int longestChain = 1;\\n\\n        foreach (var word in words) {\\n            wordChainLengths[word] = 1; // Default chain length for each word is 1\\n\\n            // Find predecessors of the current word\\n            for (int i = 0; i < word.Length; i++) {\\n                StringBuilder pred = new StringBuilder(word);\\n                pred.Remove(i, 1);\\n                string predecessor = pred.ToString();\\n\\n                // Check if the predecessor exists in the dictionary\\n                if (wordChainLengths.ContainsKey(predecessor)) {\\n                    wordChainLengths[word] = Math.Max(wordChainLengths[word], wordChainLengths[predecessor] + 1);\\n                    longestChain = Math.Max(longestChain, wordChainLengths[word]);\\n                }\\n            }\\n        }\\n\\n        return longestChain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079645,
                "title": "c-simple-precise-solution-dp-day-23",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool check(string& s1, string& s2){\\n\\n    if(s1.size() != s2.size() + 1) return false;\\n    \\n    int first = 0;\\n    int second = 0;\\n    \\n    while(first < s1.size()){\\n        if(second < s2.size() && s1[first] == s2[second]){\\n            first ++;\\n            second ++;\\n        }\\n        else first ++;\\n    }\\n    if(first == s1.size() && second == s2.size()) return true;\\n    else return false; \\n}\\n\\n    static bool comp(string& s1, string& s2){\\n        return s1.size() < s2.size();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {   // based on LIS if observed carefully! \\n        \\n        int n = words.size();\\n        //sorting accordin to the size of each word using comparator!\\n  //IMP -> SORT\\n  sort( words.begin(), words.end(), comp );\\n        vector<int> dp(n,1);\\n        int maxi = 1;\\n\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n\\n                if(check(words[i],words[prev]) && dp[i]<dp[prev]+1){\\n                    dp[i]=dp[prev]+1;\\n                }\\n            }\\n            maxi = max(maxi,dp[i]);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool check(string& s1, string& s2){\\n\\n    if(s1.size() != s2.size() + 1) return false;\\n    \\n    int first = 0;\\n    int second = 0;\\n    \\n    while(first < s1.size()){\\n        if(second < s2.size() && s1[first] == s2[second]){\\n            first ++;\\n            second ++;\\n        }\\n        else first ++;\\n    }\\n    if(first == s1.size() && second == s2.size()) return true;\\n    else return false; \\n}\\n\\n    static bool comp(string& s1, string& s2){\\n        return s1.size() < s2.size();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {   // based on LIS if observed carefully! \\n        \\n        int n = words.size();\\n        //sorting accordin to the size of each word using comparator!\\n  //IMP -> SORT\\n  sort( words.begin(), words.end(), comp );\\n        vector<int> dp(n,1);\\n        int maxi = 1;\\n\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n\\n                if(check(words[i],words[prev]) && dp[i]<dp[prev]+1){\\n                    dp[i]=dp[prev]+1;\\n                }\\n            }\\n            maxi = max(maxi,dp[i]);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079496,
                "title": "most-optimised-code-with-100-runtime-and-memory-efficient-today-s-potd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the longest word chain possible from a given list of words. A word chain is a sequence of words where each word is a predecessor of the next word, which means you can insert exactly one letter anywhere in a word to make it equal to the next word. To solve this problem, we can use dynamic programming to find the longest chain length for each word.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the given list of words based on their lengths. This sorting is important because we want to process shorter words before longer ones, ensuring that we have information about potential predecessors when processing longer words.\\n\\n2. Initialize a dp (dynamic programming) map to store the length of the longest chain for each word. Initialize a variable maxLength to keep track of the maximum chain length found.\\n\\n3. Iterate through each word in the sorted order:\\n\\n4. Initialize currentLength to 1, as a single word forms a chain of length 1.\\nFor each possible predecessor of the current word (by removing one character at a time), check if the predecessor is in the dp map.\\nIf the predecessor is in the map, update currentLength to be the maximum of its current value and the length of the chain for the predecessor (from the dp map) plus 1.\\nUpdate the dp map for the current word with the calculated currentLength.\\n\\n5. Update maxLength to be the maximum of its current value and the currentLength for the current word.\\n\\n6. Continue this process for all words.\\n\\n7. Finally, return the maxLength as the length of the longest word chain.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting the words takes O(N log N), where N is the number of words.\\nThe main loop iterates through each word, and for each word, it generates all possible predecessors by removing characters. This inner loop can take up to O(L) time, where L is the maximum length of a word.\\nTherefore, the overall time complexity is O(N log N + NL), which simplifies to O(NL + N log N).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. We use a dp map to store the chain lengths for each word, which can take up to O(N) space.\\n2. Other variables used in the algorithm have constant space requirements.\\n3. Hence, the overall space complexity is O(N).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their length\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        unordered_map<string, int> dp; // Stores the length of the longest chain for each word\\n        \\n        int maxLength = 1; // Initialize the maximum length of the chain\\n        \\n        // Iterate through each word in the sorted order\\n        for (const string& word : words) {\\n            int currentLength = 1; // Initialize the chain length for the current word\\n            \\n            // Generate all possible predecessors of the current word\\n            for (int i = 0; i < word.size(); ++i) {\\n                string predecessor = word.substr(0, i) + word.substr(i + 1);\\n                \\n                // Check if the predecessor is in the dp map\\n                if (dp.count(predecessor)) {\\n                    currentLength = max(currentLength, dp[predecessor] + 1);\\n                }\\n            }\\n            \\n            // Update the dp map for the current word\\n            dp[word] = currentLength;\\n            \\n            // Update the maximum length of the chain\\n            maxLength = max(maxLength, currentLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their length\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        unordered_map<string, int> dp; // Stores the length of the longest chain for each word\\n        \\n        int maxLength = 1; // Initialize the maximum length of the chain\\n        \\n        // Iterate through each word in the sorted order\\n        for (const string& word : words) {\\n            int currentLength = 1; // Initialize the chain length for the current word\\n            \\n            // Generate all possible predecessors of the current word\\n            for (int i = 0; i < word.size(); ++i) {\\n                string predecessor = word.substr(0, i) + word.substr(i + 1);\\n                \\n                // Check if the predecessor is in the dp map\\n                if (dp.count(predecessor)) {\\n                    currentLength = max(currentLength, dp[predecessor] + 1);\\n                }\\n            }\\n            \\n            // Update the dp map for the current word\\n            dp[word] = currentLength;\\n            \\n            // Update the maximum length of the chain\\n            maxLength = max(maxLength, currentLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079178,
                "title": "java-1d-dp-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider any 1 element of array , compare that element with all the before elements and check if it is precedure of the selected element or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake 1D dp and store maximum length of words up to that index that can be choosen to become longest predecessor.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int n = words.length;\\n        int dp[] = new int [n+1];\\n        Arrays.sort(words,(a,b)->Integer.compare(a.length(), b.length()));\\n        System.out.println(Arrays.toString(words));\\n        Arrays.fill(dp,1);\\n        int ans = 1;\\n        for(int i = 1;i < n; i++){\\n            for(int j = i-1;j >= 0; j--){\\n                if(isPossible(words,i,j)){\\n                    dp[i] = Math.max(1+dp[j],dp[i]);\\n                    ans = Math.max(ans,dp[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(String[] words,int i,int j){\\n        String s = words[i];\\n        String p = words[j];\\n        if(s.length() - p.length() == 1){\\n            boolean bool = false;\\n            for(int first = 0,second = 0;first < s.length() && second < p.length(); first++,second++){\\n                if(s.charAt(first) != p.charAt(second)){\\n                    if(bool)return false;\\n                    bool = true;\\n                    second--;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int n = words.length;\\n        int dp[] = new int [n+1];\\n        Arrays.sort(words,(a,b)->Integer.compare(a.length(), b.length()));\\n        System.out.println(Arrays.toString(words));\\n        Arrays.fill(dp,1);\\n        int ans = 1;\\n        for(int i = 1;i < n; i++){\\n            for(int j = i-1;j >= 0; j--){\\n                if(isPossible(words,i,j)){\\n                    dp[i] = Math.max(1+dp[j],dp[i]);\\n                    ans = Math.max(ans,dp[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(String[] words,int i,int j){\\n        String s = words[i];\\n        String p = words[j];\\n        if(s.length() - p.length() == 1){\\n            boolean bool = false;\\n            for(int first = 0,second = 0;first < s.length() && second < p.length(); first++,second++){\\n                if(s.charAt(first) != p.charAt(second)){\\n                    if(bool)return false;\\n                    bool = true;\\n                    second--;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078905,
                "title": "simple-c-code-longest-increasing-subsequence-variant",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to involve finding the longest chain of strings where each string in the chain can be obtained by deleting a single character from the previous string. To solve this, we could sort the strings by their lengths in ascending order. Then, we can use dynamic programming to compute the longest chain for each string, starting from the shortest string and building up to the longest.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the input strings in ascending order of their lengths.\\n2. Initialize an array `dp` of size n (number of input strings) to store the length of the longest chain ending at each string. Initialize all elements of dp to 1, as the minimum chain length for any string is 1 (the string itself).\\n3. Iterate through each string in the sorted order. For each string, iterate through all previous strings to check if the current string can be obtained by deleting a character from the previous string. If yes, update the dp value for the current string to be the `maximum of its current value and 1 plus` the dp value of the previous string.\\n4. Keep track of the maximum chain length seen so far and return it as the result.\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private:\\n  bool compare(string &s1 , string &s2){\\n    if(s1.size() != s2.size()+1) return false;\\n    int i(0) , j(0);\\n    while(i<s1.size()){\\n      if(j<s2.size() and s1[i] == s2[j]){\\n        i++;\\n        j++;\\n      }\\n      else i++;\\n    }\\n    if(i == s1.size() and j == s2.size()) return true;\\n    return false;\\n\\n  }\\n \\npublic:\\n static bool cmp(string&s1 , string&s2){\\n    return s1.size()<s2.size();\\n  }\\n    int longestStrChain(vector<string>& nums) {\\n        sort(nums.begin() , nums.end(),cmp);\\n        int n = nums.size();\\n        vector<int>dp(n, 1) ;\\n        int maxi = 1;\\n        for(int i = 0; i<n; i++){\\n         \\n            for(int j = 0; j<i; j++){\\n                if(compare(nums[i]  , nums[j])  &&  1 + dp[j] > dp[i]){\\n                    dp[i] = 1+ dp[j];\\n                }\\n            }\\n            // maxi = max(maxi , dp[i]); // last index of lIS will be max-lengthed index\\n            if(dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  private:\\n  bool compare(string &s1 , string &s2){\\n    if(s1.size() != s2.size()+1) return false;\\n    int i(0) , j(0);\\n    while(i<s1.size()){\\n      if(j<s2.size() and s1[i] == s2[j]){\\n        i++;\\n        j++;\\n      }\\n      else i++;\\n    }\\n    if(i == s1.size() and j == s2.size()) return true;\\n    return false;\\n\\n  }\\n \\npublic:\\n static bool cmp(string&s1 , string&s2){\\n    return s1.size()<s2.size();\\n  }\\n    int longestStrChain(vector<string>& nums) {\\n        sort(nums.begin() , nums.end(),cmp);\\n        int n = nums.size();\\n        vector<int>dp(n, 1) ;\\n        int maxi = 1;\\n        for(int i = 0; i<n; i++){\\n         \\n            for(int j = 0; j<i; j++){\\n                if(compare(nums[i]  , nums[j])  &&  1 + dp[j] > dp[i]){\\n                    dp[i] = 1+ dp[j];\\n                }\\n            }\\n            // maxi = max(maxi , dp[i]); // last index of lIS will be max-lengthed index\\n            if(dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078775,
                "title": "simple-intuitive-c-solution-using-sort-and-dp-tc-o-nxn-sc-o-n",
                "content": "# Intuition\\n1. Sort the vector according to size so that while traversing we have to check in just one direction. \\n2. Pick a string, while traversing through vector check whether it picked string is subsequence or not, if its a subsequence then this is a part of string chain.    \\n\\n\\n# Complexity\\n- Time complexity: O(nxn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(string a, string b){\\n        return a.length()<b.length();\\n    }\\n    bool isSubsequence(string s, string t) {\\n        int j=0;\\n        for(int i=0; i<t.length();i++){\\n            if(t[i]==s[j]){\\n                j++;\\n            }\\n        }\\n        if(s.length()==j)return true;\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),cmp);\\n        int n=words.size();\\n        vector<int> dp(n, 1);\\n        int maxLen = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(isSubsequence(words[j], words[i]) && words[j].length()+1==words[i].length()){\\n                    dp[i] = max(dp[i], dp[j]+1);\\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string a, string b){\\n        return a.length()<b.length();\\n    }\\n    bool isSubsequence(string s, string t) {\\n        int j=0;\\n        for(int i=0; i<t.length();i++){\\n            if(t[i]==s[j]){\\n                j++;\\n            }\\n        }\\n        if(s.length()==j)return true;\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),cmp);\\n        int n=words.size();\\n        vector<int> dp(n, 1);\\n        int maxLen = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(isSubsequence(words[j], words[i]) && words[j].length()+1==words[i].length()){\\n                    dp[i] = max(dp[i], dp[j]+1);\\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602346,
                "title": "easy-lis-approach-explanation-c-little-modification-in-striver-s-approach",
                "content": "# Intuition\\nHere we see the length of the words in the output sequence is increasing by one, So we can try some LIS(longest increasing sequence) kind approach.\\n\\n# Approach\\nOnly thing we need to take care about is the new characters are insersted at any index and the relative order of characters needs to be retained, we can create a separate check function for this purpose\\n\\nwe can simply use the LIS code, and replace the condition arr[i]>arr[j], with check function\\n\\nonly thing we need to be careful about is the words should be sorted, in order to form an increasing sequence by length, we can use a comparator function for this same purpose.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N*cmp), where cmp is the time complexity of comparator function\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(const string& a, const string& b) {\\n        if (b.size() + 1 != a.size()) return false;\\n        int n = a.size();\\n        while (n--) {\\n            string temp = a;\\n            if (temp.erase(n, 1) == b) return true;\\n        }\\n        return false;\\n    }\\n\\nstruct cmp {\\n    bool operator()(string& a, string& b) {\\n        return a.size() < b.size();\\n    }\\n};\\n\\nint longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        sort(words.begin(), words.end(), cmp());\\n        vector<int> dp(n, 1);\\n        int maxi = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (check(words[i], words[j]) && dp[i] < 1 + dp[j]) dp[i] = 1 + dp[j];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(const string& a, const string& b) {\\n        if (b.size() + 1 != a.size()) return false;\\n        int n = a.size();\\n        while (n--) {\\n            string temp = a;\\n            if (temp.erase(n, 1) == b) return true;\\n        }\\n        return false;\\n    }\\n\\nstruct cmp {\\n    bool operator()(string& a, string& b) {\\n        return a.size() < b.size();\\n    }\\n};\\n\\nint longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        sort(words.begin(), words.end(), cmp());\\n        vector<int> dp(n, 1);\\n        int maxi = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (check(words[i], words[j]) && dp[i] < 1 + dp[j]) dp[i] = 1 + dp[j];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303517,
                "title": "lcs-lis-code-python",
                "content": "# Intuition\\nThe intuition that for every curr string (s2) check with its previous one string(s1) that whether s2 completely contains s2 or not.\\nconditions:-\\n`1. If length of s2 - s1 != 1 => False (because we are allowed to add only one different char)`\\n`2. If s2 doesnt contain complete s1 => False (j < 0 but i != 0)`\\n\\nPerform this lcs for every curr word with its previously added word (By LIS method).\\n\\nI tried to find similar solution on Solutions sections by others but as it is not very efficient way to solve didnt find any.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # Choices -> notpick ; found LCS => pick , notpick\\n        words.sort(key=len)\\n        def LCS(i, j, s1, s2, memo):\\n            if len(s2) - len(s1) != 1:\\n                memo[(i, j)] = False\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if i < 0:\\n                memo[(i, j)] = True\\n            elif j < 0 and i >= 0:\\n                memo[(i, j)] = False\\n            elif s1[i] == s2[j]:\\n                memo[(i, j)] = LCS(i-1, j-1, s1, s2, memo)\\n            else:\\n                memo[(i, j)] = LCS(i, j-1, s1, s2, memo)\\n            return memo[(i, j)]\\n\\n        dp = [1] * len(words)\\n        for i in range(len(words)):\\n            for prev in range(i):\\n                m = len(words[prev])\\n                n = len(words[i])\\n                memo = {}\\n                if LCS(m -1, n-1, words[prev], words[i], memo):\\n                    dp[i] = max(dp[i], 1 + dp[prev])\\n        return max(dp)\\n        \\n        \\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # Choices -> notpick ; found LCS => pick , notpick\\n        words.sort(key=len)\\n        def LCS(i, j, s1, s2, memo):\\n            if len(s2) - len(s1) != 1:\\n                memo[(i, j)] = False\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if i < 0:\\n                memo[(i, j)] = True\\n            elif j < 0 and i >= 0:\\n                memo[(i, j)] = False\\n            elif s1[i] == s2[j]:\\n                memo[(i, j)] = LCS(i-1, j-1, s1, s2, memo)\\n            else:\\n                memo[(i, j)] = LCS(i, j-1, s1, s2, memo)\\n            return memo[(i, j)]\\n\\n        dp = [1] * len(words)\\n        for i in range(len(words)):\\n            for prev in range(i):\\n                m = len(words[prev])\\n                n = len(words[i])\\n                memo = {}\\n                if LCS(m -1, n-1, words[prev], words[i], memo):\\n                    dp[i] = max(dp[i], 1 + dp[prev])\\n        return max(dp)\\n        \\n        \\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420998,
                "title": "python-dynamic-programming-faster-than-95",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        answer = -1\\n        words_set = set(words)\\n        words.sort(key=lambda x: -len(x))\\n        \\n        @cache\\n        def dp(word):\\n            max_p = 1\\n            for i in range(len(word)):\\n                new_w = word[:i] + word[i+1:]\\n                if new_w in words_set:\\n                    max_p = max(max_p, 1+dp(new_w))\\n            \\n            return max_p\\n        \\n        for word in words:\\n            answer = max(answer, dp(word))\\n            \\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        answer = -1\\n        words_set = set(words)\\n        words.sort(key=lambda x: -len(x))\\n        \\n        @cache\\n        def dp(word):\\n            max_p = 1\\n            for i in range(len(word)):\\n                new_w = word[:i] + word[i+1:]\\n                if new_w in words_set:\\n                    max_p = max(max_p, 1+dp(new_w))\\n            \\n            return max_p\\n        \\n        for word in words:\\n            answer = max(answer, dp(word))\\n            \\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206492,
                "title": "lis-logic-dp-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool compare(string &a, string &b){\\n        if(a.size()-1 != b.size()) return false;\\n        int i=0, j=0;\\n        while(i<a.size()){\\n            if(a[i] == b[j]){\\n                i++; j++;\\n            }\\n            else i++;\\n        }\\n        if(i==a.size() && j==b.size()) return true;\\n        return false;\\n    }\\n\\n    static bool len(string &a, string &b){\\n        return a.size() < b.size();\\n    }\\npublic:\\n    //we need to sort string acc to their length, and then we can apply logic of longest increasing subsequence\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(), maxi=0;\\n        sort(words.begin(), words.end(), len);\\n        \\n        vector<int> dp(n, 1);\\n        for(int i=0;i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(compare(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i] = 1 + dp[j];\\n                }\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool compare(string &a, string &b){\\n        if(a.size()-1 != b.size()) return false;\\n        int i=0, j=0;\\n        while(i<a.size()){\\n            if(a[i] == b[j]){\\n                i++; j++;\\n            }\\n            else i++;\\n        }\\n        if(i==a.size() && j==b.size()) return true;\\n        return false;\\n    }\\n\\n    static bool len(string &a, string &b){\\n        return a.size() < b.size();\\n    }\\npublic:\\n    //we need to sort string acc to their length, and then we can apply logic of longest increasing subsequence\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(), maxi=0;\\n        sort(words.begin(), words.end(), len);\\n        \\n        vector<int> dp(n, 1);\\n        for(int i=0;i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(compare(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i] = 1 + dp[j];\\n                }\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162475,
                "title": "easy-dp-solution-w-explanation-dp-explained",
                "content": "We need to find the longest chain of strings.\\nLet\\'s take an example the words: `[\"a\", \"b\", \"ba\"]`\\n\\nWhat is the longest chain of strings for word `\"a\"`? It\\'s 1 because there is only 1 letter.\\nWhat is the lognest chain of strings for the word `\"ba\"`? It\\'s the longest of all possible predecessors + 1 (or 1 if there is no chain from the predecessors)\\nWhat are the possible predecessors? `\"a\"` or `\"b\"`. We simply remove 1 letter at a time. So it\\'s `1 + \"a\" longest chain which is also 1 => 1+1 (or \"b\" longest chain which is also 1)`\\n\\nIf we extend this, what is the longest chain for \"bca\"? `max(dp[\"bc\"], dp[\"ca\"], dp[\"ba\"]) + 1`.\\nNote: we must sort the words array in order to know the previous answers.\\n\\nLet\\'s just code it :)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = defaultdict(int)\\n        MAX = 1\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                dp[word] = 1\\n                continue\\n            for i in range(len(word)):\\n                possible_predecessor = word[:i] + word[i+1:]\\n                dp[word] = max(dp[possible_predecessor] + 1, dp[word])\\n                MAX = max(MAX, dp[word])\\n                \\n        return MAX\\n```\\n\\n# Complexity analysis\\nTime: `O(nlogn*l)` - where `n` is the words list length, and `l` is the longest string.\\nspace: `O(n)`\\n\\n# Top-bottom DP memo solution\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        available_words = set(words)\\n        MAX = 1\\n        for word in words:\\n            if word not in memo:\\n                MAX = max(MAX, self.recurse(words, word, available_words, memo))\\n        return MAX\\n        \\n    def recurse(self, words: List[str], word: str, available_words, memo):\\n        if len(word) == 1:\\n            memo[word] = 1\\n            return 1\\n        \\n        if word in memo:\\n            return memo[word]\\n        \\n        MAX = 1\\n        for i in range(len(word)):\\n            possible_predecessor = word[:i] + word[i+1:]\\n            if possible_predecessor in available_words:\\n                MAX = max(MAX, self.recurse(words, possible_predecessor, available_words, memo) + 1)\\n            \\n        memo[word] = MAX\\n        return MAX\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = defaultdict(int)\\n        MAX = 1\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                dp[word] = 1\\n                continue\\n            for i in range(len(word)):\\n                possible_predecessor = word[:i] + word[i+1:]\\n                dp[word] = max(dp[possible_predecessor] + 1, dp[word])\\n                MAX = max(MAX, dp[word])\\n                \\n        return MAX\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        available_words = set(words)\\n        MAX = 1\\n        for word in words:\\n            if word not in memo:\\n                MAX = max(MAX, self.recurse(words, word, available_words, memo))\\n        return MAX\\n        \\n    def recurse(self, words: List[str], word: str, available_words, memo):\\n        if len(word) == 1:\\n            memo[word] = 1\\n            return 1\\n        \\n        if word in memo:\\n            return memo[word]\\n        \\n        MAX = 1\\n        for i in range(len(word)):\\n            possible_predecessor = word[:i] + word[i+1:]\\n            if possible_predecessor in available_words:\\n                MAX = max(MAX, self.recurse(words, possible_predecessor, available_words, memo) + 1)\\n            \\n        memo[word] = MAX\\n        return MAX\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162309,
                "title": "c-longest-string-chain-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool sortByLength(string &s1, string &s2){\\n        \\n        return s1.length() < s2.length();  \\n        // eg s1 = \"ab\", s2 = \"abc\" -> return true -> no swap\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        // Sort all the words in ascending order of their length\\n        sort(words.begin(), words.end(), sortByLength);\\n        \\n        unordered_map<string, int> dp(n);\\n        int len = 0;\\n        \\n        for(int i=0; i < n; i++){\\n            \\n            dp[words[i]] = 1;   // can form by itself\\n            \\n             // deleting char by char and checking if predecessor exists\\n            for(int j=0; j < words[i].size(); j++){  \\n                \\n                string predecessor = words[i].substr(0, j) + words[i].substr(j+1);\\n                dp[words[i]] = max(dp[words[i]] , 1 + dp[predecessor]);\\n            }\\n            \\n            len = max(len, dp[words[i]]);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortByLength(string &s1, string &s2){\\n        \\n        return s1.length() < s2.length();  \\n        // eg s1 = \"ab\", s2 = \"abc\" -> return true -> no swap\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        // Sort all the words in ascending order of their length\\n        sort(words.begin(), words.end(), sortByLength);\\n        \\n        unordered_map<string, int> dp(n);\\n        int len = 0;\\n        \\n        for(int i=0; i < n; i++){\\n            \\n            dp[words[i]] = 1;   // can form by itself\\n            \\n             // deleting char by char and checking if predecessor exists\\n            for(int j=0; j < words[i].size(); j++){  \\n                \\n                string predecessor = words[i].substr(0, j) + words[i].substr(j+1);\\n                dp[words[i]] = max(dp[words[i]] , 1 + dp[predecessor]);\\n            }\\n            \\n            len = max(len, dp[words[i]]);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154668,
                "title": "python-easy-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        d = {}\\n        for i in words:\\n            d[i] = 1\\n            for j in range(len(i)):\\n                successor = i[:j] + i[j+1:]\\n                \\n                if successor in d:\\n                    d[i] = max(d[i], 1 + d[successor])\\n        return max(d.values())\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        d = {}\\n        for i in words:\\n            d[i] = 1\\n            for j in range(len(i)):\\n                successor = i[:j] + i[j+1:]\\n                \\n                if successor in d:\\n                    d[i] = max(d[i], 1 + d[successor])\\n        return max(d.values())\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154240,
                "title": "c-easy-to-understand-solution-without-sorting",
                "content": "***Loop-based Cpp solution***\\n```\\nclass Solution {\\npublic:\\n    bool check(int cur, int prev, vector<string>& words){\\n        int diff=0,i=0,j=0;\\n        while(i<words[cur].size() && j<words[prev].size()){\\n            if(words[cur][i]==words[prev][j]){\\n                i++;j++;\\n            }\\n            else{\\n                i++;\\n                diff++;\\n            }\\n        }\\n        return diff<2;\\n    }\\n\\t\\n    int longestStrChain(vector<string>& words) {\\n        vector<pair<int,int>> a[17];\\n        for(int i=0;i<words.size();i++){\\n            a[words[i].size()].push_back({i,1});\\n        }\\n        int ans=1;\\n        for(int i=2;i<17;i++){\\n            for(int j=0;j<a[i].size();j++){\\n                for(int k=0;k<a[i-1].size();k++){\\n                    if(check(a[i][j].first,a[i-1][k].first,words))\\n\\t\\t\\t\\t\\t\\ta[i][j].second=max(a[i][j].second,a[i-1][k].second+1);\\n                }\\n                ans=max(ans,a[i][j].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(int cur, int prev, vector<string>& words){\\n        int diff=0,i=0,j=0;\\n        while(i<words[cur].size() && j<words[prev].size()){\\n            if(words[cur][i]==words[prev][j]){\\n                i++;j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2153352,
                "title": "simple-java-solution-using-a-hashmap-w-comments",
                "content": "```\\nclass Solution {\\n    int longest = 1;\\n    public int longestStrChain(String[] words) {\\n        \\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        sort(words);\\n    \\n        for (int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            \\n            if (!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }\\n            \\n            // loop over the entire string and delete each character one by one.\\n            // if the resulting string was already found, then insert the current string + 1\\n            // of the previous value.  That is signifying the string chain \\n            for (int j = 0; j < curr.length(); j++) {\\n                StringBuilder sb = new StringBuilder(curr);\\n                sb.deleteCharAt(j);\\n                \\n                String newString = sb.toString();\\n                if (map.containsKey(newString)) {\\n                    map.put(curr, map.get(newString) + 1);\\n                }   \\n                longest = Math.max(longest, map.get(curr));\\n            }\\n        }\\n        return longest;\\n    }\\n    \\n    // sort array by length of string (smallest -> largest)\\n    public void sort(String[] words) {\\n        Arrays.sort(words, (a,b)->Integer.valueOf(a.length()).compareTo(Integer.valueOf(b.length())));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int longest = 1;\\n    public int longestStrChain(String[] words) {\\n        \\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        sort(words);\\n    \\n        for (int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            \\n            if (!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }\\n            \\n            // loop over the entire string and delete each character one by one.\\n            // if the resulting string was already found, then insert the current string + 1\\n            // of the previous value.  That is signifying the string chain \\n            for (int j = 0; j < curr.length(); j++) {\\n                StringBuilder sb = new StringBuilder(curr);\\n                sb.deleteCharAt(j);\\n                \\n                String newString = sb.toString();\\n                if (map.containsKey(newString)) {\\n                    map.put(curr, map.get(newString) + 1);\\n                }   \\n                longest = Math.max(longest, map.get(curr));\\n            }\\n        }\\n        return longest;\\n    }\\n    \\n    // sort array by length of string (smallest -> largest)\\n    public void sort(String[] words) {\\n        Arrays.sort(words, (a,b)->Integer.valueOf(a.length()).compareTo(Integer.valueOf(b.length())));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153318,
                "title": "c-2-approaches-lcs-lis-lis",
                "content": "**1. Using LCS + LIS**\\n\\nIn this approach, we will find the length of longest common subsequence and if the number of remaining character in 2nd string is 1 then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t // Using LCS + LIS  *** Will Give TLE ***\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint lcs_len(string word1, string word2) {\\n\\t\\t\\tint m = word1.size();\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<int>>dp(m + 1, vector<int>(n + 1, 0));\\n\\t\\t\\tfor(int idx1 = 1; idx1 <= m; idx1++) {\\n\\t\\t\\t\\tfor(int idx2 = 1; idx2 <= n; idx2++) {\\n\\t\\t\\t\\t\\tif(word1[idx1 - 1] == word2[idx2 - 1])\\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = 1 + dp[idx1 - 1][idx2 - 1]; \\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = max(dp[idx1 - 1][idx2], dp[idx1][idx2 - 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(words[i].size() == words[j].size() + 1 && lcs_len(words[i], words[j]) == words[j].size()){\\n\\t\\t\\t\\t\\t\\tif(dp[i] < dp[j] + 1)\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(),  dp.end());\\n\\t\\t}\\n\\n**2. Using LIS**\\n\\nIn this approach, instead of finding the length of longest common subsequence, we will compare two strings by using two pointer approach. If both pointers reach the end at the same time then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t// Using LIS\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValid(string &a, string &b) {\\n\\t\\t\\tif(a.size() != b.size() + 1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\twhile(i < a.size()) {\\n\\t\\t\\t\\tif(a[i] == b[j]) \\n\\t\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i == a.size() && j == b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tfor(int i = 0; i < words.size(); i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(isValid(words[i],words[j]) && dp[i] < dp[j] + 1) {\\n\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**1. Using LCS + LIS**\\n\\nIn this approach, we will find the length of longest common subsequence and if the number of remaining character in 2nd string is 1 then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t // Using LCS + LIS  *** Will Give TLE ***\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint lcs_len(string word1, string word2) {\\n\\t\\t\\tint m = word1.size();\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<int>>dp(m + 1, vector<int>(n + 1, 0));\\n\\t\\t\\tfor(int idx1 = 1; idx1 <= m; idx1++) {\\n\\t\\t\\t\\tfor(int idx2 = 1; idx2 <= n; idx2++) {\\n\\t\\t\\t\\t\\tif(word1[idx1 - 1] == word2[idx2 - 1])\\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = 1 + dp[idx1 - 1][idx2 - 1]; \\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = max(dp[idx1 - 1][idx2], dp[idx1][idx2 - 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(words[i].size() == words[j].size() + 1 && lcs_len(words[i], words[j]) == words[j].size()){\\n\\t\\t\\t\\t\\t\\tif(dp[i] < dp[j] + 1)\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(),  dp.end());\\n\\t\\t}\\n\\n**2. Using LIS**\\n\\nIn this approach, instead of finding the length of longest common subsequence, we will compare two strings by using two pointer approach. If both pointers reach the end at the same time then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t// Using LIS\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValid(string &a, string &b) {\\n\\t\\t\\tif(a.size() != b.size() + 1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\twhile(i < a.size()) {\\n\\t\\t\\t\\tif(a[i] == b[j]) \\n\\t\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i == a.size() && j == b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tfor(int i = 0; i < words.size(); i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(isValid(words[i],words[j]) && dp[i] < dp[j] + 1) {\\n\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2152993,
                "title": "c-top-down-dp-spaghetti-code",
                "content": "```\\nclass Solution {\\n    \\n    bool isValid(string& s1, string& s2) {\\n        \\n        int diff = 0;\\n        \\n        int i = 0;\\n        int j = 0;\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        \\n        while(i < n1 && j < n2) {\\n            if(s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n                diff++;\\n            }\\n        }\\n\\n        if(j == n2 -1 && i == n1 && diff == 0) return true;\\n        \\n        if(diff != 1) return false;\\n        return i == n1 && j == n2;\\n    }\\n    \\n    int dfs(unordered_map<int, vector<string>>& um, string& cur, unordered_map<string, int>& cashMoney) {\\n        int n = cur.length();\\n        \\n        if(cashMoney.find(cur) != cashMoney.end()) {\\n            return cashMoney[cur];\\n        }\\n        int best = 1;\\n        for(auto& s : um[n+1]) {\\n            if(isValid(cur, s)) {\\n                int maybe = 1 + dfs(um, s, cashMoney);\\n                best = max(maybe, best);\\n            }\\n        }\\n        return cashMoney[cur] = best;\\n    }\\n    \\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<int, vector<string>> um;\\n        unordered_map<string, int> cashMoney;\\n        int mn = INT_MAX;\\n        for(auto& s : words) {\\n            int n = s.length();\\n            mn = min(n, mn);\\n            um[n].push_back(s);\\n        }\\n        int ans = 0;\\n        for(auto& s : words) {\\n            ans = max(ans, dfs(um, s, cashMoney));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    bool isValid(string& s1, string& s2) {\\n        \\n        int diff = 0;\\n        \\n        int i = 0;\\n        int j = 0;\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        \\n        while(i < n1 && j < n2) {\\n            if(s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n                diff++;\\n            }\\n        }\\n\\n        if(j == n2 -1 && i == n1 && diff == 0) return true;\\n        \\n        if(diff != 1) return false;\\n        return i == n1 && j == n2;\\n    }\\n    \\n    int dfs(unordered_map<int, vector<string>>& um, string& cur, unordered_map<string, int>& cashMoney) {\\n        int n = cur.length();\\n        \\n        if(cashMoney.find(cur) != cashMoney.end()) {\\n            return cashMoney[cur];\\n        }\\n        int best = 1;\\n        for(auto& s : um[n+1]) {\\n            if(isValid(cur, s)) {\\n                int maybe = 1 + dfs(um, s, cashMoney);\\n                best = max(maybe, best);\\n            }\\n        }\\n        return cashMoney[cur] = best;\\n    }\\n    \\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<int, vector<string>> um;\\n        unordered_map<string, int> cashMoney;\\n        int mn = INT_MAX;\\n        for(auto& s : words) {\\n            int n = s.length();\\n            mn = min(n, mn);\\n            um[n].push_back(s);\\n        }\\n        int ans = 0;\\n        for(auto& s : words) {\\n            ans = max(ans, dfs(um, s, cashMoney));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994057,
                "title": "python-easy-solution-faster-than-99-dictionary-o-nlog-n",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:       \\n        n = len(words)\\n        words.sort(key = lambda x : len(x)) # Sort the words according to their length\\n        \\n        dit = {w:1 for w in words} # Store the longest word chain length till key word\\n        \\n        for i in range(1,n):\\n            w = words[i]\\n            for j in range(len(w)):  # Max len(w) will be 16 \\n                new_w = w[:j]+w[j+1:]  # new word after removing j-th  character\\n            \\n                if new_w in dit and dit[new_w]+1>dit[w]:\\n                    dit[w] = dit[new_w]+1\\n                \\n        return max(dit.values())    \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:       \\n        n = len(words)\\n        words.sort(key = lambda x : len(x)) # Sort the words according to their length\\n        \\n        dit = {w:1 for w in words}",
                "codeTag": "Java"
            },
            {
                "id": 1830813,
                "title": "python-dfs-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        words_set = set(words)    \\n        \\n        def get_next_word(word, index):\\n            return word[:index] + word[index + 1:]\\n        \\n        def dfs(word):\\n            if word in memo:\\n                return memo[word]\\n            \\n            total_length = 1\\n            for i in range(len(word)):\\n                next_word = get_next_word(word, i)\\n                if next_word in words_set:\\n                    current_length = 1 + dfs(next_word)\\n                    total_length = max(total_length, current_length)\\n            memo[word] = total_length\\n            return total_length\\n            \\n        \\n        ans = 0\\n        for word in words_set:\\n            ans = max(ans, dfs(word))\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        words_set = set(words)    \\n        \\n        def get_next_word(word, index):\\n            return word[:index] + word[index + 1:]\\n        \\n        def dfs(word):\\n            if word in memo:\\n                return memo[word]\\n            \\n            total_length = 1\\n            for i in range(len(word)):\\n                next_word = get_next_word(word, i)\\n                if next_word in words_set:\\n                    current_length = 1 + dfs(next_word)\\n                    total_length = max(total_length, current_length)\\n            memo[word] = total_length\\n            return total_length\\n            \\n        \\n        ans = 0\\n        for word in words_set:\\n            ans = max(ans, dfs(word))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794947,
                "title": "swift-dp",
                "content": "```\\nclass Solution {\\n    func longestStrChain(_ words: [String]) -> Int {\\n        var dp: Dictionary<String, Int> = [:]\\n        var words = words.sorted(by: {$0.count < $1.count})\\n        var longest = 1\\n        for word in words {\\n            var presentLength = 1\\n            for i in 0 ..< word.count {\\n                var newStr = Array(word)\\n                newStr.remove(at: i)\\n                let prevL = dp[String(newStr), default: 0]\\n                presentLength = max(prevL + 1,presentLength)\\n            }  \\n            dp[word] = presentLength\\n            longest = longest < presentLength ? presentLength : longest\\n        }\\n        return longest \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func longestStrChain(_ words: [String]) -> Int {\\n        var dp: Dictionary<String, Int> = [:]\\n        var words = words.sorted(by: {$0.count < $1.count})\\n        var longest = 1\\n        for word in words {\\n            var presentLength = 1\\n            for i in 0 ..< word.count {\\n                var newStr = Array(word)\\n                newStr.remove(at: i)\\n                let prevL = dp[String(newStr), default: 0]\\n                presentLength = max(prevL + 1,presentLength)\\n            }  \\n            dp[word] = presentLength\\n            longest = longest < presentLength ? presentLength : longest\\n        }\\n        return longest \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237926,
                "title": "lis-sorting-72-ms-93-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string &first, string &second) {\\n        return first.length() < second.length();\\n    }    \\n\\n    bool preceds(string &predecessor, string &word) {\\n        if (predecessor.length() != word.length()-1)\\n            return false;\\n        int first = 0, second = 0, misMatches = 0;\\n        while (first < predecessor.length() && misMatches <= 1) \\n            if (predecessor[first] != word[second]) {\\n                second++;\\n                misMatches++;\\n            } else {\\n                first++;\\n                second++;\\n            }\\n        return misMatches <= 1;\\n        \\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), cmp);\\n        vector<int> lis(words.size(), 1);\\n        int ans = 1;\\n        for (int i = 1; i < words.size(); i++)\\n            for (int j = 0; j < i; j++) \\n                if (preceds(words[j], words[i])) {\\n                    lis[i] = max(lis[i], lis[j]+1);\\n                    ans = max(ans,lis[i]);                    \\n                }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string &first, string &second) {\\n        return first.length() < second.length();\\n    }    \\n\\n    bool preceds(string &predecessor, string &word) {\\n        if (predecessor.length() != word.length()-1)\\n            return false;\\n        int first = 0, second = 0, misMatches = 0;\\n        while (first < predecessor.length() && misMatches <= 1) \\n            if (predecessor[first] != word[second]) {\\n                second++;\\n                misMatches++;\\n            } else {\\n                first++;\\n                second++;\\n            }\\n        return misMatches <= 1;\\n        \\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), cmp);\\n        vector<int> lis(words.size(), 1);\\n        int ans = 1;\\n        for (int i = 1; i < words.size(); i++)\\n            for (int j = 0; j < i; j++) \\n                if (preceds(words[j], words[i])) {\\n                    lis[i] = max(lis[i], lis[j]+1);\\n                    ans = max(ans,lis[i]);                    \\n                }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227367,
                "title": "simple-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    HashMap<String,Integer> hmp = new HashMap<>();\\n    HashSet<String> hst = new HashSet<>();\\n    private int dfs(String str) {\\n        if(str.length() == 0 || hst.contains(str) == false) return 0;\\n        if(hmp.get(str)!=null) return hmp.get(str);\\n        int temp = 0;\\n        for(int i=0;i<str.length();i++) {\\n            StringBuilder tmpStr = new StringBuilder(str);\\n            tmpStr.deleteCharAt(i);\\n            temp = Math.max(temp,1+dfs(tmpStr.toString()));\\n        }\\n        hmp.put(str,temp);\\n        return temp;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int ans = 0;\\n        for(String str : words) {\\n            hst.add(str);\\n        }\\n        for(String str : words) {\\n            ans = Math.max(ans,dfs(str));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String,Integer> hmp = new HashMap<>();\\n    HashSet<String> hst = new HashSet<>();\\n    private int dfs(String str) {\\n        if(str.length() == 0 || hst.contains(str) == false) return 0;\\n        if(hmp.get(str)!=null) return hmp.get(str);\\n        int temp = 0;\\n        for(int i=0;i<str.length();i++) {\\n            StringBuilder tmpStr = new StringBuilder(str);\\n            tmpStr.deleteCharAt(i);\\n            temp = Math.max(temp,1+dfs(tmpStr.toString()));\\n        }\\n        hmp.put(str,temp);\\n        return temp;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int ans = 0;\\n        for(String str : words) {\\n            hst.add(str);\\n        }\\n        for(String str : words) {\\n            ans = Math.max(ans,dfs(str));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098384,
                "title": "python-hashtable-dp",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        #hash table to store (word: length of longest possible word chain up to the word)\\n        ht={}\\n        \\n        #sort words by length first\\n        words.sort(key=lambda x: len(x))\\n\\n        for word in words:\\n            maxcnt=0\\n            for i in range(len(word)):\\n                \\n                #check if subsequence is in hash table\\n                if word[:i]+word[i+1:] in ht:\\n                    maxcnt=max(maxcnt, ht[word[:i]+word[i+1:]])\\n                    \\n            ht[word]=1+maxcnt\\n\\n        #return maximum length in the hashtable\\n        return max(ht.items(), key=lambda x: x[1])[1]\\n\\'\\'\\'\\n\\nTime complexity O(NC), C is the length of the longest word. Space complexity O(N) for hashtable",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        #hash table to store (word: length of longest possible word chain up to the word)\\n        ht={}",
                "codeTag": "Java"
            },
            {
                "id": 1090001,
                "title": "c-dynamic-programming-solution",
                "content": "1. Sort the input sequence by string length, keep the sequence in increasing order in terms of string length\\n2. Use a hash table, where the [key, value] pair is [string, the length of longest word chan this string participated in]\\n3. loop through the sorted sequence to build the hash table from the shortest string\\n4. For every input string, we try remove exactly one letter at index i from the string, where 0 <= i <string length\\n5. Check if the substring formed by the reset of letters exist in the table.\\n6. Keep track of the maximum length.\\n```\\nint longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](string &a, string &b){\\n            return (b.size() > a.size()) ? (true) : (false);\\n        });\\n        \\n        unordered_map<string, int> tbl;\\n        int ret = 1;\\n        for (auto s:words) {\\n            for (int i = 0; i < s.size(); i++) {\\n                string tmp = s.substr(0, i) + s.substr(i+1, s.size() - i);\\n                if (tbl.count(tmp))\\n                    tbl[s] = max(tbl[s], tbl[tmp] + 1);\\n            }\\n            tbl[s] = max(tbl[s], 1);\\n            ret = max(ret, tbl[s]);\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](string &a, string &b){\\n            return (b.size() > a.size()) ? (true) : (false);\\n        });\\n        \\n        unordered_map<string, int> tbl;\\n        int ret = 1;\\n        for (auto s:words) {\\n            for (int i = 0; i < s.size(); i++) {\\n                string tmp = s.substr(0, i) + s.substr(i+1, s.size() - i);\\n                if (tbl.count(tmp))\\n                    tbl[s] = max(tbl[s], tbl[tmp] + 1);\\n            }\\n            tbl[s] = max(tbl[s], 1);\\n            ret = max(ret, tbl[s]);\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931142,
                "title": "98-03-time-python-dp-solution",
                "content": "This is an O(nm^2) time complexity solution (where n is the number of words in the input and m is the length of the largest word). \\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key = lambda x: len(x))        \\n        \\n        memo = {}\\n        global_max_len = -1\\n        \\n        for word in words:\\n            curr_max_len = 1\\n            for i in range(len(word)):\\n                word_minus_char = word[:i] + word[i+1:]\\n                if word_minus_char in memo:\\n                    curr_max_len = max(curr_max_len, memo[word_minus_char] + 1)\\n            memo[word] = curr_max_len\\n            global_max_len = max(global_max_len, curr_max_len)\\n                    \\n        \\n        return global_max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key = lambda x: len(x))        \\n        \\n        memo = {}\\n        global_max_len = -1\\n        \\n        for word in words:\\n            curr_max_len = 1\\n            for i in range(len(word)):\\n                word_minus_char = word[:i] + word[i+1:]\\n                if word_minus_char in memo:\\n                    curr_max_len = max(curr_max_len, memo[word_minus_char] + 1)\\n            memo[word] = curr_max_len\\n            global_max_len = max(global_max_len, curr_max_len)\\n                    \\n        \\n        return global_max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922140,
                "title": "c-lis-based-self-explanatory-code-and-easy-to-understand-dp",
                "content": "For those Struggling about the problem \\nPlease Solve \\n[300. Longest Increasing Subsequence Problem](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isDifferByOne(string &a, string &b)\\n    {\\n      \\n      int i = 0, j = 0, counter = 0;\\n      \\n      while(i < a.size() and j < b.size())\\n      {\\n        if(a[i] == b[j])\\n        {\\n          i++; j++;\\n        }\\n        \\n        else\\n        { i++;  \\n         counter++; \\n        }\\n      }\\n      return (counter <= 1);\\n    }\\n  \\n    int longestStrChain(vector<string>& words) \\n    { \\n      int n = words.size();\\n      \\n      \\n      vector<int> dp(n, 1);\\n      int maxm = 0;\\n      \\n      sort(words.begin(), words.end(), [](string &s1, string &s2)\\n     {\\n       return s1.size() < s2.size();\\n     });\\n      \\n      for(int i = 0; i < n; i++) {\\n                \\n        for(int j = 0; j < i; j++)\\n        {             \\n          if(words[i].size() == 1 + words[j].size() and isDifferByOne(words[i], words[j]) && dp[i] < dp[j] + 1 )\\n            dp[i] = dp[j] + 1;\\n        }\\n        maxm = max(maxm, dp[i]);\\n      }\\n\\n      return maxm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isDifferByOne(string &a, string &b)\\n    {\\n      \\n      int i = 0, j = 0, counter = 0;\\n      \\n      while(i < a.size() and j < b.size())\\n      {\\n        if(a[i] == b[j])\\n        {\\n          i++; j++;\\n        }\\n        \\n        else\\n        { i++;  \\n         counter++; \\n        }\\n      }\\n      return (counter <= 1);\\n    }\\n  \\n    int longestStrChain(vector<string>& words) \\n    { \\n      int n = words.size();\\n      \\n      \\n      vector<int> dp(n, 1);\\n      int maxm = 0;\\n      \\n      sort(words.begin(), words.end(), [](string &s1, string &s2)\\n     {\\n       return s1.size() < s2.size();\\n     });\\n      \\n      for(int i = 0; i < n; i++) {\\n                \\n        for(int j = 0; j < i; j++)\\n        {             \\n          if(words[i].size() == 1 + words[j].size() and isDifferByOne(words[i], words[j]) && dp[i] < dp[j] + 1 )\\n            dp[i] = dp[j] + 1;\\n        }\\n        maxm = max(maxm, dp[i]);\\n      }\\n\\n      return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838617,
                "title": "swift-dp-solution",
                "content": "The key concept of DP is to cache previous work, here I used a Dictionay for that purpose.\\n\\n```\\nclass Solution {\\n    \\n    private func findSubstrings(_ word: String) -> [String] {\\n        var subStrings = [String]()\\n\\n        for removeIndex in 0..<word.count {\\n            var word = word\\n            word.remove(at: word.index(word.startIndex, offsetBy: removeIndex))\\n            subStrings.append(word)\\n        }\\n\\n        return subStrings\\n    }\\n\\n    func longestStrChain(_ words: [String]) -> Int {\\n        var map = Dictionary<String, Int>()\\n        var maxLength = 0, words = words.sorted()\\n\\n        for word in words {\\n            let subStrings = findSubstrings(word)\\n            var longest = 0\\n            for subString in subStrings {\\n                longest = max(longest, map[subString, default: 0] + 1)\\n            }\\n            map[word] = longest\\n            maxLength = max(maxLength, longest)\\n        }\\n        return maxLength\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private func findSubstrings(_ word: String) -> [String] {\\n        var subStrings = [String]()\\n\\n        for removeIndex in 0..<word.count {\\n            var word = word\\n            word.remove(at: word.index(word.startIndex, offsetBy: removeIndex))\\n            subStrings.append(word)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 837638,
                "title": "python-simple-dp-faster-than-99",
                "content": "time complexity: O(N * M^2), where N is the number of words provided, and M is the length of the longest word.\\nReason for N * M^2:\\n* N - cost of outer loop\\n* M - cost of inner loop\\n* M - cost of string slicing\\n\\nspace complexity: O(N)\\n\\n```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words.sort(key=len)\\n        graph = {}\\n        max_dist = 0\\n        for word in words:\\n            length = len(word)\\n            dist = 0\\n            for i in range(length):\\n                if (check := word[:i] + word[i+1:]) in graph:\\n                    dist = max(graph[check], dist)\\n                graph[word] = dist+1\\n                max_dist = max(max_dist, graph[word])\\n        return max_dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words.sort(key=len)\\n        graph = {}\\n        max_dist = 0\\n        for word in words:\\n            length = len(word)\\n            dist = 0\\n            for i in range(length):\\n                if (check := word[:i] + word[i+1:]) in graph:\\n                    dist = max(graph[check], dist)\\n                graph[word] = dist+1\\n                max_dist = max(max_dist, graph[word])\\n        return max_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820578,
                "title": "simple-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        int count = 0;\\n        int index = 0;\\n        for(int i = 0 ; i < a.size() and index < b.size(); i++,index++){\\n            if(a[i] != b[index]){\\n                count++;\\n                i--;\\n            }\\n            if(count > 1) return false;\\n        }\\n        return count <= 1;\\n    }\\n    static bool comp(string a, string b){\\n        return a.size() < b.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int ans = 1;\\n        vector<int> dp(words.size(),1);\\n        sort(words.begin(),words.end(),comp);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            for(int j = i - 1 ; j >= 0 and words[j].size() + 1 >= words[i].size() ; j--)\\n                if(words[j].size() == words[i].size() - 1)\\n                    if(check(words[j],words[i]))\\n                        dp[i] = max(dp[j] + 1,dp[i]);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        int count = 0;\\n        int index = 0;\\n        for(int i = 0 ; i < a.size() and index < b.size(); i++,index++){\\n            if(a[i] != b[index]){\\n                count++;\\n                i--;\\n            }\\n            if(count > 1) return false;\\n        }\\n        return count <= 1;\\n    }\\n    static bool comp(string a, string b){\\n        return a.size() < b.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int ans = 1;\\n        vector<int> dp(words.size(),1);\\n        sort(words.begin(),words.end(),comp);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            for(int j = i - 1 ; j >= 0 and words[j].size() + 1 >= words[i].size() ; j--)\\n                if(words[j].size() == words[i].size() - 1)\\n                    if(check(words[j],words[i]))\\n                        dp[i] = max(dp[j] + 1,dp[i]);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647248,
                "title": "dfs-with-memoization-use-delete-instead-of-add-character",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            map.put(word, 0);\\n        }\\n        \\n        int res = 0;\\n        for(String s : map.keySet()) {\\n            res = Math.max(res, dfs(s, map));\\n        }\\n        return res;    \\n    }\\n    \\n    private int dfs(String s, Map<String, Integer> map) {\\n        if(!map.containsKey(s)) return 0;\\n        if(map.get(s) != 0) return map.get(s);\\n        \\n        int res = 1;\\n        for(int j = 0; j < s.length(); j++) {\\n            StringBuilder sb = new StringBuilder(s);\\n            res = Math.max(res, 1 + dfs(sb.deleteCharAt(j).toString(), map));\\n        }\\n            \\n        map.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            map.put(word, 0);\\n        }\\n        \\n        int res = 0;\\n        for(String s : map.keySet()) {\\n            res = Math.max(res, dfs(s, map));\\n        }\\n        return res;    \\n    }\\n    \\n    private int dfs(String s, Map<String, Integer> map) {\\n        if(!map.containsKey(s)) return 0;\\n        if(map.get(s) != 0) return map.get(s);\\n        \\n        int res = 1;\\n        for(int j = 0; j < s.length(); j++) {\\n            StringBuilder sb = new StringBuilder(s);\\n            res = Math.max(res, 1 + dfs(sb.deleteCharAt(j).toString(), map));\\n        }\\n            \\n        map.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538369,
                "title": "java-99-runtime-solution",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<Integer, List<String>> lengthToWords = new HashMap<>();\\n        for (String word : words) {\\n            lengthToWords.putIfAbsent(word.length(), new ArrayList<>());\\n            lengthToWords.get(word.length()).add(word);\\n        }\\n        int max = 0;\\n        Map<String, Integer> seen = new HashMap<>();\\n        for (String word : words) {\\n            max = Math.max(max, longestStrChain(word, lengthToWords, seen));\\n        }\\n        return max;\\n    }\\n    \\n    private int longestStrChain(String word, Map<Integer, List<String>> lengthToWords, Map<String, Integer> seen) {\\n        if (!lengthToWords.containsKey(word.length() - 1)) return 1;\\n        if (seen.containsKey(word)) return seen.get(word);\\n        int max = 1;\\n        for (String curr : lengthToWords.get(word.length() - 1)) {\\n            if (!isPred(word, curr)) continue;\\n            max = Math.max(max, longestStrChain(curr, lengthToWords, seen) + 1);\\n        }\\n        seen.put(word, max);\\n        return max;\\n    }\\n    \\n    private boolean isPred(String word1, String word2) {\\n        for (int i = 0, j = 0, diff = 0; i < word1.length() && j < word2.length(); i++) {\\n            if (word1.charAt(i) == word2.charAt(j)) j++;\\n            else {\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<Integer, List<String>> lengthToWords = new HashMap<>();\\n        for (String word : words) {\\n            lengthToWords.putIfAbsent(word.length(), new ArrayList<>());\\n            lengthToWords.get(word.length()).add(word);\\n        }\\n        int max = 0;\\n        Map<String, Integer> seen = new HashMap<>();\\n        for (String word : words) {\\n            max = Math.max(max, longestStrChain(word, lengthToWords, seen));\\n        }\\n        return max;\\n    }\\n    \\n    private int longestStrChain(String word, Map<Integer, List<String>> lengthToWords, Map<String, Integer> seen) {\\n        if (!lengthToWords.containsKey(word.length() - 1)) return 1;\\n        if (seen.containsKey(word)) return seen.get(word);\\n        int max = 1;\\n        for (String curr : lengthToWords.get(word.length() - 1)) {\\n            if (!isPred(word, curr)) continue;\\n            max = Math.max(max, longestStrChain(curr, lengthToWords, seen) + 1);\\n        }\\n        seen.put(word, max);\\n        return max;\\n    }\\n    \\n    private boolean isPred(String word1, String word2) {\\n        for (int i = 0, j = 0, diff = 0; i < word1.length() && j < word2.length(); i++) {\\n            if (word1.charAt(i) == word2.charAt(j)) j++;\\n            else {\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442932,
                "title": "java-dp-solution-easy-to-understand",
                "content": "General DP idea is to store results of subproblem. In this case, the subproblem is the chain that can be formed ending at the current word, if any previously found word is a predecessor of the current word. At each index, store the longest known chain of words ending at that index. \\n\\nIn the end, just return the maximum value in the dp array, which means the max chain length found at any given point in the above process.\\n\\n```\\nclass Solution {\\n    \\n    private boolean isPred(String a, String b) {\\n        int diff = 0;\\n        if(a.length() != b.length()-1) return false;\\n        for(int i = 0 , j = 0;i<a.length() && j<b.length() ;) {\\n            if(a.charAt(i) == b.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if(diff>0) return  false;\\n                diff++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int[] dp = new int[words.length];\\n        Integer max = Integer.MIN_VALUE;\\n        for(int i = 0;i<dp.length;i++) dp[i]=1;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String s1, String s2) {\\n                return s1.length() - s2.length();\\n            }\\n        });\\n        for(int j = 1; j<words.length;j++) {\\n            for(int i = 0;i<j; i++) {\\n                if(isPred(words[i], words[j])) {\\n                    dp[j] = Math.max(dp[j], 1+dp[i]);\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n        }\\n        return Math.max(1, max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isPred(String a, String b) {\\n        int diff = 0;\\n        if(a.length() != b.length()-1) return false;\\n        for(int i = 0 , j = 0;i<a.length() && j<b.length() ;) {\\n            if(a.charAt(i) == b.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if(diff>0) return  false;\\n                diff++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int[] dp = new int[words.length];\\n        Integer max = Integer.MIN_VALUE;\\n        for(int i = 0;i<dp.length;i++) dp[i]=1;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String s1, String s2) {\\n                return s1.length() - s2.length();\\n            }\\n        });\\n        for(int j = 1; j<words.length;j++) {\\n            for(int i = 0;i<j; i++) {\\n                if(isPred(words[i], words[j])) {\\n                    dp[j] = Math.max(dp[j], 1+dp[i]);\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n        }\\n        return Math.max(1, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417306,
                "title": "python-dp-solutions",
                "content": "We sort the words by length, then it becomes a problem like LIS.\\n```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def predecessor(word1, word2):\\n            if len(word2) - len(word1) != 1:\\n                return False\\n            diff_distance = 0\\n            i = j = 0\\n            while i < len(word1):\\n                if word1[i] != word2[j]:\\n                    if diff_distance:\\n                        return False\\n                    diff_distance = 1\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j += 1\\n            return True\\n                    \\n\\t\\twords = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        for i in range(len(words)):\\n            for j in range(i):\\n                if predecessor(words[j],words[i]):\\n                    dp[i] = max(dp[j]+1,dp[i])\\n        return max(dp)\\n```\\nUse hashmap to reduce time complexity.\\n```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        record = {}\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                predecessor = word[:j]+word[j+1:]\\n                if predecessor in record:\\n                    dp[i] = max(dp[record[predecessor]]+1,dp[i])\\n            record[word] = i\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def predecessor(word1, word2):\\n            if len(word2) - len(word1) != 1:\\n                return False\\n            diff_distance = 0\\n            i = j = 0\\n            while i < len(word1):\\n                if word1[i] != word2[j]:\\n                    if diff_distance:\\n                        return False\\n                    diff_distance = 1\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j += 1\\n            return True\\n                    \\n\\t\\twords = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        for i in range(len(words)):\\n            for j in range(i):\\n                if predecessor(words[j],words[i]):\\n                    dp[i] = max(dp[j]+1,dp[i])\\n        return max(dp)\\n```\n```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        record = {}\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                predecessor = word[:j]+word[j+1:]\\n                if predecessor in record:\\n                    dp[i] = max(dp[record[predecessor]]+1,dp[i])\\n            record[word] = i\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399538,
                "title": "java-trie-solution-18ms-97-runtime-100-space",
                "content": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] map;\\n        int length;\\n        public TrieNode() {\\n            map = new TrieNode[26];\\n            length = 0;\\n        }\\n    }\\n    public int longestStrChain(String[] words) {\\n        int maxWordLength = 0;\\n        Map<Integer, Set<String>> map = new HashMap<>();\\n        for(String word: words) {\\n            int length = word.length();\\n            if(!map.containsKey(length)) {\\n                maxWordLength = Math.max(maxWordLength, length);\\n                map.put(length, new HashSet<String>());\\n            }\\n            map.get(length).add(word);\\n        }\\n        int max = 0;\\n        TrieNode root = new TrieNode();\\n        for(int len = 1; len <= maxWordLength; len++) {\\n            if(!map.containsKey(len)) {\\n                continue;\\n            }\\n            Set<String> set = map.get(len);\\n            for(String str: set) {\\n                //check if previous word exists in trie\\n                char[] strArr = str.toCharArray();\\n                int prevLen = find(root, strArr, 0, false);\\n                TrieNode current = root;\\n                for(char c: strArr) {\\n                    if(current.map[c - \\'a\\'] == null) {\\n                        current.map[c - \\'a\\'] = new TrieNode();\\n                    }\\n                    current = current.map[c - \\'a\\'];\\n                }\\n                max = Math.max(max, (current.length = prevLen + 1));\\n            }\\n        }\\n        return max;\\n    }\\n    int find(TrieNode root, char[]str, int index, boolean hasSeen) {\\n        if(index == str.length) {\\n            return root.length;\\n        } else if(root == null) {\\n            return 0;\\n        } else if(root.map[str[index] - \\'a\\'] == null) {\\n            if(hasSeen) {\\n                return 0;\\n            } else {\\n                return find(root, str, index+1, true);\\n            }\\n        }\\n        int straightPath = find(root.map[str[index] - \\'a\\'], str, index+1, hasSeen);\\n        return straightPath == 0 ? find(root, str, index+1, true) : straightPath;\\n    }\\n}\\n```\\n\\n**Explanation**\\n1. Create a map to bucket sort strings by length.\\n2. Iterating from 1 to maximum length (which is 16 for this problem), see if previous word is in Trie.\\n3. Add the new word to the Trie - with `length 1` if a previous word wasn\\'t found, or `length previous+1` if it has. Store the length at the tail TrieNode of the word.\\n4. If the current length is bigger than max, update max.\\n\\n**Complexity**\\n- Time: `O(N * S^2)`\\n- Space: `O(N * S)`\\n\\n**Advantage of this Method**\\n- In the average, reasonable case, the DFS of the Trie shouldn\\'t branch out multipe times, and will be much closer to `O(S)` per run. There will always be exactly `N distinct` additions of `size S`, making the average case complexity realistically closer to `O(N * S)`.\\n- This method is adventagous over other `Java` solutions due to the nature of Java\\'s poor String manipulation due to the immutability property of Strings, which realistically make the comparisons in the most popular method `O(S)` for each concat, with `O(S)` concats and `O(N)` words, totalling `O(N * S^2)`.\\n\\n**Disadvantage of this Method**\\n- As previously stated, this algorithm\\'s `worst case` time complexity is `O(N * S^2)`. The worst case is if there are 1000 16 letter words that are as different as possible (of course they all can\\'t be distinct as there are only 26 letters, but this can still get very bad).\\n- The spacial complexity is `strictly worse` for this method, and can also get very bad due to the nature of creating an object that wraps an array for each \\'letter\\' of the tree. Luckily, the maximum size of these arrays is 26 characters, which is slightly above 26 bytes overall.",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] map;\\n        int length;\\n        public TrieNode() {\\n            map = new TrieNode[26];\\n            length = 0;\\n        }\\n    }\\n    public int longestStrChain(String[] words) {\\n        int maxWordLength = 0;\\n        Map<Integer, Set<String>> map = new HashMap<>();\\n        for(String word: words) {\\n            int length = word.length();\\n            if(!map.containsKey(length)) {\\n                maxWordLength = Math.max(maxWordLength, length);\\n                map.put(length, new HashSet<String>());\\n            }\\n            map.get(length).add(word);\\n        }\\n        int max = 0;\\n        TrieNode root = new TrieNode();\\n        for(int len = 1; len <= maxWordLength; len++) {\\n            if(!map.containsKey(len)) {\\n                continue;\\n            }\\n            Set<String> set = map.get(len);\\n            for(String str: set) {\\n                //check if previous word exists in trie\\n                char[] strArr = str.toCharArray();\\n                int prevLen = find(root, strArr, 0, false);\\n                TrieNode current = root;\\n                for(char c: strArr) {\\n                    if(current.map[c - \\'a\\'] == null) {\\n                        current.map[c - \\'a\\'] = new TrieNode();\\n                    }\\n                    current = current.map[c - \\'a\\'];\\n                }\\n                max = Math.max(max, (current.length = prevLen + 1));\\n            }\\n        }\\n        return max;\\n    }\\n    int find(TrieNode root, char[]str, int index, boolean hasSeen) {\\n        if(index == str.length) {\\n            return root.length;\\n        } else if(root == null) {\\n            return 0;\\n        } else if(root.map[str[index] - \\'a\\'] == null) {\\n            if(hasSeen) {\\n                return 0;\\n            } else {\\n                return find(root, str, index+1, true);\\n            }\\n        }\\n        int straightPath = find(root.map[str[index] - \\'a\\'], str, index+1, hasSeen);\\n        return straightPath == 0 ? find(root, str, index+1, true) : straightPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383298,
                "title": "simple-python-solution",
                "content": "Pretty simple, O(nlogn) because of the sorting, O(n * k) because of individual letter scan (k=length of a word)\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = collections.defaultdict(int)\\n        words.sort(key=lambda x:len(x))\\n        for w in words:\\n            dp[w] = 1\\n            for i in range(len(w)):\\n                newW = w[:i]+w[i+1:]\\n                if newW in dp:\\n                    dp[w] = max(dp[w],dp[newW]+1)\\n                \\n            \\n        return max(dp.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = collections.defaultdict(int)\\n        words.sort(key=lambda x:len(x))\\n        for w in words:\\n            dp[w] = 1\\n            for i in range(len(w)):\\n                newW = w[:i]+w[i+1:]\\n                if newW in dp:\\n                    dp[w] = max(dp[w],dp[newW]+1)\\n                \\n            \\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295704,
                "title": "dp-c-readable-implementation",
                "content": "```\\n public static int LongestStrChain(string[] words)\\n        {\\n            var dic = new Dictionary<string, int>();\\n            foreach (var word in words.OrderBy(w => w.Length))\\n                for (int i = 0; i < word.Length; i++)\\n                {\\n                    string word2 = word.Remove(i,1);\\n                    dic[word] = Math.Max(dic.ContainsKey(word) ? dic[word] : 1,\\n                        dic.ContainsKey(word2) ? dic[word2] + 1 : 1);\\n                }\\n\\n            return dic.Values.Max();\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n public static int LongestStrChain(string[] words)\\n        {\\n            var dic = new Dictionary<string, int>();\\n            foreach (var word in words.OrderBy(w => w.Length))\\n                for (int i = 0; i < word.Length; i++)\\n                {\\n                    string word2 = word.Remove(i,1);\\n                    dic[word] = Math.Max(dic.ContainsKey(word) ? dic[word] : 1,\\n                        dic.ContainsKey(word2) ? dic[word2] + 1 : 1);\\n                }\\n\\n            return dic.Values.Max();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295409,
                "title": "java-topological-sort-with-a-graph-faster-than-dp",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Set<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        Map<String, Set<String>> map = new HashMap<>();\\n        \\n        for(String s : words){\\n            if(map.containsKey(s)) continue;\\n            map.put(s, new HashSet<>());\\n            Set<String> nodes = map.get(s);\\n            StringBuilder sb = null;\\n            \\n            for(int i = 0; i <= s.length(); ++i){\\n                for(char c = \\'a\\'; c <= \\'z\\'; ++c){\\n                    sb = new StringBuilder(s);\\n                    sb.insert(i, c);\\n                    String k = sb.toString();\\n                    if(wordSet.contains(k)){\\n                        nodes.add(sb.toString());\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for(String k : map.keySet()){\\n            Set<String> nodes = map.get(k);\\n            for(String q : nodes){\\n                inDegree.put(q, inDegree.getOrDefault(q, 0) + 1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        for(String str : words){\\n            if(!inDegree.containsKey(str)){\\n                q.offer(str);\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; ++i){\\n                String str = q.poll();\\n                for(String next : map.get(str)){\\n                    inDegree.put(next, inDegree.get(next) - 1);\\n                    if(inDegree.get(next) == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        \\n        \\n        return level;\\n    }\\n}\\n```\\n\\nEffectively this is a graph problem,  I know the dynamic programming solution exists but here is another perspective. This is faster than the dynamic programming solution (494 ms vs 600 ms).\\n\\n\\nThe idea is to build a graph then do a topological sort, clearly this works because we have a directed acyclic graph structure and we need to find the longest path in this DAG. The way to find a longest path in a DAG is to do a topological sort using indegree breadth first search. Hope you like this solution!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Set<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        Map<String, Set<String>> map = new HashMap<>();\\n        \\n        for(String s : words){\\n            if(map.containsKey(s)) continue;\\n            map.put(s, new HashSet<>());\\n            Set<String> nodes = map.get(s);\\n            StringBuilder sb = null;\\n            \\n            for(int i = 0; i <= s.length(); ++i){\\n                for(char c = \\'a\\'; c <= \\'z\\'; ++c){\\n                    sb = new StringBuilder(s);\\n                    sb.insert(i, c);\\n                    String k = sb.toString();\\n                    if(wordSet.contains(k)){\\n                        nodes.add(sb.toString());\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for(String k : map.keySet()){\\n            Set<String> nodes = map.get(k);\\n            for(String q : nodes){\\n                inDegree.put(q, inDegree.getOrDefault(q, 0) + 1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        for(String str : words){\\n            if(!inDegree.containsKey(str)){\\n                q.offer(str);\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; ++i){\\n                String str = q.poll();\\n                for(String next : map.get(str)){\\n                    inDegree.put(next, inDegree.get(next) - 1);\\n                    if(inDegree.get(next) == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        \\n        \\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295008,
                "title": "python-graph-dfs",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(w1, size):\\n            return max([dfs(w2, size + 1) for w2 in graph[w1]], default = size)\\n        graph = collections.defaultdict(list)\\n        for w in words:\\n            graph[len(w)].append(w)\\n        for w1 in words:\\n            for w2 in graph[len(w1) + 1]:\\n                for i in range(len(w2)):\\n                    if w2[:i] + w2[i + 1:] == w1:\\n                        graph[w1].append(w2)\\n        return max(dfs(w, 1) for w in words)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(w1, size):\\n            return max([dfs(w2, size + 1) for w2 in graph[w1]], default = size)\\n        graph = collections.defaultdict(list)\\n        for w in words:\\n            graph[len(w)].append(w)\\n        for w1 in words:\\n            for w2 in graph[len(w1) + 1]:\\n                for i in range(len(w2)):\\n                    if w2[:i] + w2[i + 1:] == w1:\\n                        graph[w1].append(w2)\\n        return max(dfs(w, 1) for w in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294905,
                "title": "java-dp",
                "content": "View this problem as: \\nIn each step, remove one letter from any word such that doing so produces another word which is present in the array.\\nWe have to figure out the longest possible chain of such steps.\\n\\nExample :  (ba)---remove a--->(b) {Length :1}\\n              (bca) --- remove c--->(ba) {length:2}.. so on\\n\\n```\\npublic int longestStrChain(String[] words) {\\n        Map<String,Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int max = Integer.MIN_VALUE;\\n        for(String s : words) {\\n            if(s.length()>1) {\\n                int len = util(s,map,set);\\n                max = Math.max(max,len);\\n            } else {\\n                map.put(s,1);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int util(String S,Map<String,Integer> map,Set<String> set) {\\n\\n        if(map.containsKey(S)) {\\n            return map.get(S);\\n        }\\n        int max=0;\\n        for(int i=0;i<S.length();i++) {\\n            String next = S.substring(0,i)+S.substring(i+1);\\n            if(set.contains(next)) {\\n                max = Math.max(max,util(next,map,set));\\n            }\\n        }\\n        map.put(S,max+1);\\n        return max+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestStrChain(String[] words) {\\n        Map<String,Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int max = Integer.MIN_VALUE;\\n        for(String s : words) {\\n            if(s.length()>1) {\\n                int len = util(s,map,set);\\n                max = Math.max(max,len);\\n            } else {\\n                map.put(s,1);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int util(String S,Map<String,Integer> map,Set<String> set) {\\n\\n        if(map.containsKey(S)) {\\n            return map.get(S);\\n        }\\n        int max=0;\\n        for(int i=0;i<S.length();i++) {\\n            String next = S.substring(0,i)+S.substring(i+1);\\n            if(set.contains(next)) {\\n                max = Math.max(max,util(next,map,set));\\n            }\\n        }\\n        map.put(S,max+1);\\n        return max+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080755,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach and complexity discussed in detail in video solution\\nhttps://youtu.be/5r30UDyPuoM\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& str1, const string& str2)->bool{\\n            return str1.size() < str2.size();\\n        });\\n        unordered_map<string, int> chainLen;\\n        int maxLen = 0;\\n        for (string & word : words) {\\n            for (int indx = 0; indx < word.size(); indx++) {\\n                string pred = word.substr(0, indx) + word.substr(indx + 1);\\n                chainLen[word] = max(chainLen[word], chainLen.find(pred) == chainLen.end() ? 1 : chainLen[pred] + 1);\\n            }\\n            maxLen = max(maxLen, chainLen[word]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b)-> a.length() - b.length());\\n        HashMap<String, Integer> chainLen = new HashMap<>();\\n        int maxLen = 0;\\n        for (var word : words) {\\n            for (int indx = 0; indx < word.length(); indx++) {\\n                String pred = word.substring(0, indx) + word.substring(indx + 1);\\n                chainLen.put(word, Math.max(chainLen.getOrDefault(word, 0), (!chainLen.containsKey(pred)) ? 1 : chainLen.get(pred) + 1));\\n            }\\n            maxLen = Math.max(maxLen, chainLen.get(word));\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& str1, const string& str2)->bool{\\n            return str1.size() < str2.size();\\n        });\\n        unordered_map<string, int> chainLen;\\n        int maxLen = 0;\\n        for (string & word : words) {\\n            for (int indx = 0; indx < word.size(); indx++) {\\n                string pred = word.substr(0, indx) + word.substr(indx + 1);\\n                chainLen[word] = max(chainLen[word], chainLen.find(pred) == chainLen.end() ? 1 : chainLen[pred] + 1);\\n            }\\n            maxLen = max(maxLen, chainLen[word]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b)-> a.length() - b.length());\\n        HashMap<String, Integer> chainLen = new HashMap<>();\\n        int maxLen = 0;\\n        for (var word : words) {\\n            for (int indx = 0; indx < word.length(); indx++) {\\n                String pred = word.substring(0, indx) + word.substring(indx + 1);\\n                chainLen.put(word, Math.max(chainLen.getOrDefault(word, 0), (!chainLen.containsKey(pred)) ? 1 : chainLen.get(pred) + 1));\\n            }\\n            maxLen = Math.max(maxLen, chainLen.get(word));\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079803,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079779,
                "title": "hindi-explanations-jano-intuition-in-easy-lang",
                "content": "# Intuition\\nit is clear from question statement that in string chain we will add next word if it has same chars as previous and one char that is diff from previous chars can be added anywhere.\\ntoh apn sort kr lete by length.jisse hmara search path km ho jayega and efficient bhi ho jayega.\\nnow, chain kisi bhi position se start ho skti hai toh we have call memo func from every pos and store the max ans. in memo func just check that is both words are vaild for chain if yss search for next word that can be added to chain.\\nhn ans+1 kr rhe cuz in this soln we r counting words pairs like a,b,c words me we r adding 1 for a,b and 1 for b,c so we have to add one to get exact ans;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1000]; // An array to memoize intermediate results\\n\\n    // A static comparison function for sorting words by length\\n    static bool mysort(string &a, string &b) {\\n        return a.length() < b.length();\\n    }\\n\\n    // Function to check if two strings can form a valid chain\\n    bool check(string &a, string &b) {\\n        if (a.length() != b.length() - 1) return false;\\n        int count = 0;\\n        int i = 0, j = 0;\\n        while (i < a.length() && j < b.length()) {\\n            if (a[i] != b[j]) {\\n                if (count == 1) return false;\\n                count = 1;\\n            } else {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }\\n\\n    // Recursive memoization function to find the longest chain\\n    int memo(int i, vector<string> &words, int n) {\\n        if (i >= n) return 0; // Base case: If we are out of words, return 0\\n        if (dp[i] != -1) return dp[i]; // If result is already memoized, return it\\n        int ans = 0;\\n        for (int j = i + 1; j < n; j++) {\\n            if (check(words[i], words[j])) {\\n                ans = max(ans, 1 + memo(j, words, n)); // Recursively find chain length\\n            }\\n        }\\n        return dp[i] = ans; // Memoize and return the result\\n    }\\n\\n    // Main function to find the length of the longest string chain\\n    int longestStrChain(vector<string> &words) {\\n        sort(words.begin(), words.end(), mysort); // Sort words by length\\n        int n = words.size();\\n        int ans = 0; // Initialize the maximum chain length to 0\\n\\n        // Iterate through each word and find the maximum chain length\\n        for (int i = 0; i < n; i++) {\\n            memset(dp, -1, sizeof dp); // Initialize the memoization array\\n            ans = max(ans, memo(i, words, n)); // Update the maximum chain length\\n        }\\n        return ans + 1; // Return the length of the longest chain\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1000]; // An array to memoize intermediate results\\n\\n    // A static comparison function for sorting words by length\\n    static bool mysort(string &a, string &b) {\\n        return a.length() < b.length();\\n    }\\n\\n    // Function to check if two strings can form a valid chain\\n    bool check(string &a, string &b) {\\n        if (a.length() != b.length() - 1) return false;\\n        int count = 0;\\n        int i = 0, j = 0;\\n        while (i < a.length() && j < b.length()) {\\n            if (a[i] != b[j]) {\\n                if (count == 1) return false;\\n                count = 1;\\n            } else {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }\\n\\n    // Recursive memoization function to find the longest chain\\n    int memo(int i, vector<string> &words, int n) {\\n        if (i >= n) return 0; // Base case: If we are out of words, return 0\\n        if (dp[i] != -1) return dp[i]; // If result is already memoized, return it\\n        int ans = 0;\\n        for (int j = i + 1; j < n; j++) {\\n            if (check(words[i], words[j])) {\\n                ans = max(ans, 1 + memo(j, words, n)); // Recursively find chain length\\n            }\\n        }\\n        return dp[i] = ans; // Memoize and return the result\\n    }\\n\\n    // Main function to find the length of the longest string chain\\n    int longestStrChain(vector<string> &words) {\\n        sort(words.begin(), words.end(), mysort); // Sort words by length\\n        int n = words.size();\\n        int ans = 0; // Initialize the maximum chain length to 0\\n\\n        // Iterate through each word and find the maximum chain length\\n        for (int i = 0; i < n; i++) {\\n            memset(dp, -1, sizeof dp); // Initialize the memoization array\\n            ans = max(ans, memo(i, words, n)); // Update the maximum chain length\\n        }\\n        return ans + 1; // Return the length of the longest chain\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079737,
                "title": "python3-dp-sorting-time-96-22-space-93-85-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        res = 1\\n        words.sort(key=lambda x:len(x))\\n        dp = {word:1 for word in words}\\n\\n        for i in range(1,len(words)):\\n            w = words[i]\\n            for j in range(len(w)):\\n                if w[:j]+w[j+1:] in dp:\\n                    dp[w] = max(dp[w], 1 + dp[w[:j]+w[j+1:]])\\n            res = max(res,dp[w])\\n\\n        return res\\n\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Upvote :)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        res = 1\\n        words.sort(key=lambda x:len(x))\\n        dp = {word:1 for word in words}\\n\\n        for i in range(1,len(words)):\\n            w = words[i]\\n            for j in range(len(w)):\\n                if w[:j]+w[j+1:] in dp:\\n                    dp[w] = max(dp[w], 1 + dp[w[:j]+w[j+1:]])\\n            res = max(res,dp[w])\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079634,
                "title": "java-easy-to-understand-use-map-stream-and-regex",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        words = Arrays.stream(words)\\n            .sorted(Comparator.comparingInt(String::length))\\n            .toArray(String[]::new);\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            int k = 1;\\n            for (Map.Entry<String, Integer> tail : map.entrySet()) {\\n                if (isPredecessor(word, tail.getKey())) {\\n                    k = Math.max(k, tail.getValue() + 1);\\n                }\\n            }\\n            map.put(word, k);\\n        }\\n        return map.values().stream().mapToInt(i -> i).max().orElse(0);\\n    }\\n    private boolean isPredecessor(String str, String substr) {\\n        if (str.length() != substr.length() + 1) {\\n            return false;\\n        }\\n        String regex = substr.chars()\\n            .mapToObj(c -> String.valueOf((char) c))\\n            .collect(Collectors.joining(\".?\", \".?\", \".?\"));\\n        return str.matches(regex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        words = Arrays.stream(words)\\n            .sorted(Comparator.comparingInt(String::length))\\n            .toArray(String[]::new);\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            int k = 1;\\n            for (Map.Entry<String, Integer> tail : map.entrySet()) {\\n                if (isPredecessor(word, tail.getKey())) {\\n                    k = Math.max(k, tail.getValue() + 1);\\n                }\\n            }\\n            map.put(word, k);\\n        }\\n        return map.values().stream().mapToInt(i -> i).max().orElse(0);\\n    }\\n    private boolean isPredecessor(String str, String substr) {\\n        if (str.length() != substr.length() + 1) {\\n            return false;\\n        }\\n        String regex = substr.chars()\\n            .mapToObj(c -> String.valueOf((char) c))\\n            .collect(Collectors.joining(\".?\", \".?\", \".?\"));\\n        return str.matches(regex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079580,
                "title": "bfs-c-solution",
                "content": "Here\\'s a simple BFS solution.\\n1. sort the string array.\\n2. Iterate with max length string.\\n*     push string to queue\\n*     check all possible combination by removing character one by one and if it exist in the array\\n*     if exist push it in queue \\n3. count the number of iteration you have to do for BFS\\nthat will be the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [&](const string &a, const string &b) {\\n            return a.length() < b.length();\\n        });\\n        int N = words.size();\\n        unordered_set<string> s(words.begin(), words.end());\\n        unordered_set<string> visited;\\n        int ans = 0;\\n        for(int i = N-1;i>=0;i--)\\n        {\\n            if(visited.find(words[i]) == visited.end()) {\\n                queue<string> Q;\\n                Q.push(words[i]);\\n                visited.insert(words[i]);\\n                int count = 0;\\n                while(!Q.empty())\\n                {\\n                    int sz = Q.size();\\n                    while(sz--)\\n                    {\\n                        string str = Q.front();\\n                        //cout<<str<<\" \";\\n                        Q.pop();\\n                        for(int j=0;j<str.length();j++)\\n                        {\\n                            string temp = str;\\n                            temp.erase(j, 1);\\n                            if(s.find(temp) != s.end() && visited.find(temp) == visited.end())\\n                            {\\n                                Q.push(temp);\\n                                visited.insert(temp);\\n                            }\\n                        }\\n                    }\\n                    count++;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [&](const string &a, const string &b) {\\n            return a.length() < b.length();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4079029,
                "title": "best-java-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // taken some help\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // taken some help\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078741,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:collection\\';\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int longestStrChain(List<String> words) {\\n    final hashmap = HashMap<String, int>();\\n    for (final s in words) hashmap[s] = -1;\\n    \\n    int dfs(String s) {\\n      var prev = hashmap[s];\\n      if (prev == null) return 0;\\n      if (prev == -1) {\\n        prev = 1;\\n        for (int i = 0; i < s.length; i++) {\\n          final t = s.substring(0, i) + s.substring(i + 1);\\n          prev = max(prev!, 1 + dfs(t));\\n        }\\n        hashmap[s] = prev!;\\n      }\\n      return prev;\\n    }\\n    var res = 0;\\n    for (final s in words)\\n      res = max(res, dfs(s));\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int longestStrChain(List<String> words) {\\n    final hashmap = HashMap<String, int>();\\n    for (final s in words) hashmap[s] = -1;\\n    \\n    int dfs(String s) {\\n      var prev = hashmap[s];\\n      if (prev == null) return 0;\\n      if (prev == -1) {\\n        prev = 1;\\n        for (int i = 0; i < s.length; i++) {\\n          final t = s.substring(0, i) + s.substring(i + 1);\\n          prev = max(prev!, 1 + dfs(t));\\n        }\\n        hashmap[s] = prev!;\\n      }\\n      return prev;\\n    }\\n    var res = 0;\\n    for (final s in words)\\n      res = max(res, dfs(s));\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078703,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp={}\\n        for word in sorted(words,key=len):\\n            temp=[0]\\n            n=len(word)\\n            for i in range(n):\\n                if word[:i]+word[i+1:] in dp:\\n                    temp.append(dp[word[:i]+word[i+1:]])\\n                dp[word]=max(temp)+1\\n        return max(dp.values())                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp={}\\n        for word in sorted(words,key=len):\\n            temp=[0]\\n            n=len(word)\\n            for i in range(n):\\n                if word[:i]+word[i+1:] in dp:\\n                    temp.append(dp[word[:i]+word[i+1:]])\\n                dp[word]=max(temp)+1\\n        return max(dp.values())                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078607,
                "title": "well-commented-python-code-sort-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # store { word : maxlen } in dp\\n        # word will be used to track predecessor later on\\n        dp = {}\\n        W = sorted(words, key = len) \\n        # sorting based on length\\n\\n        for w in W:\\n            dp[w] = 1\\n            # initialize\\n            for i in range(len(w)):\\n                # for each position of w, skip one\\n                # (to find its possible predecessor)\\n                # and check if it is available in dp.\\n                prv = w[:i] + w[i+1:]\\n                if prv in dp:\\n                    # predecessor of w was found!!\\n                    # update dp value\\n                    dp[w] = max(dp[prv] + 1, dp[w])\\n        \\n        # return max of all possible values in dp\\n        return max(dp.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # store { word : maxlen } in dp\\n        # word will be used to track predecessor later on\\n        dp = {}\\n        W = sorted(words, key = len) \\n        # sorting based on length\\n\\n        for w in W:\\n            dp[w] = 1\\n            # initialize\\n            for i in range(len(w)):\\n                # for each position of w, skip one\\n                # (to find its possible predecessor)\\n                # and check if it is available in dp.\\n                prv = w[:i] + w[i+1:]\\n                if prv in dp:\\n                    # predecessor of w was found!!\\n                    # update dp value\\n                    dp[w] = max(dp[prv] + 1, dp[w])\\n        \\n        # return max of all possible values in dp\\n        return max(dp.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078585,
                "title": "java-4ms-100-arrays-and-optimizations-recursion-with-memorization",
                "content": "```\\nclass Solution {\\n    static final int LONGEST_WORD_LEN = 16;\\n    \\n    public int longestStrChain(String[] words) {\\n        // Calculate number of strings of each length;\\n        int longestCount = 0;\\n        int[] lenCounts = new int[LONGEST_WORD_LEN + 1];\\n        for (int i = words.length - 1; i >= 0; i--)\\n            longestCount = Math.max(longestCount, ++lenCounts[words[i].length()]);\\n        \\n        // Build an array that for each string length, has an array of indexes to words of that  \\n        // length.  Copy the words from the words[] array into the wcs[][] array.  The array wcs \\n        // is indexed by: wcs[string len][index of words of same len].  The wcs[len][0] value is \\n        // the number of words of that same length that are stored in wcs[len].\\n        int maxWordLen = 0;\\n        for (maxWordLen = LONGEST_WORD_LEN; maxWordLen >= 0 && lenCounts[maxWordLen] == 0; maxWordLen--)  { }\\n        short[][] wcs = new short[maxWordLen + 1][longestCount + 1];\\n        for (int i = words.length - 1; i >= 0; i--) {\\n            int len = words[i].length();\\n            wcs[len][++wcs[len][0]] = (short)i;\\n        }\\n        \\n        // Create an uninitialized memorization value for each word now stored as char[] arrays in wcs[][][].\\n        byte[][] memo = new byte[maxWordLen + 1][longestCount + 1];\\n\\n        // Start with the longest words and search backward (longest word to shortest word) to find the \\n        // longest string chain.  Stop searching if the longest string chain found if longer or same \\n        // length as the current word (words are processed longest to shortest), because a longer chain \\n        // is not possible.\\n        int longestFound = 1;\\n        for (int len = maxWordLen; len > 1 && len > longestFound; len--)\\n            for (int wordIdx = wcs[len][0]; wordIdx >= 1 && len > longestFound; wordIdx--)\\n                longestFound = Math.max(longestFound, findPath(len, wordIdx, wcs, memo, words));\\n        return longestFound;\\n    }\\n    \\n    \\n    // Recursively try to find a path from a word (specified by its length and its index into words of \\n    // the same length) backward through predecessors, by comparing the word to all words that are one \\n    // character shorter.  Find the longest path from this word backward through shorter words.  Memorize \\n    // the longest path from a word, so we don\\'t have to recalculate it if we try to find the path from \\n    // this word again.\\n    private int findPath(int len, int wordIdx, short[][] wcs, byte[][] memo, String[] words) {\\n        if (len == 1)  return 1;\\n        if (memo[len][wordIdx] > 0)  return memo[len][wordIdx];\\n        String curWord = words[wcs[len][wordIdx]];\\n        int longest = 0;\\n        for (int predIdx = wcs[len - 1][0]; predIdx >= 1 && longest + 1 < len; predIdx--)\\n            if (isPredecessor(curWord, words[wcs[len - 1][predIdx]]))\\n                longest = Math.max(longest, findPath(len - 1, predIdx, wcs, memo, words));\\n        memo[len][wordIdx] = (byte)(longest + 1);\\n        return longest + 1;\\n    }\\n    \\n    \\n    // Given two words as Strings, test the second word to see if it is a predecessor of the first word.  \\n    // It is a predecessor if the second word differs from the first word by having exactly one character \\n    // in the first word that does not match the characters in the second word.  The first word will be one \\n    // character longer than the second word.  The second word is a predecessor if deleting one character \\n    // from the first word can form the second word.\\n    private boolean isPredecessor(String curWord, String predWord) {\\n        int diffCount = -1;\\n        int predIdx = predWord.length() - 1;\\n        for (int curIdx = curWord.length() - 1; curIdx >= 1; curIdx--) {\\n            if (curWord.charAt(curIdx) != predWord.charAt(predIdx--)) {\\n                if (diffCount++ == 0)  return false;\\n                predIdx++;\\n            }\\n        }\\n        return (predIdx == -1) || (curWord.charAt(0) == predWord.charAt(0));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static final int LONGEST_WORD_LEN = 16;\\n    \\n    public int longestStrChain(String[] words) {\\n        // Calculate number of strings of each length;\\n        int longestCount = 0;\\n        int[] lenCounts = new int[LONGEST_WORD_LEN + 1];\\n        for (int i = words.length - 1; i >= 0; i--)\\n            longestCount = Math.max(longestCount, ++lenCounts[words[i].length()]);\\n        \\n        // Build an array that for each string length, has an array of indexes to words of that  \\n        // length.  Copy the words from the words[] array into the wcs[][] array.  The array wcs \\n        // is indexed by: wcs[string len][index of words of same len].  The wcs[len][0] value is \\n        // the number of words of that same length that are stored in wcs[len].\\n        int maxWordLen = 0;\\n        for (maxWordLen = LONGEST_WORD_LEN; maxWordLen >= 0 && lenCounts[maxWordLen] == 0; maxWordLen--)  { }\\n        short[][] wcs = new short[maxWordLen + 1][longestCount + 1];\\n        for (int i = words.length - 1; i >= 0; i--) {\\n            int len = words[i].length();\\n            wcs[len][++wcs[len][0]] = (short)i;\\n        }\\n        \\n        // Create an uninitialized memorization value for each word now stored as char[] arrays in wcs[][][].\\n        byte[][] memo = new byte[maxWordLen + 1][longestCount + 1];\\n\\n        // Start with the longest words and search backward (longest word to shortest word) to find the \\n        // longest string chain.  Stop searching if the longest string chain found if longer or same \\n        // length as the current word (words are processed longest to shortest), because a longer chain \\n        // is not possible.\\n        int longestFound = 1;\\n        for (int len = maxWordLen; len > 1 && len > longestFound; len--)\\n            for (int wordIdx = wcs[len][0]; wordIdx >= 1 && len > longestFound; wordIdx--)\\n                longestFound = Math.max(longestFound, findPath(len, wordIdx, wcs, memo, words));\\n        return longestFound;\\n    }\\n    \\n    \\n    // Recursively try to find a path from a word (specified by its length and its index into words of \\n    // the same length) backward through predecessors, by comparing the word to all words that are one \\n    // character shorter.  Find the longest path from this word backward through shorter words.  Memorize \\n    // the longest path from a word, so we don\\'t have to recalculate it if we try to find the path from \\n    // this word again.\\n    private int findPath(int len, int wordIdx, short[][] wcs, byte[][] memo, String[] words) {\\n        if (len == 1)  return 1;\\n        if (memo[len][wordIdx] > 0)  return memo[len][wordIdx];\\n        String curWord = words[wcs[len][wordIdx]];\\n        int longest = 0;\\n        for (int predIdx = wcs[len - 1][0]; predIdx >= 1 && longest + 1 < len; predIdx--)\\n            if (isPredecessor(curWord, words[wcs[len - 1][predIdx]]))\\n                longest = Math.max(longest, findPath(len - 1, predIdx, wcs, memo, words));\\n        memo[len][wordIdx] = (byte)(longest + 1);\\n        return longest + 1;\\n    }\\n    \\n    \\n    // Given two words as Strings, test the second word to see if it is a predecessor of the first word.  \\n    // It is a predecessor if the second word differs from the first word by having exactly one character \\n    // in the first word that does not match the characters in the second word.  The first word will be one \\n    // character longer than the second word.  The second word is a predecessor if deleting one character \\n    // from the first word can form the second word.\\n    private boolean isPredecessor(String curWord, String predWord) {\\n        int diffCount = -1;\\n        int predIdx = predWord.length() - 1;\\n        for (int curIdx = curWord.length() - 1; curIdx >= 1; curIdx--) {\\n            if (curWord.charAt(curIdx) != predWord.charAt(predIdx--)) {\\n                if (diffCount++ == 0)  return false;\\n                predIdx++;\\n            }\\n        }\\n        return (predIdx == -1) || (curWord.charAt(0) == predWord.charAt(0));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706963,
                "title": "q1048-accepted-c-used-dp-lis-sort-comparator-easiest",
                "content": "CRUX\\n1) We have a comparator for comparing and sorting the string\\'s according to increasing size\\'s.\\n2) Compare function to check whether the difference between two string\\'s is only of one character.\\n3) Longest Chain Chain is needed neither subsequence or subset therefore it needs sorting.\\n4) This question resemble\\'s to LIS if we talk about the size of string in the word\\'s vector.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        return a.size() < b.size();\\n    }\\n    bool Compare(string &a,string &b){\\n        int i = 0,j = 0;\\n        int m = a.size();\\n        int n = b.size();\\n        if(m != n+1)\\n            return false;\\n        while(i < m){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        if(i == m && j == n)\\n            return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector <int> dp(n,1);\\n        sort(words.begin(),words.end(),comp); // Sorting according to the Size\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(Compare(words[i],words[j]) && dp[j]+1 > dp[i]) // Compare whether diff of string is of only ONE new character.\\n                    dp[i] = 1 + dp[j];\\n            }\\n            maxLen = max(maxLen,dp[i]);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        return a.size() < b.size();\\n    }\\n    bool Compare(string &a,string &b){\\n        int i = 0,j = 0;\\n        int m = a.size();\\n        int n = b.size();\\n        if(m != n+1)\\n            return false;\\n        while(i < m){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        if(i == m && j == n)\\n            return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector <int> dp(n,1);\\n        sort(words.begin(),words.end(),comp); // Sorting according to the Size\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(Compare(words[i],words[j]) && dp[j]+1 > dp[i]) // Compare whether diff of string is of only ONE new character.\\n                    dp[i] = 1 + dp[j];\\n            }\\n            maxLen = max(maxLen,dp[i]);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554698,
                "title": "c-dp-longest-increasing-subsequence-variation",
                "content": "# Intuition\\nSort the words by their size, now apply the LIS concept if **jth string has a size == ith string size - 1** then we check for another condition whether all characters of jth string are present in ith string and in the same order. This can be checked using two pointer technique. And then the dp array will have the length of all increaing subsequences and now we can return the maximum among them as answer.\\n\\n\\n# Code\\n```\\nbool comp(string& a,string& b)\\n{\\n    return a.size()<b.size();\\n}\\nclass Solution {\\npublic:\\n    bool func(string& a,string& b)\\n    {\\n        int ptr1 = 0,ptr2 = 0;\\n        int n1 = a.size(),n2 = b.size();\\n        while(ptr1<n1 && ptr2<n2)\\n        {\\n            if(a[ptr1]==b[ptr2])\\n            {\\n                ptr1++;\\n                ptr2++;\\n            }\\n            else\\n            ptr2++;\\n        }\\n        if(ptr1==n1)\\n        return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),comp);\\n        int n = words.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        dp[i] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                string tmp1 = words[i];\\n                string tmp2 = words[j];\\n                if(tmp2.size()+1==tmp1.size())\\n                {\\n                    if(func(tmp2,tmp1))\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool comp(string& a,string& b)\\n{\\n    return a.size()<b.size();\\n}\\nclass Solution {\\npublic:\\n    bool func(string& a,string& b)\\n    {\\n        int ptr1 = 0,ptr2 = 0;\\n        int n1 = a.size(),n2 = b.size();\\n        while(ptr1<n1 && ptr2<n2)\\n        {\\n            if(a[ptr1]==b[ptr2])\\n            {\\n                ptr1++;\\n                ptr2++;\\n            }\\n            else\\n            ptr2++;\\n        }\\n        if(ptr1==n1)\\n        return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),comp);\\n        int n = words.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        dp[i] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                string tmp1 = words[i];\\n                string tmp2 = words[j];\\n                if(tmp2.size()+1==tmp1.size())\\n                {\\n                    if(func(tmp2,tmp1))\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311205,
                "title": "c-dp-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n*l)+O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(string&s1, string&s2){\\n        if(s1.size()!=s2.size()+1){return false;}\\n        int i=0, j=0;\\n        while(i<s1.size()){\\n            if(s1[i]==s2[j]){\\n                i++; j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(i==s1.size() && j==s2.size()){return true;}\\n        return false;\\n    }\\n    static bool cmp(string&s1, string&s2){\\n        return s1.size()<s2.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        vector<int>dp(n, 1);\\n        sort(words.begin(), words.end(), cmp);\\n        int maxi=1;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(valid(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(string&s1, string&s2){\\n        if(s1.size()!=s2.size()+1){return false;}\\n        int i=0, j=0;\\n        while(i<s1.size()){\\n            if(s1[i]==s2[j]){\\n                i++; j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(i==s1.size() && j==s2.size()){return true;}\\n        return false;\\n    }\\n    static bool cmp(string&s1, string&s2){\\n        return s1.size()<s2.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        vector<int>dp(n, 1);\\n        sort(words.begin(), words.end(), cmp);\\n        int maxi=1;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(valid(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733776,
                "title": "python-o-n-time-and-space-easy-to-undersatnd-dp-solution",
                "content": "```\\ndef longestStrChain(self, words: List[str]) -> int:\\n\\tbucketsort = defaultdict(list)\\n\\tresults = {}\\n\\tfor val in words: \\n\\t\\tbucketsort[len(val)].append(val)\\n\\t\\tresults[val] = 1\\n\\tfor i in reversed(range(1,17)):#from 16 to 1 (bucket sort bounds)\\n\\t\\tfor val in bucketsort[i]:#for each value in the bucket that we are in \\n\\t\\t\\tfor i in range(len(val)):\\n\\t\\t\\t\\tpredecessor = val[:i] + val[i+1:]#all the combinations of values that we can make by deleting a char\\n\\t\\t\\t\\tif predecessor in results: #if we have this value somewhere \\n\\t\\t\\t\\t\\tresults[predecessor] = max(results[predecessor],results[val]+1)\\n\\treturn max(results.values())\\n```\\n\\n**Time complexity: O(n)\\nSpace complexity: O(n)**\\n\\n**Explaination of the algorithm: **\\nWe use bucketsort to iterate through the values with the highest length first, to the shortest length. O(n) \\nInside loop, we iterate through the words from highest length to lowest length.\\nSince the length of a word is at MOST 16, checking if all predecessor of the word exist is O(1) time.\\nIf the predecessor exists, we set it to its value.\\nAt the end of the iterations, we return the highest value that we find. \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\ndef longestStrChain(self, words: List[str]) -> int:\\n\\tbucketsort = defaultdict(list)\\n\\tresults = {}\\n\\tfor val in words: \\n\\t\\tbucketsort[len(val)].append(val)\\n\\t\\tresults[val] = 1\\n\\tfor i in reversed(range(1,17)):#from 16 to 1 (bucket sort bounds)\\n\\t\\tfor val in bucketsort[i]:#for each value in the bucket that we are in \\n\\t\\t\\tfor i in range(len(val)):\\n\\t\\t\\t\\tpredecessor = val[:i] + val[i+1:]#all the combinations of values that we can make by deleting a char\\n\\t\\t\\t\\tif predecessor in results: #if we have this value somewhere \\n\\t\\t\\t\\t\\tresults[predecessor] = max(results[predecessor],results[val]+1)\\n\\treturn max(results.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506227,
                "title": "c-iterative-clean-easy",
                "content": "![image](https://assets.leetcode.com/users/images/cc396b88-b437-4ad7-9abe-1e0b516cd40e_1661882194.5044374.png)\\n\\n\\tbool comp(string& a,string& b){\\n\\t\\treturn b.size()>a.size();\\n\\t}\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool check(string& a,string& b){\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint m=b.size();\\n\\t\\t\\tif(m-n!=1) return false;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(j<m){\\n\\t\\t\\t\\tif(a[i]==b[j] && i<m){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\telse j++;\\n\\t\\t\\t}\\n\\t\\t\\treturn i==n && j==m;\\n\\t\\t}\\n\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n=words.size();\\n\\t\\t\\tsort(words.begin(),words.end(),comp);\\n\\t\\t\\tvector<int> dp(n,1);\\n\\t\\t\\tint maxi=1;\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tfor(int prev=0;prev<i;prev++){\\n\\t\\t\\t\\t\\tif(check(words[prev],words[i])) dp[i]=max(dp[i],1+dp[prev]); \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxi=max(maxi,dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool check(string& a,string& b){\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint m=b.size();\\n\\t\\t\\tif(m-n!=1) return false;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(j<m){\\n\\t\\t\\t\\tif(a[i]==b[j] && i<m){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2251531,
                "title": "c-unordered-map-soln-well-commented-complexity-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    struct comp{    //Comparator function for sorting \\n        bool operator()(string s1,string s2){\\n            return s1.size()<s2.size();\\n        }\\n    };\\n    int longestStrChain(vector<string>& arr) {\\n        sort(begin(arr),end(arr),comp());// Sort asc according to length\\n        unordered_map<string,int>mp; //to  store ans for every word \\n        int ans=1;\\n        for(auto s:arr){//check for every word in arr\\n            mp[s]=1; // string chain must have atleast one word.\\n            for(int i=0;i<s.size();i++){\\n                string temp=s.substr(0,i)+s.substr(i+1); //remove charcter one by one and check if new string (string after removing ith character) is present in map then update value in map and our answer as well.\\n                if(mp.find(temp)!=mp.end()){\\n                    mp[s]=max(mp[s],mp[temp]+1);\\n                    ans=max(ans,mp[s]); //update ans if we get more word in chain.\\n                }\\n            }\\n        }\\n        return ans;  //final\\n    }\\n};\\n\\n// T.C----> O(NlogN)+O(N* max_len_word * max_len_word)\\n// S.C---->O(N)    \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct comp{    //Comparator function for sorting \\n        bool operator()(string s1,string s2){\\n            return s1.size()<s2.size();\\n        }\\n    };\\n    int longestStrChain(vector<string>& arr) {\\n        sort(begin(arr),end(arr),comp());// Sort asc according to length\\n        unordered_map<string,int>mp; //to  store ans for every word \\n        int ans=1;\\n        for(auto s:arr){//check for every word in arr\\n            mp[s]=1; // string chain must have atleast one word.\\n            for(int i=0;i<s.size();i++){\\n                string temp=s.substr(0,i)+s.substr(i+1); //remove charcter one by one and check if new string (string after removing ith character) is present in map then update value in map and our answer as well.\\n                if(mp.find(temp)!=mp.end()){\\n                    mp[s]=max(mp[s],mp[temp]+1);\\n                    ans=max(ans,mp[s]); //update ans if we get more word in chain.\\n                }\\n            }\\n        }\\n        return ans;  //final\\n    }\\n};\\n\\n// T.C----> O(NlogN)+O(N* max_len_word * max_len_word)\\n// S.C---->O(N)    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178896,
                "title": "simple-c-code-o-strings-len-max-string",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    static bool compare(string &a, string &b)\\n    {\\n        if(a.size() < b.size())\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> um;\\n        int ans = 1;\\n        for(string &word : words)\\n        {\\n            //cout << word << \" \";\\n            if(um.count(word)) continue;\\n            um[word]++;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                string s = word;\\n                s.erase(i,1);\\n                if(um.count(s))\\n                {\\n                    int f = um[word];\\n                    um[word] = max(um[s]+1,f);\\n                }\\n            }\\n            //cout << word << \" \" << um[word] << endl;\\n            ans = max(ans,um[word]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool compare(string &a, string &b)\\n    {\\n        if(a.size() < b.size())\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> um;\\n        int ans = 1;\\n        for(string &word : words)\\n        {\\n            //cout << word << \" \";\\n            if(um.count(word)) continue;\\n            um[word]++;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                string s = word;\\n                s.erase(i,1);\\n                if(um.count(s))\\n                {\\n                    int f = um[word];\\n                    um[word] = max(um[s]+1,f);\\n                }\\n            }\\n            //cout << word << \" \" << um[word] << endl;\\n            ans = max(ans,um[word]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2166896,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        #dp stores the inner elements and thier count\\n        dp = defaultdict(lambda : 0)\\n        res = 1\\n        for word in sorted(words,key = len):\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                inner = word[:i]+word[i+1:]\\n                if dp[inner]!=0:\\n                    dp[word] = max(dp[word],dp[inner]+1)\\n                    res = max(res,dp[word])\\n        return res        \\n```\\nUpvote if you like this solution :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        #dp stores the inner elements and thier count\\n        dp = defaultdict(lambda : 0)\\n        res = 1\\n        for word in sorted(words,key = len):\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                inner = word[:i]+word[i+1:]\\n                if dp[inner]!=0:\\n                    dp[word] = max(dp[word],dp[inner]+1)\\n                    res = max(res,dp[word])\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156283,
                "title": "java-easy-approach-deleting-letters-to-form-a-chain-reverse-hashing",
                "content": "\\n\\n    class Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        \\n          Arrays.sort(words,(String a, String b) -> b.length() - a.length());\\n        \\n        HashMap<String,Integer> map=new HashMap();//hash map to increase counter for a string if it can be           formed by deleting a letter from its successor\\n        int max=1;\\n        for(String word:words)\\n            map.put(word,1);//the minimum string chain for every word is 1\\n        for(String word:words){  //TC for this loop structure := O(nk) n-length of array,k-length of word\\n            for(int i=0;i<word.length();i++){\\n                \\n                String s=word.substring(0,i)+word.substring(i+1);\\n                if(map.containsKey(s)){\\n                    \\n                    //do\\n                    map.put(s,Math.max(map.get(s),map.get(word)+1)); //store the max value of string chain upto this s word till now\\n                    \\n                    \\n                }\\n            }\\n            max=Math.max(max,map.getOrDefault(word,0));\\n        }\\n        return max;\\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        \\n          Arrays.sort(words,(String a, String b) -> b.length() - a.length());\\n        \\n        HashMap<String,Integer> map=new HashMap();//hash map to increase counter for a string if it can be           formed by deleting a letter from its successor\\n        int max=1;\\n        for(String word:words)\\n            map.put(word,1);//the minimum string chain for every word is 1\\n        for(String word:words){  //TC for this loop structure := O(nk) n-length of array,k-length of word\\n            for(int i=0;i<word.length();i++){\\n                \\n                String s=word.substring(0,i)+word.substring(i+1);\\n                if(map.containsKey(s)){\\n                    \\n                    //do\\n                    map.put(s,Math.max(map.get(s),map.get(word)+1)); //store the max value of string chain upto this s word till now\\n                    \\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2156011,
                "title": "a-simple-approach-with-golang",
                "content": "```\\nfunc longestStrChain(words []string) int {\\n    \\n    \\n    wordMap := make(map[string]int, len(words))\\n    \\n    // note the syntax\\n    sort.Slice(words, func(i, j int) bool {\\n        if len(words[i]) > len(words[j]) {\\n            return true\\n        }\\n        return false\\n    })\\n    \\n    // the initial chain for every word is 1 and we have it in a map for easy lookup\\n    for _, word := range words {\\n        wordMap[word] = 1\\n    }\\n    \\n    // for every word, I store the longest chain till that word, as the words are sorted in descending order\\n    // example: bdca - 1 | bda - 2 | bca - 2 | ba - 3 | b - 4 | a -4\\n    longestChain := 0\\n    for _, word := range words {\\n        \\n        for i:=0; i<len(word); i++ {\\n            newWord := word[:i] + word[i+1:]\\n            \\n            if _, ok := wordMap[newWord]; ok {\\n                wordMap[newWord] = max(wordMap[word]+1, wordMap[newWord])\\n            }\\n        }\\n        \\n        // to hold the max among all words, and we are traversing all the words so we definitely get the max\\n        longestChain = max(wordMap[word], longestChain)\\n    }\\n    \\n    return longestChain\\n}\\n\\nfunc max (a,b int) int {\\n    if b > a {\\n        return b\\n    }\\n    return a\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nfunc longestStrChain(words []string) int {\\n    \\n    \\n    wordMap := make(map[string]int, len(words))\\n    \\n    // note the syntax\\n    sort.Slice(words, func(i, j int) bool {\\n        if len(words[i]) > len(words[j]) {\\n            return true\\n        }\\n        return false\\n    })\\n    \\n    // the initial chain for every word is 1 and we have it in a map for easy lookup\\n    for _, word := range words {\\n        wordMap[word] = 1\\n    }\\n    \\n    // for every word, I store the longest chain till that word, as the words are sorted in descending order\\n    // example: bdca - 1 | bda - 2 | bca - 2 | ba - 3 | b - 4 | a -4\\n    longestChain := 0\\n    for _, word := range words {\\n        \\n        for i:=0; i<len(word); i++ {\\n            newWord := word[:i] + word[i+1:]\\n            \\n            if _, ok := wordMap[newWord]; ok {\\n                wordMap[newWord] = max(wordMap[word]+1, wordMap[newWord])\\n            }\\n        }\\n        \\n        // to hold the max among all words, and we are traversing all the words so we definitely get the max\\n        longestChain = max(wordMap[word], longestChain)\\n    }\\n    \\n    return longestChain\\n}\\n\\nfunc max (a,b int) int {\\n    if b > a {\\n        return b\\n    }\\n    return a\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2155458,
                "title": "c-dynamic-programming-largest-increasing-subsequence-concept",
                "content": "**Explanation**:\\n-  this question is based totally on **Longest Increasing subsequence** pattern. which uses **dynamic programming** concept.\\n-   in original problem, we have two numbers which we compare. instead here we are checking if two string can form a chain or not.\\n-   rest the whole code is same.\\n-   for comparing two string, \\n    - we are considering its size: there should be exactly difference of 1.\\n    - all the characters of string `a` should be in `b`.\\n\\n\\n**Space complexity**: $O(n)$\\n**time complexity**: $O(n^2 . l)$ \\n- `l` is maximum length of string.\\n- `n` is size of input array\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words)\\n    {\\n        int n = words.size();\\n\\n        sort(words.begin(), words.end(), [](string& a, string& b) {\\n            return a.size() < b.size();\\n        });\\n\\n        vector<int> lis(n, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (isChainable(words[j], words[i]) && lis[i] <= lis[j] + 1) {\\n                    lis[i] = lis[j] + 1;\\n                }\\n            }\\n        }\\n\\n        return *max_element(lis.begin(), lis.end());\\n    }\\n\\n    bool isChainable(string& a, string& b)\\n    {\\n        if (a.size() + 1 != b.size())\\n            return false;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < a.size() && j < b.size()) {\\n            if (a[i] == b[j])\\n                i++;\\n            j++;\\n        }\\n\\n        return i == a.size();\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words)\\n    {\\n        int n = words.size();\\n\\n        sort(words.begin(), words.end(), [](string& a, string& b) {\\n            return a.size() < b.size();\\n        });\\n\\n        vector<int> lis(n, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (isChainable(words[j], words[i]) && lis[i] <= lis[j] + 1) {\\n                    lis[i] = lis[j] + 1;\\n                }\\n            }\\n        }\\n\\n        return *max_element(lis.begin(), lis.end());\\n    }\\n\\n    bool isChainable(string& a, string& b)\\n    {\\n        if (a.size() + 1 != b.size())\\n            return false;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < a.size() && j < b.size()) {\\n            if (a[i] == b[j])\\n                i++;\\n            j++;\\n        }\\n\\n        return i == a.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154580,
                "title": "dynamic-programming",
                "content": "First we will sort the array according to length of words because we want a chain of increasing length, Next we will create a dp array for all words where we will equal all words to one and we will start equating on all words.\\nSo in equalOrnot function, we will remove each letter of the word and will equate with any of the words in dp,\\nif present we will see which one of the two (dp[word] and 1+dp[wordwithremovedletter]) is big and we will take max of them into dp[word].\\nand at last we will return the max of dp.values()\\n\\'\\'\\'\\n*class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        @lrucache(None)\\n        def equalOrnot(s1):\\n            n=len(s1)\\n            for i in range(0,n):\\n                if i==0:\\n                    if s1[1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[1:n]])\\n                if i==n-1:\\n                    if s1[0:n-1] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:n-1]])\\n                else:\\n                    if s1[0:i]+s1[i+1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:i]+s1[i+1:n]])\\n        dp={}\\n        for i in words:\\n            dp[i]=1\\n        words=sorted(words,key=len)\\n        for i in range(1,len(words)):\\n                equalOrnot(words[i])\\n        return max(dp.values())\\n\\t\\t\\'\\'\\'*",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        @lrucache(None)\\n        def equalOrnot(s1):\\n            n=len(s1)\\n            for i in range(0,n):\\n                if i==0:\\n                    if s1[1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[1:n]])\\n                if i==n-1:\\n                    if s1[0:n-1] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:n-1]])\\n                else:\\n                    if s1[0:i]+s1[i+1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:i]+s1[i+1:n]])\\n        dp={}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2068847,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1920261,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1570714,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1568570,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1565730,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068856,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2069237,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068876,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2036438,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1576899,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068847,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1920261,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1570714,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1568570,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1565730,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068856,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2069237,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068876,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2036438,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1576899,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1938797,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1573172,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1570242,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069033,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069022,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2068884,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1573041,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1573059,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069881,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069805,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069773,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069747,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069614,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069587,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069523,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069460,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069432,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069341,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069327,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069275,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069264,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2069256,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2069165,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2069015,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068946,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068944,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068890,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068869,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2049608,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 1963572,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Operations to Make Array Equal",
        "question_content": "<p>You have an array <code>arr</code> of length <code>n</code> where <code>arr[i] = (2 * i) + 1</code> for all valid values of <code>i</code> (i.e.,&nbsp;<code>0 &lt;= i &lt; n</code>).</p>\n\n<p>In one operation, you can select two indices <code>x</code> and <code>y</code> where <code>0 &lt;= x, y &lt; n</code> and subtract <code>1</code> from <code>arr[x]</code> and add <code>1</code> to <code>arr[y]</code> (i.e., perform <code>arr[x] -=1 </code>and <code>arr[y] += 1</code>). The goal is to make all the elements of the array <strong>equal</strong>. It is <strong>guaranteed</strong> that all the elements of the array can be made equal using some operations.</p>\n\n<p>Given an integer <code>n</code>, the length of the array, return <em>the minimum number of operations</em> needed to make all the elements of arr equal.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1145020,
                "title": "js-python-java-c-easy-o-1-1-liner-mathematical-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem has a very simple mathematical solution.\\n\\nThe obvious thing here is that the array formed by the instructions is a **linear progression**. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift **1** from the right (higher) side to the left (lower) side. This process would lead to a **triangular number** of operations, modified by the fact that each value starts off **2** less/more than the ones on either side, rather than **1**.\\n\\nTake, for example, the case of **n = 7**, or **[1,3,5,7,9,11,13]**. We would perform the operation twice on the **5** & **9** pair, four times on the **3** & **11** pair, and six times on the **1** & **13** pair, bringing all values to the median of **7** with a total of **12** operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are **2** apart, rather than **1**. The standard formula for a triangular number is **n * (n + 1) / 2**. Since our triangular number is only half the length of array, not counting the middle, that equates to **2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2**, which simplifies to **(n^2 - 1) / 4**.\\n\\nBut that\\'s when **n** is odd and the middle is conveniently a point. What if **n** is even?\\n\\nIf **n** is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (*which is incidentally why the problem specified a **2** value difference in each array element, to prevent impossible fractions*). In this case, we\\'re doing the same process, only on **(n - 2) / 2** elements rather than **(n - 1) / 2** elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another **n / 2** operations to move the right side down **1** and the left side up **1**.\\n\\nThat formula becomes **2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2**, which simplifies nicely down to **n^2 / 4.**\\n\\nThus the only difference between the two formulas is the **- 1** present in the odd version, which is basically the rounding error if **n** is **odd**, and can be corrected by **floor**ing (or double **bitwise NOT**\\'ing) the result.\\n\\n***On a more intuitive note***, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area **n * 2n**, or **2n^2**. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is **1/8**th the area of the box, or **2n^2 / 8**, or **n^2 / 4**\\n\\n![Visual 1](https://i.imgur.com/YlyS1Db.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython\\'s floor division operator will actually take care of the difference for us, as will the natural int-casting of the return value in Java and C++.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 38.6MB** (beats 95% / 90%).\\n```javascript\\nvar minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.2MB** (beats 100% / 75%).\\n```python\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return n * n // 4\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.5MB** (beats 100% / 89%).\\n```java\\nclass Solution {\\n    public int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 2.4%).\\n```c++\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};\\n```\n```python\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return n * n // 4\\n```\n```java\\nclass Solution {\\n    public int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145082,
                "title": "simple-o-1-1-liner-easy-solution-w-explanation-beats-100",
                "content": "***Solution (Make Equal to Mid Element)***\\n\\nThe main thing in this problem is that we must realize that to make array equal in minimum operations, we need to **make all the elements equal to the Mid element** (which would be equal to `n`). Also, if we make the first half equal to the mid element, the other half will also become equal since one operation consists of adding and subtracting. There will always be a pair of elements which need same number of addition and subtraction to become equal to mid.\\n\\nFor this, there exists two cases. You may understand it better if you consider an example alongside -\\n\\n* **n is Odd** : In this case, all the elements need to become equal to the mid element( equal to `n`). This is done by adding 1 to elements smaller than mid and subtracting 1 from elements bigger than mid till all become equal.\\n\\n\\tThe **total number of operations** needed are - `2 + 4 + 6 + 8 + ... (n - 1) /2 elements`. How `(n - 1) / 2` elements ? These correspond to the number to elements coming before mid. So, we need to apply operations to all those elements (2 times, 4 times, 6 times and so on...).\\n\\t\\n\\tThe given equation is in *Arithmetic Progression*, which can be simplified to - \\n\\t```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [2 + ((N -1)) * 2) / 2]\\n\\t=  N * [2 + N - 1]\\n\\t=  N * [N + 1]\\n\\twhere N = number of elements in the Arithmetic Progression = (n -1) / 2 \\n\\t```\\n\\n* **n is Even** - In this case, all the elements need to become equal to the mean of mid elements (equal to `n`). Again, the operations are applied as in the case when n is odd by adding to smaller than mid & subtracting from larger than mid elements.\\n\\n\\tThe **total number of operations** needed are - `1 + 3 + 5 + 7 + ... n /2 elements`. How `n / 2` elements ? These again correspond to the number to elements coming before the mean of mid elements. In even case, the first half and second half contains n/2 elements each. So, we need to apply operations to all those elements (1 times, 3 times, 5 times and so on...).\\n\\t\\n\\tThe given equation is in *Arithmetic Progression*, which can be simplified to - \\n\\t```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [1 + ((N - 1) * 2) / 2]\\n\\t=  N * [1 + N - 1]\\n\\t=  N * N\\n\\twhere N = number of elements in the Arithmetic Progression = n / 2 \\n\\t```\\n\\t\\n----\\t\\n\\t\\nThe implementation of above idea is given below - \\n\\n```\\nint minOperations(int n) {\\n\\tif(n & 1){ // Odd Case\\n\\t\\tint N = (n - 1) / 2;  // number of elements before mid element\\n\\t\\treturn N * (N + 1); \\n\\t}\\n\\tint N = n / 2;  // number of elements before mean of mid elements\\n\\treturn N * N; \\n}\\n```\\n\\n***Time Complexity :*** **`O(1)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n----\\n\\n***Solution - II (1 - Liner)***\\n\\nThe below is the same solution as above just modified into 1-Liner. Just apply simple math to simplify the above equations -\\n\\n```\\nint minOperations(int n) {\\n\\treturn (n & 1 ? n * --n : n * n) >> 2;    // x >> 2 = x / 4\\n}\\n```\\n\\n*More Simplfied -*\\n\\n```\\nint minOperations(int n) {\\n\\treturn n * n >> 2; // or n*n/4\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1fe0195b-2da0-41f3-95ea-66f9b6e8cec6_1617696798.1046119.png)\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [2 + ((N -1)) * 2) / 2]\\n\\t=  N * [2 + N - 1]\\n\\t=  N * [N + 1]\\n\\twhere N = number of elements in the Arithmetic Progression = (n -1) / 2 \\n\\t```\n```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [1 + ((N - 1) * 2) / 2]\\n\\t=  N * [1 + N - 1]\\n\\t=  N * N\\n\\twhere N = number of elements in the Arithmetic Progression = n / 2 \\n\\t```\n```\\nint minOperations(int n) {\\n\\tif(n & 1){ // Odd Case\\n\\t\\tint N = (n - 1) / 2;  // number of elements before mid element\\n\\t\\treturn N * (N + 1); \\n\\t}\\n\\tint N = n / 2;  // number of elements before mean of mid elements\\n\\treturn N * N; \\n}\\n```\n```\\nint minOperations(int n) {\\n\\treturn (n & 1 ? n * --n : n * n) >> 2;    // x >> 2 = x / 4\\n}\\n```\n```\\nint minOperations(int n) {\\n\\treturn n * n >> 2; // or n*n/4\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145066,
                "title": "minimum-operations-to-make-array-equal-easy-o-1-1-liner-explained",
                "content": "***Solution (Make Equal to Mid Element)***\\n\\nThe main thing in this problem is that we must realize that to make array equal in minimum operations, we need to **make all the elements equal to the Mid element** (which would be equal to `n`). Also, if we make the first half equal to the mid element, the other half will also become equal since one operation consists of adding and subtracting. There will always be a pair of elements which need same number of addition and subtraction to become equal to mid.\\n\\nFor this, there exists two cases. You may understand it better if you consider an example alongside -\\n\\n* **n is Odd** : In this case, all the elements need to become equal to the mid element( equal to `n`). This is done by adding 1 to elements smaller than mid and subtracting 1 from elements bigger than mid till all become equal.\\n\\n\\tThe **total number of operations** needed are - `2 + 4 + 6 + 8 + ... (n - 1) /2 elements`. How `(n - 1) / 2` elements ? These correspond to the number to elements coming before mid. So, we need to apply operations to all those elements (2 times, 4 times, 6 times and so on...).\\n\\t\\n\\tThe given equation is in *Arithmetic Progression*, which can be simplified to - \\n\\t```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [2 + ((N -1)) * 2) / 2]\\n\\t=  N * [2 + N - 1]\\n\\t=  N * [N + 1]\\n\\twhere N = number of elements in the Arithmetic Progression = (n -1) / 2 \\n\\t```\\n\\n* **n is Even** - In this case, all the elements need to become equal to the mean of mid elements (equal to `n`). Again, the operations are applied as in the case when n is odd by adding to smaller than mid & subtracting from larger than mid elements.\\n\\n\\tThe **total number of operations** needed are - `1 + 3 + 5 + 7 + ... n /2 elements`. How `n / 2` elements ? These again correspond to the number to elements coming before the mean of mid elements. In even case, the first half and second half contains n/2 elements each. So, we need to apply operations to all those elements (1 times, 3 times, 5 times and so on...).\\n\\t\\n\\tThe given equation is in *Arithmetic Progression*, which can be simplified to - \\n\\t```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [1 + ((N - 1) * 2) / 2]\\n\\t=  N * [1 + N - 1]\\n\\t=  N * N\\n\\twhere N = number of elements in the Arithmetic Progression = n / 2 \\n\\t```\\n\\t\\n----\\t\\n\\t\\nThe implementation of above idea is given below - \\n\\n```\\nint minOperations(int n) {\\n\\tif(n & 1){ // Odd Case\\n\\t\\tint N = (n - 1) / 2;  // number of elements before mid element\\n\\t\\treturn N * (N + 1); \\n\\t}\\n\\tint N = n / 2;  // number of elements before mean of mid elements\\n\\treturn N * N; \\n}\\n```\\n\\n***Time Complexity :*** **`O(1)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n----\\n\\n***Solution - II (1 - Liner)***\\n\\nThe below is the same solution as above just modified into 1-Liner. Just apply simple math to simplify the above equations -\\n\\n```\\nint minOperations(int n) {\\n\\treturn (n & 1 ? n * --n : n * n) >> 2;    // x >> 2 = x / 4\\n}\\n```\\n\\n*More Simplfied -*\\n\\n```\\nint minOperations(int n) {\\n\\treturn n * n >> 2; // or n*n/4\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1fe0195b-2da0-41f3-95ea-66f9b6e8cec6_1617696798.1046119.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [2 + ((N -1)) * 2) / 2]\\n\\t=  N * [2 + N - 1]\\n\\t=  N * [N + 1]\\n\\twhere N = number of elements in the Arithmetic Progression = (n -1) / 2 \\n\\t```\n```\\n\\t=> N * [a + ((N - 1) * d) / 2]      // A.P Formula\\n\\t=  N * [1 + ((N - 1) * 2) / 2]\\n\\t=  N * [1 + N - 1]\\n\\t=  N * N\\n\\twhere N = number of elements in the Arithmetic Progression = n / 2 \\n\\t```\n```\\nint minOperations(int n) {\\n\\tif(n & 1){ // Odd Case\\n\\t\\tint N = (n - 1) / 2;  // number of elements before mid element\\n\\t\\treturn N * (N + 1); \\n\\t}\\n\\tint N = n / 2;  // number of elements before mean of mid elements\\n\\treturn N * N; \\n}\\n```\n```\\nint minOperations(int n) {\\n\\treturn (n & 1 ? n * --n : n * n) >> 2;    // x >> 2 = x / 4\\n}\\n```\n```\\nint minOperations(int n) {\\n\\treturn n * n >> 2; // or n*n/4\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794236,
                "title": "java-o-1-constant-time-solution-with-detailed-explanation",
                "content": "Basic Approach:\\n            if n is odd, suppose n=5.\\n                The array is :\\n                1 3 5 7 9.\\n                Here, we will have the middle element as 5. \\n                We take 2 from 7 and add to 3 to make each one 5.\\n                We take 4 from 9 and add to 1 to make each one 5.\\n                Total steps: 2+4=6. (sum of first n/2 even numbers)  \\n\\t\\t\\t\\tSum of first k EVEN numbers = \\n\\t\\t\\t\\tSum(i=1 to k) {2 * i} = 2 * ( Sum(i=1 to k){ i } )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 2 * (k*(k+1))/2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= k*(k+1)\\n           if n is even, suppose n=6.\\n                The array is :\\n                1 3 5 7 9 11.\\n                Here, we will have the middle element as (5+7)/2=6.\\n                We take 1 from 7 and add to 5 to make each one 6.\\n                We take 3 from 9 and add to 3 to make each one 6.\\n                We take 5 from 11 and add to 1 to make each one 6.\\n                Total steps: 1+3+5=9. (sum of first n/2 odd numbers) \\n\\t\\t\\t\\tSum of first k ODD numbers = k * k.\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n\\t// Take care of overflow if n is too large.\\n        if(n%2==1){\\n            n/=2;\\n            return (n*(n+1));\\n        }        \\n        n/=2;\\n        return n*n;\\n    }\\n}\\n```\\nThanks for reading. Please share and upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n\\t// Take care of overflow if n is too large.\\n        if(n%2==1){\\n            n/=2;\\n            return (n*(n+1));\\n        }        \\n        n/=2;\\n        return n*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794163,
                "title": "java-2-lines",
                "content": "if odd length:\\nneed 2, 4 .. , 2 * ( n / 2) ops, that is n / 2 * (2 +  2 * (n / 2)) / 2 = n / 2 * (n / 2 + 1) ;\\n\\nif even length:\\nneed 1, 3 .. , 2 * ( n / 2)  - 1 ops, that is n / 2 * (1 +  2 * (n / 2) - 1) / 2 = n / 2 * (n / 2) ;\\n```\\n    public int minOperations(int n) {\\n        int cnt = n / 2;\\n        return cnt * (cnt + n % 2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperations(int n) {\\n        int cnt = n / 2;\\n        return cnt * (cnt + n % 2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145077,
                "title": "python-math-oneliner-explained",
                "content": "All we need to do in this problem is to use some school math. There will be two cases we need to consider, `odd` and `even` n. Let us consider `odd` case first:\\n\\n1. **Odd** case: consider `1, 3, 5, 7, 9, 11, 13, 15, 17` to see the pattern. Then we need to make all numbers equal to `9`. How many operations we need? For pair `7,11` we need `2` operations, for `5,13` we need `4` operation, then `6` and `8`. In total we need `2+4+6+8 = 20` operations. How to calculate it in general case? If `n = 2k + 1`, then we need to calculate `2 + 4 + ... + 2k`, which is the sum of arithmetic progression and equal to `k*(k+1) = (n*n-1)//4`.\\n2. **Even** case: consider `1, 3, 5, 7, 9, 11, 13, 15` to see the pattern. Then we need to make all numbers equal to `8`. We need `1 + 3+ 5 + 7 = 16` operations and in general case we need `1 + 3 + ... + 2k-1 = k*k = n*n//4` operations.\\n3. Finally we can write down it as one formula, using rounding.\\n\\n#### Complexity\\nTime and space complexity is just `O(1)`\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minOperations(self, n):\\n        return n*n//4\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, n):\\n        return n*n//4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145017,
                "title": "minimum-operations-to-make-array-equal-js-python-java-c-easy-o-1-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem has a very simple mathematical solution.\\n\\nThe obvious thing here is that the array formed by the instructions is a **linear progression**. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift **1** from the right (higher) side to the left (lower) side. This process would lead to a **triangular number** of operations, modified by the fact that each value starts off **2** less/more than the ones on either side, rather than **1**.\\n\\nTake, for example, the case of **n = 7**, or **[1,3,5,7,9,11,13]**. We would perform the operation twice on the **5** & **9** pair, four times on the **3** & **11** pair, and six times on the **1** & **13** pair, bringing all values to the median of **7** with a total of **12** operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are **2** apart, rather than **1**. The standard formula for a triangular number is **n * (n + 1) / 2**. Since our triangular number is only half the length of array, not counting the middle, that equates to **2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2**, which simplifies to **(n^2 - 1) / 4**.\\n\\nBut that\\'s when **n** is odd and the middle is conveniently a point. What if **n** is even?\\n\\nIf **n** is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (*which is incidentally why the problem specified a **2** value difference in each array element, to prevent impossible fractions*). In this case, we\\'re doing the same process, only on **(n - 2) / 2** elements rather than **(n - 1) / 2** elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another **n / 2** operations to move the right side down **1** and the left side up **1**.\\n\\nThat formula becomes **2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2**, which simplifies nicely down to **n^2 / 4.**\\n\\nThus the only difference between the two formulas is the **- 1** present in the odd version, which is basically the rounding error if **n** is **odd**, and can be corrected by **floor**ing (or double **bitwise NOT**\\'ing) the result.\\n\\n***On a more intuitive note***, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area **n * 2n**, or **2n^2**. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is **1/8**th the area of the box, or **2n^2 / 8**, or **n^2 / 4**\\n\\n![Visual 1](https://i.imgur.com/YlyS1Db.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython\\'s floor division operator will actually take care of the difference for us, as will the natural int-casting of the return value in Java and C++.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 38.6MB** (beats 95% / 90%).\\n```javascript\\nvar minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.2MB** (beats 100% / 75%).\\n```python\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return n * n // 4\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.5MB** (beats 100% / 89%).\\n```java\\nclass Solution {\\n    public int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 2.4%).\\n```c++\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minOperations = function(n) {\\n    return ~~(n * n / 4)\\n};\\n```\n```python\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return n * n // 4\\n```\n```java\\nclass Solution {\\n    public int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794165,
                "title": "self-explanatory-code-explained-with-steps",
                "content": "arr[i] =  `2*i + 1` ==> which will generate sequence of first odd numbers \\nlet n = 5 => [1, 3, 5, 7, 9]\\nlet n = 6 => [1, 3, 5, 7, 9, 11]\\n\\noptimal way to make all equal is to make all numbers equals to n.\\n\\nwe will club two numbers together like 1, 9 take them to 5, 3, 7 take them to 5  =>  4 + 2 = 6\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int op = 0;\\n        int odd = 1;\\n        while(odd < n) {\\n            op += n - odd;\\n            odd += 2;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int op = 0;\\n        int odd = 1;\\n        while(odd < n) {\\n            op += n - odd;\\n            odd += 2;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794149,
                "title": "java-detailed-explanation-with-example",
                "content": "**METHOD IS TO CONVERT ALL NUMBERS TO THE MEAN OF THE ARRAY**\\nlet n=5(IT\\'S NOTHING BUT AN ARRAY OF N CONSECUTIVE ODD INTEGERS)\\nthen array[1,3,5,7,9], mean is (1+9)/2=5\\nthen the best method to minimize the conversion steps will be to convert all numbers to array mean (1+9)/2=5\\nsince \\nNumber of. operations to convert 1 and 9 to 5 is= 4 steps\\nNumber of. operations to convert 3 and 7 to 5 is= 2 steps\\nNumber of. operations to convert 5 to 5 is= 0 steps\\nhence 4+2+0=6 is answer\\n**CONCLUSION- number of steps to convert the first half==number of steps to convert second half**\\n**SO WE JUST NEED TO FIND STEPS FOR THE FIRST HALF**\\n**NOTE- MEAN OF N CONSECUTIVE ODD INTEGERS IS N**\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        if(n==0 || n==1)\\n            return 0;\\n        int count=0;\\n        for(int i=0;i<n/2;i++)// for the first half\\n        {\\n            count+=(n-(2*i+1));// mean will always be \\'n\\' reason given in the note above (try yourself)\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        if(n==0 || n==1)\\n            return 0;\\n        int count=0;\\n        for(int i=0;i<n/2;i++)// for the first half\\n        {\\n            count+=(n-(2*i+1));// mean will always be \\'n\\' reason given in the note above (try yourself)\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488289,
                "title": "c-c-javascript-the-shortest-solutions-are-there",
                "content": "# Intuition:\\n![image.png](https://assets.leetcode.com/users/images/e4fd3842-9330-463c-8df3-515cc90ecec4_1683274258.4139304.png)\\nif you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![photo_2023-05-05_13-11-09.jpg](https://assets.leetcode.com/users/images/1fc87bfb-99bb-4b34-b4f9-796f2c51769b_1683274417.5123234.jpeg)\\n\\n```javascript []\\nvar minOperations = (n) =>n*n/4; \\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       return n*n/4; \\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n\\n    public int MinOperations(int n) => n*n/4;\\n\\n}\\n```\\n\\n![Vote.png](https://assets.leetcode.com/users/images/b1b63813-16ae-4cea-8923-121576c1b7fb_1683274036.8745968.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript"
                ],
                "code": "```javascript []\\nvar minOperations = (n) =>n*n/4; \\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       return n*n/4; \\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n\\n    public int MinOperations(int n) => n*n/4;\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145756,
                "title": "java-simple-mathematics",
                "content": "**EXPLANATION AND IDEA:**\\nCase 1: when n is odd\\nLet say n is 5 \\n```\\narr = [1 ,3 , 5 , 7, 9]\\n```\\nIn one operation we can +1 arr[x] and -1 arr[y] where x<y . okay so best way to operate is fix mid that mean change every value to arr[mid]=5  ,  do operation on neighbours. i.e x=mid-1 , y=mid+1\\n```\\n           arr = [1    , 3   , 5  ,  7   , 9 ]\\n                  +4    +2      0    -2   -4\\nafter     arr  = [5   ,  5   , 5  ,  5  ,  5  ] \\t\\t\\t\\t  \\n```\\nTotal operation :\\n=4+ 2 \\n=2(2+1)\\n=2(1+2) where 2 is n/2 let say mid=n/2\\n=2(sum(mid))  sum: 1 + 2 + 3 + .. n/2 (sum(x) : sum of x natural number)\\n=2 ( mid * (mid + 1) ) /2\\n=mid *( mid+1 )\\n\\nCASE 2: when n is even \\nlet say n=4\\n```\\narr = [ 1 , 3 , 5 , 7]\\n```\\nIdea is same match the number around mid. but here dont have proper mid so change this mid i.e 3 to 4 and 5 to 4 by performing one operation and now change every value of array to 4.\\n```\\n  arr= [ 1  , 3  , 5  , 7  ]\\n         +3  +1   -1   -3\\n\\tarr =[4 ,  4 ,  4 ,  4]\\t\\t\\n```\\t\\t\\t\\nTotal operation:\\n=1+3   (where 3 is n/2+1)\\n=1 + 3 + 5 + 7 + ... (mid+1) [ aritmatic progression with a=1 , d =2 , total terms = n/2 i.e mid] \\n(Sum = n/2[2a + (n \\u2212 1) \\xD7 d])\\n=mid * mid \\n     \\n**CODE:** \\n```\\n   public int minOperations(int n) {\\n        int mid=n/2;\\n        return n%2==0?mid*mid:mid*(mid+1);\\n    }\\n```\\n\\nAnother way to code:\\n```\\npublic int minOperations(int n) {\\n        int mid=n/2;\\n        return mid*(mid+n%2);\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(1) and Space:O(1)`\\n\\nPlease **upvote**  if found it helpful and feel free to reach out to me or comment down if you have any doubt.\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\narr = [1 ,3 , 5 , 7, 9]\\n```\n```\\n           arr = [1    , 3   , 5  ,  7   , 9 ]\\n                  +4    +2      0    -2   -4\\nafter     arr  = [5   ,  5   , 5  ,  5  ,  5  ] \\t\\t\\t\\t  \\n```\n```\\narr = [ 1 , 3 , 5 , 7]\\n```\n```\\n  arr= [ 1  , 3  , 5  , 7  ]\\n         +3  +1   -1   -3\\n\\tarr =[4 ,  4 ,  4 ,  4]\\t\\t\\n```\n```\\n   public int minOperations(int n) {\\n        int mid=n/2;\\n        return n%2==0?mid*mid:mid*(mid+1);\\n    }\\n```\n```\\npublic int minOperations(int n) {\\n        int mid=n/2;\\n        return mid*(mid+n%2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794196,
                "title": "c-easy-to-understand-with-explanation",
                "content": "Minimum Operations to make array equal will be to make all the elments equal to mid of the array.\\nSo, the result will be to find the diff (n-arr[i]) till mid of the array\\n    1 - 1\\n    2 - 1,3 - 2,2\\n    3 - 1,3,5 - 2,3,4, - 3,3,3\\n    4 - 1,3,5,7 - 2,3,5,6- 3,3,4,6 - 3,4,4,5 - 4,4,4,4\\n    5 - 1,3,5,7,9 - 2,3,5,7,8 - 3,3,5,7,7 - 4,3,5,7,6 - 5,3,5,7,5 - 5,4,5,6,5 - 5,5,5,5,5\\n```\\n    int minOperations(int n) {\\n        int res = 0;\\n        for(int i =0; i < n/2;i++)\\n        {\\n            res += n-(2*i + 1);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Minimum Operations to make array equal will be to make all the elments equal to mid of the array.\\nSo, the result will be to find the diff (n-arr[i]) till mid of the array\\n    1 - 1\\n    2 - 1,3 - 2,2\\n    3 - 1,3,5 - 2,3,4, - 3,3,3\\n    4 - 1,3,5,7 - 2,3,5,6- 3,3,4,6 - 3,4,4,5 - 4,4,4,4\\n    5 - 1,3,5,7,9 - 2,3,5,7,8 - 3,3,5,7,7 - 4,3,5,7,6 - 5,3,5,7,5 - 5,4,5,6,5 - 5,5,5,5,5\\n```\\n    int minOperations(int n) {\\n        int res = 0;\\n        for(int i =0; i < n/2;i++)\\n        {\\n            res += n-(2*i + 1);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1145030,
                "title": "c-easy-explanation-100-fast-short-code",
                "content": "In this question we have array where A[i] = 2i + 1. \\n\\n* For making elements equal we try to reduce all elements to a central number as it is closest to elements on both sides of it.\\n* If number of elements are odd we have a central element and we try to reduce elements on its sides to that number. {1,3,5,7,9} (In this for reducing 3 and 7 we need 2 operations as we can reduce just 1 in one operation so in 2 operations we get {1,5,5,5,9} similary for 1 and 9 we need 4 operations and so on). So we will need 2 + 4 + ....... n/2 operations.\\n* In even case we will reduce to a central number but this time operations will start from 1 and next 3 and so on because {1,3,5,7} has center number 4 and it needs 1 operation to make 3,4,5 equal then it will need 3 operation. Total operation will be 1+3+5 + .... n/2 operations.\\n* We need n/2 operations because we update both sides in a single operation.\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(int start, int diff,int elements){\\n        int ans = 0;\\n        for(int i = 0 ; i< elements ; i++)\\n        {\\n            ans = ans + start;\\n            start = start + diff;\\n        }\\n        return ans;\\n    }\\n    \\n    int minOperations(int n) {\\n        //if n is odd then we have a center number and try to reduce other numbers to center number with number of operations starting from 2 and next being 4 and 6 and so on.\\n        if(n % 2 != 0){\\n            return helper(2,2,n/2);\\n        } // if n is even then we try to reduce numbers of a number that is mid of two middle elements with number of operations starting from 1 and next 3 and 5 and so on.\\n        else{\\n            return helper(1,2,n/2);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(int start, int diff,int elements){\\n        int ans = 0;\\n        for(int i = 0 ; i< elements ; i++)\\n        {\\n            ans = ans + start;\\n            start = start + diff;\\n        }\\n        return ans;\\n    }\\n    \\n    int minOperations(int n) {\\n        //if n is odd then we have a center number and try to reduce other numbers to center number with number of operations starting from 2 and next being 4 and 6 and so on.\\n        if(n % 2 != 0){\\n            return helper(2,2,n/2);\\n        } // if n is even then we try to reduce numbers of a number that is mid of two middle elements with number of operations starting from 1 and next 3 and 5 and so on.\\n        else{\\n            return helper(1,2,n/2);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087528,
                "title": "java-2-solutions-with-pictures",
                "content": "# Please Upvote :D\\n---\\n### 1. Naive solution using a loop:\\n##### When `n` is odd:\\n![image.png](https://assets.leetcode.com/users/images/23e33018-fb0a-4d00-a796-b6c0b18fb1e8_1674414311.8147304.png)\\n\\n##### When `n` is even:\\n![image.png](https://assets.leetcode.com/users/images/3d021e25-740e-4017-aa2e-f262fbe3287a_1674414531.4001348.png)\\n\\n#### Code:\\n\\n``` java []\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ops = 0;\\n        for (int i = 0; i < n / 2; i++) {\\n            int x = 2 * i + 1;  // given in statement\\n            ops += (n - x);\\n        } \\n\\n        return ops;\\n    }\\n}\\n\\n// TC: O(n/2) => O(n), SC: O(1)\\n```\\n---\\n### 2. Optimal solution (No loop):\\n##### When `n` is odd:\\n![image.png](https://assets.leetcode.com/users/images/d13fe28a-c3f3-4d2f-b461-eec7bf86465b_1674415315.432981.png)\\n\\n##### When `n` is even:\\n![image.png](https://assets.leetcode.com/users/images/97972aca-dd14-4638-a4b6-02525a49a4eb_1674415114.2349482.png)\\n\\n#### Code:\\n``` java []\\nclass Solution {\\n    public int minOperations(int n) {\\n        int mid = n / 2;\\n        return mid * ((n % 2 == 0)? mid : (mid + 1));\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```\\n#### OR\\n``` java []\\nclass Solution {\\n    public int minOperations(int n) {\\n        int mid = n / 2;\\n        return mid * (mid + n % 2);\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ops = 0;\\n        for (int i = 0; i < n / 2; i++) {\\n            int x = 2 * i + 1;  // given in statement\\n            ops += (n - x);\\n        } \\n\\n        return ops;\\n    }\\n}\\n\\n// TC: O(n/2) => O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int minOperations(int n) {\\n        int mid = n / 2;\\n        return mid * ((n % 2 == 0)? mid : (mid + 1));\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int minOperations(int n) {\\n        int mid = n / 2;\\n        return mid * (mid + n % 2);\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846613,
                "title": "python-o-1-solution-using-math",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return (n ** 2) // 4\\n```\\n# Approach\\nIf we look attentively, we\\'ll discover that the array arr is a sequence of odd numbers.\\nFirst, I tried to find any rule or regularity in answers, and I nociced that we should do all operations and as a result bring all numbers to a single one (for ex. if n = 3: arr = [1, 3, 5], we make arr = [3, 3, 3], we bring all numbers to 3; if n = 4: arr = [1, 3, 5, 7] and we bring all numbers to 4: arr becomes [4, 4, 4, 4] etc.). And as you can notice if n is odd (in this ex. 3) this resulting number is n itself (3). If n is even (4 in this ex.) the resulting number is also n itself (4). So that means we need to bring all numbers to n by using operations. But how to calculate the minimum number of operations? Let\\'s again look at the previous example. \\nIf n = 4 (n is even): arr = [1, 3, 5, 7]. \\nFirst, we make 3 and 5 become 4 by one opeartion (3 += 1 and 5 -= 1), then 1 and 7 become 4 by three operations (just do 1 += 1 and 7 -= 1 three times). So we have total 1 + 3 (**it\\'s an arithmetic sequence with step 2 starting with 1**) operations.\\nFor ex. if n = 5 (n is odd): arr = [1, 3, 5, 7, 9].\\nSince 5 is already there we move on and make 3 and 7 become 5 by two operations (3 += 1 and 7 -= 1 two times). Then 1 and 9 become 5 by four operations (1 += 1 and 9 -= 1 four times). So we get in total 2 + 4 operations (**also arithmetic sequence with also step 2, but starting with 2**.)\\nWe see the regularity: \\n1) **If n is odd we should calculate the sum of arithmetic sequence with the step 2 and which starts with 2 upto n - 1 (arithmetic sequence = [2, 4, 6, 8, ..., n - 1]).** \\n2) **If n is even we should calculate the sum of arithmetic sequence with the step 2 and which starts with 1 upto n - 1 (arithmetic sequence = [1, 3, 5, 7, ..., n - 1]).**\\n \\nWe can simply calculate those sums by using formula for finding the sum of arithmetic sequence:\\n\\n![image.png](https://assets.leetcode.com/users/images/301fda5c-e285-4094-b7e0-a80d421d0515_1669347506.7557456.png), where a1 - first element, an - last element, n - quantity of elements. \\nSo for the case when n is odd: \\na1 = 2, \\nan = n - 1,\\nn = n // 2 (since the sequence has the step 2)\\n\\nAnd for the case when n is even:\\na1 = 1, \\nan = n - 1, \\nn = n // 2 (since the sequence also has the step 2). \\n\\nTherefore if n is odd: result1 = (2 + (n - 1)) * (n // 2) / 2; \\nand if n is even: result2 = (1 + (n - 1) * (n // 2) / 2. \\nBy simplifying we get: result1 = (n + 1) * (n // 2) / 2, result2 = n * (n // 2) / 2. We could stop here but let\\'s try to think more.\\nWe can notice that if n is odd then n // 2 = (n - 1) / 2 therefore result1 = (n + 1) * (n - 1) / 2 / 2. By simplifying we get result1 = (n ** 2 - 1) / 4. \\nThen we can notice that if n is even then n // 2 = n / 2 therefore also by simplifying result2 we get: result2 = (n ** 2) / 4. We can see that if n is odd then n ** 2 is also odd therefore n ** 2 will not be divided wholly by 4 and that\\'s why we subtract one from it, but since we just need the whole part we can simply get: result1 = (n ** 2) // 4. By the same logic we get result2 = (n ** 2) // 4. So in both cases the answer is the same so we just return  (n ** 2) // 4.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```python []\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return (n ** 2) // 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794229,
                "title": "c-1-liner-o-1-solution-return-n-n-4-beats-100-with-detailed-explanation",
                "content": "teaser:\\nthe result is as follows\\n```\\nint minOperations(int n) \\n{\\n\\treturn n*n/4;\\n}\\n```\\nExplanation (start from an O(n) solution and reduced to an O(1) one):\\ncase 1: 1 (n=average=1)\\ncase 2: 1 3 (n=average=2)\\ncase 3: 1 3 5 (n=average=3)\\ncase 4: 1 3 5 7 (n=average=4)\\ncase 5: 1 3 5 7 9 (n=average=5)\\nwe count only from 0 to n/2 because each operation can be performed symmetrically on 2 numbers\\n```\\nint minOperations(int n) \\n{\\n\\tint result=0;\\n\\tfor(int i=0;i<n/2;i++)\\n\\t\\tresult+=n-2*i-1; //n is the mean (every number should be turned to n)\\n\\n\\treturn result;\\n}\\n```\\n1.We first learn that sum of n from 0~n/2 is n^2/2\\n2.We then calculate the sum for 1,3,......,n-1 (2i+1)\\nwe can use arithmetic progression formula:N(a1+aN)/2, and N=n/2\\n->a1=1,aN=(floor(n/2)-1)x2+1\\nso N(a1+aN)/2\\n=((1+(floor(n/2)-1)x2+1)floor(n/2))/2=floor(n/2)x2xfloor(n/2)/2=floor(n/2)xfloor(n/2)\\nthis can be expressed with nxn/4 in C++\\n\\nthe result is nxn/2-nxn/4=nxn/4\\nhence, result can be reduced to simply {return n * n/4;}",
                "solutionTags": [],
                "code": "```\\nint minOperations(int n) \\n{\\n\\treturn n*n/4;\\n}\\n```\n```\\nint minOperations(int n) \\n{\\n\\tint result=0;\\n\\tfor(int i=0;i<n/2;i++)\\n\\t\\tresult+=n-2*i-1; //n is the mean (every number should be turned to n)\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573849,
                "title": "easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       int i,j,k=0,s=0;\\n       i=n/2;\\n       int max=n;\\n       \\n        for(j=0;j<i;j++){\\n            s+=max-2*j-1;\\n\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n\\n//1 3 5 7\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       int i,j,k=0,s=0;\\n       i=n/2;\\n       int max=n;\\n       \\n        for(j=0;j<i;j++){\\n            s+=max-2*j-1;\\n\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n\\n//1 3 5 7\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794670,
                "title": "simple-solution-by-python-3",
                "content": "Find the pattern.\\n\\nWhen `n = 5`,\\n1 3 5 7 9\\n1 **4** 5 **6** 9\\n1 **5** 5 **5** 9\\n**2** 5 5 5 **8**\\n**3** 5 5 5 **7**\\n**4** 5 5 5 **6**\\n**5** 5 5 5 **5**\\n-> 2 + 4 = 6\\n\\nWhen `n = 6`,\\n1 3 5 7 9 11\\n1 3 **6 6** 9 11\\n1 **4** 6 6 **8** 11\\n1 **5** 6 6 **7** 11\\n1 **6** 6 6 **6** 11\\n**2** 6 6 6 6 **10**\\n**3** 6 6 6 6 **9**\\n**4** 6 6 6 6 **8**\\n**5** 6 6 6 6 **7**\\n**6** 6 6 6 6 **6**\\n-> 1 + 3 + 5 = 9\\n\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return ((n + 1) // 2) * (n // 2)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return ((n + 1) // 2) * (n // 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566840,
                "title": "c-easy-to-understand-4-1-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n         int i = 0, j = n - 1, ans = 0;\\n        while(i < j) {\\n            ans += j-- - i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    \\n    return n * n / 4;\\n    \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n         int i = 0, j = n - 1, ans = 0;\\n        while(i < j) {\\n            ans += j-- - i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    \\n    return n * n / 4;\\n    \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145061,
                "title": "c-super-simple-intuitive-4-line-explained-solution-0-ms-fatser-than-100",
                "content": "We have to sum the difference between the median of the array (which will always be n) and the current number.\\nWhy will the median always be n?\\nLet\\'s see examples:\\n* n = 1: arr = [1], medain = 1\\n* n = 2: arr = [1, 3], median = 2\\n* n = 3: arr = [1, 3, 5], median = 3\\n* n = 4: arr = [1, 3, 5, 7], median = 4\\nAnd so on.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        for (int i = 0; i < n/2; i++) {\\n            res += n - (2 * i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        for (int i = 0; i < n/2; i++) {\\n            res += n - (2 * i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794330,
                "title": "java-solution-using-two-pointer",
                "content": "Straight forward solution Easy to understand\\nMethod 1:\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count =0;\\n        int[] arr = new int[n];\\n        for (int i=0; i < n ; i++){\\n            arr[i] =(2 * i) +1;\\n        }\\n        int left =0; \\n        int right=n-1;\\n        while (left <= right){\\n            while (arr[left] != arr[right]){\\n             arr[left] += 1;\\n             arr[right] -= 1;  \\n                count++;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\\nMethod 2:\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return (n*n)/4;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count =0;\\n        int[] arr = new int[n];\\n        for (int i=0; i < n ; i++){\\n            arr[i] =(2 * i) +1;\\n        }\\n        int left =0; \\n        int right=n-1;\\n        while (left <= right){\\n            while (arr[left] != arr[right]){\\n             arr[left] += 1;\\n             arr[right] -= 1;  \\n                count++;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return (n*n)/4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794113,
                "title": "c-every-element-is-n-time-o-n-space-o-1",
                "content": "\\n\\nA simple O(n) solution is to set every element to n.\\nNow since we can get two elements close to n at the same time ({a[0], a[n-1]}, {a[1], a[n-2]} .. {a[n/2], a[n/2]})\\n\\nWe just need to iterate i from 0 to n/2 and find the distance between n and 2*i + 1\\n\\nTime Complexity : `O(n)`\\nSpace Complexity : `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ops = 0;\\n        for(int i=0; i<n/2; i++) {\\n            int curr = (2*i) + 1;\\n            ops += abs(n-curr);\\n        }\\n        return ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ops = 0;\\n        for(int i=0; i<n/2; i++) {\\n            int curr = (2*i) + 1;\\n            ops += abs(n-curr);\\n        }\\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373089,
                "title": "c-ap-sum-upto-n-numbers-o-1-time-o-1-space-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAP Sum upto N numbers \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$S(N)=N/2*(2*a+(N-1)*d)$$\\n\\nconsider odd n=7 (input)\\n1 3 5 7 9 11 13\\nwe can make all elements equal to 7 in minimum moves \\n1 and 13 in 6 moves \\n3 and 11 in 4 moves \\n5 and 9 in 2 moves \\n\\nthis is an AP upto N numbers. (Here N will be given by n/2) where **a=2**\\n\\nconsider odd n=6 (input)\\n1 3 5 7 9 11 \\nwe can make all elements equal to 6 in minimum moves \\n1 and 11 in 5 moves \\n3 and 9 in 3 moves \\n5 and 7 in 1 move \\n\\nthis is an AP upto N numbers. (Here N will be given by n/2) where **a=1**\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n==1) return 0;\\n        int num=n/2;\\n        int ans=0;\\n        if(n%2==0){\\n            int a=1;\\n            ans=num*(a+(num-1));\\n        }\\n        else{\\n             int a=2;\\n             ans=num*(a+(num-1));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n==1) return 0;\\n        int num=n/2;\\n        int ans=0;\\n        if(n%2==0){\\n            int a=1;\\n            ans=num*(a+(num-1));\\n        }\\n        else{\\n             int a=2;\\n             ans=num*(a+(num-1));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398876,
                "title": "java-two-pointer-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count = 0;\\n        for(int i = 0;i < n / 2;i++){\\n            int start = 2 * i + 1;\\n            int end = 2 * (n - i - 1) + 1;\\n            \\n            count += (end - start) / 2;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count = 0;\\n        for(int i = 0;i < n / 2;i++){\\n            int start = 2 * i + 1;\\n            int end = 2 * (n - i - 1) + 1;\\n            \\n            count += (end - start) / 2;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794244,
                "title": "c-o-1-2-line-solution-explained-in-detail-finding-the-nth-term",
                "content": "Figuring out the general term of the series can be tricky.\\nThe key here is to focus on the number of final operations required.\\n\\nStarting with `n`=1, the first few terms of the series would be:\\n0, 1, 2, 4, 6, 9, 12, 16, 20, 25 and so on... \\n\\nIf you see the difference between 2 consecutive terms, now you begin to see a pattern:\\n1, 1, 2, 2, 3, 3, 4, 4 and so on...  \\n\\nWe separate the odd and even terms and get the 2 new series:\\nFor `n%2==0` we get 1, 4, 9, 16, 25...\\nFor `n%2==1` we get 0, 2, 6, 12, 20...\\n\\nNow, it is clear that for all the even numbers, we have to return the square of `n/2` \\nFor odd, simply return `n/2` multiplied by the next consecutive number `n/2 +1`\\n\\nFeel free to optimize further or mention any different approach of handling this problem :)\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n%2==0) return (n/2)*(n/2);\\n        else return (n/2)*(n/2 +1);\\n    }\\n};\\n```\\nPlease upvote if you liked this approach... Thanks!",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n%2==0) return (n/2)*(n/2);\\n        else return (n/2)*(n/2 +1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794135,
                "title": "c-o-n",
                "content": "**Intuition**\\nAll numbers converge at `n / 2`, and it\\'s true for arrays of even and odd lenghts. Just solve a few examples by hand and it\\'ll become clear how to solve it.\\n\\nNote that we only need to go till `n / 2`, since we increasing/decreasing two \\'oposite\\' numbers at the same time.\\n\\n```cpp\\nint minOperations(int n) {\\n    int res = 0;\\n    for (int i = 0; i < n / 2; ++i)\\n        res += n - i * 2 - 1;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(int n) {\\n    int res = 0;\\n    for (int i = 0; i < n / 2; ++i)\\n        res += n - i * 2 - 1;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084141,
                "title": "simplest-c-solution-with-intuition",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\nsum of all n nums is n^2\\nmake all element equal to n bcos it will be the optimal choice\\ncount the no. of oprns\\n*/\\n    int minOperations(int n) {\\n        int ans=0;\\n\\n        for(int i=0; i<n/2; i++){\\n            ans += (n -(2*i+1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nsum of all n nums is n^2\\nmake all element equal to n bcos it will be the optimal choice\\ncount the no. of oprns\\n*/\\n    int minOperations(int n) {\\n        int ans=0;\\n\\n        for(int i=0; i<n/2; i++){\\n            ans += (n -(2*i+1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223509,
                "title": "java-o-1-tc-sc-simplest-easy-maths",
                "content": "We have to only get a Sharp observation in this question to get the solution in O(1) Time complexity, So, \\nValues of n      =  1, 2, 3, 4, 5, 6,  7,  8,   9,   10,  11, 12, 13, 14, 15...\\nExpected ans =  0, 1, 2, 4, 6,  9, 12, 16, 20, 25, 30,  36, 42, 49, 56...\\nWe can observe that , when n is even it is simply the Square of (n/2),\\nwhen it is odd it is Square of (n/2) + (n/2) \\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        if(n%2==0){\\n            return (int)Math.pow(n/2,2);\\n        }\\n        else{\\n            return ((int)Math.pow(n/2,2))+n/2;\\n        }\\n    }\\n}\\n```\\nKindly upvote If you liked the explanation!!!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        if(n%2==0){\\n            return (int)Math.pow(n/2,2);\\n        }\\n        else{\\n            return ((int)Math.pow(n/2,2))+n/2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187715,
                "title": "3-approaches-one-line-solution-100-fast-o-1",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    vector<int>nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = (2 * i) + 1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            int diff=nums[n-i-1]-nums[i];\\n            ans+=diff/2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    return(n*n)/4 ;\\n    }\\n};\\n```\\n\\n\\n```\\n\\n\\nHere is my cpp one liner with explanation\\n\\nThere are two possible cases\\nn is odd\\nlet\\'s consider n=5.\\narray contains\\n1 3 5 7 9\\nHere, middle element of array is -> 5.\\nNow, we need to choose elements in a pair (which are not equal to the mid element), perform some operation on a pair to make them equal to middle element.\\nLet\\'s take pair (3,7) ,We will decrement 7 and incement 3, two times to make them equal to 5(middle element).\\nSo it takes 2 steps.\\nLet\\'s take another pair (1,9) We will decrement 9 and incement 1, four times to make them equal to 5.\\nSo it takes 4 steps.\\nAfter performing these steps, all elements will become 5.\\nSo, Total steps: 2+4=6. (sum of first n/2 even numbers)\\nSum of first k EVEN numbers = k(k+1)\\nans would be n/2(n/2+1)\\nn is even\\nlet\\'s consider n=6.\\narray contains\\n1 3 5 7 9 11\\nHere, middle element of array is -> (5+7)/2=6.\\nLet\\'s take pair (5,7), We will decrement 7 and incement 5, one time to make them equal to 6.\\nSo it takes 1 step.\\nLet\\'s take 2nd pair (3,9), We will decrement 9 and incement 3, three times to make them equal to 6.\\nSo it takes 3 steps.\\nLet\\'s take last pair (1,11), We will decrement 11 and incement 1, five times to them equal to 6.\\nSo it takes 5 steps.\\nAfter performing these steps, all elements will become 6.\\nTotal steps: 1+3+5=9. (sum of first n/2 odd numbers)\\nSum of first k ODD numbers = k*k.\\nans would be n/2*n/2\\n\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       return n&1 ? n/2*(n/2+1) : n/2*n/2 ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    vector<int>nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = (2 * i) + 1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            int diff=nums[n-i-1]-nums[i];\\n            ans+=diff/2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    return(n*n)/4 ;\\n    }\\n};\\n```\n```\\n\\n\\nHere is my cpp one liner with explanation\\n\\nThere are two possible cases\\nn is odd\\nlet\\'s consider n=5.\\narray contains\\n1 3 5 7 9\\nHere, middle element of array is -> 5.\\nNow, we need to choose elements in a pair (which are not equal to the mid element), perform some operation on a pair to make them equal to middle element.\\nLet\\'s take pair (3,7) ,We will decrement 7 and incement 3, two times to make them equal to 5(middle element).\\nSo it takes 2 steps.\\nLet\\'s take another pair (1,9) We will decrement 9 and incement 1, four times to make them equal to 5.\\nSo it takes 4 steps.\\nAfter performing these steps, all elements will become 5.\\nSo, Total steps: 2+4=6. (sum of first n/2 even numbers)\\nSum of first k EVEN numbers = k(k+1)\\nans would be n/2(n/2+1)\\nn is even\\nlet\\'s consider n=6.\\narray contains\\n1 3 5 7 9 11\\nHere, middle element of array is -> (5+7)/2=6.\\nLet\\'s take pair (5,7), We will decrement 7 and incement 5, one time to make them equal to 6.\\nSo it takes 1 step.\\nLet\\'s take 2nd pair (3,9), We will decrement 9 and incement 3, three times to make them equal to 6.\\nSo it takes 3 steps.\\nLet\\'s take last pair (1,11), We will decrement 11 and incement 1, five times to them equal to 6.\\nSo it takes 5 steps.\\nAfter performing these steps, all elements will become 6.\\nTotal steps: 1+3+5=9. (sum of first n/2 odd numbers)\\nSum of first k ODD numbers = k*k.\\nans would be n/2*n/2\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       return n&1 ? n/2*(n/2+1) : n/2*n/2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495958,
                "title": "java-1-liner-solution-with-detailed-explanation-beats-100",
                "content": "The solution is based on the insight that the sum of all elements in the array is not changed based on operations becase we are subtracting 1 and adding 1 in every operaiton. Based on that fact and the requirement that all elements in the array are equal we can learn more about what should be the end goal.\\n\\nIf we look at the sum for every n:\\n\\n```\\nn=1 => 1\\nn=2 => 1+3=4\\nn=3 => 1+3+5=9\\nn=4 => 1+3+5+7=16\\n```\\n\\nWe can see that` sum(n) = n^2`. If all elements are equal, then every element has to be: `sum(n) / n` which solves to `(n^2)/n = n`.\\n\\nEvery operation will increase the leftmost value and decrease the rightmost value until they are both equal to `n`. That means we have in total `n/2` operations (rounded down) where the amount of operations for every `i` until `n/2` is `n-arr[i]`.\\nWe are getting the arithmetic sequence of the amount of operations:\\n```\\na1 = n-1\\nd = 2\\n```\\nThe element at `n/2` will be `1` when `n` is even and `2` when `n` is odd. The sum of the series is `(n/2) * (a1 + an/2)/2` as the sum of the progression.\\nThis translates to:\\n`(n/2)*(n-1 + 1)/2 => (n/2)*(n)/2` when even.\\n`(n/2)*(n-1 + 2)/2 => (n/2)*(n+1)/2` when odd.\\n\\nWe can quickly check whether an integer is odd by a simple bit operation: `n & 1`. If `n` is even then the result is `0`, otherwise it\\'s `1` because the LSB is `1` for odd numbers.\\n\\nThe solution is the following:\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return (n/2)*(n + (n & 1))/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nn=1 => 1\\nn=2 => 1+3=4\\nn=3 => 1+3+5=9\\nn=4 => 1+3+5+7=16\\n```\n```\\na1 = n-1\\nd = 2\\n```\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return (n/2)*(n + (n & 1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148440,
                "title": "c-math-solution-explained-step-by-step-100-time-70-space",
                "content": "Nice math challenge we have here :)\\n\\nOkay, let\\'s proceed step by step and see if we can spot on how we can figure out the amount of needed operations.\\n\\nFor example, let\\'s assume we start with `n == 6` and let\\'s do some grouping on the series with the first `6` odd numbers, like this:\\n\\n```cpp\\n//    1,     3,     5,     7,     9,    11 == \\n//    1,     3,     5, 6 + 1, 6 + 3, 6 + 5 ==\\n// 1+ 5, 3 + 3, 5 + 1,     6,     6,     6 ==\\n//    6,     6,     6,     6,     6,     6\\n```\\n\\nBasically we can proceed removing values from the second half so that they mirror what is in the first half in order to balance every series we need to balance.\\n\\nOr, more simply, the number of operations needed is going to be equal to the sum of all the elements in the first half.\\n\\nLet\\'s move on from there and try to figure out how to proceed, still continuing on our example:\\n\\n```cpp\\n//       1 +       3 +       5 ==\\n// (0 + 1) + (2 + 1) + (4 + 1) ==\\n// (1 + 1 + 1) + (0 + 2 + 4) ==\\n// 3 + 2 * (0 + 1 + 2)\\n```\\n\\nAnd from here we can finally derive some more general formula, calling `h` half the value of `n` and having found that our result equates to `h` plus twice the sum of all the first `h - 1` numbers; with a bit more grouping we can have:\\n\\n```cpp\\n// h + 2 * h * (h - 1) / 2 ==\\n// h + h * (h - 1) ==\\n// h * h ==\\n// (n / 2) * (n / 2)\\n```\\n\\nHence our own solution is just `n * n / 4`; you might have noticed that things might change with odd numbers, but they actually do not: if we had to rebalance for, say, `n == 7`, then we would have `1, 3, 5, 7, 9, 11, 13` and we can ignore the cental element (`7`) and just rebalance the left side taking from the right exactly as we did before.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\n//    1,     3,     5,     7,     9,    11 == \\n//    1,     3,     5, 6 + 1, 6 + 3, 6 + 5 ==\\n// 1+ 5, 3 + 3, 5 + 1,     6,     6,     6 ==\\n//    6,     6,     6,     6,     6,     6\\n```\n```cpp\\n//       1 +       3 +       5 ==\\n// (0 + 1) + (2 + 1) + (4 + 1) ==\\n// (1 + 1 + 1) + (0 + 2 + 4) ==\\n// 3 + 2 * (0 + 1 + 2)\\n```\n```cpp\\n// h + 2 * h * (h - 1) / 2 ==\\n// h + h * (h - 1) ==\\n// h * h ==\\n// (n / 2) * (n / 2)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146241,
                "title": "java-simple-and-easy-to-understand-solution-t-o-n-2-s-o-1-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int operations = 0;\\n        \\n        /* sum of difference between, n - arr[i], i => [0, n /2)\\n        */\\n        \\n        for(int i = 0; i < n / 2; i++){\\n            //append the difference\\n            operations += (n - (2  * i + 1));\\n        }\\n        \\n        return operations;\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int operations = 0;\\n        \\n        /* sum of difference between, n - arr[i], i => [0, n /2)\\n        */\\n        \\n        for(int i = 0; i < n / 2; i++){\\n            //append the difference\\n            operations += (n - (2  * i + 1));\\n        }\\n        \\n        return operations;\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794295,
                "title": "math-problem-arithmetic-sequence-o-1",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int n) {\\n        int len = n / 2;\\n        int min = n % 2 == 0 ? 1 : 2;\\n\\t\\tint max = min + (len - 1) * 2;\\n        return (min + max) * len / 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int n) {\\n        int len = n / 2;\\n        int min = n % 2 == 0 ? 1 : 2;\\n\\t\\tint max = min + (len - 1) * 2;\\n        return (min + max) * len / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794152,
                "title": "java-o-n-and-o-1",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int start = 1, end = (n-1) * 2 + 1;\\n        int ans = 0;\\n        while(start < end)\\n        {\\n            ans += (end - start) / 2;\\n            start += 2;\\n            end -= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int start = 1, end = (n-1) * 2 + 1;\\n        int ans = 0;\\n        while(start < end)\\n        {\\n            ans += (end - start) / 2;\\n            start += 2;\\n            end -= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095714,
                "title": "one-line-code-100-beat-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n/2)*(n/2)+(n%2)*(n/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n/2)*(n/2)+(n%2)*(n/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937875,
                "title": "java-1-line-code-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO ( 1 )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO ( 1 )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return n*n/4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return n*n/4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670935,
                "title": "java-easy-100-0ms",
                "content": "# Please Upvote\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Minimum Operations to Make Array Equal.\\nMemory Usage: 39.3 MB, less than 94.03% of Java online submissions for Minimum Operations to Make Array Equal.\\n```\\n\\n```\\n    public int minOperations(int n) {\\n        int count = 0;\\n        if(n <= 3)\\n            return n - 1;\\n        int diff = n - 1;\\n        if((diff & 1) == 1){\\n            count = (n / 2) * (n / 2);\\n        }else\\n            count = (n / 2) * ((n / 2) + 1);\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Minimum Operations to Make Array Equal.\\nMemory Usage: 39.3 MB, less than 94.03% of Java online submissions for Minimum Operations to Make Array Equal.\\n```\n```\\n    public int minOperations(int n) {\\n        int count = 0;\\n        if(n <= 3)\\n            return n - 1;\\n        int diff = n - 1;\\n        if((diff & 1) == 1){\\n            count = (n / 2) * (n / 2);\\n        }else\\n            count = (n / 2) * ((n / 2) + 1);\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646050,
                "title": "c-maths-1-liner-w-explanation",
                "content": "We have an array of `n` sequential odd numbers starting from 1. It is fairly simple to prove (induction) that the sum of the first `n` odd numbers is just `n*n`. So the value that is closest to each term is the average, i.e. `sum([1, 3, 5, ... ]) / n = n*n / n = n`.\\nNow we need to apply the operations. As the first and last terms are an equal distance from the average we can pair up terms and only consider the distance of each from the average. Note that if there is an odd number of terms, the middle term must be the average, and hence has 0 operations applied to it. Now if we apply the operations we see that we have `n - (2*i + 1)` (number of ops to make `ith` term equal to `n`) operations applied to the `ith` term, as there are `n/2` terms we can separate the sum into `n*(n/2) - (1 + 3 + 5 + ... ) = n*n/2 - (sum of n/2 sequential odd numbers) = n*n/2 - n*n/4 = n*n/4`.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n      return n*n / 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n      return n*n / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440555,
                "title": "simple-java-sol-easy-to-understand-2-approaches-with-and-without-space",
                "content": "```\\nclass Solution {\\n// With Space ================\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        int sum = 0;\\n        for(int i = 0; i < n; i++){\\n            arr[i] = (2 * i) + 1;\\n            sum += arr[i];\\n        }\\n        sum = sum / n;\\n        int ans = 0;\\n        for(int i = 0; i < n/2; i++){\\n            ans += (sum - arr[i]);\\n        }\\n        return ans;\\n    }\\n\\t// Without Space =============\\n\\t//here with just simple observation in above approach, u can eleminate the space\\n\\tpublic int minOperations(int n) {\\n        int ans = 0;\\n        for(int i = 0; i < n/2; i++){\\n            ans += (n - ((2*i)+1));\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n// With Space ================\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        int sum = 0;\\n        for(int i = 0; i < n; i++){\\n            arr[i] = (2 * i) + 1;\\n            sum += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2314349,
                "title": "easy-understanding-easy-approch-even-odd",
                "content": "class Solution {\\npublic:\\n    int minOperations(int n) \\n    {\\n       if(n%2==0){\\n           n=n/2;\\n           return n*n; }\\n        else{\\n            n=n/2;\\n            return n*(n+1);}\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) \\n    {\\n       if(n%2==0){\\n           n=n/2;\\n           return n*n; }",
                "codeTag": "Java"
            },
            {
                "id": 2284340,
                "title": "handle-odd-and-even-index-elements-separetely",
                "content": "```\\nclass Solution {\\n\\tpublic int minOperations(int n) {\\n\\t\\tint sum = 0;\\n\\t\\tif (n % 2 == 0) {\\n\\t\\t\\tfor (int i = 1; i < n; i = i + 2) {\\n\\t\\t\\t\\tsum += i;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = 0; i < n; i = i + 2) {\\n\\t\\t\\t\\tsum += i;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minOperations(int n) {\\n\\t\\tint sum = 0;\\n\\t\\tif (n % 2 == 0) {\\n\\t\\t\\tfor (int i = 1; i < n; i = i + 2) {\\n\\t\\t\\t\\tsum += i;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = 0; i < n; i = i + 2) {\\n\\t\\t\\t\\tsum += i;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136025,
                "title": "simple-and-helpful-o-1-easy",
                "content": "**<++++++++ Press upvote Button !!!!!!!!!**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        \\n        if(n==1)\\n            return 0;\\n        \\n        bool parity= n%2 == 0 ? true : false;\\n        \\n        int a = parity== true? 1 : 0,  // This will look similar Like\\n        d= 2,                          // An = a +  (n-1)d\\n        N= ceil(n*1.0/2),              // Sn = n/2( a + An )       \\n        An= a + (N-1)*d,               // exactly like arthematic operation\\n        \\n        Sn= (( N)*( a + An ))/2;\\n        \\n        return Sn;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/77767fb7-0c55-4695-a6ee-af693e2a67f2_1654887231.2400758.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        \\n        if(n==1)\\n            return 0;\\n        \\n        bool parity= n%2 == 0 ? true : false;\\n        \\n        int a = parity== true? 1 : 0,  // This will look similar Like\\n        d= 2,                          // An = a +  (n-1)d\\n        N= ceil(n*1.0/2),              // Sn = n/2( a + An )       \\n        An= a + (N-1)*d,               // exactly like arthematic operation\\n        \\n        Sn= (( N)*( a + An ))/2;\\n        \\n        return Sn;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972200,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int c=0;\\n            for(int i=0;i<n/2;i++)\\n            {\\n                c+=abs(2*i+1-n);\\n            }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int c=0;\\n            for(int i=0;i<n/2;i++)\\n            {\\n                c+=abs(2*i+1-n);\\n            }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449795,
                "title": "c-solution-with-explanation",
                "content": "Explanation :\\n1) Given array is of odd consecutive numbers and sum of odd consecutive numbers is always equal to square of there count,\\nExample --> 1 + 3 + 5 is 9 && 1 + 3 + 5 + 7 is 16.\\n2) In one operation we can decrease one number and increase other number.\\n3) We have to make array equal and there can be only one number to which we can convert all elements of our array, that would be the (n), because total sum is (n * n) and we have to make all values or numbers equal.\\n4) If we count number of operations on each number we have to perform to make our number equal to n, we found out, we will find our ans.\\n5) one operation is decreasing a number and increasing other number, so we can take sum of operations that requires numbers to be added into them or sum of operations that requires to be subtrated fromt hem.\\nExample --> 1, 3, 5, 7. Here for 1 => 3 operations of add , for 3 => 1 operation of add , for 5 => 1 operation of subtract and for 7 => 3 operations of subtract.\\nWe can observe count of add operations is equal to subtract operations and we have our given operation in which we can add to one and subtract to other, so ther answer is self explained here.\\n\\nI hope this will help you in solving this problem.\\n\\nPLEASE UPVOTE IF YOU LIKE MY ANSWER.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n * n) / 4;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n * n) / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435654,
                "title": "c-easy-o-1-mathematical-solution-with-intuition-1-line-code",
                "content": "The Array is [ 1 3 5 7 9 11 13 15....... (2n-1) ]\\nNow,\\n\\tLets take n=7 (odd)\\n\\tArray= [ 1 3 5 7 9 11 13 ]\\nNow we will **equalise** the values in such a way that the larger numbers and smaller numbers converge to a common number. So we start with the extremes and left extreme is increased by 1 and right extreme is decreased by 1. the **converging numbers is median of the array** (here 7 which is equal to n) by observation and some examples.\\n\\t[ 2 3 5 7 9 11 12 ] - 1\\n\\t[ 3 3 5 7 9 11 11 ] - 2\\n\\t[ 4 3 5 7 9 11 10 ] - 3\\n\\t[ 5 3 5 7 9 11 9 ] - 4\\n\\t[ 6 3 5 7 9 11 8 ] - 5\\n\\t[ 7 3 5 7 9 11 7 ] - 6\\n\\tnow we shift to next extremes and repeat the steps\\n\\t[ 7 4 5 7 9 10 7 ] - 7\\n\\t[ 7 5 5 7 9 9 7 ] - 8\\n\\t[ 7 6 5 7 9 8 7 ] - 9\\n\\t[ 7 7 5 7 9 7 7 ] - 10\\n\\t[ 7 7 6 7 8 7 7 ] - 11\\n\\t[ 7 7 7 7 7 7 7 ] - 12\\n\\t\\nTotal 12 operations\\n\\t\\nSimilarly we can do for the even n.\\nWe observe that we increased/decreased the repective extremes one by one by **(n - their value)** times. So **total number of operations** will be will be **(n - their value) times for n/2 numbers exactly** as we increase and decrease in same operation.\\n\\nSo here n=7=median(common)\\nans=(n-1)+(n-3)+(n-5)=6+4+2=12   { n+n+n - (1+3+5)}\\nNow calculation can be generalised as sum of **Arithmetic progression**\\nsum=n/2[2a+(n-1)d] {where d=2,a=1,n=n/2}\\nThis sum needs to be subtracted from n+n+n.....n/2 times=n * n / 2\\nFinal ans=n * n/2 - sum which simplifies as (n * n)/4.\\n\\n```\\nint minOperations(int n) {\\n         return (n*n)/4;   \\n    }\\n```\\nPlease Upvote if you find it helpful. \\n\\t",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nint minOperations(int n) {\\n         return (n*n)/4;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383686,
                "title": "c-0ms-1-line-solution-o-1-solution",
                "content": "It is a well known fact that the minimum absolute dist of the numbers in the array is from their median.\\n\\nWe can observe the fact of the median will be equal to it\\'s size i.e median==n/2.\\n\\nNow we can also observe the array is cyclic about the median meaning that for every indices , there exist another indice in the array having the same absolute difference with respect to the median , so if we calculate for the first n/2 terms we can get the answer.\\n\\nWe will now having a simple ap where the ans is the sum of the ap .\\nThe ans == sum of(n-1 , n-3,n-5,n-7)\\n\\nIt is a well known fact that the sum of first k (here n/2 )odd numbers is k^2(Proof is left to the reader to prove). This means that our answer is k*(n-k) , where k is the number of terms before the median , =n/2;\\n\\nhence the answer is simply (n/2)*(n-n/2)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n/2*(n-n/2);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n/2*(n-n/2);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225240,
                "title": "python-brute-force-with-optimized-code-fastest-simple-explained",
                "content": "Maths formula used? \\n1) Sum of first n even numbers = n(n+1)\\n2) Sum of first n odd numbers = n * n\\n\\nLet\\'s consider 2 scenarios:\\n1) n is odd:\\nExample : n=6\\nArray: 1, 3, 5, 7, 9, 11, 13\\nIn order to make all the values same, it\\'s easiest to pick the middle element and make all the elements same as that.\\nSo, in one operation, let\\'s pick one element from left side of middle and one element from right side of middle.\\nFor our example: middle element = 7\\n1st operation: Let\\'s pick 5 on left and 9 on right. Operations: 5+1 and 9-1 (as only we can add/subtract by 1 for 2 elements at once)\\nArray: 1, 3, 6, 7, 8, 11, 13\\n2nd operation: 6+1 and 8-1\\nArray: 1, 3, 7, 7, 7, 11, 13\\nLike you can see, we had to use 2 operations to make 5 and 9 on either side of 7 to make it equal to 7. No. of operations = middle - current element\\nSo for next steps, we need 4 operations to make 3 same as 7 and another 6 operations for 1 to be 7.\\n\\nIf we see the pattern: If we select middle element as 7. \\nThese are the number of operations: 6 operations for 1, 4 operations for 3, 2 operations for 5 \\nThe pattern is as follows (reverse): 2, 4, 6 \\nIf n is odd, the pattern is of even numbers. As we already know formula for sum of even numbers = n(n+1)\\nNumber of elements in above pattern = n/2 \\nSo *sum = n/2(n/2 + 1)*\\n\\n2) n is even:\\n\\nSimilarly, let\\'s take an example with even number of elements:\\nArray: 1, 3, 5, 7, 9, 11\\nMiddle element =? not there, 5, 7 are in middle, so it is wise to change all elements to 6\\nIf we check patterns for operations it will be: 1, 3, 5     (6-5, 6-3, 6-1)\\nIt is a pattern of odd numbers.\\nSum formula is nxn\\nIn pattern we see half the elements i.e. n/2\\n*Ans: n/2 x n/2*\\n\\nSo algo for code:\\n1) Find the number of elements in pattern ? mid = n/2\\n2) For even n, pattern is of odd numbers. Ans: n/2 x n/2\\n3) For odd n, patterm is of even numbers. Ans: n/2 x (n/2 + 1)\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # first_val = 1\\n        # end_val = 2*(n-1)+1\\n        # target_val = (first_val+end_val)//2\\n        # diff1 = (target_val - first_val)//2\\n        # steps = diff1*(diff1+1)\\n        # while first_val < target_val:\\n        #     steps = steps + (target_val - first_val)\\n        #     first_val = first_val + 2\\n        mid = n//2\\n        if n%2 != 0:\\n            return mid*(mid+1)\\n        else:\\n            return mid*mid\\n            \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # first_val = 1\\n        # end_val = 2*(n-1)+1\\n        # target_val = (first_val+end_val)//2\\n        # diff1 = (target_val - first_val)//2\\n        # steps = diff1*(diff1+1)\\n        # while first_val < target_val:\\n        #     steps = steps + (target_val - first_val)\\n        #     first_val = first_val + 2\\n        mid = n//2\\n        if n%2 != 0:\\n            return mid*(mid+1)\\n        else:\\n            return mid*mid\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149664,
                "title": "python-o-1",
                "content": "\\nIt a simple math problem.\\n\\nConsider an example and understand the hidden logic.\\n\\nlet n is odd and n = 5\\nArray -      [1,3,5,7,9]\\nAddOns - [4,2,0,-2,-4]\\nSo we require 2+4 operations.\\nAs n is 5 we require 2(Arithemtic progression sum of 5//2 numbers) = 2(1+2)\\nif n is 10 we require 2(Arithemtic progression sum of 10//2 numbers) = 2(1+2+3+4+5)\\n\\nLet\\'s assume mid = n//2\\nReduce above into a formula:\\n2((mid*(mid+1))//2) = mid*(mid+1)\\n\\nIf n is even:\\nFor example n is 6.\\n\\tArray = [1,3,5,7,9,11]\\nAddons = [5,3,1,-1,-3,-5]\\nNumber of operations = (1+3+5)\\nIt is equal to AP sum of n//2 (Assume it as mid) odd numbers.\\nApply summation for 2*mid + 1, it will result as mid**2\\n\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        mid = n//2\\n        return mid * (mid + n%2)\\n```\\n\\nTime ans space complexity - O(1)\\n\\nIf it is helpful, please upvote.",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        mid = n//2\\n        return mid * (mid + n%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146162,
                "title": "one-line-solution-beats-100-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n*n/4;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n*n/4;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1145359,
                "title": "one-line-js-super-simple",
                "content": "1. create a array and than store each value according to the 2*i + 1\\n2. now each element of the array should be brought to \"n\" in order to achieve equality (study the pattern)\\n3. after that we know in each operation there is both decrement and increment. \\nTherefore we only consider either of the cases required and return the sum.\\n\\n```\\nconst minOperations = n => Array(n).fill(0).map((e,i)=> 2*i + 1).reduce((a,e)=> e<n ? a+=(n-e):a, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nconst minOperations = n => Array(n).fill(0).map((e,i)=> 2*i + 1).reduce((a,e)=> e<n ? a+=(n-e):a, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145248,
                "title": "o-1-solution-cpp-explain",
                "content": "if n==6\\n[1,3,5,7,9,11]\\nsum => 5(6-1) + 3(6-3) + 1(6-5)\\n1+3+5 = > 2+4+6 - 1+1+1 => 2*(1+2+3) -3 => k=n/2 => 2*(k*(k+1))/2 - k=> k*(k+1) -k=> k^2+k-k=>k^2\\nn%2==0 sum of first n/2 odd number\\n\\nn%2==1 sum of first n/2 even number\\nn==7\\nsum => 2+4+6 => 2*(1+2+3) => k=n/2 => 2*(k*(k+1))/2=> k*(k+1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n%2==1){\\n            return (n/2)*(n/2 +1);\\n        }\\n        else\\n        {\\n            return (n/2)*(n/2);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n%2==1){\\n            return (n/2)*(n/2 +1);\\n        }\\n        else\\n        {\\n            return (n/2)*(n/2);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839017,
                "title": "javascript-easy-to-understand",
                "content": "Noted that this array is an arithmetic sequence. To make the elements equal to the same number, it has to be the one in the \"middle\". And other values on each side just increment and decrement accordingly. This will result into minimum number of operations.\\n\\nAlso remember the formula for sum of arithmetic sequences: `sum = N * (A1 + An) / 2`, with `n` being the number of the elements in the sequence, `A1` the first element, `An` the last element.\\n\\n```js\\nvar minOperations = function(n) {\\n    // For example when n = 4\\n    // 1 3 5 7    -> (4 is the middle element)\\n    // 3 1 ..     -> (steps to increment to become the middle element\\n    if (n % 2 === 0) {\\n        // return (n / 2) * (1 + n - 1) / 2; (N = n/2 , A1 = 1 and An = n - 1)\\n        return n * n / 4; // simplified above\\n    }\\n    // For example when n = 5\\n    // 1 3 5 7 9  -> (5 is the middle element)\\n    // 4 2        -> (steps to increment to become the middle element)\\n    // return (n - 1) / 2 * (2 + n - 1) / 2; (N = (n-1)/2 , A1 = 2 and An = n - 1)\\n    return (n * n - 1) / 4;\\n\\t\\n\\t// Also you can combine above two cases.\\n\\t// return (n * n - n % 2) / 4;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar minOperations = function(n) {\\n    // For example when n = 4\\n    // 1 3 5 7    -> (4 is the middle element)\\n    // 3 1 ..     -> (steps to increment to become the middle element\\n    if (n % 2 === 0) {\\n        // return (n / 2) * (1 + n - 1) / 2; (N = n/2 , A1 = 1 and An = n - 1)\\n        return n * n / 4; // simplified above\\n    }\\n    // For example when n = 5\\n    // 1 3 5 7 9  -> (5 is the middle element)\\n    // 4 2        -> (steps to increment to become the middle element)\\n    // return (n - 1) / 2 * (2 + n - 1) / 2; (N = (n-1)/2 , A1 = 2 and An = n - 1)\\n    return (n * n - 1) / 4;\\n\\t\\n\\t// Also you can combine above two cases.\\n\\t// return (n * n - n % 2) / 4;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 803585,
                "title": "c-simple-solution-with-math-technique-time-and-space-o-1",
                "content": "I solved this problem by Mathematics technique.\\nFirst, list the conditions at different n and we can observe that all the number converge to n :\\nwhen n is odd : \\nn = 3: 1 3 5 \\n-> 1 and 5 converge to 3 -> takes 2 operations\\n\\nn = 5: 1 3 5 7 9 \\n-> 3 and 7 converge to 5 (2 op.), 1 and 9 converge to 5 as well (4 op.) -> take `2 + 4` operations\\n\\nn = 7: 1 3 5 7 9 11 13 \\n-> take `2 + 4 + 6` operations\\nBy formula of arithmetic series, we get that the result is `(n - 1) * (n + 1) / 4`\\n\\nLikewise, the case of \"n is even\" are as follows:\\nn = 4 : 1 3 5 7 \\n-> all the numbers converge to 4, 3 and 5 take 1 op. , 1 and 7 take 3 op. -> take `1 + 3` operation\\n\\nn = 6 : 1 3 5 7 9 11 \\n-> take `1 + 3 + 5` operation\\n\\nBy formula of arithmetic series, we get that the result is `n * n / 4`\\n```\\nint minOperations(int n) {\\n        if(n % 2)\\n            return (n-1)*(n+1)/4;\\n        else\\n            return n * n / 4;\\n    }\\n```\\n\\nActually, we can further simplify it : \\n```\\n int minOperations(int n) {\\n            return n * n / 4;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(int n) {\\n        if(n % 2)\\n            return (n-1)*(n+1)/4;\\n        else\\n            return n * n / 4;\\n    }\\n```\n```\\n int minOperations(int n) {\\n            return n * n / 4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796948,
                "title": "python-sol-by-balance-w-explanation",
                "content": "**Explanation** & **Abstract model**:\\n\\nThink of **balance**.\\n\\nInput array is in the form\\n\\n1, 3, 5, ..., **n**, ..., 2n-5, 2n -3, 2n-1\\n\\nWe can view this problem by balance procedure\\n\\n![image](https://assets.leetcode.com/users/images/14f4c594-2ec6-4845-9786-99ad80840331_1597672703.3123982.png)\\n\\n\\n1 gram, 3 gram, 5 gram, ...,**n** gram, ..., 2n-5 gram, 2n -3 gram, 2n-1 gram\\n\\nBy description, with one operation, we can **+1 gram** on one position on the **left-hand side**, and **-1 gram** on another position on the **right-hand side**.\\n\\nAfter k times of operation( a pair of +1 and -1 on balance), final state would be\\n\\nn gram, n gram, n gram, ..., **n** gram, ..., n gram, n gram, n gram\\n\\nTherefore, combined the property of symmetirc, we can derive **k** from the weight **difference accumulation to balance point n**\\n\\nk \\n= weight **difference accumulation** of **left hand-side** to balance point n\\n= weight **difference accumulation** of **right hand-side** to balance point n\\n= ( n - 1 ) + ( n - 3 ) + ( n - 5 ) + ...\\n\\n--- \\n\\nFor example with **n** = **5**\\n\\narr = [1, 3, **5**, 7, 9]\\n\\n**balance point** = **n** = **5**\\n\\nweight difference accumulation on left hand side\\n= ( 5 - 1 ) + ( 5 - 3 )\\n= 4 + 2\\n= 6\\n\\nTherefore, we need 6 times operation to make array equal\\n\\n---\\n\\n**Implementation** by balance procedure:\\n\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        \\n        # balance point is n\\n        # left hand side is lighter\\n        # right hand side is heavier\\n        balance_point = n\\n        \\n        \\n        diff_accumulation = 0\\n        \\n        odd = 1\\n        \\n        # accumulate all the differnce between small odds to balance point\\n        while odd < n:\\n            \\n            diff_accumulation += (balance_point - odd)\\n            \\n            # move to next odd number\\n            odd += 2\\n        \\n        # each operation contribute one pair of +1 on left hand side / -1 on right hand side\\n        # so the accumulation of difference is the answer\\n        return diff_accumulation\\n```\\n\\n---\\n\\n**Implementation** by math formula derived from balance procedure:\\n\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n\\n        # only cosinder left-hand side is enough, due to symmetric property of balance procedure\\n        first_odd = 1\\n        last_odd = n-2 if (n % 2 == 1) else n-1\\n        \\n        first_diff = n - first_odd\\n        last_diff = n - last_odd\\n        terms = 1 + (first_diff - last_diff) // 2\\n        \\n        diff_accumulation = (first_diff + last_diff) * terms // 2\\n        return diff_accumulation\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        \\n        # balance point is n\\n        # left hand side is lighter\\n        # right hand side is heavier\\n        balance_point = n\\n        \\n        \\n        diff_accumulation = 0\\n        \\n        odd = 1\\n        \\n        # accumulate all the differnce between small odds to balance point\\n        while odd < n:\\n            \\n            diff_accumulation += (balance_point - odd)\\n            \\n            # move to next odd number\\n            odd += 2\\n        \\n        # each operation contribute one pair of +1 on left hand side / -1 on right hand side\\n        # so the accumulation of difference is the answer\\n        return diff_accumulation\\n```\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n\\n        # only cosinder left-hand side is enough, due to symmetric property of balance procedure\\n        first_odd = 1\\n        last_odd = n-2 if (n % 2 == 1) else n-1\\n        \\n        first_diff = n - first_odd\\n        last_diff = n - last_odd\\n        terms = 1 + (first_diff - last_diff) // 2\\n        \\n        diff_accumulation = (first_diff + last_diff) * terms // 2\\n        return diff_accumulation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794226,
                "title": "java-easiest-solution-only-3-lines-o-n-2",
                "content": "public static int minOperations(int n) {\\n\\tint res = 0;\\n\\tfor (int i = 1; i < n; i += 2)\\n\\t\\tres += n - i;\\n\\n\\treturn res;\\n}",
                "solutionTags": [],
                "code": "public static int minOperations(int n) {\\n\\tint res = 0;\\n\\tfor (int i = 1; i < n; i += 2)\\n\\t\\tres += n - i;\\n\\n\\treturn res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 794169,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int m=(n%2)? n+1: n;\\n        int res=0;\\n        for(int i=0; i<n/2; ++i){\\n            res+=(m-2*i-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int m=(n%2)? n+1: n;\\n        int res=0;\\n        for(int i=0; i<n/2; ++i){\\n            res+=(m-2*i-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970964,
                "title": "easy-c-basic-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       int ans=0;\\n       for(int i=0;i<n/2;i++)\\n       {\\n           ans+=n-((2*i) + 1);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       int ans=0;\\n       for(int i=0;i<n/2;i++)\\n       {\\n           ans+=n-((2*i) + 1);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784575,
                "title": "most-easiest-python-code",
                "content": "\\n\\n# Approach\\nIF LENGTH OF str = even \\nwe need to sum first n//2 odd numbers\\nwhich n//2 square\\nand vice versa\\n\\n# Complexity\\n- Time complexity:\\nI think it will be o(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        if n%2==1:\\n            return (n//2)*(n//2+1)\\n        else:\\n            return (n//2)**2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        if n%2==1:\\n            return (n//2)*(n//2+1)\\n        else:\\n            return (n//2)**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664468,
                "title": "beats-100-constant-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is given that the $i^{th}$ element is the $i+1^{th}$ odd number, now after taking a closer look you can see in every case all the elements finally become n, i.e. the size of the array\\n\\n[1, 3, 5, 7] gets turned into [4, 4, 4, 4] after 4 operations\\n[1, 3, 5, 7, 9] gets turned into [5, 5, 5, 5, 5] after 6 operations\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow we can simply calculate the number of operations required to turn the whole array to n, after carefull examining we can conclude that\\n#### For odd number of elements :\\n [1, 3, 5, 7, 9]\\nThe pair (1,9) requires 4 operations to turn into 5,5\\nThe pair (3,7) requires 2 operations to turn into 5,5\\n\\nThis can be generalized to form an ap of first n/2 odd numbers, which in this case are the first 2 odd numbers\\n\\n##### For even number of elements :\\n [1, 3, 5, 7]\\nThe pair (1,7) requires 3 operations to turn into 4,4\\nThe pair (3,5) requires 1 operations to turn into 4,4\\n\\nThis can be generalized to form an ap of first n/2 even numbers, which in this case are the first 2 even numbers\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n%2)     // condition odd\\n        {\\n            return n/2*(2+(n/2)-1);\\n        }\\n        return n/2*(1+(n/2)-1); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n%2)     // condition odd\\n        {\\n            return n/2*(2+(n/2)-1);\\n        }\\n        return n/2*(1+(n/2)-1); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339418,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int sum = 0,sol = 0;\\n        for(int i = 0; i < n; i++){\\n            sum += 2*i+1;\\n        }\\n        sum /= n;\\n        for(int i = 0; i < n/2; i++){\\n            sol += sum - (2*i+1);\\n        }\\n        return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int sum = 0,sol = 0;\\n        for(int i = 0; i < n; i++){\\n            sum += 2*i+1;\\n        }\\n        sum /= n;\\n        for(int i = 0; i < n/2; i++){\\n            sol += sum - (2*i+1);\\n        }\\n        return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234004,
                "title": "one-line-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI knew that the numbers are in sequence, So my first thoughts is to use the Sum of Arithmetic Series.\\n> Thanks to Carl Friedrich Gauss\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst you need to calculate the sum of all Odd numbers from 1 to 2*n-1 \\nwe got `sum`= `n^2`\\n\\n![Capture1.PNG](https://assets.leetcode.com/users/images/9f66fa53-6168-42f3-848b-d98bcf9a53ec_1677431611.3710175.png)\\n\\nThen the `average` = `sum/n` = `n`, so the `average` it\\'s just `n`\\n\\n![Capture2.PNG](https://assets.leetcode.com/users/images/866238a2-20d0-4190-8603-1910aae722e7_1677431730.8526685.png)\\n\\nThe result will be just the sum of all numbers: \\n{ `average - i` with `(i=1 ; i<=n ; i+=2)` }\\n- If you use the Sum of Arithmetic Series it will be like this : \\n![Capture3.PNG](https://assets.leetcode.com/users/images/04cef7cd-c94d-41fd-9ad8-4bc706f81aaa_1677434707.2776978.png)\\nwith this relation you need to use `Math.ceil()` \\nCode :`return (int)Math.ceil(n*(n/2.0+0.5)-(n/2.0+0.5)*(n/2.0+0.5));`\\n\\n- Here is another relation that is simple and does not use `Math.ceil` :\\n![Capture5.PNG](https://assets.leetcode.com/users/images/82d8d307-ca00-4c74-98e0-43e19cadf4f2_1677780064.6279993.png)\\n\\nthis relation works because we know that the numbers after the comma will be removed automatically without the need to use `Math.floor()`\\nCode : `return (n*n)/4;`\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        //You can call me Gauss\\n        return (n*n)/4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        //You can call me Gauss\\n        return (n*n)/4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229688,
                "title": "4-line-c-solution-to-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We can get the minimum number of operations only by making all the elements equal to n(target element).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter forming all the elements by the formula (2*i)+1, the summation of the differences between target element n and the elements lesser than that should give you the answer\\n\\n\\n# Complexity\\n- Time complexity: O(n/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int sum=0;\\n        for(int i=0; i<n/2; i++){\\n            sum+=n-((2*i)+1);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int sum=0;\\n        for(int i=0; i<n/2; i++){\\n            sum+=n-((2*i)+1);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102987,
                "title": "c-one-liner-constant-time-o-1-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n\\n        return n % 2? (n/2) * ((n/2)+1) : (n/2) * (n/2);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n\\n        return n % 2? (n/2) * ((n/2)+1) : (n/2) * (n/2);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086176,
                "title": "c-code-with-explanation-o-1-approach-and-o-n-approach",
                "content": "# Intuition\\nIntuition: the array is composed of n odd elements and no matter how much operation we perform the sum of all elements will be same because if we increase one element then we also decrease the other.\\n\\n# Approach\\nThus using Arthemetic Progesssion to determine the sum of n odd numbers which is n^2.\\n then we distribute n^2 through the array of size n that means n^2/n which is n. \\nThus for an ideal array all element will be equal to n\\n  Eg:    --  arr[size:6] =1 3 5 7 9 11   sum(n^2)=6*6=36\\n    ---- ideal array is :   6 6 6 6 6 6\\n     ----    differnce is:  -5 -3 -1 1 3 5\\n   \\nNow all we have to do is count how many units of +ve and -ve \\nwill collide to yield ideal array. In above example ans is 9 (5 and -5 \\ncollide thus 5 operation,  3 and -3 thus 3 opn, 1 and -1 thus 1 opn, and now adding them all 5+3+1=9  return 9)\\n\\nNote this is for even of elements for odd no center element will be 0 eg:\\n      1 3 5 7 9\\n      5 5 5 5 5 \\n      -4 -2 0 2 4   ---   ans is 4+2 = 6\\n\\n# Complexity\\n- Time complexity -- O(n)\\n\\n- Space complexity -- O(1)\\n\\n# Code-1\\n```\\nclass Solution {\\npublic:\\n\\n    int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){  \\n            //Traversing half the array because rest half is \\n            // redundant info coz of palindrome\\n            ans+=(n-((2*i)+1));\\n        }\\n         return ans;\\n    }\\n};\\n\\n\\n```\\n# Code -2 \\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        \\n         //This code also has the same approah but instead of loop i have used AProgression formula\\n\\n\\n         if(n%2==0)return n*n/4; //Sum of n/2 odd number\\n         \\n         return (n/2)*((n/2)+1); //Sum of n/2 even number\\n        \\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){  \\n            //Traversing half the array because rest half is \\n            // redundant info coz of palindrome\\n            ans+=(n-((2*i)+1));\\n        }\\n         return ans;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        \\n         //This code also has the same approah but instead of loop i have used AProgression formula\\n\\n\\n         if(n%2==0)return n*n/4; //Sum of n/2 odd number\\n         \\n         return (n/2)*((n/2)+1); //Sum of n/2 even number\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932014,
                "title": "java-solution-easy-to-understand",
                "content": "# java Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n       int avg =0;\\n       int sum =0;\\n       int count=0;\\n       \\n        for(int i=0; i<n; i++){\\n          sum += (2 * i) +1;\\n        }\\n        avg = sum/n;\\n\\n        for(int i=0; i<n; i++){\\n            int no = (2*i) +1;\\n            if(no < avg){\\n                count += (avg - no);\\n            }\\n        }\\n        return count;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n       int avg =0;\\n       int sum =0;\\n       int count=0;\\n       \\n        for(int i=0; i<n; i++){\\n          sum += (2 * i) +1;\\n        }\\n        avg = sum/n;\\n\\n        for(int i=0; i<n; i++){\\n            int no = (2*i) +1;\\n            if(no < avg){\\n                count += (avg - no);\\n            }\\n        }\\n        return count;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802588,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n * n / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780976,
                "title": "java-n-n-4-no-loops-just-one-return-statement-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        return n*n/4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        return n*n/4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698458,
                "title": "python3-brute-force",
                "content": "Following the problem statement as it is, the following code is designed. \\n\\n1. Generate the array of numbers following the rule: arr[i] = (2 * i) + 1\\n2. Calculate the middle/converging (mid) value for the array:\\n\\t* \\tIf the number **n** is even, the converging value for the array is **sum(middle two elements of the array) / 2** which is equal to **n**.\\n\\t* \\tIf the number **n** is odd, the converging value for the array is the **middle element of the array**.\\n3. Traverse through the array and sum up the difference of the element in the array with the converging value. *abs(num - mid)*\\n4. Since at a time 2 operations can be done *(In one operation, you can select two indices x and y)*, divide the final result by 2.\\n\\n```\\n\\t\\tnums = []        \\n        for i in range(n):\\n            nums.append((2 * i) + 1)\\n        \\n        res, mid = 0, 0\\n        if n % 2 == 0:\\n            mid = n\\n        else:\\n            mid = nums[len(nums) // 2]\\n        for num in nums:\\n            res += abs(num - mid)\\n        return res // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tnums = []        \\n        for i in range(n):\\n            nums.append((2 * i) + 1)\\n        \\n        res, mid = 0, 0\\n        if n % 2 == 0:\\n            mid = n\\n        else:\\n            mid = nums[len(nums) // 2]\\n        for num in nums:\\n            res += abs(num - mid)\\n        return res // 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694718,
                "title": "minimum-operations-to-make-array-equal",
                "content": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        int mid = n/2;\\n        return mid * (mid+n%2);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        int mid = n/2;\\n        return mid * (mid+n%2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2570561,
                "title": "golang-simple-solution",
                "content": "\\n## Area created by lines \\n![image](https://assets.leetcode.com/users/images/2a163d14-3821-43a7-8727-0d3c35fc7263_1663067058.7350228.jpeg)\\n\\nArea created by lines:\\ny = 2x + 1 (arr[i]=2x+1) \\ny-axis \\ny = n/2\\n\\nheight = y2-y1\\n\\t\\t\\t=(2(n/2) + 1) - (2(0)+1)\\n\\t\\t\\t= n\\nwidth = x1-x2 \\n\\t\\t\\t= n/2 - 0\\n\\t\\t\\t= n/2\\n\\t\\t\\t\\ntriangle area   = (height * width)/2 \\n\\t\\t\\t\\t\\t\\t= (n * n/2 ) / 2 \\n\\t\\t\\t\\t\\t\\t= (n*n) / 4\\n\\n\\n```\\nfunc minOperations(n int) int {\\n    return (n * n  / 4 )\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(n int) int {\\n    return (n * n  / 4 )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548503,
                "title": "0-ms-fast-solution-2-lines-of-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int mid = n/2;\\n        return n%2 == 0 ? mid*mid : mid*(mid+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int mid = n/2;\\n        return n%2 == 0 ? mid*mid : mid*(mid+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329711,
                "title": "java-solution-o-1-space-and-time-complexities-with-explanation",
                "content": "The array is always going to be a list of odd numbers. Let\\'s say, n = 4\\n\\nIn this case, the array will be [1, 3, 5, 7]. Note that this is an arithmetic progression and therefore the average (in this case, 4) will lie in the middle of the array. So we can solve this problem by making all elements equal to the average.\\n\\nTo make all the elements 4, we need to add the following: [+3, +1, -1, -3]. Let\\'s call this array `addArray`. This corresponds to 4 operations.\\n\\nLet\\'s take another case where the array has odd number  of elements: n = 5. In this case, the array will be [1, 3, 5, 7, 9]. The average is 5. To make all the elements 5, we need to add the following: [+4, +2, +0, -2, -4]. This corresponds to 6 operations.\\n\\nObserve that if we can simply add the positive numbers in `addArray`, we get the required result. Since the positive numbers form an arithmetic progression, we can use the formula for finding the sum of the elements of an arithmetic progression: S = num/2 ( 2 * a + (num - 1) * d) where S is the sum, num is the number of elements in the progression, a is the first element and d is the difference between each pair of elements.\\n\\nSince the number of positive numbers in `addArray` is half the number of elements in the original array, we have\\n\\n**when n is odd:**\\nnum = n/2\\na = 2\\nd = 2\\n\\nS = n/2 + (n^2)/4\\n\\n**when n is even:**\\nnum = n/2\\na = 1\\nd = 2\\n\\nS = n^2\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int num = n / 2;\\n        if (n % 2 == 0) {\\n            return (num * (2 * 1 + (num - 1) * 2)) / 2;\\n        } else {\\n            return (num * (2 * 2 + (num - 1) * 2)) / 2;\\n        }\\n    }\\n}\\n```\\n\\nWith simplified formulae:\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int num = n / 2;\\n        if (n % 2 == 0) {\\n            return (int) Math.pow(n/2, 2);\\n        } else {\\n            return (int) (n/2 + Math.pow(n/2, 2));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int num = n / 2;\\n        if (n % 2 == 0) {\\n            return (num * (2 * 1 + (num - 1) * 2)) / 2;\\n        } else {\\n            return (num * (2 * 2 + (num - 1) * 2)) / 2;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int num = n / 2;\\n        if (n % 2 == 0) {\\n            return (int) Math.pow(n/2, 2);\\n        } else {\\n            return (int) (n/2 + Math.pow(n/2, 2));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218011,
                "title": "c-simple-math-solution-o-1",
                "content": "There are two cases that can arise:\\n1. If n is odd\\n2. If n is even\\n\\nNow lets see what happens when n is odd, say 5. \\nWe have array as [1,3,5,7,9]\\nNow we can make all the elements equal to the mid element. So the total operation would be [4,2,0,2,4]. As we can clearly see that we will not add the right side of zero as we can two element at a time so we will add 4 + 2 + 0 = 6. In this way we can derive a formula that is (n/2) * (n/2 + 1) {Sum of n/2 even number}.\\n\\nNow if n is even, say 6.\\nWe have array as [1,3,5,7,9,11]\\nHere we can make all the elements equal to the average of (n-1)/2 and n/2. The average comes out to be (5+7)/2 = 6. So the total operations would be [5,3,1,1,3,5]. Now, we will sum the operations and divide it by 2 because we can take 2 elements at a time. The sum of n/2 odd numbers is n * n. So, 3 * 3 = 9.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n%2 == 0) {\\n            return (n/2) * (n/2);\\n        }\\n        else {\\n            n = n-1;\\n            return ((n/2) * ((n/2) + 1));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n%2 == 0) {\\n            return (n/2) * (n/2);\\n        }\\n        else {\\n            n = n-1;\\n            return ((n/2) * ((n/2) + 1));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954521,
                "title": "o-1-one-line-solution-explained",
                "content": "For all n belongs to Integer. \\nRquired array is 1,3,5,...2n-1\\nWe need to make all the elements equal to n.\\nThe 1st and last element can be made equal to n in (n-1) operations\\nSimilarly, we require (n-1), (n-3), (n-5).... operations.\\nTotal operations = (n-1)+(n-3)+(n-5)+... upto n/2 terms.\\nIt can be simplified as (n+n+n....) - (1+3+5....)\\nwhich equals n.n/2 - (n/2)^2\\n= n^2/4\\n```\\nreturn (n*n)/4",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "For all n belongs to Integer. \\nRquired array is 1,3,5,...2n-1\\nWe need to make all the elements equal to n.\\nThe 1st and last element can be made equal to n in (n-1) operations\\nSimilarly, we require (n-1), (n-3), (n-5).... operations.\\nTotal operations = (n-1)+(n-3)+(n-5)+... upto n/2 terms.\\nIt can be simplified as (n+n+n....) - (1+3+5....)\\nwhich equals n.n/2 - (n/2)^2\\n= n^2/4\\n```\\nreturn (n*n)/4",
                "codeTag": "Unknown"
            },
            {
                "id": 1921991,
                "title": "python3-simple-and-easy-explained",
                "content": "If list has only 1 element return 0 as no operation is performed\\nIf list has more than one element then check for 1st and last element as 1st element will be 1 and last element will be 2*(n-1)+1(formula is given in question) 1st and last element will converge or become equal at their average value. So we have to make all elements\\nof the array equal to that average value.\\nWe will chose indexes as (1st and last element) then (2nd and 2nd last element) and so on...\\nIn this approach we will increase the lower value(1st,2nd..) and decrease the higher value(last, 2nd last...) by 1\\nwe see that operations are performed in a symmetric way. So we will just calculate the values for one half of\\nthe array and add and store the results.\\nHere I have done on the 2nd half you can do it for the first half if you like(from 0 to n//2)\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # if there is only one element in list then its already equal so no need to perform any operation\\n        if n==1:return 0\\n        else:\\n            a=1 # First value\\n            b=2*(n-1)+1 # Last value\\n            avg=(b+1)//2  # Taking average\\n            res=0 # Counter for storing answer\\n            for i in range(n//2,n): # Loop for 2nd half portion of the array\\n                res+=abs((2*i+1)-avg)   # Taking the difference with average value and adding to the result\\n            return res\\n```\\n**Please upvote if the solution helps.\\nFeel free to ask any questions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # if there is only one element in list then its already equal so no need to perform any operation\\n        if n==1:return 0\\n        else:\\n            a=1 # First value\\n            b=2*(n-1)+1 # Last value\\n            avg=(b+1)//2  # Taking average\\n            res=0 # Counter for storing answer\\n            for i in range(n//2,n): # Loop for 2nd half portion of the array\\n                res+=abs((2*i+1)-avg)   # Taking the difference with average value and adding to the result\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826326,
                "title": "java-detailed-explanation-two-approaches",
                "content": "# Approach -1 :\\n**For n = 3**\\n* If i = 0 , arr[0] = 2i + 1 = 1\\n* If i = 1 , arr[1] = 2i + 1 = 3\\n* If i = 2 , arr[2] = 2i + 1 = 5\\nWe dec 5 by 1 and inc 1 by 1 \\narr : { 2 , 3 , 4 }\\nWe dec 4 by 1 and inc 2 by 1\\narr : { 3 , 3 , 3 }\\nMin operation = 2\\nAverage of all nos = ( 1 + 3 + 5 ) / 3 = 3\\n\\n**For  n = 4**\\n* If i = 0 , arr[ 0 ] = 2i +1 = 1\\n* If i = 1 , arr[ 1 ] = 2i + 1 = 3\\n* If i = 2 , arr[ 2 ] = 2i + 1 = 5\\n* If i = 3 , arr [ 3 ] = 2i + 1 = 7\\nWe dec 7 by 1 & inc 1 by 1\\narr : { 2 , 3, 5, 6 }\\nWe dec 6 by 1 and inc 2 by 1\\narr : { 3 , 3 , 5 , 5 }\\nWe dec 5 by 1 and inc 3 by 1\\narr : { 4 , 3, 4 , 5 }\\nWe dec 5 by 1 and inc 3 by 1\\narr : { 4 , 4, 4, 4 }\\n\\nmin operation = 4\\nAverage of all elements = (1 + 3 + 5 + 7) / 4 = 4\\n\\n## Observation from the above examples : All Elements tend to acheive their average \\n\\narr :   {   1 ,   3  ,  5 ,  7 }\\nops : { +3 , +1 , -1 , -3 }\\nWe clearly see the pairs .\\nWe have to inc arr[ 0 ] = 1 by 1,  3 times &  dec arr [ 3 ] = 7 , by 1, 3 times\\nWe have to inc arr[ 1 ] = 1 by 1,  1 time &  dec arr [ 3 ] = 7 , by 1 , 3 times.\\n\\nSo , min operations = 3 + 1 = 4\\n\\n# Steps :\\n* We find the average of all elements.\\n* We create an array \\'operations\\' of size = n.\\n* operations [ i ] = avg - arr [ i ] , i.e we calculate how much we have to add to make arr[ i ] =  avg. If arr[ i ] > avg , then , avg - arr [ i ] = -ve.\\n* We add all non -ve  elements of operations array . That\\'ll give us the final answer.\\n# Time Complexity : O(n)\\n# Code:\\n```\\nclass Solution {\\n    public int minOperations(int n) \\n    {\\n        int arr[] = new int[n];\\n        int sum = 0;\\n        int operations[] = new int[n]; // operations[i] = stores deviation of arr[i] from average of arr elements\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            arr[i] = (2*i)+1;\\n            sum += arr[i];\\n        }\\n        int avg = sum/n;\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            operations[i] = avg - arr[i];\\n            if(operations[i]>=0)\\n                ans += operations[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Approach - 2:\\n* As we know , for n = 4 \\n   arr : { 1 , 3 , 5 , 7 }  &  avg = 4\\n\\t ops : { 3 , 1 , -1 , - 3 } \\n\\t min operations = 4\\n\\t We observe , that , our ans is sum of the AP series : { 1 , 3 } \\n* For n = 3 ,\\n  arr : { 1 , 3  , 5 } &  avg = 3\\n\\tops : { 2 , 0 , -2 }\\n\\tMin operations = 2\\n\\tWe observe , that , our ans is sum of the AP series : {  2 }\\n\\t\\n* \\tFor n = 5\\n    arr : { 1 , 3 , 5 , 7 , 9 }  & avg = 5\\n\\t\\tops : { 4 , 2 , 0 , -2 , -4 }\\n\\t\\tmin operations = 6\\n\\t\\tWe observe that our ans is sum of the AP series : {2 ,4 }\\n\\t\\t\\n*  For n = 6,\\n    arr : { 1 ,3 , 5 , 7 , 9 , 11} & avg = 6\\n\\t\\tops : { 5 , 3, 1 , -1 , -3 , -5 }\\n\\t\\tmin operations = 9\\n\\t\\tWe observe , our ans is the sum of the AP series : { 1 , 3 , 5}\\n\\t\\t\\n# \\t\\tFrom the above examples , we make a couple of conclusions:-\\n **1.)When n = odd , The answer is sum of first (n/2) elements AP of series : { 2 , 4 ,6 ,8 ,....} **\\n As we know ,  the sum of first n terms of an AP series = S = n/2[2a + (n \\u2212 1) \\xD7 d]\\n Here a = 2 & d = 2 & n = n/2\\n So, S =n/2[4 + ( n - 1 ) * 2 ]**\\n          = n /2 [ 4 + 2n - 2 ]\\n\\t\\t\\t\\t\\t= n/2 [ 2 + 2n ] \\n\\t\\t\\t\\t\\t= n * (n+1)\\nHere, n = n/ 2\\nSo, S = n/2 * ( n/2 + 1)\\n\\t\\t\\t\\t\\t\\n**2. ) When n = even , The answer is sum of first (n/2) elements of AP series : { 1 , 3 , 5 ,....}**\\n As we know ,  the sum of first n terms of an AP series = S = n/2[2a + (n \\u2212 1) \\xD7 d]\\n Here a = 1 & d = 2 & n = n/2\\n So , S = n/2 [ 2 + 2(n-1)]\\n           = n/2[ 2 + 2n - 2 ]\\n\\t\\t\\t\\t\\t = n/2 * 2n\\n\\t\\t\\t\\t\\t = n^2\\nHere , n = n /2\\nSo , S = (n/2)^2\\n\\n# Time Complexity : O(1)\\n# Code:\\n```\\nclass Solution {\\n    public int minOperations(int n) \\n    {\\n        int s = 0;\\n        if(n%2 == 0)\\n            s = (n/2) * (n/2);\\n        else\\n            s = (n/2) * (n/2 + 1);\\n        return s;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) \\n    {\\n        int arr[] = new int[n];\\n        int sum = 0;\\n        int operations[] = new int[n]; // operations[i] = stores deviation of arr[i] from average of arr elements\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            arr[i] = (2*i)+1;\\n            sum += arr[i];\\n        }\\n        int avg = sum/n;\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            operations[i] = avg - arr[i];\\n            if(operations[i]>=0)\\n                ans += operations[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int n) \\n    {\\n        int s = 0;\\n        if(n%2 == 0)\\n            s = (n/2) * (n/2);\\n        else\\n            s = (n/2) * (n/2 + 1);\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770882,
                "title": "c-simplest-intuitive-solution",
                "content": "* We just have to make all the elements equal to the sumOfAll/2 or (first + last)/2 (Both are the same since they\\'re consecutive odd numbers).\\n* That is the minimum no. of operations performed.\\n* So traverse the first half of the array and add target - arr[i] to the ans (Since arr[x] + 1 & arr[y] - 1 are counted as one operation and x ---> belongs to the first half & y ---> belongs to the second half).\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int target = (1 + 2*(n-1) + 1)/2, min_op=0;\\n        for(int i=0; i<n/2; i++) min_op += target - (2*(i) + 1);\\n        \\n        return min_op;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n/2)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int target = (1 + 2*(n-1) + 1)/2, min_op=0;\\n        for(int i=0; i<n/2; i++) min_op += target - (2*(i) + 1);\\n        \\n        return min_op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765166,
                "title": "easy-soln-cpp",
                "content": "int minOperations(int n) {\\n        int cnt=0;\\n         for(int i=1;i<=n;i++){\\n             if(i%2==1){\\n                 cnt+=(n-i);\\n             }\\n         }\\n        return cnt;\\n}",
                "solutionTags": [],
                "code": "int minOperations(int n) {\\n        int cnt=0;\\n         for(int i=1;i<=n;i++){\\n             if(i%2==1){\\n                 cnt+=(n-i);\\n             }\\n         }\\n        return cnt;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1726736,
                "title": "c-100-faster-solution-one-lline-code-easy-implementation",
                "content": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n/2)*(n-(n/2));\\n    }\\n};\\nyou can easily understand it by exploring this deduction\\nyou can try like this\\nforex. n=6\\n1    +5=6\\n3    +3=6\\n5    +1=6\\n7     -1=6\\n9     -3=6\\n11   -5=6",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n/2)*(n-(n/2));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1704407,
                "title": "understandable-code-for-beginners-like-me-in-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        if(n%2!=0):\\n            n=n//2\\n            return n*(n+1)\\n        else:\\n            n=n//2\\n            return n**2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        if(n%2!=0):\\n            n=n//2\\n            return n*(n+1)\\n        else:\\n            n=n//2\\n            return n**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566356,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n     int count=0;\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            count=count+((2*j+1) -(2*i+1))/2;\\n            i++;\\n            j--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n     int count=0;\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            count=count+((2*j+1) -(2*i+1))/2;\\n            i++;\\n            j--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561325,
                "title": "how-is-this-even-a-medium-question-100-faster-solution",
                "content": "```\\nint minOperations(int n) {\\n        int i = 0, j = n - 1, ans = 0;\\n        while(i < j) {\\n            ans += ((2 * j) - (2 * i)) / 2;\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(int n) {\\n        int i = 0, j = n - 1, ans = 0;\\n        while(i < j) {\\n            ans += ((2 * j) - (2 * i)) / 2;\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483915,
                "title": "python3-constant-time-o-1-space",
                "content": "**Basically we have an array with all the odd elements**\\n\\nDepending upon the value of ```n``` we will have 2 different ```if``` cases :\\n\\n#### **1. If N is odd:** \\nThe value of all elements is eventually going to be equal to the middle term (observation from notes taken on paper). Its ```True``` because there is equally larg subset of numbers that need to be compensated with ```+=1``` as with ```-=1```.\\n\\n(For instance for ```n=5 -> [1, 3, 5, 7, 9]``` eventually we will make the ```[5, 3, 5, 7, 5]```, hence 1 a 9 has been affected by the same number(4) ```k times```, so was 3 & 7 by different number(2) and just``` k-2 times```) We just need to try more values for ```n``` and for each sum all the compensation values. 4+2=6\\n\\nFor more n it is going to be the same, write down the observations and you will find yourself with something like me \\n```\\n1->0\\n3->2\\n5->6\\n7->12\\n9->20\\n```\\nWhich can be written as a\\\\*b where a+b=9 and a+1=b ```(5 -> 3*2 because 3+2=5) or (7 -> 4*3 because 4+3=7)...```\\n\\n\\n#### **2. If N is even:** \\nwe can make the same observation on paper:\\n```\\n2->1\\n4->2\\n6->9\\n8->16\\n10->25\\n12->36\\n```\\nNow just we need to see there a pattern, this one is kinda obvious, the outputs are in form (n/2)\\\\*\\\\*2.\\n\\nWe have got ourselves solution in O(1) since we have been using just pure math to do the job. \\n____\\n## CODE in O(1)\\n\\n```\\nimport math\\n\\ndef minOperations(n: int) -> int:\\n\\t\\n\\tif n%2==0:\\n\\t\\treturn int((n/2)**2)\\n\\telse:\\n\\t\\thalf=math.floor(n/2)\\n\\t\\treturn half*(half+1)\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```n```\n```if```\n```True```\n```+=1```\n```-=1```\n```n=5 -> [1, 3, 5, 7, 9]```\n```[5, 3, 5, 7, 5]```\n```k times```\n``` k-2 times```\n```n```\n```\\n1->0\\n3->2\\n5->6\\n7->12\\n9->20\\n```\n```(5 -> 3*2 because 3+2=5) or (7 -> 4*3 because 4+3=7)...```\n```\\n2->1\\n4->2\\n6->9\\n8->16\\n10->25\\n12->36\\n```\n```\\nimport math\\n\\ndef minOperations(n: int) -> int:\\n\\t\\n\\tif n%2==0:\\n\\t\\treturn int((n/2)**2)\\n\\telse:\\n\\t\\thalf=math.floor(n/2)\\n\\t\\treturn half*(half+1)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1391415,
                "title": "c-beats-100-easy-to-understand-solution",
                "content": "```\\nint minOperations(int n) {\\n        if(n == 1) return 0;\\n        int ans = 0;\\n        if(n % 2 == 0){\\n            // int avg = n;\\n            for(int i = 0; i < n/2 ; i++){\\n                ans += (n - (2 * i + 1));\\n            }\\n        }\\n        else{\\n            int val = 2 * (n/2) + 1;\\n            for(int i = 0; i < n/2; i++){\\n                ans += (val - (2*i + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nHit upvote if you liked the answer.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minOperations(int n) {\\n        if(n == 1) return 0;\\n        int ans = 0;\\n        if(n % 2 == 0){\\n            // int avg = n;\\n            for(int i = 0; i < n/2 ; i++){\\n                ans += (n - (2 * i + 1));\\n            }\\n        }\\n        else{\\n            int val = 2 * (n/2) + 1;\\n            for(int i = 0; i < n/2; i++){\\n                ans += (val - (2*i + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151154,
                "title": "java-o-1-100-logic",
                "content": "\\tLOGIC: there are 2 cases even length array and odd length array\\n\\tcase1: Even length array ex 1,3,5,7,9,11\\n\\tso we will change every element into (5+7)/2 or simply \\'6\\'\\n\\tso forget right half and convert left operations will be 1 (5 to 6), 3 (3 to 6), 5(1 to 6) and so on \\n\\thencee answer =(sum f n odd numbers ) i.e (n^2)\\n\\t\\n\\tcase2: Odd Length Array ex 1,3,5,7,9\\n\\tso we will change every element into 5 i.e. middle element\\n\\tso forget right half and convert left operations will be 2 (3 to 5), 6 (1 to 5) and so on\\n\\thence answer = (n^2 - n)\\n\\nclass Solution {\\n\\t\\tpublic int minOperations(int n) {\\n\\t\\t\\treturn n*n/4;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minOperations(int n) {\\n\\t\\t\\treturn n*n/4;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1146256,
                "title": "java-simple-and-easy-to-1-so-1-solution-0-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        // 1  3  5  7  9 arr[i]\\n        // 0  1  2  3  4\\n        // n = 5, half =  5 / 2 = 2\\n        \\n        //sum =  (5 - 1) +  (5 - 3) \\n        //.   =  (5 + 5) -  (1 + 3)\\n        //.   =  (n * 2) -  (sum of first n / 2  odd number)\\n        \\n        int half = (n / 2);\\n        \\n        return (n * half) - getSeriesSum(1, 2, half);\\n    }\\n                                \\n    private int getSeriesSum(int a, int d, double n){\\n        //Arithmetic Progressions\\n        //The sum to n terms of an arithmetic progression\\n        //This is given by:\\n        //Sn = \\xBD n [ 2a + (n - 1)d ]\\n        //  where d = common difference, a = first term\\n        \\n        \\n        return (int)((n / 2) * (2 * a + (n - 1)  * d));\\n    }   \\n}\\n                                \\n  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        // 1  3  5  7  9 arr[i]\\n        // 0  1  2  3  4\\n        // n = 5, half =  5 / 2 = 2\\n        \\n        //sum =  (5 - 1) +  (5 - 3) \\n        //.   =  (5 + 5) -  (1 + 3)\\n        //.   =  (n * 2) -  (sum of first n / 2  odd number)\\n        \\n        int half = (n / 2);\\n        \\n        return (n * half) - getSeriesSum(1, 2, half);\\n    }\\n                                \\n    private int getSeriesSum(int a, int d, double n){\\n        //Arithmetic Progressions\\n        //The sum to n terms of an arithmetic progression\\n        //This is given by:\\n        //Sn = \\xBD n [ 2a + (n - 1)d ]\\n        //  where d = common difference, a = first term\\n        \\n        \\n        return (int)((n / 2) * (2 * a + (n - 1)  * d));\\n    }   \\n}\\n                                \\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145437,
                "title": "2-solution-0ms-one-line-solution-java",
                "content": "sum of odd integers in n^2, thus average is (nxn/n)=n\\n\\nwe iterate over the number of integers less than average and add the difference to answer, since only adding 1\\nor subtracting 1 is allowed.\\n\\n```\\n\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n/2;i++){\\n            \\n            ans+=n-(2*i)-1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}\\n\\n\\n```\\n\\n\\non the basis of observation it is clear that \\n\\n```\\n\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        return (n*n/4);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n/2;i++){\\n            \\n            ans+=n-(2*i)-1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n}\\n\\n\\n```\n```\\n\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        return (n*n/4);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145255,
                "title": "simple-solution",
                "content": "``` java solution\\n\\nclass Solution {\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        int sumOfNum = 0;\\n        for(int i=0;i<n;i++)\\n        { \\n            arr[i] = 2*i + 1;\\n            sumOfNum += arr[i];\\n        }\\n        \\n        int avg = sumOfNum/n;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((avg-arr[i])>0)\\n                count += (avg-arr[i]);\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n\\npython solution\\n\\nclass Solution(object):\\n    def minOperations(self, n):\\n        arr = []\\n        NumSum = 0;\\n        \\n        for i in range(0, n, 1):\\n            arr.append(2*i + 1)\\n            NumSum += arr[i]\\n        \\n        avg = NumSum/n\\n        \\n        count = 0;\\n        \\n        for i in range(0, n, 1):\\n            if (avg-arr[i]) > 0:\\n                count += (avg-arr[i])\\n            else:\\n                break\\n        \\n        return count\\n        \\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        int sumOfNum = 0;\\n        for(int i=0;i<n;i++)\\n        { \\n            arr[i] = 2*i + 1;\\n            sumOfNum += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1145247,
                "title": "minimum-operations-1-line-no-code-just-a-calculation-0-ms",
                "content": "This is just a math problem. I solved it with pencil and paper.\\n\\nIf n is odd, then the answer is 2 * (1 + 2 + 3 + ... + m), where m = (n - 1) / 2.   That works out to m * (m + 1) which is (n^2 - 1) / 4.\\nIf n is even, then the answer is 2 * (1 + 2 + 3 + ... + m) - (n / 2), where m = (n / 2).  That works out to (n^2) / 4.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n * n - n % 2) / 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n * n - n % 2) / 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145229,
                "title": "c-best-explanation-and-easy-code-100-fast",
                "content": "The main objective of this problem is to **make all the elements** of array **equal to the Mid element**. \\n* There are two possible cases\\n1. **n is odd**\\nlet\\'s consider n=5.\\narray contains\\n**1 3 5 7 9**\\n* Here, middle element of array is -> 5.\\n* Now one by one, we need to choose elements in a pair (which are not equal to mid element), perform some operation on a pair to make them equal to middle element.\\n* Let\\'s take pair **(3,7)** ,We will decrement 7 and incement 3, two times to make them equal to 5(middle element).\\n* So it takes 2 steps.\\n* Let\\'s take another pair **(1,9)** We will decrement 9 and incement 1, four times to make them equal to 5.\\n* So it takes 4 steps.\\n* After performing these steps, all elements will become 5.\\n* So, Total steps: 2+4=6. (sum of first n/2 even numbers)\\n* **Sum of first k EVEN numbers = k(k+1)**\\n* ans would be  **n/2(n/2+1)**\\n\\n2. **n is even**\\nlet\\'s consider n=6.\\narray contains\\n**1 3 5 7 9 11**\\n* Here, middle element of array is -> (5+7)/2=6.\\n* Let\\'s take pair **(5,7)**, We will decrement 7 and incement 5, one time to make them equal to 6.\\n* So it takes 1 step.\\n* Let\\'s take 2nd pair **(3,9)**, We will decrement 9 and incement 3, three times to make them equal to 6.\\n* So it takes 3 steps.\\n*  Let\\'s take last pair **(1,11)**, We will decrement 11 and incement 1, five times to them equal to 6.\\n* So it takes 5 steps.\\n* After performing these steps, all elements will become 6.\\n* Total steps: 1+3+5=9. (sum of first n/2 odd numbers)\\n* **Sum of first k ODD numbers = k*k.**\\n*  ans would be **n/2*n/2**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       return n&1 ? n/2*(n/2+1) : n/2*n/2 ;\\n    }\\n};\\n```\\n*If you liked this solution please upvote\\uD83D\\uDE4F if you have any query plz comment below \\uD83D\\uDC47*",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       return n&1 ? n/2*(n/2+1) : n/2*n/2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145211,
                "title": "minimum-operations-to-make-array-equal-easy-solution-one-liner-explained",
                "content": "Here, the main point to consider is, `arr[i] = (2 * i) + 1` which are consecutive odd numbers,\\nso, to make all numbers equal by choosing` x, y` and performing `arr[x] -=1 and arr[y] += 1`, we just take `x as last number and y as 1st number` and perform the **number of operations until its value equal to mid element.**\\nLets take a example to understand it more.\\nn = 5, then array will be..[1,3,5,7,9]\\n-> step-1: here, take x=9 and y=1 perform operations until both equal to 5. It take 4 operations.\\n-> step-2: now take x=7 and y=3, perform operations until both equal to 5. it takes 2 operations.\\n-> Total number of operations will be `2+4=6`\\nBut, why equal to 5? we need minimum number of operations. so follow greedy method.\\n**Have you noticed somthing in number of operations required??**\\n-->if n==odd, we need **(sum of n/2 even numbers)** operations.(observe above example)\\n-->if n==even, we need **(sum of n/2 odd numbers)** operations.(take an example, you will find it out).\\nSo, our problem now became easier for us. now **we just need to cal sum of n/2 even numbers if n is odd, sum of n/2 odd numbers if n is even.**\\n\\n**Do upvote**if you like the code and explanation.\\n```\\nint minOperations(int n) {\\n        return n%2 ? (2*(n/2)*((n/2)+1)/2) : (n*n/4);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(int n) {\\n        return n%2 ? (2*(n/2)*((n/2)+1)/2) : (n*n/4);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145175,
                "title": "minimum-operations-to-make-array-equal-python-solution-with-clear-intuition-and-explanation",
                "content": "This problem has a very simple intuition behind it. When given the input n, we form the array first. We observe that we get a simple **arithmetic progression** (AP) with a **common difference of 2**. \\n\\nNow, moving ahead, we have **two possibilities, n can either be even, or odd**. So, for both the possibilities, let us take an example and proceed:\\n\\n**For n = 5, we have an array: [1,3,5,7,9]**\\n\\nNow, since n is odd, it has a middle element, and if we carefully observe, **the resultant array will have all elements equal to the middle element** (if n is odd, you can take other examples of n which are odd and verify this).\\nSo, we can easily pair 3 and 7 and perform two operations to make them equal to 5, similarly pair 1 and 9 to perform 4 operations to make them equal to 5.\\n\\n**We observe that the total number of operations here are summing in a series:\\n2 (3 and 7) + 4 (1 and 9)**\\n\\n**Now, if n is even:\\nFor n = 6, arr = [1,3,5,7,9,11]**\\n\\nIt does not have a middle element, but **here, we can start from the middle of the array and pair 5 and 7 in the start and perform 1 operation to make them equal to \\'6\\', which we observe to be equal to all elements in the resultant array**. So, continuing, we can follow to pair 3 and 9, and then 1 and 11, and so on.\\n\\n**We observe that the total number of operations here are summing in a series:\\n1 (5 and 7) + 3 (3 and 9) + 5(1 and 11)**\\n\\nIf the intuition isn\\'t simple enough, python makes it way more easier for us, as we can just run a loop to sum the values with step = 2 starting from 1 ( for even n) or from 2 (for odd n). \\n\\nHere is my implementation for the above problem:\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return sum([i for i in range(1,n,2)]) if(n%2==0) else sum([i for i in range(2,n,2)])\\n```\\n\\n**We can optimize this code, by using the summation formula of odd numbers and even numbers, but this was not used by me here just for the sake of easy demonstration of the intuition.**\\n\\n**PS: This is my first article!** Please **upvote** if you find it helpful, as it would encourage me to do even better! \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return sum([i for i in range(1,n,2)]) if(n%2==0) else sum([i for i in range(2,n,2)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145130,
                "title": "python-explained-simple-solution-runtime-beats-90-and-memory-beats-75",
                "content": "Observe that:\\nWhen `n=2`, array is `[1, 3]`, we need `1*1` operations.\\nWhen `n=3`, array is `[1, 3, 5]`, we need `1*2` operations.\\nWhen `n=4`, array is `[1, 3, 5, 7]`, we need `2*2` operations.\\nWhen `n=5`, array is `[1, 3, 5, 7, 9]`, we need `2*3` operations.\\nWhen `n=6`, array is `[1, 3, 5, 7, 9, 11]`, we need `3*3` operations.\\nAnd so on.\\n\\nThe idea is that we need to exchange `floor(n/2)` pairs of numbers on an average of `ceil(n/2)` times. Since `floor(n/2)+ceil(n/2)=n` for any integer, we can solve the problem by:\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        half = int(n/2)\\n        return half*(n-half)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        half = int(n/2)\\n        return half*(n-half)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145107,
                "title": "java-easy-solution-fast",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int a[]=new int[n],sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=(2*i)+1;\\n            sum+=a[i];\\n        }\\n        sum/=n;\\n        int c=0;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            c+=Math.abs(sum-a[i]);\\n        }\\n            return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int a[]=new int[n],sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=(2*i)+1;\\n            sum+=a[i];\\n        }\\n        sum/=n;\\n        int c=0;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            c+=Math.abs(sum-a[i]);\\n        }\\n            return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145070,
                "title": "python-solution-one-line",
                "content": "Magic line:\\n\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return (n // 2) * (n // 2 + n % 2)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return (n // 2) * (n // 2 + n % 2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145049,
                "title": "python-arithmetic-progression",
                "content": "# Idea\\n\\nThe problem can be solved in constant time if you think enough about the question. The question states that the values need to end up being equal. Natural question is, **equal to what?** Let\\'s see two examples: `[1, 3, 5]`, `[1, 3, 5, 7]`. To make all numbers equal and perform the least number of operations, we need to shift them to the \"middle\" or the average. In the two examples above these numbers are 3 and 4 respectively. Because of the properties of the arithmetic progression we are given, this is actually `n`, which is the length of the arithmetic progression that is given to us.\\n\\nWe now know the target value. So, **how many** operations would we need to perform? Since the target value is the mean value of our sequence, we will need to perform equal number of increments and decrements. In one operation we do both, so we can count either the number of increments or decrements necessary and that will be our answer. Here let\\'s try to find the number of increments.\\n\\nThe numbers of increments for consecutive values will actually form another arithmetic progression. To find the sum of it, we need to find the first, last and the number of elements in this progression. Then we can use the formula for calculating the sum of arithmetic progression to find our answer.\\n# Complexity\\nTime / Space: O(1)\\n```\\ndef minOperations(self, n: int) -> int:\\n\\t# n is actually the goal value for us\\n\\tnum_count = (n + 1) // 2\\n\\tfirst = n - 1\\n\\tlast = n - (2 * num_count - 1)\\n\\treturn num_count * (first + last) // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef minOperations(self, n: int) -> int:\\n\\t# n is actually the goal value for us\\n\\tnum_count = (n + 1) // 2\\n\\tfirst = n - 1\\n\\tlast = n - (2 * num_count - 1)\\n\\treturn num_count * (first + last) // 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 963316,
                "title": "c-java-python-1-liners",
                "content": "**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n*n)/4;   \\n    }\\n};\\n```\\n\\n**Java:**\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return (n*n)/4;\\n    }\\n}\\n```\\n\\n**Python:**\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return (n*n)//4\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n*n)/4;   \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return (n*n)/4;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return (n*n)//4\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940948,
                "title": "python3-one-line",
                "content": "```\\ndef minOperations(n):\\n\\treturn int((n+n%2)*(n//2)/2\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperations(n):\\n\\treturn int((n+n%2)*(n//2)/2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 897675,
                "title": "silly-one-liner",
                "content": "```java\\nreturn n/2*(n/2+n%2);\\n```\\n\\nIt is based off the knowledge that the first k odd integers sum to k^2, so the solution is (n/2)^2 for even n. For odd n, it takes an extra n/2 steps to solve the problem.\\n\\n",
                "solutionTags": [],
                "code": "```java\\nreturn n/2*(n/2+n%2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876528,
                "title": "c-o-1-one-line-beats-100",
                "content": "```\\nint minOperations(int n) {\\n        return (n*(n/2))-((n/2)*(n/2));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(int n) {\\n        return (n*(n/2))-((n/2)*(n/2));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868630,
                "title": "one-liner-in-c-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // If n is even then resultant ans will be the sum of odd numbers starting from 1 to n/2 --> formula =>\\n\\t\\t//(number of terms)^2\\n\\t\\t\\n\\t\\t// if n is odd then resultant ans will be the sum of even numbers starting from 2 to n/2 --> formula =>\\n\\t\\t// (number of terms)*(number of terms + 1)\\n\\t\\t\\n        return (n%2 == 0) ? (n/2)*(n/2) : (n/2)*((n/2)+1);\\n\\t\\t\\n\\t\\t// Now if you are thinking why sum of odd/ even numbers upto n/2 terms, Let me give you a brief idea :\\n\\t\\t/*\\n\\t\\t\\tsuppose n = 7, i.e array = [1, 3, 5, 7, 9, 11, 13]\\n\\t\\t\\tFirst, look at the middle element, we are going to convert whole array to this number.\\n\\t\\t\\t1) convert 5 and 9 to 6 and 8, then again convert them to 7 and 7, which costs --> 2\\n\\t\\t\\t2) convert 3 and 11 to 7 and 7 which costs                                                          --> 4\\n\\t\\t\\t3) convert 1 and 13 to 7 and 7 which costs                                                          --> 6\\n\\n\\t\\t\\tSo, ans will be 2 + 4 + 6 ===> 3 terms (n/2), where n is 7\\n\\t\\t\\tTherefore, ans = 3*(3 + 1).\\n\\t\\t*/\\n    }\\n};\\n```\\n\\nThanks for reading, if you like the explanation and soln, then do upvote. :) Happy Coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // If n is even then resultant ans will be the sum of odd numbers starting from 1 to n/2 --> formula =>\\n\\t\\t//(number of terms)^2\\n\\t\\t\\n\\t\\t// if n is odd then resultant ans will be the sum of even numbers starting from 2 to n/2 --> formula =>\\n\\t\\t// (number of terms)*(number of terms + 1)\\n\\t\\t\\n        return (n%2 == 0) ? (n/2)*(n/2) : (n/2)*((n/2)+1);\\n\\t\\t\\n\\t\\t// Now if you are thinking why sum of odd/ even numbers upto n/2 terms, Let me give you a brief idea :\\n\\t\\t/*\\n\\t\\t\\tsuppose n = 7, i.e array = [1, 3, 5, 7, 9, 11, 13]\\n\\t\\t\\tFirst, look at the middle element, we are going to convert whole array to this number.\\n\\t\\t\\t1) convert 5 and 9 to 6 and 8, then again convert them to 7 and 7, which costs --> 2\\n\\t\\t\\t2) convert 3 and 11 to 7 and 7 which costs                                                          --> 4\\n\\t\\t\\t3) convert 1 and 13 to 7 and 7 which costs                                                          --> 6\\n\\n\\t\\t\\tSo, ans will be 2 + 4 + 6 ===> 3 terms (n/2), where n is 7\\n\\t\\t\\tTherefore, ans = 3*(3 + 1).\\n\\t\\t*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796116,
                "title": "javascript-80-ms-36-8-mb",
                "content": "```js\\n/*\\n  linear function: 2n + 1\\n  target = sum(1 to f(n)) / n\\n\\n  nth element (last elements value) = 2 * (n - 1) + 1\\n  target = avg of first and nth element: (2 * (n - 1) + 1 + 1) / 2\\n  simplify target => (2n - 2 + 2) / 2, which is = n;\\n*/\\nvar minOperations = function (n) {\\n  let counter = 0;\\n  for (let i = 1; i < n; i += 2) {\\n    counter += n - i;\\n  }\\n  return counter;\\n}\\n```\\n---\\ninitial idea (slow)\\n```js\\nvar minOperations = function (n) {\\n  const half = Math.floor(n / 2);\\n  const arr = Array.from(new Array(n), (_, idx) => 2 * idx + 1);\\n  const target = arr.reduce((acc, cur) => acc + cur) / n;\\n\\n  let counter = 0;\\n  for (let i = 0; i < half; i++) {\\n    if (arr[i] < target) counter += target - arr[i];\\n  }\\n  return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n  linear function: 2n + 1\\n  target = sum(1 to f(n)) / n\\n\\n  nth element (last elements value) = 2 * (n - 1) + 1\\n  target = avg of first and nth element: (2 * (n - 1) + 1 + 1) / 2\\n  simplify target => (2n - 2 + 2) / 2, which is = n;\\n*/\\nvar minOperations = function (n) {\\n  let counter = 0;\\n  for (let i = 1; i < n; i += 2) {\\n    counter += n - i;\\n  }\\n  return counter;\\n}\\n```\n```js\\nvar minOperations = function (n) {\\n  const half = Math.floor(n / 2);\\n  const arr = Array.from(new Array(n), (_, idx) => 2 * idx + 1);\\n  const target = arr.reduce((acc, cur) => acc + cur) / n;\\n\\n  let counter = 0;\\n  for (let i = 0; i < half; i++) {\\n    if (arr[i] < target) counter += target - arr[i];\\n  }\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794306,
                "title": "java-3-liner-100-time-100-memory",
                "content": "```\\npublic int minOperations(int n) {\\n        int mid = n / 2;\\n        int steps=mid * (mid + n % 2);\\n\\t\\treturn steps;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int n) {\\n        int mid = n / 2;\\n        int steps=mid * (mid + n % 2);\\n\\t\\treturn steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794299,
                "title": "csharp-solution-o-1",
                "content": "Time Complexity O(1)\\nUse the formula to determine the minimum number of operations.\\n\\nIf `n` is 5, our array will be `1, 3, 5, 7, 9` with **odd** number of total elements\\n\\nThe element in the middle will be `5` at index `2`. \\n\\nFrom the middle, we can calculate the distance from the nearest elements.\\n\\nFor `3` to reach 5, it will take `2` operations. (Distance from middle element is `1`) \\nFor `1` to reach 5 it will take `4` operations. (Distance from middle element is `2`)\\n\\nSo we can create the table:\\n\\nDistance to middle element | Number of Operations\\n1 | 2 \\n2 | 6 (2 operations + 4 operations)\\n3 | 12\\n4 | 20\\n...\\n\\nFrom the table we can derive the formula: (The index will be the distance to the middle element)\\n\\n*Minimum number of operations = middleIndex  * middleIndex + middleIndex*\\n\\n\\nIf `n` is 6, our array will be `1, 3, 5, 7, 9, 11` with **even** number of total elements\\n\\nWe need to add one operation to the minimum number of operations, because if we have even number of elements there will be two elements that are at the middle of the array. E.g. `5, 7`. One operation is required to make them the same.\\n\\nMiddle element is now `6`.\\n\\nFor `3` to reach 6, it will take `3` operations. (Distance from middle element is `1`) \\nFor `1` to reach 6 it will take `5` operations. (Distance from middle element is `2`)\\n\\nLikewise we can create the table:\\n\\nDistance to middle element | Number of Operations\\n1 | 3 \\n2 | 8 (3 operations + 5 operations)\\n3 | 15\\n4 | 24\\n...\\n\\n*Minimum number of operations = middleIndex  * (middleIndex + 1) + middleIndex + 1*\\n\\n\\n\\n\\n```\\npublic int MinOperations (int n) {\\n\\tint middleIndex = n / 2;\\n\\tif (n % 2 == 1) {\\n\\t\\t// if n is odd\\n\\t\\treturn middleIndex * middleIndex + middleIndex;\\n\\t}\\n\\n\\t// if n is even\\n\\tmiddleIndex -= 1;\\n\\treturn middleIndex * (middleIndex + 1) + middleIndex + 1;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int MinOperations (int n) {\\n\\tint middleIndex = n / 2;\\n\\tif (n % 2 == 1) {\\n\\t\\t// if n is odd\\n\\t\\treturn middleIndex * middleIndex + middleIndex;\\n\\t}\\n\\n\\t// if n is even\\n\\tmiddleIndex -= 1;\\n\\treturn middleIndex * (middleIndex + 1) + middleIndex + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794267,
                "title": "return-n-n-4-directly",
                "content": "We compute the sum of array: [2,6,10,...2n-2]. Use arithmetic progression to compute the sum. There are total n/2 elements in the array. So the sum is ((2+2n-2)*n/2)/2 = n*n/4.\\n```c++\\n    int minOperations(int n) {\\n        return n*n/4;\\n    }\\n```",
                "solutionTags": [],
                "code": "```c++\\n    int minOperations(int n) {\\n        return n*n/4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794187,
                "title": "simplest-1-line-o-1",
                "content": "```\\nreturn (n / 2) * (n / 2 + n % 2)\\n```",
                "solutionTags": [],
                "code": "```\\nreturn (n / 2) * (n / 2 + n % 2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794134,
                "title": "one-liner-c-code-beating-100",
                "content": "```\\nint minOperations(int n) {\\n        return n%2==0 ? (n/2)*(n/2): (n/2)*(n/2+1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(int n) {\\n        return n%2==0 ? (n/2)*(n/2): (n/2)*(n/2+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794131,
                "title": "simple-solution-no-array-required-o-n-java",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans =0;\\n        int avg = 0;\\n        int sum =0;\\n        \\n        for(int i=0; i<n; i++){\\n            sum+= (2 * i)+1;\\n        }\\n        \\n        avg = sum/n;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            int no = (2*i)+1;\\n            \\n            if( no < avg){\\n                ans+= (avg - no);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans =0;\\n        int avg = 0;\\n        int sum =0;\\n        \\n        for(int i=0; i<n; i++){\\n            sum+= (2 * i)+1;\\n        }\\n        \\n        avg = sum/n;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            int no = (2*i)+1;\\n            \\n            if( no < avg){\\n                ans+= (avg - no);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886434,
                "title": "very-easy-java-solution-100-beats-o-1-time-complexity",
                "content": "# Intuition\\njust observe the pattern\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int result = 0;\\n        \\n        if (n % 2 == 0) {\\n            result = (n / 2) * (n / 2);\\n        } else {\\n            result = ((n - 1) / 2) * ((n + 1) / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int result = 0;\\n        \\n        if (n % 2 == 0) {\\n            result = (n / 2) * (n / 2);\\n        } else {\\n            result = ((n - 1) / 2) * ((n + 1) / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791645,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> arr;\\n        for(int i=0; i<n; i++){\\n            arr.push_back((2*i)+1);\\n        }\\n\\n        int sum =0;\\n        for(int i=0; i<n/2; i++){\\n            sum+=(n-arr[i]);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> arr;\\n        for(int i=0; i<n; i++){\\n            arr.push_back((2*i)+1);\\n        }\\n\\n        int sum =0;\\n        for(int i=0; i<n/2; i++){\\n            sum+=(n-arr[i]);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676485,
                "title": "only-1-lines-c-beats-100",
                "content": "# if it Helps You, please Upvote me...! \\u2764 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very simple try to solve with pan and paper...!\\n\\n**Note:-to minimize the operations change all the elemetns to n by selecting first & last , first+1 & last-1......**\\n\\nEx:-\\n**odd Case:- n = 5 array = [1,3,5,7,9]**\\nchange all the elements to 5\\nselect arr[0] & arr[4]: operations:-5-1 = 9-5 = 4\\nselect arr[1] & arr[3]: operations:-5-3 = 7-5 = 2\\nselect arr[2] & arr[2]: operations:-5-5 = 5-5 = 0\\ntotal operations  = 4+2+0 = 6 = (1+3+(number of elements in AP, which is = 2))\\n\\n**even case:- n = 6 array = [1,3,5,7,9,11]**\\nchange all the elements to 6\\nselect arr[0] & arr[5]: operations:-6-1 = 11-6 = 5\\nselect arr[1] & arr[4]: operations:-6-3 = 9-6 = 3\\nselect arr[2] & arr[2]: operations:-6-5 = 7-6 = 1\\n\\ntotal operations  = 5+4+1 = 9 = (1+3+5)\\n\\n**Note:- AP : 1,3,5,7,9,......**\\n  **sum of AP = (N*N),  here N = number of elements in AP**\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n/2)*(n/2)+(n/2)*(n%2);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/90177435-eb95-4976-a21b-ece675774b28_1687597460.7219067.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n/2)*(n/2)+(n/2)*(n%2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659262,
                "title": "php",
                "content": "\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function minOperations($n) {\\n        $sum = 0;\\n        for($i = $n%2+1; $i < $n; $i = $i + 2){\\n            $sum+=$i;\\n        }\\n        return $sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function minOperations($n) {\\n        $sum = 0;\\n        for($i = $n%2+1; $i < $n; $i = $i + 2){\\n            $sum+=$i;\\n        }\\n        return $sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572931,
                "title": "easy-solution-js",
                "content": "*Happy learning!*\\n\\n---\\n\\n\\n# About the problem\\nYou have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n).\\n\\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\\n\\nGiven an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minOperations = function(n) {\\n    if(n%2==0) return n*n/4; //for even\\n    else return (n*n-1)/4; //for odd\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minOperations = function(n) {\\n    if(n%2==0) return n*n/4; //for even\\n    else return (n*n-1)/4; //for odd\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515363,
                "title": "super-easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            int x=(2 * i) + 1;\\n            ans+=n-x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            int x=(2 * i) + 1;\\n            ans+=n-x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365276,
                "title": "accepted-c-one-liner-solution-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n   \\n     \\n      // just write the series fro n=1 to n==6;\\n      //notice the mid elemnt is equal to n for every series\\n      // try to make every element equal to the mid element (which will be n)\\n      //and  that diffeerence will be a series of odd numbers\\n      //and calculate the sum of this series \\n       // and sum of m odd numbers is m*m \\n       \\n                 // if n is even then      //if n is odd\\n      \\n      return (n%2==0) ? (n/2)*(1ll)*(n/2) :  ((n/2)+1)*(1ll)*(n/2);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n   \\n     \\n      // just write the series fro n=1 to n==6;\\n      //notice the mid elemnt is equal to n for every series\\n      // try to make every element equal to the mid element (which will be n)\\n      //and  that diffeerence will be a series of odd numbers\\n      //and calculate the sum of this series \\n       // and sum of m odd numbers is m*m \\n       \\n                 // if n is even then      //if n is odd\\n      \\n      return (n%2==0) ? (n/2)*(1ll)*(n/2) :  ((n/2)+1)*(1ll)*(n/2);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365242,
                "title": "accepted-swift-one-liner-solution-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func minOperations(_ n: Int) -> Int {\\n        return n%2 == 0 ?  n/2*n/2 : n/2*(n/2+1)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperations(_ n: Int) -> Int {\\n        return n%2 == 0 ?  n/2*n/2 : n/2*(n/2+1)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347724,
                "title": "java-simple-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            arr[i] = (2*i)+1;\\n        }\\n        int start = 0, end = n-1, count = 0;\\n        int mid = (start+ end) >> 1;\\n        if(n % 2 != 0) { // Odd -->\\n            while(start < mid && end > mid) {\\n                while(arr[start] != arr[mid] && arr[end] != arr[mid]) {\\n                    arr[start] += 1;\\n                    arr[end] += 1;\\n                    count++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        } else {\\n            int midVal = (arr[mid] + arr[mid+1])/2;\\n            while(start <= mid && end > mid) {\\n                while(arr[start] != midVal && arr[end] != midVal) {\\n                    arr[start] += 1;\\n                    arr[end] += 1;\\n                    count++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            arr[i] = (2*i)+1;\\n        }\\n        int start = 0, end = n-1, count = 0;\\n        int mid = (start+ end) >> 1;\\n        if(n % 2 != 0) { // Odd -->\\n            while(start < mid && end > mid) {\\n                while(arr[start] != arr[mid] && arr[end] != arr[mid]) {\\n                    arr[start] += 1;\\n                    arr[end] += 1;\\n                    count++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        } else {\\n            int midVal = (arr[mid] + arr[mid+1])/2;\\n            while(start <= mid && end > mid) {\\n                while(arr[start] != midVal && arr[end] != midVal) {\\n                    arr[start] += 1;\\n                    arr[end] += 1;\\n                    count++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217266,
                "title": "beats-100-just-observe-the-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        \\n        int lim = n/2;\\n        int mid;\\n        if(n%2==0)\\n        {\\n            mid = 2*lim;\\n            res++;\\n        }\\n        else\\n        {\\n            mid = 2*lim+1;\\n        }\\n        for(int i=0;i<=lim;i++)\\n        {\\n            res+=(mid-(2*i+1));\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        \\n        int lim = n/2;\\n        int mid;\\n        if(n%2==0)\\n        {\\n            mid = 2*lim;\\n            res++;\\n        }\\n        else\\n        {\\n            mid = 2*lim+1;\\n        }\\n        for(int i=0;i<=lim;i++)\\n        {\\n            res+=(mid-(2*i+1));\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136813,
                "title": "easy-c-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nint minOperations(int n){\\nint  ans=0;\\nfor(int i=0;i<n/2;i++){\\n    ans+=n-(i*2+1);\\n}\\nreturn ans;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(int n){\\nint  ans=0;\\nfor(int i=0;i<n/2;i++){\\n    ans+=n-(i*2+1);\\n}\\nreturn ans;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082536,
                "title": "o-1-tc-o-1-sc-best-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) TC\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) SC\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int val=n/2;\\n        int rem=n-val;\\n\\n        return val*rem;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int val=n/2;\\n        int rem=n-val;\\n\\n        return val*rem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057828,
                "title": "0-ms-beats-100-c-code",
                "content": "# Idea\\n    For odd we increment in pairs of two\\n    For even first middle two and then the rest\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // Odd - 1 3 5 7 9\\n        // Even - 1 3 5 7 9 11\\n        return (n*n/(4));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // Odd - 1 3 5 7 9\\n        // Even - 1 3 5 7 9 11\\n        return (n*n/(4));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057092,
                "title": "o-n-time-o-1-space-efficient-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int>arr(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]=(2*i+1);\\n        }\\n        int mid=n/2;\\n        if(n%2!=0){\\n            int diff=0;\\n            for(int i=0;i<arr.size();i++){\\n                diff+=abs(arr[mid]-arr[i]);\\n            }\\n            return (diff/2);\\n        }\\n        else{\\n            int diff=0;\\n            for(int i=0;i<arr.size();i++){\\n                diff+=abs((arr[mid]-1)-arr[i]);\\n            }\\n            return (diff/2);\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int>arr(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]=(2*i+1);\\n        }\\n        int mid=n/2;\\n        if(n%2!=0){\\n            int diff=0;\\n            for(int i=0;i<arr.size();i++){\\n                diff+=abs(arr[mid]-arr[i]);\\n            }\\n            return (diff/2);\\n        }\\n        else{\\n            int diff=0;\\n            for(int i=0;i<arr.size();i++){\\n                diff+=abs((arr[mid]-1)-arr[i]);\\n            }\\n            return (diff/2);\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037421,
                "title": "easiest-simple-intiutive-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // Constructing a vector with the given formula\\n        vector<int>acha(n);\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            acha[i] = (2 * i) + 1;\\n            sum += acha[i];\\n        }\\n        int target = sum / n; // (provided hint \\uD83D\\uDE01)\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            //find steps required to make all elements equal to the target\\n            cnt += abs(target - acha[i]); \\n        }\\n        return cnt/2; //since in 1 step we can do 2 operations.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // Constructing a vector with the given formula\\n        vector<int>acha(n);\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            acha[i] = (2 * i) + 1;\\n            sum += acha[i];\\n        }\\n        int target = sum / n; // (provided hint \\uD83D\\uDE01)\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            //find steps required to make all elements equal to the target\\n            cnt += abs(target - acha[i]); \\n        }\\n        return cnt/2; //since in 1 step we can do 2 operations.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968464,
                "title": "simple-one-line-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter Performing the operations all elements of the array became eqaul to n so first calculate all operation required then devide it by 2(because in one operation we do both increment and decrement by one).\\n\\n# Approach\\n## <!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res=0;\\n        for(int i=0;i<n;i++)res+=abs(((n-((2*i)+1))));\\n        return (res)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res=0;\\n        for(int i=0;i<n;i++)res+=abs(((n-((2*i)+1))));\\n        return (res)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964500,
                "title": "c-1-line-o-1-solution-2-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For odd **n**, transform every array element to the middle element in the array.\\n- For even **n**, transform every array element to the everage of two middle elements in the array.\\n- Why this works? for every element in the first half of array that gets increamented by **x**, there is a corresponding element in the second half that needs to be decreamented by **x** for it to be equal to the final value.\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i+=2)\\n            ans += (n - i);\\n        return ans;\\n    }\\n};\\n//TC : O(n)\\n```\\n\\n- From this we can easily derive a mathematical formulae\\n- We are adding n (n/2) times\\n- From this subtract the sum of odd number uptill n.\\n- [Sum of all odd numbers uptill n](https://www.cuemath.com/algebra/sum-of-odd-numbers/) = pow((n/2),2) = (n/2)*(n/2)\\n- So, ans = n*(n/2) - (n/2)*(n/2)\\n- ans = (n*n)/4\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n*n)/4;\\n    }\\n};\\n//TC : O(1)\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i+=2)\\n            ans += (n - i);\\n        return ans;\\n    }\\n};\\n//TC : O(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n*n)/4;\\n    }\\n};\\n//TC : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832905,
                "title": "easy-java-o-1-solution",
                "content": "int c=0;\\n        if((n&1)==0){\\n             c=(int)(Math.pow(n/2,2));\\n        }\\n            else {\\n             n=(n-1)/2;\\n            c=(n)*(n+1);\\n        }\\n        return c;",
                "solutionTags": [],
                "code": "int c=0;\\n        if((n&1)==0){\\n             c=(int)(Math.pow(n/2,2));\\n        }\\n            else {\\n             n=(n-1)/2;\\n            c=(n)*(n+1);\\n        }\\n        return c;",
                "codeTag": "Unknown"
            },
            {
                "id": 2742512,
                "title": "easy-java-code-with-o-n-complexity",
                "content": "class Solution {\\n    public int minOperations(int n) {\\n        int[] arr= new int[n];\\n        int c=0,mid=(n-1)/2;\\n        for(int i=0;i<n;i++){\\n            arr[i]=(2*i)+1;\\n            if(arr[i]!=n && i<=mid){\\n                c=c+(n-arr[i]);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(int n) {\\n        int[] arr= new int[n];\\n        int c=0,mid=(n-1)/2;\\n        for(int i=0;i<n;i++){\\n            arr[i]=(2*i)+1;\\n            if(arr[i]!=n && i<=mid){\\n                c=c+(n-arr[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2715320,
                "title": "0ms-1-line-code",
                "content": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        return ((((2+(2*(n-1)))/2)*(n/2))-((2+(2*((n/2)-1)))*(n/2)/2));\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        return ((((2+(2*(n-1)))/2)*(n/2))-((2+(2*((n/2)-1)))*(n/2)/2));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2715306,
                "title": "c-easy-0ms-100-fast-solution",
                "content": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        long long c=(2+(2*(n-1)))/2;\\n        int t=n/2;\\n        long long s=(2+(2*(t-1)))*t/2;\\n        return int((c*t)-s);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n        long long c=(2+(2*(n-1)))/2;\\n        int t=n/2;\\n        long long s=(2+(2*(t-1)))*t/2;\\n        return int((c*t)-s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2623404,
                "title": "c-0ms-100-fast-easy-approach",
                "content": "**Please upvote if you find this helpful.**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        else{\\n            int last_num=2*n-1;\\n            int temp=last_num-n;\\n            while(temp>=0){\\n                ans+=temp;\\n                temp-=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n[Link to my submission](https://leetcode.com/submissions/detail/808350845/)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        else{\\n            int last_num=2*n-1;\\n            int temp=last_num-n;\\n            while(temp>=0){\\n                ans+=temp;\\n                temp-=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599580,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        s=t=0\\n        for i in range(1,n+1):\\n            if i%2!=0:\\n                s+=t\\n                t+=1\\n            else: \\n                s+=t\\n        return s\\n            \\n\\t\\t```\\n            \\t",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        s=t=0\\n        for i in range(1,n+1):\\n            if i%2!=0:\\n                s+=t\\n                t+=1\\n            else: \\n                s+=t\\n        return s\\n            \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2535746,
                "title": "c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int mid=n;\\n        int ans=0;\\n        int i=1;\\n        while(i<n){\\n            ans=ans+(mid-i);\\n            i=i+2;\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int mid=n;\\n        int ans=0;\\n        int i=1;\\n        while(i<n){\\n            ans=ans+(mid-i);\\n            i=i+2;\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513743,
                "title": "detailed-answer-python",
                "content": "**Input(n)->Output->(next element output-current element output)**\\n1\\u21920->1\\n2\\u21921->1\\n3\\u21922->2\\n4\\u21924->2\\n5\\u21926->3\\n6\\u21929->3\\n7\\u219212->4\\n8->16->4\\nBy seeing this pattern of the difference we can generate formulae.. \\ni.e. \\n**The formula is\\nn\\u2192\\u230An2\\u230B+1\\nwhere the notation \\u230Ax\\u230B means the greatest integer not exceeding x.**\\n\\nCode 1:\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        #Runtime:305ms\\n        sum1=0\\n        for i in range(n-1):\\n            sum1+=floor(i/2)+1\\n        return sum1 \\n```\\nCode 2: Optimizing the above code...!!\\n**By seeing more in pattern we can say that if n is divisible of 2 than the answer will be the square of (n//2) and if it not divisible by 2 than the answer will be n*(n+1) where n=n//2 **\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        #Runtime:46ms\\n        if(n%2!=0):\\n            n=n//2\\n            return n*(n+1)\\n        else:\\n            n=n//2\\n            return n**2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        #Runtime:305ms\\n        sum1=0\\n        for i in range(n-1):\\n            sum1+=floor(i/2)+1\\n        return sum1 \\n```\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        #Runtime:46ms\\n        if(n%2!=0):\\n            n=n//2\\n            return n*(n+1)\\n        else:\\n            n=n//2\\n            return n**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423911,
                "title": "c-1-line-code-logic-explained",
                "content": "![image](https://assets.leetcode.com/users/images/217c81cf-bc2a-4ca8-813f-dd62f3ac6caf_1660471263.3595095.png)\\n\\n**m==number of odd Integers between 1 and n.\\nT->O(m) && S->O(1)**\\n\\n***Logic-> Try to make all the numbers equal to the average of all.***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(int n) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=1;i<n;i+=2) count+=n-i;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(int n) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=1;i<n;i+=2) count+=n-i;\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2393128,
                "title": "java-simplest-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans = (n/2)*(n/2);\\n        if(n%2==1){\\n            ans += n/2;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(int n) {\\n        int ans = (n/2)*(n/2);\\n        if(n%2==1){\\n            ans += n/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2388489,
                "title": "5-lines-implementation-using-java",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int[] arr=new int[n];\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(2*i)+1;\\n        }\\n        return sum/4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int[] arr=new int[n];\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(2*i)+1;\\n        }\\n        return sum/4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363340,
                "title": "c-easy-question",
                "content": "```\\nint res=n/2;\\n        int mid1=(2*res)+1;\\n      \\n        int ans=0;\\n      \\n        if(n%2==1){\\n            for(int i=0;i<mid1;i++){\\n                if(i%2==0){\\n                    ans+=i;\\n                   \\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<mid1;i++){\\n                if(i%2!=0){\\n                    ans+=i;\\n                   // cout<<i<<\" \";\\n                }\\n            }\\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "```\\nint res=n/2;\\n        int mid1=(2*res)+1;\\n      \\n        int ans=0;\\n      \\n        if(n%2==1){\\n            for(int i=0;i<mid1;i++){\\n                if(i%2==0){\\n                    ans+=i;\\n                   \\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<mid1;i++){\\n                if(i%2!=0){\\n                    ans+=i;\\n                   // cout<<i<<\" \";\\n                }\\n            }\\n        }\\n        return ans;",
                "codeTag": "C++"
            },
            {
                "id": 2264983,
                "title": "python-and-c-solution-easy-to-understand-100-faster-one-liner",
                "content": "\\n# PYTHON SOLUTION\\n\\n       class Solution:\\n       def minOperations(self, n: int) -> int:\\n        res=0\\n        i=0\\n        while 2*i<n:\\n            res+=((2*(n-i-1)+1)-(2*i+1))//2\\n            i=i+1\\n        return res\\n\\n# C++ SOLUTION\\n    class Solution {\\n    public:\\n     int minOperations(int n) {\\n        int res=0;\\n        for(int i=0;i<n/2;i++){\\n            res+=((2*(n-i-1)+1)-(2*i+1))/2;\\n        }\\n        return res;\\n      }\\n     };\\n\\t \\n\\t \\n\\t** IF U FIND IT USEFUL THEN PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "class Solution:\\n       def minOperations(self, n: int) -> int:\\n        res=0\\n        i=0\\n        while 2*i<n:\\n            res+=((2*(n-i-1)+1)-(2*i+1))//2\\n            i=i+1\\n        return res\\n\\n# C++ SOLUTION\\n    class Solution {\\n    public:\\n     int minOperations(int n) {\\n        int res=0;\\n        for(int i=0;i<n/2;i++){\\n            res+=((2*(n-i-1)+1)-(2*i+1))/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2257324,
                "title": "minimum-operations-to-make-array-equal-mathematical-formula-faster-than-100-o-1",
                "content": "**Explanation**\\narray elements are (2*i+1) where i is index of element\\nfor eg: n = 6 array is [1,3,5,7,9,11]\\nto make all elements equal , it should be average or median of the elements\\nthe median element of array is 6 (basic median formula).\\n\\nSo, if we consider any array in this problem, the equal element is \"n\" itself.\\nWe have to all elements of array equal by subtracting 1 from one element and adding it to other element.\\nSo, we will add 1 to the elements which are less than \"n\" to make it n. Number of times the addition is performed to the elements will be the answer.\\n\\nfor n=6 [1,3,5,7,9,11]\\nadd 1 to 5 by subtracting 1 from 7  (1 time)   - 1 operation\\nadd 1 to 3 by subtracting 1 from 9  (3 times) - 3 operations\\nadd 1 to 1 by subtracting 1 from 11 (5 times) - 5 operations\\nSo total 9 operations.\\n\\nMathematically, \\nwe are making odd numbers less than \"n\" equal to n. (eg: 1,3,5 are changing to 6)\\nThere are floor(n/2) odd numbers less than n ( eg: 3 odd numbers less than 7)\\nSo no of operations are (6-1) + (6-3) + (6-5)\\n:= (6+6+6) - (1+3+5)\\n:= (3*6) - (1+3+5)\\n\\nSum of 1st n odd numbers is n^2.\\nHere we are finding sum of first (n/2) odd numbers = (n/2)^2.\\n\\nAnd also We are making first n/2 odd numbers as n . So n*(n/2).\\n\\nGeneralising above example\\n:= n*(n/2) - (n/2)*(n/2)\\n:= n*n(1/2 - 1/4)\\n:= (n*n)/4\\n\\nSo minimum number of operations is given by n*n/4.\\n\\n**C++ solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n*n)/4;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return (n*n)/4;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218298,
                "title": "2-python-self-understandable-solutions-slight-change-to-leetcode-462-i-e-minimum-moves-problem",
                "content": "NOTE : Both solutions are in O(n) time complexity and O(n) space complexity\\n\\n*The aim of this post is to showcase \"different\" types of approaches.*\\n\\n**Solution 1** :\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # Method 1 : Median\\n        nums = []\\n        for i in range(n):\\n            nums.append(2*i + 1)\\n        median_ish = nums[len(nums)//2]\\n        count = 0\\n        \\n        for i in nums:\\n            count += abs(i - median_ish)\\n        \\n        return count//2\\n        # we divided it by 2 because increment and decrement operation can be done\\n        # at the same time\\n```\\n\\n**Solution 2** :\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # Method 2 : Using concept of median i.e. minimize the number of moves\\n        nums = []\\n        for i in range(n):\\n            nums.append(2*i + 1)\\n        start, end = 0, len(nums)-1\\n        count = 0\\n        \\n        while(start < end):\\n            count += abs(nums[end] - nums[start])\\n            start += 1\\n            end -= 1\\n        \\n        return count//2\\n\\t\\t# we divided it by 2 because increment and decrement operation can be done\\n        # at the same time\\n  ```\\n*  Second approach explanantion :\\nSuppose we\\'ve an array [1,3,5,7,9]\\nResultant array would be suppose [x,x,x,x,x] where x could be any element such that it proposes the property of median (neither left skewdness nor right skewdness).\\n\\nNow, 1 + a = x = 9 - b\\nwhere, a and b denotes number to be subtracted/added in order to get desired element i.e x\\nSo, 1 + a = 9 - b\\n\\t  a + b = 8 i.e. subtract elements from extreme ends\\n\\t  \\nTherefore, to minimze the value of a+b (call it moves) , we\\'ve to first sort in increasing order and subtract elements at extreme ends and later, divided the number of moves by 2 because we are performing increment and decrement operation at the same time.\\n\\n\\n*That\\'s the main crux of 2nd approach.*\\n\\n**Thank You.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # Method 1 : Median\\n        nums = []\\n        for i in range(n):\\n            nums.append(2*i + 1)\\n        median_ish = nums[len(nums)//2]\\n        count = 0\\n        \\n        for i in nums:\\n            count += abs(i - median_ish)\\n        \\n        return count//2\\n        # we divided it by 2 because increment and decrement operation can be done\\n        # at the same time\\n```\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        # Method 2 : Using concept of median i.e. minimize the number of moves\\n        nums = []\\n        for i in range(n):\\n            nums.append(2*i + 1)\\n        start, end = 0, len(nums)-1\\n        count = 0\\n        \\n        while(start < end):\\n            count += abs(nums[end] - nums[start])\\n            start += 1\\n            end -= 1\\n        \\n        return count//2\\n\\t\\t# we divided it by 2 because increment and decrement operation can be done\\n        # at the same time\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2182774,
                "title": "o-1-time-o-1-space-100-fast-c-solution",
                "content": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n       \\n     \\n        return (n*n)/4;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(int n) {\\n       \\n     \\n        return (n*n)/4;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2170343,
                "title": "c-dp-solution-basic-pattern",
                "content": "You just have to notice a basic patten so that you can relate your ouput to previous outputs.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int dp[10001] = {0};\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        dp[3] = 2;\\n        \\n        for(int i = 4;i<=n;i++){\\n            if(i%2 == 0){\\n                dp[i] = dp[i-1]+ (i/2);\\n            }else{\\n                dp[i] = dp[i-2] + (i-1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int dp[10001] = {0};\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        dp[3] = 2;\\n        \\n        for(int i = 4;i<=n;i++){\\n            if(i%2 == 0){\\n                dp[i] = dp[i-1]+ (i/2);\\n            }else{\\n                dp[i] = dp[i-2] + (i-1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168515,
                "title": "simple-approach-without-recursion-and-constt-space",
                "content": "```\\n  int minOperations(int n) {\\n        int mid = (2*((n-1)/2))+1;\\n        int i = 0; int j=n-1;\\n        int ctr = 0;\\n        if(n%2==0){\\n            mid = mid+1;\\n            while(i<=(n-1)/2){\\n               ctr+=(mid-((2*i)+1));\\n            i++; \\n            }\\n            return ctr;\\n        }\\n        while(i<(n-1)/2){\\n            ctr+=(mid-((2*i)+1));\\n            i++;           \\n        }     \\n        return ctr;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int minOperations(int n) {\\n        int mid = (2*((n-1)/2))+1;\\n        int i = 0; int j=n-1;\\n        int ctr = 0;\\n        if(n%2==0){\\n            mid = mid+1;\\n            while(i<=(n-1)/2){\\n               ctr+=(mid-((2*i)+1));\\n            i++; \\n            }\\n            return ctr;\\n        }\\n        while(i<(n-1)/2){\\n            ctr+=(mid-((2*i)+1));\\n            i++;           \\n        }     \\n        return ctr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2159893,
                "title": "t-c-o-1-two-keyword-solution-just-return-n-n-4-mathematical-approach-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n*n/4;\\n    }\\n};\\n**If U Like it Please Upvote**\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return n*n/4;\\n    }\\n};\\n**If U Like it Please Upvote**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120004,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "```\\n\\n```def minOperations(self, n: int) -> int:\\n        \\n        arr = [None] * n        # create a list arr that has n number of None\\n        \\n        for i in range(n):      # iterate thorugh n, arr[i] = 2*i + 1\\n            arr[i] = 2*i + 1\\n        \\n        target = sum(arr) // n      # target is avg of sum(arr)\\n        \\n        sums = 0        # iterate through arr, only count the sums of difference between arr[i] and target throught the first len(arr)//2 numbers\\n        for i in range(len(arr)//2):\\n            sums += abs(arr[i]-target)\\n        \\n        return sums",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103616,
                "title": "easy-java-code",
                "content": "class Solution {\\n    public int minOperations(int n) {\\n         int sum=0;\\n        if(n%2!=0)\\n        {\\n            n=n-1;\\n            n=n/2;\\n            \\n            sum=((n+1)*n);\\n        }\\n        else if(n%2==0)\\n        {\\n            n=n/2;\\n            sum=(n*n);\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(int n) {\\n         int sum=0;\\n        if(n%2!=0)\\n        {\\n            n=n-1;\\n            n=n/2;\\n            \\n            sum=((n+1)*n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1952543,
                "title": "1-line-python-solution-90-faster-memory-less-than-97",
                "content": "### ***Solution (Math): TC O(1) / SC O(1)***\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return n**2//4\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        return n**2//4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944165,
                "title": "my-java-0ms",
                "content": "You just have to come up with a logic. Suppose we have [1,3,5] the element that the array gets changed to is 3, and if its [1,3,5,7] it would be 4. Technically it will be the median value(3 in case of [1,3,5] and (3+5)/2 in case of [1,3,5,7]). Similary in case of [1,3,5,7,11,13] it would be 6. On the whole , if we observe carefully the median value is nothing but the size of the array n. The number of operations would be the sum of values obtained by subtracting the median from right half of the array or subtracting the left half array from median. To understand you can do it by hand. \\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int median = n, sum = 0;\\n        while(2*n - 1 > median){\\n            sum += (2*n - 1) - median;\\n            n--;\\n        }\\n        return sum;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int median = n, sum = 0;\\n        while(2*n - 1 > median){\\n            sum += (2*n - 1) - median;\\n            n--;\\n        }\\n        return sum;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914827,
                "title": "1-liner-c-language-agnostic-more-or-less-with-detailed-explanation",
                "content": "I tried performing the operations at first, to understand the behaviour of the problem. I did so for array sizes ```n = 3, 4, 5, 6``` and there were a couple of conclusions:\\n* The final result, after performing the operations, is ```n``` itself.\\n* The number of steps it takes to *equalize* the array formed a sequence that looked like this for the first six values of ```n``` : ```0 1 2 4 6 9 12```.\\n\\n## Elaborating on the working\\nI\\'ll perform the operations for one even and one odd array size each, ```5``` and ```6```.\\nFor ```n = 5```, the array is ```1 3 5 7 9```. Tracing the result after each step:\\n* Step 1: ```2 3 5 7 8```, for ```y = 0``` and ```x = 4```.\\n* Step 2: ```3 3 5 7 7```, for ```y = 0``` and ```x = 4```.\\n* Step 3: ```4 3 5 7 6```, for ```y = 0``` and ```x = 4```.\\n* Step 4: ```4 4 5 6 6```, for ```y = 1``` and ```x = 3```.\\n* Step 5: ```5 4 5 5 6```, for ```y = 0``` and ```x = 3```.\\n* Step 6: ```5 5 5 5 5```, for ```y = 1``` and ```x = 4```.\\n\\nFor ```n = 6```, the array is ```1 3 5 7 9 11```. Tracing the result after each step:\\n* Step 1: ```2 3 5 7 9 10```, for ```y = 0``` and ```x = 5```.\\n* Step 2: ```3 3 5 7 9 9```, for ```y = 0``` and ```x = 5```.\\n* Step 3: ```4 3 5 7 9 8```, for ```y = 0``` and ```x = 5```.\\n* Step 4: ```4 4 5 7 8 8```, for ```y = 1``` and ```x = 4```.\\n* Step 5: ```4 4 6 6 8 8```, for ```y = 2``` and ```x = 3```.\\n* Step 6: ```5 4 6 6 8 7```, for ```y = 0``` and ```x = 5```.\\n* Step 7: ```5 5 6 6 7 7```, for ```y = 1``` and ```x = 4```.\\n* Step 8: ```6 5 6 6 6 7```, for ```y = 0``` and ```x = 4```.\\n* Step 9: ```6 6 6 6 6 6```, for ```y = 1``` and ```x = 5```.\\n\\nWe can derive many insights from here notwithstanding the fact that those aren\\'t needed for solving this problem.\\n\\n## Solving the problem\\nNote that one doesn\\'t need to chart out these steps and *count* them at the end to derive the aforementioned series. You can hack your way by simply feeding custom inputs and looking at the expected outputs, of course.\\n\\n*For the discussion below, note that `t_i `represents the ith term of the sequence.*\\n\\nIrrespective of the way you get the sequence ```0 1 2 4 6 9 12..```, the key step is to get the nth term of this sequence. That would wrap up the problem by itself. For this, you can use a very standard method that is demonstrated below.\\n\\nLet the series for the progression be **S**, which is nothing but the sum of the sequence.\\nThus, `S = 0 + 1 + 2 + 4 + 6 + 9 + 12 + ... + t_n`, where t_n is the nth term.\\nShift the series one place to the right and subtract it from the series above. To elucidate:\\n\\n```\\n  S = 0 + 1 + 2 + 4 + 6 + 9 + 12 + ... + t_n\\n- S =  -( 0 + 1 + 2 + 4 + 6 + 9 +  ...  + t_(n-1) + t_n) \\n```\\n\\nThus, we get:\\n```\\n0 = 0 + 1 + 1 + 2 + 2 + 3 + 3 + ... + t_n - t_(n-1) - t_n\\n```\\nThis can be rewritten as:\\n```\\nt_n = 0 + 1 + 1 + 2 + 2 + 3 + 3 + ... + t_n - t_(n-1)\\n```\\nWhich is the same as:\\n``` t_n = 0 + 2(1 + 2 + 3 + ... )``` for (n-1)/2 terms\\n\\nThe part enclosed in parentheses is the [sum of first k natural numbers](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF), which is for `k = (n-1) terms` in this case. Thus,\\n```\\nt_n = 0 + 2((n-1)/2)((n+1)/2)/2\\n```\\nWhich is the same as:\\n```\\nt_n = (n*n - 1)/4\\n```\\n\\nThe formula works seamlessly for odd values of `n`. However, to ensure that the formula returns an integral result for even values of `n`, we need to round up the calculated result. A [ceil](https://www.cplusplus.com/reference/cmath/ceil/) function or its equivalent works well.\\n\\n### Code in C++\\n```\\nint minOperations(int n) {\\n        return ceil((n*n - 1)/4.0);\\n    }\\n```\\nTo ensure that the argument passed to the ceil function is a double type, we must prevent [integer division](https://stackoverflow.com/questions/3602827/what-is-the-behavior-of-integer-division), which will lead to an incorrect answer. I wrote 4 as 4.0 for achieving that end.\\n\\nThe solution had beaten 100% submissions in runtime, in my case.\\nThe time and space complexities are `O(1)` for this solution.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```n = 3, 4, 5, 6```\n```n```\n```n```\n```0 1 2 4 6 9 12```\n```5```\n```6```\n```n = 5```\n```1 3 5 7 9```\n```2 3 5 7 8```\n```y = 0```\n```x = 4```\n```3 3 5 7 7```\n```y = 0```\n```x = 4```\n```4 3 5 7 6```\n```y = 0```\n```x = 4```\n```4 4 5 6 6```\n```y = 1```\n```x = 3```\n```5 4 5 5 6```\n```y = 0```\n```x = 3```\n```5 5 5 5 5```\n```y = 1```\n```x = 4```\n```n = 6```\n```1 3 5 7 9 11```\n```2 3 5 7 9 10```\n```y = 0```\n```x = 5```\n```3 3 5 7 9 9```\n```y = 0```\n```x = 5```\n```4 3 5 7 9 8```\n```y = 0```\n```x = 5```\n```4 4 5 7 8 8```\n```y = 1```\n```x = 4```\n```4 4 6 6 8 8```\n```y = 2```\n```x = 3```\n```5 4 6 6 8 7```\n```y = 0```\n```x = 5```\n```5 5 6 6 7 7```\n```y = 1```\n```x = 4```\n```6 5 6 6 6 7```\n```y = 0```\n```x = 4```\n```6 6 6 6 6 6```\n```y = 1```\n```x = 5```\n```0 1 2 4 6 9 12..```\n```\\n  S = 0 + 1 + 2 + 4 + 6 + 9 + 12 + ... + t_n\\n- S =  -( 0 + 1 + 2 + 4 + 6 + 9 +  ...  + t_(n-1) + t_n) \\n```\n```\\n0 = 0 + 1 + 1 + 2 + 2 + 3 + 3 + ... + t_n - t_(n-1) - t_n\\n```\n```\\nt_n = 0 + 1 + 1 + 2 + 2 + 3 + 3 + ... + t_n - t_(n-1)\\n```\n``` t_n = 0 + 2(1 + 2 + 3 + ... )```\n```\\nt_n = 0 + 2((n-1)/2)((n+1)/2)/2\\n```\n```\\nt_n = (n*n - 1)/4\\n```\n```\\nint minOperations(int n) {\\n        return ceil((n*n - 1)/4.0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884171,
                "title": "java-0ms-simple-easiest-approach",
                "content": "```\\n\\t  int sum = 0;\\n      int x = n-1;\\n      while(x > 0)\\n      {\\n        sum += x;\\n        x -= 2;\\n      }\\n      return sum;\\n```\\nPlease UpVote if it helps you in any way...\\nComment if have any doubt !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t  int sum = 0;\\n      int x = n-1;\\n      while(x > 0)\\n      {\\n        sum += x;\\n        x -= 2;\\n      }\\n      return sum;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574291,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            },
            {
                "id": 1851418,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            },
            {
                "id": 1807269,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            },
            {
                "id": 1782170,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            },
            {
                "id": 1764279,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            },
            {
                "id": 1575224,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            },
            {
                "id": 2038035,
                "content": [
                    {
                        "username": "sachinmewar",
                        "content": "If you multiply n * n and then divide it by 4. You will find out that the solution does not depends whether n is even or odd.\\nYou will get the correct answer.\\n\\nYou have to simply return  ( n * n ) /4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain how it would work?"
                    },
                    {
                        "username": "Msey",
                        "content": "I cant get a point of solving the pure math problems and throw off the programming and analysys skills at all. Put here another probability theory problem or related to chemistry one and call it medium/hard lol."
                    },
                    {
                        "username": "dopingcode",
                        "content": "the frustration \\uD83D\\uDE02"
                    },
                    {
                        "username": "15o1",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please someone explain me how just one line of code: return (n*n)/4 works????"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@pushp_raj](/pushp_raj) Great explanation, thank you"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mathematics"
                    },
                    {
                        "username": "sarthi_",
                        "content": "How??"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "return (n*n)/4;"
                    },
                    {
                        "username": "pushp_raj",
                        "content": "[@sohanurrahman](/sohanurrahman)  The obvious thing here is that the array formed by the instructions is a linear progression. Mathematically, it should also be obvious that the value to which we need to make each element of our array is the same value found at the middle of the array.\\n\\nIf we were to follow the literal instructions, we could move outward from the middle point and repeatedly shift 1 from the right (higher) side to the left (lower) side. This process would lead to a triangular number of operations, modified by the fact that each value starts off 2 less/more than the ones on either side, rather than 1.\\n\\nTake, for example, the case of n = 7, or [1,3,5,7,9,11,13]. We would perform the operation twice on the 5 & 9 pair, four times on the 3 & 11 pair, and six times on the 1 & 13 pair, bringing all values to the median of 7 with a total of 12 operations.\\n\\nThe sum of linearly increasing numbers is the very definition of a triangular number, which is in this case doubled because the numbers are 2 apart, rather than 1. The standard formula for a triangular number is n * (n + 1) / 2. Since our triangular number is only half the length of array, not counting the middle, that equates to 2 * ((n - 1) / 2) * ((n - 1) / 2 + 1) / 2, which simplifies to (n^2 - 1) / 4.\\n\\nBut that\\'s when n is odd and the middle is conveniently a point. What if n is even?\\n\\nIf n is even, then it becomes a slightly different formula, with the midpoint being halfway between the two middle points (which is incidentally why the problem specified a 2 value difference in each array element, to prevent impossible fractions). In this case, we\\'re doing the same process, only on (n - 2) / 2 elements rather than (n - 1) / 2 elements, omitting the two \"middle\" elements.\\n\\nThis will leave the entire left side of the array equal to the left-middle element, and the entire right side of the array equal to the right-middle element. In order to even the entire array, we\\'ll just need another n / 2 operations to move the right side down 1 and the left side up 1.\\n\\nThat formula becomes 2 * ((n - 2) / 2) * ((n - 2) / 2 + 1) / 2 + n / 2, which simplifies nicely down to n^2 / 4.\\n\\nThus the only difference between the two formulas is the - 1 present in the odd version, which is basically the rounding error if n is odd, and can be corrected by flooring (or double bitwise NOT\\'ing) the result.\\n\\nOn a more intuitive note, if you think of the array as points forming a line on a graph, then you can think of that line as the diagonal of a box of area n * 2n, or 2n^2. If you then think of the triangle of moves that have to be made, you can note that the area of said triangle is 1/8th the area of the box, or 2n^2 / 8, or n^2 / 4"
                    },
                    {
                        "username": "sohanurrahman",
                        "content": "can you please explain the logic behind it?"
                    },
                    {
                        "username": "laosunhust",
                        "content": "`return int((n*n-n%2)/4)`"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I am unable to find O(1) approach but I can sense it."
                    }
                ]
            }
        ]
    }
]