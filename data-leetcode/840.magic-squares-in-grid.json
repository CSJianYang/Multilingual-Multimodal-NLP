[
    {
        "title": "Magic Squares In Grid",
        "question_content": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col&nbsp;grid&nbsp;of integers, how many 3 x 3 \"magic square\" subgrids are there?&nbsp; (Each subgrid is contiguous).\n&nbsp;\nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\nwhile this one is not:\nIn total, there is only one magic square inside the given grid.\n\nExample 2:\n\nInput: grid = [[8]]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 10\n\t0 <= grid[i][j] <= 15",
        "solutions": [
            {
                "id": 133874,
                "title": "python-5-and-43816729",
                "content": "The intuition is brute force, don\\'t need any tricky. \\nOne thing to pay attention: A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from **1 to 9**.\\nI just find many sumbmission ignoring this condition. \\n\\nHere I just want share two observatons with this **1-9** condition:\\n\\nAssume a magic square:\\na1,a2,a3\\na4,a5,a6\\na7,a8,a9\\n\\n`a2 + a5 + a8 = 15`\\n`a4 + a5 + a6 = 15`\\n`a1 + a5 + a9 = 15`\\n`a3 + a5 + a7 = 15`\\n\\nAccumulate all, then we have:\\n`sum(ai) + 3 * a5 = 60`\\n`3 * a5 = 15`\\n`a5 = 5`\\n\\nThe center of magic square must be 5.\\n\\nAnother observation for other 8 numbers:\\nThe even must be in the corner, and the odd must be on the edge.\\nAnd it must be in a order like \"43816729\" \\uFF08clockwise or anticlockwise)\\n\\n```\\n    def numMagicSquaresInside(self, g):\\n        def isMagic(i, j):\\n            s = \"\".join(str(g[i + x / 3][j + x % 3]) for x in [0, 1, 2, 5, 8, 7, 6, 3])\\n            return g[i][j] % 2 == 0 and (s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2)\\n        return sum(isMagic(i, j) for i in range(len(g) - 2) for j in range(len(g[0]) - 2) if g[i + 1][j + 1] == 5)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def numMagicSquaresInside(self, g):\\n        def isMagic(i, j):\\n            s = \"\".join(str(g[i + x / 3][j + x % 3]) for x in [0, 1, 2, 5, 8, 7, 6, 3])\\n            return g[i][j] % 2 == 0 and (s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2)\\n        return sum(isMagic(i, j) for i in range(len(g) - 2) for j in range(len(g[0]) - 2) if g[i + 1][j + 1] == 5)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133861,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, result = 0;\\n        for (int i = 0; i < m - 2; i++) {\\n            for (int j = 0; j < n - 2; j++) {\\n                if (isMagic(grid, i, j)) {\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isMagic(int[][] grid, int row, int col) {\\n        int[] record = new int[10];\\n        for (int i = row; i < row + 3; i++) {\\n            for (int j = col; j < col + 3; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9 || record[grid[i][j]] > 0) {\\n                    return false;\\n                }\\n                record[grid[i][j]] = 1;\\n            }\\n        }\\n        int sum1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int sum2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        if (sum1 != sum2) {\\n            return false;\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            if (grid[row + i][col] + grid[row + i][col + 1] + grid[row + i][col + 2] != sum1) {\\n                return false;\\n            }\\n            if (grid[row][col + i] + grid[row + 1][col + i] + grid[row + 2][col + i] != sum1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, result = 0;\\n        for (int i = 0; i < m - 2; i++) {\\n            for (int j = 0; j < n - 2; j++) {\\n                if (isMagic(grid, i, j)) {\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isMagic(int[][] grid, int row, int col) {\\n        int[] record = new int[10];\\n        for (int i = row; i < row + 3; i++) {\\n            for (int j = col; j < col + 3; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9 || record[grid[i][j]] > 0) {\\n                    return false;\\n                }\\n                record[grid[i][j]] = 1;\\n            }\\n        }\\n        int sum1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int sum2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        if (sum1 != sum2) {\\n            return false;\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            if (grid[row + i][col] + grid[row + i][col + 1] + grid[row + i][col + 2] != sum1) {\\n                return false;\\n            }\\n            if (grid[row][col + i] + grid[row + 1][col + i] + grid[row + 2][col + i] != sum1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208894,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133938,
                "title": "java-8-ms-straightforward-ugly-solution",
                "content": "The center of the square must be 5.\\nAnd I judge whether         **1.** the square contains number 1~9.        **2.** the four sides and two diagonal lines all equal to 15. \\nUgly and straightforward solution.\\n```\\npublic int numMagicSquaresInside(int[][] grid) {\\n        int cnt=0;\\n        for(int i=0;i<=grid.length-3;i++)\\n            for(int j=0;j<=grid[0].length-3;j++)\\n                if(helper(i,j,grid)) cnt++;\\n            \\n        return cnt;\\n    }  \\n    \\n    private boolean helper(int x,int y,int[][] grid){\\n        if(grid[x+1][y+1]!=5) return false;\\n        \\n        int[] valid=new int[16];\\n        \\n        for(int i=x;i<=x+2;i++)\\n            for(int j=y;j<=y+2;j++)\\n                valid[grid[i][j]]++;\\n            \\n        for (int v = 1; v <= 9; v++)\\n            if (valid[v] != 1) return false;\\n        \\n        if((grid[x][y]+grid[x][y+1]+grid[x][y+2])!=15)         return false;\\n        if((grid[x][y]+grid[x+1][y+1]+grid[x+2][y+2])!=15)     return false;\\n        if((grid[x][y]+grid[x+1][y]+grid[x+2][y])!=15)         return false;\\n        if((grid[x+2][y]+grid[x+2][y+1]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+2]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+1]+grid[x+2][y])!=15)     return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numMagicSquaresInside(int[][] grid) {\\n        int cnt=0;\\n        for(int i=0;i<=grid.length-3;i++)\\n            for(int j=0;j<=grid[0].length-3;j++)\\n                if(helper(i,j,grid)) cnt++;\\n            \\n        return cnt;\\n    }  \\n    \\n    private boolean helper(int x,int y,int[][] grid){\\n        if(grid[x+1][y+1]!=5) return false;\\n        \\n        int[] valid=new int[16];\\n        \\n        for(int i=x;i<=x+2;i++)\\n            for(int j=y;j<=y+2;j++)\\n                valid[grid[i][j]]++;\\n            \\n        for (int v = 1; v <= 9; v++)\\n            if (valid[v] != 1) return false;\\n        \\n        if((grid[x][y]+grid[x][y+1]+grid[x][y+2])!=15)         return false;\\n        if((grid[x][y]+grid[x+1][y+1]+grid[x+2][y+2])!=15)     return false;\\n        if((grid[x][y]+grid[x+1][y]+grid[x+2][y])!=15)         return false;\\n        if((grid[x+2][y]+grid[x+2][y+1]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+2]+grid[x+2][y+2])!=15)   return false;\\n        if((grid[x][y+2]+grid[x+1][y+1]+grid[x+2][y])!=15)     return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390880,
                "title": "java-100-both",
                "content": "Skipping the part on sliding the window, the key idea is to work in the understanding of the \\npossibilities you can have with 9 **different** digits form **1 to 9** *(like a sudoku box)* in the same 3x3 matrix giving you only limited possible outcomes.\\nIf you try to put an element different form 5 in the center you will never be able to have a magicBox, so 5 must be at the center.\\nNow if you try to put **odd** numbers in the corners you can never menage to find a way to obtain all diagonal values equal, forcing you to put these values between angles.\\nTo end this you can discover after some attempt that the only way to have equal sum is only with a sum equal to 15, so you have only to check if the rows and columns sum to 15 ( the diagonals are granted from the Even/Odd checks), you can avoid checking 1 column or row because if the other sums to 15 they imply that the last one does it as well.\\n\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133857,
                "title": "why-is-this-test-case-yielding-0",
                "content": "My submission failed on this: ```[[10,3,5],[1,6,11],[7,9,2]]```\\nIt says expected result is 0, but clearly you can do it by hand that the sum is 18 for all cases",
                "solutionTags": [],
                "code": "```[[10,3,5],[1,6,11],[7,9,2]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 754816,
                "title": "c-4-ms-solution-complete-brute-force-easy-to-understand",
                "content": "***Runtime: 4 ms, faster than 92.34% of C++ online submissions for Magic Squares In Grid.\\nMemory Usage: 8.3 MB, less than 96.49% of C++ online submissions for Magic Squares In Grid.***\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194689,
                "title": "100-simple-c-solution",
                "content": "Here is a simple C++ Solution which beats 100% - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool chk(vector<vector<int>>& grid, int m, int n) {\\n        \\n        if (m + 3 > grid.size())\\n            return false;\\n        \\n        if (n + 3 > grid[m].size())\\n            return false;\\n        \\n        vector<bool> v (10, false);\\n        \\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                v[grid[i][j]] = true;\\n            }\\n        }\\n        \\n        int sum = grid[m][n] + grid[m+1][n+1] + grid[m+2][n+2];\\n        \\n        if (sum != grid[m][n+2] + grid[m+1][n+1] + grid[m+2][n])\\n            return false;\\n        \\n        \\n        for (int i = m; i < m + 3; i++) {\\n            if (grid[i][n] + grid[i][n+1] + grid[i][n+2] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = n; i < n + 3; i++) {\\n            if (grid[m][i] + grid[m+1][i] + grid[m+2][i] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            if (!v[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    } \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (chk(grid, i, j))\\n                    cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\nThanks",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool chk(vector<vector<int>>& grid, int m, int n) {\\n        \\n        if (m + 3 > grid.size())\\n            return false;\\n        \\n        if (n + 3 > grid[m].size())\\n            return false;\\n        \\n        vector<bool> v (10, false);\\n        \\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                v[grid[i][j]] = true;\\n            }\\n        }\\n        \\n        int sum = grid[m][n] + grid[m+1][n+1] + grid[m+2][n+2];\\n        \\n        if (sum != grid[m][n+2] + grid[m+1][n+1] + grid[m+2][n])\\n            return false;\\n        \\n        \\n        for (int i = m; i < m + 3; i++) {\\n            if (grid[i][n] + grid[i][n+1] + grid[i][n+2] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = n; i < n + 3; i++) {\\n            if (grid[m][i] + grid[m+1][i] + grid[m+2][i] != sum)\\n                return false;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            if (!v[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    } \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (chk(grid, i, j))\\n                    cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514157,
                "title": "javascript-solution-44ms-runtime",
                "content": "There are only a [small number of possible magic squares](https://oeis.org/A217568).\\n\\nRuntime: 44 ms, faster than 100.00% of JavaScript online submissions\\nMemory Usage: 35.2 MB, less than 100.00% of JavaScript online submissions\\n\\n```javascript\\nconst numMagicSquaresInside = grid => {\\n  const magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n  let cnt = 0;\\n  for (let i = 0; i < grid.length - 2; i++)\\n    for (let j = 0; j < grid[0].length - 2; j++)\\n      if (\\n        magicSquares.has(\\n          grid[i][j].toString() +\\n            grid[i][j + 1] +\\n            grid[i][j + 2] +\\n            grid[i + 1][j] +\\n            grid[i + 1][j + 1] +\\n            grid[i + 1][j + 2] +\\n            grid[i + 2][j] +\\n            grid[i + 2][j + 1] +\\n            grid[i + 2][j + 2],\\n        )\\n      )\\n        cnt++;\\n  return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```javascript\\nconst numMagicSquaresInside = grid => {\\n  const magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n  let cnt = 0;\\n  for (let i = 0; i < grid.length - 2; i++)\\n    for (let j = 0; j < grid[0].length - 2; j++)\\n      if (\\n        magicSquares.has(\\n          grid[i][j].toString() +\\n            grid[i][j + 1] +\\n            grid[i][j + 2] +\\n            grid[i + 1][j] +\\n            grid[i + 1][j + 1] +\\n            grid[i + 1][j + 2] +\\n            grid[i + 2][j] +\\n            grid[i + 2][j + 1] +\\n            grid[i + 2][j + 2],\\n        )\\n      )\\n        cnt++;\\n  return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181724,
                "title": "java-brute-force-math-beats-100-0ms-t-c-o-r-c",
                "content": "\\n    // O(m*n)\\n\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\tint m = grid.length, n = grid[0].length, ans = 0;\\n\\t\\tfor (int i = 0; i <= m - 3; i++) {\\n\\t\\t\\tfor (int j = 0; j <= n - 3; j++) {\\n\\t\\t\\t\\tif (grid[i + 1][j + 1] != 5)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tboolean flag = isMagicSquare(grid, i, j);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic boolean isMagicSquare(int[][] grid, int top, int left) {\\n\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tfor (int i = 0; i <= 2; i++) {\\n\\t\\t\\tfor (int j = 0; j <= 2; j++) {\\n\\t\\t\\t\\tif (grid[top + i][left + j] >= 10)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tmap[grid[top + i][left + j]] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn (grid[top][left] + grid[top][left + 1] + grid[top][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 1][left] + grid[top + 1][left + 1] + grid[top + 1][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 2][left] + grid[top + 2][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left] + grid[top + 2][left] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 1] + grid[top + 1][left + 1] + grid[top + 2][left + 1] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 2] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 1] + grid[top + 2][left] == 15);\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(m*n)\\n\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\tint m = grid.length, n = grid[0].length, ans = 0;\\n\\t\\tfor (int i = 0; i <= m - 3; i++) {\\n\\t\\t\\tfor (int j = 0; j <= n - 3; j++) {\\n\\t\\t\\t\\tif (grid[i + 1][j + 1] != 5)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tboolean flag = isMagicSquare(grid, i, j);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic boolean isMagicSquare(int[][] grid, int top, int left) {\\n\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tfor (int i = 0; i <= 2; i++) {\\n\\t\\t\\tfor (int j = 0; j <= 2; j++) {\\n\\t\\t\\t\\tif (grid[top + i][left + j] >= 10)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tmap[grid[top + i][left + j]] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn (grid[top][left] + grid[top][left + 1] + grid[top][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 1][left] + grid[top + 1][left + 1] + grid[top + 1][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top + 2][left] + grid[top + 2][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left] + grid[top + 2][left] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 1] + grid[top + 1][left + 1] + grid[top + 2][left + 1] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 2] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left] + grid[top + 1][left + 1] + grid[top + 2][left + 2] == 15)\\n\\t\\t\\t\\t&& (grid[top][left + 2] + grid[top + 1][left + 1] + grid[top + 2][left] == 15);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 581967,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows < 3 || cols < 3) return 0;\\n        int count = 0;\\n        for (int i=0;i<rows-2;i++) {\\n            for (int j=0;j<cols-2;j++) {\\n                if(isMagicGrid(grid,i, j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    public boolean isMagicGrid(int[][] grid,int rowStart,int colStart) {\\n        int diagonalsSum = 0;\\n\\t\\tint antiDiagonalSum = 0;\\n        int[] rowsSum = new int[3];\\n        int[] colsSum = new int[3];\\n        int[] numbers = new int[9];\\n        for (int i = rowStart,row =0; i < rowStart + 3; i++,row++) {\\n            for (int j = colStart,col=0; j < colStart + 3; j++,col++) {\\n                if(grid[i][j] > 9 || grid[i][j] < 1) return false;\\n                rowsSum[i%3] += grid[i][j];\\n                colsSum[j%3] += grid[i][j];\\n                if(numbers[grid[i][j]-1] == 0) {\\n                    numbers[grid[i][j]-1]++;\\n                } else {\\n                    return false;\\n                }\\n                if (row == col) diagonalsSum += grid[i][j];\\n                if ((3 - row - 1) == col) antiDiagonalSum += grid[i][j];\\n            }\\n        }\\n        if(diagonalsSum != antiDiagonalSum) return false;\\n        boolean isRowsEqual = rowsSum[0] == rowsSum[1]  && rowsSum[1] == rowsSum[2];\\n        boolean isColsEqual = colsSum[0] == colsSum[1]  && colsSum[1] == colsSum[2];\\n        return isRowsEqual && isColsEqual;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows < 3 || cols < 3) return 0;\\n        int count = 0;\\n        for (int i=0;i<rows-2;i++) {\\n            for (int j=0;j<cols-2;j++) {\\n                if(isMagicGrid(grid,i, j)) count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2330775,
                "title": "c-brute-force",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i+2<grid.size();i++)\\n        {\\n            for(int j=0;j+2<grid[0].size();j++)\\n            {\\n                res+=fun(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j)\\n    {\\n        vector<int> v(16,0);\\n        for(int x=i;x<i+3;x++)\\n        {\\n            for(int y=j;y<j+3;y++)\\n            {\\n                v[grid[x][y]]=1;\\n            }\\n        }\\n        for(int x=1;x<10;x++)\\n        {\\n            if(!v[x])\\n                return 0;\\n        }\\n        int sum=0,t=0;\\n        int p=i,q=j;\\n        for(int k=0;k<3;k++)\\n        {\\n            sum+=grid[p][q];\\n            p++;\\n            q++;\\n        }\\n        p=i,q=j+2;\\n        for(int k=0;k<3;k++)\\n        {\\n            t+=grid[p][q];\\n            p++;\\n            q--;\\n        }\\n        if(t!=sum)\\n            return 0;\\n        \\n        for(int x=i;x<i+3;x++)\\n        {\\n            t=0;\\n            for(int y=j;y<j+3;y++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        for(int y=j;y<j+3;y++)\\n        {\\n            t=0;\\n            for(int x=i;x<i+3;x++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i+2<grid.size();i++)\\n        {\\n            for(int j=0;j+2<grid[0].size();j++)\\n            {\\n                res+=fun(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j)\\n    {\\n        vector<int> v(16,0);\\n        for(int x=i;x<i+3;x++)\\n        {\\n            for(int y=j;y<j+3;y++)\\n            {\\n                v[grid[x][y]]=1;\\n            }\\n        }\\n        for(int x=1;x<10;x++)\\n        {\\n            if(!v[x])\\n                return 0;\\n        }\\n        int sum=0,t=0;\\n        int p=i,q=j;\\n        for(int k=0;k<3;k++)\\n        {\\n            sum+=grid[p][q];\\n            p++;\\n            q++;\\n        }\\n        p=i,q=j+2;\\n        for(int k=0;k<3;k++)\\n        {\\n            t+=grid[p][q];\\n            p++;\\n            q--;\\n        }\\n        if(t!=sum)\\n            return 0;\\n        \\n        for(int x=i;x<i+3;x++)\\n        {\\n            t=0;\\n            for(int y=j;y<j+3;y++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        for(int y=j;y<j+3;y++)\\n        {\\n            t=0;\\n            for(int x=i;x<i+3;x++)\\n            {\\n                t+=grid[x][y];\\n            }\\n            if(t!=sum)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409821,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int row, int col){\\n        return hasDistinctNumbers(grid, row, col) && rowSumEqual(grid, row, col) && colSumEqual(grid, row, col) && diagSumEqual(grid, row, col);\\n    }\\n    \\n    public boolean rowSumEqual(int[][] grid, int row, int col){\\n        int rs1 = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n        int rs2 = grid[row + 1][col] + grid[row + 1][col + 1] + grid[row + 1][col + 2];\\n        int rs3 = grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n        return rs1 == rs2 && rs2 == rs3;\\n    }\\n    \\n    public boolean colSumEqual(int[][] grid, int row, int col){\\n        int cs1 = grid[row][col] + grid[row + 1][col] + grid[row + 2][col];\\n        int cs2 = grid[row][col + 1] + grid[row + 1][col + 1] + grid[row + 2][col + 1];\\n        int cs3 = grid[row][col + 2] + grid[row + 1][col + 2] + grid[row + 2][col + 2];\\n        return cs1 == cs2 && cs2 == cs3;\\n    }\\n    \\n    public boolean diagSumEqual(int[][] grid, int row, int col){\\n        int rds1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int rds2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        return rds1 == rds2;\\n    }\\n    \\n    public boolean hasDistinctNumbers(int[][] grid, int row, int col){\\n        boolean[] nums = new boolean[10];\\n        for(int i = row; i < row + 3; i++){\\n            for(int j = col; j < col + 3; j++){\\n                if(grid[i][j] == 0 || grid[i][j] > 9 || nums[grid[i][j]]){\\n                    return false;\\n                }\\n                else{\\n                    nums[grid[i][j]] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int row, int col){\\n        return hasDistinctNumbers(grid, row, col) && rowSumEqual(grid, row, col) && colSumEqual(grid, row, col) && diagSumEqual(grid, row, col);\\n    }\\n    \\n    public boolean rowSumEqual(int[][] grid, int row, int col){\\n        int rs1 = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n        int rs2 = grid[row + 1][col] + grid[row + 1][col + 1] + grid[row + 1][col + 2];\\n        int rs3 = grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n        return rs1 == rs2 && rs2 == rs3;\\n    }\\n    \\n    public boolean colSumEqual(int[][] grid, int row, int col){\\n        int cs1 = grid[row][col] + grid[row + 1][col] + grid[row + 2][col];\\n        int cs2 = grid[row][col + 1] + grid[row + 1][col + 1] + grid[row + 2][col + 1];\\n        int cs3 = grid[row][col + 2] + grid[row + 1][col + 2] + grid[row + 2][col + 2];\\n        return cs1 == cs2 && cs2 == cs3;\\n    }\\n    \\n    public boolean diagSumEqual(int[][] grid, int row, int col){\\n        int rds1 = grid[row][col] + grid[row + 1][col + 1] + grid[row + 2][col + 2];\\n        int rds2 = grid[row][col + 2] + grid[row + 1][col + 1] + grid[row + 2][col];\\n        return rds1 == rds2;\\n    }\\n    \\n    public boolean hasDistinctNumbers(int[][] grid, int row, int col){\\n        boolean[] nums = new boolean[10];\\n        for(int i = row; i < row + 3; i++){\\n            for(int j = col; j < col + 3; j++){\\n                if(grid[i][j] == 0 || grid[i][j] > 9 || nums[grid[i][j]]){\\n                    return false;\\n                }\\n                else{\\n                    nums[grid[i][j]] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290240,
                "title": "java-0ms-solution",
                "content": "**Explanation:**\\nA magic sqaure is always size 3 x 3, and having distinct numbers 1-9 in each slot.\\n```\\na b c\\nd e f\\ng h i\\n```\\nAnd, according to the definition of a magic square:\\n```\\nsum(a,b,c,d,e,f,g,h,i) = sum(1,2,3,4,5,6,7,8,9) = 45\\n```\\nThus, we can conclude that\\n```\\nrows: sum(a,b,c) = sum(d,e,f) = sum(g,h,i) = 15 (sum of each row to be 15)\\ncols: sum(a,d,g) = sum(b,e,h) = sum(c,f,i) = 15 (sum of each column to be 15)\\ndiagonals: sum(a,e,i) = sum(c,e,g) = 15 (sum of each diagnoal to be 15)\\n```\\n\\nFor terns that have the center number:\\n```\\nsum(a,e,i) = sum(d,e,f) = sum(c,e,g) = sum(b,e,h) = 15\\nAssume sum(a,i) = sum(d,f) = sum(c,g) = sum(b,h) = x\\n\\n=> 4*x + 4*e = 4*15 = 60, 4*x + e = 45(sum of all 9 numbers)\\n=> 3*e = 15\\n=> e = 5 (the center of a magic square has to be 5)\\n=> x = 10(the other 2 numbers, which can form up a line together with the center number, have the sum to be 10)\\n```\\n\\n**Checklist:**\\n1. The center number has to be 5, all square without a center number as 5 can be ignored.\\n2. The other 2 numbers, which can form up a line together with the center number, have the sum to be 10.\\n3. The rows and columns that don\\'t include the center number should also have the sum to be 15.\\n4. The square should include distinct numbers from `1-9`, no duplicates are allowed, and number `0, 10-15` are also invalid.\\n\\nAlso, the numbers on the edges of the grid can never be the center number of a valid magic square, so we can start checking the center number with index `1 <= i < row - 1` and `1 <= j < col - 1`.\\n\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int res = 0;\\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n\\t\\t\\t\\t// check the center number of a square\\n                if (grid[i][j] != 5) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the other 2 numbers that can form up a line with the center number\\n                if (grid[i][j - 1] + grid[i][j + 1] != 10) continue;\\n                if (grid[i - 1][j] + grid[i + 1][j] != 10) continue;\\n                if (grid[i - 1][j - 1] + grid[i + 1][j + 1] != 10) continue;\\n                if (grid[i + 1][j - 1] + grid[i - 1][j + 1] != 10) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the rows and columns that don\\'t include the center number\\n                if (grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] != 15) continue;\\n                if (grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1] != 15) continue;\\n                if (grid[i - 1][j - 1] + grid[i][j - 1] + grid[i + 1][j - 1] != 15) continue;\\n                if (grid[i - 1][j + 1] + grid[i][j + 1] + grid[i + 1][j + 1] != 15) continue;\\n                   \\n\\t\\t\\t\\t// check if the current square is valid (distinct numbers from 1 to 9)\\n                if (isValid(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int x, int y) {\\n        int[] dx = {-1, 0, 1};\\n        int[] dy = {-1, 0, 1};\\n        int[] cnt = new int[16];\\n        \\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                cnt[grid[x + dx[i]][y + dy[j]]]++;\\n            }\\n        }\\n        \\n        for (int n = 1; n <= 9; ++n) {\\n            if (cnt[n] != 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\na b c\\nd e f\\ng h i\\n```\n```\\nsum(a,b,c,d,e,f,g,h,i) = sum(1,2,3,4,5,6,7,8,9) = 45\\n```\n```\\nrows: sum(a,b,c) = sum(d,e,f) = sum(g,h,i) = 15 (sum of each row to be 15)\\ncols: sum(a,d,g) = sum(b,e,h) = sum(c,f,i) = 15 (sum of each column to be 15)\\ndiagonals: sum(a,e,i) = sum(c,e,g) = 15 (sum of each diagnoal to be 15)\\n```\n```\\nsum(a,e,i) = sum(d,e,f) = sum(c,e,g) = sum(b,e,h) = 15\\nAssume sum(a,i) = sum(d,f) = sum(c,g) = sum(b,h) = x\\n\\n=> 4*x + 4*e = 4*15 = 60, 4*x + e = 45(sum of all 9 numbers)\\n=> 3*e = 15\\n=> e = 5 (the center of a magic square has to be 5)\\n=> x = 10(the other 2 numbers, which can form up a line together with the center number, have the sum to be 10)\\n```\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int res = 0;\\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n\\t\\t\\t\\t// check the center number of a square\\n                if (grid[i][j] != 5) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the other 2 numbers that can form up a line with the center number\\n                if (grid[i][j - 1] + grid[i][j + 1] != 10) continue;\\n                if (grid[i - 1][j] + grid[i + 1][j] != 10) continue;\\n                if (grid[i - 1][j - 1] + grid[i + 1][j + 1] != 10) continue;\\n                if (grid[i + 1][j - 1] + grid[i - 1][j + 1] != 10) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check the rows and columns that don\\'t include the center number\\n                if (grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] != 15) continue;\\n                if (grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1] != 15) continue;\\n                if (grid[i - 1][j - 1] + grid[i][j - 1] + grid[i + 1][j - 1] != 15) continue;\\n                if (grid[i - 1][j + 1] + grid[i][j + 1] + grid[i + 1][j + 1] != 15) continue;\\n                   \\n\\t\\t\\t\\t// check if the current square is valid (distinct numbers from 1 to 9)\\n                if (isValid(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int x, int y) {\\n        int[] dx = {-1, 0, 1};\\n        int[] dy = {-1, 0, 1};\\n        int[] cnt = new int[16];\\n        \\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                cnt[grid[x + dx[i]][y + dy[j]]]++;\\n            }\\n        }\\n        \\n        for (int n = 1; n <= 9; ++n) {\\n            if (cnt[n] != 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162192,
                "title": "clean-python-solution-easily-scalable-for-nxn-magic-squares",
                "content": "I avoided hardcoding my solution too much, so instead I made it scalable for NxN magic squares (just replace every occurence of 3 with N)\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(i, j):\\n            nums_set = {k for k in range(1, 3 * 3 + 1)}\\n            target = 0\\n            \\n            # Traverse first row and use sum(first_row) as the target\\n            for num in grid[i][j:j + 3]:\\n                if 1 <= num <= 3 * 3:\\n                    nums_set.discard(num)\\n                    target += num\\n                else:\\n                    return 0\\n            \\n            # Traverse the other rows\\n            for k in range(i + 1, i + 3):\\n                t = 0\\n                for num in grid[k][j:j + 3]:\\n                    if 1 <= num <= 3 * 3:\\n                        nums_set.discard(num)\\n                        t += num\\n                    else:\\n                        return 0\\n                if t != target:\\n                    return 0\\n            \\n            # After traversing all rows, this set should be empty if all numbers were distinct\\n            if len(nums_set) != 0: return 0\\n            \\n            # Traverse the columns\\n            for q in range(j, j + 3):\\n                t = 0\\n                for p in range(i, i + 3):\\n                    t += grid[p][q]\\n                if t != target:\\n                    return 0\\n            \\n            # Traverse the top-left diagonal\\n            p, q = i, j\\n            t = 0\\n            while p < i + 3 and q < j + 3:\\n                t += grid[p][q]\\n                p += 1\\n                q += 1\\n            if t != target:\\n                return 0\\n            \\n            # Traverse the top-right diagonal\\n            p, q = i, j + 3\\n            t = 0\\n            while p < i + 3 and q > j:\\n                q -= 1\\n                t += grid[p][q]\\n                p += 1\\n            if t != target:\\n                return 0\\n                \\n            return 1\\n        \\n        # Go through all magic squares of length 3\\n        ans = 0\\n        for i in range(len(grid) - 3 + 1):\\n            for j in range(len(grid[0]) - 3 + 1):\\n                ans += is_magic_square(i, j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(i, j):\\n            nums_set = {k for k in range(1, 3 * 3 + 1)}\\n            target = 0\\n            \\n            # Traverse first row and use sum(first_row) as the target\\n            for num in grid[i][j:j + 3]:\\n                if 1 <= num <= 3 * 3:\\n                    nums_set.discard(num)\\n                    target += num\\n                else:\\n                    return 0\\n            \\n            # Traverse the other rows\\n            for k in range(i + 1, i + 3):\\n                t = 0\\n                for num in grid[k][j:j + 3]:\\n                    if 1 <= num <= 3 * 3:\\n                        nums_set.discard(num)\\n                        t += num\\n                    else:\\n                        return 0\\n                if t != target:\\n                    return 0\\n            \\n            # After traversing all rows, this set should be empty if all numbers were distinct\\n            if len(nums_set) != 0: return 0\\n            \\n            # Traverse the columns\\n            for q in range(j, j + 3):\\n                t = 0\\n                for p in range(i, i + 3):\\n                    t += grid[p][q]\\n                if t != target:\\n                    return 0\\n            \\n            # Traverse the top-left diagonal\\n            p, q = i, j\\n            t = 0\\n            while p < i + 3 and q < j + 3:\\n                t += grid[p][q]\\n                p += 1\\n                q += 1\\n            if t != target:\\n                return 0\\n            \\n            # Traverse the top-right diagonal\\n            p, q = i, j + 3\\n            t = 0\\n            while p < i + 3 and q > j:\\n                q -= 1\\n                t += grid[p][q]\\n                p += 1\\n            if t != target:\\n                return 0\\n                \\n            return 1\\n        \\n        # Go through all magic squares of length 3\\n        ans = 0\\n        for i in range(len(grid) - 3 + 1):\\n            for j in range(len(grid[0]) - 3 + 1):\\n                ans += is_magic_square(i, j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765635,
                "title": "easy-and-clean-code-with-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is1To9Exist(vector<vector<int>>& grid, int m1, int n1, int m2, int n2){\\n        vector<bool> arr(10,false);\\n        arr[0]=true;\\n        for(int i=m1;i<m2;i++){\\n           for(int j=n1;j<n2;j++){\\n               if(grid[i][j]>9 or arr[grid[i][j]]){\\n                   return false;\\n               }\\n               arr[grid[i][j]]=true;\\n           }\\n        }\\n        return true;\\n    }\\n    \\n    int isMagic(int row0, int row1, int row2, int col0, int col1, int col2, int daig1, int daig2){\\n        return (row0==row1 and row0==row2 and row0==col0 and row0==col1 and row0==col2 and row0==daig1 and row0==daig2)?1:0;        \\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        if(row<3){\\n            return 0;\\n        }\\n        int row1=0, row2=0, row0=0, col1=0, col2=0, col0=0, daig1=0, daig2=0, count=0;\\n        int i=0;\\n        for(int i=0;i<row-2;i++){\\n            for(int j=0;j<grid[i].size()-2;j++){\\n                if(!is1To9Exist(grid, i, j, i+3, j+3)){\\n                    continue;\\n                }\\n                row0 = grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                col0 = grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n                row1 = grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n                col1 = grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];            \\n                row2 = grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                col2 = grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n                daig1 = grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n                daig2 = grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n                // cout<<row0<<\" \"<<row1<<\" \"<<row2<<\" \"<<col0<<\" \"<<col1<<\" \"<<col2<<\" \"<<daig1<<\" \"<<daig2<<endl;\\n                count+=isMagic(row0, row1, row2, col0, col1, col2, daig1, daig2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is1To9Exist(vector<vector<int>>& grid, int m1, int n1, int m2, int n2){\\n        vector<bool> arr(10,false);\\n        arr[0]=true;\\n        for(int i=m1;i<m2;i++){\\n           for(int j=n1;j<n2;j++){\\n               if(grid[i][j]>9 or arr[grid[i][j]]){\\n                   return false;\\n               }\\n               arr[grid[i][j]]=true;\\n           }\\n        }\\n        return true;\\n    }\\n    \\n    int isMagic(int row0, int row1, int row2, int col0, int col1, int col2, int daig1, int daig2){\\n        return (row0==row1 and row0==row2 and row0==col0 and row0==col1 and row0==col2 and row0==daig1 and row0==daig2)?1:0;        \\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        if(row<3){\\n            return 0;\\n        }\\n        int row1=0, row2=0, row0=0, col1=0, col2=0, col0=0, daig1=0, daig2=0, count=0;\\n        int i=0;\\n        for(int i=0;i<row-2;i++){\\n            for(int j=0;j<grid[i].size()-2;j++){\\n                if(!is1To9Exist(grid, i, j, i+3, j+3)){\\n                    continue;\\n                }\\n                row0 = grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n                col0 = grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n                row1 = grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n                col1 = grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];            \\n                row2 = grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n                col2 = grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n                daig1 = grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n                daig2 = grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n                // cout<<row0<<\" \"<<row1<<\" \"<<row2<<\" \"<<col0<<\" \"<<col1<<\" \"<<col2<<\" \"<<daig1<<\" \"<<daig2<<endl;\\n                count+=isMagic(row0, row1, row2, col0, col1, col2, daig1, daig2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 663698,
                "title": "go-beats-100",
                "content": "```go\\nimport \"sort\"\\n\\nfunc numMagicSquaresInside(grid [][]int) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid) - 2; i++ {\\n        for j := 0; j < len(grid[0]) - 2; j++ {\\n            if grid[i + 1][j + 1] != 5 {\\n                continue\\n            }\\n            \\n            if check(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                     grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                     grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2]) {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc check(a, b, c, d, e, f, g, h, i int) bool {\\n    nums := []int{a, b, c, d, e, f, g, h, i}\\n    \\n    sort.Ints(nums)\\n    \\n    for i, v := range nums {\\n        if i + 1 != v {\\n            return false\\n        }\\n    }\\n    \\n    return a + b + c == 15 &&  d + e + f == 15 && g + h + i == 15 && a + d + g == 15 && b + e + h == 15 && c + f + i == 15 && a + e + i == 15 && c + e + g == 15\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"sort\"\\n\\nfunc numMagicSquaresInside(grid [][]int) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid) - 2; i++ {\\n        for j := 0; j < len(grid[0]) - 2; j++ {\\n            if grid[i + 1][j + 1] != 5 {\\n                continue\\n            }\\n            \\n            if check(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                     grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                     grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2]) {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc check(a, b, c, d, e, f, g, h, i int) bool {\\n    nums := []int{a, b, c, d, e, f, g, h, i}\\n    \\n    sort.Ints(nums)\\n    \\n    for i, v := range nums {\\n        if i + 1 != v {\\n            return false\\n        }\\n    }\\n    \\n    return a + b + c == 15 &&  d + e + f == 15 && g + h + i == 15 && a + d + g == 15 && b + e + h == 15 && c + f + i == 15 && a + e + i == 15 && c + e + g == 15\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 533267,
                "title": "c-double-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isFrom1to9(vector<vector<int>>& grid, int si, int sj) {\\n        bool find[16]{false};\\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                find[grid[si+i][sj+j]] = true;\\n            }\\n        }\\n        for (int i = 1; i < 10; ++i) {\\n            if (!find[i]) return false;\\n        }\\n        return true;\\n    }\\n    bool isMagic(vector<vector<int>>& grid, int si, int sj) {\\n        if (!isFrom1to9(grid, si, sj))\\n            return false;\\n        int sum = grid[si][sj] + grid[si][sj+1] + grid[si][sj+2];\\n        for (int i = 0; i < 3; ++i) {\\n            int tmp1 = grid[si+i][sj] + grid[si+i][sj+1] + grid[si+i][sj+2];\\n            int tmp2 = grid[si][sj+i] + grid[si+1][sj+i] + grid[si+2][sj+i];\\n            if (tmp1 != sum || tmp2 != sum) return false;\\n        }\\n        int tmp3 = grid[si][sj] + grid[si+1][sj+1] + grid[si+2][sj+2];\\n        int tmp4 = grid[si+2][sj] + grid[si+1][sj+1] + grid[si][sj+2];\\n        printf(\"tmp3=%d tmp4=%d\\\\n\", tmp3, tmp4);\\n        if (tmp3 != sum || tmp4 != sum) return false;\\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int max_i = grid.size();\\n        int max_j = grid[0].size();\\n        int sum = 0;\\n        for (int i = 0; i < max_i - 2; ++i) {\\n            for (int j = 0; j < max_j - 2; ++j) {\\n                if (isMagic(grid, i, j)) ++sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFrom1to9(vector<vector<int>>& grid, int si, int sj) {\\n        bool find[16]{false};\\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                find[grid[si+i][sj+j]] = true;\\n            }\\n        }\\n        for (int i = 1; i < 10; ++i) {\\n            if (!find[i]) return false;\\n        }\\n        return true;\\n    }\\n    bool isMagic(vector<vector<int>>& grid, int si, int sj) {\\n        if (!isFrom1to9(grid, si, sj))\\n            return false;\\n        int sum = grid[si][sj] + grid[si][sj+1] + grid[si][sj+2];\\n        for (int i = 0; i < 3; ++i) {\\n            int tmp1 = grid[si+i][sj] + grid[si+i][sj+1] + grid[si+i][sj+2];\\n            int tmp2 = grid[si][sj+i] + grid[si+1][sj+i] + grid[si+2][sj+i];\\n            if (tmp1 != sum || tmp2 != sum) return false;\\n        }\\n        int tmp3 = grid[si][sj] + grid[si+1][sj+1] + grid[si+2][sj+2];\\n        int tmp4 = grid[si+2][sj] + grid[si+1][sj+1] + grid[si][sj+2];\\n        printf(\"tmp3=%d tmp4=%d\\\\n\", tmp3, tmp4);\\n        if (tmp3 != sum || tmp4 != sum) return false;\\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int max_i = grid.size();\\n        int max_j = grid[0].size();\\n        int sum = 0;\\n        for (int i = 0; i < max_i - 2; ++i) {\\n            for (int j = 0; j < max_j - 2; ++j) {\\n                if (isMagic(grid, i, j)) ++sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453742,
                "title": "javascript-solution",
                "content": "### \\u5206\\u6790 1\\n\\n> \\u66B4\\u529B\\u62C6\\u89E3 + \\u6821\\u9A8C\\n\\n\\u66B4\\u529B\\u62C6\\u89E3\\uFF1A\\n\\n1. \\u4E09\\u9636\\u4EE5\\u4E0B\\uFF0C\\u8FD4\\u56DE 0\\n\\n2. \\u5927\\u4E8E\\u7B49\\u4E8E\\u4E09\\u9636\\uFF0C\\u904D\\u5386\\u6240\\u6709\\u4E5D\\u5BAB\\u683C\\u77E9\\u9635\\n\\n\\u6821\\u9A8C\\uFF1A\\n\\n1. 1-9\\n2. \\u6570\\u5B57\\u5404\\u4E0D\\u76F8\\u540C\\n3. \\u6BCF\\u884C\\u6BCF\\u5217\\u53CA\\u5BF9\\u89D2\\u7EBF\\u548C\\u76F8\\u7B49\\uFF088\\u4E2A\\u7B49\\u5F0F\\uFF09\\n\\n\\n\\n### \\u5206\\u6790 2\\n\\n> \\u4ECD\\u7136\\u662F \\u66B4\\u529B\\u62C6\\u89E3 + \\u6821\\u9A8C\\uFF0C\\u4F46\\u5728\\u5206\\u6790 1 \\u7684\\u57FA\\u7840\\u4E0A\\uFF0C\\u5BF9\\u6821\\u9A8C\\u6761\\u4EF6 3 \\u505A\\u4F18\\u5316\\n\\n| a     | b     | s-a-b |\\n| ----- | ----- | ----- |\\n| c     | d     | s-c-d |\\n| s-a-c | s-b-d | s-a-d |\\n\\n\\u5047\\u8BBE\\u5E7B\\u65B9\\u53F3\\u4E0A\\u89D2\\u56DB\\u4E2A\\u5143\\u7D20\\u4E3Aa,b,c,d\\uFF0C\\u6BCF\\u4E00\\u884C\\u7684\\u548C\\u4E3A s ,\\u5219\\u5269\\u4F59 5 \\u4E2A\\u5143\\u7D20\\u90FD\\u53EF\\u4EE5\\u6C42\\u5F97\\u3002\\n\\n\\u5219\\u7B2C\\u4E09\\u884C\\uFF08\\u5217\\uFF09\\u5FC5\\u7136\\u6EE1\\u8DB3\\uFF1A\\n\\n\\u200B\\t(s-a-c)+(s-b-d)+(s-a-d)=s\\n\\n=> 2a+b+c+2d=2s\\n\\n\\u8FD9\\u6837\\uFF0C\\u5206\\u6790 1 \\u7684\\u6821\\u9A8C 3 \\u5C31\\u4ECE 8 \\u4E2A \\u88AB\\u4F18\\u5316\\u5230 1 \\u4E2A\\u7B49\\u5F0F\\u3002\\n\\n\\n\\n## \\u5206\\u6790 3\\n\\n> \\u51E1\\u662F\\u8FD9\\u79CD\\u9AD8\\u5EA6\\u5BF9\\u79F0\\u7684\\u56FE\\u5F62\\u6216\\u6570\\u96C6\\uFF0C\\u53EF\\u4EE5\\u731C\\u60F3\\u4E2D\\u5FC3\\u6570\\u5B57\\u662F\\u5426\\u4E3A\\u5BF9\\u79F0\\u4E2D\\u5FC3\\uFF081-9 \\u7684\\u5BF9\\u79F0\\u4E2D\\u5FC3\\u662F 5\\uFF09\\u3002\\n\\n\\u6240\\u6709\\u884C\\u5217\\u548C\\uFF088 \\u5BF9\\uFF09\\u76F8\\u7B49\\uFF0C\\u5219\\u52BF\\u5FC5\\u6DB5\\u76D6\\u4E2D\\u5FC3\\u7684\\uFF084 \\u5BF9\\uFF09\\u76F8\\u7B49\\uFF0C\\u7531\\u6821\\u9A8C\\u6761\\u4EF6 1\\uFF0C2 \\u53EF\\u4EE5\\u63A8\\u51FA\\uFF0C\\u8981\\u5728 1-9 \\u5185\\u627E\\u51FA 4 \\u5BF9\\u548C\\u76F8\\u540C\\u7684\\u6570\\u5B57\\uFF0C\\u5FC5\\u7136\\u662F \\uFF081\\u30019\\uFF09\\uFF082\\u30018\\uFF09\\uFF083\\u30017\\uFF09\\uFF084\\u30016\\uFF09\\uFF085\\uFF09\\uFF0C\\u6240\\u4EE5\\u4E2D\\u5FC3\\u6570\\u5B57\\u4E00\\u5B9A\\u4E3A 5\\u3002\\uFF08\\u8BE6\\u7EC6\\u8BC1\\u660E\\u7565\\uFF09\\n\\n```javascript\\nvar numMagicSquaresInside = function(grid) {\\n  let num = 0;\\n  if (grid.length < 3 || grid.some(r => r.length < 3)) {\\n    return num;\\n  }\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length - 2; j++) {\\n      const square = [\\n        grid[i][j],\\n        grid[i][j + 1],\\n        grid[i][j + 2],\\n        grid[i + 1][j],\\n        grid[i + 1][j + 1],\\n        grid[i + 1][j + 2],\\n        grid[i + 2][j],\\n        grid[i + 2][j + 1],\\n        grid[i + 2][j + 2]\\n      ];\\n      if (\\n        grid[4]!==5 ||\\n        square.some(x => x < 1 || x > 9) ||\\n        Array.from(new Set(square)).length < 9\\n      ) {\\n        continue;\\n      }\\n      if (\\n        2 * square[0] + square[1] + square[3] + 2 * square[4] ===\\n        2 * (square[0] + square[1] + square[2])\\n      ) {\\n        num++;\\n      }\\n    }\\n  }\\n  return num;\\n};\\n```\\n\\n\\n\\n### \\u603B\\u7ED3\\n\\n\\u4E09\\u79CD\\u65B9\\u6CD5\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF1A\\u5206\\u6790 1>\\u5206\\u6790 2>\\u5206\\u6790 3",
                "solutionTags": [],
                "code": "```javascript\\nvar numMagicSquaresInside = function(grid) {\\n  let num = 0;\\n  if (grid.length < 3 || grid.some(r => r.length < 3)) {\\n    return num;\\n  }\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length - 2; j++) {\\n      const square = [\\n        grid[i][j],\\n        grid[i][j + 1],\\n        grid[i][j + 2],\\n        grid[i + 1][j],\\n        grid[i + 1][j + 1],\\n        grid[i + 1][j + 2],\\n        grid[i + 2][j],\\n        grid[i + 2][j + 1],\\n        grid[i + 2][j + 2]\\n      ];\\n      if (\\n        grid[4]!==5 ||\\n        square.some(x => x < 1 || x > 9) ||\\n        Array.from(new Set(square)).length < 9\\n      ) {\\n        continue;\\n      }\\n      if (\\n        2 * square[0] + square[1] + square[3] + 2 * square[4] ===\\n        2 * (square[0] + square[1] + square[2])\\n      ) {\\n        num++;\\n      }\\n    }\\n  }\\n  return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241515,
                "title": "no-tricks-plain-brute-force-elaborate-and-understandable-beats-100-python",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: \\'List[List[int]]\\') -> \\'int\\':\\n        verticalstep = 0\\n        magiccnt = 0\\n        if len(grid[0]) < 3 or len(grid[1]) < 3:\\n            return magiccnt\\n            \\n        while verticalstep+2 < len(grid):\\n            startindex = 0\\n            endindex = 2\\n            while endindex < len(grid[0]):\\n                \\n                s = []\\n                for i in range(verticalstep, verticalstep+3):\\n                    s.extend( grid[i][startindex:endindex+1])\\n                \\n                s = set(s)\\n                if len(s) < 9 or min(s) < 1 or max(s) > 9:\\n                    startindex+=1\\n                    endindex+=1\\n                    continue\\n                \\n                rowsum = getSum(grid[verticalstep:verticalstep+3], \\'row\\', startindex, endindex, verticalstep)\\n                colsum = getSum(grid[verticalstep:verticalstep+3], \\'col\\', startindex, endindex, verticalstep)\\n                daigonalsum = getSum(grid[verticalstep:verticalstep+3], \\'daigonal\\', startindex, endindex, verticalstep)\\n                \\n                \\n                if rowsum[1] and colsum[1] and daigonalsum[1] and rowsum[0]== colsum[0] and daigonalsum[0]:\\n                    magiccnt += 1\\n                startindex+=1\\n                endindex+=1\\n            \\n            verticalstep+=1\\n            \\n        return magiccnt\\n            \\n\\ndef getSum(grd, way, startindex, endindex, verticalstep):\\n    \\n    summ = 0\\n    if way == \\'row\\':\\n        for item in grd:\\n            if summ==0:\\n                summ = sum(item[startindex:endindex+1])\\n            else:\\n                if summ != sum(item[startindex:endindex+1]):\\n                    return(-1, False)\\n        return (summ, True)\\n    \\n    elif way== \\'col\\':\\n        \\n        col1, col2, col3 = 0, 0, 0\\n        for col in grd:\\n            col1+= col[startindex]\\n            col2+= col[startindex+1]\\n            col3+= col[startindex+2]\\n        \\n        if col1 == col2 == col3 :\\n            summ = col1\\n            return (summ, True)\\n        else:\\n            return (-1, False)\\n            \\n    elif way == \\'daigonal\\':\\n        for daig in grd:\\n            daig1 = grd[0][startindex] + grd[1][startindex+1] + grd[2][startindex+2]\\n            daig2 = grd[0][endindex] + grd[1][endindex-1] + grd[2][endindex-2]\\n            \\n            if daig1 == daig2:\\n                summ = daig1\\n                return (summ, True)\\n            else:\\n                return (-1, False)\\n            \\n    # Error Checking\\n    else:\\n        return -1\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: \\'List[List[int]]\\') -> \\'int\\':\\n        verticalstep = 0\\n        magiccnt = 0\\n        if len(grid[0]) < 3 or len(grid[1]) < 3:\\n            return magiccnt\\n            \\n        while verticalstep+2 < len(grid):\\n            startindex = 0\\n            endindex = 2\\n            while endindex < len(grid[0]):\\n                \\n                s = []\\n                for i in range(verticalstep, verticalstep+3):\\n                    s.extend( grid[i][startindex:endindex+1])\\n                \\n                s = set(s)\\n                if len(s) < 9 or min(s) < 1 or max(s) > 9:\\n                    startindex+=1\\n                    endindex+=1\\n                    continue\\n                \\n                rowsum = getSum(grid[verticalstep:verticalstep+3], \\'row\\', startindex, endindex, verticalstep)\\n                colsum = getSum(grid[verticalstep:verticalstep+3], \\'col\\', startindex, endindex, verticalstep)\\n                daigonalsum = getSum(grid[verticalstep:verticalstep+3], \\'daigonal\\', startindex, endindex, verticalstep)\\n                \\n                \\n                if rowsum[1] and colsum[1] and daigonalsum[1] and rowsum[0]== colsum[0] and daigonalsum[0]:\\n                    magiccnt += 1\\n                startindex+=1\\n                endindex+=1\\n            \\n            verticalstep+=1\\n            \\n        return magiccnt\\n            \\n\\ndef getSum(grd, way, startindex, endindex, verticalstep):\\n    \\n    summ = 0\\n    if way == \\'row\\':\\n        for item in grd:\\n            if summ==0:\\n                summ = sum(item[startindex:endindex+1])\\n            else:\\n                if summ != sum(item[startindex:endindex+1]):\\n                    return(-1, False)\\n        return (summ, True)\\n    \\n    elif way== \\'col\\':\\n        \\n        col1, col2, col3 = 0, 0, 0\\n        for col in grd:\\n            col1+= col[startindex]\\n            col2+= col[startindex+1]\\n            col3+= col[startindex+2]\\n        \\n        if col1 == col2 == col3 :\\n            summ = col1\\n            return (summ, True)\\n        else:\\n            return (-1, False)\\n            \\n    elif way == \\'daigonal\\':\\n        for daig in grd:\\n            daig1 = grd[0][startindex] + grd[1][startindex+1] + grd[2][startindex+2]\\n            daig2 = grd[0][endindex] + grd[1][endindex-1] + grd[2][endindex-2]\\n            \\n            if daig1 == daig2:\\n                summ = daig1\\n                return (summ, True)\\n            else:\\n                return (-1, False)\\n            \\n    # Error Checking\\n    else:\\n        return -1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041450,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static boolean helper(int arr[][], int a, int b, int c , int d){\\n\\n        int ax[] = new int[9];\\n\\n        for(int i=a; i<=c; i++){\\n            for(int j=b; j<=d; j++){\\n                if(arr[i][j]<10 && arr[i][j]>0)\\n                ax[arr[i][j]-1]++;\\n            }\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            if(ax[i]==0) return false;\\n        }\\n\\n        int sum = arr[a][b]+arr[a][b+1]+arr[a][b+2];\\n\\n        for(int i=a; i<=c; i++){\\n            int s = arr[i][b]+arr[i][b+1]+arr[i][b+2];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        for(int j=b; j<=d; j++){\\n            int s = arr[a][j]+arr[a+1][j]+arr[a+2][j];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        if(arr[a][b]+arr[a+1][b+1]+arr[a+2][b+2]!=sum) {\\n            return false;\\n        }\\n        if(arr[a][b+2]+arr[a+1][b+1]+arr[a+2][b]!=sum) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] arr) {\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++){\\n            for(int j=0; j<m-2; j++){\\n                if(helper(arr,i,j,i+2,j+2)) ans++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static boolean helper(int arr[][], int a, int b, int c , int d){\\n\\n        int ax[] = new int[9];\\n\\n        for(int i=a; i<=c; i++){\\n            for(int j=b; j<=d; j++){\\n                if(arr[i][j]<10 && arr[i][j]>0)\\n                ax[arr[i][j]-1]++;\\n            }\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            if(ax[i]==0) return false;\\n        }\\n\\n        int sum = arr[a][b]+arr[a][b+1]+arr[a][b+2];\\n\\n        for(int i=a; i<=c; i++){\\n            int s = arr[i][b]+arr[i][b+1]+arr[i][b+2];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        for(int j=b; j<=d; j++){\\n            int s = arr[a][j]+arr[a+1][j]+arr[a+2][j];\\n            if(s!=sum) {\\n                return false;\\n            }\\n        }\\n\\n        if(arr[a][b]+arr[a+1][b+1]+arr[a+2][b+2]!=sum) {\\n            return false;\\n        }\\n        if(arr[a][b+2]+arr[a+1][b+1]+arr[a+2][b]!=sum) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] arr) {\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++){\\n            for(int j=0; j<m-2; j++){\\n                if(helper(arr,i,j,i+2,j+2)) ans++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489358,
                "title": "solution",
                "content": "```C++ []\\n#define DO(...) { __VA_ARGS__ do\\n#define WHILE(...) while(__VA_ARGS__); }\\n\\nclass Solution {\\n    typedef unsigned int uInt;\\n    typedef const uInt c_uInt;\\n    static constexpr uInt\\n        magicSize = 3, magicSizeM1 = magicSize - 1;\\n    bool contained[10];\\n    bool isMagicSqr (const vector<vector<int>> &grid, c_uInt c_row, c_uInt c_col) {\\n        uInt sum, targetSum;\\n        DO ( uInt row = 0; ) {\\n            sum = 0;\\n            DO ( uInt col = 0; ) {\\n                uInt num = grid[c_row + row][c_col + col];\\n                if ((1 <= num) && (num <= 9)) {} else return false;\\n                bool &hasNum = contained[num];\\n                if (hasNum) return false;\\n                hasNum = true; sum += num;\\n            } WHILE (++col < magicSize);\\n            if (row) {\\n                if (targetSum != sum) return false;\\n            } else { targetSum = sum; }\\n        } WHILE (++row < magicSize);\\n        DO ( uInt col = 0; ) {\\n            sum = 0;\\n            DO ( uInt row = 0; ) {\\n                sum += grid[c_row + row][c_col + col];\\n            } WHILE (++row < magicSize);\\n            if (targetSum != sum) return false;\\n        } WHILE (++col < magicSize);\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        if (targetSum != sum) return false;\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + magicSizeM1 - ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        return (targetSum == sum);\\n    }\\npublic:\\n    uInt numMagicSquaresInside(const vector<vector<int>> &grid) {\\n        uInt magicCnt = 0;\\n        c_uInt rowCnt = grid.size(), colCnt = grid[0].size();\\n        for (uInt lstRow = magicSizeM1; lstRow < rowCnt; lstRow++) {\\n            for (uInt lstCol = magicSizeM1; lstCol < colCnt; lstCol++) {\\n                fill(contained + 1, contained + 10, false);\\n                if (isMagicSqr(grid, lstRow - magicSizeM1, lstCol - magicSizeM1)) { ++magicCnt; }\\n            }\\n        }\\n        return magicCnt;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n\\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n        return count\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        return magicBoxCount;\\n    }\\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 || \\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15)\\n        {\\n            return false;\\n        }\\n        return true;   \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#define DO(...) { __VA_ARGS__ do\\n#define WHILE(...) while(__VA_ARGS__); }\\n\\nclass Solution {\\n    typedef unsigned int uInt;\\n    typedef const uInt c_uInt;\\n    static constexpr uInt\\n        magicSize = 3, magicSizeM1 = magicSize - 1;\\n    bool contained[10];\\n    bool isMagicSqr (const vector<vector<int>> &grid, c_uInt c_row, c_uInt c_col) {\\n        uInt sum, targetSum;\\n        DO ( uInt row = 0; ) {\\n            sum = 0;\\n            DO ( uInt col = 0; ) {\\n                uInt num = grid[c_row + row][c_col + col];\\n                if ((1 <= num) && (num <= 9)) {} else return false;\\n                bool &hasNum = contained[num];\\n                if (hasNum) return false;\\n                hasNum = true; sum += num;\\n            } WHILE (++col < magicSize);\\n            if (row) {\\n                if (targetSum != sum) return false;\\n            } else { targetSum = sum; }\\n        } WHILE (++row < magicSize);\\n        DO ( uInt col = 0; ) {\\n            sum = 0;\\n            DO ( uInt row = 0; ) {\\n                sum += grid[c_row + row][c_col + col];\\n            } WHILE (++row < magicSize);\\n            if (targetSum != sum) return false;\\n        } WHILE (++col < magicSize);\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        if (targetSum != sum) return false;\\n        sum = 0;\\n        DO ( uInt ctr = 0; ) {\\n            sum += grid[c_row + magicSizeM1 - ctr][c_col + ctr];\\n        } WHILE (++ctr < magicSize);\\n        return (targetSum == sum);\\n    }\\npublic:\\n    uInt numMagicSquaresInside(const vector<vector<int>> &grid) {\\n        uInt magicCnt = 0;\\n        c_uInt rowCnt = grid.size(), colCnt = grid[0].size();\\n        for (uInt lstRow = magicSizeM1; lstRow < rowCnt; lstRow++) {\\n            for (uInt lstCol = magicSizeM1; lstCol < colCnt; lstCol++) {\\n                fill(contained + 1, contained + 10, false);\\n                if (isMagicSqr(grid, lstRow - magicSizeM1, lstCol - magicSizeM1)) { ++magicCnt; }\\n            }\\n        }\\n        return magicCnt;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n\\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        return magicBoxCount;\\n    }\\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 || \\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15)\\n        {\\n            return false;\\n        }\\n        return true;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414013,
                "title": "c-easy-to-under-stand",
                "content": "# Intuition\\n![WhatsApp Image 2023-04-14 at 00.11.01.jpg](https://assets.leetcode.com/users/images/bfa78578-a8f9-44ec-9874-de030cecfe4c_1681411350.9803658.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool magicsquare(vector<vector<int>> &grid , int i , int j){\\n\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(magicsquare(grid, i, j)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool magicsquare(vector<vector<int>> &grid , int i , int j){\\n\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(magicsquare(grid, i, j)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066406,
                "title": "0ms-runtime-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to check each 3x3 sub-grid in the grid for the conditions of a magic square, and if all conditions are satisfied, increment the count of the number of magic squares. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo do that, we first check if the sum of each row, column and diagonal are equal. If they are, we then check if the central element is 5, and if all the numbers from 1 to 9 are present in the 3x3 sub-grid. If all conditions are met, we increment our count.\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the above code is O(n^3), where n is the size of the grid. This is because the code iterates through each element in the grid, and then checks each row, column, and diagonal for a sum of 15.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the above code is O(1), as the code does not use any additional memory and only uses variables declared within the function.\\n# Code\\n```\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698216,
                "title": "python-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        M, N = len(grid), len(grid[0])\\n        ans = 0\\n        \\n        \\n        def magic(a,b,c,\\n                  d,e,f,\\n                  g,h,i):\\n            \\n            return (reduce(lambda d, c: d + 1 if 1<=c<=9 else 0, set([a,b,c,d,e,f,g,h,i]), 0) == 9 and\\n                (a+b+c == d+e+f == g+h+i == a+d+g == b+e+h == c+f+i == a+e+i == c+e+g == 15))\\n        \\n        for i in range(M-2):\\n            for j in range(N-2):\\n                if magic(grid[i][j], grid[i][j+1], grid[i][j+2], \\n                      grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2], \\n                      grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]) : ans += 1\\n                       \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        M, N = len(grid), len(grid[0])\\n        ans = 0\\n        \\n        \\n        def magic(a,b,c,\\n                  d,e,f,\\n                  g,h,i):\\n            \\n            return (reduce(lambda d, c: d + 1 if 1<=c<=9 else 0, set([a,b,c,d,e,f,g,h,i]), 0) == 9 and\\n                (a+b+c == d+e+f == g+h+i == a+d+g == b+e+h == c+f+i == a+e+i == c+e+g == 15))\\n        \\n        for i in range(M-2):\\n            for j in range(N-2):\\n                if magic(grid[i][j], grid[i][j+1], grid[i][j+2], \\n                      grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2], \\n                      grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]) : ans += 1\\n                       \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898235,
                "title": "java-1ms-intuition-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nr of columns or rows < 3 return false \\n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\\n           - use a boolean[10] seen to mark the already present number in 3x3 view\\n           - return false if number if <1 or > 9\\n           - return false if any found sum is different that a reference sum\\n        4. Count the views /3x3 matrices and return their number   \\n    */\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for (int i = 0; i < grid.length -2; i++) {\\n            for (int j = 0; j < grid[i].length -2; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    private boolean isMagicSquare(int[][] grid, int row, int col) {\\n        // map the present number is a boolean of 10 (1-9)\\n        boolean[] seen = new boolean[10];\\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n        // row sum\\n        for (int i = row; i <= row +2; i++) {\\n            tempSum = 0;\\n            for (int j = col; j <= col +2; j++) {\\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if (tempSum != sum) {\\n                return false;\\n            }\\n        }\\n        //col sum\\n        for (int j = col; j <= col +2; j++) {\\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\\n                return false;\\n            }\\n        }\\n        //diag 1 and 2\\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nr of columns or rows < 3 return false \\n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\\n           - use a boolean[10] seen to mark the already present number in 3x3 view\\n           - return false if number if <1 or > 9\\n           - return false if any found sum is different that a reference sum\\n        4. Count the views /3x3 matrices and return their number   \\n    */\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for (int i = 0; i < grid.length -2; i++) {\\n            for (int j = 0; j < grid[i].length -2; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    private boolean isMagicSquare(int[][] grid, int row, int col) {\\n        // map the present number is a boolean of 10 (1-9)\\n        boolean[] seen = new boolean[10];\\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n        // row sum\\n        for (int i = row; i <= row +2; i++) {\\n            tempSum = 0;\\n            for (int j = col; j <= col +2; j++) {\\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if (tempSum != sum) {\\n                return false;\\n            }\\n        }\\n        //col sum\\n        for (int j = col; j <= col +2; j++) {\\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\\n                return false;\\n            }\\n        }\\n        //diag 1 and 2\\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651894,
                "title": "java-easy-solution-bfa",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[i].length;j++) \\n                if(magic(grid,i,j))\\n                    count++;\\n        \\n        \\n        \\n        return count;\\n    }\\n    boolean magic(int grid[][],int x,int y){\\n        if(x+2>=grid.length || y+2 >=grid[0].length)\\n            return false;\\n        int row[]=new int[3];\\n        int col[]=new int[3];\\n        int diagonal[]=new int[2];\\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=x;i<=x+2;i++){\\n            for(int j=y;j<=y+2;j++){\\n                \\n                if(set.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                set.add(grid[i][j]);\\n                \\n                row[i-x]+=grid[i][j];\\n                col[j-y]+=grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n                \\n            }\\n        }\\n        int val=row[0];\\n        for(int i:row) if(val!=i) return false;\\n        val=col[0];\\n        for(int i:col) if(val!=i) return false;\\n        if(diagonal[0]!=diagonal[1]) return false;\\n        return true;\\n        \\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[i].length;j++) \\n                if(magic(grid,i,j))\\n                    count++;\\n        \\n        \\n        \\n        return count;\\n    }\\n    boolean magic(int grid[][],int x,int y){\\n        if(x+2>=grid.length || y+2 >=grid[0].length)\\n            return false;\\n        int row[]=new int[3];\\n        int col[]=new int[3];\\n        int diagonal[]=new int[2];\\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=x;i<=x+2;i++){\\n            for(int j=y;j<=y+2;j++){\\n                \\n                if(set.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                set.add(grid[i][j]);\\n                \\n                row[i-x]+=grid[i][j];\\n                col[j-y]+=grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n                \\n            }\\n        }\\n        int val=row[0];\\n        for(int i:row) if(val!=i) return false;\\n        val=col[0];\\n        for(int i:col) if(val!=i) return false;\\n        if(diagonal[0]!=diagonal[1]) return false;\\n        return true;\\n        \\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595289,
                "title": "py-magic-squares-in-grid",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n        \\n        R,C = len(G), len(G[0])\\n        if R < 3 or C < 3: return 0\\n        \\n        ans = 0\\n        for r in range(R-2):\\n            for c in range(C-2):\\n                nums = set(G[r][c:c+3] + G[r+1][c:c+3] + G[r+2][c:c+3])\\n                r1 = sum(G[r][c:c+3])\\n                r2 = sum(G[r+1][c:c+3])\\n                r3 = sum(G[r+2][c:c+3])\\n                c1 = G[r][c] + G[r+1][c] + G[r+2][c]\\n                c2 = G[r][c+1] + G[r+1][c+1] + G[r+2][c+1]\\n                c3 = G[r][c+2] + G[r+1][c+2] + G[r+2][c+2]\\n                d1 = G[r][c] + G[r+1][c+1] + G[r+2][c+2]\\n                d2 = G[r+2][c] + G[r+1][c+1] + G[r][c+2]\\n                ans += len(nums) == 9 and min(nums) >= 1 and max(nums) <= 9 and r1 == r2 == r3 == c1 == c2 == c3 == d1 == d2\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n        \\n        R,C = len(G), len(G[0])\\n        if R < 3 or C < 3: return 0\\n        \\n        ans = 0\\n        for r in range(R-2):\\n            for c in range(C-2):\\n                nums = set(G[r][c:c+3] + G[r+1][c:c+3] + G[r+2][c:c+3])\\n                r1 = sum(G[r][c:c+3])\\n                r2 = sum(G[r+1][c:c+3])\\n                r3 = sum(G[r+2][c:c+3])\\n                c1 = G[r][c] + G[r+1][c] + G[r+2][c]\\n                c2 = G[r][c+1] + G[r+1][c+1] + G[r+2][c+1]\\n                c3 = G[r][c+2] + G[r+1][c+2] + G[r+2][c+2]\\n                d1 = G[r][c] + G[r+1][c+1] + G[r+2][c+2]\\n                d2 = G[r+2][c] + G[r+1][c+1] + G[r][c+2]\\n                ans += len(nums) == 9 and min(nums) >= 1 and max(nums) <= 9 and r1 == r2 == r3 == c1 == c2 == c3 == d1 == d2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437092,
                "title": "math-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }\\n        }\\n        return magic_squares;\\n    }\\n    \\n    private boolean isMagic(int[][] grid, int i, int j) {\\n        // For magic squares to be possible :\\n        // Foll conditions should be checked!\\n        \\n        //1. Corners should be even number\\n        if(grid[i][j]%2!=0 || grid[i][j+2]%2!=0 || grid[i+2][j]%2!=0 || grid[i+2][j+2]%2!=0)\\n            return false;\\n        \\n        //2. Non-corners should be odd number\\n        if(grid[i][j+1]%2==0 || grid[i+1][j]%2==0 || grid[i+1][j+2]%2==0 || grid[i+2][j+1]%2==0)\\n            return false;\\n        \\n        //3. Check 2 rows and 2 cols. We can ignore another as if 2 are equal to 15 then third will also be!\\n        if((grid[i][j]+grid[i][j+1]+grid[i][j+2]!=15) || //row 1\\n          (grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]!=15) || //row 2\\n          (grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]!=15) || //col 1\\n          (grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]!=15) // col 2\\n          )\\n            return false;\\n        \\n        // 4. Center number should be 5\\n        if(grid[i+1][j+1]!=5)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }\\n        }\\n        return magic_squares;\\n    }\\n    \\n    private boolean isMagic(int[][] grid, int i, int j) {\\n        // For magic squares to be possible :\\n        // Foll conditions should be checked!\\n        \\n        //1. Corners should be even number\\n        if(grid[i][j]%2!=0 || grid[i][j+2]%2!=0 || grid[i+2][j]%2!=0 || grid[i+2][j+2]%2!=0)\\n            return false;\\n        \\n        //2. Non-corners should be odd number\\n        if(grid[i][j+1]%2==0 || grid[i+1][j]%2==0 || grid[i+1][j+2]%2==0 || grid[i+2][j+1]%2==0)\\n            return false;\\n        \\n        //3. Check 2 rows and 2 cols. We can ignore another as if 2 are equal to 15 then third will also be!\\n        if((grid[i][j]+grid[i][j+1]+grid[i][j+2]!=15) || //row 1\\n          (grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]!=15) || //row 2\\n          (grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]!=15) || //col 1\\n          (grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]!=15) // col 2\\n          )\\n            return false;\\n        \\n        // 4. Center number should be 5\\n        if(grid[i+1][j+1]!=5)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416192,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid == null || grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isValid(grid, i, j)) {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int m, int n) {\\n        int sum = grid[m][n] + grid[m][n + 1] + grid[m][n + 2];\\n        //row\\n        for (int i = m; i < m + 3; i++) {\\n            int rowSum = 0;\\n            for (int j = n; j < n + 3; j++) {\\n                rowSum += grid[i][j];\\n            }\\n            if (rowSum != sum) {\\n                return false;\\n            }\\n        }\\n        //column\\n        for (int j = n; j < n + 3; j++) {\\n            int colSum = 0;\\n            for (int i = m; i < m + 3; i++) {\\n                colSum += grid[i][j];\\n            }\\n            if (colSum != sum) {\\n                return false;\\n            }\\n        }\\n        //diagonal\\n        if (sum != grid[m][n] + grid[m + 1][n + 1] + grid[m + 2][n + 2]) {\\n            return false;\\n        }\\n        //back diagonal\\n        if (sum != grid[m][n + 2] + grid[m + 1][n + 1] + grid[m + 2][n]) {\\n            return false;\\n        }\\n        //distinct and 1-9\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                if (grid[i][j] > 9 || grid[i][j] < 1) {\\n                    return false;\\n                }\\n                if (set.contains(grid[i][j])) {\\n                    return false;\\n                } else {\\n                    set.add(grid[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid == null || grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isValid(grid, i, j)) {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int m, int n) {\\n        int sum = grid[m][n] + grid[m][n + 1] + grid[m][n + 2];\\n        //row\\n        for (int i = m; i < m + 3; i++) {\\n            int rowSum = 0;\\n            for (int j = n; j < n + 3; j++) {\\n                rowSum += grid[i][j];\\n            }\\n            if (rowSum != sum) {\\n                return false;\\n            }\\n        }\\n        //column\\n        for (int j = n; j < n + 3; j++) {\\n            int colSum = 0;\\n            for (int i = m; i < m + 3; i++) {\\n                colSum += grid[i][j];\\n            }\\n            if (colSum != sum) {\\n                return false;\\n            }\\n        }\\n        //diagonal\\n        if (sum != grid[m][n] + grid[m + 1][n + 1] + grid[m + 2][n + 2]) {\\n            return false;\\n        }\\n        //back diagonal\\n        if (sum != grid[m][n + 2] + grid[m + 1][n + 1] + grid[m + 2][n]) {\\n            return false;\\n        }\\n        //distinct and 1-9\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = m; i < m + 3; i++) {\\n            for (int j = n; j < n + 3; j++) {\\n                if (grid[i][j] > 9 || grid[i][j] < 1) {\\n                    return false;\\n                }\\n                if (set.contains(grid[i][j])) {\\n                    return false;\\n                } else {\\n                    set.add(grid[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1413117,
                "title": "solved-without-skills",
                "content": "There are only 8 magic squares\\n- The center must be 5. We know that sum of each column/row is 15 ((1+2+3+4+5+6+7+8+9) / 3). If the center is not 5, there is no place for 9. If the center is 9, there is no place for 8.\\n- The corners must not be 9. If it is, we need 9 + 2 + 4 and 9 + 3 + 3 which is not possible.\\n- And so on and so forth.\\n- All 8 magic squares are flipped / reversed / mirrored from the others.\\n\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        squares = [\\n            [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\\n            [[2, 7, 6], [9, 5, 1], [4, 3, 8]],\\n            [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\\n            [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\\n            \\n            [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\\n            [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\\n            [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\\n            [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\\n        ]\\n        \\n        ans = 0\\n        \\n        for x, y, z in itertools.product(range(len(grid[0]) - 2), range(len(grid) - 2), range(8)):\\n            for dx, dy in itertools.product(range(3), range(3)):\\n                if grid[y+dy][x+dx] != squares[z][dy][dx]:\\n                    break\\n            else:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        squares = [\\n            [[4, 3, 8], [9, 5, 1], [2, 7, 6]],\\n            [[2, 7, 6], [9, 5, 1], [4, 3, 8]],\\n            [[8, 3, 4], [1, 5, 9], [6, 7, 2]],\\n            [[6, 7, 2], [1, 5, 9], [8, 3, 4]],\\n            \\n            [[8, 1, 6], [3, 5, 7], [4, 9, 2]],\\n            [[4, 9, 2], [3, 5, 7], [8, 1, 6]],\\n            [[6, 1, 8], [7, 5, 3], [2, 9, 4]],\\n            [[2, 9, 4], [7, 5, 3], [6, 1, 8]],\\n        ]\\n        \\n        ans = 0\\n        \\n        for x, y, z in itertools.product(range(len(grid[0]) - 2), range(len(grid) - 2), range(8)):\\n            for dx, dy in itertools.product(range(3), range(3)):\\n                if grid[y+dy][x+dx] != squares[z][dy][dx]:\\n                    break\\n            else:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124534,
                "title": "fast-c-solution",
                "content": "```\\npublic int NumMagicSquaresInside(int[][] grid) {\\n        var subGrids = GetSubGrids(grid); \\n        var count = 0; \\n        foreach(var subGrid in subGrids) {\\n            if(IsMagicSquare(subGrid))\\n                count++; \\n        }\\n        return count; \\n    }\\n    private List<int[,]> GetSubGrids(int[][] grid) {\\n        var subGrids = new List<int[,]>(); \\n        for(int row = 0; row < grid.Length - 2; row++) {\\n            for(int col = 0; col < grid[0].Length - 2; col++) {\\n                int[,] magicSquare = new int[3, 3]; \\n                magicSquare[0, 0] = grid[row][col]; \\n                magicSquare[0, 1] = grid[row][col + 1]; \\n                magicSquare[0, 2] = grid[row][col + 2]; \\n                magicSquare[1, 0] = grid[row + 1][col];\\n                magicSquare[1, 1] = grid[row + 1][col + 1]; \\n                magicSquare[1, 2] = grid[row + 1][col + 2]; \\n                magicSquare[2, 0] = grid[row + 2][col];\\n                magicSquare[2, 1] = grid[row + 2][col + 1]; \\n                magicSquare[2 ,2] = grid[row + 2][col + 2]; \\n                subGrids.Add(magicSquare);\\n            }\\n        }\\n        return subGrids; \\n    }\\n    \\n    private bool IsMagicSquare(int[,] grid) {\\n        var mid = grid[1,1]; \\n        \\n        if(mid != 5 || !IsNumbersUniqueInMagicSquare(grid)) \\n            return false;\\n        \\n        var sums = new [] {\\n            grid[0,0] + grid[0,1] + grid[0,2], \\n            grid[1,0] + mid + grid[1,2], \\n            grid[2, 0] + grid[2,1] + grid[2,2], \\n            grid[0,0] + mid + grid[2,2], \\n            grid[0,2] + mid + grid[2,0], \\n            grid[0, 0] + grid[1, 0] + grid[2, 0], \\n            grid[0, 1] + mid + grid[2, 1],  \\n            grid[0, 2] + grid[1, 2] + grid[2, 2]\\n        }; \\n        foreach(var sum in sums) {\\n            if(sum != 15)\\n                return false;   \\n        } \\n        \\n        return true; \\n    }\\n    \\n    private bool IsNumbersUniqueInMagicSquare(int[,] grid) {\\n        HashSet<int> numbers = new HashSet<int>(); \\n        \\n        for(int i = 0; i < grid.GetLength(0); i++) {\\n            for(int j = 0; j < grid.GetLength(1); j++) {\\n                if(grid[i, j] < 1 || grid[i, j] > 10 || numbers.Contains(grid[i, j]))\\n                    return false; \\n                \\n                numbers.Add(grid[i, j]);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumMagicSquaresInside(int[][] grid) {\\n        var subGrids = GetSubGrids(grid); \\n        var count = 0; \\n        foreach(var subGrid in subGrids) {\\n            if(IsMagicSquare(subGrid))\\n                count++; \\n        }\\n        return count; \\n    }\\n    private List<int[,]> GetSubGrids(int[][] grid) {\\n        var subGrids = new List<int[,]>(); \\n        for(int row = 0; row < grid.Length - 2; row++) {\\n            for(int col = 0; col < grid[0].Length - 2; col++) {\\n                int[,] magicSquare = new int[3, 3]; \\n                magicSquare[0, 0] = grid[row][col]; \\n                magicSquare[0, 1] = grid[row][col + 1]; \\n                magicSquare[0, 2] = grid[row][col + 2]; \\n                magicSquare[1, 0] = grid[row + 1][col];\\n                magicSquare[1, 1] = grid[row + 1][col + 1]; \\n                magicSquare[1, 2] = grid[row + 1][col + 2]; \\n                magicSquare[2, 0] = grid[row + 2][col];\\n                magicSquare[2, 1] = grid[row + 2][col + 1]; \\n                magicSquare[2 ,2] = grid[row + 2][col + 2]; \\n                subGrids.Add(magicSquare);\\n            }\\n        }\\n        return subGrids; \\n    }\\n    \\n    private bool IsMagicSquare(int[,] grid) {\\n        var mid = grid[1,1]; \\n        \\n        if(mid != 5 || !IsNumbersUniqueInMagicSquare(grid)) \\n            return false;\\n        \\n        var sums = new [] {\\n            grid[0,0] + grid[0,1] + grid[0,2], \\n            grid[1,0] + mid + grid[1,2], \\n            grid[2, 0] + grid[2,1] + grid[2,2], \\n            grid[0,0] + mid + grid[2,2], \\n            grid[0,2] + mid + grid[2,0], \\n            grid[0, 0] + grid[1, 0] + grid[2, 0], \\n            grid[0, 1] + mid + grid[2, 1],  \\n            grid[0, 2] + grid[1, 2] + grid[2, 2]\\n        }; \\n        foreach(var sum in sums) {\\n            if(sum != 15)\\n                return false;   \\n        } \\n        \\n        return true; \\n    }\\n    \\n    private bool IsNumbersUniqueInMagicSquare(int[,] grid) {\\n        HashSet<int> numbers = new HashSet<int>(); \\n        \\n        for(int i = 0; i < grid.GetLength(0); i++) {\\n            for(int j = 0; j < grid.GetLength(1); j++) {\\n                if(grid[i, j] < 1 || grid[i, j] > 10 || numbers.Contains(grid[i, j]))\\n                    return false; \\n                \\n                numbers.Add(grid[i, j]);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865143,
                "title": "c-optimized-soln-with-detailed-explanation",
                "content": "```\\n// The center of the magic square has to be 5\\n// Total sum = n * (n+1) /2 => 45\\n// 3 rows  = 3 cols = 2 digs = 45. So each row and each col => 15\\n// All lines crossing center => middle row + middle col + diag + anti-diag = 15 + 15+ 15+ 15 => 60\\n// top element of middle col + diag + anti diag = 15\\n// similarly bottom elment of middle col + diag + anti diag = 15\\n// so middle row + 3 * center value = 60 - 15 - 15 = 30\\n// 3* center value = 15 => center value = 5.\\n// Scan the grid and every time we see a 5, check the 3*3 matrix formed with 5 in middle is a magic square\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n        var row = grid.Length;\\n        var col = row > 0 ? grid[0].Length : 0;\\n        \\n        if(row < 3 || col < 3)\\n            return 0;\\n        \\n        var sq = 0;\\n        for(var i = 0; i < row ; i++)\\n            for(var j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 5 && IsMagicSquare((i, j), row, col, grid))\\n                    sq++;                    \\n            }\\n        \\n        return sq;\\n    }\\n    \\n    private bool IsMagicSquare((int Row, int Col) centerPoint, int row, int col, int[][] grid)\\n    {\\n        if(centerPoint.Row - 1 < 0\\n           || centerPoint.Row + 1 >= row \\n           || centerPoint.Col - 1 < 0\\n           || centerPoint.Col + 1 >= col)\\n            return false;\\n        \\n        // Row sum\\n        var allDigits = new bool[9];\\n        for(var i = centerPoint.Row - 1; i <= centerPoint.Row + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Col - 1; j <= centerPoint.Col + 1; j++)\\n            {\\n                sum += grid[i][j];\\n                \\n                // Digits shd be in range of 1..9\\n                if(grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                \\n                allDigits[grid[i][j] - 1] = true;\\n            }\\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // All digits needs to be present\\n        if(allDigits.Any(d => !d))\\n            return false;\\n        \\n        // Col sum\\n        for(var i = centerPoint.Col - 1; i <= centerPoint.Col + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Row - 1; j <= centerPoint.Row + 1; j++)\\n            {\\n                sum += grid[j][i];\\n            }\\n            \\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // diag and anti-diag\\n        if(grid[centerPoint.Row-1][centerPoint.Col-1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col+1] != 15)\\n            return false;\\n        \\n        if(grid[centerPoint.Row-1][centerPoint.Col+1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col-1] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// The center of the magic square has to be 5\\n// Total sum = n * (n+1) /2 => 45\\n// 3 rows  = 3 cols = 2 digs = 45. So each row and each col => 15\\n// All lines crossing center => middle row + middle col + diag + anti-diag = 15 + 15+ 15+ 15 => 60\\n// top element of middle col + diag + anti diag = 15\\n// similarly bottom elment of middle col + diag + anti diag = 15\\n// so middle row + 3 * center value = 60 - 15 - 15 = 30\\n// 3* center value = 15 => center value = 5.\\n// Scan the grid and every time we see a 5, check the 3*3 matrix formed with 5 in middle is a magic square\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n        var row = grid.Length;\\n        var col = row > 0 ? grid[0].Length : 0;\\n        \\n        if(row < 3 || col < 3)\\n            return 0;\\n        \\n        var sq = 0;\\n        for(var i = 0; i < row ; i++)\\n            for(var j = 0; j < col; j++)\\n            {\\n                if(grid[i][j] == 5 && IsMagicSquare((i, j), row, col, grid))\\n                    sq++;                    \\n            }\\n        \\n        return sq;\\n    }\\n    \\n    private bool IsMagicSquare((int Row, int Col) centerPoint, int row, int col, int[][] grid)\\n    {\\n        if(centerPoint.Row - 1 < 0\\n           || centerPoint.Row + 1 >= row \\n           || centerPoint.Col - 1 < 0\\n           || centerPoint.Col + 1 >= col)\\n            return false;\\n        \\n        // Row sum\\n        var allDigits = new bool[9];\\n        for(var i = centerPoint.Row - 1; i <= centerPoint.Row + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Col - 1; j <= centerPoint.Col + 1; j++)\\n            {\\n                sum += grid[i][j];\\n                \\n                // Digits shd be in range of 1..9\\n                if(grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                \\n                allDigits[grid[i][j] - 1] = true;\\n            }\\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // All digits needs to be present\\n        if(allDigits.Any(d => !d))\\n            return false;\\n        \\n        // Col sum\\n        for(var i = centerPoint.Col - 1; i <= centerPoint.Col + 1; i++)\\n        {\\n            var sum = 0;\\n            for(var j = centerPoint.Row - 1; j <= centerPoint.Row + 1; j++)\\n            {\\n                sum += grid[j][i];\\n            }\\n            \\n            if(sum != 15)\\n                return false;\\n        }\\n        \\n        // diag and anti-diag\\n        if(grid[centerPoint.Row-1][centerPoint.Col-1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col+1] != 15)\\n            return false;\\n        \\n        if(grid[centerPoint.Row-1][centerPoint.Col+1]\\n           + grid[centerPoint.Row][centerPoint.Col]\\n           +grid[centerPoint.Row+1][centerPoint.Col-1] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792469,
                "title": "question-about-a-test-case-i-am-not-seeing",
                "content": "The test case I got stuck on is when input is [[10,3,5],[1,6,11],[7,9,2]]\\n\\nBoth row, column, and diag is equal is 18. How is this wrong?\\n\\nThe problem states that the numbers are from 1-9, but in the test cases 0 <= grid[i][j] <= 15 ????\\n\\n\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        // 840\\n        //1 : check row\\n        //2: check colum\\n        //3: chcek diag\\n        // m x n ; m can be any and so can n\\n        // all sum = same\\n        //all nums have to be unique\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int count = 0;\\n        \\n        for(int x = 0; x < m -2; x++){\\n            for(int y = 0; y < n -2; y++){\\n                count+=check(grid,x,y);\\n            }\\n        }\\n        \\n        return count;\\n    }\\nprivate:\\n    int check(vector<vector<int>>& grid, int m, int n){\\n        printf(\"called\");\\n        vector<bool> number(15,false);//check all 15 people\\n        int sum = grid[m][n]+grid[m+1][n+1]+grid[m+2][n+2]; //check diag\\n        if(sum!=grid[m][n+2]+grid[m+1][n+1]+grid[m+2][n]) return 0;\\n        for(int i = 0; i < 3; i++){ //check x axis\\n            if(sum!=grid[m+i][n]+grid[m+i][n+1]+grid[m+i][n+2]) return 0;\\n            if(sum!=grid[m][n+i]+grid[m+1][n+i]+grid[m+2][n+i]) return 0;\\n            //also need to see if all the numbers are unique\\n            if(number[grid[m+i][n]] || number[grid[m+i][n+1]] || number[grid[m+i][n+2]]) return 0;\\n            number[grid[m+i][n]] = true;\\n            number[grid[m+i][n+1]] = true;\\n            number[grid[m+i][n+2]] = true;\\n        }\\n\\n        return 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        // 840\\n        //1 : check row\\n        //2: check colum\\n        //3: chcek diag\\n        // m x n ; m can be any and so can n\\n        // all sum = same\\n        //all nums have to be unique\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int count = 0;\\n        \\n        for(int x = 0; x < m -2; x++){\\n            for(int y = 0; y < n -2; y++){\\n                count+=check(grid,x,y);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 789919,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\tpublic int numMagicSquaresInside(int[][] grid) {\\n     \\n\\t\\tint rows = grid.length;\\n\\t\\tint cols = grid[0].length;\\n\\t\\t\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i + 3 <= rows; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 0; j + 3<= cols; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ismGrid =  isMagicGrid(grid, i, j);\\n\\t\\t\\t\\tif(ismGrid == true)\\n\\t\\t\\t\\t\\tresult += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn result;\\n    }\\n\\tprivate boolean isMagicGrid(int[][] grid, int row, int col) {\\n\\t\\tint[] arr = new int[10];\\n    for (int i = row; i < row + 3; i++) {\\n        for (int j = col; j < col + 3; j++) {\\n            if (grid[i][j] < 1 || grid[i][j] > 9 || arr[grid[i][j]] > 0) {\\n                return false;\\n            }\\n            arr[grid[i][j]] = 1;\\n        }\\n    }\\n\\n\\t\\tint sumDiagonal = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n\\t\\tint sumOppDiagonal = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n\\t\\t\\n\\t\\tif(sumDiagonal != sumOppDiagonal)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tint i =0;\\n\\t\\twhile(i < 3)\\n\\t\\t{\\n\\t\\t\\tint sum = grid[row+i][col] + grid[row+i][col+1] + grid[row+i][col+2];\\n\\t\\t\\t\\n\\t\\t\\tif(sum != sumDiagonal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint j = 0;\\n\\t\\twhile(j < 3)\\n\\t\\t{\\n\\t\\t\\tint sum = grid[row][col+j] + grid[row+1][col+j] + grid[row+2][col+j];\\n\\t\\t\\tif(sum != sumDiagonal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic int numMagicSquaresInside(int[][] grid) {\\n     \\n\\t\\tint rows = grid.length;\\n\\t\\tint cols = grid[0].length;\\n\\t\\t\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i + 3 <= rows; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j = 0; j + 3<= cols; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ismGrid =  isMagicGrid(grid, i, j);\\n\\t\\t\\t\\tif(ismGrid == true)\\n\\t\\t\\t\\t\\tresult += 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 572672,
                "title": "java-simple-beats-100-runtime-and-space",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        final int row = grid.length;\\n        final int col = grid[0].length;\\n        int res = 0;\\n        for(int r = 0; r < row-2; r++){\\n            for(int c = 0; c < col-2; c++){\\n                if(grid[r+1][c+1] != 5) continue;\\n                if(magic(grid[r][c], grid[r][c+1], grid[r][c+2], grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2], grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2])) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean magic(int... vals){\\n        Set<Integer> uniqs = new HashSet<>();\\n        for(int v : vals){\\n            if(uniqs.contains(v) || v > 9 || v < 1) return false;\\n            uniqs.add(v);\\n        }\\n        return (vals[0] + vals[1] + vals[2] == 15 &&\\n                vals[3] + vals[4] + vals[5] == 15 &&\\n                vals[6] + vals[7] + vals[8] == 15 &&\\n                vals[0] + vals[3] + vals[6] == 15 &&\\n                vals[1] + vals[4] + vals[7] == 15 &&\\n                vals[2] + vals[5] + vals[8] == 15 &&\\n                vals[0] + vals[4] + vals[8] == 15 &&\\n                vals[2] + vals[4] + vals[6] == 15);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        final int row = grid.length;\\n        final int col = grid[0].length;\\n        int res = 0;\\n        for(int r = 0; r < row-2; r++){\\n            for(int c = 0; c < col-2; c++){\\n                if(grid[r+1][c+1] != 5) continue;\\n                if(magic(grid[r][c], grid[r][c+1], grid[r][c+2], grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2], grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2])) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean magic(int... vals){\\n        Set<Integer> uniqs = new HashSet<>();\\n        for(int v : vals){\\n            if(uniqs.contains(v) || v > 9 || v < 1) return false;\\n            uniqs.add(v);\\n        }\\n        return (vals[0] + vals[1] + vals[2] == 15 &&\\n                vals[3] + vals[4] + vals[5] == 15 &&\\n                vals[6] + vals[7] + vals[8] == 15 &&\\n                vals[0] + vals[3] + vals[6] == 15 &&\\n                vals[1] + vals[4] + vals[7] == 15 &&\\n                vals[2] + vals[5] + vals[8] == 15 &&\\n                vals[0] + vals[4] + vals[8] == 15 &&\\n                vals[2] + vals[4] + vals[6] == 15);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557666,
                "title": "python-easy",
                "content": "Note that this does not check the diagonals and it seems that it is enough for the all of the test cases\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        # for each 5 check if there is a magic square around\\n        # and the total should be 15\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                #five is the col index\\n                #rowix is the row index of number five\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n                #check if this subgrid is a magic square\\n\\n                \\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n                \\n        return count                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        # for each 5 check if there is a magic square around\\n        # and the total should be 15\\n        count = 0\\n        numset=set(range(1,10))\\n        for rowix in range(1,len(grid)-1):\\n            row =grid[rowix]\\n            fiveix = [ix for ix in range(1, len(row)-1) if row[ix] == 5]\\n            for five in fiveix:\\n                #five is the col index\\n                #rowix is the row index of number five\\n                subgrid = [row[five-1:five+2] for row in grid]\\n                subgrid = subgrid[rowix-1:rowix+2]\\n                #check if this subgrid is a magic square\\n\\n                \\n                flatgrid=set([item for row in subgrid for item in row])\\n                diff = numset-flatgrid\\n                \\n                row_sum = [1 if sum(row)==15 else 0 for row in subgrid]\\n                col_sum = [1 if sum(col)==15 else 0 for col in zip(*subgrid)]\\n                if sum(row_sum) == 3 and sum(col_sum)==3 and len(diff)==0:\\n                    count +=1\\n                \\n                \\n        return count                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 538492,
                "title": "my-java-sol-beats-100",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(check(i,j,grid))count++;\\n            }\\n        }return count;\\n        \\n    }\\n    private boolean check(int i, int j, int[][] grid){\\n        int[] temp = new int[10];\\n         for (int k = i; k < i + 3; k++) {\\n            for (int l = j; l < j + 3; l++) {\\n                if (grid[k][l] < 1 || grid[k][l] > 9 || temp[grid[k][l]] > 0) {\\n                    return false;\\n                }\\n                temp[grid[k][l]] = 1;\\n            }\\n        }\\n        return grid[i][j]+grid[i+1][j]+grid[i+2][j]==15 &&\\n                grid[i][j]+grid[i][j+1]+grid[i][j+2]==15 &&\\n                grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]==15 &&\\n                grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]==15 &&\\n                grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]==15 &&\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]==15;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(check(i,j,grid))count++;\\n            }\\n        }return count;\\n        \\n    }\\n    private boolean check(int i, int j, int[][] grid){\\n        int[] temp = new int[10];\\n         for (int k = i; k < i + 3; k++) {\\n            for (int l = j; l < j + 3; l++) {\\n                if (grid[k][l] < 1 || grid[k][l] > 9 || temp[grid[k][l]] > 0) {\\n                    return false;\\n                }\\n                temp[grid[k][l]] = 1;\\n            }\\n        }\\n        return grid[i][j]+grid[i+1][j]+grid[i+2][j]==15 &&\\n                grid[i][j]+grid[i][j+1]+grid[i][j+2]==15 &&\\n                grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]==15 &&\\n                grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]==15 &&\\n                grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]==15 &&\\n                grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15 &&\\n                grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]==15;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515676,
                "title": "use-two-way-map-to-match",
                "content": "```\\nclass Solution {\\n    private Map<Integer, Integer> map;\\n    private Map<Integer, Integer> mapRev;\\n    private Set<Integer> st;\\n    public int numMagicSquaresInside(int[][] g) {\\n        int res = 0, m = g.length, n = g[0].length;\\n        int k = 0;\\n        int[] arr = {4,3,8,1,6,7,2,9};\\n        map = new HashMap<>();\\n        mapRev = new HashMap<>();\\n        st = new HashSet<>();\\n        for (int i : arr){\\n            map.put(i, k);\\n            mapRev.put(k++, i);\\n            st.add(i);\\n        }\\n        for (int i = 0; i < m - 2; i++) {\\n            for(int j = 0; j < n - 2; j++) {\\n                if (g[i+1][j+1] != 5) continue; \\n                if (isPerf(g, i, j)) res++; \\n            }\\n        }\\n        return res;\\n    }\\n\\n    \\n    private boolean isPerf(int[][] g, int i, int j){\\n        if (g[i][j] % 2 != 0 || (!st.contains(g[i][j]))) return false;\\n        int start = map.get(g[i][j]);\\n        int rev = start;\\n        boolean counter = false;\\n        int[] arr = {0, 1, 2, 5, 8, 7, 6, 3};\\n        for ( int x : arr) {\\n            if(start > 7) start = 0;\\n            if(rev < 0) rev = 7;\\n            int curr = g[i + x / 3][j + x % 3];\\n            if (!st.contains(curr)) return false;\\n            if (x == 1) {\\n                if (curr != mapRev.get(start)) counter = true;\\n                if (counter && (curr != mapRev.get(rev))) return false;\\n                start++;\\n                rev--;\\n                continue;\\n            }\\n            \\n            if (!counter && (curr != mapRev.get(start))) return false;\\n            if (counter && (curr != mapRev.get(rev))) return false;\\n            start++;\\n            rev--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer, Integer> map;\\n    private Map<Integer, Integer> mapRev;\\n    private Set<Integer> st;\\n    public int numMagicSquaresInside(int[][] g) {\\n        int res = 0, m = g.length, n = g[0].length;\\n        int k = 0;\\n        int[] arr = {4,3,8,1,6,7,2,9};\\n        map = new HashMap<>();\\n        mapRev = new HashMap<>();\\n        st = new HashSet<>();\\n        for (int i : arr){\\n            map.put(i, k);\\n            mapRev.put(k++, i);\\n            st.add(i);\\n        }\\n        for (int i = 0; i < m - 2; i++) {\\n            for(int j = 0; j < n - 2; j++) {\\n                if (g[i+1][j+1] != 5) continue; \\n                if (isPerf(g, i, j)) res++; \\n            }\\n        }\\n        return res;\\n    }\\n\\n    \\n    private boolean isPerf(int[][] g, int i, int j){\\n        if (g[i][j] % 2 != 0 || (!st.contains(g[i][j]))) return false;\\n        int start = map.get(g[i][j]);\\n        int rev = start;\\n        boolean counter = false;\\n        int[] arr = {0, 1, 2, 5, 8, 7, 6, 3};\\n        for ( int x : arr) {\\n            if(start > 7) start = 0;\\n            if(rev < 0) rev = 7;\\n            int curr = g[i + x / 3][j + x % 3];\\n            if (!st.contains(curr)) return false;\\n            if (x == 1) {\\n                if (curr != mapRev.get(start)) counter = true;\\n                if (counter && (curr != mapRev.get(rev))) return false;\\n                start++;\\n                rev--;\\n                continue;\\n            }\\n            \\n            if (!counter && (curr != mapRev.get(start))) return false;\\n            if (counter && (curr != mapRev.get(rev))) return false;\\n            start++;\\n            rev--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507719,
                "title": "c-100-runtime-75-mem",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    \\n    bool checkRowSum(vector<vector<int>> & grid, int x, int y, int sum){\\n        for (int i=x;i<x+3;i++){\\n            int rowSum = 0;\\n            for (int j=y;j<y+3;j++){\\n                rowSum+= grid[i][j];\\n            }\\n            if (rowSum != sum)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool checkColSum(vector<vector<int>> & grid, int x, int y, int sum){\\n        for (int j=y;j<y+3;j++){\\n            int colSum = 0;\\n            for (int i=x;i<x+3;i++){\\n                colSum +=grid[i][j];\\n            }\\n            if (colSum != sum)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool checkDiagSum(vector<vector<int>> & grid, int x, int y, int sum){\\n       \\n        if (  (grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2] != sum) && (grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y] != sum) )\\n            return false;\\n        return true;\\n       \\n    }\\n    \\n    bool checkOneToNine(vector<vector<int>> & grid, int x, int y, int sum){\\n        unordered_set<int> u_set;\\n        for (int i=x;i<x+3;i++){\\n            for (int j=y;j<y+3;j++){\\n                if (grid[i][j] >=1 && grid[i][j] <= 9){\\n                    if (u_set.find(grid[i][j]) != u_set.end())\\n                        return false;\\n                    else\\n                        u_set.insert(grid[i][j]);\\n                        \\n                }\\n                else\\n                    return false;\\n            }\\n        }\\n        if(u_set.size() == 9)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isMagicSquare(vector<vector<int>> & grid, int x, int y){\\n        bool isMagic = false;\\n        int sum = grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2];\\n\\n        // cout << x << \" \" << y<< \" \" << sum << \" \" << checkRowSum(grid,x,y, sum) << \" \" << checkColSum(grid,x,y, sum) << \" \" << checkDiagSum(grid, x, y, sum)  << \" \" << checkOneToNine( grid,x, y, sum) << \"\\\\n\";\\n        if (checkRowSum(grid,x,y, sum) && checkColSum(grid,x,y, sum) && checkDiagSum(grid, x, y, sum) && checkOneToNine( grid,x, y, sum))\\n            isMagic =true;\\n        return isMagic;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (m*n < 9)\\n            return 0;\\n        int count = 0;\\n        for (int i=0;i<=m-3;i++){\\n            for (int j=0;j<=n-3;j++){\\n                if(isMagicSquare(grid, i, j))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    bool checkRowSum(vector<vector<int>> & grid, int x, int y, int sum){\\n        for (int i=x;i<x+3;i++){\\n            int rowSum = 0;\\n            for (int j=y;j<y+3;j++){\\n                rowSum+= grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 500848,
                "title": "python-solution-less-than-100-memory-usage",
                "content": "Yes, it is indeed a boring question. Below is my version of solution.\\n\\n```\\ndef numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ct=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                if isSubGridMagic(grid,i,j):\\n                    ct+=1\\n        return ct\\n\\ndef isSubGridMagic(grid,i,j): \\n    nums = set(grid[a][b] for b in range(j,j+3) for a in range(i,i+3) if grid[a][b]>=1 and grid[a][b]<=9)\\n    a = grid[i][j:j+3]\\n    b = grid[i+1][j:j+3]\\n    c = grid[i+2][j:j+3]\\n    d = [grid[x][j] for x in range(i,i+3)]\\n    e = [grid[x][j+1] for x in range(i,i+3)]\\n    f = [grid[x][j+2] for x in range(i,i+3)]\\n    g = [grid[x+i][y+j] for x in range(3) for y in range(3) if x==y]\\n    h = [grid[x+i][y+j] for x in range(2,-1,-1) for y in range(3) if x+y==2]\\n    if sum(a)==sum(b)==sum(c) == sum(d)==sum(e)==sum(f)==sum(g)==sum(h) and len(nums)==9:\\n        return True\\n    else:\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ct=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):\\n                if isSubGridMagic(grid,i,j):\\n                    ct+=1\\n        return ct\\n\\ndef isSubGridMagic(grid,i,j): \\n    nums = set(grid[a][b] for b in range(j,j+3) for a in range(i,i+3) if grid[a][b]>=1 and grid[a][b]<=9)\\n    a = grid[i][j:j+3]\\n    b = grid[i+1][j:j+3]\\n    c = grid[i+2][j:j+3]\\n    d = [grid[x][j] for x in range(i,i+3)]\\n    e = [grid[x][j+1] for x in range(i,i+3)]\\n    f = [grid[x][j+2] for x in range(i,i+3)]\\n    g = [grid[x+i][y+j] for x in range(3) for y in range(3) if x==y]\\n    h = [grid[x+i][y+j] for x in range(2,-1,-1) for y in range(3) if x+y==2]\\n    if sum(a)==sum(b)==sum(c) == sum(d)==sum(e)==sum(f)==sum(g)==sum(h) and len(nums)==9:\\n        return True\\n    else:\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 416921,
                "title": "python-brute-force-in-place-in-case-anybody-wants-to-practice-basics",
                "content": "```\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def ismagic(grid, x, y):\\n            flat = [grid[x+i][y+j] for i in (-1, 0, 1) for j in (-1, 0, 1)]\\n            if set(flat) != {1, 2, 3, 4, 5, 6, 7, 8, 9}:\\n                return False\\n            rsums = [sum(grid[x+i][y+j] for j in (-1, 0, 1)) for i in (-1, 0, 1)]\\n            csums = [sum(grid[x+i][y+j] for i in (-1, 0, 1)) for j in (-1, 0, 1)]\\n            dsums = [sum(grid[x-i][y-i] for i in (-1, 0, 1)), sum(grid[x+i][y-i] for i in (-1, 0, 1))]\\n            sums = rsums + csums + dsums\\n            return len(set(sums)) == 1\\n     \\n        rst = 0\\n        for i in range(1, len(grid) - 1):\\n            for j in range(1, len(grid) - 1):\\n                if ismagic(grid, i, j):\\n                    rst += 1\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def ismagic(grid, x, y):\\n            flat = [grid[x+i][y+j] for i in (-1, 0, 1) for j in (-1, 0, 1)]\\n            if set(flat) != {1, 2, 3, 4, 5, 6, 7, 8, 9}:\\n                return False\\n            rsums = [sum(grid[x+i][y+j] for j in (-1, 0, 1)) for i in (-1, 0, 1)]\\n            csums = [sum(grid[x+i][y+j] for i in (-1, 0, 1)) for j in (-1, 0, 1)]\\n            dsums = [sum(grid[x-i][y-i] for i in (-1, 0, 1)), sum(grid[x+i][y-i] for i in (-1, 0, 1))]\\n            sums = rsums + csums + dsums\\n            return len(set(sums)) == 1\\n     \\n        rst = 0\\n        for i in range(1, len(grid) - 1):\\n            for j in range(1, len(grid) - 1):\\n                if ismagic(grid, i, j):\\n                    rst += 1\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 381223,
                "title": "two-solutions-in-python-3-beats-99-two-lines",
                "content": "_Two-Line Solution:_ (beats ~99%)\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n    \\tM, N, S, t = len(G)-2, len(G[0])-2, {(8,1,6,3,5,7,4,9,2),(6,1,8,7,5,3,2,9,4),(2,7,6,9,5,1,4,3,8),(6,7,2,1,5,9,8,3,4)}, range(3)\\n    \\treturn sum((lambda x: x in S or x[::-1] in S)(tuple(sum([G[i+k][j:j+3] for k in t],[]))) for i,j in itertools.product(range(M),range(N)))\\n\\n\\n```\\n_Standard Solution_: (beats ~94%)\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n    \\tM, N, S, t, s = len(G), len(G[0]), set(range(1,10)), range(3), 0\\n    \\tfor i in range(M-2):\\n    \\t\\tfor j in range(N-2):\\n    \\t\\t\\tg = [G[i+k][j:j+3] for k in t]\\n    \\t\\t\\tif set(sum(g,[])) != S or g[1][1] != 5: continue\\n    \\t\\t\\tif any(sum(g[k]) != 15 for k in t) or any(sum([g[k][l] for k in t]) != 15 for l in t): continue\\n    \\t\\t\\tif sum([g[k][k] for k in t]) != 15 or sum([g[k][2-k] for k in t]) != 15: continue\\n    \\t\\t\\ts += 1\\n    \\treturn s\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, G: List[List[int]]) -> int:\\n    \\tM, N, S, t = len(G)-2, len(G[0])-2, {(8,1,6,3,5,7,4,9,2),(6,1,8,7,5,3,2,9,4),(2,7,6,9,5,1,4,3,8),(6,7,2,1,5,9,8,3,4)}, range(3)\\n    \\treturn sum((lambda x: x in S or x[::-1] in S)(tuple(sum([G[i+k][j:j+3] for k in t],[]))) for i,j in itertools.product(range(M),range(N)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378498,
                "title": "python-solution-brute-force",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def chk(lst):\\n            t=[]\\n            for i in lst:\\n                t+=i\\n            if sorted(t)!=[x for x in range(1,10)]:return False\\n            ls=list(zip(*lst))\\n            s=sum(lst[0])\\n            su=0\\n            su1=0\\n            for i in range(3):\\n                if sum(lst[i])!=s:return False\\n                if sum(ls[i])!=s:return False\\n                su+=lst[i][i]\\n                su1+=lst[i][2-i]\\n            if su!=s or su1!=s:return False\\n            return True\\n        count=0\\n        r=len(grid)\\n        c=len(grid[0])\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                lst=[]\\n                lst.append(grid[i][j:j+3])\\n                lst.append(grid[i+1][j:j+3])\\n                lst.append(grid[i+2][j:j+3])\\n                m=chk(lst)\\n                if m:count+=1\\n        return count\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def chk(lst):\\n            t=[]\\n            for i in lst:\\n                t+=i\\n            if sorted(t)!=[x for x in range(1,10)]:return False\\n            ls=list(zip(*lst))\\n            s=sum(lst[0])\\n            su=0\\n            su1=0\\n            for i in range(3):\\n                if sum(lst[i])!=s:return False\\n                if sum(ls[i])!=s:return False\\n                su+=lst[i][i]\\n                su1+=lst[i][2-i]\\n            if su!=s or su1!=s:return False\\n            return True\\n        count=0\\n        r=len(grid)\\n        c=len(grid[0])\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                lst=[]\\n                lst.append(grid[i][j:j+3])\\n                lst.append(grid[i+1][j:j+3])\\n                lst.append(grid[i+2][j:j+3])\\n                m=chk(lst)\\n                if m:count+=1\\n        return count\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 337418,
                "title": "php-solution-beats-100",
                "content": "I started with mathematical solutions, then saw there really aren\\'t that many possibilities.\\n\\nRuntime: 4 ms, faster than 100.00% of PHP online submissions\\nMemory Usage: 14.9 MB, less than 100.00% of PHP online submissions\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $grid\\n     * @return Integer\\n     */\\n    function numMagicSquaresInside($grid)\\n    {\\n        list($cols, $rows) = [count($grid[0]), count($grid)];\\n        if ($cols < 3 || $rows < 3) return 0;\\n        $result = 0;\\n        for ($i = 0; $i < $rows - 2; $i++) {\\n            for ($j = 0; $j < $cols - 2; $j++) {\\n                if (5 !== $grid[$i + 1][$j + 1]) continue;\\n                $perimiter = $grid[$i][$j] .\\n                    $grid[$i][$j + 1] .\\n                    $grid[$i][$j + 2] .\\n                    $grid[$i + 1][$j] .\\n                    $grid[$i + 1][$j + 2] .\\n                    $grid[$i + 2][$j] .\\n                    $grid[$i + 2][$j + 1] .\\n                    $grid[$i + 2][$j + 2];\\n                if (\\n                    $perimiter === \\'29473618\\' ||\\n                    $perimiter === \\'67219834\\' ||\\n                    $perimiter === \\'81637492\\' ||\\n                    $perimiter === \\'43891276\\' ||\\n                    $perimiter === \\'27691438\\' ||\\n                    $perimiter === \\'49237816\\' ||\\n                    $perimiter === \\'83419672\\' ||\\n                    $perimiter === \\'61873294\\'\\n                ) $result++;\\n            }\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $grid\\n     * @return Integer\\n     */\\n    function numMagicSquaresInside($grid)\\n    {\\n        list($cols, $rows) = [count($grid[0]), count($grid)];\\n        if ($cols < 3 || $rows < 3) return 0;\\n        $result = 0;\\n        for ($i = 0; $i < $rows - 2; $i++) {\\n            for ($j = 0; $j < $cols - 2; $j++) {\\n                if (5 !== $grid[$i + 1][$j + 1]) continue;\\n                $perimiter = $grid[$i][$j] .\\n                    $grid[$i][$j + 1] .\\n                    $grid[$i][$j + 2] .\\n                    $grid[$i + 1][$j] .\\n                    $grid[$i + 1][$j + 2] .\\n                    $grid[$i + 2][$j] .\\n                    $grid[$i + 2][$j + 1] .\\n                    $grid[$i + 2][$j + 2];\\n                if (\\n                    $perimiter === \\'29473618\\' ||\\n                    $perimiter === \\'67219834\\' ||\\n                    $perimiter === \\'81637492\\' ||\\n                    $perimiter === \\'43891276\\' ||\\n                    $perimiter === \\'27691438\\' ||\\n                    $perimiter === \\'49237816\\' ||\\n                    $perimiter === \\'83419672\\' ||\\n                    $perimiter === \\'61873294\\'\\n                ) $result++;\\n            }\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309842,
                "title": "java-hashset-1-ms-faster-than-51-84-34-4-mb-less-than-100",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int diagSum = 0;\\n        int rowSum = 0;\\n        int columnSum = 0;\\n        int count = 0;\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i=0; i<grid.length-2; i++) {            \\n            for(int j=0; j<grid[0].length-2; j++)\\n            {\\n                set = new HashSet<Integer>();\\n                rowSum = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n                diagSum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n                columnSum = grid[i][j] + grid[i+1][j] + grid[i+2][j];               \\n                \\n                if((rowSum == diagSum) && (rowSum == columnSum))\\n                {\\n                    for(int x=i; x<i+3; x++)\\n                        for(int y=j; y<j+3; y++)\\n                            if(grid[x][y] > 0 && grid[x][y] < 10)\\n                                set.add(grid[x][y]);\\n                    \\n                    if(set.size() == 9)\\n                        count++;\\n                }                   \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int diagSum = 0;\\n        int rowSum = 0;\\n        int columnSum = 0;\\n        int count = 0;\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i=0; i<grid.length-2; i++) {            \\n            for(int j=0; j<grid[0].length-2; j++)\\n            {\\n                set = new HashSet<Integer>();\\n                rowSum = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n                diagSum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n                columnSum = grid[i][j] + grid[i+1][j] + grid[i+2][j];               \\n                \\n                if((rowSum == diagSum) && (rowSum == columnSum))\\n                {\\n                    for(int x=i; x<i+3; x++)\\n                        for(int y=j; y<j+3; y++)\\n                            if(grid[x][y] > 0 && grid[x][y] < 10)\\n                                set.add(grid[x][y]);\\n                    \\n                    if(set.size() == 9)\\n                        count++;\\n                }                   \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302082,
                "title": "python-stupid-solution",
                "content": "```python \\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        def isMagic(grid):\\n            #d = set(grid)\\n            #print(d)\\n            d = set()\\n            s = sum(grid[0])\\n            diag1 = 0\\n            diag2 = 0\\n            for i in range(0,3):\\n                if sum(grid[i]) != s:\\n                    return False\\n                #col_s = 0\\n                for j in range(0,3):\\n                    col_s = grid[0][j]+grid[1][j]+grid[2][j]\\n                    if col_s != s:\\n                        return False\\n                    if grid[i][j]>9 or grid[i][j]<1:\\n                        return False\\n                    else:\\n                        d.add(grid[i][j])\\n            for k in range(0,3):\\n                diag1 += grid[k][k]\\n                diag2 += grid[k][2-k]\\n            if diag1 != s or diag2 != s:\\n                return False\\n            if len(d) != 9:\\n                return False\\n            \\n            return True\\n        \\n        count = 0\\n        for i in range(0,len(grid)-2):\\n            #print(\"debug\")\\n            for j in range(0,len(grid[0])-2):\\n                cur_grid = []\\n                for k in range(3):\\n                    #print(grid[0,0:2])\\n                    cur_grid.append(grid[i+k][j:j+3])\\n                #print(cur_grid)\\n                if isMagic(cur_grid):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python \\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        def isMagic(grid):\\n            #d = set(grid)\\n            #print(d)\\n            d = set()\\n            s = sum(grid[0])\\n            diag1 = 0\\n            diag2 = 0\\n            for i in range(0,3):\\n                if sum(grid[i]) != s:\\n                    return False\\n                #col_s = 0\\n                for j in range(0,3):\\n                    col_s = grid[0][j]+grid[1][j]+grid[2][j]\\n                    if col_s != s:\\n                        return False\\n                    if grid[i][j]>9 or grid[i][j]<1:\\n                        return False\\n                    else:\\n                        d.add(grid[i][j])\\n            for k in range(0,3):\\n                diag1 += grid[k][k]\\n                diag2 += grid[k][2-k]\\n            if diag1 != s or diag2 != s:\\n                return False\\n            if len(d) != 9:\\n                return False\\n            \\n            return True\\n        \\n        count = 0\\n        for i in range(0,len(grid)-2):\\n            #print(\"debug\")\\n            for j in range(0,len(grid[0])-2):\\n                cur_grid = []\\n                for k in range(3):\\n                    #print(grid[0,0:2])\\n                    cur_grid.append(grid[i+k][j:j+3])\\n                #print(cur_grid)\\n                if isMagic(cur_grid):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216579,
                "title": "clean-and-readable-solution",
                "content": "```\\n    private boolean isValid(int a1, int a2, int a3, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0) || (a3 > 9 || a3 < 0)) return false;\\n        if (a1 == a2 || a1 == a3 || a2 == a3) return false;\\n        return (a1 + a2 + a3 == sum);\\n    }\\n\\n    private boolean isValid(int a1, int a2, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0)) return false;\\n        return (a1 != a2 && a1 + a2 == sum);\\n    }\\n\\n    public int numMagicSquaresInside(int[][] A) {\\n        int M = A.length, N = A[0].length, count = 0;\\n        for (int i = 1; i < M-1; i++) {\\n            for (int j = 1; j < N-1; j++) {\\n                // center\\n                if (A[i][j] != 5) continue;\\n                // row\\n                if (!isValid(A[i-1][j-1], A[i-1][j],A[i-1][j+1], 15)) continue;\\n                if (!isValid(A[i+1][j-1], A[i+1][j], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i][j-1], A[i][j+1], 10)) continue;\\n                // column\\n                if (!isValid(A[i-1][j-1], A[i][j-1], A[i+1][j-1], 15)) continue;\\n                if (!isValid(A[i-1][j+1], A[i][j+1], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i-1][j], A[i+1][j], 10)) continue;\\n                // diagonal\\n                if (!isValid(A[i-1][j-1], A[i+1][j+1], 10)) continue;\\n                if (!isValid(A[i-1][j+1], A[i+1][j-1], 10)) continue;\\n\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private boolean isValid(int a1, int a2, int a3, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0) || (a3 > 9 || a3 < 0)) return false;\\n        if (a1 == a2 || a1 == a3 || a2 == a3) return false;\\n        return (a1 + a2 + a3 == sum);\\n    }\\n\\n    private boolean isValid(int a1, int a2, int sum) {\\n        if ((a1 > 9 || a1 < 0) || (a2 > 9 || a2 < 0)) return false;\\n        return (a1 != a2 && a1 + a2 == sum);\\n    }\\n\\n    public int numMagicSquaresInside(int[][] A) {\\n        int M = A.length, N = A[0].length, count = 0;\\n        for (int i = 1; i < M-1; i++) {\\n            for (int j = 1; j < N-1; j++) {\\n                // center\\n                if (A[i][j] != 5) continue;\\n                // row\\n                if (!isValid(A[i-1][j-1], A[i-1][j],A[i-1][j+1], 15)) continue;\\n                if (!isValid(A[i+1][j-1], A[i+1][j], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i][j-1], A[i][j+1], 10)) continue;\\n                // column\\n                if (!isValid(A[i-1][j-1], A[i][j-1], A[i+1][j-1], 15)) continue;\\n                if (!isValid(A[i-1][j+1], A[i][j+1], A[i+1][j+1], 15)) continue;\\n                if (!isValid(A[i-1][j], A[i+1][j], 10)) continue;\\n                // diagonal\\n                if (!isValid(A[i-1][j-1], A[i+1][j+1], 10)) continue;\\n                if (!isValid(A[i-1][j+1], A[i+1][j-1], 10)) continue;\\n\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181626,
                "title": "beats-100-20ms-python",
                "content": "```\nclass Solution(object):\n    def numMagicSquaresInside(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        R=len(grid)\n        C=len(grid[0]) if R>0 else 0\n        ans=0\n        for r in range(1,R-1):\n            for c in range(1,C-1):\n                if grid[r][c]==5:\n                    valid=True\n                    seen=set()\n                    for a,b in [\n                        (grid[r][c-1], grid[r][c+1]),\n                        (grid[r-1][c], grid[r+1][c]),\n                        (grid[r-1][c-1], grid[r+1][c+1]),\n                        (grid[r-1][c+1], grid[r+1][c-1])\n                        ]:\n                        valid &= a+b==10 and a>0 and b > 0\n                        seen.add(a)\n                        seen.add(b)\n                    if valid and len(seen)==8:\n                        ans+=1\n                    \n        return ans\n\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def numMagicSquaresInside(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        R=len(grid)\n        C=len(grid[0]) if R>0 else 0\n        ans=0\n        for r in range(1,R-1):\n            for c in range(1,C-1):\n                if grid[r][c]==5:\n                    valid=True\n                    seen=set()\n                    for a,b in [\n                        (grid[r][c-1], grid[r][c+1]),\n                        (grid[r-1][c], grid[r+1][c]),\n                        (grid[r-1][c-1], grid[r+1][c+1]),\n                        (grid[r-1][c+1], grid[r+1][c-1])\n                        ]:\n                        valid &= a+b==10 and a>0 and b > 0\n                        seen.add(a)\n                        seen.add(b)\n                    if valid and len(seen)==8:\n                        ans+=1\n                    \n        return ans\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 181322,
                "title": "beats-100-javascript",
                "content": "1. For magic square, 5 must be in the center, so we should skip `1st row, last row, 1st left col, last right col` because 5 should not be there if it is a valid magic square\\n\\n2. cheeck surrounding number must be 1-9 (using set)\\n3. check sums etc.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    if (!grid || grid.length < 3 || grid[0].length < 3) return 0;\\n    \\n    let row = grid.length;\\n    let col = grid[0].length;\\n    let count = 0;\\n    \\n    for (let r = 1; r < row - 1; r++) {\\n        for (let c = 1; c < col - 1; c++) {\\n            if (grid[r][c] === 5) {\\n                \\n                if (!validSurroundNum(grid,r,c)) continue;\\n                \\n                if (grid[r-1][c-1] + grid[r+1][c+1] !== 10) continue; // left top, right bottom = 10\\n                if (grid[r+1][c-1] + grid[r-1][c+1] !== 10) continue; // left bottom, right top =10\\n                \\n                if (grid[r-1][c-1] + grid[r-1][c] + grid[r-1][c+1] !== 15) continue; // top row = 15\\n                if (grid[r+1][c-1] + grid[r+1][c] + grid[r+1][c+1] !== 15) continue; // bottom row = 15\\n                \\n                if (grid[r-1][c-1] + grid[r][c-1] + grid[r+1][c-1] !== 15) continue; // left col = 15\\n                if (grid[r-1][c+1] + grid[r][c+1] + grid[r+1][c+1] !== 15) continue; // right col = 15\\n                \\n                count += 1;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n\\nfunction validSurroundNum(grid, x,y) {\\n    let set = new Set();\\n    for (let i = -1; i < 1; i++) {\\n        for (let j = -1; j < 1; j++) {\\n            if (set.has(grid[x+i][y+j]) || grid[x+i][y+j] < 1 || grid[x+i][y+j] > 9) {\\n                return false;   \\n            } else {\\n                set.add(grid[x+i][y+j]);\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    if (!grid || grid.length < 3 || grid[0].length < 3) return 0;\\n    \\n    let row = grid.length;\\n    let col = grid[0].length;\\n    let count = 0;\\n    \\n    for (let r = 1; r < row - 1; r++) {\\n        for (let c = 1; c < col - 1; c++) {\\n            if (grid[r][c] === 5) {\\n                \\n                if (!validSurroundNum(grid,r,c)) continue;\\n                \\n                if (grid[r-1][c-1] + grid[r+1][c+1] !== 10) continue; // left top, right bottom = 10\\n                if (grid[r+1][c-1] + grid[r-1][c+1] !== 10) continue; // left bottom, right top =10\\n                \\n                if (grid[r-1][c-1] + grid[r-1][c] + grid[r-1][c+1] !== 15) continue; // top row = 15\\n                if (grid[r+1][c-1] + grid[r+1][c] + grid[r+1][c+1] !== 15) continue; // bottom row = 15\\n                \\n                if (grid[r-1][c-1] + grid[r][c-1] + grid[r+1][c-1] !== 15) continue; // left col = 15\\n                if (grid[r-1][c+1] + grid[r][c+1] + grid[r+1][c+1] !== 15) continue; // right col = 15\\n                \\n                count += 1;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n\\nfunction validSurroundNum(grid, x,y) {\\n    let set = new Set();\\n    for (let i = -1; i < 1; i++) {\\n        for (let j = -1; j < 1; j++) {\\n            if (set.has(grid[x+i][y+j]) || grid[x+i][y+j] < 1 || grid[x+i][y+j] > 9) {\\n                return false;   \\n            } else {\\n                set.add(grid[x+i][y+j]);\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148543,
                "title": "fastest-cpp-solution-beats-100",
                "content": "```\\n bool inRange(int x)\\n    {\\n        return 0<x && x<10;\\n    }\\n    bool isValidOrig(vector<vector<int>>& grid, int r, int c)\\n    {\\n        return r+2<grid.size() && c+2<grid[r].size() && inRange(grid[r][c]) && inRange(grid[r][c+1]) \\n            && inRange(grid[r][c+2]) && inRange(grid[r+1][c]) && inRange(grid[r+1][c+1]) && \\n            inRange(grid[r+1][c+2])&&inRange(grid[r+2][c]) && inRange(grid[r+2][c+1]) && \\n            inRange(grid[r+2][c+2]);\\n    }\\n    bool isMagicSq(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(!isValidOrig(grid,r,c))\\n            return false;\\n        \\n        int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n        return ((grid[r][c]+grid[r][c+1]+grid[r][c+2] == sum) &&\\n            (grid[r+1][c]+grid[r+1][c+1]+grid[r+1][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+2][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c]+grid[r+2][c] == sum) &&\\n            (grid[r][c+1]+grid[r+1][c+1]+grid[r+2][c+1] == sum) &&\\n            (grid[r][c+2]+grid[r+1][c+2]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+1][c+1]+grid[r][c+2]==sum));\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        for(int r=0;r<grid.size();++r)\\n            for(int c=0;c<grid[r].size();++c)\\n                if(isMagicSq(grid, r, c))\\n                    count++;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool inRange(int x)\\n    {\\n        return 0<x && x<10;\\n    }\\n    bool isValidOrig(vector<vector<int>>& grid, int r, int c)\\n    {\\n        return r+2<grid.size() && c+2<grid[r].size() && inRange(grid[r][c]) && inRange(grid[r][c+1]) \\n            && inRange(grid[r][c+2]) && inRange(grid[r+1][c]) && inRange(grid[r+1][c+1]) && \\n            inRange(grid[r+1][c+2])&&inRange(grid[r+2][c]) && inRange(grid[r+2][c+1]) && \\n            inRange(grid[r+2][c+2]);\\n    }\\n    bool isMagicSq(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(!isValidOrig(grid,r,c))\\n            return false;\\n        \\n        int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n        return ((grid[r][c]+grid[r][c+1]+grid[r][c+2] == sum) &&\\n            (grid[r+1][c]+grid[r+1][c+1]+grid[r+1][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+2][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c]+grid[r+2][c] == sum) &&\\n            (grid[r][c+1]+grid[r+1][c+1]+grid[r+2][c+1] == sum) &&\\n            (grid[r][c+2]+grid[r+1][c+2]+grid[r+2][c+2] == sum) &&\\n            (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2] == sum) &&\\n            (grid[r+2][c]+grid[r+1][c+1]+grid[r][c+2]==sum));\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        for(int r=0;r<grid.size();++r)\\n            for(int c=0;c<grid[r].size();++c)\\n                if(isMagicSq(grid, r, c))\\n                    count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134620,
                "title": "simple-solution-in-c",
                "content": "```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n            int result = 0;\\n            for (int i = 0; i < grid.Length - 2; ++i)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; ++j)\\n                {\\n\\n                    if (isMagicGrid(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                                    grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                                    grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2])){result++;} ;\\n\\n                }\\n            }\\n            return result;\\n    }\\n    \\n        private bool isMagicGrid(params int[] values)\\n        {\\n            int[] count = new int[16];\\n            foreach (var value in values)\\n            {\\n                count[value] = 1;\\n            }\\n            for (int i = 1; i <= values.Length; ++i)\\n            {\\n                if (count[i] != 1)\\n                    return false;\\n            }\\n            return (values[0] + values[1] + values[2] == 15 &&\\n                    values[3] + values[4] + values[5] == 15 &&\\n                    values[6] + values[7] + values[8] == 15 &&\\n                    values[0] + values[3] + values[6] == 15 &&\\n                    values[1] + values[4] + values[7] == 15 &&\\n                    values[2] + values[5] + values[8] == 15 &&\\n                    values[0] + values[4] + values[8] == 15 &&\\n                    values[2] + values[4] + values[6] == 15);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n            int result = 0;\\n            for (int i = 0; i < grid.Length - 2; ++i)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; ++j)\\n                {\\n\\n                    if (isMagicGrid(grid[i][j], grid[i + 1][j], grid[i + 2][j],\\n                                    grid[i][j + 1], grid[i + 1][j + 1], grid[i + 2][j + 1],\\n                                    grid[i][j + 2], grid[i + 1][j + 2], grid[i + 2][j + 2])){result++;} ;\\n\\n                }\\n            }\\n            return result;\\n    }\\n    \\n        private bool isMagicGrid(params int[] values)\\n        {\\n            int[] count = new int[16];\\n            foreach (var value in values)\\n            {\\n                count[value] = 1;\\n            }\\n            for (int i = 1; i <= values.Length; ++i)\\n            {\\n                if (count[i] != 1)\\n                    return false;\\n            }\\n            return (values[0] + values[1] + values[2] == 15 &&\\n                    values[3] + values[4] + values[5] == 15 &&\\n                    values[6] + values[7] + values[8] == 15 &&\\n                    values[0] + values[3] + values[6] == 15 &&\\n                    values[1] + values[4] + values[7] == 15 &&\\n                    values[2] + values[5] + values[8] == 15 &&\\n                    values[0] + values[4] + values[8] == 15 &&\\n                    values[2] + values[4] + values[6] == 15);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133976,
                "title": "brute-force-java-solution",
                "content": "```\\n    public int numMagicSquaresInside(int[][] g) {\\n        int count = 0;\\n        for(int i=2; i<g.length; i++) {\\n            for(int j=2; j<g[0].length; j++) {\\n                if(g[i][j] >9 || g[i][j] < 1\\n                 || g[i][j-1] >9 || g[i][j-1] < 1\\n                 || g[i][j-2] >9 || g[i][j-2] < 1\\n                 || g[i-1][j] >9 || g[i-1][j] < 1\\n                 || g[i-1][j-1] >9 || g[i-1][j-1] < 1\\n                 || g[i-1][j-2] >9 || g[i-1][j-2] < 1\\n                 || g[i-2][j] >9 || g[i-2][j] < 1\\n                 || g[i-2][j-1] >9 || g[i-2][j-1] < 1\\n                 || g[i-2][j-2] >9 || g[i-2][j-2] < 1\\n                    \\n                  ||  g[i][j]+g[i-2][j-2] != g[i-2][j]+ g[i][j-2]\\n                  || g[i-1][j]+g[i-1][j-2] != g[i-2][j-1]+ g[i][j-1]\\n                  || g[i][j]+g[i][j-1] != g[i-2][j-2]+ g[i-1][j-2]\\n                  || g[i][j]+g[i-1][j] != g[i-2][j-2]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i-1][j-2] != g[i-2][j]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i][j-1] != g[i-2][j]+ g[i-1][j]) continue;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numMagicSquaresInside(int[][] g) {\\n        int count = 0;\\n        for(int i=2; i<g.length; i++) {\\n            for(int j=2; j<g[0].length; j++) {\\n                if(g[i][j] >9 || g[i][j] < 1\\n                 || g[i][j-1] >9 || g[i][j-1] < 1\\n                 || g[i][j-2] >9 || g[i][j-2] < 1\\n                 || g[i-1][j] >9 || g[i-1][j] < 1\\n                 || g[i-1][j-1] >9 || g[i-1][j-1] < 1\\n                 || g[i-1][j-2] >9 || g[i-1][j-2] < 1\\n                 || g[i-2][j] >9 || g[i-2][j] < 1\\n                 || g[i-2][j-1] >9 || g[i-2][j-1] < 1\\n                 || g[i-2][j-2] >9 || g[i-2][j-2] < 1\\n                    \\n                  ||  g[i][j]+g[i-2][j-2] != g[i-2][j]+ g[i][j-2]\\n                  || g[i-1][j]+g[i-1][j-2] != g[i-2][j-1]+ g[i][j-1]\\n                  || g[i][j]+g[i][j-1] != g[i-2][j-2]+ g[i-1][j-2]\\n                  || g[i][j]+g[i-1][j] != g[i-2][j-2]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i-1][j-2] != g[i-2][j]+ g[i-2][j-1]\\n                  || g[i][j-2]+g[i][j-1] != g[i-2][j]+ g[i-1][j]) continue;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133879,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def is_magic(sq):\\n            s = sum(sq[0])\\n            return set(x for row in sq for x in row) == set(range(1, 10)) and all(sum(row) == s for row in sq) and all(sum(sq[i][j] for i in range(3)) == s for j in range(3)) and sum(sq[i][i] for i in range(3)) == s and sum(sq[i][2-i] for i in range(3)) == s        \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):                \\n                mgrid = [[grid[k][m] for m in range(j,j+3)] for k in range(i,i+3) ]\\n                if is_magic(mgrid)==True:\\n                    count+=1\\n                               \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def is_magic(sq):\\n            s = sum(sq[0])\\n            return set(x for row in sq for x in row) == set(range(1, 10)) and all(sum(row) == s for row in sq) and all(sum(sq[i][j] for i in range(3)) == s for j in range(3)) and sum(sq[i][i] for i in range(3)) == s and sum(sq[i][2-i] for i in range(3)) == s        \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[0])-2):                \\n                mgrid = [[grid[k][m] for m in range(j,j+3)] for k in range(i,i+3) ]\\n                if is_magic(mgrid)==True:\\n                    count+=1\\n                               \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074825,
                "title": "python3-intuitive-but-not-most-optimal-beats-82-52-runtime-and-85-44-memory",
                "content": "# Intuition\\nSlice down grid into 3x3 sub-grids and calculate sums for each:\\n- rows\\n- columns\\n- diagonals\\n\\n# Approach\\n1. Figure out row and column index range (i.e. highest value when slicing to 3x3 sub-grids)\\n2. For each row index and column index in respective index_range\\n2.1 calculate `expected_sum` (to be used when calculating rows/columns/diagonals sums)\\n2.2 calculate sums for `rows`, while checking if the sums are equal to `expected_sum` from `2.1`, respective values are $$1 < x < 10$$ and values are distinct numbers\\n2.3 calculate sums for `columns`, while checking if the sums are equal to `expected_sum` from `2.1`, respective values are $$1 < x < 10$$ and values are distinct numbers\\n2.4 calculate sums for `diagonals`, while checking if the sums are equal to `expected_sum` from `2.1`, respective values are $$1 < x < 10$$ and values are distinct numbers\\n3. check if `len(rows) == 3 && len(columns) == 3 && len(diagonals) == 2`\\n3.1 check if all values for `rows`, `columns` and `diagonals` are the same, if so, increase `results`\\n4. return `results` value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        result = 0\\n\\n        no_rows = len(grid)\\n        no_columns = len(grid[0])\\n\\n        if no_rows < 3:\\n            return 0\\n        if no_columns < 3:\\n            return 0\\n\\n        row_index_range = 1 if no_columns == 3 else no_rows - 2\\n        column_index_range = 1 if no_columns == 3 else no_columns - 2\\n        for row_idx in range(row_index_range):\\n            for col_idx in range(column_index_range):\\n                expected_sum = sum(grid[row_idx][col_idx : col_idx + 3])\\n                rows = self.get_rows(grid[row_idx : row_idx + 3], col_idx, expected_sum)\\n                columns = self.get_columns(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                diags = self.get_diags(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                if len(rows) == 3 and len(columns) == 3 and len(diags) == 2:\\n                    if all(rows) and all(columns) and all(diags):\\n                        result += 1\\n\\n        return result\\n\\n    def get_rows(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx in range(len(grid)):\\n            summ = sum(grid[idx][column_index : column_index + 3])\\n            if summ != expected_sum or any(\\n                el < 1 or el > 9 for el in grid[idx][column_index : column_index + 3]\\n            ) or len(set(grid[idx][column_index : column_index + 3])) < 3:\\n                return []\\n            result.append(summ)\\n        return result\\n\\n    def get_columns(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx_col in range(column_index, column_index + 3):\\n            tmp = []\\n            for idx_row in range(len(grid)):\\n                if 1 > grid[idx_row][idx_col] > 9:\\n                    return []\\n                tmp.append(grid[idx_row][idx_col])\\n            if sum(tmp) != expected_sum or len(set(tmp)) < 3:\\n                return []\\n            result.append(sum(tmp))\\n        return result\\n\\n    def get_diags(self, grid, column_index, expected_sum):\\n        result = []\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][idx + column_index] > 9:\\n                return []\\n            tmp.append(grid[idx][idx + column_index])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][column_index + 2 - idx] > 9:\\n                return []\\n            tmp.append(grid[idx][column_index + 2 - idx])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        result = 0\\n\\n        no_rows = len(grid)\\n        no_columns = len(grid[0])\\n\\n        if no_rows < 3:\\n            return 0\\n        if no_columns < 3:\\n            return 0\\n\\n        row_index_range = 1 if no_columns == 3 else no_rows - 2\\n        column_index_range = 1 if no_columns == 3 else no_columns - 2\\n        for row_idx in range(row_index_range):\\n            for col_idx in range(column_index_range):\\n                expected_sum = sum(grid[row_idx][col_idx : col_idx + 3])\\n                rows = self.get_rows(grid[row_idx : row_idx + 3], col_idx, expected_sum)\\n                columns = self.get_columns(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                diags = self.get_diags(\\n                    grid[row_idx : row_idx + 3], col_idx, expected_sum\\n                )\\n                if len(rows) == 3 and len(columns) == 3 and len(diags) == 2:\\n                    if all(rows) and all(columns) and all(diags):\\n                        result += 1\\n\\n        return result\\n\\n    def get_rows(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx in range(len(grid)):\\n            summ = sum(grid[idx][column_index : column_index + 3])\\n            if summ != expected_sum or any(\\n                el < 1 or el > 9 for el in grid[idx][column_index : column_index + 3]\\n            ) or len(set(grid[idx][column_index : column_index + 3])) < 3:\\n                return []\\n            result.append(summ)\\n        return result\\n\\n    def get_columns(self, grid, column_index, expected_sum):\\n        result = []\\n        for idx_col in range(column_index, column_index + 3):\\n            tmp = []\\n            for idx_row in range(len(grid)):\\n                if 1 > grid[idx_row][idx_col] > 9:\\n                    return []\\n                tmp.append(grid[idx_row][idx_col])\\n            if sum(tmp) != expected_sum or len(set(tmp)) < 3:\\n                return []\\n            result.append(sum(tmp))\\n        return result\\n\\n    def get_diags(self, grid, column_index, expected_sum):\\n        result = []\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][idx + column_index] > 9:\\n                return []\\n            tmp.append(grid[idx][idx + column_index])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n        tmp = []\\n        for idx in range(len(grid)):\\n            if 1 > grid[idx][column_index + 2 - idx] > 9:\\n                return []\\n            tmp.append(grid[idx][column_index + 2 - idx])\\n        if sum(tmp) != expected_sum:\\n            return []\\n        result.append(sum(tmp))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038080,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979924,
                "title": "easy-c-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        int s=0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2<m && j+2<n)\\n                {\\n                    map<int,int> p,q;\\n                    bool b=1;\\n                    for(int r=i;r<i+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=j;c<j+3;c++)\\n                         {t+=g[r][c];\\n                         q[g[r][c]]++;\\n                         if(g[r][c]==0 || g[r][c]>9) b=0;\\n                         }\\n                         p[t]++;\\n                     }\\n                     for(int r=j;r<j+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=i;c<i+3;c++)\\n                         t+=g[c][r];\\n                         p[t]++;\\n                     }\\n                     int t=0;\\n                      for(int r=i;r<i+3;r++)\\n                     {\\n                         for(int c=j;c<j+3;c++)\\n                         if(c-j==r-i)\\n                         t+=g[r][c]; \\n                     }\\n                     p[t]++;\\n                     if(p.size()==1 && q.size()==9 && b)\\n                     s++;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        int s=0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2<m && j+2<n)\\n                {\\n                    map<int,int> p,q;\\n                    bool b=1;\\n                    for(int r=i;r<i+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=j;c<j+3;c++)\\n                         {t+=g[r][c];\\n                         q[g[r][c]]++;\\n                         if(g[r][c]==0 || g[r][c]>9) b=0;\\n                         }\\n                         p[t]++;\\n                     }\\n                     for(int r=j;r<j+3;r++)\\n                     {\\n                         int t=0;\\n                         for(int c=i;c<i+3;c++)\\n                         t+=g[c][r];\\n                         p[t]++;\\n                     }\\n                     int t=0;\\n                      for(int r=i;r<i+3;r++)\\n                     {\\n                         for(int c=j;c<j+3;c++)\\n                         if(c-j==r-i)\\n                         t+=g[r][c]; \\n                     }\\n                     p[t]++;\\n                     if(p.size()==1 && q.size()==9 && b)\\n                     s++;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958596,
                "title": "check-function-for-each-3x3-sub-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(int i,int j,vector<vector<int>>& grid){\\n        vector<int>row(3,0);\\n        vector<int>col(3,0);\\n        int mx=INT_MIN,mn=INT_MAX;\\n        unordered_set<int>h;\\n        for(int r=i;r<i+3;r++){\\n            for(int c=j;c<j+3;c++){\\n                row[r-i]=row[r-i]+grid[r][c];\\n                h.insert(grid[r][c]);\\n                mx=max(mx,grid[r][c]);\\n                mn=min(mn,grid[r][c]);\\n            }\\n        }\\n        if(h.size()<9)return 0;\\n        if(mn>9||mn<1||mx>9||mx<1)return 0;\\n        if(row[0]!=row[1]||row[1]!=row[2])return 0;\\n        for(int c=j;c<j+3;c++){\\n            for(int r=i;r<i+3;r++){\\n                col[c-j]=col[c-j]+grid[r][c];\\n            }\\n        }\\n        if(col[0]!=col[1]||col[1]!=col[2])return 0;\\n        if(row[0]!=col[0])return 0;\\n        int d1=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n        int d2=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n        if(d1!=d2||d1!=row[0])return 0;\\n        return 1;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i+2<grid.size();i++){\\n            for(int j=0;j+2<grid[0].size();j++){\\n                if(check(i,j,grid))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int i,int j,vector<vector<int>>& grid){\\n        vector<int>row(3,0);\\n        vector<int>col(3,0);\\n        int mx=INT_MIN,mn=INT_MAX;\\n        unordered_set<int>h;\\n        for(int r=i;r<i+3;r++){\\n            for(int c=j;c<j+3;c++){\\n                row[r-i]=row[r-i]+grid[r][c];\\n                h.insert(grid[r][c]);\\n                mx=max(mx,grid[r][c]);\\n                mn=min(mn,grid[r][c]);\\n            }\\n        }\\n        if(h.size()<9)return 0;\\n        if(mn>9||mn<1||mx>9||mx<1)return 0;\\n        if(row[0]!=row[1]||row[1]!=row[2])return 0;\\n        for(int c=j;c<j+3;c++){\\n            for(int r=i;r<i+3;r++){\\n                col[c-j]=col[c-j]+grid[r][c];\\n            }\\n        }\\n        if(col[0]!=col[1]||col[1]!=col[2])return 0;\\n        if(row[0]!=col[0])return 0;\\n        int d1=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2];\\n        int d2=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j];\\n        if(d1!=d2||d1!=row[0])return 0;\\n        return 1;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i+2<grid.size();i++){\\n            for(int j=0;j+2<grid[0].size();j++){\\n                if(check(i,j,grid))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862360,
                "title": "fast-solution",
                "content": "# Intuition\\nRuntime: 15ms (100%)\\nMemory: 13.2 MB (94.74%)\\n\\n# Approach\\nA function to check validity of of each 3x3 matrix, by getting all rows, columns and both diagonals and then comparing their sums, as well as making sure the 3x3 matrix contains all numbers from 1 to 9.\\n\\nSecond part of code is to get each 3x3 submatrix. On each row, increasing the start unit by one each time before moving onto the column below.\\n\\n# Complexity\\n- Time complexity:\\n\\nidk\\n- Space complexity:\\nidk\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n\\n        \\n        def check(matrix):\\n            nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n            mat2 = []\\n            for x in matrix:\\n                mat2.extend(x)\\n           \\n            for x in nums:\\n                if x not in mat2:\\n                    return False\\n            rows = [x for x in matrix]\\n            cols = []\\n            for x in range(0, 3):\\n                a = []\\n                for y in matrix:\\n                    a.append(y[x])\\n                cols.append(a)\\n            \\n            diagonal1 = [matrix[0][0], matrix[1][1], matrix[2][2]]\\n            diagonal2 = [matrix[0][2], matrix[1][1], matrix[2][0]]\\n            \\n            target = sum(diagonal1)\\n            \\n            for x in rows:\\n                if sum(x) != target:\\n                    return False\\n            for x in cols:\\n                if sum(x) != target:\\n                    return False\\n            if sum(diagonal2) != target:\\n                return False\\n            \\n            return True\\n        \\n        #get mini matrixes\\n    \\n        num1 = 0\\n        num2 = 0\\n        def rows(mat, r):\\n            count = 0\\n            out = []\\n            start = 0\\n            for x in range(len(mat[0]) - 3 + 1):\\n                a = []\\n                for y in range(r, r + 3):\\n                    lst = mat[y]\\n                    a.append(lst[start:start + 3])\\n                start += 1\\n                \\n               \\n                if check(a) == True:\\n                    count += 1\\n            return count\\n        mats = []\\n        out = 0\\n        \\n        for x in range(len(grid) - 3 + 1):\\n           out += rows(grid, x)\\n       \\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n\\n        \\n        def check(matrix):\\n            nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n            mat2 = []\\n            for x in matrix:\\n                mat2.extend(x)\\n           \\n            for x in nums:\\n                if x not in mat2:\\n                    return False\\n            rows = [x for x in matrix]\\n            cols = []\\n            for x in range(0, 3):\\n                a = []\\n                for y in matrix:\\n                    a.append(y[x])\\n                cols.append(a)\\n            \\n            diagonal1 = [matrix[0][0], matrix[1][1], matrix[2][2]]\\n            diagonal2 = [matrix[0][2], matrix[1][1], matrix[2][0]]\\n            \\n            target = sum(diagonal1)\\n            \\n            for x in rows:\\n                if sum(x) != target:\\n                    return False\\n            for x in cols:\\n                if sum(x) != target:\\n                    return False\\n            if sum(diagonal2) != target:\\n                return False\\n            \\n            return True\\n        \\n        #get mini matrixes\\n    \\n        num1 = 0\\n        num2 = 0\\n        def rows(mat, r):\\n            count = 0\\n            out = []\\n            start = 0\\n            for x in range(len(mat[0]) - 3 + 1):\\n                a = []\\n                for y in range(r, r + 3):\\n                    lst = mat[y]\\n                    a.append(lst[start:start + 3])\\n                start += 1\\n                \\n               \\n                if check(a) == True:\\n                    count += 1\\n            return count\\n        mats = []\\n        out = 0\\n        \\n        for x in range(len(grid) - 3 + 1):\\n           out += rows(grid, x)\\n       \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835094,
                "title": "javascript-solution",
                "content": "# Intuition\\nIt is necessary to count the number of magic squares in the grid.\\nWe assume that the sum of rows, columns and diagonals in the \"magic square\" will be equal to 15 (always).\\nAlso, all numbers must be from 1 to 9.\\n\\n# Approach\\nCreate a function to select a 3 * 3 subgrid.\\nWe create a function to check if a 3 x 3 subgrid is a magic square.\\nWe go through all possible 3 x 3 subgrids in a given grid and apply functions to test for each of them.\\nIf the subgrid is a magic square, increment the counter by 1.\\nWe return the value of the counter as a response to the task.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nfunction numMagicSquaresInside(grid) {\\n    function MagicSquare(matrix) {\\n        let hash = new Set();\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (hash.has(matrix[i][j])) {\\n                    return false;\\n                } else {\\n                    hash.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        // Checking sums of diagonals\\n        const magicSum = 15;\\n        if (\\n            matrix[0][0] + matrix[1][1] + matrix[2][2] !== magicSum ||\\n            matrix[0][2] + matrix[1][1] + matrix[2][0] !== magicSum\\n        ) {\\n            return false;\\n        }\\n\\n        // Checking sums of rows and columns\\n        for (let i = 0; i < 3; i++) {\\n            if (\\n                magicSum !== matrix[i].reduce((sum, item) => (sum += item), 0) ||\\n                magicSum !== matrix.reduce((sum, row) => (sum += row[i]), 0)\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function toMatrix(col, row) {\\n        let matrix = [[], [], []];\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (grid[row + i] && grid[row + i][col + j]) {\\n                    matrix[i].push(grid[row + i][col + j]);\\n                } else {\\n                    return null; // Handle incomplete 3x3 matrices\\n                }\\n            }\\n        }\\n        return matrix;\\n    }\\n\\n    let sumMagicSquares = 0;\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 0; j < grid[i].length - 2; j++) {\\n            const matrix = toMatrix(j, i);\\n            if (matrix !== null && MagicSquare(matrix)) {\\n                sumMagicSquares++;\\n            }\\n        }\\n    }\\n    return sumMagicSquares;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nfunction numMagicSquaresInside(grid) {\\n    function MagicSquare(matrix) {\\n        let hash = new Set();\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (hash.has(matrix[i][j])) {\\n                    return false;\\n                } else {\\n                    hash.add(matrix[i][j]);\\n                }\\n            }\\n        }\\n        // Checking sums of diagonals\\n        const magicSum = 15;\\n        if (\\n            matrix[0][0] + matrix[1][1] + matrix[2][2] !== magicSum ||\\n            matrix[0][2] + matrix[1][1] + matrix[2][0] !== magicSum\\n        ) {\\n            return false;\\n        }\\n\\n        // Checking sums of rows and columns\\n        for (let i = 0; i < 3; i++) {\\n            if (\\n                magicSum !== matrix[i].reduce((sum, item) => (sum += item), 0) ||\\n                magicSum !== matrix.reduce((sum, row) => (sum += row[i]), 0)\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function toMatrix(col, row) {\\n        let matrix = [[], [], []];\\n        for (let i = 0; i < 3; i++) {\\n            for (let j = 0; j < 3; j++) {\\n                if (grid[row + i] && grid[row + i][col + j]) {\\n                    matrix[i].push(grid[row + i][col + j]);\\n                } else {\\n                    return null; // Handle incomplete 3x3 matrices\\n                }\\n            }\\n        }\\n        return matrix;\\n    }\\n\\n    let sumMagicSquares = 0;\\n    for (let i = 0; i < grid.length - 2; i++) {\\n        for (let j = 0; j < grid[i].length - 2; j++) {\\n            const matrix = toMatrix(j, i);\\n            if (matrix !== null && MagicSquare(matrix)) {\\n                sumMagicSquares++;\\n            }\\n        }\\n    }\\n    return sumMagicSquares;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808827,
                "title": "easy-to-understand-c-basic-2-d-matrix-traversing",
                "content": "# Intuition\\nI simply traversed the grid from square one and checked if all the conditions matched for that particular cell i.e. if a magic square could be formed from there.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$ As we are traversing the grid so it\\'s space is included in the stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool f(vector<vector<int>> &grid , int i , int j){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        \\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(i+2<grid.size() && j+2< grid[0].size()){\\n                    if(f(grid, i, j)){\\n                        res++;\\n                    } \\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool f(vector<vector<int>> &grid , int i , int j){\\n\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n\\n\\n            if((col1 == col2) &&  (col1 == col3) &&(col1 == row1) &&(col1 == row2) && (col1 == row3) &&(col1 == diag1) &&(col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int k = 0 ; k < 3 ; k++){\\n                        for(int l = 0; l < 3 ; l++){\\n                            s.erase(grid[i + k][j + l]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        \\n        return false;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(i+2<grid.size() && j+2< grid[0].size()){\\n                    if(f(grid, i, j)){\\n                        res++;\\n                    } \\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801035,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752330,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(r, c):\\n            if grid[r + 1][c + 1] != 5:\\n                return False\\n            unique, sums = set(), set()\\n            for dr in range(3):\\n                row_sum = col_sum = diag_sum = adiag_sum = 0\\n                for dc in range(3):\\n                    unique.add(grid[r + dr][c + dc])\\n                    row_sum += grid[r + dr][c + dc]\\n                    col_sum += grid[r + dc][c + dr]\\n                    diag_sum += grid[r + dc][c + dc]\\n                    adiag_sum += grid[r + dc][c + 2 - dc]\\n                sums.update((row_sum, col_sum, diag_sum, adiag_sum))\\n            return len(sums) == 1 and len(unique) == 9 and min(unique) == 1 and max(unique) == 9\\n        R, C = len(grid), len(grid[0])\\n        return sum(r + 2 < R and c + 2 < C and is_magic_square(r, c)\\n                   for r,c in product(range(R), range(C)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def is_magic_square(r, c):\\n            if grid[r + 1][c + 1] != 5:\\n                return False\\n            unique, sums = set(), set()\\n            for dr in range(3):\\n                row_sum = col_sum = diag_sum = adiag_sum = 0\\n                for dc in range(3):\\n                    unique.add(grid[r + dr][c + dc])\\n                    row_sum += grid[r + dr][c + dc]\\n                    col_sum += grid[r + dc][c + dr]\\n                    diag_sum += grid[r + dc][c + dc]\\n                    adiag_sum += grid[r + dc][c + 2 - dc]\\n                sums.update((row_sum, col_sum, diag_sum, adiag_sum))\\n            return len(sums) == 1 and len(unique) == 9 and min(unique) == 1 and max(unique) == 9\\n        R, C = len(grid), len(grid[0])\\n        return sum(r + 2 < R and c + 2 < C and is_magic_square(r, c)\\n                   for r,c in product(range(R), range(C)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709590,
                "title": "beats-92-of-runtime-detailed-explanation",
                "content": "\\n# Approach\\nWe divide the requirements and implement functions for each requirement. This way, it\\'s easier to debug the code and also know what\\'s happening at every step. From the problem, it can be seen that a 3*3 grid is classified as a magic square if:\\n    - all rows are equal\\n    - all columns are equal \\n    - all diagonals are equal\\n    - and the 3* *by 3 grid contains elements from 1-9 without repetition*.\\n\\nFor all the requirements we create the necessary functions for them. We then traverse the main matrix in a 3 * 3 grid mode and check if each grid satisfies all the requirements. We then output the number of grids in the matrix which satisfy all four requirements   \\n\\n# Code\\n```\\nclass Solution:\\n    def check_diagonals(self, matrix): #Checks validity of sums of diagonals\\n        n = int(len(matrix)/2)+1\\n        front, back = [], []\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j:\\n                    front.extend([matrix[i][j],matrix[n-i][n-j]])\\n                    back.extend([matrix[i][n-j],matrix[n-j][i]])\\n        if sum(front[:len(matrix)]) == sum(back[:len(matrix)]):\\n            return True\\n        return False\\n\\n    def check_rows(self, matrix): #Checks validity of sums of rows\\n        top_row, middle_row, bottom_row = sum(matrix[0]), sum(matrix[1]), sum(matrix[2])\\n        if top_row==middle_row==bottom_row:\\n            return True\\n        return False\\n        \\n    def check_cols(self, matrix): #Checks validity of sums of columns\\n        right_col, middle_col, left_col = 0, 0, 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                right_col+=matrix[i][0]\\n                middle_col+=matrix[i][1]\\n                left_col+=matrix[i][2]\\n        if right_col==middle_col==left_col:\\n            return True\\n        return False\\n    \\n    def check_matrix(self, matrix): #Checks validity of sub_matrix or sub_grid\\n        nums = set()\\n        for i in matrix:\\n            for j in range(len(i)):\\n                if i[j]<10 and i[j]>0:\\n                    nums.add(i[j])\\n        if len(nums)!= 9:\\n            return False\\n        return True\\n\\n    def numMagicSquaresInside(self, grid: list[list[int]]):  \\n        ans = 0\\n        for i in range(len(grid)-2):\\n            for j in range(0,len(grid[0])-2):\\n                sub_grid = grid[i:i+3]\\n                for k in range(len(sub_grid)):\\n                    sub_grid[k] = sub_grid[k][j:j+3]\\n                if self.check_matrix(sub_grid) is False:\\n                    continue\\n                else:\\n                    if self.check_diagonals(sub_grid) and self.check_cols(sub_grid) and self.check_rows(sub_grid):\\n                        ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def check_diagonals(self, matrix): #Checks validity of sums of diagonals\\n        n = int(len(matrix)/2)+1\\n        front, back = [], []\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j:\\n                    front.extend([matrix[i][j],matrix[n-i][n-j]])\\n                    back.extend([matrix[i][n-j],matrix[n-j][i]])\\n        if sum(front[:len(matrix)]) == sum(back[:len(matrix)]):\\n            return True\\n        return False\\n\\n    def check_rows(self, matrix): #Checks validity of sums of rows\\n        top_row, middle_row, bottom_row = sum(matrix[0]), sum(matrix[1]), sum(matrix[2])\\n        if top_row==middle_row==bottom_row:\\n            return True\\n        return False\\n        \\n    def check_cols(self, matrix): #Checks validity of sums of columns\\n        right_col, middle_col, left_col = 0, 0, 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                right_col+=matrix[i][0]\\n                middle_col+=matrix[i][1]\\n                left_col+=matrix[i][2]\\n        if right_col==middle_col==left_col:\\n            return True\\n        return False\\n    \\n    def check_matrix(self, matrix): #Checks validity of sub_matrix or sub_grid\\n        nums = set()\\n        for i in matrix:\\n            for j in range(len(i)):\\n                if i[j]<10 and i[j]>0:\\n                    nums.add(i[j])\\n        if len(nums)!= 9:\\n            return False\\n        return True\\n\\n    def numMagicSquaresInside(self, grid: list[list[int]]):  \\n        ans = 0\\n        for i in range(len(grid)-2):\\n            for j in range(0,len(grid[0])-2):\\n                sub_grid = grid[i:i+3]\\n                for k in range(len(sub_grid)):\\n                    sub_grid[k] = sub_grid[k][j:j+3]\\n                if self.check_matrix(sub_grid) is False:\\n                    continue\\n                else:\\n                    if self.check_diagonals(sub_grid) and self.check_cols(sub_grid) and self.check_rows(sub_grid):\\n                        ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701149,
                "title": "set-theory-and-memo-s-100-time-and-space-complexity-on-average-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are only so many magic and non-magic squares we may encounter (though the latter is quite great!). Based on this, we can utilize memoization to speed up a set based approach to our problem. \\n\\nTo start, notice that we can use the order of the items in a square (called subgrid from here on) as a memo-key, which we can then mark after analysis as either a magic square or a non magic square. \\n\\nIf we know the number of magic squares, we also know when we can hit a real speed boost! To learn more, check this new york times article here : https://mindyourdecisions.com/blog/2015/11/08/how-many-3x3-magic-squares-are-there-sunday-puzzle/\\n\\nWith this in mind, we can outline our approach as follows \\nWe are going to count the number of magic squares \\nTo be a magic square, a square of 3 x 3 values in a grid must \\n- have all values 1 to 9  \\n- have all 3 rows sum to 15 \\n- have all 3 cols sum to 15 \\n\\nFrom the article, we know there are only 8 magic squares. In the interest of fairness, we\\'ll build these up as we go rather than simply enter them all at the start. \\n\\nThen, for each square subgrid in our grid \\n- Get the subgrid key for the subgrid \\n- If we have 8 magic keys already \\n    - increment number of magic squares by int cast of boolean of whether or not the subgrid key is in our magic keys \\n    - continue \\n- otherwise if it is in our magic keys \\n    - increment number of magic squares by 1 and continue \\n- otherwise if it is in our normal keys \\n    - continue \\n- otherwise if it has all values 1 to 9 and has all rows sum to 15 and all cols sum to 15 \\n    - add the subgrid key to the magic squares set \\n    - increment number magic squares by 1 \\n    - continue \\n- otherwise \\n    - add the subgrid key to the normal keys \\n    - continue \\n\\nAt end return number of magic squares     \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is fairly laid out in the intuition, however, we\\'ll note a few additions here \\n\\nIf you want the number of each type of magic square \\n- change from magic square sets to magic square frequency dictionaries \\n- make sure you increment on that as needed \\n\\nSimilar for the normal squares \\n\\nTo get each subgrid is actually a bit of a process. For our purposes we do the following \\n- Loop row index in range 1 to rows - 1 \\n    - set row as grid at row index \\n    - set col indices as [index for index in range(1, cols-1) if row[index] == 5] (we can skip over those others in this way) \\n    - for col index in col indices \\n        - set a subgrid as the list of sub rows from col index - 1 to col index + 2 for sub row in grid from row index - 1 to row index + 2 \\n        - set a subgrid key as \"\".join([str(item) for row_s in subgrid for item in row_s]) \\n        - from here, above logic follows \\n\\n# Complexity\\n- Time complexity : O(R * (C + c)) \\n    - We loop each row basically \\n        - In each row we do C work to loop each col and build col indices\\n        - Then we do c work for each col indices \\n        - Then we do O(1) work to build subgrid and get key \\n        - Then we do O(1) work for reset of processing \\n    - In total then we do O(R * (C + c))   \\n\\n- Space complexity : O(K) \\n    - We store at most 8 magic keys \\n    - We store at most the unique normal keys K \\n    - All other space is technically referential \\n    - O(K) is the final space, where K is the number of keys \\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int :\\n        # what we are after \\n        num_magic_squares = 0 \\n        # what a magic square must contain \\n        num_set = set(range(1, 10))\\n        # dimensions of our problem \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        # square list of normal and magical keys respectively \\n        square_list = [set(), set()]\\n        # for row index in range 1 to rows - 1 \\n        for row_index in range(1, rows - 1) : \\n            # get the row \\n            row = grid[row_index]\\n            # only care about col indices where row at index is 5 as an optional skip\\n            col_indices = [index for index in range(1, cols-1) if row[index] == 5]\\n            # for col indices we care about \\n            for col_index in col_indices : \\n                # get the subgrid as sub row at col_index - 1 to col index + 2 for each sub row in grid \\n                subgrid = [row_s[col_index-1:col_index+2] for row_s in grid[row_index-1 : row_index + 2]]\\n                # build your subgrid key in order to utilize memo \\n                subgrid_key = \"\".join([str(item) for row_s in subgrid for item in row_s])\\n                # if you found them all, use that fact to skip out early \\n                if len(square_list[1]) == 8 : \\n                    num_magic_squares += int(subgrid_key in square_list[1])\\n                    continue\\n                elif subgrid_key in square_list[1] : \\n                    # otherwise, if you found this one increment and continue to next col index\\n                    num_magic_squares += 1 \\n                    continue\\n                elif subgrid_key in square_list[0] : \\n                    # or skip out early if you already know it\\'s not magical \\n                    continue\\n                else : \\n                    # if we have all numbers in 0 - 9 and our row sum is 15 3 times and our col sum is 15 3 times, this is a magic square. Otherwise it is not. \\n                    magical = (len(num_set-set([item for row_s in subgrid for item in row_s]))==0) and (sum([sum(row_s)==15 for row_s in subgrid])== sum([sum(col_s)==15 for col_s in zip(*subgrid)])==3)\\n                    # increment based on status \\n                    num_magic_squares += magical \\n                    # and assign appropriately \\n                    square_list[magical].add(subgrid_key)\\n                    # then continue\\n                    continue\\n        # return when done \\n        return num_magic_squares\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int :\\n        # what we are after \\n        num_magic_squares = 0 \\n        # what a magic square must contain \\n        num_set = set(range(1, 10))\\n        # dimensions of our problem \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        # square list of normal and magical keys respectively \\n        square_list = [set(), set()]\\n        # for row index in range 1 to rows - 1 \\n        for row_index in range(1, rows - 1) : \\n            # get the row \\n            row = grid[row_index]\\n            # only care about col indices where row at index is 5 as an optional skip\\n            col_indices = [index for index in range(1, cols-1) if row[index] == 5]\\n            # for col indices we care about \\n            for col_index in col_indices : \\n                # get the subgrid as sub row at col_index - 1 to col index + 2 for each sub row in grid \\n                subgrid = [row_s[col_index-1:col_index+2] for row_s in grid[row_index-1 : row_index + 2]]\\n                # build your subgrid key in order to utilize memo \\n                subgrid_key = \"\".join([str(item) for row_s in subgrid for item in row_s])\\n                # if you found them all, use that fact to skip out early \\n                if len(square_list[1]) == 8 : \\n                    num_magic_squares += int(subgrid_key in square_list[1])\\n                    continue\\n                elif subgrid_key in square_list[1] : \\n                    # otherwise, if you found this one increment and continue to next col index\\n                    num_magic_squares += 1 \\n                    continue\\n                elif subgrid_key in square_list[0] : \\n                    # or skip out early if you already know it\\'s not magical \\n                    continue\\n                else : \\n                    # if we have all numbers in 0 - 9 and our row sum is 15 3 times and our col sum is 15 3 times, this is a magic square. Otherwise it is not. \\n                    magical = (len(num_set-set([item for row_s in subgrid for item in row_s]))==0) and (sum([sum(row_s)==15 for row_s in subgrid])== sum([sum(col_s)==15 for col_s in zip(*subgrid)])==3)\\n                    # increment based on status \\n                    num_magic_squares += magical \\n                    # and assign appropriately \\n                    square_list[magical].add(subgrid_key)\\n                    # then continue\\n                    continue\\n        # return when done \\n        return num_magic_squares\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669180,
                "title": "simple-java-solution-0ms-100",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3) {\\n            return 0;\\n        }\\n        if (grid[0].length < 3) {\\n            return 0;\\n        }\\n\\n        int magic = 0;\\n        for (int y = 0; y < grid.length - 2; y++) {\\n            for (int x = 0; x < grid.length - 2; x++) {\\n                int c1 = grid[y][x];\\n                int c2 = grid[y][x + 1];\\n                int c3 = grid[y][x + 2];\\n                if (c1 < 1 || c1 > 9 || c2 < 1 || c2 > 9 || c3 < 1 || c3 > 9) {\\n                    continue;\\n                }\\n\\n                int c4 = grid[y + 1][x];\\n                int c5 = grid[y + 1][x + 1];\\n                int c6 = grid[y + 1][x + 2];\\n                if (c4 < 1 || c4 > 9 || c5 < 1 || c5 > 9 || c6 < 1 || c6 > 9) {\\n                    continue;\\n                }\\n\\n                int c7 = grid[y + 2][x];\\n                int c8 = grid[y + 2][x + 1];\\n                int c9 = grid[y + 2][x + 2];\\n                if (c7 < 1 || c7 > 9 || c8 < 1 || c8 > 9 || c9 < 1 || c9 > 9) {\\n                    continue;\\n                }\\n\\n                int row1 = c1 + c2 + c3;\\n                int row2 = c4 + c5 + c6;\\n                int row3 = c7 + c8 + c9;\\n\\n                int col1 = c1 + c4 + c7;\\n                int col2 = c2 + c5 + c8;\\n                int col3 = c3 + c6 + c9;\\n\\n                int diag1 = c1 + c5 + c9;\\n                int diag2 = c7 + c5 + c3;\\n\\n                if (c1 != c2 && c2 != c3 && c3 != c4 && c4 != c5 && c5 != c6 && c6 != c7 && c7 != c8 && c8 != c9) {\\n                    if (row1 + row2 + row3 == 45 && row1 == row2 && row2 == row3 && col1 == col2 && col2 == col3 && diag1 == diag2) {\\n                        magic++;\\n                    }\\n                }\\n            }\\n        }\\n        return magic;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if (grid.length < 3) {\\n            return 0;\\n        }\\n        if (grid[0].length < 3) {\\n            return 0;\\n        }\\n\\n        int magic = 0;\\n        for (int y = 0; y < grid.length - 2; y++) {\\n            for (int x = 0; x < grid.length - 2; x++) {\\n                int c1 = grid[y][x];\\n                int c2 = grid[y][x + 1];\\n                int c3 = grid[y][x + 2];\\n                if (c1 < 1 || c1 > 9 || c2 < 1 || c2 > 9 || c3 < 1 || c3 > 9) {\\n                    continue;\\n                }\\n\\n                int c4 = grid[y + 1][x];\\n                int c5 = grid[y + 1][x + 1];\\n                int c6 = grid[y + 1][x + 2];\\n                if (c4 < 1 || c4 > 9 || c5 < 1 || c5 > 9 || c6 < 1 || c6 > 9) {\\n                    continue;\\n                }\\n\\n                int c7 = grid[y + 2][x];\\n                int c8 = grid[y + 2][x + 1];\\n                int c9 = grid[y + 2][x + 2];\\n                if (c7 < 1 || c7 > 9 || c8 < 1 || c8 > 9 || c9 < 1 || c9 > 9) {\\n                    continue;\\n                }\\n\\n                int row1 = c1 + c2 + c3;\\n                int row2 = c4 + c5 + c6;\\n                int row3 = c7 + c8 + c9;\\n\\n                int col1 = c1 + c4 + c7;\\n                int col2 = c2 + c5 + c8;\\n                int col3 = c3 + c6 + c9;\\n\\n                int diag1 = c1 + c5 + c9;\\n                int diag2 = c7 + c5 + c3;\\n\\n                if (c1 != c2 && c2 != c3 && c3 != c4 && c4 != c5 && c5 != c6 && c6 != c7 && c7 != c8 && c8 != c9) {\\n                    if (row1 + row2 + row3 == 45 && row1 == row2 && row2 == row3 && col1 == col2 && col2 == col3 && diag1 == diag2) {\\n                        magic++;\\n                    }\\n                }\\n            }\\n        }\\n        return magic;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660233,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<stdio.h>\\n#include<stdlib.h>\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<stdio.h>\\n#include<stdlib.h>\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0};\\n                for (int k = 0; k < 3; k++) {\\n                    for (int l = 0; l < 3; l++) {\\n                        if (grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9 || seen[grid[i + k][j + l]]) {\\n                            goto next;\\n                        }\\n                        seen[grid[i + k][j + l]] = 1;\\n                    }\\n                }\\n                count++;\\n            }\\n            next:;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3620003,
                "title": "runtime-0-ms-beats-100-intuition-and-approach-java",
                "content": "# Intuition and Approach :\\nThe given code provides a solution for the \"Magic Squares In Grid\" problem. The problem requires us to count the number of 3x3 magic squares in the given grid.\\n\\nLet\\'s understand the intuition and approach used in the code:\\n\\n- The code begins by checking the dimensions of the grid. If either the number of rows or the number of columns is less than 3, it means there are not enough cells to form a 3x3 magic square. In such cases, the code returns 0.\\n\\n- A variable magicSquares is initialized to keep track of the count of magic squares found.\\n\\n- The code uses two nested loops to iterate over the grid, excluding the last two rows and the last two columns. This is done to ensure that there are enough cells remaining in the grid to form a 3x3 magic square.\\n\\n- For each starting cell (i, j) in the grid, the code checks if it forms a magic square by calling the isMagicSquare helper function.\\n\\n- The isMagicSquare function checks the properties of a magic square starting from the given row row and column col.\\n\\n- Inside the isMagicSquare function, an array seen is used to keep track of numbers seen so far. It is initialized as a boolean array of size 10, with all values initially set to false. The purpose of this array is to ensure that each number from 1 to 9 appears exactly once in the magic square.\\n\\n- The function calculates the expected sum of the magic square by summing the values in the first row starting from the given row and col position.\\n\\n- The function then checks the row sums by iterating over each row and summing the values. It also checks if each number in the grid is within the range of 1 to 9 and has not been seen before. If any of these conditions fail, it returns false.\\n\\n- After checking the row sums, the function checks the column sums by iterating over each column and summing the values. If any column sum does not equal the expected sum, the function returns false.\\n\\n- Finally, the function checks the two diagonal sums. If either diagonal sum does not equal the expected sum, the function returns false.\\n\\n- If all the checks pass, the function returns true, indicating that the 3x3 grid starting from (row, col) is a magic square.\\n\\n- The main function counts the number of magic squares found by incrementing magicSquares whenever the isMagicSquare function returns true.\\n\\n- Finally, the count of magic squares is returned as the result.\\n\\nThe approach followed in this code involves iterating over each possible 3x3 grid in the given grid and checking if it forms a magic square according to the defined properties. By using helper functions and carefully checking the row sums, column sums, and diagonal sums, the code efficiently determines the count of magic squares.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3){\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n\\n    private boolean isMagicSquare(int[][] grid, int row, int col){\\n        boolean[] seen = new boolean[10];\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n\\n        //ROW SUM :\\n        for(int i = row; i <= row+2; i++){\\n            tempSum = 0;\\n            for(int j = col; j <= col+2; j++){\\n                if(grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]){\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if(tempSum != sum){\\n                return false;\\n            }\\n        }\\n\\n        // COL SUM :\\n        for(int j = col; j <= col+2; j++){\\n            if(grid[row][j] + grid[row+1][j] + grid[row+2][j] != sum){\\n                return false;\\n            }\\n        }\\n\\n        // DIAG SUM :\\n        if(grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Complexity :\\nThe time complexity of the code is O(N^2), where N is the number of rows or columns in the grid. This is because the code iterates over each starting cell of the 3x3 grid, resulting in N^2 iterations in total.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3){\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n\\n    private boolean isMagicSquare(int[][] grid, int row, int col){\\n        boolean[] seen = new boolean[10];\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n\\n        //ROW SUM :\\n        for(int i = row; i <= row+2; i++){\\n            tempSum = 0;\\n            for(int j = col; j <= col+2; j++){\\n                if(grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]){\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if(tempSum != sum){\\n                return false;\\n            }\\n        }\\n\\n        // COL SUM :\\n        for(int j = col; j <= col+2; j++){\\n            if(grid[row][j] + grid[row+1][j] + grid[row+2][j] != sum){\\n                return false;\\n            }\\n        }\\n\\n        // DIAG SUM :\\n        if(grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613670,
                "title": "easy-java-solution-0ms-with-explanation-o-1-space-complexity",
                "content": "# Intuition\\nMagic Square is a matrix square which has a size of n * n and only contains numbers from 1 to 9 (included). We should also keep in mind that the number 5 is always in the center of the matrix.\\n\\n# Approach\\nCheck every possible 3 * 3 matrix if it is a magic square.\\nWe will make use of an external method called (checker) to check whether the corresponding matrix is Magic or not.\\n\\n# Complexity\\n- Time complexity: Think it is Number of possible 3 * 3 matrix multiplied by 9.\\n\\n- Space complexity:Since we wont be creating any redundant matrix the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rowlen = grid.length;\\n        int collen = grid[0].length;\\n        int res = 0;\\n        for(int i = 0;i < rowlen - 2; i++){\\n            for(int j = 0; j < collen - 2; j++){\\n                //Check if middle element is 5\\n                if(grid[i + 1][j + 1] != 5) continue;\\n                if(checker(grid, i, j)) res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean checker(int[][] grid, int rowstart, int colstart){\\n        int[] counter = new int[10];\\n\\n        //row checking\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            int sum = 0;\\n            for(int j = colstart; j < (colstart + 3); j++){\\n                int number = grid[i][j];\\n                if(number > 9 || number < 1) return false;\\n                counter[number]++;\\n                if(counter[number] > 1) return false;\\n                sum += number;\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n\\n        //column checking\\n        for(int i = colstart; i < (colstart + 3); i++){\\n            int sum = 0;\\n            for(int j = rowstart; j < (rowstart + 3); j++){\\n                sum += grid[j][i];\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n        //diagonal (top left to bottom right)\\n        int tmpsum = 0;\\n        int tmpcol = colstart;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol++];\\n        }\\n        if(tmpsum != 15) return false;\\n\\n        //diagonal (top right to bottom left)\\n        tmpsum = 0;\\n        tmpcol = colstart + 2;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol--];\\n        }\\n        if(tmpsum != 15) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int rowlen = grid.length;\\n        int collen = grid[0].length;\\n        int res = 0;\\n        for(int i = 0;i < rowlen - 2; i++){\\n            for(int j = 0; j < collen - 2; j++){\\n                //Check if middle element is 5\\n                if(grid[i + 1][j + 1] != 5) continue;\\n                if(checker(grid, i, j)) res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean checker(int[][] grid, int rowstart, int colstart){\\n        int[] counter = new int[10];\\n\\n        //row checking\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            int sum = 0;\\n            for(int j = colstart; j < (colstart + 3); j++){\\n                int number = grid[i][j];\\n                if(number > 9 || number < 1) return false;\\n                counter[number]++;\\n                if(counter[number] > 1) return false;\\n                sum += number;\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n\\n        //column checking\\n        for(int i = colstart; i < (colstart + 3); i++){\\n            int sum = 0;\\n            for(int j = rowstart; j < (rowstart + 3); j++){\\n                sum += grid[j][i];\\n            }\\n            if(sum != 15) return false;\\n        }\\n\\n        //diagonal (top left to bottom right)\\n        int tmpsum = 0;\\n        int tmpcol = colstart;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol++];\\n        }\\n        if(tmpsum != 15) return false;\\n\\n        //diagonal (top right to bottom left)\\n        tmpsum = 0;\\n        tmpcol = colstart + 2;\\n        for(int i = rowstart;i < (rowstart + 3); i++){\\n            tmpsum += grid[i][tmpcol--];\\n        }\\n        if(tmpsum != 15) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517690,
                "title": "easy-and-understandable-cpp-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if (grid.size()<3 || grid[0].size()<3)\\n        {\\n            return 0;\\n        }\\n\\n        // Counter = 0\\n        int c = 0;\\n\\n        // NEsted for loop for iterating through each point\\n        for (int i=0; i<grid.size()-2; i++)\\n        {\\n            for (int j=0; j<grid[i].size()-2; j++)\\n            {\\n                // Making the square matrix of 3x3\\n                vector<vector<int>> mat;\\n                for (int k=0; k<3; k++)\\n                {\\n                    vector<int> v;\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        v.push_back(0);\\n                    }\\n                    mat.push_back(v);   \\n                }\\n\\n                // Adding the values of grid into 3x3 matrix\\n                int cr = 0;\\n                for (int k=i; k<i+3; k++)\\n                {\\n                    int cc=0;\\n                    for (int m=j; m<j+3; m++)\\n                    {\\n                        mat[cr][cc] = grid[k][m];\\n                        cc++;\\n                    }\\n                    cr++;\\n                }\\n\\n                // Declaring a set\\n                // Erase all the elements which occured in the set\\n                // It helps us to identify whether all integers from 1 to 9 is present or not\\n                set <int> s ({1, 2, 3, 4, 5, 6, 7, 8, 9});\\n                for (int k=0; k<3; k++)\\n                {\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        s.erase(mat[k][m]);\\n                    }   \\n                }\\n\\n                // Finding all the required sums need to be checked\\n                int r1s = mat[0][0] + mat[0][1] + mat[0][2];\\n                int r2s = mat[1][0] + mat[1][1] + mat[1][2];\\n                int r3s = mat[2][0] + mat[2][1] + mat[2][2];\\n                int c1s = mat[0][0] + mat[1][0] + mat[2][0];\\n                int c2s = mat[0][1] + mat[1][1] + mat[2][1];\\n                int c3s = mat[0][2] + mat[1][2] + mat[2][2];\\n                int d1s = mat[0][0] + mat[1][1] + mat[2][2];\\n                int d2s = mat[0][2] + mat[1][1] + mat[2][0];\\n\\n                // If the set is empty and all sums are same it means we have found the magic square\\n                if (s.empty())\\n                {\\n                    if (r1s==r2s && r1s==r3s && r1s==c1s && r1s==c2s && r1s==c3s && r1s==d1s && r1s==d2s)\\n                    {\\n                        c++;\\n                    }\\n                }\\n\\n                cout << endl;\\n\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if (grid.size()<3 || grid[0].size()<3)\\n        {\\n            return 0;\\n        }\\n\\n        // Counter = 0\\n        int c = 0;\\n\\n        // NEsted for loop for iterating through each point\\n        for (int i=0; i<grid.size()-2; i++)\\n        {\\n            for (int j=0; j<grid[i].size()-2; j++)\\n            {\\n                // Making the square matrix of 3x3\\n                vector<vector<int>> mat;\\n                for (int k=0; k<3; k++)\\n                {\\n                    vector<int> v;\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        v.push_back(0);\\n                    }\\n                    mat.push_back(v);   \\n                }\\n\\n                // Adding the values of grid into 3x3 matrix\\n                int cr = 0;\\n                for (int k=i; k<i+3; k++)\\n                {\\n                    int cc=0;\\n                    for (int m=j; m<j+3; m++)\\n                    {\\n                        mat[cr][cc] = grid[k][m];\\n                        cc++;\\n                    }\\n                    cr++;\\n                }\\n\\n                // Declaring a set\\n                // Erase all the elements which occured in the set\\n                // It helps us to identify whether all integers from 1 to 9 is present or not\\n                set <int> s ({1, 2, 3, 4, 5, 6, 7, 8, 9});\\n                for (int k=0; k<3; k++)\\n                {\\n                    for (int m=0; m<3; m++)\\n                    {\\n                        s.erase(mat[k][m]);\\n                    }   \\n                }\\n\\n                // Finding all the required sums need to be checked\\n                int r1s = mat[0][0] + mat[0][1] + mat[0][2];\\n                int r2s = mat[1][0] + mat[1][1] + mat[1][2];\\n                int r3s = mat[2][0] + mat[2][1] + mat[2][2];\\n                int c1s = mat[0][0] + mat[1][0] + mat[2][0];\\n                int c2s = mat[0][1] + mat[1][1] + mat[2][1];\\n                int c3s = mat[0][2] + mat[1][2] + mat[2][2];\\n                int d1s = mat[0][0] + mat[1][1] + mat[2][2];\\n                int d2s = mat[0][2] + mat[1][1] + mat[2][0];\\n\\n                // If the set is empty and all sums are same it means we have found the magic square\\n                if (s.empty())\\n                {\\n                    if (r1s==r2s && r1s==r3s && r1s==c1s && r1s==c2s && r1s==c3s && r1s==d1s && r1s==d2s)\\n                    {\\n                        c++;\\n                    }\\n                }\\n\\n                cout << endl;\\n\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3515978,
                "title": "brute-force",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        res = 0\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                r = [0, 0, 0]\\n                c = [0, 0, 0]\\n                a = b = 0\\n                used = [0] * 9\\n                for x in range(i - 1, i + 2):\\n                    a += grid[x][j + x - i]\\n                    b += grid[x][j - x + i]\\n                    for y in range(j - 1, j + 2):\\n                        if 1 <= grid[x][y] <= 9:\\n                            used[grid[x][y] - 1] = 1\\n                        r[x - i + 1] += grid[x][y]\\n                        c[y - j + 1] += grid[x][y]\\n                if sum(used) == 9 and r[0] == r[1] == r[2] == c[0] == c[1] == c[2] == a == b:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        res = 0\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                r = [0, 0, 0]\\n                c = [0, 0, 0]\\n                a = b = 0\\n                used = [0] * 9\\n                for x in range(i - 1, i + 2):\\n                    a += grid[x][j + x - i]\\n                    b += grid[x][j - x + i]\\n                    for y in range(j - 1, j + 2):\\n                        if 1 <= grid[x][y] <= 9:\\n                            used[grid[x][y] - 1] = 1\\n                        r[x - i + 1] += grid[x][y]\\n                        c[y - j + 1] += grid[x][y]\\n                if sum(used) == 9 and r[0] == r[1] == r[2] == c[0] == c[1] == c[2] == a == b:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513705,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int dir[] = new int []{0,1,-1};\\n        int count= 0;\\n        for (int i=1;i<grid.length-1;i++){\\n            outer:\\n            for (int j=1;j<grid[0].length-1;j++){\\n                int sum =grid [i-1][j-1] + grid[i][j] + grid[i+1][j+1];\\n                if (sum!=grid [i+1][j-1] + grid[i][j] + grid[i-1][j+1]) continue;\\n                for (int d :dir){\\n                    if(sum != grid [i+d][j-1] + grid[i+d][j] + grid[i+d][j+1]) continue outer;\\n                    if(sum != grid [i+1][j+d] + grid[i][j+d] + grid[i-1][j+d]) continue outer;\\n                }\\n                boolean[] includesZtoN = new boolean[9];\\n                for (int d1:dir)\\n                    for (int d2:dir){ \\n                        int cur = grid[i+d1][j+d2];\\n                        if (cur>9 || cur <1 ||includesZtoN[cur-1]) continue outer;\\n                        includesZtoN[cur-1] = true;\\n                    }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int dir[] = new int []{0,1,-1};\\n        int count= 0;\\n        for (int i=1;i<grid.length-1;i++){\\n            outer:\\n            for (int j=1;j<grid[0].length-1;j++){\\n                int sum =grid [i-1][j-1] + grid[i][j] + grid[i+1][j+1];\\n                if (sum!=grid [i+1][j-1] + grid[i][j] + grid[i-1][j+1]) continue;\\n                for (int d :dir){\\n                    if(sum != grid [i+d][j-1] + grid[i+d][j] + grid[i+d][j+1]) continue outer;\\n                    if(sum != grid [i+1][j+d] + grid[i][j+d] + grid[i-1][j+d]) continue outer;\\n                }\\n                boolean[] includesZtoN = new boolean[9];\\n                for (int d1:dir)\\n                    for (int d2:dir){ \\n                        int cur = grid[i+d1][j+d2];\\n                        if (cur>9 || cur <1 ||includesZtoN[cur-1]) continue outer;\\n                        includesZtoN[cur-1] = true;\\n                    }\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482975,
                "title": "java-correct-this-problem",
                "content": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int sum = 0;\\n        for(int col = 0; col <n; col++) {\\n            sum = sum+grid[0][col];\\n        }\\n        \\n        \\n        for(int row = 0; row<n; row++) {\\n            int rSum = 0;\\n            for(int col = 0; col <n;col++) {\\n                rSum = rSum+grid[row][col];\\n            }\\n            if(rSum != sum) {\\n                return 0;\\n            }\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int cSum = 0;\\n            for(int row = 0; row <n;row++) {\\n                cSum = cSum+grid[row][col];\\n            }\\n            if(cSum != sum) {\\n                return 0;\\n            }\\n        }\\n        \\n        int dSum = 0;\\n        for(int i = 0; i<n; i++) {\\n            dSum = dSum+grid[i][i];\\n        }\\n        \\n        if(dSum != sum) {\\n                return 0;\\n            }\\n        \\n        int Adsum = 0;\\n        for(int i = 0; i<n; i++) {\\n            Adsum = Adsum+grid[i][n-1-i];\\n        }\\n        if(Adsum != sum) {\\n                return 0;\\n            }\\n        \\n        return 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int sum = 0;\\n        for(int col = 0; col <n; col++) {\\n            sum = sum+grid[0][col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3463529,
                "title": "shortest-code",
                "content": "your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        # Construct the 3x3 square\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid)-2):\\n                temp_grid = [grid[i+k][j:j+3] for k in range(3)]\\n                if self.isMagicSquare(temp_grid):\\n                    cnt += 1\\n        \\n        return cnt\\n        \\n    \\n    def isMagicSquare(self, grid):\\n        \\'\\'\\'\\n        Check whether the given grid is a magic square\\n        \\'\\'\\'\\n        # Check the elements\\n        flat = [num for row in grid for num in row]\\n        if sorted(flat) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n            return False\\n        \\n        # Check the row, column and diagnal sums\\n        row_sums = [sum(row) for row in grid]\\n        col_sums = [sum([row[i] for row in grid]) for i in range(3)]\\n        diag_sums = [sum([grid[i][i] for i in range(3)]), (grid[0][2] + grid[1][1] + grid[2][0])]\\n        row_sums.extend(col_sums)\\n        row_sums.extend(diag_sums)\\n        return len(set(row_sums)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462864,
                "title": "javascripts-with-3x3-subarrays",
                "content": "Algorithm\\n1. Find 3x3 subgrid in grid\\n2. Check if it is magic squar:\\na) calculate sum on diagonals, rows and columns\\nor\\nb) there is a finite number of magic squares 3x3, so u can just put them into array and check it\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    \\n    let count = 0;\\n\\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n\\n            // get 3x3 subgrid\\n            arr = getSubGrid(grid,i,j)\\n           \\n            if (magicSquares.has(arr.flat(Infinity).join(\"\"))) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n  \\n};\\n\\nfunction getSubGrid(grid,i,j) {\\n    arr = []\\n    for (let k = 0; k < 3; k++) { \\n        arr1 = []\\n        for (let l = 0; l < 3; l++) {\\n            const num = grid[i + k][j + l];\\n            arr1.push(num)\\n        }\\n        arr.push(arr1)\\n    }\\n\\n    return arr;\\n}\\n\\nconst magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function(grid) {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    \\n    let count = 0;\\n\\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n\\n            // get 3x3 subgrid\\n            arr = getSubGrid(grid,i,j)\\n           \\n            if (magicSquares.has(arr.flat(Infinity).join(\"\"))) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n  \\n};\\n\\nfunction getSubGrid(grid,i,j) {\\n    arr = []\\n    for (let k = 0; k < 3; k++) { \\n        arr1 = []\\n        for (let l = 0; l < 3; l++) {\\n            const num = grid[i + k][j + l];\\n            arr1.push(num)\\n        }\\n        arr.push(arr1)\\n    }\\n\\n    return arr;\\n}\\n\\nconst magicSquares = new Set([\\n    \\'276951438\\',\\n    \\'294753618\\',\\n    \\'438951276\\',\\n    \\'492357816\\',\\n    \\'618753294\\',\\n    \\'672159834\\',\\n    \\'816357492\\',\\n    \\'834159672\\',\\n  ]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462860,
                "title": "c-note",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n         if(grid.Length < 3 || grid[0].Length < 3) return 0;\\n         int result=0;\\n        for (int i = 0; i < grid.Length - 2; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; j++)\\n                {List<int> ks1 = new List<int>();\\n\\n                    ks1.Add(grid[i][j]);\\n                    ks1.Add(grid[i][j + 1]);\\n                    ks1.Add(grid[i][j + 2]);\\n                    ks1.Add(grid[i + 1][j]);\\n                    ks1.Add(grid[i + 1][j + 1]);\\n                    ks1.Add(grid[i + 1][j + 2]);\\n                    ks1.Add(grid[i + 2][j]);\\n                    ks1.Add(grid[i + 2][j + 1]);\\n                    ks1.Add(grid[i + 2][j + 2]);\\n                    var numberGroups = ks1.GroupBy(LL => LL)\\n                               .Select(grp => new\\n                               {\\n                                   number = grp.Key,\\n                                   total = grp.Count()\\n                               })\\n                   .ToArray();\\n                    if (numberGroups.Where(w => w.total > 1||w.number>9).Count() == 0)\\n                    {\\n                        int ans =15;\\n                        if (\\n                           (grid[i][j] + grid[i][j + 1] + grid[i][j + 2]) == ans &&\\n                           (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j] + grid[i + 2][j]) == ans &&\\n                           (grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1]) == ans &&\\n                           (grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 1][j + 1] + grid[i][j + 2]) == ans\\n                            )\\n                        {\\n                            result = result + 1;\\n                        }\\n                    }\\n\\n                }\\n            }\\nreturn result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumMagicSquaresInside(int[][] grid) {\\n         if(grid.Length < 3 || grid[0].Length < 3) return 0;\\n         int result=0;\\n        for (int i = 0; i < grid.Length - 2; i++)\\n            {\\n                for (int j = 0; j < grid[0].Length - 2; j++)\\n                {List<int> ks1 = new List<int>();\\n\\n                    ks1.Add(grid[i][j]);\\n                    ks1.Add(grid[i][j + 1]);\\n                    ks1.Add(grid[i][j + 2]);\\n                    ks1.Add(grid[i + 1][j]);\\n                    ks1.Add(grid[i + 1][j + 1]);\\n                    ks1.Add(grid[i + 1][j + 2]);\\n                    ks1.Add(grid[i + 2][j]);\\n                    ks1.Add(grid[i + 2][j + 1]);\\n                    ks1.Add(grid[i + 2][j + 2]);\\n                    var numberGroups = ks1.GroupBy(LL => LL)\\n                               .Select(grp => new\\n                               {\\n                                   number = grp.Key,\\n                                   total = grp.Count()\\n                               })\\n                   .ToArray();\\n                    if (numberGroups.Where(w => w.total > 1||w.number>9).Count() == 0)\\n                    {\\n                        int ans =15;\\n                        if (\\n                           (grid[i][j] + grid[i][j + 1] + grid[i][j + 2]) == ans &&\\n                           (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j] + grid[i + 2][j]) == ans &&\\n                           (grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1]) == ans &&\\n                           (grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) == ans &&\\n                           (grid[i + 2][j] + grid[i + 1][j + 1] + grid[i][j + 2]) == ans\\n                            )\\n                        {\\n                            result = result + 1;\\n                        }\\n                    }\\n\\n                }\\n            }\\nreturn result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460742,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        if(3>grid.length || 3>grid[0].length)\\n            return 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) \\n                if (magicSquare(i, j, 3, grid)) \\n                    count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean magicSquare(int row, int col, int k, int[][]grid) {\\n        int sumDiag1 = 0;\\n        int sumDiag2 = 0; \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = row; i<row+k; i++)\\n            for(int j = col; j<col+k; j++){\\n                if(grid[i][j]>9 || grid[i][j]< 1 || map.getOrDefault(grid[i][j], 0)>=1)\\n                    return false;\\n                map.put(grid[i][j], 1);\\n            }\\n        for (int i = 0; i < k; i++) {\\n            sumDiag1 += grid[row + i][col + i];\\n            sumDiag2 += grid[row + i][col + k - 1 - i];\\n        }\\n        if (sumDiag1 != sumDiag2) \\n            return false;\\n        for (int i = 0; i < k; i++) {\\n            int sumRow = 0;\\n            int sumCol = 0;\\n            for (int j = 0; j < k; j++) {\\n                sumRow += grid[row + i][col + j];\\n                sumCol += grid[row + j][col + i];\\n            }\\n            if (sumRow != sumDiag1 || sumCol != sumDiag1) \\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        if(3>grid.length || 3>grid[0].length)\\n            return 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) \\n                if (magicSquare(i, j, 3, grid)) \\n                    count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean magicSquare(int row, int col, int k, int[][]grid) {\\n        int sumDiag1 = 0;\\n        int sumDiag2 = 0; \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = row; i<row+k; i++)\\n            for(int j = col; j<col+k; j++){\\n                if(grid[i][j]>9 || grid[i][j]< 1 || map.getOrDefault(grid[i][j], 0)>=1)\\n                    return false;\\n                map.put(grid[i][j], 1);\\n            }\\n        for (int i = 0; i < k; i++) {\\n            sumDiag1 += grid[row + i][col + i];\\n            sumDiag2 += grid[row + i][col + k - 1 - i];\\n        }\\n        if (sumDiag1 != sumDiag2) \\n            return false;\\n        for (int i = 0; i < k; i++) {\\n            int sumRow = 0;\\n            int sumCol = 0;\\n            for (int j = 0; j < k; j++) {\\n                sumRow += grid[row + i][col + j];\\n                sumCol += grid[row + j][col + i];\\n            }\\n            if (sumRow != sumDiag1 || sumCol != sumDiag1) \\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441483,
                "title": "java-step-by-step-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length-2;i++){\\n            for(int j=0;j<grid[0].length-2;j++){\\n                if(sum(grid,i,j)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean sum(int grid[][],int row,int col){\\n        //checking element of selected 3x3 have unique element or not And less than 10 and not equal to 0 as well ;\\n        HashSet<Integer> visited=new HashSet<>();\\n        for(int i=row;i<row+3;i++){\\n            for(int j=col;j<col+3;j++){\\n                if(visited.contains(grid[i][j]) || grid[i][j]>9 || grid[i][j]==0) return false;\\n                visited.add(grid[i][j]);\\n            }\\n        }\\n        // sum of element of left row and right row\\n        ArrayList<Integer> list=new ArrayList<>();\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=row;i<row+3;i++){\\n            sum1+=grid[i][col];\\n            sum2+=grid[i][col+2];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of upper column and lower column\\n        sum1=0;\\n        sum2=0;\\n        for(int i=col;i<col+3;i++){\\n            sum1+=grid[row][i];\\n            sum2+=grid[row+2][i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        // sum of element of both diagonals\\n        sum1=0;\\n        sum2=0;\\n        for(int i=0;i<3;i++){\\n            sum1+=grid[row+i][col+i];\\n            sum2+=grid[row+i][col+2-i];\\n        }\\n        list.add(sum1);\\n        list.add(sum2);\\n        //checking all sum is equal or not;\\n        for(int i=0;i<6;i++){\\n            if(list.get(0)!=list.get(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391886,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n            \\n            row_sums = [sum(r) for r in sub_grid]\\n            if len(set(row_sums)) > 1:\\n                return False\\n\\n            col_sums = [sum([row[i] for row in sub_grid]) for i in range(3)]\\n            if len(set(col_sums)) > 1 and row_sums[0] != col_sums[0]:\\n                return False\\n            \\n            diag_sums = sum([sub_grid[i][i] for i in range(3)])\\n            return diag_sums == row_sums[0]\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n            \\n            row_sums = [sum(r) for r in sub_grid]\\n            if len(set(row_sums)) > 1:\\n                return False\\n\\n            col_sums = [sum([row[i] for row in sub_grid]) for i in range(3)]\\n            if len(set(col_sums)) > 1 and row_sums[0] != col_sums[0]:\\n                return False\\n            \\n            diag_sums = sum([sub_grid[i][i] for i in range(3)])\\n            return diag_sums == row_sums[0]\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391817,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n\\n            if sum(sub_grid[0]) != sum(sub_grid[1]) != sum(sub_grid[2]):\\n                return False\\n            r_sum = sum(sub_grid[0])\\n\\n            if r_sum != (sub_grid[0][0] + sub_grid[1][0] + sub_grid[2][0]) != (sub_grid[0][1] + sub_grid[1][1] + sub_grid[2][1]) != (sub_grid[0][2] + sub_grid[1][2] + sub_grid[2][2]):\\n                return False\\n            \\n            if r_sum != (sub_grid[0][0] + sub_grid[1][1] + sub_grid[2][2]):\\n                return False\\n            \\n            return True\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def isMagic(sub_grid):\\n            arr = []\\n            for i in range(len(sub_grid)):\\n                for j in range(len(sub_grid[0])):\\n                    arr.append(sub_grid[i][j])\\n            if sorted(arr) != [1, 2, 3, 4, 5, 6, 7, 8, 9]:\\n                return False\\n\\n            if sum(sub_grid[0]) != sum(sub_grid[1]) != sum(sub_grid[2]):\\n                return False\\n            r_sum = sum(sub_grid[0])\\n\\n            if r_sum != (sub_grid[0][0] + sub_grid[1][0] + sub_grid[2][0]) != (sub_grid[0][1] + sub_grid[1][1] + sub_grid[2][1]) != (sub_grid[0][2] + sub_grid[1][2] + sub_grid[2][2]):\\n                return False\\n            \\n            if r_sum != (sub_grid[0][0] + sub_grid[1][1] + sub_grid[2][2]):\\n                return False\\n            \\n            return True\\n\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]\\n                if(isMagic(sub_grid)):\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382869,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int r,int c,vector<vector<int>>& grid)\\n    {\\n      vector<int>vis(16,0);\\n      int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n      for (int i=r;i<r+3;i++)\\n      {\\n          int cnt=0;\\n          for (int j=c;j<c+3;j++)\\n          {\\n             vis[grid[i][j]]=1;\\n             cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n       for (int i=1;i<=9;i++) \\n      {\\n          if (!vis[i]) return false;\\n      }\\n     \\n      for (int j=c;j<c+3;j++)\\n      {\\n          int cnt=0;\\n          for (int i=r;i<r+3;i++)\\n          {\\n            cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n      if (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2]!=sum) return false;\\n      if (grid[r][c+2]+grid[r+1][c+1]+grid[r+2][c]!=sum) return false;\\n      return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<=n-3;i++)\\n        {\\n            for (int j=0;j<=m-3;j++)\\n            {\\n               if (check(i,j,grid)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int r,int c,vector<vector<int>>& grid)\\n    {\\n      vector<int>vis(16,0);\\n      int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];\\n      for (int i=r;i<r+3;i++)\\n      {\\n          int cnt=0;\\n          for (int j=c;j<c+3;j++)\\n          {\\n             vis[grid[i][j]]=1;\\n             cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n       for (int i=1;i<=9;i++) \\n      {\\n          if (!vis[i]) return false;\\n      }\\n     \\n      for (int j=c;j<c+3;j++)\\n      {\\n          int cnt=0;\\n          for (int i=r;i<r+3;i++)\\n          {\\n            cnt+=grid[i][j];\\n          }\\n          if (cnt!=sum) return false;\\n      }\\n      if (grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2]!=sum) return false;\\n      if (grid[r][c+2]+grid[r+1][c+1]+grid[r+2][c]!=sum) return false;\\n      return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<=n-3;i++)\\n        {\\n            for (int j=0;j<=m-3;j++)\\n            {\\n               if (check(i,j,grid)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373384,
                "title": "easy-python",
                "content": "\\tclass Solution:\\n\\t\\tdef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(len(grid)-2):\\n\\t\\t\\t\\tfor j in range(len(grid)-2):\\n\\t\\t\\t\\t\\tcoll=set()\\n\\t\\t\\t\\t\\tnumSet = set()\\n\\t\\t\\t\\t\\tfor r in range(3):\\n\\t\\t\\t\\t\\t\\tfor c in range(3):\\n\\t\\t\\t\\t\\t\\t\\tnum = grid[r+i][c+j]\\n\\t\\t\\t\\t\\t\\t\\tnumSet.add(num)\\n\\t\\t\\t\\t\\tif list(numSet)!=[1,2,3,4,5,6,7,8,9]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tsumall=sum(grid[i][j:j+3])\\n\\t\\t\\t\\t\\tif (sumall!=sum(grid[i+1][j:j+3]))or(sumall!=sum(grid[i+2][j:j+3])):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j]+grid[i+2][j] or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1])or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2] or sumall!=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\n\\t\\t\\treturn count\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(len(grid)-2):\\n\\t\\t\\t\\tfor j in range(len(grid)-2):\\n\\t\\t\\t\\t\\tcoll=set()\\n\\t\\t\\t\\t\\tnumSet = set()\\n\\t\\t\\t\\t\\tfor r in range(3):\\n\\t\\t\\t\\t\\t\\tfor c in range(3):\\n\\t\\t\\t\\t\\t\\t\\tnum = grid[r+i][c+j]\\n\\t\\t\\t\\t\\t\\t\\tnumSet.add(num)\\n\\t\\t\\t\\t\\tif list(numSet)!=[1,2,3,4,5,6,7,8,9]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tsumall=sum(grid[i][j:j+3])\\n\\t\\t\\t\\t\\tif (sumall!=sum(grid[i+1][j:j+3]))or(sumall!=sum(grid[i+2][j:j+3])):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j]+grid[i+2][j] or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1])or (sumall!=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif sumall!=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2] or sumall!=grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcount+=1\\n\\n\\t\\t\\treturn count\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3214736,
                "title": "simple-solution-just-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(rows*column)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(3*3)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0,m=grid.length,n=grid[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2>=m || j+2>=n ) continue;\\n                int reqsum=-1;\\n                boolean valid=true;\\n                Set<Integer>set=new HashSet<>();\\n\\n                //checking if 3x3 contains any duplicate element or element greater than 9 or element less than 1\\n                //if thats the case we will simply continue to our next 3x3 matrix\\n                 for(int k=i;k<=i+2;k++)\\n                {\\n                   \\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        if(set.contains(grid[k][l]) || grid[k][l] > 9 || grid [k][l] < 1) {valid=false;}\\n                        set.add(grid[i][j]);\\n                    }\\n                }\\n\\n                if(!valid) continue;\\n\\n                // checking all rows\\n                for(int k=i;k<=i+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        sum+=grid[k][l];\\n                    }\\n                  //  System.out.println(sum+\"R\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) { valid=false; break;}\\n                }\\n                if(!valid) continue;\\n\\n                //checking all columns\\n                for(int k=j;k<=j+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=i;l<=i+2;l++)\\n                    {\\n                        sum+=grid[l][k];\\n                    }\\n                  //  System.out.println(sum+\"C\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) {valid=false; break;}\\n                }\\n                 if(!valid) continue;\\n\\n                // checking top left diagnol\\n                int sum=0;\\n                for(int k=i,l=j;k<=i+2 && l<=j+2 ;k++,l++)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DL\");\\n\\n                \\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                sum=0;\\n                // checking top right dagnol;\\n                for(int k=i,l=j+2;k<=i+2 && l>=j ;k++,l--)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DR\");\\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                if(valid) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//[[5,5,5],[5,5,5],[5,5,5]]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count=0,m=grid.length,n=grid[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i+2>=m || j+2>=n ) continue;\\n                int reqsum=-1;\\n                boolean valid=true;\\n                Set<Integer>set=new HashSet<>();\\n\\n                //checking if 3x3 contains any duplicate element or element greater than 9 or element less than 1\\n                //if thats the case we will simply continue to our next 3x3 matrix\\n                 for(int k=i;k<=i+2;k++)\\n                {\\n                   \\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        if(set.contains(grid[k][l]) || grid[k][l] > 9 || grid [k][l] < 1) {valid=false;}\\n                        set.add(grid[i][j]);\\n                    }\\n                }\\n\\n                if(!valid) continue;\\n\\n                // checking all rows\\n                for(int k=i;k<=i+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=j;l<=j+2;l++)\\n                    {\\n                        sum+=grid[k][l];\\n                    }\\n                  //  System.out.println(sum+\"R\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) { valid=false; break;}\\n                }\\n                if(!valid) continue;\\n\\n                //checking all columns\\n                for(int k=j;k<=j+2;k++)\\n                {\\n                    int sum=0;\\n                    for(int l=i;l<=i+2;l++)\\n                    {\\n                        sum+=grid[l][k];\\n                    }\\n                  //  System.out.println(sum+\"C\");\\n                    if(reqsum==-1) reqsum=sum;\\n                    else if(reqsum!=sum) {valid=false; break;}\\n                }\\n                 if(!valid) continue;\\n\\n                // checking top left diagnol\\n                int sum=0;\\n                for(int k=i,l=j;k<=i+2 && l<=j+2 ;k++,l++)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DL\");\\n\\n                \\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                sum=0;\\n                // checking top right dagnol;\\n                for(int k=i,l=j+2;k<=i+2 && l>=j ;k++,l--)\\n                {\\n                    sum+=grid[k][l];\\n                }\\n               // System.out.println(sum+\"DR\");\\n                if(sum!=reqsum || !valid)\\n                {\\n                    valid=false;\\n                }\\n                if(valid) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//[[5,5,5],[5,5,5],[5,5,5]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152935,
                "title": "c-easy-understanding-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(int row,int col,vector<vector<int>>&arr){\\n        \\n        int n=arr.size();\\n        int m=arr[0].size();\\n        if(row+2>=n || col+2>=m){\\n            return false;\\n        }\\n        set<int> s;\\n        bool flag=1;\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if(arr[row+i][col+j]>9 || arr[row+i][col+j]<1){\\n                    return false;\\n                }\\n                s.insert(arr[row+i][col+j]);\\n            }\\n        }\\n        if(s.size()<9 || flag==0){\\n            return false;\\n        }\\n        long long sum1=0;\\n        long long sum2=0;\\n        sum1=sum1+arr[row][col]+arr[row+2][col+2]+arr[row+1][col+1];\\n        sum2=sum2+arr[row][col+2]+arr[row+2][col]+arr[row+1][col+1];\\n        s.clear();\\n        s.insert(sum1);\\n        s.insert(sum2);\\n        for(int i=0;i<3;i++){\\n            long long sum=0;\\n            for(int j=0;j<3;j++){\\n                sum=sum+arr[row+i][col+j];\\n            }\\n            s.insert(sum);\\n            if(s.size()>1){\\n                return false;\\n            }\\n        }\\n        for(int j=0;j<3;j++){\\n            long long sum=0;\\n            for(int i=0;i<3;i++){\\n                sum=sum+arr[row+i][col+j];\\n            }\\n            s.insert(sum);\\n            if(s.size()>1){\\n                return false;\\n            }\\n        }\\n        if(s.size()>1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(ispossible(i,j,grid)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool ispossible(int row,int col,vector<vector<int>>&arr){\\n        \\n        int n=arr.size();\\n        int m=arr[0].size();\\n        if(row+2>=n || col+2>=m){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3150556,
                "title": "python-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        # Helper function to check if a 3x3 subgrid is a magic square\\n        def is_magic_square(subgrid):\\n            # Flatten the subgrid into a single list\\n            flattened_subgrid = [num for row in subgrid for num in row]\\n            \\n            # Check if all numbers from 1 to 9 are present in the subgrid\\n            if sorted(flattened_subgrid) != [x for x in range(1, 10)]:\\n                return False\\n            \\n            # Check if all rows and columns have the same sum\\n            sum_of_first_row = sum(subgrid[0])\\n            for row in subgrid:\\n                if sum(row) != sum_of_first_row:\\n                    return False\\n            \\n            column1 = [row[0] for row in subgrid]\\n            column2 = [row[1] for row in subgrid]\\n            column3 = [row[2] for row in subgrid]\\n            if sum(column1) != sum_of_first_row or sum(column2) != sum_of_first_row or sum(column3) != sum_of_first_row:\\n                return False\\n            \\n            # Check if both diagonals have the same sum\\n            sum_of_main_diagonal = sum([subgrid[i][i] for i in range(3)])\\n            sum_of_other_diagonal = sum([subgrid[i][2-i] for i in range(3)])\\n            if sum_of_main_diagonal != sum_of_first_row or sum_of_other_diagonal != sum_of_first_row:\\n                return False\\n            \\n            return True\\n        \\n        # Counter for magic squares found in the grid\\n        magic_squares_count = 0\\n        \\n        # Get the number of rows and columns in the grid\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        \\n        # Iterate over each 3x3 subgrid\\n        for row in range(rows - 2):\\n            for col in range(columns - 2):\\n                subgrid = [grid[row][col:col+3], grid[row+1][col:col+3], grid[row+2][col:col+3]]\\n                if is_magic_square(subgrid):\\n                    magic_squares_count += 1\\n        \\n        return magic_squares_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        \\n        # Helper function to check if a 3x3 subgrid is a magic square\\n        def is_magic_square(subgrid):\\n            # Flatten the subgrid into a single list\\n            flattened_subgrid = [num for row in subgrid for num in row]\\n            \\n            # Check if all numbers from 1 to 9 are present in the subgrid\\n            if sorted(flattened_subgrid) != [x for x in range(1, 10)]:\\n                return False\\n            \\n            # Check if all rows and columns have the same sum\\n            sum_of_first_row = sum(subgrid[0])\\n            for row in subgrid:\\n                if sum(row) != sum_of_first_row:\\n                    return False\\n            \\n            column1 = [row[0] for row in subgrid]\\n            column2 = [row[1] for row in subgrid]\\n            column3 = [row[2] for row in subgrid]\\n            if sum(column1) != sum_of_first_row or sum(column2) != sum_of_first_row or sum(column3) != sum_of_first_row:\\n                return False\\n            \\n            # Check if both diagonals have the same sum\\n            sum_of_main_diagonal = sum([subgrid[i][i] for i in range(3)])\\n            sum_of_other_diagonal = sum([subgrid[i][2-i] for i in range(3)])\\n            if sum_of_main_diagonal != sum_of_first_row or sum_of_other_diagonal != sum_of_first_row:\\n                return False\\n            \\n            return True\\n        \\n        # Counter for magic squares found in the grid\\n        magic_squares_count = 0\\n        \\n        # Get the number of rows and columns in the grid\\n        rows = len(grid)\\n        columns = len(grid[0])\\n        \\n        # Iterate over each 3x3 subgrid\\n        for row in range(rows - 2):\\n            for col in range(columns - 2):\\n                subgrid = [grid[row][col:col+3], grid[row+1][col:col+3], grid[row+2][col:col+3]]\\n                if is_magic_square(subgrid):\\n                    magic_squares_count += 1\\n        \\n        return magic_squares_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086436,
                "title": "c",
                "content": "```\\n//center have to be 5\\n//other can\\' be 5\\n//itmes can\\'t bigger than 9, or less than 1\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int m = gridSize ;\\n    int n = *gridColSize ;\\n    if( m < 3 || n < 3)\\n        return 0 ;\\n    int ans = 0;\\n    for(int i = 0 ; i <= m-3; i++){\\n        for(int j = 0; j <= n-3; j++){\\n            if(grid[i+1][j+1] != 5)\\n                continue ;\\n            //row\\n            if(grid[i][j] == 5)\\n                continue ;\\n            for(int p = i; p < i+3; p++){\\n                int sum = 0;\\n                for(int q = j; q < j+3; q++){\\n                    if(grid[p][q] > 9 || grid[p][q] < 1)\\n                        goto next ;\\n                    sum += grid[p][q] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //col\\n            for(int p = j; p < j+3; p++){\\n                int sum = 0;\\n                for(int q = i; q < i+3; q++){\\n                    sum += grid[q][p] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //diag\\n            int sum = 0;\\n            sum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] ;\\n            if(sum != 15)\\n                goto next ;\\n            sum = 0;\\n            sum = grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] ;\\n            if(sum != 15)\\n                goto next ;\\n            ans++;\\n            next :\\n                continue ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//center have to be 5\\n//other can\\' be 5\\n//itmes can\\'t bigger than 9, or less than 1\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int m = gridSize ;\\n    int n = *gridColSize ;\\n    if( m < 3 || n < 3)\\n        return 0 ;\\n    int ans = 0;\\n    for(int i = 0 ; i <= m-3; i++){\\n        for(int j = 0; j <= n-3; j++){\\n            if(grid[i+1][j+1] != 5)\\n                continue ;\\n            //row\\n            if(grid[i][j] == 5)\\n                continue ;\\n            for(int p = i; p < i+3; p++){\\n                int sum = 0;\\n                for(int q = j; q < j+3; q++){\\n                    if(grid[p][q] > 9 || grid[p][q] < 1)\\n                        goto next ;\\n                    sum += grid[p][q] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //col\\n            for(int p = j; p < j+3; p++){\\n                int sum = 0;\\n                for(int q = i; q < i+3; q++){\\n                    sum += grid[q][p] ;\\n                }\\n                if(sum != 15)\\n                    goto next ;    \\n            }\\n            //diag\\n            int sum = 0;\\n            sum = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] ;\\n            if(sum != 15)\\n                goto next ;\\n            sum = 0;\\n            sum = grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] ;\\n            if(sum != 15)\\n                goto next ;\\n            ans++;\\n            next :\\n                continue ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998910,
                "title": "c-brut-force-easy-to-understand",
                "content": "\\n\\n# Approach\\nBrut Force\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(int row, int col, int sum,vector<vector<int>> arr, int &res){\\n        for(int i=row+1; i < row+3; i++){\\n            int colsum =0;\\n            for(int k=col; k<col+3; k++) colsum += arr[i][k];\\n            if(colsum != sum) return;\\n        }\\n        for(int k= col; k< col+3; k++){\\n            int rowsum = 0;\\n            for(int i=row; i<row+3; i++) rowsum += arr[i][k];\\n            if(rowsum != sum) return;\\n        }\\n        int digsum =0;\\n        for(int i=row, j=col; i< row+3, j<col+3; i++, j++){\\n            digsum += arr[i][j];\\n        }\\n        if(digsum != sum) return;\\n        digsum =0;\\n        for(int i=row+2, j=col; i>= row, j<col+3; i--, j++){\\n           digsum += arr[i][j]; \\n        }\\n        if(digsum != sum) return;\\n        res++;\\n    }\\n\\n    bool isdist(int row, int col,vector<vector<int>> arr){\\n        unordered_map<int,int>m;\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                if(m.find(arr[i][j]) != m.end()) return false;\\n                else if(arr[i][j] < 1 || arr[i][j] > 9) return false;\\n                m[arr[i][j]]++;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if(grid.size() < 3 || grid[0].size() < 3) return 0;\\n        int res=0;\\n        for(int i=0; i <= grid.size()-3; i++){\\n            for(int j=0; j<= grid[0].size()-3; j++){\\n                int sum=0;\\n                for(int k=i; k< i+3; k++) sum+= grid[k][j];\\n                if(isdist(i,j,grid))solve(i,j,sum,grid,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(int row, int col, int sum,vector<vector<int>> arr, int &res){\\n        for(int i=row+1; i < row+3; i++){\\n            int colsum =0;\\n            for(int k=col; k<col+3; k++) colsum += arr[i][k];\\n            if(colsum != sum) return;\\n        }\\n        for(int k= col; k< col+3; k++){\\n            int rowsum = 0;\\n            for(int i=row; i<row+3; i++) rowsum += arr[i][k];\\n            if(rowsum != sum) return;\\n        }\\n        int digsum =0;\\n        for(int i=row, j=col; i< row+3, j<col+3; i++, j++){\\n            digsum += arr[i][j];\\n        }\\n        if(digsum != sum) return;\\n        digsum =0;\\n        for(int i=row+2, j=col; i>= row, j<col+3; i--, j++){\\n           digsum += arr[i][j]; \\n        }\\n        if(digsum != sum) return;\\n        res++;\\n    }\\n\\n    bool isdist(int row, int col,vector<vector<int>> arr){\\n        unordered_map<int,int>m;\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                if(m.find(arr[i][j]) != m.end()) return false;\\n                else if(arr[i][j] < 1 || arr[i][j] > 9) return false;\\n                m[arr[i][j]]++;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        if(grid.size() < 3 || grid[0].size() < 3) return 0;\\n        int res=0;\\n        for(int i=0; i <= grid.size()-3; i++){\\n            for(int j=0; j<= grid[0].size()-3; j++){\\n                int sum=0;\\n                for(int k=i; k< i+3; k++) sum+= grid[k][j];\\n                if(isdist(i,j,grid))solve(i,j,sum,grid,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971792,
                "title": "java-check-each-3-3-square-to-see-if-it-is-magical",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) {\\n                Map<String, Integer> prefixSum = new HashMap<>();\\n                Set<Integer> seen = new HashSet<>();\\n                boolean hasInvalidValues = false;\\n                for (int r = i, nr = 0; r < i + 3; r++, nr++) {\\n                    for (int c = j, nc = 0; c < j + 3; c++, nc++) {\\n                        if (seen.contains(grid[r][c]) || grid[r][c] < 1 || grid[r][c] > 9 ) {\\n                            hasInvalidValues = true;\\n                            break;\\n                        }\\n                        seen.add(grid[r][c]);\\n                        String key = \"r\" + nr;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        key = \"c\" + nc;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        if (nr == nc) {\\n                           key = \"d0\";\\n                           prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        } \\n                        if (nr + nc == 2) {\\n                            key = \"d1\";\\n                            prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        }\\n                    }\\n                    if (hasInvalidValues) break;\\n                }\\n                if (!hasInvalidValues) {\\n                    Integer val = null;\\n                    boolean isMagic = true;\\n                    for (String key : prefixSum.keySet()) {\\n                        if (val == null) {\\n                            val = prefixSum.get(key);\\n                        } else if (val != prefixSum.get(key)) {\\n                            isMagic = false;\\n                            break;\\n                        }\\n                    }\\n                    if (isMagic) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[0].length - 3; j++) {\\n                Map<String, Integer> prefixSum = new HashMap<>();\\n                Set<Integer> seen = new HashSet<>();\\n                boolean hasInvalidValues = false;\\n                for (int r = i, nr = 0; r < i + 3; r++, nr++) {\\n                    for (int c = j, nc = 0; c < j + 3; c++, nc++) {\\n                        if (seen.contains(grid[r][c]) || grid[r][c] < 1 || grid[r][c] > 9 ) {\\n                            hasInvalidValues = true;\\n                            break;\\n                        }\\n                        seen.add(grid[r][c]);\\n                        String key = \"r\" + nr;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        key = \"c\" + nc;\\n                        prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        if (nr == nc) {\\n                           key = \"d0\";\\n                           prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        } \\n                        if (nr + nc == 2) {\\n                            key = \"d1\";\\n                            prefixSum.put(key, prefixSum.getOrDefault(key, 0) + grid[r][c]);\\n                        }\\n                    }\\n                    if (hasInvalidValues) break;\\n                }\\n                if (!hasInvalidValues) {\\n                    Integer val = null;\\n                    boolean isMagic = true;\\n                    for (String key : prefixSum.keySet()) {\\n                        if (val == null) {\\n                            val = prefixSum.get(key);\\n                        } else if (val != prefixSum.get(key)) {\\n                            isMagic = false;\\n                            break;\\n                        }\\n                    }\\n                    if (isMagic) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937540,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {\\n        fn check(i: usize, j: usize, grid: &[Vec<i32>]) -> bool {\\n            let mut mp = std::collections::HashMap::new();\\n            for item in grid.iter().skip(i).take(3) {\\n                for &point in item.iter().skip(j).take(3) {\\n                    if mp.contains_key(&point) || !(1..=9).contains(&point) {\\n                        return false;\\n                    } else {\\n                        mp.insert(point, 1);\\n                    }\\n                }\\n            }\\n            if mp.len() != 9 {\\n                return false;\\n            }\\n            let sum = grid[i][j] + grid[i + 1][j] + grid[i + 2][j];\\n\\n            if sum != grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n            if sum != grid[i][j] + grid[i][j + 1] + grid[i][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] {\\n                return false;\\n            }\\n            true\\n        }\\n\\n        let mut count = 0;\\n        if grid.len() < 3 || grid[0].len() < 3 {\\n            return 0;\\n        }\\n        for i in 0..grid.len() - 2 {\\n            for j in 0..grid[0].len() - 2 {\\n                if check(i, j, &grid) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {\\n        fn check(i: usize, j: usize, grid: &[Vec<i32>]) -> bool {\\n            let mut mp = std::collections::HashMap::new();\\n            for item in grid.iter().skip(i).take(3) {\\n                for &point in item.iter().skip(j).take(3) {\\n                    if mp.contains_key(&point) || !(1..=9).contains(&point) {\\n                        return false;\\n                    } else {\\n                        mp.insert(point, 1);\\n                    }\\n                }\\n            }\\n            if mp.len() != 9 {\\n                return false;\\n            }\\n            let sum = grid[i][j] + grid[i + 1][j] + grid[i + 2][j];\\n\\n            if sum != grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n            if sum != grid[i][j] + grid[i][j + 1] + grid[i][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] {\\n                return false;\\n            }\\n\\n            if sum != grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] {\\n                return false;\\n            }\\n            true\\n        }\\n\\n        let mut count = 0;\\n        if grid.len() < 3 || grid[0].len() < 3 {\\n            return 0;\\n        }\\n        for i in 0..grid.len() - 2 {\\n            for j in 0..grid[0].len() - 2 {\\n                if check(i, j, &grid) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922180,
                "title": "python3-brutal-force",
                "content": "```\\nclass Solution:\\n    def helper(self, r, c, grid):\\n        res = all(1<=grid[i][j]<=9 for i in range(r,r+3) for j in range(c,c+3))\\n        res &= len({grid[i][j] for i in range(r,r+3) for j in range(c,c+3)})==9\\n        for i in range(r,r+3):\\n            res &= sum(grid[i][j] for j in range(c,c+3))==15\\n        for j in range(c,c+3):\\n            res &= sum(grid[i][j] for i in range(r,r+3))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c,c+3)))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c+2,c-1,-1)))==15\\n        return res\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        return sum(self.helper(r,c,grid) for r in range(m-2) for c in range(n-2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, r, c, grid):\\n        res = all(1<=grid[i][j]<=9 for i in range(r,r+3) for j in range(c,c+3))\\n        res &= len({grid[i][j] for i in range(r,r+3) for j in range(c,c+3)})==9\\n        for i in range(r,r+3):\\n            res &= sum(grid[i][j] for j in range(c,c+3))==15\\n        for j in range(c,c+3):\\n            res &= sum(grid[i][j] for i in range(r,r+3))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c,c+3)))==15\\n        res &= sum(grid[i][j] for i,j in zip(range(r,r+3),range(c+2,c-1,-1)))==15\\n        return res\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        return sum(self.helper(r,c,grid) for r in range(m-2) for c in range(n-2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913688,
                "title": "all-conditions-checked-finally-c-solution",
                "content": "# Intuition\\nno other alternative than to check all their mentioned conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnote: greaterthan9 variable also checks for 0\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool jaadu(vector<vector<int>> a){\\n        int row1s = 0, row2s = 0, row3s = 0, col1s = 0, col2s = 0, col3s = 0, diagse = 0, diagsh = 0;\\n        int b = 3;\\n        map<int, int> mp;\\n        bool greaterthan9 = false;\\n        for(int g = 0; g < b; g++){\\n            for(int h = 0; h < b; h++){\\n                mp[a[g][h]]++;\\n                if(a[g][h] > 9){\\n                    greaterthan9 = true;\\n                }\\n                if(a[g][h] == 0){\\n                    greaterthan9 = true;\\n                }\\n                if(g == 0) row1s += a[g][h];\\n                if(g == 1) row2s += a[g][h];\\n                if(g == 2) row3s += a[g][h];\\n\\n                if(h == 0) col1s += a[g][h];\\n                if(h == 1) col2s += a[g][h];\\n                if(h == 2) col3s += a[g][h];\\n\\n                if(g == h) diagse += a[g][h];\\n\\n                if(g == 0 && h == 2 || g == 1 && h == 1 || g == 2 && h == 0) diagsh += a[g][h];\\n            }\\n        }\\n        \\n        bool kya = false;\\n        if(mp.size() != 9){\\n            kya = false;\\n        }\\n        else if(row1s == row2s && row1s == row3s && row1s == col1s  && row1s == col2s  && row1s == col3s  && row1s == diagse && row1s == diagsh && greaterthan9 == false){\\n            kya = true;\\n        }\\n        return kya;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size(), c = grid[0].size();\\n        int i = 0, j = 0;\\n        while(i+2 < r && j+2 < c){\\n            vector<vector<int>> now;\\n            for(int k = i; k <= (i+2); k++){\\n                vector<int> v;\\n                for(int l =  j; l <=(j+2); l++){\\n                    v.push_back(grid[k][l]);\\n                }\\n                now.push_back(v);\\n            }\\n            bool check = jaadu(now);\\n            if(check) ans += 1;\\n\\n            j += 1;\\n            int val = c-3;\\n            if(j == val + 1){\\n                i += 1;\\n                j = 0;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool jaadu(vector<vector<int>> a){\\n        int row1s = 0, row2s = 0, row3s = 0, col1s = 0, col2s = 0, col3s = 0, diagse = 0, diagsh = 0;\\n        int b = 3;\\n        map<int, int> mp;\\n        bool greaterthan9 = false;\\n        for(int g = 0; g < b; g++){\\n            for(int h = 0; h < b; h++){\\n                mp[a[g][h]]++;\\n                if(a[g][h] > 9){\\n                    greaterthan9 = true;\\n                }\\n                if(a[g][h] == 0){\\n                    greaterthan9 = true;\\n                }\\n                if(g == 0) row1s += a[g][h];\\n                if(g == 1) row2s += a[g][h];\\n                if(g == 2) row3s += a[g][h];\\n\\n                if(h == 0) col1s += a[g][h];\\n                if(h == 1) col2s += a[g][h];\\n                if(h == 2) col3s += a[g][h];\\n\\n                if(g == h) diagse += a[g][h];\\n\\n                if(g == 0 && h == 2 || g == 1 && h == 1 || g == 2 && h == 0) diagsh += a[g][h];\\n            }\\n        }\\n        \\n        bool kya = false;\\n        if(mp.size() != 9){\\n            kya = false;\\n        }\\n        else if(row1s == row2s && row1s == row3s && row1s == col1s  && row1s == col2s  && row1s == col3s  && row1s == diagse && row1s == diagsh && greaterthan9 == false){\\n            kya = true;\\n        }\\n        return kya;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size(), c = grid[0].size();\\n        int i = 0, j = 0;\\n        while(i+2 < r && j+2 < c){\\n            vector<vector<int>> now;\\n            for(int k = i; k <= (i+2); k++){\\n                vector<int> v;\\n                for(int l =  j; l <=(j+2); l++){\\n                    v.push_back(grid[k][l]);\\n                }\\n                now.push_back(v);\\n            }\\n            bool check = jaadu(now);\\n            if(check) ans += 1;\\n\\n            j += 1;\\n            int val = c-3;\\n            if(j == val + 1){\\n                i += 1;\\n                j = 0;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898273,
                "title": "easiest-java-solution",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        int count=0;\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(check(grid,i,j,m,n))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public boolean check(int[][] grid, int i, int j, int m, int n)\\n    {\\n        if((i+2)>=m || (j+2)>=n)\\n        {\\n            return false;\\n        }\\n        \\n        int row=i;\\n        int col=j;\\n        Set<Integer> set=new HashSet<>();\\n        \\n        for(int r=row;r<row+3;r++)\\n        {\\n            for(int c=col;c<col+3;c++)\\n            {\\n                if(grid[r][c]>0 && grid[r][c]<10)\\n                {\\n                    set.add(grid[r][c]);\\n                }\\n                \\n            }\\n        }\\n        \\n        if(set.size()!=9)\\n        {\\n            return false;\\n        }\\n        int row1=grid[row][col]+grid[row][col+1]+grid[row][col+2];\\n        int row2=grid[row+1][col]+grid[row+1][col+1]+grid[row+1][col+2];\\n        int row3=grid[row+2][col]+grid[row+2][col+1]+grid[row+2][col+2];\\n        \\n        if((row1!=row2) || (row2!=row3) || (row1!=row3))\\n        {\\n            return false;\\n        }\\n        \\n        int col1=grid[row][col]+grid[row+1][col]+grid[row+2][col];\\n        int col2=grid[row][col+1]+grid[row+1][col+1]+grid[row+2][col+1];\\n        int col3=grid[row][col+2]+grid[row+1][col+2]+grid[row+2][col+2];\\n        \\n        if((col1!=col2) || (col2!=col3) || (col3!=col1))\\n        {\\n            return false;\\n        }\\n        \\n        int diag1=grid[row][col]+grid[row+1][col+1]+grid[row+2][col+2];\\n        int diag2=grid[row][col+2]+grid[row+1][col+1]+grid[row+2][col];\\n        \\n        if(diag1!=diag2)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) \\n    {\\n        int count=0;\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(check(grid,i,j,m,n))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public boolean check(int[][] grid, int i, int j, int m, int n)\\n    {\\n        if((i+2)>=m || (j+2)>=n)\\n        {\\n            return false;\\n        }\\n        \\n        int row=i;\\n        int col=j;\\n        Set<Integer> set=new HashSet<>();\\n        \\n        for(int r=row;r<row+3;r++)\\n        {\\n            for(int c=col;c<col+3;c++)\\n            {\\n                if(grid[r][c]>0 && grid[r][c]<10)\\n                {\\n                    set.add(grid[r][c]);\\n                }\\n                \\n            }\\n        }\\n        \\n        if(set.size()!=9)\\n        {\\n            return false;\\n        }\\n        int row1=grid[row][col]+grid[row][col+1]+grid[row][col+2];\\n        int row2=grid[row+1][col]+grid[row+1][col+1]+grid[row+1][col+2];\\n        int row3=grid[row+2][col]+grid[row+2][col+1]+grid[row+2][col+2];\\n        \\n        if((row1!=row2) || (row2!=row3) || (row1!=row3))\\n        {\\n            return false;\\n        }\\n        \\n        int col1=grid[row][col]+grid[row+1][col]+grid[row+2][col];\\n        int col2=grid[row][col+1]+grid[row+1][col+1]+grid[row+2][col+1];\\n        int col3=grid[row][col+2]+grid[row+1][col+2]+grid[row+2][col+2];\\n        \\n        if((col1!=col2) || (col2!=col3) || (col3!=col1))\\n        {\\n            return false;\\n        }\\n        \\n        int diag1=grid[row][col]+grid[row+1][col+1]+grid[row+2][col+2];\\n        int diag2=grid[row][col+2]+grid[row+1][col+1]+grid[row+2][col];\\n        \\n        if(diag1!=diag2)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842286,
                "title": "c-easy-simple-solution",
                "content": "\\'\\'\\'\\n\\n\\n\\n bool check( int i , int j , vector<vector<int>>& grid )\\n    {\\n        unordered_map< int , int >mp ;\\n        \\n        for( int r = i ; r <= i + 2 ; r++ )\\n        {\\n            for( int c = j ; c <= j + 2 ; c++ )\\n            {\\n                if( mp.find(grid[r][c]) != mp.end() || grid[r][c] > 9 || grid[r][c] < 1)\\n                {\\n                  return false ;  \\n                }\\n                else{\\n                    mp[grid[r][c]]++ ;\\n                }\\n            }\\n        }\\n        \\n        if( mp.size() != 9 ) return false ;\\n        \\n        int sum = grid[i][j] + grid[i+1][j] + grid[i+2][j] ;\\n        \\n        if( sum != grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i][j+1] + grid[i][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]  ) return false ;\\n        \\n        \\n        \\n        \\n        return true ;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int count = 0 ;\\n        \\n        if( grid.size() < 3 || grid[0].size() < 3 ) return 0 ;\\n        for( int i = 0 ; i < grid.size() -2 ; i++ )\\n        {\\n            for( int j = 0 ; j < grid[0].size() - 2 ; j++ )\\n            {\\n                if( check( i , j , grid ))\\n                {\\n                    count++ ;\\n                }\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n bool check( int i , int j , vector<vector<int>>& grid )\\n    {\\n        unordered_map< int , int >mp ;\\n        \\n        for( int r = i ; r <= i + 2 ; r++ )\\n        {\\n            for( int c = j ; c <= j + 2 ; c++ )\\n            {\\n                if( mp.find(grid[r][c]) != mp.end() || grid[r][c] > 9 || grid[r][c] < 1)\\n                {\\n                  return false ;  \\n                }\\n                else{\\n                    mp[grid[r][c]]++ ;\\n                }\\n            }\\n        }\\n        \\n        if( mp.size() != 9 ) return false ;\\n        \\n        int sum = grid[i][j] + grid[i+1][j] + grid[i+2][j] ;\\n        \\n        if( sum != grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i][j+1] + grid[i][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2]  ) return false ;\\n        \\n         if( sum != grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]  ) return false ;\\n        \\n         if( sum != grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j]  ) return false ;\\n        \\n        \\n        \\n        \\n        return true ;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int count = 0 ;\\n        \\n        if( grid.size() < 3 || grid[0].size() < 3 ) return 0 ;\\n        for( int i = 0 ; i < grid.size() -2 ; i++ )\\n        {\\n            for( int j = 0 ; j < grid[0].size() - 2 ; j++ )\\n            {\\n                if( check( i , j , grid ))\\n                {\\n                    count++ ;\\n                }\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2835418,
                "title": "c-brute-force-code-joining-the-party",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int G[4][14][14];\\n    int mk[16];\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        memset(G, 0, sizeof(G));\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                G[0][i+1][j+1] = G[0][i+1][j] + grid[i][j];\\n                G[1][i+1][j+1] = G[1][i][j+1] + grid[i][j];\\n                G[2][i+1][j+1] = G[2][i][j] + grid[i][j];\\n                G[3][i+1][j+1] = G[3][i][j+2] + grid[i][j];\\n            }\\n        }\\n        int gi, gj;\\n        for (int i = 0; i <= r - 3; i++) {\\n            for (int j = 0; j <= c - 3; j++) {\\n                memset(mk, false, sizeof(mk));\\n                gi = i + 1;\\n                gj = j + 1;\\n                for (int k = i; k < i + 3; k++) {\\n                    for (int l = j; l < j + 3; l++) {\\n                        mk[grid[k][l]] = true;\\n                    }\\n                }\\n                int v = 1;\\n                for (; v <= 9; v++) {\\n                    if (!mk[v])\\n                        break;\\n                }\\n                if (v > 9) {\\n                    int s = G[0][gi][gj+2] - G[0][gi][gj-1];\\n                    if (s != G[0][gi+1][gj+2] - G[0][gi+1][gj-1] ||\\n                       s != G[0][gi+2][gj+2] - G[0][gi+2][gj-1] ||\\n                       s != G[1][gi+2][gj] - G[1][gi-1][gj] ||\\n                       s != G[1][gi+2][gj+1] - G[1][gi-1][gj+1] ||\\n                       s != G[1][gi+2][gj+2] - G[1][gi-1][gj+2] ||\\n                       s != G[2][gi+2][gj+2] - G[2][gi-1][gj-1] ||\\n                       s != G[3][gi+2][gj] - G[3][gi-1][gj+3]) {\\n                        \\n                    }\\n                    else {\\n                        res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int G[4][14][14];\\n    int mk[16];\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int res = 0;\\n        memset(G, 0, sizeof(G));\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                G[0][i+1][j+1] = G[0][i+1][j] + grid[i][j];\\n                G[1][i+1][j+1] = G[1][i][j+1] + grid[i][j];\\n                G[2][i+1][j+1] = G[2][i][j] + grid[i][j];\\n                G[3][i+1][j+1] = G[3][i][j+2] + grid[i][j];\\n            }\\n        }\\n        int gi, gj;\\n        for (int i = 0; i <= r - 3; i++) {\\n            for (int j = 0; j <= c - 3; j++) {\\n                memset(mk, false, sizeof(mk));\\n                gi = i + 1;\\n                gj = j + 1;\\n                for (int k = i; k < i + 3; k++) {\\n                    for (int l = j; l < j + 3; l++) {\\n                        mk[grid[k][l]] = true;\\n                    }\\n                }\\n                int v = 1;\\n                for (; v <= 9; v++) {\\n                    if (!mk[v])\\n                        break;\\n                }\\n                if (v > 9) {\\n                    int s = G[0][gi][gj+2] - G[0][gi][gj-1];\\n                    if (s != G[0][gi+1][gj+2] - G[0][gi+1][gj-1] ||\\n                       s != G[0][gi+2][gj+2] - G[0][gi+2][gj-1] ||\\n                       s != G[1][gi+2][gj] - G[1][gi-1][gj] ||\\n                       s != G[1][gi+2][gj+1] - G[1][gi-1][gj+1] ||\\n                       s != G[1][gi+2][gj+2] - G[1][gi-1][gj+2] ||\\n                       s != G[2][gi+2][gj+2] - G[2][gi-1][gj-1] ||\\n                       s != G[3][gi+2][gj] - G[3][gi-1][gj+3]) {\\n                        \\n                    }\\n                    else {\\n                        res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799304,
                "title": "c-solution-beats-100-matrix-brute",
                "content": "\\n# Complexity\\n- Time complexity:O(n*m*3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass sam{\\n    public:\\n    int col = 0;\\n    int row = 0;\\n    int dia = 0;\\n\\n};\\nclass Solution {\\nprivate:\\n    bool is_magic(vector<vector<int>>&grid, int x, int y){\\n\\n        // check all integers are different\\n        vector<int>vis(10,0);\\n        for(int i=x;i<x+3;i++){\\n            for(int j=y;j<y+3;j++){\\n                if(grid[i][j] > 9 || grid[i][j] == 0 || vis[grid[i][j]] == 1) return false;\\n                vis[grid[i][j]] = 1;\\n            }\\n        }\\n\\n        // diagonal\\n        int dia1 = grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2];\\n        int dia2 = grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y];\\n\\n        if(dia1 != dia2) return false;\\n\\n        // row and col sum must be 15 else return false\\n        for(int i=0;i<3;i++){\\n            if(grid[x][y+i] + grid[x+1][y+i] + grid[x+2][y+i] != dia1) return false;\\n            if(grid[x+i][y] + grid[x+i][y+1] + grid[x+i][y+2] != dia1) return false;   \\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int cnt = 0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=0;j<m-2;j++){\\n                if(is_magic(grid,i,j)){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass sam{\\n    public:\\n    int col = 0;\\n    int row = 0;\\n    int dia = 0;\\n\\n};\\nclass Solution {\\nprivate:\\n    bool is_magic(vector<vector<int>>&grid, int x, int y){\\n\\n        // check all integers are different\\n        vector<int>vis(10,0);\\n        for(int i=x;i<x+3;i++){\\n            for(int j=y;j<y+3;j++){\\n                if(grid[i][j] > 9 || grid[i][j] == 0 || vis[grid[i][j]] == 1) return false;\\n                vis[grid[i][j]] = 1;\\n            }\\n        }\\n\\n        // diagonal\\n        int dia1 = grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2];\\n        int dia2 = grid[x][y+2] + grid[x+1][y+1] + grid[x+2][y];\\n\\n        if(dia1 != dia2) return false;\\n\\n        // row and col sum must be 15 else return false\\n        for(int i=0;i<3;i++){\\n            if(grid[x][y+i] + grid[x+1][y+i] + grid[x+2][y+i] != dia1) return false;\\n            if(grid[x+i][y] + grid[x+i][y+1] + grid[x+i][y+2] != dia1) return false;   \\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int cnt = 0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=0;j<m-2;j++){\\n                if(is_magic(grid,i,j)){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767666,
                "title": "c-tc-o-m-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool solve(vector<vector<int>> &grid, int row, int col) {\\n\\t\\t\\tint count[10] = {0};\\n\\t\\t\\tint rowSum[3] = {0};\\n\\t\\t\\tint colSum[3] = {0};\\n\\t\\t\\tint ld = 0, rd = 0;\\n\\t\\t\\tfor(int i = 0; i < 3; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < 3; j++) {\\n\\t\\t\\t\\t\\tint r = row + i;\\n\\t\\t\\t\\t\\tint c = col + j;\\n\\t\\t\\t\\t\\tif(grid[r][c] >= 10 || grid[r][c] < 1 || count[grid[r][c]])\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tcount[grid[r][c]]++;\\n\\t\\t\\t\\t\\trowSum[i] += grid[r][c];\\n\\t\\t\\t\\t\\tcolSum[j] += grid[r][c];\\n\\t\\t\\t\\t\\tif(i == j) ld += grid[r][c];\\n\\t\\t\\t\\t\\tif(i + j == 2) rd += grid[r][c];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn rowSum[0] == 15 && rowSum[1] == 15 && rowSum[2] == 15 && colSum[0] == 15 && colSum[1] == 15 && colSum[2] == 15 && ld == 15 && rd == 15;\\n\\t\\t}\\n\\t\\tint numMagicSquaresInside(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0; i < m - 2; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n - 2; j++) {\\n\\t\\t\\t\\t\\tif(solve(grid, i, j)) ans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool solve(vector<vector<int>> &grid, int row, int col) {\\n\\t\\t\\tint count[10] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2753085,
                "title": "kotlin-solution",
                "content": "Solution may be long, but intuitive i think :)\\n\\n```\\nclass Solution {\\n    fun numMagicSquaresInside(grid: Array<IntArray>): Int {\\n    if(grid.size<3 || grid[0].size<3) { return 0 }\\n\\n    var row_size = grid[0].size-1\\n    var col_size = grid.size-1\\n    var i = 0\\n    var j = 0\\n    var res = 0\\n    var ij_res: IntArray\\n\\n    while (i<=row_size-2 && j<=col_size-2) {\\n        if (!row_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!col_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!diag_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!unique_numbers(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        res++\\n        ij_res = ij_count(i,j,row_size,col_size)\\n        i=ij_res[0]\\n        j=ij_res[1]\\n    }\\n    return res\\n}\\n\\nfun ij_count(i: Int, j: Int, row_size: Int, col_size: Int): IntArray {\\n    var i = i\\n    var j = j\\n    if (i==row_size-2 && j!=col_size-2) {\\n        i=0\\n        j++\\n    } else {\\n        i++\\n    }\\n    return intArrayOf(i,j)\\n}\\n\\nfun row_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i]+grid[j+2][i]\\n    val second = grid[j][i+1]+grid[j+1][i+1]+grid[j+2][i+1]\\n    val third = grid[j][i+2]+grid[j+1][i+2]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun col_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j][i+1]+grid[j][i+2]\\n    val second = grid[j+1][i]+grid[j+1][i+1]+grid[j+1][i+2]\\n    val third = grid[j+2][i]+grid[j+2][i+1]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun diag_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i+1]+grid[j+2][i+2]\\n    val second = grid[j][i+2]+grid[j+1][i+1]+grid[j+2][i]\\n    return first==second\\n}\\n\\nfun unique_numbers(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    var numbers = arrayOf(1,2,3,4,5,6,7,8,9)\\n    var f = true\\n    var g = arrayOf(grid[j][i],grid[j][i+1],grid[j][i+2],\\n                grid[j+1][i],grid[j+1][i+1],grid[j+1][i+2],\\n                grid[j+2][i],grid[j+2][i+1],grid[j+2][i+2])\\n    for (n in 0..numbers.size-1) {\\n        if(numbers.contains(g[n])) {\\n            numbers[g[n]-1] = -1\\n        } else {\\n            f=false\\n        }\\n    }\\n    return f\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numMagicSquaresInside(grid: Array<IntArray>): Int {\\n    if(grid.size<3 || grid[0].size<3) { return 0 }\\n\\n    var row_size = grid[0].size-1\\n    var col_size = grid.size-1\\n    var i = 0\\n    var j = 0\\n    var res = 0\\n    var ij_res: IntArray\\n\\n    while (i<=row_size-2 && j<=col_size-2) {\\n        if (!row_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!col_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!diag_count(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        if (!unique_numbers(i,j,grid)) {\\n            ij_res = ij_count(i,j,row_size,col_size)\\n            i=ij_res[0]\\n            j=ij_res[1]\\n            continue\\n        }\\n        res++\\n        ij_res = ij_count(i,j,row_size,col_size)\\n        i=ij_res[0]\\n        j=ij_res[1]\\n    }\\n    return res\\n}\\n\\nfun ij_count(i: Int, j: Int, row_size: Int, col_size: Int): IntArray {\\n    var i = i\\n    var j = j\\n    if (i==row_size-2 && j!=col_size-2) {\\n        i=0\\n        j++\\n    } else {\\n        i++\\n    }\\n    return intArrayOf(i,j)\\n}\\n\\nfun row_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i]+grid[j+2][i]\\n    val second = grid[j][i+1]+grid[j+1][i+1]+grid[j+2][i+1]\\n    val third = grid[j][i+2]+grid[j+1][i+2]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun col_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j][i+1]+grid[j][i+2]\\n    val second = grid[j+1][i]+grid[j+1][i+1]+grid[j+1][i+2]\\n    val third = grid[j+2][i]+grid[j+2][i+1]+grid[j+2][i+2]\\n    return first==second && first==third\\n}\\n\\nfun diag_count(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    val first = grid[j][i]+grid[j+1][i+1]+grid[j+2][i+2]\\n    val second = grid[j][i+2]+grid[j+1][i+1]+grid[j+2][i]\\n    return first==second\\n}\\n\\nfun unique_numbers(i: Int, j: Int, grid: Array<IntArray>):Boolean {\\n    var numbers = arrayOf(1,2,3,4,5,6,7,8,9)\\n    var f = true\\n    var g = arrayOf(grid[j][i],grid[j][i+1],grid[j][i+2],\\n                grid[j+1][i],grid[j+1][i+1],grid[j+1][i+2],\\n                grid[j+2][i],grid[j+2][i+1],grid[j+2][i+2])\\n    for (n in 0..numbers.size-1) {\\n        if(numbers.contains(g[n])) {\\n            numbers[g[n]-1] = -1\\n        } else {\\n            f=false\\n        }\\n    }\\n    return f\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751435,
                "title": "straightforward-code-c-with-comment",
                "content": "```\\n*class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), cnt = 0;\\n        for (int i = 0; i < n; i++) {\\n            int row = 0;\\n            vector<vector<int>> add; // store 3 full row\\n            vector<int> v;\\n            for (int j = i; j < n; j++) {\\n                row++;\\n                add.push_back(grid[j]);\\n                if (row >= 3) break;\\n            }\\n            if (add.size() >= 3) {\\n                for (int a = 0; a < m; a++) {                     \\n                    vector<vector<int>> store; // store every 3 * 3 matrix from 3 rows\\n                    for (int row = 0; row < 3; row++) {\\n                        vector<int> va;\\n                        for (int col = a; col < m; col++) { // traverse every 3 element from every row and add them\\n                            va.push_back(add[row][col]);\\n                            if (va.size() >= 3) break;\\n                        }\\n                        store.push_back(va);\\n                    }\\n                    if (store.size() < 3 or store[0].size() < 3) continue;\\n                    set<int> s, dist;\\n                    int ok = 1;\\n                    for (int i = 0; i < 3; i++) {\\n                        int row_sum = 0, col_sum = 0;\\n                        for (int j = 0; j < 3; j++) {\\n                            row_sum += store[i][j];// sum of row element\\n                            col_sum += store[j][i];//sum of column element\\n                            int val = store[i][j];\\n                            if (val > 0 and val < 10) dist.insert(val); // base case to check the value in range(1 - 9);\\n                            else ok = 0;\\n                        }\\n                        if (!ok) break;\\n                        s.insert(row_sum);\\n                        s.insert(col_sum);\\n                    }\\n                    if (!ok) continue;\\n                    \\n                    int ld = store[0][0] + store[1][1] + store[2][2]; // sum of left diagonal\\n                    int rd = store[0][2] + store[1][1] + store[2][0]; // sum of right diagonal\\n                    s.insert(ld);\\n                    s.insert(rd);\\n                    cnt += (s.size() == 1 and dist.size() == 9);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};*\\n```",
                "solutionTags": [],
                "code": "```\\n*class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), cnt = 0;\\n        for (int i = 0; i < n; i++) {\\n            int row = 0;\\n            vector<vector<int>> add; // store 3 full row\\n            vector<int> v;\\n            for (int j = i; j < n; j++) {\\n                row++;\\n                add.push_back(grid[j]);\\n                if (row >= 3) break;\\n            }\\n            if (add.size() >= 3) {\\n                for (int a = 0; a < m; a++) {                     \\n                    vector<vector<int>> store; // store every 3 * 3 matrix from 3 rows\\n                    for (int row = 0; row < 3; row++) {\\n                        vector<int> va;\\n                        for (int col = a; col < m; col++) { // traverse every 3 element from every row and add them\\n                            va.push_back(add[row][col]);\\n                            if (va.size() >= 3) break;\\n                        }\\n                        store.push_back(va);\\n                    }\\n                    if (store.size() < 3 or store[0].size() < 3) continue;\\n                    set<int> s, dist;\\n                    int ok = 1;\\n                    for (int i = 0; i < 3; i++) {\\n                        int row_sum = 0, col_sum = 0;\\n                        for (int j = 0; j < 3; j++) {\\n                            row_sum += store[i][j];// sum of row element\\n                            col_sum += store[j][i];//sum of column element\\n                            int val = store[i][j];\\n                            if (val > 0 and val < 10) dist.insert(val); // base case to check the value in range(1 - 9);\\n                            else ok = 0;\\n                        }\\n                        if (!ok) break;\\n                        s.insert(row_sum);\\n                        s.insert(col_sum);\\n                    }\\n                    if (!ok) continue;\\n                    \\n                    int ld = store[0][0] + store[1][1] + store[2][2]; // sum of left diagonal\\n                    int rd = store[0][2] + store[1][1] + store[2][0]; // sum of right diagonal\\n                    s.insert(ld);\\n                    s.insert(rd);\\n                    cnt += (s.size() == 1 and dist.size() == 9);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};*\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721432,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\\n        \\n        guard grid.count >= 3, grid[0].count >= 3 else { return 0 }\\n        \\n        var result = 0\\n        \\n        for i in 0..<grid.count - 2 {\\n            \\n            for j in 0..<grid[0].count - 2 {\\n                if isMagic(i, j, grid) {\\n                    result += 1\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func isMagic(_ i: Int, _ j: Int, _ grid: [[Int]]) -> Bool {\\n        var sumSet: Set<Int> = []\\n        \\n        var numberSet: Set = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        var arraySet: Set<Int> = []\\n        \\n        for r in 0..<3 {\\n            for c in 0..<3 {\\n                arraySet.insert(grid[i+r][j+c])\\n            }\\n        }\\n        \\n        if arraySet != numberSet {\\n            return false\\n        }\\n        \\n        let row1 = grid[i+0][j+0] + grid[i+0][j+1] + grid[i+0][j+2]\\n        let row2 = grid[i+1][j+0] + grid[i+1][j+1] + grid[i+1][j+2]\\n        let row3 = grid[i+2][j+0] + grid[i+2][j+1] + grid[i+2][j+2]\\n        \\n        let col1 = grid[i+0][j+0] + grid[i+1][j+0] + grid[i+2][j+0]\\n        let col2 = grid[i+0][j+1] + grid[i+1][j+1] + grid[i+2][j+1]\\n        let col3 = grid[i+0][j+2] + grid[i+1][j+2] + grid[i+2][j+2]\\n        \\n        let dg1 = grid[i+0][j+0] + grid[i+1][j+1] + grid[i+2][j+2]\\n        let dg2 = grid[i+0][j+2] + grid[i+1][j+1] + grid[i+2][j+0]\\n        sumSet = [row1, row2, row3, col1, col2, col3, dg1, dg2]\\n        return sumSet.contains(15) && sumSet.count == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numMagicSquaresInside(_ grid: [[Int]]) -> Int {\\n        \\n        guard grid.count >= 3, grid[0].count >= 3 else { return 0 }\\n        \\n        var result = 0\\n        \\n        for i in 0..<grid.count - 2 {\\n            \\n            for j in 0..<grid[0].count - 2 {\\n                if isMagic(i, j, grid) {\\n                    result += 1\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func isMagic(_ i: Int, _ j: Int, _ grid: [[Int]]) -> Bool {\\n        var sumSet: Set<Int> = []\\n        \\n        var numberSet: Set = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        var arraySet: Set<Int> = []\\n        \\n        for r in 0..<3 {\\n            for c in 0..<3 {\\n                arraySet.insert(grid[i+r][j+c])\\n            }\\n        }\\n        \\n        if arraySet != numberSet {\\n            return false\\n        }\\n        \\n        let row1 = grid[i+0][j+0] + grid[i+0][j+1] + grid[i+0][j+2]\\n        let row2 = grid[i+1][j+0] + grid[i+1][j+1] + grid[i+1][j+2]\\n        let row3 = grid[i+2][j+0] + grid[i+2][j+1] + grid[i+2][j+2]\\n        \\n        let col1 = grid[i+0][j+0] + grid[i+1][j+0] + grid[i+2][j+0]\\n        let col2 = grid[i+0][j+1] + grid[i+1][j+1] + grid[i+2][j+1]\\n        let col3 = grid[i+0][j+2] + grid[i+1][j+2] + grid[i+2][j+2]\\n        \\n        let dg1 = grid[i+0][j+0] + grid[i+1][j+1] + grid[i+2][j+2]\\n        let dg2 = grid[i+0][j+2] + grid[i+1][j+1] + grid[i+2][j+0]\\n        sumSet = [row1, row2, row3, col1, col2, col3, dg1, dg2]\\n        return sumSet.contains(15) && sumSet.count == 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680399,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar numMagicSquaresInside = function(grid) {\\n\\t\\tlet result = 0;\\n\\t\\tconst isMagic = (row, col) => {\\n\\t\\t\\tif (grid[row + 1][col + 1] !== 5) return false;\\n\\t\\t\\tconst visited = new Set();\\n\\t\\t\\tconst nums = [[], [], []];\\n\\n\\t\\t\\tfor (let m = row; m <= row + 2; m++) {\\n\\t\\t\\t\\tfor (let n = col; n <= col + 2; n++) {\\n\\t\\t\\t\\t\\tconst num = grid[m][n];\\n\\t\\t\\t\\t\\tif (num === 0 || num > 9 || visited.has(num)) return false;\\n\\t\\t\\t\\t\\tvisited.add(num);\\n\\t\\t\\t\\t\\tnums[m - row][n - col] = num;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let index = 0; index < 3; index++) {\\n\\t\\t\\t\\tif (nums[index][0] + nums[index][1] + nums[index][2] !== 15) return false;\\n\\t\\t\\t\\tif (nums[0][index] + nums[1][index] + nums[2][index] !== 15) return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[0][0] + nums[1][1] + nums[2][2] !== 15) return false;\\n\\t\\t\\tif (nums[0][2] + nums[1][1] + nums[2][0] !== 15) return false;\\n\\t\\t\\treturn true;\\n\\t\\t};\\n\\n\\t\\tfor (let row = 0; row < grid.length - 2; row++) {\\n\\t\\t\\tfor (let col = 0; col < grid[0].length - 2; col++) {\\n\\t\\t\\t\\tisMagic(row, col) && result++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar numMagicSquaresInside = function(grid) {\\n\\t\\tlet result = 0;\\n\\t\\tconst isMagic = (row, col) => {\\n\\t\\t\\tif (grid[row + 1][col + 1] !== 5) return false;\\n\\t\\t\\tconst visited = new Set();\\n\\t\\t\\tconst nums = [[], [], []];\\n\\n\\t\\t\\tfor (let m = row; m <= row + 2; m++) {\\n\\t\\t\\t\\tfor (let n = col; n <= col + 2; n++) {\\n\\t\\t\\t\\t\\tconst num = grid[m][n];\\n\\t\\t\\t\\t\\tif (num === 0 || num > 9 || visited.has(num)) return false;\\n\\t\\t\\t\\t\\tvisited.add(num);\\n\\t\\t\\t\\t\\tnums[m - row][n - col] = num;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let index = 0; index < 3; index++) {\\n\\t\\t\\t\\tif (nums[index][0] + nums[index][1] + nums[index][2] !== 15) return false;\\n\\t\\t\\t\\tif (nums[0][index] + nums[1][index] + nums[2][index] !== 15) return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[0][0] + nums[1][1] + nums[2][2] !== 15) return false;\\n\\t\\t\\tif (nums[0][2] + nums[1][1] + nums[2][0] !== 15) return false;\\n\\t\\t\\treturn true;\\n\\t\\t};\\n\\n\\t\\tfor (let row = 0; row < grid.length - 2; row++) {\\n\\t\\t\\tfor (let col = 0; col < grid[0].length - 2; col++) {\\n\\t\\t\\t\\tisMagic(row, col) && result++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2678040,
                "title": "ts-js-solution",
                "content": "```\\nfunction numMagicSquaresInside(grid: number[][]): number {\\n  let count = 0;\\n\\n  if (grid.length < 3 || grid?.[0]?.length < 0) {\\n    return count;\\n  }\\n\\n  const checkMagicSquare = (i: number, j: number): void => {\\n    const get3x3Numbers = (): number[][] => {\\n      const numbers = [[], [], []];\\n\\n      for (let k = 0; k < 3; k++) {\\n        for (let l = 0; l < 3; l++) {\\n          numbers[k][l] = grid[i + k][j + l];\\n        }\\n      }\\n\\n      return numbers;\\n    };\\n\\n    const isAllDistinctNumbers = (): boolean => {\\n      return new Set(numbers.reduce((acc, row) => {\\n        row.forEach(num => {\\n          if (num >= 1 && num <= 9) {\\n            acc.push(num);\\n          }\\n        });\\n\\n        return acc;\\n      }, [])).size === 9;\\n    };\\n\\n    const haveAllSameSum = (): boolean => {\\n      return new Set([\\n        // rows\\n        numbers[0][0] + numbers[0][1] + numbers[0][2],\\n        numbers[1][0] + numbers[1][1] + numbers[1][2],\\n        numbers[2][0] + numbers[2][1] + numbers[2][2],\\n\\n        // cols\\n        numbers[0][0] + numbers[1][0] + numbers[2][0],\\n        numbers[0][1] + numbers[1][1] + numbers[2][1],\\n        numbers[0][2] + numbers[1][2] + numbers[2][2],\\n\\n        // diagonals\\n        numbers[0][0] + numbers[1][1] + numbers[2][2],\\n        numbers[0][2] + numbers[1][1] + numbers[2][0],\\n      ]).size === 1;\\n    };\\n\\n    const numbers = get3x3Numbers();\\n\\n    if (isAllDistinctNumbers() && haveAllSameSum()) {\\n      count++;\\n    }\\n  };\\n\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i + 2]?.[j + 2] === undefined) {\\n        break;\\n      }\\n\\n      checkMagicSquare(i, j);\\n    }\\n  }\\n\\n  return count;\\n};\\n```\\n\\n```\\nRuntime: 100 ms, faster than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\nMemory Usage: 45.8 MB, less than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numMagicSquaresInside(grid: number[][]): number {\\n  let count = 0;\\n\\n  if (grid.length < 3 || grid?.[0]?.length < 0) {\\n    return count;\\n  }\\n\\n  const checkMagicSquare = (i: number, j: number): void => {\\n    const get3x3Numbers = (): number[][] => {\\n      const numbers = [[], [], []];\\n\\n      for (let k = 0; k < 3; k++) {\\n        for (let l = 0; l < 3; l++) {\\n          numbers[k][l] = grid[i + k][j + l];\\n        }\\n      }\\n\\n      return numbers;\\n    };\\n\\n    const isAllDistinctNumbers = (): boolean => {\\n      return new Set(numbers.reduce((acc, row) => {\\n        row.forEach(num => {\\n          if (num >= 1 && num <= 9) {\\n            acc.push(num);\\n          }\\n        });\\n\\n        return acc;\\n      }, [])).size === 9;\\n    };\\n\\n    const haveAllSameSum = (): boolean => {\\n      return new Set([\\n        // rows\\n        numbers[0][0] + numbers[0][1] + numbers[0][2],\\n        numbers[1][0] + numbers[1][1] + numbers[1][2],\\n        numbers[2][0] + numbers[2][1] + numbers[2][2],\\n\\n        // cols\\n        numbers[0][0] + numbers[1][0] + numbers[2][0],\\n        numbers[0][1] + numbers[1][1] + numbers[2][1],\\n        numbers[0][2] + numbers[1][2] + numbers[2][2],\\n\\n        // diagonals\\n        numbers[0][0] + numbers[1][1] + numbers[2][2],\\n        numbers[0][2] + numbers[1][1] + numbers[2][0],\\n      ]).size === 1;\\n    };\\n\\n    const numbers = get3x3Numbers();\\n\\n    if (isAllDistinctNumbers() && haveAllSameSum()) {\\n      count++;\\n    }\\n  };\\n\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i + 2]?.[j + 2] === undefined) {\\n        break;\\n      }\\n\\n      checkMagicSquare(i, j);\\n    }\\n  }\\n\\n  return count;\\n};\\n```\n```\\nRuntime: 100 ms, faster than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\nMemory Usage: 45.8 MB, less than 100.00% of TypeScript online submissions for Magic Squares In Grid.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674804,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        numbers = set([i for i in range(1,10)])\\n        def check(i, j):\\n            if numbers != set([grid[i+di][j+dj] for di in range(3) for dj in range(3)]):\\n                return False\\n            s = sum(grid[i][j+k] for k in range(3))\\n            for di in range(3):\\n                if s != sum(grid[i+di][j+k] for k in range(3)): return False\\n            for dj in range(3):\\n                if s != sum(grid[i+k][j+dj] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+k] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+2-k] for k in range(3)): return False\\n            return True\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                res += check(i,j)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        numbers = set([i for i in range(1,10)])\\n        def check(i, j):\\n            if numbers != set([grid[i+di][j+dj] for di in range(3) for dj in range(3)]):\\n                return False\\n            s = sum(grid[i][j+k] for k in range(3))\\n            for di in range(3):\\n                if s != sum(grid[i+di][j+k] for k in range(3)): return False\\n            for dj in range(3):\\n                if s != sum(grid[i+k][j+dj] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+k] for k in range(3)): return False\\n            if s != sum(grid[i+k][j+2-k] for k in range(3)): return False\\n            return True\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                res += check(i,j)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2657442,
                "title": "0ms-easy-understandable-solution",
                "content": "```\\nclass Solution {\\n     Set<Integer> set = new HashSet<>();\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i + 2 < grid.length && j + 2 < grid[0].length) {\\n                    if (isMagicSquare(grid, i, i + 2, j, j + 2))\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int rs, int re, int cs, int ce) {\\n        \\n       \\n        set.clear();\\n        for (int i = rs; i <= re; i++) {\\n            for (int j = cs; j <= ce; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9) return false;\\n                if (set.contains(grid[i][j]))\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n\\n        int row1Sum = 0, col1Sum = 0, row2Sum = 0, col2Sum = 0, row3Sum = 0, col3Sum = 0;\\n        row1Sum = grid[rs][cs] + grid[rs][cs + 1] + grid[rs][cs + 2];\\n        row2Sum = grid[rs + 1][cs] + grid[rs + 1][cs + 1] + grid[rs + 1][cs + 2];\\n        row3Sum = grid[rs + 2][cs] + grid[rs + 2][cs + 1] + grid[rs + 2][cs + 2];\\n\\n        col1Sum = grid[rs][cs] + grid[rs + 1][cs] + grid[rs + 2][cs];\\n        col2Sum = grid[rs][cs + 1] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 1];\\n        col3Sum = grid[rs][cs + 2] + grid[rs + 1][cs + 2] + grid[rs + 2][cs + 2];\\n\\n        if ((row1Sum == row2Sum) && (row1Sum == row3Sum) && (row1Sum == col1Sum) && (col1Sum == col2Sum) && (col2Sum == col3Sum)) {\\n            int diag1Sum = 0, diag2Sum = 0;\\n            diag1Sum = grid[rs][cs] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 2];\\n            diag2Sum = grid[rs][ce] + grid[rs + 1][ce - 1] + grid[rs + 2][ce - 2];\\n            return diag1Sum == diag2Sum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n     Set<Integer> set = new HashSet<>();\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i + 2 < grid.length && j + 2 < grid[0].length) {\\n                    if (isMagicSquare(grid, i, i + 2, j, j + 2))\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public boolean isMagicSquare(int[][] grid, int rs, int re, int cs, int ce) {\\n        \\n       \\n        set.clear();\\n        for (int i = rs; i <= re; i++) {\\n            for (int j = cs; j <= ce; j++) {\\n                if (grid[i][j] < 1 || grid[i][j] > 9) return false;\\n                if (set.contains(grid[i][j]))\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n\\n        int row1Sum = 0, col1Sum = 0, row2Sum = 0, col2Sum = 0, row3Sum = 0, col3Sum = 0;\\n        row1Sum = grid[rs][cs] + grid[rs][cs + 1] + grid[rs][cs + 2];\\n        row2Sum = grid[rs + 1][cs] + grid[rs + 1][cs + 1] + grid[rs + 1][cs + 2];\\n        row3Sum = grid[rs + 2][cs] + grid[rs + 2][cs + 1] + grid[rs + 2][cs + 2];\\n\\n        col1Sum = grid[rs][cs] + grid[rs + 1][cs] + grid[rs + 2][cs];\\n        col2Sum = grid[rs][cs + 1] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 1];\\n        col3Sum = grid[rs][cs + 2] + grid[rs + 1][cs + 2] + grid[rs + 2][cs + 2];\\n\\n        if ((row1Sum == row2Sum) && (row1Sum == row3Sum) && (row1Sum == col1Sum) && (col1Sum == col2Sum) && (col2Sum == col3Sum)) {\\n            int diag1Sum = 0, diag2Sum = 0;\\n            diag1Sum = grid[rs][cs] + grid[rs + 1][cs + 1] + grid[rs + 2][cs + 2];\\n            diag2Sum = grid[rs][ce] + grid[rs + 1][ce - 1] + grid[rs + 2][ce - 2];\\n            return diag1Sum == diag2Sum;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656508,
                "title": "python-clean-solution",
                "content": "```\\ndef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\tdef valid(m):\\n\\t\\tif sorted(m)!=list(range(1, 10)):\\n\\t\\t\\treturn 0\\n\\t\\tif not (m[0]+m[1]+m[2]==m[3]+m[4]+m[5]==m[6]+m[7]+m[8]==15):\\n\\t\\t\\treturn 0    # row-base\\n\\t\\tif not (m[0]+m[3]+m[6]==m[1]+m[4]+m[7]==m[2]+m[5]+m[8]==15):\\n\\t\\t\\treturn 0   # col-base\\n\\t\\tif not (m[0]+m[4]+m[8]==m[2]+m[4]+m[6]==15):\\n\\t\\t\\treturn 0   # diag and anti-diag\\n\\t\\treturn 1\\n\\n\\tx, y, ans = len(grid), len(grid[0]), 0\\n\\tfor i in range(x-2):\\n\\t\\tfor j in range(y-2):\\n\\t\\t\\tmat = grid[i][j:j+3]+grid[i+1][j:j+3]+grid[i+2][j:j+3]\\n\\t\\t\\tans += valid(mat)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n\\tdef valid(m):\\n\\t\\tif sorted(m)!=list(range(1, 10)):\\n\\t\\t\\treturn 0\\n\\t\\tif not (m[0]+m[1]+m[2]==m[3]+m[4]+m[5]==m[6]+m[7]+m[8]==15):\\n\\t\\t\\treturn 0    # row-base\\n\\t\\tif not (m[0]+m[3]+m[6]==m[1]+m[4]+m[7]==m[2]+m[5]+m[8]==15):\\n\\t\\t\\treturn 0   # col-base\\n\\t\\tif not (m[0]+m[4]+m[8]==m[2]+m[4]+m[6]==15):\\n\\t\\t\\treturn 0   # diag and anti-diag\\n\\t\\treturn 1\\n\\n\\tx, y, ans = len(grid), len(grid[0]), 0\\n\\tfor i in range(x-2):\\n\\t\\tfor j in range(y-2):\\n\\t\\t\\tmat = grid[i][j:j+3]+grid[i+1][j:j+3]+grid[i+2][j:j+3]\\n\\t\\t\\tans += valid(mat)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2617493,
                "title": "c-simple-and-straightforward-solution",
                "content": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<row-2; i++){\\n            for(int j=0; j<col-2; j++){\\n                if(magic_square(i,j,grid)){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    bool magic_square(int a, int b, vector<vector<int>>& grid){\\n        \\n        int s[3][3];\\n        set<int> st;\\n        \\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                s[i][j] = grid[a+i][b+j];\\n                st.insert(s[i][j]);\\n            }\\n        }\\n        \\n        //9 Unique Element\\n        if(st.size()!=9) return false;\\n        \\n        //Checking Numbers from 1 to 9. \\n        int n = 1;\\n        for(auto x: st){\\n            if(x!=n) return false;\\n            n++;\\n        }\\n        \\n        \\n        //Checking R1, R2, R3, C1, C2, C3, D1, D2 Sum. \\n        int SUM[8] = {0};\\n        \\n        //Rows\\n        SUM[0] = s[0][0] + s[0][1] + s[0][2];\\n        SUM[1] = s[1][0] + s[1][1] + s[1][2];\\n        SUM[2] = s[2][0] + s[2][1] + s[2][2];\\n        \\n        //Column\\n        SUM[3] = s[0][0] + s[1][0] + s[2][0];\\n        SUM[4] = s[0][1] + s[1][1] + s[2][1];\\n        SUM[5] = s[0][2] + s[1][2] + s[2][2];\\n        \\n        //Diagonal\\n        SUM[6] = s[0][0] + s[1][1] + s[2][2];\\n        SUM[7] = s[0][2] + s[1][1] + s[2][0];\\n        \\n        \\n        for(int i=0; i<8; i++){\\n            if(SUM[i]!=15) return false;\\n        }\\n\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<row-2; i++){\\n            for(int j=0; j<col-2; j++){\\n                if(magic_square(i,j,grid)){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2546545,
                "title": "java-simple-solution-7ms",
                "content": "Runtime: 7 ms, faster than 11.97% of Java online submissions for Magic Squares In Grid.\\nMemory Usage: 42.6 MB, less than 14.53% of Java online submissions for Magic Squares In Grid.\\n\\n```\\nclass Solution {\\n    static boolean colMat(int[][] grid, int a, int b) {\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = b; i < b + 3; i++) {\\n            for (int j = a; j < a + 3; j++) {\\n                sum = sum + grid[j][i];\\n             }\\n            set.add(sum);\\n            sum = 0;\\n        }\\n        return (set.size() == 1);\\n    }\\n\\n    static boolean rowMat(int[][] grid, int a, int b) {\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = a; i < a + 3; i++) {\\n            for (int j = b; j < b + 3; j++) {\\n                sum = sum + grid[i][j];\\n            }\\n            set.add(sum);\\n            sum = 0;\\n        }\\n        return (set.size() == 1);\\n    }\\n\\n    static boolean checkMat(int[][] grid, int a, int b) {\\n        ArrayList<Integer> lis = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            lis.add(i);\\n        }\\n        if ((a + 3) <= grid.length && (b + 3) <= grid[0].length) {\\n            for (int i = a; i < a + 3; i++) {\\n                for (int j = b; j < b + 3; j++) {\\n                    if (lis.contains(grid[i][j])) {\\n                        lis.remove(Integer.valueOf(grid[i][j]));\\n                    }\\n                }\\n            }\\n        }\\n        int a1 = 0;\\n        int b1 = 0;\\n        if (lis.size() == 0) {\\n            a1 = grid[a][b] + grid[a + 2][b + 2];\\n            b1 = grid[a][b + 2] + grid[a + 2][b];\\n            return (a1 == b1);\\n        }\\n        return false;\\n    }\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i <= grid.length - 3; i++) {\\n            for (int j = 0; j <= grid[i].length - 3; j++) {\\n                if (checkMat(grid, i, j)) {\\n                    if (rowMat(grid, i, j)) {\\n                        if (colMat(grid, i, j)) {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    static boolean colMat(int[][] grid, int a, int b) {\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = b; i < b + 3; i++) {\\n            for (int j = a; j < a + 3; j++) {\\n                sum = sum + grid[j][i];\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2517668,
                "title": "c-best-solution",
                "content": "**C Best Solution Basics Beats 100% 100%**\\n\\n```\\nbool chk(int **a, int i, int j)\\n{\\n    int map[10]={0};\\n    for(int n=i;n<=i+2;n++)\\n    {\\n        for(int m=j;m<=j+2;m++)\\n        {\\n            if(a[n][m]>9)return false;\\n            map[a[n][m]]++;\\n        } \\n    }\\n    for(int n=1;n<10;n++)if(map[n]==0)return false;\\n    int s=a[i][j]+a[i][j+1]+a[i][j+2];\\n    if(a[i+1][j]+a[i+1][j+1]+a[i+1][j+2]==s &&\\n       a[i+2][j]+a[i+2][j+1]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j]+a[i+2][j]==s &&\\n       a[i][j+1]+a[i+1][j+1]+a[i+2][j+1]==s &&\\n       a[i][j+2]+a[i+1][j+2]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j+1]+a[i+2][j+2]==s &&\\n       a[i+2][j]+a[i+1][j+1]+a[i][j+2]==s)return true;\\n    return false;\\n}\\n        \\nint numMagicSquaresInside(int** a, int n, int* nl)\\n{\\n    int k=0;\\n    for(int i=0;i<n-2;i++)\\n        for(int j=0;j<*nl-2;j++)if(chk(a,i,j))k++;\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool chk(int **a, int i, int j)\\n{\\n    int map[10]={0};\\n    for(int n=i;n<=i+2;n++)\\n    {\\n        for(int m=j;m<=j+2;m++)\\n        {\\n            if(a[n][m]>9)return false;\\n            map[a[n][m]]++;\\n        } \\n    }\\n    for(int n=1;n<10;n++)if(map[n]==0)return false;\\n    int s=a[i][j]+a[i][j+1]+a[i][j+2];\\n    if(a[i+1][j]+a[i+1][j+1]+a[i+1][j+2]==s &&\\n       a[i+2][j]+a[i+2][j+1]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j]+a[i+2][j]==s &&\\n       a[i][j+1]+a[i+1][j+1]+a[i+2][j+1]==s &&\\n       a[i][j+2]+a[i+1][j+2]+a[i+2][j+2]==s &&\\n       a[i][j]+a[i+1][j+1]+a[i+2][j+2]==s &&\\n       a[i+2][j]+a[i+1][j+1]+a[i][j+2]==s)return true;\\n    return false;\\n}\\n        \\nint numMagicSquaresInside(int** a, int n, int* nl)\\n{\\n    int k=0;\\n    for(int i=0;i<n-2;i++)\\n        for(int j=0;j<*nl-2;j++)if(chk(a,i,j))k++;\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2475106,
                "title": "javascript-solution-that-works",
                "content": "```\\nvar numMagicSquaresInside = function(grid) {\\n    if (grid.length < 3){\\n        return 0\\n    }\\n    \\n    let total = 0\\n    \\n    for(let row = 0; row < grid.length - 2; row++){\\n        for(let col = 0; col < grid[0].length - 2; col++){\\n            if(numsDiff(row, col, grid) === true && rowCheck(row, col, grid) === true && colCheck(row, col, grid) === true && diagCheck(row, col, grid)  === true){\\n                total++\\n            }\\n        }\\n    }\\n    \\n    return total\\n};\\n\\nfunction numsDiff(row, col, grid){\\n    let mySet = new Set()\\n    for(let i = row; i < row+3; i++){\\n        for(let j = col; j < col+3; j++){\\n            if (grid[i][j] > 9){\\n                return false\\n            }\\n            mySet.add(grid[i][j])\\n        }\\n    }\\n   return mySet.size === 9 ? true : false\\n}\\n\\nfunction rowCheck(row, col, grid){\\n    let check = true\\n    for(let i = row; i < row+3; i++){\\n        let total = grid[row][col] + grid[row][col + 1] + grid[row][col + 2]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction colCheck(row, col, grid){\\n    let check = true\\n    for(let i = col; i < col+3; i++){\\n        let total = grid[row][col] + grid[row+1][col] + grid[row+2][col]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction diagCheck(row, col, grid){\\n    let check = false\\n    if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] === 15 && grid[row+2][col] + grid[row+1][col+1] + grid[row][col+2] === 15){\\n        check = true\\n    }\\n   return check\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numMagicSquaresInside = function(grid) {\\n    if (grid.length < 3){\\n        return 0\\n    }\\n    \\n    let total = 0\\n    \\n    for(let row = 0; row < grid.length - 2; row++){\\n        for(let col = 0; col < grid[0].length - 2; col++){\\n            if(numsDiff(row, col, grid) === true && rowCheck(row, col, grid) === true && colCheck(row, col, grid) === true && diagCheck(row, col, grid)  === true){\\n                total++\\n            }\\n        }\\n    }\\n    \\n    return total\\n};\\n\\nfunction numsDiff(row, col, grid){\\n    let mySet = new Set()\\n    for(let i = row; i < row+3; i++){\\n        for(let j = col; j < col+3; j++){\\n            if (grid[i][j] > 9){\\n                return false\\n            }\\n            mySet.add(grid[i][j])\\n        }\\n    }\\n   return mySet.size === 9 ? true : false\\n}\\n\\nfunction rowCheck(row, col, grid){\\n    let check = true\\n    for(let i = row; i < row+3; i++){\\n        let total = grid[row][col] + grid[row][col + 1] + grid[row][col + 2]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction colCheck(row, col, grid){\\n    let check = true\\n    for(let i = col; i < col+3; i++){\\n        let total = grid[row][col] + grid[row+1][col] + grid[row+2][col]\\n        if(total !== 15){\\n            check = false\\n        }\\n    }\\n   return check\\n}\\n\\nfunction diagCheck(row, col, grid){\\n    let check = false\\n    if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] === 15 && grid[row+2][col] + grid[row+1][col+1] + grid[row][col+2] === 15){\\n        check = true\\n    }\\n   return check\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446125,
                "title": "c-easy-to-understand-painfull-question",
                "content": "```\\nclass Solution {\\npublic:\\n     int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                int check = 0;\\n                int flag = 0;\\n                int sum = 0;\\n                for(int p = 0;p<3;p++){\\n                    for(int q=0;q<3;q++){\\n                        sum+=grid[i+p][j+q];\\n                        if(check == grid[i+p][j+q] || grid[i+p][j+q]>9 || grid[i+p][j+q]<1){\\n                            flag = 1;\\n                        }\\n                        check = grid[i+p][j+q];\\n                    }\\n                }\\n                if(sum != 45) flag = 1;\\n                return flag == 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                int check = 0;\\n                int flag = 0;\\n                int sum = 0;\\n                for(int p = 0;p<3;p++){\\n                    for(int q=0;q<3;q++){\\n                        sum+=grid[i+p][j+q];\\n                        if(check == grid[i+p][j+q] || grid[i+p][j+q]>9 || grid[i+p][j+q]<1){\\n                            flag = 1;\\n                        }\\n                        check = grid[i+p][j+q];\\n                    }\\n                }\\n                if(sum != 45) flag = 1;\\n                return flag == 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421185,
                "title": "crisp-n-clear-o-n-javascript-runtime-90-meaningful-vars",
                "content": "Runtime: 70 ms, faster than 90.00% of JavaScript online submissions for Magic Squares In Grid.\\nMemory Usage: 42.4 MB, less than 85.00% of JavaScript online submissions for Magic Squares In Grid.\\n\\n```\\nfunction areNumbersDistinct(grid, rowIndex, columnIndex) {\\n  const obj = {};\\n  for (let childRowIndex = rowIndex; childRowIndex <= rowIndex + 2; childRowIndex++) {\\n    for (\\n      let childColumnIndex = columnIndex;\\n      childColumnIndex <= columnIndex + 2;\\n      childColumnIndex++\\n    ) {\\n      const currentNum = grid[childRowIndex][childColumnIndex];\\n      if (currentNum < 1 || currentNum > 9) {\\n        return false;\\n      }\\n      if (!obj[grid[childRowIndex][childColumnIndex]]) {\\n        obj[grid[childRowIndex][childColumnIndex]] = 1;\\n      } else {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nfunction areAllRowsEqual(grid, rowIndex, columnIndex) {\\n  const firstRowSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex][columnIndex + 1] + grid[rowIndex][columnIndex + 2];\\n  const secondRowSum =\\n    grid[rowIndex + 1][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 2];\\n  const thirdRowSum =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 2][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstRowSum === secondRowSum && secondRowSum === thirdRowSum;\\n}\\n\\nfunction areAllColumnsEqual(grid, rowIndex, columnIndex) {\\n  const firstColumnSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex + 1][columnIndex] + grid[rowIndex + 2][columnIndex];\\n  const secondColumnSum =\\n    grid[rowIndex][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 1];\\n  const thirdColumnSum =\\n    grid[rowIndex][columnIndex + 2] +\\n    grid[rowIndex + 1][columnIndex + 2] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstColumnSum === secondColumnSum && secondColumnSum === thirdColumnSum;\\n}\\nfunction areAllDiagonalsEqual(grid, rowIndex, columnIndex) {\\n  const firstDiagonal =\\n    grid[rowIndex][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  const secondDiagonal =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex][columnIndex + 2];\\n  return firstDiagonal === secondDiagonal;\\n}\\n\\nvar numMagicSquaresInside = function (grid) {\\n  let count = 0;\\n  for (let rowIndex = 0; rowIndex < grid.length - 2; rowIndex++) {\\n    for (let columnIndex = 0; columnIndex < grid.length - 2; columnIndex++) {\\n      if (\\n        areAllRowsEqual(grid, rowIndex, columnIndex) &&\\n        areAllColumnsEqual(grid, rowIndex, columnIndex) &&\\n        areAllDiagonalsEqual(grid, rowIndex, columnIndex) &&\\n        areNumbersDistinct(grid, rowIndex, columnIndex)\\n      ) {\\n        count += 1;\\n      }\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction areNumbersDistinct(grid, rowIndex, columnIndex) {\\n  const obj = {};\\n  for (let childRowIndex = rowIndex; childRowIndex <= rowIndex + 2; childRowIndex++) {\\n    for (\\n      let childColumnIndex = columnIndex;\\n      childColumnIndex <= columnIndex + 2;\\n      childColumnIndex++\\n    ) {\\n      const currentNum = grid[childRowIndex][childColumnIndex];\\n      if (currentNum < 1 || currentNum > 9) {\\n        return false;\\n      }\\n      if (!obj[grid[childRowIndex][childColumnIndex]]) {\\n        obj[grid[childRowIndex][childColumnIndex]] = 1;\\n      } else {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nfunction areAllRowsEqual(grid, rowIndex, columnIndex) {\\n  const firstRowSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex][columnIndex + 1] + grid[rowIndex][columnIndex + 2];\\n  const secondRowSum =\\n    grid[rowIndex + 1][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 2];\\n  const thirdRowSum =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 2][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstRowSum === secondRowSum && secondRowSum === thirdRowSum;\\n}\\n\\nfunction areAllColumnsEqual(grid, rowIndex, columnIndex) {\\n  const firstColumnSum =\\n    grid[rowIndex][columnIndex] + grid[rowIndex + 1][columnIndex] + grid[rowIndex + 2][columnIndex];\\n  const secondColumnSum =\\n    grid[rowIndex][columnIndex + 1] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 1];\\n  const thirdColumnSum =\\n    grid[rowIndex][columnIndex + 2] +\\n    grid[rowIndex + 1][columnIndex + 2] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  return firstColumnSum === secondColumnSum && secondColumnSum === thirdColumnSum;\\n}\\nfunction areAllDiagonalsEqual(grid, rowIndex, columnIndex) {\\n  const firstDiagonal =\\n    grid[rowIndex][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex + 2][columnIndex + 2];\\n  const secondDiagonal =\\n    grid[rowIndex + 2][columnIndex] +\\n    grid[rowIndex + 1][columnIndex + 1] +\\n    grid[rowIndex][columnIndex + 2];\\n  return firstDiagonal === secondDiagonal;\\n}\\n\\nvar numMagicSquaresInside = function (grid) {\\n  let count = 0;\\n  for (let rowIndex = 0; rowIndex < grid.length - 2; rowIndex++) {\\n    for (let columnIndex = 0; columnIndex < grid.length - 2; columnIndex++) {\\n      if (\\n        areAllRowsEqual(grid, rowIndex, columnIndex) &&\\n        areAllColumnsEqual(grid, rowIndex, columnIndex) &&\\n        areAllDiagonalsEqual(grid, rowIndex, columnIndex) &&\\n        areNumbersDistinct(grid, rowIndex, columnIndex)\\n      ) {\\n        count += 1;\\n      }\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401915,
                "title": "java-expensive-but-still-runs-8ms-to-15ms-detailed-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\t// hashset for checking if grid is filled with 1 to 9\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\t\\t// initialize hashset (fill it 1 to 9 values)\\n\\t\\t\\tfor (int i = 1 ; i <= 9; i++) {\\n\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\t// brute force loop, subtract 3 to avoid out ouf bounds\\n\\t\\t\\tfor (int i = 0 ; i <= grid.length - 3; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j <= grid[0].length - 3; j++) {\\n\\n\\t\\t\\t\\t\\t// make new 3x3 grid\\n\\t\\t\\t\\t\\tint[][] newGrid = new int[3][3];\\n\\n\\t\\t\\t\\t\\t// fill the grid (see function below)\\n\\t\\t\\t\\t\\tfillGrid(grid, newGrid, i, j);\\n\\n\\t\\t\\t\\t\\t// check the requirements to confirm that it is a magic square (see function below)\\n\\t\\t\\t\\t\\tif (oneToNine(newGrid) && matchingSum (newGrid)) {\\n\\t\\t\\t\\t\\t\\tans += 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic void fillGrid(int[][] grid, int[][] newGrid, int i, int j) {\\n\\n\\t\\t\\t// save the original j value because we will use this for the new row such as (i + 1 row will turn back the incremented j to originalJ)\\n\\t\\t\\tint origJ = j;\\n\\n\\t\\t\\tfor (int r = 0; r < 3; r++) {\\n\\t\\t\\t\\tfor (int c = 0; c < 3; c++) {\\n\\t\\t\\t\\t\\tnewGrid[r][c] = grid[i][j]; // place the values from main grid to the new grid\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += 1;  // increment row of main grid\\n\\t\\t\\t\\tj = origJ; // turn j to original j to match the main grid\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean matchingSum(int[][] mat) {\\n\\n\\t\\t\\tint allSum = 0;\\n\\n\\t\\t\\t// get the general sum for row col and diagonal\\n\\t\\t\\tfor (int i = 0; i < 3; i++) {\\n\\t\\t\\t\\tallSum += mat[0][i];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// start at 1 because you already used 0 from general sum (allSum variable)\\n\\t\\t\\tfor (int i = 1; i < 3; i++) {\\n\\t\\t\\t\\t// make variable for row and col sum\\n\\t\\t\\t\\tint rowCurr = 0;\\n\\t\\t\\t\\tint colCurr = 0;\\n\\t\\t\\t\\tfor (int j = 0; j < 3; j++) {\\n\\t\\t\\t\\t\\trowCurr += mat[i][j]; // increment current row sum\\n\\t\\t\\t\\t\\tcolCurr += mat[j][i]; // increment current col sum\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// do the checking for row and col sum\\n\\t\\t\\t\\tif (allSum != rowCurr || allSum != colCurr) return false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// diagonal\\n\\n\\t\\t\\tfor (int i = 2; i >= 0; i--) {\\n\\t\\t\\t\\tallSum -= mat[i][i]; // subtract the value of allSum from the opposite diagonal values\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if it is 0, if zero then it is matched, else false\\n\\t\\t\\tif (allSum != 0) return false;\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean oneToNine(int[][] mat) {\\n\\n\\t\\t\\t// variable to count that we have 1 to 9 values\\n\\t\\t\\tint nineCounts = 0;\\n\\n\\t\\t\\tfor (int[] ar : mat) {\\n\\t\\t\\t\\tfor (int n : ar) {\\n\\t\\t\\t\\t\\tif (set.contains(n)) { // check if set contains the value from the newly made grid\\n\\t\\t\\t\\t\\t\\tset.remove(n); // remove from set\\n\\t\\t\\t\\t\\t\\tnineCounts += 1; // increment nineCounts variable\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 1 ; i <= 9; i++) {\\n\\t\\t\\t\\tset.add(i); // fill up set once again from 1 to 9\\n\\t\\t\\t}\\n\\t\\t\\treturn nineCounts == 9; // check if nineCounts == 9\\n\\t\\t} \\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\t\\t// hashset for checking if grid is filled with 1 to 9\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\n\\t\\t\\t// initialize hashset (fill it 1 to 9 values)\\n\\t\\t\\tfor (int i = 1 ; i <= 9; i++) {\\n\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2378722,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size() ; j++){\\n                if(isMagicSquare(grid, i, j)){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    bool isMagicSquare(vector<vector<int>>& grid, int i, int j){\\n        if(i + 2 < grid.size() && j+2 < grid[i].size()){\\n            int col1 = grid[i][j] + grid[i+1][j] + grid[i+2][j];\\n            int col2 = grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1];\\n            int col3 = grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2];\\n            int row1 = grid[i][j] + grid[i][j+1] + grid[i][j+2];\\n            int row2 = grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2];\\n            int row3 = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];\\n            int diag1 = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2];\\n            int diag2 = grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2];\\n            if(\\n                (col1 == col2) &&\\n                (col1 == col3) &&\\n                (col1 == row1) && \\n                (col1 == row2) &&\\n                (col1 == row3) &&\\n                (col1 == diag1) &&\\n                (col1 == diag2)) {\\n                    set<int> s({1,2,3,4,5,6,7,8,9});\\n                    for(int r = 0 ; r < 3 ; r++){\\n                        for(int c = 0; c < 3 ; c++){\\n                            s.erase(grid[i + r][j + c]);\\n                        }\\n                    }\\n                    return s.empty();\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359322,
                "title": "straightforward-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\t\\t\\tint n=grid.length,m=grid[0].length,count=0;\\n\\t\\t\\tfor(int i=0;i<n-2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m-2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(sum(i,j,grid))\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tpublic boolean sum(int x,int y,int[][] grid)\\n\\t\\t{\\n\\t\\t\\tint sum=grid[x][y]+grid[x][y+1]+grid[x][y+2],sum1=0,sum2=0;\\n\\t\\t\\tint []count=new int[10];\\n\\t\\t\\tfor(int i=0;i<3;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum1=0;\\n\\t\\t\\t\\tsum2=0;   \\n\\t\\t\\t\\tfor(int j=0;j<3;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum1+=grid[x+i][y+j];\\n\\t\\t\\t\\t\\tsum2+=grid[x+j][y+i];\\n\\t\\t\\t\\t\\tif(grid[x+i][y+j]<1 ||grid[x+i][y+j]>9 ||count[grid[x+i][y+j]]!=0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tcount[grid[x+i][y+j]]=1;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(sum1!=sum || sum!=sum2 || sum1!=sum2)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tsum1=grid[x][y]+grid[x+1][y+1]+grid[x+2][y+2];\\n\\t\\t\\tsum2=grid[x][y+2]+grid[x+1][y+1]+grid[x+2][y];\\n\\t\\t\\tif(sum1!=sum2 || sum1!=sum)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int numMagicSquaresInside(int[][] grid) {\\n\\t\\t\\tint n=grid.length,m=grid[0].length,count=0;\\n\\t\\t\\tfor(int i=0;i<n-2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m-2;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(sum(i,j,grid))\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2319604,
                "title": "c-85-faster-easy-to-understand-using-unordered-set-added-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\t\\t// 3x3 cannot exist here as matrix itself is smaller\\n        if (row < 3 or col < 3) return 0;\\n        int magicSquares = 0;\\n        \\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n                unordered_set<int> s;\\n                // first check if all numbers are distinct\\n                s.insert(grid[i-1][j-1]);\\n                s.insert(grid[i-1][j]);\\n                s.insert(grid[i-1][j+1]);\\n                s.insert(grid[i][j-1]);\\n                s.insert(grid[i][j]);\\n                s.insert(grid[i][j+1]);\\n                s.insert(grid[i+1][j-1]);\\n                s.insert(grid[i+1][j]);\\n                s.insert(grid[i+1][j+1]);\\n                \\n\\t\\t\\t\\t// we need exactly 9 numbers\\n                if (s.size() != 9) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We only need numbers from 1-9\\n                bool wrongNum = false;\\n                for (auto val : s) {\\n                    if (val < 1 or val > 9) {\\n                        wrongNum = true;\\n                        break;\\n                    }\\n                }\\n                if (wrongNum) continue;\\n                s.clear();\\n                \\n\\t\\t\\t\\t// After adding all the sums here there should be only one sum in the set\\n\\t\\t\\t\\t// anywhere we see more we can just move to next iteration\\n                s.insert(grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]);\\n                s.insert(grid[i][j-1] + grid[i][j] + grid[i][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j-1] + grid[i+1][j-1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j] + grid[i][j] + grid[i+1][j]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j+1] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j] + grid[i+1][j-1]);\\n                if (s.size() == 1) magicSquares++;\\n            }\\n        }\\n        \\n        return magicSquares;\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\t\\t// 3x3 cannot exist here as matrix itself is smaller\\n        if (row < 3 or col < 3) return 0;\\n        int magicSquares = 0;\\n        \\n        for (int i = 1; i < row - 1; ++i) {\\n            for (int j = 1; j < col - 1; ++j) {\\n                unordered_set<int> s;\\n                // first check if all numbers are distinct\\n                s.insert(grid[i-1][j-1]);\\n                s.insert(grid[i-1][j]);\\n                s.insert(grid[i-1][j+1]);\\n                s.insert(grid[i][j-1]);\\n                s.insert(grid[i][j]);\\n                s.insert(grid[i][j+1]);\\n                s.insert(grid[i+1][j-1]);\\n                s.insert(grid[i+1][j]);\\n                s.insert(grid[i+1][j+1]);\\n                \\n\\t\\t\\t\\t// we need exactly 9 numbers\\n                if (s.size() != 9) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We only need numbers from 1-9\\n                bool wrongNum = false;\\n                for (auto val : s) {\\n                    if (val < 1 or val > 9) {\\n                        wrongNum = true;\\n                        break;\\n                    }\\n                }\\n                if (wrongNum) continue;\\n                s.clear();\\n                \\n\\t\\t\\t\\t// After adding all the sums here there should be only one sum in the set\\n\\t\\t\\t\\t// anywhere we see more we can just move to next iteration\\n                s.insert(grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]);\\n                s.insert(grid[i][j-1] + grid[i][j] + grid[i][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j-1] + grid[i+1][j-1]); \\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j] + grid[i][j] + grid[i+1][j]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j+1] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j-1] + grid[i][j] + grid[i+1][j+1]);\\n                if (s.size() != 1) continue;\\n                s.insert(grid[i-1][j+1] + grid[i][j] + grid[i+1][j-1]);\\n                if (s.size() == 1) magicSquares++;\\n            }\\n        }\\n        \\n        return magicSquares;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290500,
                "title": "java-with-beautiful-solution-explained",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n       int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }\\n        }\\n        return magic_squares;\\n    }\\n    \\n    private boolean isMagic(int[][] grid, int i, int j) {\\n        // For magic squares to be possible :\\n        // Foll conditions should be checked!\\n        \\n        //1. Corners should be even number\\n        if(grid[i][j]%2!=0 || grid[i][j+2]%2!=0 || grid[i+2][j]%2!=0 || grid[i+2][j+2]%2!=0)\\n            return false;\\n        \\n        //2. Non-corners should be odd number\\n        if(grid[i][j+1]%2==0 || grid[i+1][j]%2==0 || grid[i+1][j+2]%2==0 || grid[i+2][j+1]%2==0)\\n            return false;\\n        \\n        //3. Check 2 rows and 2 cols. We can ignore another as if 2 are equal to 15 then third will also be!\\n        if((grid[i][j]+grid[i][j+1]+grid[i][j+2]!=15) || //row 1\\n          (grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2]!=15) || //row 2\\n          (grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]!=15) || //col 1\\n          (grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2]!=15) // col 2\\n          )\\n            return false;\\n        \\n        // 4. Center number should be 5\\n        if(grid[i+1][j+1]!=5)\\n            return false;\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n       int magic_squares = 0;\\n        if(grid.length<3 || grid[0].length<3)\\n            return 0;\\n        for(int i=0; i<=grid.length-3; i++) {\\n            for(int j=0; j<=grid.length-3; j++) {\\n                if(isMagic(grid, i, j)) magic_squares++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2276425,
                "title": "easy-c-solution-using-helper-function",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    bool check(vector<vector<int>>& grid,int r,int c){\\n        int row_sum=0;\\n        int sum = 0;\\n        for(int j=c;j<c+3;j++)\\n            sum += grid[r][j];\\n        // check row\\n        for(int i=r;i<r+3;i++){\\n            row_sum = 0;\\n            for(int j=c;j<c+3;j++){\\n                if(grid[i][j]>9 or grid[i][j] < 1) return false;\\n                row_sum += grid[i][j]; s.insert(grid[i][j]);\\n            }\\n            if(row_sum != sum) return false;\\n        }\\n        if(s.size() == 1) return false;\\n        s.clear();\\n        // check row\\n        for(int i=c;i<c+3;i++){\\n            row_sum = 0;\\n            for(int j=r;j<r+3;j++)\\n                row_sum += grid[j][i];\\n            if(row_sum != sum) return false;\\n        }\\n        //check for dia\\n        row_sum = 0;\\n        int i=r,j=c;\\n        while(i<r+3)\\n            row_sum += grid[i++][j++];\\n        if(row_sum != sum) return false;\\n        i = r,j = c+2;\\n        row_sum = 0;\\n        while(i<r+3)\\n            row_sum += grid[i++][j--];\\n        if(row_sum != sum) return false;\\n        return true;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(n<3 || m<3) return 0;\\n        int ans = 0;\\n        for(int i =0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++)\\n                if(check(grid,i,j)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    bool check(vector<vector<int>>& grid,int r,int c){\\n        int row_sum=0;\\n        int sum = 0;\\n        for(int j=c;j<c+3;j++)\\n            sum += grid[r][j];\\n        // check row\\n        for(int i=r;i<r+3;i++){\\n            row_sum = 0;\\n            for(int j=c;j<c+3;j++){\\n                if(grid[i][j]>9 or grid[i][j] < 1) return false;\\n                row_sum += grid[i][j]; s.insert(grid[i][j]);\\n            }\\n            if(row_sum != sum) return false;\\n        }\\n        if(s.size() == 1) return false;\\n        s.clear();\\n        // check row\\n        for(int i=c;i<c+3;i++){\\n            row_sum = 0;\\n            for(int j=r;j<r+3;j++)\\n                row_sum += grid[j][i];\\n            if(row_sum != sum) return false;\\n        }\\n        //check for dia\\n        row_sum = 0;\\n        int i=r,j=c;\\n        while(i<r+3)\\n            row_sum += grid[i++][j++];\\n        if(row_sum != sum) return false;\\n        i = r,j = c+2;\\n        row_sum = 0;\\n        while(i<r+3)\\n            row_sum += grid[i++][j--];\\n        if(row_sum != sum) return false;\\n        return true;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(n<3 || m<3) return 0;\\n        int ans = 0;\\n        for(int i =0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++)\\n                if(check(grid,i,j)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222691,
                "title": "c",
                "content": "```\\n// BF\\nbool check(int** grid, int row, int col, int* map) {\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            map[grid[row+i][col+j]]++;\\n            if (map[grid[row+i][col+j]] > 1 || grid[row+i][col+j] > 9 || grid[row+i][col+j] == 0) return false;\\n        }\\n    }\\n    int a = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n    int b = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n    int c = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n    if (a != 15 || b != 15 || c != 15) return false;\\n    \\n    int d = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n    int e = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n    int f = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n    if (d != 15 || e != 15 || f != 15) return false;\\n    \\n    int g = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n    int h = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n    if (g != 15 || h != 15) return false;\\n    return true;\\n}\\n\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize) {\\n    if (gridSize < 3 || gridColSize[0] < 3) return 0;\\n    int* map = (int*) calloc(16, sizeof(int));\\n    int cnt = 0;\\n    for (int i = 0; i + 2 < gridSize; i++) {\\n        for (int j = 0; j + 2 < gridColSize[0]; j++) {\\n            if (check(grid, i, j, map)) cnt++;\\n            memset(map, 0, 16 * sizeof(int));\\n        }\\n    }\\n    free(map);\\n    return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// BF\\nbool check(int** grid, int row, int col, int* map) {\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            map[grid[row+i][col+j]]++;\\n            if (map[grid[row+i][col+j]] > 1 || grid[row+i][col+j] > 9 || grid[row+i][col+j] == 0) return false;\\n        }\\n    }\\n    int a = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n    int b = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n    int c = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n    if (a != 15 || b != 15 || c != 15) return false;\\n    \\n    int d = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n    int e = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n    int f = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n    if (d != 15 || e != 15 || f != 15) return false;\\n    \\n    int g = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n    int h = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n    if (g != 15 || h != 15) return false;\\n    return true;\\n}\\n\\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize) {\\n    if (gridSize < 3 || gridColSize[0] < 3) return 0;\\n    int* map = (int*) calloc(16, sizeof(int));\\n    int cnt = 0;\\n    for (int i = 0; i + 2 < gridSize; i++) {\\n        for (int j = 0; j + 2 < gridColSize[0]; j++) {\\n            if (check(grid, i, j, map)) cnt++;\\n            memset(map, 0, 16 * sizeof(int));\\n        }\\n    }\\n    free(map);\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2055385,
                "title": "scala",
                "content": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val OneToNine = (1 to 9).to(BitSet)\\n  \\n  def numMagicSquaresInside(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n\\n    Iterator\\n      .range(0, m - 2)\\n      .flatMap(row => Iterator.tabulate(n - 2)(row -> _))\\n      .count { case (row, col) =>\\n        (for {\\n          i <- (row until row + 3).to(BitSet)\\n          j <- col until col + 3\\n        } yield {\\n          grid(i)(j)\\n        }) == OneToNine && {\\n          val sum = Iterator.range(0, 3).map(k => grid(row + k)(col + 2 - k)).sum\\n\\n          Iterator(Iterator.range(0, 3).map(k => grid(row + k)(col + k)).sum)\\n            .concat(Iterator.range(row, row + 3).map(i => Iterator.range(col, col + 3).map(grid(i)(_)).sum))\\n            .concat(Iterator.range(col, col + 3).map(j => Iterator.range(row, row + 3).map(grid(_)(j)).sum))\\n            .forall(_ == sum)\\n        }\\n      }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.immutable.BitSet\\n\\nobject Solution {\\n  private val OneToNine = (1 to 9).to(BitSet)\\n  \\n  def numMagicSquaresInside(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n\\n    Iterator\\n      .range(0, m - 2)\\n      .flatMap(row => Iterator.tabulate(n - 2)(row -> _))\\n      .count { case (row, col) =>\\n        (for {\\n          i <- (row until row + 3).to(BitSet)\\n          j <- col until col + 3\\n        } yield {\\n          grid(i)(j)\\n        }) == OneToNine && {\\n          val sum = Iterator.range(0, 3).map(k => grid(row + k)(col + 2 - k)).sum\\n\\n          Iterator(Iterator.range(0, 3).map(k => grid(row + k)(col + k)).sum)\\n            .concat(Iterator.range(row, row + 3).map(i => Iterator.range(col, col + 3).map(grid(i)(_)).sum))\\n            .concat(Iterator.range(col, col + 3).map(j => Iterator.range(row, row + 3).map(grid(_)(j)).sum))\\n            .forall(_ == sum)\\n        }\\n      }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2053996,
                "title": "python-brute-force-check-all-3x3-matrices",
                "content": "My slightly verbose python solution:\\n\\n```\\nclass Solution:\\n    # Helper function to check if 3x3 matrix is a magic square\\n    def check_magic(self, mat):\\n        nums = set(range(1, 10))\\n        numbers = []\\n        # Row check\\n        for row in mat:\\n            # Ensuring all numbers are in range 1-9\\n            numbers.extend(row)\\n            if sum(row) != 15:\\n                return False\\n        # Col check\\n        for row in zip(*mat):\\n            if sum(row) != 15:\\n                return False      \\n        # Diagonal checks\\n        if mat[0][0] + mat[1][1] + mat[2][2] != 15:\\n            return False  \\n        if mat[2][0] + mat[1][1] + mat[0][2] != 15:\\n            return False\\n        # Final check to ensure all numbers are 1-9\\n        return nums == set(numbers)\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        # Returns if row/col length is less than 3\\n        if m < 3 or n < 3:\\n            return 0\\n        \\n        # Constructing all 3x3 squares\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                mat = []\\n                for x in range(3):\\n                    row = []\\n                    for y in range(3):\\n                        row.append(grid[x+i][y+j])\\n                    mat.append(row)\\n                if self.check_magic(mat):\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Helper function to check if 3x3 matrix is a magic square\\n    def check_magic(self, mat):\\n        nums = set(range(1, 10))\\n        numbers = []\\n        # Row check\\n        for row in mat:\\n            # Ensuring all numbers are in range 1-9\\n            numbers.extend(row)\\n            if sum(row) != 15:\\n                return False\\n        # Col check\\n        for row in zip(*mat):\\n            if sum(row) != 15:\\n                return False      \\n        # Diagonal checks\\n        if mat[0][0] + mat[1][1] + mat[2][2] != 15:\\n            return False  \\n        if mat[2][0] + mat[1][1] + mat[0][2] != 15:\\n            return False\\n        # Final check to ensure all numbers are 1-9\\n        return nums == set(numbers)\\n    \\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        res = 0\\n        # Returns if row/col length is less than 3\\n        if m < 3 or n < 3:\\n            return 0\\n        \\n        # Constructing all 3x3 squares\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                mat = []\\n                for x in range(3):\\n                    row = []\\n                    for y in range(3):\\n                        row.append(grid[x+i][y+j])\\n                    mat.append(row)\\n                if self.check_magic(mat):\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000921,
                "title": "javascript-memo-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function (grid) {\\n  if (grid.length < 3 || grid[0].length < 3) return 0\\n  const SUM_ROW = 15\\n  let rtn = 0\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length; j++) {\\n      if (isMagic(i, j)) rtn += 1\\n    }\\n  }\\n  return rtn\\n\\n  function isMagic(i, j) {\\n    let [row, column, diagnoal1, diagnoal2] = [isRow, isColumn, isDiagonal1, isDiagonal2].map(x => memo(x))\\n    return row(i, j) && row(i + 1, j) && row(i + 2, j)\\n      && column(i, j) && column(i, j + 1) && column(i, j + 2)\\n      && diagnoal1(i, j) && diagnoal2(i, j) && numCheck(i, j)\\n  }\\n\\n  function numCheck(i, j) {\\n    let arr = new Array(9).fill(0)\\n      ;[0, 1, 2].forEach(x => [0, 1, 2].forEach(y => arr[grid[i + x][j + y] - 1] = 1))\\n    return !arr.some(x => !x)\\n  }\\n\\n  function isRow(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i][j + next], 0)\\n  }\\n\\n  function isColumn(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j], 0)\\n  }\\n\\n\\n  function isDiagonal1(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j + next], 0)\\n  }\\n\\n\\n  function isDiagonal2(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + 2 - next][j + next], 0)\\n  }\\n\\n  function memo(fn) {\\n    let cache = grid.map(x => x.map(y => undefined))\\n    return (i, j) => {\\n      if (cache[i][j] === undefined) cache[i][j] = fn(i, j)\\n      return cache[i][j]\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar numMagicSquaresInside = function (grid) {\\n  if (grid.length < 3 || grid[0].length < 3) return 0\\n  const SUM_ROW = 15\\n  let rtn = 0\\n  for (let i = 0; i < grid.length - 2; i++) {\\n    for (let j = 0; j < grid[i].length; j++) {\\n      if (isMagic(i, j)) rtn += 1\\n    }\\n  }\\n  return rtn\\n\\n  function isMagic(i, j) {\\n    let [row, column, diagnoal1, diagnoal2] = [isRow, isColumn, isDiagonal1, isDiagonal2].map(x => memo(x))\\n    return row(i, j) && row(i + 1, j) && row(i + 2, j)\\n      && column(i, j) && column(i, j + 1) && column(i, j + 2)\\n      && diagnoal1(i, j) && diagnoal2(i, j) && numCheck(i, j)\\n  }\\n\\n  function numCheck(i, j) {\\n    let arr = new Array(9).fill(0)\\n      ;[0, 1, 2].forEach(x => [0, 1, 2].forEach(y => arr[grid[i + x][j + y] - 1] = 1))\\n    return !arr.some(x => !x)\\n  }\\n\\n  function isRow(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i][j + next], 0)\\n  }\\n\\n  function isColumn(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j], 0)\\n  }\\n\\n\\n  function isDiagonal1(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + next][j + next], 0)\\n  }\\n\\n\\n  function isDiagonal2(i, j) {\\n    return SUM_ROW == [0, 1, 2].reduce((result, next) => result + grid[i + 2 - next][j + next], 0)\\n  }\\n\\n  function memo(fn) {\\n    let cache = grid.map(x => x.map(y => undefined))\\n    return (i, j) => {\\n      if (cache[i][j] === undefined) cache[i][j] = fn(i, j)\\n      return cache[i][j]\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988475,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int res = 0;\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j ++){\\n                if(checkMagic(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    boolean checkMagic(int[][] grid, int top, int left){\\n        int sum = 0;\\n        for(int i = 0; i < 3; i ++){\\n            sum += grid[top + i][left+i];\\n        }\\n        HashSet<Integer> set = new HashSet<>(); \\n        for(int i = 0; i < 3; i++){\\n            int dig = 0, row = 0, col = 0;\\n            for(int j = 0; j < 3; j++){\\n                if(grid[top+i][left+j] > 9 || grid[top+i][left+j] < 1) return false;       \\n                set.add(grid[top+i][left+j]);\\n                dig += grid[top + j][left + 2 - j];\\n                row += grid[top + i][left + j];\\n                col += grid[top + j][left + i];\\n            }\\n            if(dig != sum || row != sum || col != sum) return false;\\n        }\\n        return set.size() == 9;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int res = 0;\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length - 2; i++){\\n            for(int j = 0; j < grid[0].length - 2; j ++){\\n                if(checkMagic(grid, i, j)) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    boolean checkMagic(int[][] grid, int top, int left){\\n        int sum = 0;\\n        for(int i = 0; i < 3; i ++){\\n            sum += grid[top + i][left+i];\\n        }\\n        HashSet<Integer> set = new HashSet<>(); \\n        for(int i = 0; i < 3; i++){\\n            int dig = 0, row = 0, col = 0;\\n            for(int j = 0; j < 3; j++){\\n                if(grid[top+i][left+j] > 9 || grid[top+i][left+j] < 1) return false;       \\n                set.add(grid[top+i][left+j]);\\n                dig += grid[top + j][left + 2 - j];\\n                row += grid[top + i][left + j];\\n                col += grid[top + j][left + i];\\n            }\\n            if(dig != sum || row != sum || col != sum) return false;\\n        }\\n        return set.size() == 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955008,
                "title": "c-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int row, col;\\n    bool isMagicSquare(vector<vector<int>>& grid, int r, int c) {\\n        if (r+2>=row || c+2>=col) return false;\\n        \\n        // check if there are unique number from 1 to 9\\n        vector<int> n(10, 0);\\n        for (int i=0; i<3; i++) {\\n            for (int j=0; j<3; j++) {\\n                int idx = grid[r+i][c+j];\\n                if (idx>9 || idx<1 || n[idx]==1) return false;\\n                n[idx]++;\\n            }\\n        }\\n        \\n        // check sum on each row, column and diagnal\\n        vector<int> sumByRow(3, 0), sumByCol(3, 0), sumDiagnal(2, 0);\\n        for (int i=0; i<3; i++) {\\n            sumByRow[i] = accumulate(grid[r+i].begin()+c, grid[r+i].begin()+c+3, 0);\\n            for (int j=0; j<3; j++) {\\n                sumByCol[i] += grid[r+j][c+i];\\n                if (i==j) {\\n                    sumDiagnal[0] += grid[r+i][c+j];\\n                }\\n                if (i+j==2) {\\n                    sumDiagnal[1] += grid[r+i][c+j];\\n                }\\n            }\\n        }\\n        \\n        // since magic square contains unique numbers from 1 to 9, sum for each row, column or diagnose should be 15\\n        for (int i=0; i<3; i++) {\\n            if (sumByRow[i]!=15 || sumByCol[i]!=15) return false;\\n        }\\n        if (sumDiagnal[0]!=15 || sumDiagnal[1]!=15) return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        row = grid.size();\\n        col = grid[0].size();\\n        int cnt = 0;\\n        if (row<3 || col<3) return 0;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int row, col;\\n    bool isMagicSquare(vector<vector<int>>& grid, int r, int c) {\\n        if (r+2>=row || c+2>=col) return false;\\n        \\n        // check if there are unique number from 1 to 9\\n        vector<int> n(10, 0);\\n        for (int i=0; i<3; i++) {\\n            for (int j=0; j<3; j++) {\\n                int idx = grid[r+i][c+j];\\n                if (idx>9 || idx<1 || n[idx]==1) return false;\\n                n[idx]++;\\n            }\\n        }\\n        \\n        // check sum on each row, column and diagnal\\n        vector<int> sumByRow(3, 0), sumByCol(3, 0), sumDiagnal(2, 0);\\n        for (int i=0; i<3; i++) {\\n            sumByRow[i] = accumulate(grid[r+i].begin()+c, grid[r+i].begin()+c+3, 0);\\n            for (int j=0; j<3; j++) {\\n                sumByCol[i] += grid[r+j][c+i];\\n                if (i==j) {\\n                    sumDiagnal[0] += grid[r+i][c+j];\\n                }\\n                if (i+j==2) {\\n                    sumDiagnal[1] += grid[r+i][c+j];\\n                }\\n            }\\n        }\\n        \\n        // since magic square contains unique numbers from 1 to 9, sum for each row, column or diagnose should be 15\\n        for (int i=0; i<3; i++) {\\n            if (sumByRow[i]!=15 || sumByCol[i]!=15) return false;\\n        }\\n        if (sumDiagnal[0]!=15 || sumDiagnal[1]!=15) return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        row = grid.size();\\n        col = grid[0].size();\\n        int cnt = 0;\\n        if (row<3 || col<3) return 0;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931692,
                "title": "100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        \\n        int n=g.size();\\n        int m=g[0].size();\\n        \\n        if(n<3 || m<3)\\n            return 0;\\n        \\n        int count=0;\\n        int r1,r2,r3,c1,c2,c3,d1,d2;\\n        int r,c,d;\\n        for(int i=0;i<n;i++){\\n            if(i+2>=n)\\n                break;\\n            for(int j=0;j<m;j++){\\n              if(j+2>=m)\\n                  break;\\n            \\n                // each row sum of 3*3 matrix whose top left cell=(i,j)\\n                 r1=g[i][j]+g[i][j+1]+g[i][j+2];\\n                 r2=g[i+1][j]+g[i+1][j+1]+g[i+1][j+2];\\n                 r3=g[i+2][j]+g[i+2][j+1]+g[i+2][j+2];\\n        \\n                 // each column sum of 3*3 matrix whose top left cell=(i,j)\\n\\n                c1=g[i][j]+g[i+1][j]+g[i+2][j];\\n                c2=g[i][j+1]+g[i+1][j+1]+g[i+2][j+1];\\n                c3=g[i][j+2]+g[i+1][j+2]+g[i+2][j+2];\\n               \\n                //diagonal sum\\n                d1=g[i][j]+g[i+1][j+1]+g[i+2][j+2];\\n                d2=g[i][j+2]+g[i+1][j+1]+g[i+2][j];\\n                \\n               //checking sum equality\\n                \\n           bool f=false;     \\nif((r1==r2)&&(r1==r3)&&(r1==c1)&&(r1==c2)&&(r1==c3)&&(r1==d1)&&(r1==d2))\\n                  f=true;\\n                else\\n                    continue;\\n                \\n      // checking duplicacy of no\\'s and range of no\\'s [1,9]      \\n                \\n                set<int>st;\\n                \\n                for(int k1=i;k1<=i+2;k1++){\\n                    for(int k2=j;k2<=j+2;k2++){\\n                        if(g[k1][k2]>9 || g[k1][k2]==0){\\n                            f=false;\\n                            break;\\n                        }\\n                        st.insert(g[k1][k2]);\\n                    }\\n                    if(f==false)\\n                        break;\\n                }\\n                \\n                if(f && (st.size()==9))\\n                    count++;\\n\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& g) {\\n        \\n        int n=g.size();\\n        int m=g[0].size();\\n        \\n        if(n<3 || m<3)\\n            return 0;\\n        \\n        int count=0;\\n        int r1,r2,r3,c1,c2,c3,d1,d2;\\n        int r,c,d;\\n        for(int i=0;i<n;i++){\\n            if(i+2>=n)\\n                break;\\n            for(int j=0;j<m;j++){\\n              if(j+2>=m)\\n                  break;\\n            \\n                // each row sum of 3*3 matrix whose top left cell=(i,j)\\n                 r1=g[i][j]+g[i][j+1]+g[i][j+2];\\n                 r2=g[i+1][j]+g[i+1][j+1]+g[i+1][j+2];\\n                 r3=g[i+2][j]+g[i+2][j+1]+g[i+2][j+2];\\n        \\n                 // each column sum of 3*3 matrix whose top left cell=(i,j)\\n\\n                c1=g[i][j]+g[i+1][j]+g[i+2][j];\\n                c2=g[i][j+1]+g[i+1][j+1]+g[i+2][j+1];\\n                c3=g[i][j+2]+g[i+1][j+2]+g[i+2][j+2];\\n               \\n                //diagonal sum\\n                d1=g[i][j]+g[i+1][j+1]+g[i+2][j+2];\\n                d2=g[i][j+2]+g[i+1][j+1]+g[i+2][j];\\n                \\n               //checking sum equality\\n                \\n           bool f=false;     \\nif((r1==r2)&&(r1==r3)&&(r1==c1)&&(r1==c2)&&(r1==c3)&&(r1==d1)&&(r1==d2))\\n                  f=true;\\n                else\\n                    continue;\\n                \\n      // checking duplicacy of no\\'s and range of no\\'s [1,9]      \\n                \\n                set<int>st;\\n                \\n                for(int k1=i;k1<=i+2;k1++){\\n                    for(int k2=j;k2<=j+2;k2++){\\n                        if(g[k1][k2]>9 || g[k1][k2]==0){\\n                            f=false;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1910414,
                "title": "java",
                "content": "```\\nclass Solution {\\n    boolean isMagic(int[][] grid, int row, int col) {\\n        if(row + 2 >= grid.length || col + 2 >= grid[0].length)\\n            return false;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                boolean add = set.add(grid[i][j]);\\n                if(!add || grid[i][j]==0)\\n                    return false;\\n            }\\n        }\\n        int dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + i - row];\\n        }\\n        if (dSum != 15)\\n            return false;\\n        dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + row + 2 - i];\\n        }\\n        if (dSum != 15)\\n            return false;\\n\\n        for (int i = row; i < row + 3; i++) {\\n            int sum = grid[i][col] + grid[i][col + 1] + grid[i][col + 2];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        for (int i = col; i < col + 3; i++) {\\n            int sum = grid[row][i] + grid[row + 1][i] + grid[row + 2][i];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSqaures = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isMagic(grid, i, j))\\n                    magicSqaures++;\\n            }\\n        }\\n        return magicSqaures;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean isMagic(int[][] grid, int row, int col) {\\n        if(row + 2 >= grid.length || col + 2 >= grid[0].length)\\n            return false;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=row; i<row+3; i++){\\n            for(int j=col; j<col+3; j++){\\n                boolean add = set.add(grid[i][j]);\\n                if(!add || grid[i][j]==0)\\n                    return false;\\n            }\\n        }\\n        int dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + i - row];\\n        }\\n        if (dSum != 15)\\n            return false;\\n        dSum = 0;\\n        for (int i = row; i < row + 3; i++) {\\n            dSum += grid[i][col + row + 2 - i];\\n        }\\n        if (dSum != 15)\\n            return false;\\n\\n        for (int i = row; i < row + 3; i++) {\\n            int sum = grid[i][col] + grid[i][col + 1] + grid[i][col + 2];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        for (int i = col; i < col + 3; i++) {\\n            int sum = grid[row][i] + grid[row + 1][i] + grid[row + 2][i];\\n            if (sum != 15)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int magicSqaures = 0;\\n        for (int i = 0; i < grid.length - 2; i++) {\\n            for (int j = 0; j < grid[0].length - 2; j++) {\\n                if (isMagic(grid, i, j))\\n                    magicSqaures++;\\n            }\\n        }\\n        return magicSqaures;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896970,
                "title": "c-solution-easy-to-understand",
                "content": "```C\\nbool checkarr(int **grid, int i, int j)//helper function to check conditions set by problem statement\\n{\\n    int H[16]={-1};//using hashmap, problem constraint says 0 <= grid[i][j] <= 15\\n    for(int k = 0; k<9; k++)//loop to find any duplicate, or any zero element or element >9\\n    {\\n        if(H[grid[i+k/3][j+k%3]]==grid[i+k/3][j+k%3] || grid[i+k/3][j+k%3]==0 || grid[i+k/3][j+k%3]>9)\\n        {\\n            return false;\\n        }\\n        H[grid[i+k/3][j+k%3]] = grid[i+k/3][j+k%3];\\n    }\\n    \\n    int arr[8] = {0};//array to store all the column, row and diagonal sums\\n    for(int k = 0; k <3;k++)\\n    {\\n        arr[6] += grid[i+k][j+k]; //first diagonal sum\\n        arr[7] +=grid[i+k][j+2-k];//second diagonal sum\\n        arr[k]=grid[i+k][j]+grid[i+k][j+1]+grid[i+k][j+2];//row sum\\n        arr[3+k] = grid[i][j+k]+grid[i+1][j+k]+grid[i+2][j+k];//column sum\\n    }\\n    int check = arr[0];\\n    for(int x=0; x<8; x++)// loop to check if all column, row, diagonal sums are same\\n    {\\n        if(arr[x]!=check){return false;}\\n    }\\n    return true;\\n}\\n        \\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    if(gridSize < 3 || *gridColSize < 3){return 0;}\\n    int m = gridSize-2; \\n    int n = *gridColSize-2; // each(m,n) conveys starting element of single 3x3 matrix in the given grid\\n    int count = 0;\\n    for(int i=0; i <m; i++)\\n    {\\n        for(int j = 0; j< n;j++)//loop to pass each 3x3 arr from grid to helper function\\n        {\\n            if(checkarr(grid,i,j)){count++;}//using helper function to check if the 3x3 array passed to it meets all the criteria of the problem.\\n        }\\n    }\\n    return count;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nbool checkarr(int **grid, int i, int j)//helper function to check conditions set by problem statement\\n{\\n    int H[16]={-1};//using hashmap, problem constraint says 0 <= grid[i][j] <= 15\\n    for(int k = 0; k<9; k++)//loop to find any duplicate, or any zero element or element >9\\n    {\\n        if(H[grid[i+k/3][j+k%3]]==grid[i+k/3][j+k%3] || grid[i+k/3][j+k%3]==0 || grid[i+k/3][j+k%3]>9)\\n        {\\n            return false;\\n        }\\n        H[grid[i+k/3][j+k%3]] = grid[i+k/3][j+k%3];\\n    }\\n    \\n    int arr[8] = {0};//array to store all the column, row and diagonal sums\\n    for(int k = 0; k <3;k++)\\n    {\\n        arr[6] += grid[i+k][j+k]; //first diagonal sum\\n        arr[7] +=grid[i+k][j+2-k];//second diagonal sum\\n        arr[k]=grid[i+k][j]+grid[i+k][j+1]+grid[i+k][j+2];//row sum\\n        arr[3+k] = grid[i][j+k]+grid[i+1][j+k]+grid[i+2][j+k];//column sum\\n    }\\n    int check = arr[0];\\n    for(int x=0; x<8; x++)// loop to check if all column, row, diagonal sums are same\\n    {\\n        if(arr[x]!=check){return false;}\\n    }\\n    return true;\\n}\\n        \\nint numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    if(gridSize < 3 || *gridColSize < 3){return 0;}\\n    int m = gridSize-2; \\n    int n = *gridColSize-2; // each(m,n) conveys starting element of single 3x3 matrix in the given grid\\n    int count = 0;\\n    for(int i=0; i <m; i++)\\n    {\\n        for(int j = 0; j< n;j++)//loop to pass each 3x3 arr from grid to helper function\\n        {\\n            if(checkarr(grid,i,j)){count++;}//using helper function to check if the 3x3 array passed to it meets all the criteria of the problem.\\n        }\\n    }\\n    return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1856843,
                "title": "java-solution-fast-with-math",
                "content": "```\\n//The trick is that in every sub-grid, the middlemost element should be \\'5\\'.\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\n//The trick is that in every sub-grid, the middlemost element should be \\'5\\'.\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        //Assuming each row have the same length\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        \\n        int magicBoxCount = 0;\\n        for(int i=0; i<=(grid.length-3); i++){\\n            for(int j=0; (j<=grid[0].length-3); j++){\\n                if(isAMagicBox(grid, i, j)) \\n                    magicBoxCount++;\\n            }\\n        }\\n        \\n        return magicBoxCount;\\n    }\\n    \\n    private boolean isAMagicBox(int[][] grid, int x, int y){\\n        if(grid[x+1][y+1] != 5) return false;\\n        \\n        //corner are even\\n        if(grid[x][y] %2 != 0 || grid[x+2][y] %2 != 0  ||\\n           grid[x][y+2] %2 != 0 || grid[x+2][y+2] %2 != 0 )\\n        {\\n            return false;\\n        }\\n        \\n        //not-corner are odd\\n        if(grid[x+1][y] %2 == 0 || grid[x][y+1] %2 == 0  ||\\n           grid[x+1][y+2] %2 == 0 || grid[x+2][y+1] %2 == 0 )\\n        {\\n            return false;\\n        }\\n        \\n        if ( (grid[x][y] + grid[x][y+1] + grid[x][y+2]) != 15 ||  //row1\\n            (grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2]) != 15 ||  //row2\\n            (grid[x][y] + grid[x+1][y] + grid[x+2][y]) != 15) //column 1\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805859,
                "title": "magic-squares-in-layman-terms",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        //matrix must > 3x3\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(isMagic(grid, i,j))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    boolean isMagic(int [][] grid, int x, int y){\\n        //no overflow \\n        if(x+2 > grid.length || y+2 > grid[0].length){\\n            return false;\\n        }\\n        \\n        //check if middle number is 5 or not \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                if(grid[x + 1][y + 1] != 5){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        //no number must repeat and each grid number must be <= 9 and > 0\\n        HashSet <Integer> set = new HashSet<>();\\n        for(int i = x; i <= x + 2; i++){\\n            for(int j = y; j <= y + 2;j++){\\n                if(set.contains(grid[i][j]) || grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n                \\n        //check if sum of diagonals are equal,rows and columns are equal \\n        int row[] = new int[3];\\n        int col[] = new int[3];\\n        int diagonal[] = new int[2];\\n        \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                row[i-x] += grid[i][j];\\n                col[j-y] += grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n            }\\n        }\\n        \\n        \\n        //checking if all rows cum is equal \\n        int row_val = row[0];\\n        for(int ele : row){\\n            if(ele != row_val) return false;\\n        }\\n        \\n        //checking if all colums sum is equal \\n        int col_val = row[0];\\n        for(int ele : col){\\n            if(ele != col_val) return false;\\n        }\\n        \\n        \\n        // checking if all diagonals sum is equal \\n        \\n        int dig = row[0];\\n        for(int ele : diagonal){\\n            if(ele != dig) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int count = 0;\\n        //matrix must > 3x3\\n        if(grid.length < 3 || grid[0].length < 3) return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(isMagic(grid, i,j))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    boolean isMagic(int [][] grid, int x, int y){\\n        //no overflow \\n        if(x+2 > grid.length || y+2 > grid[0].length){\\n            return false;\\n        }\\n        \\n        //check if middle number is 5 or not \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                if(grid[x + 1][y + 1] != 5){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        //no number must repeat and each grid number must be <= 9 and > 0\\n        HashSet <Integer> set = new HashSet<>();\\n        for(int i = x; i <= x + 2; i++){\\n            for(int j = y; j <= y + 2;j++){\\n                if(set.contains(grid[i][j]) || grid[i][j] > 9 || grid[i][j] < 1)\\n                    return false;\\n                else set.add(grid[i][j]);\\n            }\\n        }\\n                \\n        //check if sum of diagonals are equal,rows and columns are equal \\n        int row[] = new int[3];\\n        int col[] = new int[3];\\n        int diagonal[] = new int[2];\\n        \\n        for(int i = x; i < x + 3; i++){\\n            for(int j = y; j < y + 3;j++){\\n                row[i-x] += grid[i][j];\\n                col[j-y] += grid[i][j];\\n                if( (i==x && j==y ) || (i==x+1 && j==y+1) || ( i==x+2 &&j==y+2) )\\n                    diagonal[0]+=grid[i][j];\\n                if( (i==x&&j==y+2 )||( i==x+1 && j==y+1) ||( i==x+2 && j==y )  )\\n                    diagonal[1]+=grid[i][j];\\n            }\\n        }\\n        \\n        \\n        //checking if all rows cum is equal \\n        int row_val = row[0];\\n        for(int ele : row){\\n            if(ele != row_val) return false;\\n        }\\n        \\n        //checking if all colums sum is equal \\n        int col_val = row[0];\\n        for(int ele : col){\\n            if(ele != col_val) return false;\\n        }\\n        \\n        \\n        // checking if all diagonals sum is equal \\n        \\n        int dig = row[0];\\n        for(int ele : diagonal){\\n            if(ele != dig) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757619,
                "title": "c-brute-force-time-o-w-h-space-o-1",
                "content": "Checks all magic squares in the grid. The check is constant in time complexity since the cost for verifying a 3 x 3 magic square does not increase as the dimension of the grid increases.\\n```\\nint32_t numMagicSquaresInside(\\n\\tvector<vector<int32_t>>& grid)\\n{\\n\\tint32_t answer = 0;\\n\\tif (grid.size() && grid[0].size())\\n\\t{\\n\\t\\tuint32_t rows = grid.size();\\n\\t\\tuint32_t columns = grid[0].size();\\n\\t\\tuint8_t unique[9];\\n\\t\\tif (rows >= 3 && columns >= 3)\\n\\t\\t{\\n\\t\\t\\tfor (uint32_t x = 0; x < columns - 2; x++)\\n\\t\\t\\tfor (uint32_t y = 0; y < rows - 2; y++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemset(unique, 0, sizeof(unique));\\n\\t\\t\\t\\tuint8_t g00 = grid[y+0][x+0];\\n\\t\\t\\t\\tuint8_t g01 = grid[y+0][x+1];\\n\\t\\t\\t\\tuint8_t g02 = grid[y+0][x+2];\\n\\t\\t\\t\\tuint8_t g10 = grid[y+1][x+0];\\n\\t\\t\\t\\tuint8_t g11 = grid[y+1][x+1];\\n\\t\\t\\t\\tuint8_t g12 = grid[y+1][x+2];\\n\\t\\t\\t\\tuint8_t g20 = grid[y+2][x+0];\\n\\t\\t\\t\\tuint8_t g21 = grid[y+2][x+1];\\n\\t\\t\\t\\tuint8_t g22 = grid[y+2][x+2];\\n\\t\\t\\t\\tif (g00 >= 1 && g01 >= 1 && g02 >= 1 &&\\n\\t\\t\\t\\t\\tg10 >= 1 && g11 >= 1 && g12 >= 1 &&\\n\\t\\t\\t\\t\\tg20 >= 1 && g21 >= 1 && g22 >= 1 &&\\n\\t\\t\\t\\t\\tg00 <= 9 && g01 <= 9 && g02 <= 9 &&\\n\\t\\t\\t\\t\\tg10 <= 9 && g11 <= 9 && g12 <= 9 &&\\n\\t\\t\\t\\t\\tg20 <= 9 && g21 <= 9 && g22 <= 9)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuint8_t r1 = g00 + g01 + g02;\\n\\t\\t\\t\\t\\tuint8_t r2 = g10 + g11 + g12;\\n\\t\\t\\t\\t\\tuint8_t r3 = g20 + g21 + g22;\\n\\t\\t\\t\\t\\tuint8_t c1 = g00 + g10 + g20;\\n\\t\\t\\t\\t\\tuint8_t c2 = g01 + g11 + g21;\\n\\t\\t\\t\\t\\tuint8_t c3 = g02 + g12 + g22;\\n\\t\\t\\t\\t\\tuint8_t dl = g00 + g11 + g22;\\n\\t\\t\\t\\t\\tuint8_t dr = g20 + g11 + g02;\\n\\t\\t\\t\\t\\tunique[g00 - 1]++;\\n\\t\\t\\t\\t\\tunique[g01 - 1]++;\\n\\t\\t\\t\\t\\tunique[g02 - 1]++;\\n\\t\\t\\t\\t\\tunique[g10 - 1]++;\\n\\t\\t\\t\\t\\tunique[g11 - 1]++;\\n\\t\\t\\t\\t\\tunique[g12 - 1]++;\\n\\t\\t\\t\\t\\tunique[g20 - 1]++;\\n\\t\\t\\t\\t\\tunique[g21 - 1]++;\\n\\t\\t\\t\\t\\tunique[g22 - 1]++;\\n\\t\\t\\t\\t\\tanswer +=\\n\\t\\t\\t\\t\\t\\tunique[ 0] <= 1 && unique[ 1] <= 1 && unique[ 2] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 3] <= 1 && unique[ 4] <= 1 && unique[ 5] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 6] <= 1 && unique[ 7] <= 1 && unique[ 8] <= 1 &&\\n\\t\\t\\t\\t\\t\\tc1 == c2 && c2 == c3 && c3 == r1 &&\\n\\t\\t\\t\\t\\t\\tr1 == r2 && r2 == r3 && r3 == dl &&\\n\\t\\t\\t\\t\\t\\tdl == dr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint32_t numMagicSquaresInside(\\n\\tvector<vector<int32_t>>& grid)\\n{\\n\\tint32_t answer = 0;\\n\\tif (grid.size() && grid[0].size())\\n\\t{\\n\\t\\tuint32_t rows = grid.size();\\n\\t\\tuint32_t columns = grid[0].size();\\n\\t\\tuint8_t unique[9];\\n\\t\\tif (rows >= 3 && columns >= 3)\\n\\t\\t{\\n\\t\\t\\tfor (uint32_t x = 0; x < columns - 2; x++)\\n\\t\\t\\tfor (uint32_t y = 0; y < rows - 2; y++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemset(unique, 0, sizeof(unique));\\n\\t\\t\\t\\tuint8_t g00 = grid[y+0][x+0];\\n\\t\\t\\t\\tuint8_t g01 = grid[y+0][x+1];\\n\\t\\t\\t\\tuint8_t g02 = grid[y+0][x+2];\\n\\t\\t\\t\\tuint8_t g10 = grid[y+1][x+0];\\n\\t\\t\\t\\tuint8_t g11 = grid[y+1][x+1];\\n\\t\\t\\t\\tuint8_t g12 = grid[y+1][x+2];\\n\\t\\t\\t\\tuint8_t g20 = grid[y+2][x+0];\\n\\t\\t\\t\\tuint8_t g21 = grid[y+2][x+1];\\n\\t\\t\\t\\tuint8_t g22 = grid[y+2][x+2];\\n\\t\\t\\t\\tif (g00 >= 1 && g01 >= 1 && g02 >= 1 &&\\n\\t\\t\\t\\t\\tg10 >= 1 && g11 >= 1 && g12 >= 1 &&\\n\\t\\t\\t\\t\\tg20 >= 1 && g21 >= 1 && g22 >= 1 &&\\n\\t\\t\\t\\t\\tg00 <= 9 && g01 <= 9 && g02 <= 9 &&\\n\\t\\t\\t\\t\\tg10 <= 9 && g11 <= 9 && g12 <= 9 &&\\n\\t\\t\\t\\t\\tg20 <= 9 && g21 <= 9 && g22 <= 9)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuint8_t r1 = g00 + g01 + g02;\\n\\t\\t\\t\\t\\tuint8_t r2 = g10 + g11 + g12;\\n\\t\\t\\t\\t\\tuint8_t r3 = g20 + g21 + g22;\\n\\t\\t\\t\\t\\tuint8_t c1 = g00 + g10 + g20;\\n\\t\\t\\t\\t\\tuint8_t c2 = g01 + g11 + g21;\\n\\t\\t\\t\\t\\tuint8_t c3 = g02 + g12 + g22;\\n\\t\\t\\t\\t\\tuint8_t dl = g00 + g11 + g22;\\n\\t\\t\\t\\t\\tuint8_t dr = g20 + g11 + g02;\\n\\t\\t\\t\\t\\tunique[g00 - 1]++;\\n\\t\\t\\t\\t\\tunique[g01 - 1]++;\\n\\t\\t\\t\\t\\tunique[g02 - 1]++;\\n\\t\\t\\t\\t\\tunique[g10 - 1]++;\\n\\t\\t\\t\\t\\tunique[g11 - 1]++;\\n\\t\\t\\t\\t\\tunique[g12 - 1]++;\\n\\t\\t\\t\\t\\tunique[g20 - 1]++;\\n\\t\\t\\t\\t\\tunique[g21 - 1]++;\\n\\t\\t\\t\\t\\tunique[g22 - 1]++;\\n\\t\\t\\t\\t\\tanswer +=\\n\\t\\t\\t\\t\\t\\tunique[ 0] <= 1 && unique[ 1] <= 1 && unique[ 2] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 3] <= 1 && unique[ 4] <= 1 && unique[ 5] <= 1 &&\\n\\t\\t\\t\\t\\t\\tunique[ 6] <= 1 && unique[ 7] <= 1 && unique[ 8] <= 1 &&\\n\\t\\t\\t\\t\\t\\tc1 == c2 && c2 == c3 && c3 == r1 &&\\n\\t\\t\\t\\t\\t\\tr1 == r2 && r2 == r3 && r3 == dl &&\\n\\t\\t\\t\\t\\t\\tdl == dr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729470,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int result = 0;\\n        for (int i = 0; i < grid.length - 2; i++)\\n            for (int j = 0; j < grid[0].length - 2; j++)\\n                 if (this.isMagicBox(grid, i, j)) \\n                     result++;\\n         return result;\\n    }\\n\\n    boolean isMagicBox(int[][] grid, int x, int y) {\\n        if (grid[x+1][y+1] != 5)\\n            return false;\\n        boolean flag = false;\\n        int rowSum = 0;\\n        for (int r = x; r < x + 3; r++) {\\n            rowSum = 0;\\n            for (int c = y; c < y + 3; c++) {\\n                rowSum += grid[r][c];\\n                flag = !flag;\\n                if (r == x+1 && c == y+1)\\n                    continue;\\n                if (this.isEven(grid[r][c]) != flag)\\n                    return false;\\n            }\\n            if (rowSum != 15)\\n                return false;\\n        }\\n        return grid[x][y] + grid[x+1][y] + grid[x+2][y] == 15;\\n    }\\n    \\n    boolean isEven(int n) {\\n        return (n & 1) == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int result = 0;\\n        for (int i = 0; i < grid.length - 2; i++)\\n            for (int j = 0; j < grid[0].length - 2; j++)\\n                 if (this.isMagicBox(grid, i, j)) \\n                     result++;\\n         return result;\\n    }\\n\\n    boolean isMagicBox(int[][] grid, int x, int y) {\\n        if (grid[x+1][y+1] != 5)\\n            return false;\\n        boolean flag = false;\\n        int rowSum = 0;\\n        for (int r = x; r < x + 3; r++) {\\n            rowSum = 0;\\n            for (int c = y; c < y + 3; c++) {\\n                rowSum += grid[r][c];\\n                flag = !flag;\\n                if (r == x+1 && c == y+1)\\n                    continue;\\n                if (this.isEven(grid[r][c]) != flag)\\n                    return false;\\n            }\\n            if (rowSum != 15)\\n                return false;\\n        }\\n        return grid[x][y] + grid[x+1][y] + grid[x+2][y] == 15;\\n    }\\n    \\n    boolean isEven(int n) {\\n        return (n & 1) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724617,
                "title": "magic-square-java-easy-to-understand-solution",
                "content": "//The only thing that you actually need to know is that a 3x3 magic square has 5 at it\\'s center.\\n\\n```\\nclass Solution {\\n  public int numMagicSquaresInside(int[][] grid) {\\n\\n\\n    int m = grid.length; //r\\n    int n = grid[0].length; //c\\n\\n    if (m < 3 || n < 3)\\n      return 0;\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < m - 2; i++)\\n    {\\n      for (int j = 0; j < n - 2; j++)\\n      {\\n        if (grid[i + 1][j + 1] == 5)\\n          if (isMagicGrid(i, j, grid) == true)\\n            count++;\\n      }\\n\\n    }\\n\\n    return count;\\n  }\\n  public static boolean isMagicGrid(int x, int y, int [][]grid) {\\n\\n\\n    int a = grid[x + 0][y + 0];\\n    int b = grid[x + 0][y + 1];\\n    int c = grid[x + 0][y + 2];\\n\\n    int d = grid[x + 1][y + 0];\\n    int e = grid[x + 1][y + 1];\\n    int f = grid[x + 1][y + 2];\\n\\n    int g = grid[x + 2][y + 0];\\n    int h = grid[x + 2][y + 1];\\n    int i = grid[x + 2][y + 2];\\n\\n\\n    HashSet<Integer> hmap = new HashSet<>();\\n\\n    int arr[] = {a, b, c, d, e, f, g, h, i};\\n    for (int p = 0; p < 9 ; p++)\\n    {\\n      if (arr[p] >= 1 && arr[p]  <= 9)\\n        hmap.add(arr[p]);\\n\\n    }\\n\\n    Boolean first = false;\\n    if (hmap.size() == 9)\\n      first = true;\\n\\n\\n\\n\\n\\n    Boolean second = false;\\n\\n\\n\\n\\n\\n\\n\\n\\n    if (a + b + c == 15 && d + e + f == 15 && g + h + i == 15 && a + d + g == 15 && b + e + h == 15 &&   c + f + i == 15 && a + e + i == 15 && c + e + g == 15  )\\n      second = true;\\n\\n\\n    return (first == true && second == true)  ;\\n\\n  }\\n\\n}\\n// please upvote so that others can see it too",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n  public int numMagicSquaresInside(int[][] grid) {\\n\\n\\n    int m = grid.length; //r\\n    int n = grid[0].length; //c\\n\\n    if (m < 3 || n < 3)\\n      return 0;\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < m - 2; i++)\\n    {\\n      for (int j = 0; j < n - 2; j++)\\n      {\\n        if (grid[i + 1][j + 1] == 5)\\n          if (isMagicGrid(i, j, grid) == true)\\n            count++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1690285,
                "title": "edge-case-missed-by-leetcode",
                "content": "my code is accepted,but showing wrong ans for [[1,2,7,6],[4,9,5,1],[5,4,3,8]]\\n\\n ```\\n public static int numMagicSquaresInside(int[][] grid) {\\n  \\t  \\t  // Write your code here\\n  \\t  \\t   int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i+2<=grid.length-1 && j+2<=grid[0].length-1){\\n            int []record=new int[10];\\n            int ans=0;\\n            for(int a=i;a<i+3;a++){\\n                for(int b=j;b<j+3;b++){\\n                    if(grid[a][b]<1 || grid[a][b]>9 || record[grid[a][b]]>0){\\n                        ans=-1;\\n                    }\\n                    else{\\n                        record[grid[a][b]]=1;\\n                    }\\n                }\\n            }\\n            \\n            if(grid[i+1][j+1]!=5){\\n                if(j+2<grid.length-1){\\n                    j++;\\n                    continue;\\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                     continue;\\n                    \\n                }\\n               \\n            }\\n            else{\\n        \\n            int row1=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n            int row2=grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n            int row3=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n            int col1=grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n            int col2=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];\\n            int col3=grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n            int dia1=grid[i][j]+5+grid[i+2][j+2];\\n            int dia2=grid[i][j+2]+5+grid[i+2][j];\\n            if(row2==row1 && col1 == row1 && col2 == row1 && dia1==row1 && dia1==dia2 && ans==0){\\n                \\n                count++;\\n            }\\n             if(j+2<grid.length-1){\\n                    j++;\\n                   \\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                 }\\n        }\\n            \\n    }\\n     return count;   \\n  \\t  }\\n```\\n\\ni cant figure out where i am wrong . pls help",
                "solutionTags": [],
                "code": "```\\n public static int numMagicSquaresInside(int[][] grid) {\\n  \\t  \\t  // Write your code here\\n  \\t  \\t   int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i+2<=grid.length-1 && j+2<=grid[0].length-1){\\n            int []record=new int[10];\\n            int ans=0;\\n            for(int a=i;a<i+3;a++){\\n                for(int b=j;b<j+3;b++){\\n                    if(grid[a][b]<1 || grid[a][b]>9 || record[grid[a][b]]>0){\\n                        ans=-1;\\n                    }\\n                    else{\\n                        record[grid[a][b]]=1;\\n                    }\\n                }\\n            }\\n            \\n            if(grid[i+1][j+1]!=5){\\n                if(j+2<grid.length-1){\\n                    j++;\\n                    continue;\\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                     continue;\\n                    \\n                }\\n               \\n            }\\n            else{\\n        \\n            int row1=grid[i][j]+grid[i][j+1]+grid[i][j+2];\\n            int row2=grid[i+1][j]+grid[i+1][j+1]+grid[i+1][j+2];\\n            int row3=grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2];\\n            int col1=grid[i][j]+grid[i+1][j]+grid[i+2][j];\\n            int col2=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1];\\n            int col3=grid[i][j+2]+grid[i+1][j+2]+grid[i+2][j+2];\\n            int dia1=grid[i][j]+5+grid[i+2][j+2];\\n            int dia2=grid[i][j+2]+5+grid[i+2][j];\\n            if(row2==row1 && col1 == row1 && col2 == row1 && dia1==row1 && dia1==dia2 && ans==0){\\n                \\n                count++;\\n            }\\n             if(j+2<grid.length-1){\\n                    j++;\\n                   \\n                }\\n                else if(j+2==grid.length-1){\\n                    i++;\\n                    j=0;\\n                 }\\n        }\\n            \\n    }\\n     return count;   \\n  \\t  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682225,
                "title": "magic-square-java",
                "content": "class Solution {\\n    public boolean check(int grid[][],int i,int j){\\n        \\n        int r1=grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1];\\n        int r2=grid[i][j-1]+grid[i][j]+grid[i][j+1];\\n        int r3=grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1];\\n        int c1=grid[i-1][j-1]+grid[i][j-1]+grid[i+1][j-1];\\n        int c2=grid[i-1][j]+grid[i][j]+grid[i+1][j];\\n        int c3=grid[i-1][j+1]+grid[i][j+1]+grid[i+1][j+1];\\n        int d1=grid[i][j]+grid[i-1][j-1]+grid[i+1][j+1];\\n        int d2=grid[i][j]+grid[i-1][j+1]+grid[i+1][j-1];\\n        // System.out.print(r1+\" \"+r2+\" \"+r3+\" \"+c1+\" \"+c2+\" \"+c3+\" \"+d1+\" \"+d2);\\n        HashSet<Integer> h=new HashSet<>();\\n        boolean flag=true;\\n        h.add(grid[i-1][j-1]);\\n        h.add(grid[i-1][j]);\\n        h.add(grid[i-1][j+1]);\\n        h.add(grid[i][j-1]);\\n        h.add(grid[i][j]);\\n        h.add(grid[i][j+1]);\\n        h.add(grid[i+1][j-1]);\\n        h.add(grid[i+1][j]);\\n        h.add(grid[i+1][j+1]);\\n        for(int n:h){\\n            if(n>=10){\\n                flag=false;\\n                break;\\n            }\\n        }\\n        if(r1==r2&&r3==r2&&c1==r1&&c2==c1&&c3==c1&&d1==r1&&d2==d1&&h.size()==9&&flag==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length<3||grid[0].length<3){\\n            return 0;\\n        }\\n        int c=0;\\n        for(int i=1;i<grid.length-1;i++){\\n            for(int j=1;j<grid[0].length-1;j++){\\n                if(grid[i][j]==5){\\n                    boolean ans=check(grid,i,j);\\n                    // System.out.print(ans);\\n                    if(ans==true)c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean check(int grid[][],int i,int j){\\n        \\n        int r1=grid[i-1][j-1]+grid[i-1][j]+grid[i-1][j+1];\\n        int r2=grid[i][j-1]+grid[i][j]+grid[i][j+1];\\n        int r3=grid[i+1][j-1]+grid[i+1][j]+grid[i+1][j+1];\\n        int c1=grid[i-1][j-1]+grid[i][j-1]+grid[i+1][j-1];\\n        int c2=grid[i-1][j]+grid[i][j]+grid[i+1][j];\\n        int c3=grid[i-1][j+1]+grid[i][j+1]+grid[i+1][j+1];\\n        int d1=grid[i][j]+grid[i-1][j-1]+grid[i+1][j+1];\\n        int d2=grid[i][j]+grid[i-1][j+1]+grid[i+1][j-1];\\n        // System.out.print(r1+\" \"+r2+\" \"+r3+\" \"+c1+\" \"+c2+\" \"+c3+\" \"+d1+\" \"+d2);\\n        HashSet<Integer> h=new HashSet<>();\\n        boolean flag=true;\\n        h.add(grid[i-1][j-1]);\\n        h.add(grid[i-1][j]);\\n        h.add(grid[i-1][j+1]);\\n        h.add(grid[i][j-1]);\\n        h.add(grid[i][j]);\\n        h.add(grid[i][j+1]);\\n        h.add(grid[i+1][j-1]);\\n        h.add(grid[i+1][j]);\\n        h.add(grid[i+1][j+1]);\\n        for(int n:h){\\n            if(n>=10){\\n                flag=false;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1669102,
                "title": "with-hashset-and-system-out-println-for-easier-simulation",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int result = 0;\\n        \\n        for(int i=0;i<row-2;i++)\\n        {\\n            for(int j = 0 ; j< col-2;j++)\\n            {\\n                if(grid[i+1][j+1] == 5)\\n                {\\n                    if(isMagic(i,j,grid))\\n                    {\\n                        result++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n            \\n    }\\n    \\n    public boolean isMagic(int row , int col , int[][] grid)\\n    {\\n        Set<Integer> set = new HashSet();\\n        for(int i=row ; i<row+3 ; i++)\\n        {\\n            for(int j = col ; j<col+3 ; j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    return false;\\n                }\\n                set.add(grid[i][j]);\\n            }\\n        }\\n        \\n        if(set.size() != 9)\\n        {\\n            return false;\\n        }\\n            \\n        \\n        int sum1 = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        \\n        System.out.println(sum1 + \"----\");\\n        \\n        int sum2 = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n        \\n        System.out.println(sum2 + \"----\");\\n        int sum3 = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n        System.out.println(sum3 + \"----\");\\n        int diag1 = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n        System.out.println(diag1 + \"----\");\\n        int diag2 = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n        System.out.println(diag2 + \"----\");\\n        \\n        int col1 = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n        System.out.println(col1 + \"----\");\\n        int col2 = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n        System.out.println(col2 + \"----\");\\n        int col3 = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n        System.out.println(col3 + \"----\");\\n        \\n        \\n        if(sum1 == sum2 && sum2 == sum3 && diag1 == diag2 && col1==col2 && col2==col3)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int result = 0;\\n        \\n        for(int i=0;i<row-2;i++)\\n        {\\n            for(int j = 0 ; j< col-2;j++)\\n            {\\n                if(grid[i+1][j+1] == 5)\\n                {\\n                    if(isMagic(i,j,grid))\\n                    {\\n                        result++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n            \\n    }\\n    \\n    public boolean isMagic(int row , int col , int[][] grid)\\n    {\\n        Set<Integer> set = new HashSet();\\n        for(int i=row ; i<row+3 ; i++)\\n        {\\n            for(int j = col ; j<col+3 ; j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    return false;\\n                }\\n                set.add(grid[i][j]);\\n            }\\n        }\\n        \\n        if(set.size() != 9)\\n        {\\n            return false;\\n        }\\n            \\n        \\n        int sum1 = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        \\n        System.out.println(sum1 + \"----\");\\n        \\n        int sum2 = grid[row+1][col] + grid[row+1][col+1] + grid[row+1][col+2];\\n        \\n        System.out.println(sum2 + \"----\");\\n        int sum3 = grid[row+2][col] + grid[row+2][col+1] + grid[row+2][col+2];\\n        System.out.println(sum3 + \"----\");\\n        int diag1 = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];\\n        System.out.println(diag1 + \"----\");\\n        int diag2 = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];\\n        System.out.println(diag2 + \"----\");\\n        \\n        int col1 = grid[row][col] + grid[row+1][col] + grid[row+2][col];\\n        System.out.println(col1 + \"----\");\\n        int col2 = grid[row][col+1] + grid[row+1][col+1] + grid[row+2][col+1];\\n        System.out.println(col2 + \"----\");\\n        int col3 = grid[row][col+2] + grid[row+1][col+2] + grid[row+2][col+2];\\n        System.out.println(col3 + \"----\");\\n        \\n        \\n        if(sum1 == sum2 && sum2 == sum3 && diag1 == diag2 && col1==col2 && col2==col3)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642412,
                "title": "simple-and-clean-with-brute-force-approach",
                "content": "class Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def check(i,j):\\n            k=[grid[i][j],grid[i+1][j],grid[i+2][j],grid[i][j+1],grid[i+1][j+1],grid[i+2][j+1],grid[i][j+2],grid[i+1][j+2],grid[i+2][j+2]]\\n            k.sort()\\n            w1=list(range(1,10))\\n            if(w1!=k):\\n                return(0)\\n            w=[]\\n            t1=sum(grid[i][j:j+3])\\n            t2=sum(grid[i+1][j:j+3])\\n            t3=sum(grid[i+2][j:j+3])\\n            t4=grid[i][j]+grid[i+1][j]+grid[i+2][j]\\n            t5=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t6=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t7=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]\\n            t8=grid[i+1][j+1]+grid[i][j+2]+grid[i+2][j]\\n            # print(t1,t2,t3,t4,t5,t6,t7,t8)\\n            if(t1 == t2 and t2 == t3 and t3 == t4 and t4 == t5 and t5 == t6 and t6 == t7 and t7 == t8):\\n        \\n                return(1)\\n            return(0)\\n    \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[i])-2):\\n                count=count+ check(i,j)\\n        return(count)\\n                \\n\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def check(i,j):\\n            k=[grid[i][j],grid[i+1][j],grid[i+2][j],grid[i][j+1],grid[i+1][j+1],grid[i+2][j+1],grid[i][j+2],grid[i+1][j+2],grid[i+2][j+2]]\\n            k.sort()\\n            w1=list(range(1,10))\\n            if(w1!=k):\\n                return(0)\\n            w=[]\\n            t1=sum(grid[i][j:j+3])\\n            t2=sum(grid[i+1][j:j+3])\\n            t3=sum(grid[i+2][j:j+3])\\n            t4=grid[i][j]+grid[i+1][j]+grid[i+2][j]\\n            t5=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t6=grid[i][j+1]+grid[i+1][j+1]+grid[i+2][j+1]\\n            t7=grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]\\n            t8=grid[i+1][j+1]+grid[i][j+2]+grid[i+2][j]\\n            # print(t1,t2,t3,t4,t5,t6,t7,t8)\\n            if(t1 == t2 and t2 == t3 and t3 == t4 and t4 == t5 and t5 == t6 and t6 == t7 and t7 == t8):\\n        \\n                return(1)\\n            return(0)\\n    \\n        count=0\\n        for i in range(len(grid)-2):\\n            for j in range(len(grid[i])-2):\\n                count=count+ check(i,j)\\n        return(count)\\n                \\n\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1595645,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public static int numMagicSquaresInside(int[][] grid) {\\n       if(grid[0].length<3 || grid.length<3)\\n           return 0;\\n        int count=0;\\n            for(int i=0;i<=grid.length-3;i++){\\n                for(int j=0;j<=grid[0].length-3;j++){\\n                    if(isMagicSquare(i,j,grid))\\n                        count++;    \\n            }\\n        \\n        }\\n        return count;\\n    }\\n    public static boolean isMagicSquare(int i,int j,int[][]grid){\\n        Set<Integer> uniqueSet=new HashSet<>();\\n        //Map<Integer,Integer> rowMap=new HashMap<>();\\n        int rowSum=0;\\n        int rowTemp=0;\\n        int leftDiag=0;\\n        int rightDiag=0;\\n        Map<Integer,Integer>colMap=new HashMap<>();\\n        \\n        \\n        for(int a=i;a<i+3;a++){\\n            rowSum=0;\\n            for(int b=j;b<j+3;b++){\\n                if(uniqueSet.contains(grid[a][b])||grid[a][b]>9||grid[a][b]<1)\\n                    return false;\\n                else\\n                    uniqueSet.add(grid[a][b]);\\n                colMap.put(b-j,colMap.getOrDefault(b-j,0)+grid[a][b]);        \\n                rowSum=rowSum+grid[a][b];\\n                if((a-i)==(b-j))\\n                    leftDiag=leftDiag+grid[a][b];\\n                if(((a-i)==(2-(b-j))))\\n                    rightDiag=rightDiag+grid[a][b];\\n            }\\n            if(rowTemp==0)\\n                rowTemp=rowSum;\\n            else if(rowTemp!=rowSum)\\n                return false;\\n            \\n        }if(rightDiag!=leftDiag)\\n            return false;\\n        if(colMap.get(0)!=colMap.get(1)||colMap.get(1)!=colMap.get(2))\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int numMagicSquaresInside(int[][] grid) {\\n       if(grid[0].length<3 || grid.length<3)\\n           return 0;\\n        int count=0;\\n            for(int i=0;i<=grid.length-3;i++){\\n                for(int j=0;j<=grid[0].length-3;j++){\\n                    if(isMagicSquare(i,j,grid))\\n                        count++;    \\n            }\\n        \\n        }\\n        return count;\\n    }\\n    public static boolean isMagicSquare(int i,int j,int[][]grid){\\n        Set<Integer> uniqueSet=new HashSet<>();\\n        //Map<Integer,Integer> rowMap=new HashMap<>();\\n        int rowSum=0;\\n        int rowTemp=0;\\n        int leftDiag=0;\\n        int rightDiag=0;\\n        Map<Integer,Integer>colMap=new HashMap<>();\\n        \\n        \\n        for(int a=i;a<i+3;a++){\\n            rowSum=0;\\n            for(int b=j;b<j+3;b++){\\n                if(uniqueSet.contains(grid[a][b])||grid[a][b]>9||grid[a][b]<1)\\n                    return false;\\n                else\\n                    uniqueSet.add(grid[a][b]);\\n                colMap.put(b-j,colMap.getOrDefault(b-j,0)+grid[a][b]);        \\n                rowSum=rowSum+grid[a][b];\\n                if((a-i)==(b-j))\\n                    leftDiag=leftDiag+grid[a][b];\\n                if(((a-i)==(2-(b-j))))\\n                    rightDiag=rightDiag+grid[a][b];\\n            }\\n            if(rowTemp==0)\\n                rowTemp=rowSum;\\n            else if(rowTemp!=rowSum)\\n                return false;\\n            \\n        }if(rightDiag!=leftDiag)\\n            return false;\\n        if(colMap.get(0)!=colMap.get(1)||colMap.get(1)!=colMap.get(2))\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578281,
                "title": "java-brute-force-faster-than-100-submissions",
                "content": "```\\nclass Solution {\\n    \\n    private int k = 3;\\n    \\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(isMagic(grid, i,j))\\n                    count++;\\n        return count;\\n    }\\n    \\n    public boolean isMagic(int[][] grid, int x, int y){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(n - x < k)\\n            return false;\\n        if(m - y < k)\\n            return false;\\n        int targetSum = 0;\\n        for(int i = x; i < x+k; i++)\\n            targetSum+=grid[i][y];\\n        \\n        int sum = 0;\\n        for(int i=y+1; i<y+k;i++){\\n            sum = 0;\\n            for(int j = x; j < x+k; j++)\\n                sum+=grid[j][i];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        for(int i=x; i<x+k;i++){\\n            sum=0;\\n            for(int j = y; j < y+k; j++)\\n                sum+=grid[i][j];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        int diagonalSum = 0;\\n        int antiDiagonalSum = 0;\\n        int sumOfDiagonalIndices = x + y + k - 1;\\n        \\n        Set<Integer> unique = new HashSet<>();\\n        \\n        for(int i=x; i<x+k;i++)\\n            for(int j=y;j<y+k;j++){\\n                if(grid[i][j] < 1 || grid[i][j] > 9)\\n                    return false;\\n                unique.add(grid[i][j]);\\n                if(i-x==j-y)\\n                    diagonalSum+=grid[i][j];\\n                if(i + j == sumOfDiagonalIndices)\\n                    antiDiagonalSum+=grid[i][j];  \\n            }\\n        \\n        if(unique.size() < k*k)\\n            return false;\\n        \\n        if(targetSum!=diagonalSum)\\n            return false;\\n        \\n        if(targetSum!=antiDiagonalSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int k = 3;\\n    \\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(isMagic(grid, i,j))\\n                    count++;\\n        return count;\\n    }\\n    \\n    public boolean isMagic(int[][] grid, int x, int y){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if(n - x < k)\\n            return false;\\n        if(m - y < k)\\n            return false;\\n        int targetSum = 0;\\n        for(int i = x; i < x+k; i++)\\n            targetSum+=grid[i][y];\\n        \\n        int sum = 0;\\n        for(int i=y+1; i<y+k;i++){\\n            sum = 0;\\n            for(int j = x; j < x+k; j++)\\n                sum+=grid[j][i];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        for(int i=x; i<x+k;i++){\\n            sum=0;\\n            for(int j = y; j < y+k; j++)\\n                sum+=grid[i][j];\\n            if(sum!=targetSum)\\n                return false;\\n        }\\n        \\n        int diagonalSum = 0;\\n        int antiDiagonalSum = 0;\\n        int sumOfDiagonalIndices = x + y + k - 1;\\n        \\n        Set<Integer> unique = new HashSet<>();\\n        \\n        for(int i=x; i<x+k;i++)\\n            for(int j=y;j<y+k;j++){\\n                if(grid[i][j] < 1 || grid[i][j] > 9)\\n                    return false;\\n                unique.add(grid[i][j]);\\n                if(i-x==j-y)\\n                    diagonalSum+=grid[i][j];\\n                if(i + j == sumOfDiagonalIndices)\\n                    antiDiagonalSum+=grid[i][j];  \\n            }\\n        \\n        if(unique.size() < k*k)\\n            return false;\\n        \\n        if(targetSum!=diagonalSum)\\n            return false;\\n        \\n        if(targetSum!=antiDiagonalSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549633,
                "title": "optimized-brute-force-javascript-with-comments-beats-85-95",
                "content": "\\n\\n\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\n// An enumerator class that allows for O(1)\\n// insertions and checks for completion (all numbers being present)\\nclass Enumerator {\\n    enum = {\\n        1: true,\\n        2: true,\\n        3: true,\\n        4: true,\\n        5: true,\\n        6: true,\\n        7: true,\\n        8: true,\\n        9: true\\n    }\\n    set = new Set();\\n\\n    isValid(item) {\\n        return item in this.enum;\\n    }\\n    insert(item) {\\n        if(this.isValid(item)) {\\n            this.set.add(item);\\n        }\\n    }\\n    get complete() {\\n        return this.set.size === 9;\\n    }\\n}\\n\\nclass Solution {\\n    constructor(grid) {\\n        this.total = 0;\\n        this.grid = grid;\\n        // cache the max indices that can serve as the top\\n        // left cell of a square and use them as outer\\n        // bounds for the initial loop\\n        this.maxHIndex = this.grid[0].length - 2;\\n        this.maxVIndex = this.grid.length - 2;\\n        // return early if the grid is too small\\n        if(this.maxHIndex < 0 || this.maxVIndex < 0) {\\n            return;\\n        }\\n        this.enumerator = new Enumerator();\\n        this.execute();\\n    }\\n    execute() {\\n        for(let i = 0; i < this.maxVIndex; i++) {\\n            for(let j = 0; j < this.maxHIndex; j++) {\\n                // search from a valid top-left position\\n                this.search(i, j);\\n                this.enumerator = new Enumerator();\\n            }\\n        }\\n    }\\n    search(y, x) {  \\n        // the middle cell must be a 5 to be a \"magic square\"\\n        if(this.grid[y + 1][x + 1] !== 5) {\\n            return false;\\n        }\\n        this.enumerator.insert(5);\\n        const topLeft = this.grid[y][x];\\n        // make sure your starting point is within the range 1-9\\n        if(!this.enumerator.isValid(topLeft)) {\\n            return;\\n        }\\n        // validate the square\\n        if(this.validate(y, x)) {\\n            this.total++;\\n        }\\n    }\\n    validate(y, x) {\\n        let HSum;\\n        let VSum;\\n        // check columns and rows\\n        for(let i = 0; i < 3; i++) {\\n            const horizontalSum = this.getHorizontalSum(y + i, x);\\n            if(!HSum) {\\n                HSum = horizontalSum;\\n            } else if(HSum !== horizontalSum) {\\n                return false;\\n            }\\n            const verticalSum = this.getVerticalSum(y, x + i);\\n            if(!VSum) {\\n                if(verticalSum !== HSum) {\\n                    return false;\\n                }\\n                VSum = verticalSum;\\n            } else if(VSum !== verticalSum) {\\n                return false;\\n            }\\n        }\\n        //check for numbers 1-9 each being present in the square\\n        if(!this.enumerator.complete) {\\n            return false;\\n        }\\n        //check diagonals from left to right and right to left\\n        if(\\n            !this.isDiagonalRightSumValid(y, x) ||\\n            !this.isDiagonalLeftSumValid(y, x + 2)\\n        ) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    // sums for grid[y][x] through grid[y][x + 2]\\n    // Also - memoize cell values while traversing rows\\n    // to validate against later\\n    getHorizontalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            const cur = this.grid[y][x + i];\\n            this.enumerator.insert(cur);\\n            sum += cur;\\n        }\\n        return sum;\\n    }\\n    //sums for grid[y][x] through grid[y + 2][x]\\n    getVerticalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            sum += this.grid[y + i][x];\\n        }\\n        return sum;\\n    }\\n    // sum from top left to bottom right assuming 5 is the middle cell\\n    isDiagonalRightSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x + 2] === 10;\\n    }\\n    // sum from top right to bottom left assuming 5 is the middle cell\\n    isDiagonalLeftSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x - 2] === 10;\\n    }\\n}\\n\\nvar numMagicSquaresInside = function(grid) {\\n    return new Solution(grid).total;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\n// An enumerator class that allows for O(1)\\n// insertions and checks for completion (all numbers being present)\\nclass Enumerator {\\n    enum = {\\n        1: true,\\n        2: true,\\n        3: true,\\n        4: true,\\n        5: true,\\n        6: true,\\n        7: true,\\n        8: true,\\n        9: true\\n    }\\n    set = new Set();\\n\\n    isValid(item) {\\n        return item in this.enum;\\n    }\\n    insert(item) {\\n        if(this.isValid(item)) {\\n            this.set.add(item);\\n        }\\n    }\\n    get complete() {\\n        return this.set.size === 9;\\n    }\\n}\\n\\nclass Solution {\\n    constructor(grid) {\\n        this.total = 0;\\n        this.grid = grid;\\n        // cache the max indices that can serve as the top\\n        // left cell of a square and use them as outer\\n        // bounds for the initial loop\\n        this.maxHIndex = this.grid[0].length - 2;\\n        this.maxVIndex = this.grid.length - 2;\\n        // return early if the grid is too small\\n        if(this.maxHIndex < 0 || this.maxVIndex < 0) {\\n            return;\\n        }\\n        this.enumerator = new Enumerator();\\n        this.execute();\\n    }\\n    execute() {\\n        for(let i = 0; i < this.maxVIndex; i++) {\\n            for(let j = 0; j < this.maxHIndex; j++) {\\n                // search from a valid top-left position\\n                this.search(i, j);\\n                this.enumerator = new Enumerator();\\n            }\\n        }\\n    }\\n    search(y, x) {  \\n        // the middle cell must be a 5 to be a \"magic square\"\\n        if(this.grid[y + 1][x + 1] !== 5) {\\n            return false;\\n        }\\n        this.enumerator.insert(5);\\n        const topLeft = this.grid[y][x];\\n        // make sure your starting point is within the range 1-9\\n        if(!this.enumerator.isValid(topLeft)) {\\n            return;\\n        }\\n        // validate the square\\n        if(this.validate(y, x)) {\\n            this.total++;\\n        }\\n    }\\n    validate(y, x) {\\n        let HSum;\\n        let VSum;\\n        // check columns and rows\\n        for(let i = 0; i < 3; i++) {\\n            const horizontalSum = this.getHorizontalSum(y + i, x);\\n            if(!HSum) {\\n                HSum = horizontalSum;\\n            } else if(HSum !== horizontalSum) {\\n                return false;\\n            }\\n            const verticalSum = this.getVerticalSum(y, x + i);\\n            if(!VSum) {\\n                if(verticalSum !== HSum) {\\n                    return false;\\n                }\\n                VSum = verticalSum;\\n            } else if(VSum !== verticalSum) {\\n                return false;\\n            }\\n        }\\n        //check for numbers 1-9 each being present in the square\\n        if(!this.enumerator.complete) {\\n            return false;\\n        }\\n        //check diagonals from left to right and right to left\\n        if(\\n            !this.isDiagonalRightSumValid(y, x) ||\\n            !this.isDiagonalLeftSumValid(y, x + 2)\\n        ) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    // sums for grid[y][x] through grid[y][x + 2]\\n    // Also - memoize cell values while traversing rows\\n    // to validate against later\\n    getHorizontalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            const cur = this.grid[y][x + i];\\n            this.enumerator.insert(cur);\\n            sum += cur;\\n        }\\n        return sum;\\n    }\\n    //sums for grid[y][x] through grid[y + 2][x]\\n    getVerticalSum(y, x) {\\n        let sum = 0;\\n        for(let i = 0; i < 3; i++) {\\n            sum += this.grid[y + i][x];\\n        }\\n        return sum;\\n    }\\n    // sum from top left to bottom right assuming 5 is the middle cell\\n    isDiagonalRightSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x + 2] === 10;\\n    }\\n    // sum from top right to bottom left assuming 5 is the middle cell\\n    isDiagonalLeftSumValid(y, x) {\\n        return this.grid[y][x] + this.grid[y + 2][x - 2] === 10;\\n    }\\n}\\n\\nvar numMagicSquaresInside = function(grid) {\\n    return new Solution(grid).total;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537746,
                "title": "c-faster-than-100",
                "content": "\\n\\n\\n```\\nclass Solution {\\nprivate:    \\n    bool isMagicSquare(vector<vector<int>>& grid, int x, int y) {\\n        //! num in 3*3 grid should be 1 ~ 9\\n        map<int, int> dup;\\n        for(int i = x; i < x + 3; i ++) {\\n            for (int j = y; j < y + 3; j ++) {\\n                if(grid[i][j] < 1 || grid[i][j] > 9) {\\n                    return false;\\n                }\\n                else {\\n                    if(dup.count(grid[i][j]) > 0) {\\n                        return false;\\n                    }\\n                    else {\\n                        dup[grid[i][j]] = 3 * i + j;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //! 3 row\\n        int sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];\\n        if(sum != grid[x+1][y] + grid[x+1][y+1] + grid[x+1][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2])\\n            return false;\\n        //! 3 column\\n        if(sum != grid[x][y] + grid[x+1][y] + grid[x+2][y])\\n            return false;\\n        if(sum != grid[x][y+1] + grid[x+1][y+1] + grid[x+2][y+1])\\n            return false;\\n        if(sum != grid[x][y+2] + grid[x+1][y+2] + grid[x+2][y+2])\\n            return false;\\n        //! two disgonals\\n        if(sum != grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+1][y+1] + grid[x][y+2])\\n            return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int iCount = 0;\\n        \\n        for (int x = 1; x < m - 1; x ++) {\\n            for (int y = 1; y < n - 1; y ++) {\\n                if(grid[x][y] == 5) {\\n                    if(isMagicSquare(grid, x-1, y-1))\\n                        iCount ++;\\n                }\\n            }\\n        }\\n        \\n        return iCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:    \\n    bool isMagicSquare(vector<vector<int>>& grid, int x, int y) {\\n        //! num in 3*3 grid should be 1 ~ 9\\n        map<int, int> dup;\\n        for(int i = x; i < x + 3; i ++) {\\n            for (int j = y; j < y + 3; j ++) {\\n                if(grid[i][j] < 1 || grid[i][j] > 9) {\\n                    return false;\\n                }\\n                else {\\n                    if(dup.count(grid[i][j]) > 0) {\\n                        return false;\\n                    }\\n                    else {\\n                        dup[grid[i][j]] = 3 * i + j;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //! 3 row\\n        int sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];\\n        if(sum != grid[x+1][y] + grid[x+1][y+1] + grid[x+1][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+2][y+1] + grid[x+2][y+2])\\n            return false;\\n        //! 3 column\\n        if(sum != grid[x][y] + grid[x+1][y] + grid[x+2][y])\\n            return false;\\n        if(sum != grid[x][y+1] + grid[x+1][y+1] + grid[x+2][y+1])\\n            return false;\\n        if(sum != grid[x][y+2] + grid[x+1][y+2] + grid[x+2][y+2])\\n            return false;\\n        //! two disgonals\\n        if(sum != grid[x][y] + grid[x+1][y+1] + grid[x+2][y+2])\\n            return false;\\n        if(sum != grid[x+2][y] + grid[x+1][y+1] + grid[x][y+2])\\n            return false;\\n        \\n        return true;\\n    }\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int iCount = 0;\\n        \\n        for (int x = 1; x < m - 1; x ++) {\\n            for (int y = 1; y < n - 1; y ++) {\\n                if(grid[x][y] == 5) {\\n                    if(isMagicSquare(grid, x-1, y-1))\\n                        iCount ++;\\n                }\\n            }\\n        }\\n        \\n        return iCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532829,
                "title": "fast-extremely-clear-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isUnique(vector<vector<int>>&grid, int u, int v)\\n    {\\n        int hash[10]={0};\\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            for(int j=v;j<grid[0].size() && j<3+v;j++)\\n            {\\n                if(grid[i][j]>9) return false;\\n                hash[grid[i][j]]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<10;i++)\\n        {\\n            if(hash[i]!=1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int digSum(vector<vector<int>>&grid,int u,int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v+1]+grid[u+2][v+2]);\\n    }\\n    \\n    int rowSum(vector<vector<int>>&grid, int u,int v)\\n    {\\n        return (grid[u][v]+grid[u][v+1]+grid[u][v+2]);\\n    }\\n    \\n    int colSum(vector<vector<int>>&grid, int u , int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v]+grid[u+2][v]);\\n    }\\n    \\n    \\n    bool sumCheck(vector<vector<int>>&grid,int u,int v)\\n    {\\n        int dS = digSum(grid,u,v);\\n        for(int i=v;i<3+v && i<grid[0].size();i++)\\n        {\\n            if(colSum(grid,u,i)!=dS) return false;\\n        }\\n        \\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            if(rowSum(grid,i,v)!=dS) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size(),ans=0;\\n        if(m<3 || n<3) return 0;\\n        \\n        for(int i=0;i+2<n;i++)\\n        {\\n            for(int j=0;j+2<m;j++)\\n            {\\n                if(isUnique(grid,i,j) &&sumCheck(grid,i,j))\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isUnique(vector<vector<int>>&grid, int u, int v)\\n    {\\n        int hash[10]={0};\\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            for(int j=v;j<grid[0].size() && j<3+v;j++)\\n            {\\n                if(grid[i][j]>9) return false;\\n                hash[grid[i][j]]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<10;i++)\\n        {\\n            if(hash[i]!=1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int digSum(vector<vector<int>>&grid,int u,int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v+1]+grid[u+2][v+2]);\\n    }\\n    \\n    int rowSum(vector<vector<int>>&grid, int u,int v)\\n    {\\n        return (grid[u][v]+grid[u][v+1]+grid[u][v+2]);\\n    }\\n    \\n    int colSum(vector<vector<int>>&grid, int u , int v)\\n    {\\n        return (grid[u][v]+grid[u+1][v]+grid[u+2][v]);\\n    }\\n    \\n    \\n    bool sumCheck(vector<vector<int>>&grid,int u,int v)\\n    {\\n        int dS = digSum(grid,u,v);\\n        for(int i=v;i<3+v && i<grid[0].size();i++)\\n        {\\n            if(colSum(grid,u,i)!=dS) return false;\\n        }\\n        \\n        for(int i=u;i<3+u && i<grid.size();i++)\\n        {\\n            if(rowSum(grid,i,v)!=dS) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size(),ans=0;\\n        if(m<3 || n<3) return 0;\\n        \\n        for(int i=0;i+2<n;i++)\\n        {\\n            for(int j=0;j+2<m;j++)\\n            {\\n                if(isUnique(grid,i,j) &&sumCheck(grid,i,j))\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504747,
                "title": "intuitive-simulate",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>> g;\\n    \\n    int res = 0;\\n    \\n    void process(int r, int c) {\\n        vector<int> rowv(3, 0);\\n        vector<int> colv(3, 0);\\n        int diag = 0;\\n        int rdiag = 0;\\n        \\n        vector<bool> vis(10, false);\\n        \\n        for (int i = r; i < r + 3; i++) {\\n            for (int j = c; j < c + 3; j++) {\\n                \\n                vis[g[i][j]] = true;\\n                \\n                rowv[i - r] += g[i][j];\\n                colv[j - c] += g[i][j];\\n                if (i - r == j - c)\\n                    diag += g[i][j];\\n                if (i - r == 2 - (j - c))\\n                    rdiag += g[i][j];\\n            }\\n        }\\n        \\n        for (int i = 1; i < 10; i++) {\\n            if (!vis[i])\\n                return ;\\n        }\\n        \\n        int tmp = diag;\\n        \\n        if (diag != rdiag)\\n            return ;\\n        \\n        for (auto x : rowv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        for (auto x : colv) {\\n            if (tmp != x)\\n                return ;\\n        }\\n        res++;\\n    }\\n    \\n    void init(vector<vector<int>>& grid) {\\n        g = grid;\\n        rows = g.size();\\n        cols = g[0].size();\\n        for (int i = 0; i <= rows - 3; i++) {\\n            for (int j = 0; j <= cols - 3; j++) {\\n                process(i, j);\\n            }\\n        }\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        init(grid);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435412,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    bool magic(int a,int b,int c,int d,int e,int f,int g,int h,int i){\\n        \\n        set<int>s1={a,b,c,d,e,f,g,h,i};\\n        set<int>s2={1,2,3,4,5,6,7,8,9};\\n        \\n        if(s1==s2 && (a+b+c)==15 && (d+e+f)==15 && (g+h+i)==15 && (a+d+g)==15 && (b+e+h)==15 && (c+f+i)==15 && (a+e+i)==15 && (c+e+g)==15 && e==5 ){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(m<3 || n<3){\\n            return 0;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<m-2;i++){\\n            for(int j=0;j<n-2;j++){\\n                \\n              \\n                \\n                if(magic(grid[i][j],grid[i][j+1],grid[i][j+2],grid[i+1][j],grid[i+1][j+1],grid[i+1][j+2],grid[i+2][j],grid[i+2][j+1],grid[i+2][j+2])){\\n                    ans+=1;\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool magic(int a,int b,int c,int d,int e,int f,int g,int h,int i){\\n        \\n        set<int>s1={a,b,c,d,e,f,g,h,i}",
                "codeTag": "Java"
            },
            {
                "id": 1430066,
                "title": "c-brute-force",
                "content": "**The idea is to iterate over each 3*3 matrix in grid and check the given condition**\\n```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n      \\n        int r=grid.size();\\n        int c=grid[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<=r-3;i++){\\n            \\n            for(int j=0;j<=c-3;j++){\\n            \\n               bool b=1;\\n                int arr[10]={};\\n                \\n                for(int rr=i;rr<i+3;rr++){\\n                    for(int cc=j;cc<j+3;cc++){\\n                        if(grid[rr][cc]>9 or grid[rr][cc]<1){\\n                            b=0;\\n                            break;\\n                        }\\n                        else\\n                            {\\n                                if(arr[grid[rr][cc]]==0)\\n                                    arr[grid[rr][cc]]=1;\\n                                else{\\n                                    b=0;break;\\n                                }\\n                             }\\n                    }\\n                    if(!b) break;\\n                }\\n                if(b){\\n                    bool bb=1;\\n                    int prev=INT_MIN;\\n                    for(int rr=i;rr<i+3;rr++){\\n                        int sm=grid[rr][j]+grid[rr][j+1]+grid[rr][j+2];\\n                        if(prev==INT_MIN) prev=sm;\\n                        else if(prev!=sm){\\n                            bb=0;\\n                            goto last;\\n                        }\\n                    }\\n                    \\n                    for(int cc=j;cc<j+3;cc++){\\n                        int sm=grid[i][cc]+grid[i+1][cc]+grid[i+2][cc];\\n                        if(prev!=sm){\\n                            bb=0;goto last;\\n                        }\\n                    }\\n                    if(grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]!=prev)\\n                        bb=0;\\n                    if(grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]!=prev)\\n                        bb=0;\\n                    last:\\n                    if(bb)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n      \\n        int r=grid.size();\\n        int c=grid[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<=r-3;i++){\\n            \\n            for(int j=0;j<=c-3;j++){\\n            \\n               bool b=1;\\n                int arr[10]={};\\n                \\n                for(int rr=i;rr<i+3;rr++){\\n                    for(int cc=j;cc<j+3;cc++){\\n                        if(grid[rr][cc]>9 or grid[rr][cc]<1){\\n                            b=0;\\n                            break;\\n                        }\\n                        else\\n                            {\\n                                if(arr[grid[rr][cc]]==0)\\n                                    arr[grid[rr][cc]]=1;\\n                                else{\\n                                    b=0;break;\\n                                }\\n                             }\\n                    }\\n                    if(!b) break;\\n                }\\n                if(b){\\n                    bool bb=1;\\n                    int prev=INT_MIN;\\n                    for(int rr=i;rr<i+3;rr++){\\n                        int sm=grid[rr][j]+grid[rr][j+1]+grid[rr][j+2];\\n                        if(prev==INT_MIN) prev=sm;\\n                        else if(prev!=sm){\\n                            bb=0;\\n                            goto last;\\n                        }\\n                    }\\n                    \\n                    for(int cc=j;cc<j+3;cc++){\\n                        int sm=grid[i][cc]+grid[i+1][cc]+grid[i+2][cc];\\n                        if(prev!=sm){\\n                            bb=0;goto last;\\n                        }\\n                    }\\n                    if(grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]!=prev)\\n                        bb=0;\\n                    if(grid[i][j+2]+grid[i+1][j+1]+grid[i+2][j]!=prev)\\n                        bb=0;\\n                    last:\\n                    if(bb)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419104,
                "title": "straightforward-98-speed",
                "content": "![image](https://assets.leetcode.com/users/images/5975e6c4-d95f-446a-bbf7-67aaeb6672ad_1629618715.8212204.png)\\n```\\nclass Solution:\\n\\n    digits = {1, 2, 3, 4, 5, 6, 7, 8, 9}\\n\\n    @classmethod\\n    def magic_3_3(cls, square: List[List[int]]) -> bool:\\n        if set(sum(square, [])) != Solution.digits:\\n            return False\\n        sum_row0 = sum(square[0])\\n        for r in range(1, 3):\\n            if sum(square[r]) != sum_row0:\\n                return False\\n        if any(sum(col) != sum_row0 for col in zip(*square)):\\n            return False\\n        sum_main_diagonal = sum_second_diagonal = 0\\n        for i in range(3):\\n            sum_main_diagonal += square[i][i]\\n            sum_second_diagonal += square[i][2 - i]\\n        return sum_main_diagonal == sum_second_diagonal == sum_row0\\n\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows - 2):\\n            for c in range(cols - 2):\\n                if Solution.magic_3_3([grid[row_idx][c: c + 3]\\n                                       for row_idx in range(r, r + 3)]):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    digits = {1, 2, 3, 4, 5, 6, 7, 8, 9}\\n\\n    @classmethod\\n    def magic_3_3(cls, square: List[List[int]]) -> bool:\\n        if set(sum(square, [])) != Solution.digits:\\n            return False\\n        sum_row0 = sum(square[0])\\n        for r in range(1, 3):\\n            if sum(square[r]) != sum_row0:\\n                return False\\n        if any(sum(col) != sum_row0 for col in zip(*square)):\\n            return False\\n        sum_main_diagonal = sum_second_diagonal = 0\\n        for i in range(3):\\n            sum_main_diagonal += square[i][i]\\n            sum_second_diagonal += square[i][2 - i]\\n        return sum_main_diagonal == sum_second_diagonal == sum_row0\\n\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        count = 0\\n        rows, cols = len(grid), len(grid[0])\\n        for r in range(rows - 2):\\n            for c in range(cols - 2):\\n                if Solution.magic_3_3([grid[row_idx][c: c + 3]\\n                                       for row_idx in range(r, r + 3)]):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393313,
                "title": "100-00-than-all-c-online-submission-so-far",
                "content": "```\\n public int NumMagicSquaresInside(int[][] grid) {\\n        int numberOfMagicSqaures = 0;\\n        if(grid.Length < 3 && grid[0].Length < 3)\\n            return numberOfMagicSqaures;        \\n        \\n        for(int i = 0;i < grid.Length; i++)\\n        {\\n             for(int j = 0; j < grid[i].Length; j++)\\n             {\\n                 if(i + 2 < grid.Length && j + 2 < grid[i].Length && CountMagic(grid, i, j))\\n                 {\\n                     numberOfMagicSqaures++;\\n                 }\\n             }\\n        }\\n        \\n        return numberOfMagicSqaures;\\n    }\\n    \\n    private bool CountMagic(int[][] grid, int i, int j)\\n    {  \\n        bool[] distinctDigits = new bool[10];\\n        for(int k=i;k <= i+2; k++)\\n        {\\n            for(int l=j;l <= j+2; l++)\\n            {\\n                if(grid[k][l] < 1 || grid[k][l] > 9)\\n                    return false;\\n                \\n                if(distinctDigits[grid[k][l]])\\n                    return false;\\n                else\\n                    distinctDigits[grid[k][l]] = true;\\n            }\\n        }        \\n        \\n        // Rows\\n        if( grid[i][j] + grid[i][j+1] + grid[i][j+2] != 15 || grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2] != 15 ||\\n          grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] != 15)\\n            return false;\\n        \\n        // Columns\\n        if(grid[i][j] + grid[i+1][j] + grid[i+2][j] != 15 || grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1] != 15 ||\\n          grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2] != 15)\\n            return false;\\n          \\n         // Diagonals \\n        if(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] != 15 || grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int NumMagicSquaresInside(int[][] grid) {\\n        int numberOfMagicSqaures = 0;\\n        if(grid.Length < 3 && grid[0].Length < 3)\\n            return numberOfMagicSqaures;        \\n        \\n        for(int i = 0;i < grid.Length; i++)\\n        {\\n             for(int j = 0; j < grid[i].Length; j++)\\n             {\\n                 if(i + 2 < grid.Length && j + 2 < grid[i].Length && CountMagic(grid, i, j))\\n                 {\\n                     numberOfMagicSqaures++;\\n                 }\\n             }\\n        }\\n        \\n        return numberOfMagicSqaures;\\n    }\\n    \\n    private bool CountMagic(int[][] grid, int i, int j)\\n    {  \\n        bool[] distinctDigits = new bool[10];\\n        for(int k=i;k <= i+2; k++)\\n        {\\n            for(int l=j;l <= j+2; l++)\\n            {\\n                if(grid[k][l] < 1 || grid[k][l] > 9)\\n                    return false;\\n                \\n                if(distinctDigits[grid[k][l]])\\n                    return false;\\n                else\\n                    distinctDigits[grid[k][l]] = true;\\n            }\\n        }        \\n        \\n        // Rows\\n        if( grid[i][j] + grid[i][j+1] + grid[i][j+2] != 15 || grid[i+1][j] + grid[i+1][j+1] + grid[i+1][j+2] != 15 ||\\n          grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] != 15)\\n            return false;\\n        \\n        // Columns\\n        if(grid[i][j] + grid[i+1][j] + grid[i+2][j] != 15 || grid[i][j+1] + grid[i+1][j+1] + grid[i+2][j+1] != 15 ||\\n          grid[i][j+2] + grid[i+1][j+2] + grid[i+2][j+2] != 15)\\n            return false;\\n          \\n         // Diagonals \\n        if(grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] != 15 || grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2] != 15)\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384638,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n           int ans = 0; \\n         unordered_map<int , int >mp; \\n        for(int i = 0;i+3<=grid.size();i++)\\n        { \\n             for(int j = 0; j+3 <= grid[0].size(); j++)\\n             {  \\n                 int ok = 0; \\n                 int sum = 0; \\n                  for(int k = i; k<i+3; k++)\\n                  {  sum = 0; \\n                     for(int l =j ; l<j+3; l++)\\n                     {  mp[grid[k][l]]++;\\n                        sum += grid[k][l] ; \\n                     }\\n                   if(sum == 15)ok++; \\n                  } \\n                   for(int k = j; k<j+3; k++)\\n                  {  sum = 0; \\n                     for(int l =i ; l<i+3; l++)\\n                     { mp[grid[l][k]]++;\\n                        sum += grid[l][k] ; \\n                     }\\n                   if(sum == 15) ok++; \\n             }\\n              if(grid[i+1][j+1] == 5) ok++; \\n                 int mx = 0; \\n                 for(auto a : mp){mx = max(mx , a.first); }\\n              if(ok == 7 && mp.size()==9 && mx==9) ans++; \\n                 mp.clear(); \\n        } \\n        }\\n        \\n        return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n           int ans = 0; \\n         unordered_map<int , int >mp; \\n        for(int i = 0;i+3<=grid.size();i++)\\n        { \\n             for(int j = 0; j+3 <= grid[0].size(); j++)\\n             {  \\n                 int ok = 0; \\n                 int sum = 0; \\n                  for(int k = i; k<i+3; k++)\\n                  {  sum = 0; \\n                     for(int l =j ; l<j+3; l++)\\n                     {  mp[grid[k][l]]++;\\n                        sum += grid[k][l] ; \\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 1306651,
                "title": "javascript-easy-to-understand-solution-81-100",
                "content": "Runtime: 76 ms, faster than 81.82% of JavaScript online submissions for Magic Squares In Grid.\\nMemory Usage: 38.8 MB, less than 100.00% of JavaScript online submissions for Magic Squares In Grid.\\n```\\nvar numMagicSquaresInside = function(grid) {\\n    let res = 0;\\n    for(let i = 0; i < grid.length - 2; i++){\\n       for(let j = 0; j < grid[0].length - 2; j++){\\n\\t       //only check 4\\n           if(grid[i][j]+grid[i][j+1]+grid[i][j+2]==15\\n           && grid[i][j]+grid[i+1][j]+grid[i+2][j]==15\\n           && grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15\\n           && grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15){\\n               let set = new Set();\\n           for(let a = i; a<=i+2; a++){\\n              for(let b = j; b<=j+2; b++){ \\n                  if(grid[a][b]>=1&&grid[a][b]<=9) set.add(grid[a][b]);                \\n           }}\\n           if(set.size===9) res++;      \\n       }}}\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numMagicSquaresInside = function(grid) {\\n    let res = 0;\\n    for(let i = 0; i < grid.length - 2; i++){\\n       for(let j = 0; j < grid[0].length - 2; j++){\\n\\t       //only check 4\\n           if(grid[i][j]+grid[i][j+1]+grid[i][j+2]==15\\n           && grid[i][j]+grid[i+1][j]+grid[i+2][j]==15\\n           && grid[i][j]+grid[i+1][j+1]+grid[i+2][j+2]==15\\n           && grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]==15){\\n               let set = new Set();\\n           for(let a = i; a<=i+2; a++){\\n              for(let b = j; b<=j+2; b++){ \\n                  if(grid[a][b]>=1&&grid[a][b]<=9) set.add(grid[a][b]);                \\n           }}\\n           if(set.size===9) res++;      \\n       }}}\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305588,
                "title": "java-brute-approach",
                "content": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int a[][]=new int[3][3];\\n        if(n<3 || m<3)\\n            return 0;\\n        else\\n            {\\n            int count=0;\\n            int r=0;\\n            while(r+2<n)\\n            {\\n            \\n            for(int i=0;i+2<m;i++)\\n            {\\n                if(check(matrix(grid,r+2,i,i+2)))\\n                   count++;\\n                \\n            }\\n            r++;\\n            }\\n            return count;\\n            \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n    private int[][] matrix(int grid[][],int row,int start,int end)\\n    {\\n        int a[][]=new int[3][3];\\n        \\n        for(int i=row-2;i<=row;i++)\\n        {\\n            for(int j=start;j<=end;j++)\\n            {\\n                a[i-row+2][j-start]=grid[i][j];\\n            }\\n            \\n        }\\n        return a;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public boolean check(int[][] a)\\n    {\\n      \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            set.add(i);\\n        }\\n        int sum=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            sum=sum+a[0][i];\\n            \\n        }\\n        for(int i=0;i<3;i++)\\n        {   int tsum=0;\\n            for(int j=0;j<3;j++)\\n            {\\n            tsum=tsum+a[i][j];\\n            if(!set.remove(a[i][j]))\\n                return false;\\n            \\n            }\\n            if(tsum!=sum)\\n                return false;\\n        }\\n        for(int i=0;i<3;i++)\\n        {int sum2=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                sum2=sum2+a[j][i];\\n            }\\n         if(sum2!=sum)\\n             return false;\\n        }\\n        if(a[0][0]+a[1][1]+a[2][2]==sum && a[0][2]+a[1][1]+a[2][0]==sum && set.isEmpty())\\n            return true;\\n        else \\n            return false;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numMagicSquaresInside(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int a[][]=new int[3][3];\\n        if(n<3 || m<3)\\n            return 0;\\n        else\\n            {\\n            int count=0;\\n            int r=0;\\n            while(r+2<n)\\n            {\\n            \\n            for(int i=0;i+2<m;i++)\\n            {\\n                if(check(matrix(grid,r+2,i,i+2)))\\n                   count++;\\n                \\n            }\\n            r++;\\n            }\\n            return count;\\n            \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n    private int[][] matrix(int grid[][],int row,int start,int end)\\n    {\\n        int a[][]=new int[3][3];\\n        \\n        for(int i=row-2;i<=row;i++)\\n        {\\n            for(int j=start;j<=end;j++)\\n            {\\n                a[i-row+2][j-start]=grid[i][j];\\n            }\\n            \\n        }\\n        return a;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public boolean check(int[][] a)\\n    {\\n      \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            set.add(i);\\n        }\\n        int sum=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            sum=sum+a[0][i];\\n            \\n        }\\n        for(int i=0;i<3;i++)\\n        {   int tsum=0;\\n            for(int j=0;j<3;j++)\\n            {\\n            tsum=tsum+a[i][j];\\n            if(!set.remove(a[i][j]))\\n                return false;\\n            \\n            }\\n            if(tsum!=sum)\\n                return false;\\n        }\\n        for(int i=0;i<3;i++)\\n        {int sum2=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                sum2=sum2+a[j][i];\\n            }\\n         if(sum2!=sum)\\n             return false;\\n        }\\n        if(a[0][0]+a[1][1]+a[2][2]==sum && a[0][2]+a[1][1]+a[2][0]==sum && set.isEmpty())\\n            return true;\\n        else \\n            return false;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303628,
                "title": "javascript-solution-brute-force",
                "content": "```\\nvar numMagicSquaresInside = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n            const sums = new Array(8).fill(0); // (1)\\n            const set = new Set();\\n            \\n            let isMagical = true;\\n\\n            for (let k = 0; k < 3; k++) { // row direction\\n                for (let l = 0; l < 3; l++) { // col direction\\n\\n                    const num = grid[i + k][j + l];\\n\\n                    if (num === 0 || num > 9 || set.has(num)) { // (2)\\n                        isMagical = false;\\n                        break;\\n                    }\\n\\n                    set.add(num);\\n\\n                    sums[k] += num;\\n                    sums[3 + l] += num;\\n\\n                    if (k === l) sums[6] += num; // left diagonal\\n                    if (k + l === 2) sums[7] += num; // right diagonal\\n                }\\n            } \\n    \\n            if (!isMagical) continue;\\n\\n            let areSame = true; // Boolean to check if all the sums are the same\\n            \\n            for (let i = 1; i < 8; i++) {\\n                if (sums[i] != sums[i - 1]) {\\n                    areSame = false;\\n                    break;\\n                }\\n            }\\n\\n            count += areSame;\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n/**\\nAdditional Notes:\\n1. The first 3 element maintains sum for the 3 rows, the next 3 elements maintain the sum for the columns, \\n\\tand the last two element maintains the sum for the left and right diagonals.\\n\\t\\n2. If the num is out of range of 1 to 9 or if we seen the number already before, we mark the current \\n\\t3x3 square as non magical and break\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numMagicSquaresInside = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < m - 2; i++) {\\n        for (let j = 0; j < n - 2; j++) {\\n            const sums = new Array(8).fill(0); // (1)\\n            const set = new Set();\\n            \\n            let isMagical = true;\\n\\n            for (let k = 0; k < 3; k++) { // row direction\\n                for (let l = 0; l < 3; l++) { // col direction\\n\\n                    const num = grid[i + k][j + l];\\n\\n                    if (num === 0 || num > 9 || set.has(num)) { // (2)\\n                        isMagical = false;\\n                        break;\\n                    }\\n\\n                    set.add(num);\\n\\n                    sums[k] += num;\\n                    sums[3 + l] += num;\\n\\n                    if (k === l) sums[6] += num; // left diagonal\\n                    if (k + l === 2) sums[7] += num; // right diagonal\\n                }\\n            } \\n    \\n            if (!isMagical) continue;\\n\\n            let areSame = true; // Boolean to check if all the sums are the same\\n            \\n            for (let i = 1; i < 8; i++) {\\n                if (sums[i] != sums[i - 1]) {\\n                    areSame = false;\\n                    break;\\n                }\\n            }\\n\\n            count += areSame;\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n/**\\nAdditional Notes:\\n1. The first 3 element maintains sum for the 3 rows, the next 3 elements maintain the sum for the columns, \\n\\tand the last two element maintains the sum for the left and right diagonals.\\n\\t\\n2. If the num is out of range of 1 to 9 or if we seen the number already before, we mark the current \\n\\t3x3 square as non magical and break\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283640,
                "title": "python-o-n-2-brute-force",
                "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def isMagic(i,j):\\n            total = 0\\n            count = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]\\n            distinctDic = collections.defaultdict(int)\\n            #check rows and cols\\n            for r in range(3):\\n                distinctDic[grid[i+r][j]]+=1\\n                distinctDic[grid[i+r][j+1]]+=1\\n                distinctDic[grid[i+r][j+2]]+=1\\n                \\n                \\n                row = grid[i+r][j] + grid[i+r][j+1] + grid[i+r][2+j]\\n                col = grid[i][r+j] + grid[1+i][r+j] + grid[2+i][r+j]\\n                if row != col or row != count:\\n                    return 0\\n             # checks if all numbers are distinct\\n            for num in range(1,10):\\n                if distinctDic[num] == 0:\\n                    return 0\\n                    \\n            return 1 if count == grid[i][2+j] + grid[1+i][1+j] + grid[2+i][j] else 0\\n            \\n        \\n            \\n        r = len(grid)\\n        c = len(grid[0])\\n        \\n        ret = 0\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                ret+=isMagic(i,j)\\n        return ret\\n                \\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        def isMagic(i,j):\\n            total = 0\\n            count = grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2]\\n            distinctDic = collections.defaultdict(int)\\n            #check rows and cols\\n            for r in range(3):\\n                distinctDic[grid[i+r][j]]+=1\\n                distinctDic[grid[i+r][j+1]]+=1\\n                distinctDic[grid[i+r][j+2]]+=1\\n                \\n                \\n                row = grid[i+r][j] + grid[i+r][j+1] + grid[i+r][2+j]\\n                col = grid[i][r+j] + grid[1+i][r+j] + grid[2+i][r+j]\\n                if row != col or row != count:\\n                    return 0\\n             # checks if all numbers are distinct\\n            for num in range(1,10):\\n                if distinctDic[num] == 0:\\n                    return 0\\n                    \\n            return 1 if count == grid[i][2+j] + grid[1+i][1+j] + grid[2+i][j] else 0\\n            \\n        \\n            \\n        r = len(grid)\\n        c = len(grid[0])\\n        \\n        ret = 0\\n        for i in range(r-2):\\n            for j in range(c-2):\\n                ret+=isMagic(i,j)\\n        return ret\\n                \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270304,
                "title": "c-brute-force-o-n-m-important-test-cases",
                "content": "Different test cases:\\n**[[4,3,8,4],[9,5,1,9],[2,7,6,2]]\\n[[10,3,5],[1,6,11],[7,9,2]]\\n[[8]]\\n[[4,4],[4,4]]\\n[[4,3,8],[9,5,1],[2,7,6]]\\n[[7,0,5],[2,4,6],[3,8,1]]\\n[[4,7,8],[9,5,1],[2,3,6]]\\n[[4,3,8],[9,5,1],[2,7,6]]**\\n\\n**OUTPUT:\\n1\\n0\\n0\\n0\\n1\\n0\\n0\\n1**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMagicSquare(vector<vector<int>> &grid, int a, int b, int c, int d) {\\n        --a; --b; --c; --d;\\n        int magicSum = 0;\\n        vector<bool> distinct(9, true);\\n        for (int i = b; i <= d; i++) {\\n            if(distinct[grid[a][i]] == false or grid[a][i] <= 0 or grid[a][i] > 9)\\n                return false;\\n            magicSum += grid[a][i];\\n            distinct[grid[a][i]] = false;\\n        }\\n\\n        // for every row in matrix\\n        for (int i = a + 1; i <= c; i++) {\\n            int rowSum = 0;\\n            for (int j = b; j <= d; j++) {\\n                if(distinct[grid[i][j]] == false or grid[i][j] <= 0 or grid[i][j] > 9)\\n                    return false;\\n                rowSum += grid[i][j];\\n                distinct[grid[i][j]] = false;\\n            }\\n            if (magicSum != rowSum)\\n                return false;\\n        }\\n\\n        // for every column in matrix\\n        for (int j = b; j <= d; j++) {\\n            int colSum = 0;\\n            for (int i = a; i <= c; i++)   \\n                colSum += grid[i][j];\\n            if (magicSum != colSum)\\n                return false;\\n        }\\n\\n        int diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[a + i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n\\n        diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[c - i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(n < 3 or m < 3)\\n            return 0;\\n        int count = 0;\\n        int k = 3;\\n            for (int i = 1; i + k - 1 <= n; i++)\\n                for (int j = 1; j + k - 1 <= m; j++)\\n                    if (isMagicSquare(grid, i, j, i + k - 1, j + k - 1))  \\n                        count++;\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMagicSquare(vector<vector<int>> &grid, int a, int b, int c, int d) {\\n        --a; --b; --c; --d;\\n        int magicSum = 0;\\n        vector<bool> distinct(9, true);\\n        for (int i = b; i <= d; i++) {\\n            if(distinct[grid[a][i]] == false or grid[a][i] <= 0 or grid[a][i] > 9)\\n                return false;\\n            magicSum += grid[a][i];\\n            distinct[grid[a][i]] = false;\\n        }\\n\\n        // for every row in matrix\\n        for (int i = a + 1; i <= c; i++) {\\n            int rowSum = 0;\\n            for (int j = b; j <= d; j++) {\\n                if(distinct[grid[i][j]] == false or grid[i][j] <= 0 or grid[i][j] > 9)\\n                    return false;\\n                rowSum += grid[i][j];\\n                distinct[grid[i][j]] = false;\\n            }\\n            if (magicSum != rowSum)\\n                return false;\\n        }\\n\\n        // for every column in matrix\\n        for (int j = b; j <= d; j++) {\\n            int colSum = 0;\\n            for (int i = a; i <= c; i++)   \\n                colSum += grid[i][j];\\n            if (magicSum != colSum)\\n                return false;\\n        }\\n\\n        int diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[a + i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n\\n        diagSum = 0;\\n        for (int i = 0; i <= c - a; i++)\\n            diagSum += grid[c - i][b + i];\\n\\n        if (magicSum != diagSum)\\n            return false;\\n        \\n        return true;\\n    }\\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(n < 3 or m < 3)\\n            return 0;\\n        int count = 0;\\n        int k = 3;\\n            for (int i = 1; i + k - 1 <= n; i++)\\n                for (int j = 1; j + k - 1 <= m; j++)\\n                    if (isMagicSquare(grid, i, j, i + k - 1, j + k - 1))  \\n                        count++;\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564901,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1567304,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1573774,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1572779,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1569228,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1757940,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1573136,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            },
            {
                "id": 1744405,
                "content": [
                    {
                        "username": "sweetandbitter",
                        "content": "Problem says it is distinct numbers from 1 to 9, I thought it indicate grid contain only 1 to 9 .\\nWhen I failed in test case [[10, 3, 5], [1, 6. 11], [7, 9, 2]], I got confused and tried more than 10 times.\\n0 <= grid[i][j] <= 15 should move to the start of the problem and highlight instead of put it in note."
                    },
                    {
                        "username": "chensuim",
                        "content": "It\\'s really sad that the leetcode contest has problem for three weeks.\\nThe first week, wrong test case.\\nThe second week, wrong answer for example case.\\nThe third week, inappropriate example.\\nHope leetcode strengthens review of the contest problems."
                    },
                    {
                        "username": "cq960327",
                        "content": "[4,7,8],[9,5,1],[2,3,6]"
                    },
                    {
                        "username": "mearvind",
                        "content": "![image](https://assets.leetcode.com/users/mearvind/image_1561104426.png)\\n\\nY it is not magic square? sum of all row col and digonal coming 18"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "the number must be between 1 and 9\\n"
                    },
                    {
                        "username": "purva9413",
                        "content": "The input [[10,3,5],[1,6,11],[7,9,2]] gives the answer as 0. Shouldn\\'t answer be 1, as all rows columns and diagonals have sum 18?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This should be marked as Easy, it\\'s brute force and implementation based. There is no tirck."
                    },
                    {
                        "username": "learner_bee",
                        "content": "The problem statement says below.\\n\\ngrid filled with distinct numbers from 1 to 9\\npoint 3 in notes: 0 <= grid[i][j] <= 15\\n\\nthose two statements are confusing me. \\n\\nCan someone elaborate?\\n\\nThanks,"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Wrong Testcase :\\n[[9,9,5,1,9,5,5,7,2,5],[9,1,8,3,4,6,7,2,8,9],[4,1,1,5,9,1,5,9,6,4],[5,5,6,7,2,8,3,4,0,6],[1,9,1,8,3,1,4,2,9,4],[2,8,6,4,2,7,3,2,7,6],[9,2,5,0,7,8,2,9,5,1],[2,1,4,4,7,6,2,4,3,8],[1,2,5,3,0,5,10,8,5,2],[6,9,6,8,8,4,3,6,0,9]]\\n\\nCorrect output = 2\\nExpected output = 3\\n\\nA lot of people has confusion in this question due to top and below condition of range. So, simply put it is asking to find number of magic squares possible in given grid which contains distinct numbers from 1 to 9, though grid can contain numbers from 0 to 15. So, the sub matrices which contain numbers except 1-9 are simply rejected."
                    }
                ]
            }
        ]
    }
]